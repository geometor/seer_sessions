{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by moving specific non-zero digits ('movers')\ndiagonally towards the largest contiguous block of identical non-zero digits\n('target block').\n\n1. Identifies the largest contiguous block of a single non-zero digit using\n   orthogonal adjacency (up, down, left, right).\n2. Identifies all other non-zero digits ('movers') that are not part of this\n   target block.\n3. For each mover:\n    a. Determines the diagonal direction towards the target block based on\n       its position relative to the block's bounding box. (e.g., if mover is\n       top-left of the block's bounding box, direction is down-right).\n    b. Traces this diagonal path one step at a time from the mover's starting\n       position.\n    c. Finds the first cell along this path whose coordinates belong to the\n       set of coordinates identified for the target block.\n    d. Replaces the value of the hit target block cell in the output grid\n       with the mover's value.\n    e. Sets the original position of the mover in the output grid to 0.\n4. Returns the modified grid. All cells not affected by the movers (original\n   zeros and remaining target block cells) retain their original values.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# Helper function using Breadth-First Search (BFS) to find a connected component\n# of identical non-zero values based on orthogonal adjacency.\ndef _bfs(grid, start_row, start_col, visited):\n    \"\"\"\n    Performs BFS starting from (start_row, start_col) to find all connected\n    cells with the same non-zero value.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): Starting row index.\n        start_col (int): Starting column index.\n        visited (set): A set of (row, col) tuples already visited.\n\n    Returns:\n        tuple: (component_coords, value)\n               component_coords (set): Set of (row, col) tuples in the component.\n               value (int): The value of the cells in the component. Returns 0 if start is 0.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_row, start_col)])\n    component_coords = set()\n    value = grid[start_row, start_col]\n\n    # Cannot start BFS on a background cell\n    if value == 0:\n        return set(), 0\n\n    # Mark start as visited and add to component\n    visited.add((start_row, start_col))\n    component_coords.add((start_row, start_col))\n\n    while q:\n        r, c = q.popleft()\n        # Check 4 orthogonal neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds, has the same value, and not visited\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               (nr, nc) not in visited and grid[nr, nc] == value:\n                visited.add((nr, nc))\n                component_coords.add((nr, nc))\n                q.append((nr, nc))\n    return component_coords, value\n\n# Helper function to find the largest contiguous block of identical non-zero numbers.\ndef _find_largest_block(grid):\n    \"\"\"\n    Finds the largest connected component of identical non-zero values in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (largest_block_coords, largest_block_value)\n               largest_block_coords (set): Set of (row, col) tuples for the largest block.\n               largest_block_value (int): The value of the cells in the largest block.\n                                          Returns -1 if no non-zero block found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    largest_block_coords = set()\n    largest_block_value = -1 # Indicates no block found yet\n\n    # Iterate through grid to find potential starting points for BFS\n    for r in range(rows):\n        for c in range(cols):\n            # If cell is non-zero and not yet visited, start BFS\n            if grid[r, c] != 0 and (r, c) not in visited:\n                component_coords, value = _bfs(grid, r, c, visited)\n                # Update if this component is larger than the current largest\n                if len(component_coords) > len(largest_block_coords):\n                    largest_block_coords = component_coords\n                    largest_block_value = value\n    return largest_block_coords, largest_block_value\n\n# Helper function to find all non-zero cells that are not part of the target block.\ndef _find_movers(grid, block_coords):\n    \"\"\"\n    Identifies mover cells (non-zero cells not in the target block).\n\n    Args:\n        grid (np.array): The input grid.\n        block_coords (set): Set of (row, col) tuples for the target block.\n\n    Returns:\n        list: A list of dictionaries, each representing a mover:\n              {'value': int, 'r': int, 'c': int}\n    \"\"\"\n    rows, cols = grid.shape\n    movers = []\n    for r in range(rows):\n        for c in range(cols):\n            # Check if cell is non-zero and not part of the identified block\n            if grid[r, c] != 0 and (r, c) not in block_coords:\n                movers.append({'value': grid[r, c], 'r': r, 'c': c})\n    return movers\n\n# Helper function to determine the diagonal move direction for a mover\n# based on its position relative to the target block's bounding box.\ndef _get_move_direction(mover_r, mover_c, block_coords):\n    \"\"\"\n    Calculates the diagonal step (dr, dc) for a mover towards the block.\n\n    Args:\n        mover_r (int): Row index of the mover.\n        mover_c (int): Column index of the mover.\n        block_coords (set): Set of (row, col) tuples for the target block.\n\n    Returns:\n        tuple: (dr, dc) representing the change in row and column for one step.\n               Returns (0, 0) if block is empty or direction cannot be determined.\n    \"\"\"\n    if not block_coords:\n        return 0, 0 # No block, no move\n\n    # Find bounding box of the target block\n    min_r = min(r for r, c in block_coords)\n    max_r = max(r for r, c in block_coords)\n    min_c = min(c for r, c in block_coords)\n    max_c = max(c for r, c in block_coords)\n\n    dr = 0\n    dc = 0\n\n    # Determine vertical component of direction\n    if mover_r < min_r:\n        dr = 1 # Move down\n    elif mover_r > max_r:\n        dr = -1 # Move up\n\n    # Determine horizontal component of direction\n    if mover_c < min_c:\n        dc = 1 # Move right\n    elif mover_c > max_c:\n        dc = -1 # Move left\n\n    # This logic assumes movers are outside the row/column span of the block's\n    # bounding box, ensuring a diagonal move (dr != 0 and dc != 0),\n    # which holds true for the provided examples.\n    # If a mover was exactly aligned (e.g., mover_r >= min_r and mover_r <= max_r),\n    # this logic might result in a non-diagonal move (dr=0 or dc=0).\n    # However, based on examples, such cases do not occur.\n\n    return dr, dc\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules deduced from examples.\n    \"\"\"\n    # Convert input to a numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to store the output, modifying this copy\n    output_grid_np = grid_np.copy()\n    rows, cols = grid_np.shape\n\n    # Step 1: Find the largest contiguous block of identical non-zero numbers\n    target_block_coords, target_block_value = _find_largest_block(grid_np)\n\n    # If no significant block is found, return the original grid unchanged\n    if not target_block_coords:\n        # Convert back to list of lists for consistent output format\n        return output_grid_np.tolist()\n\n    # Step 2: Find all mover digits (non-zero, not part of the target block)\n    movers = _find_movers(grid_np, target_block_coords)\n\n    # Step 3: Process each mover\n    for mover in movers:\n        mover_val = mover['value']\n        start_r, start_c = mover['r'], mover['c']\n\n        # Step 3a: Determine the diagonal move direction towards the target block\n        dr, dc = _get_move_direction(start_r, start_c, target_block_coords)\n\n        # Skip if the direction is ambiguous (should not happen based on examples)\n        if dr == 0 and dc == 0:\n            continue\n\n        # Step 3b/3c: Trace the diagonal path until the target block is hit\n        curr_r, curr_c = start_r, start_c\n        while True:\n            # Calculate the next position\n            next_r, next_c = curr_r + dr, curr_c + dc\n\n            # Check if the next position is out of grid bounds\n            if not (0 <= next_r < rows and 0 <= next_c < cols):\n                # Path went out of bounds before hitting the block. Stop tracing for this mover.\n                break\n\n            # Check if the next position belongs to the target block's coordinates\n            if (next_r, next_c) in target_block_coords:\n                # Destination found.\n                # Step 3d: Update the output grid at the destination with the mover's value\n                output_grid_np[next_r, next_c] = mover_val\n                # Step 3e: Set the mover's original position to 0 in the output grid\n                output_grid_np[start_r, start_c] = 0\n                # Stop tracing for this mover as it has reached its destination\n                break\n            # Check if the path is crossing over a zero - if so, continue tracing\n            elif grid_np[next_r, next_c] == 0:\n                 curr_r, curr_c = next_r, next_c # Update current position and continue\n            else:\n                 # Path hit a non-zero cell that isn't part of the target block.\n                 # Based on examples, this shouldn't happen. Stop tracing.\n                 break\n\n    # Step 4: Return the final modified grid as a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1808,
    "candidates_token_count": 2618,
    "total_token_count": 4426,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 63.642043,
  "retries": 1
}