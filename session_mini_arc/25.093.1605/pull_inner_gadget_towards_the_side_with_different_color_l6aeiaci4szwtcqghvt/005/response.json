{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set, Optional\n\n\"\"\"\nTransformation Rule:\n1. Identify distinct objects: Background (0), Target (7), Movable Object (heuristic: non-0/7, not simple border, least frequent if ambiguous), and Static Obstacles (other non-0).\n2. Determine the single cardinal movement direction (dr, dc) from the Movable Object's centroid towards the Target Object's centroid.\n3. Iteratively move the Movable Object one step in the determined direction until a stop condition is met.\n4. Stop conditions (checked *before* executing a move):\n    a) Any part of the Movable Object is currently adjacent (sharing an edge) to any part of the Target Object (7).\n    b) The *next* potential move would cause any part of the Movable Object to go out of grid bounds.\n    c) The *next* potential move would cause any part of the Movable Object to collide with (land on) a Static Obstacle cell.\n5. If no stop condition is met, execute the move: erase the Movable Object from its current position (fill with 0) and draw it in the new position. Update the object's coordinates and repeat the loop.\n6. If no Target Object (7) exists or the direction is ambiguous (e.g., centroids overlap), no movement occurs.\n\"\"\"\n\ndef find_digit_coords(grid: np.ndarray, digit: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of a specific digit.\"\"\"\n    coords = np.argwhere(grid == digit)\n    return [tuple(coord) for coord in coords]\n\ndef identify_objects(grid: np.ndarray) -> Tuple[Optional[int], List[Tuple[int, int]], List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Identifies the movable digit/coords, target coords (7), and static obstacle coords.\n    Returns: (movable_digit, movable_coords, target_coords, static_obstacle_coords)\n    \"\"\"\n    rows, cols = grid.shape\n    unique_digits = np.unique(grid)\n\n    # Identify Target (7)\n    target_coords = find_digit_coords(grid, 7)\n    \n    # Identify potential movable digits (non-0, non-7)\n    potential_movable_digits = [d for d in unique_digits if d != 0 and d != 7]\n    if not potential_movable_digits:\n        # No potential movable objects found (only 0s and 7s, or just 0s)\n        # All non-zero, non-7 are static obstacles in this case\n        static_obstacle_coords = [tuple(c) for c in np.argwhere(grid != 0) if grid[c[0], c[1]] != 7]\n        return None, [], target_coords, static_obstacle_coords\n\n    counts = {d: np.sum(grid == d) for d in potential_movable_digits}\n\n    # Simple border check heuristic: check if the outermost layer is composed of a single potential digit\n    border_digit = -1 # Use -1 to indicate no simple border found or border is 0/7\n    potential_border_digit = grid[0,0]\n    if potential_border_digit in potential_movable_digits:\n        is_simple_border = True\n        # Check corners\n        if not (grid[0, -1] == potential_border_digit and \\\n                grid[-1, 0] == potential_border_digit and \\\n                grid[-1, -1] == potential_border_digit):\n            is_simple_border = False\n        # Check edges (ensure all non-zero edge cells match potential_border_digit)\n        if is_simple_border:\n            for r in range(rows):\n                if grid[r, 0] != 0 and grid[r, 0] != potential_border_digit: is_simple_border = False; break\n                if grid[r, cols-1] != 0 and grid[r, cols-1] != potential_border_digit: is_simple_border = False; break\n            if is_simple_border:\n                for c in range(cols):\n                    if grid[0, c] != 0 and grid[0, c] != potential_border_digit: is_simple_border = False; break\n                    if grid[rows-1, c] != 0 and grid[rows-1, c] != potential_border_digit: is_simple_border = False; break\n        \n        if is_simple_border:\n            border_digit = potential_border_digit\n\n\n    # Filter out the identified border digit from potential movable digits\n    if border_digit != -1:\n        potential_movable_digits = [d for d in potential_movable_digits if d != border_digit]\n\n    # Determine the movable digit\n    movable_digit = None\n    if not potential_movable_digits:\n        # Only border and target/background exist\n        movable_digit = None\n    elif len(potential_movable_digits) == 1:\n        movable_digit = potential_movable_digits[0]\n    else:\n        # Ambiguous: Use frequency heuristic (least frequent non-border/non-target/non-zero)\n        counts_filtered = {d: counts[d] for d in potential_movable_digits}\n        sorted_counts = sorted(counts_filtered.items(), key=lambda item: item[1])\n        if sorted_counts:\n            movable_digit = sorted_counts[0][0] # Choose least frequent\n        # If still ambiguous (e.g., equal counts), this picks the one with the lower digit value first due to sorting tie-breaking\n\n    # Get coordinates for the identified objects\n    movable_coords = []\n    if movable_digit is not None:\n        movable_coords = find_digit_coords(grid, movable_digit)\n\n    # Identify all static obstacles (non-0, non-7, non-movable)\n    all_non_zero_coords = np.argwhere(grid != 0)\n    movable_set = set(movable_coords)\n    target_set = set(target_coords)\n    \n    static_obstacle_coords = []\n    for r, c in all_non_zero_coords:\n        coord = (r, c)\n        if coord not in movable_set and coord not in target_set:\n            static_obstacle_coords.append(coord)\n            \n    return movable_digit, movable_coords, target_coords, static_obstacle_coords\n\n\ndef calculate_center(coords: List[Tuple[int, int]]) -> Optional[Tuple[float, float]]:\n    \"\"\"Calculates the geometric center (average row, col) of coordinates.\"\"\"\n    if not coords:\n        return None\n    avg_row = sum(r for r, c in coords) / len(coords)\n    avg_col = sum(c for r, c in coords) / len(coords)\n    return (avg_row, avg_col)\n\ndef determine_direction(movable_center: Optional[Tuple[float, float]], target_center: Optional[Tuple[float, float]]) -> Tuple[int, int]:\n    \"\"\"Determines the primary cardinal direction (dr, dc) from movable to target.\"\"\"\n    if movable_center is None or target_center is None:\n        return (0, 0) # No movement if either object doesn't exist\n\n    dr_f = target_center[0] - movable_center[0]\n    dc_f = target_center[1] - movable_center[1]\n\n    # Handle cases where centers are very close or identical\n    if abs(dr_f) < 1e-6 and abs(dc_f) < 1e-6:\n        return (0, 0)\n\n    if abs(dr_f) >= abs(dc_f):\n        # Move vertically\n        return (1 if dr_f > 0 else -1, 0)\n    else:\n        # Move horizontally\n        return (0, 1 if dc_f > 0 else -1)\n\ndef check_adjacency(coords: List[Tuple[int, int]], target_set: Set[Tuple[int, int]]) -> bool:\n    \"\"\"Checks if any coord in the list is adjacent to any coord in the target_set.\"\"\"\n    for r, c in coords:\n        for dr_adj, dc_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_r, adj_c = r + dr_adj, c + dc_adj\n            if (adj_r, adj_c) in target_set:\n                return True # Found adjacency\n    return False # No adjacency found\n\ndef check_path_validity(\n    potential_coords: List[Tuple[int, int]], \n    obstacle_set: Set[Tuple[int, int]], \n    grid_shape: Tuple[int, int]\n) -> bool:\n    \"\"\"Checks if the potential move is valid (within bounds and no collision with obstacles).\"\"\"\n    rows, cols = grid_shape\n    for r, c in potential_coords:\n        # Check grid bounds\n        if not (0 <= r < rows and 0 <= c < cols):\n            return False  # Invalid: Out of bounds\n        # Check collision with static obstacles\n        if (r, c) in obstacle_set:\n            return False # Invalid: Collision with obstacle\n    return True # Path is valid\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Moves a block of digits towards the '7' block until adjacent or blocked.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # --- 1. Identify Components ---\n    movable_digit, current_movable_coords, target_coords, static_obstacle_coords = identify_objects(grid)\n\n    # If no movable object identified, return the original grid\n    if movable_digit is None or not current_movable_coords:\n        return output_grid.tolist()\n\n    # Convert lists to sets for efficient lookup\n    target_set = set(target_coords)\n    static_obstacle_set = set(static_obstacle_coords)\n\n    # --- 2. Determine Movement Direction ---\n    movable_center = calculate_center(current_movable_coords)\n    target_center = calculate_center(target_coords)\n    dr, dc = determine_direction(movable_center, target_center)\n\n    # If no direction (e.g., no target, or centers coincide), return original grid\n    if dr == 0 and dc == 0:\n        return output_grid.tolist()\n\n    # --- 3. Iterative Movement ---\n    while True:\n        # --- 3a. Check Stop Condition: Adjacency to Target ---\n        # Check if the *current* position is adjacent to the target\n        if check_adjacency(current_movable_coords, target_set):\n            break # Stop: Already adjacent\n\n        # --- 3b. Calculate Potential Next Position ---\n        potential_next_coords = [(r + dr, c + dc) for r, c in current_movable_coords]\n\n        # --- 3c. Check Stop Condition: Path Validity for Next Step ---\n        # Check if the *next* move would be invalid (out of bounds or collision)\n        if not check_path_validity(potential_next_coords, static_obstacle_set, (rows, cols)):\n            break # Stop: Next move is blocked\n\n        # --- 3d. Execute Move (if no stop conditions met) ---\n        # Clear old positions in the output grid\n        for r, c in current_movable_coords:\n            output_grid[r, c] = 0\n        # Place movable object in new positions in the output grid\n        for nr, nc in potential_next_coords:\n            # Double check bounds just in case check_path_validity had a flaw\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 output_grid[nr, nc] = movable_digit\n            \n        # Update coordinates for the next iteration\n        current_movable_coords = potential_next_coords\n        \n        # Basic safety break to prevent potential infinite loops in unexpected scenarios, limit steps.\n        # A better approach might involve state tracking if needed.\n        # For now, relying on stop conditions.\n\n    # --- 4. Finalize ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14324,
    "candidates_token_count": 3430,
    "total_token_count": 17754,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.678054,
  "retries": 1
}