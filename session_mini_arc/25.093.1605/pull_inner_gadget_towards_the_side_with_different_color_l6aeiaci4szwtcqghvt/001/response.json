{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a 'movable object' (a block of identical digits, not 0 and not 7, distinct from the main border digit) \nand a 'target object' (block of digit 7). Determines the primary cardinal direction from the movable object towards \nthe target object. Iteratively moves the movable object one step at a time in that direction, filling its previous \nlocation with 0s. The movement stops when any part of the movable object becomes adjacent (up, down, left, or right) \nto any part of the target object (7) or any other static non-zero digit (like the border).\n\"\"\"\n\ndef find_digit_coords(grid, digit):\n    \"\"\"Finds all coordinates (row, col) of a specific digit in the grid.\"\"\"\n    coords = np.argwhere(grid == digit)\n    return [tuple(coord) for coord in coords]\n\ndef find_movable_and_static(grid):\n    \"\"\"\n    Identifies the movable digit, its coordinates, and coordinates of all static elements (non-zero, non-movable).\n    Assumes there's only one type of movable digit per grid (excluding 0 and 7).\n    Assumes 7 is always static/target.\n    \"\"\"\n    unique_digits = np.unique(grid)\n    potential_movable = [d for d in unique_digits if d != 0 and d != 7]\n    \n    # Heuristic: Often the border is the most frequent digit excluding 0.\n    # Or, the movable object might be less frequent. Let's find the digit that isn't 0 or 7\n    # and isn't surrounding the grid completely (simple border check).\n    \n    movable_digit = -1\n    rows, cols = grid.shape\n    \n    counts = {d: np.sum(grid == d) for d in potential_movable}\n\n    # A simple check: if a digit forms the entire outer frame, it's likely the border.\n    # Check corners and some edge midpoints.\n    corner_val = grid[0, 0]\n    is_simple_border = True\n    if grid[0, -1] != corner_val or grid[-1, 0] != corner_val or grid[-1, -1] != corner_val or \\\n       grid[0, cols//2] != corner_val or grid[-1, cols//2] != corner_val or \\\n       grid[rows//2, 0] != corner_val or grid[rows//2, -1] != corner_val:\n           is_simple_border = False\n\n    # If there's only one potential digit, it's the movable one.\n    if len(potential_movable) == 1:\n        movable_digit = potential_movable[0]\n    # If multiple, try to exclude the simple border if found.\n    elif is_simple_border and corner_val in potential_movable:\n         # Assume the non-border digit is movable. This might need refinement for complex cases.\n         other_potential = [d for d in potential_movable if d != corner_val]\n         if len(other_potential) == 1:\n             movable_digit = other_potential[0]\n         else:\n             # If still ambiguous, maybe pick the least frequent non-7, non-0 digit?\n             # Or the one not touching the edge? This needs better logic for edge cases.\n             # For now, let's fallback or raise an error if ambiguous.\n             # Trying least frequent as a guess for the examples provided.\n              sorted_counts = sorted(counts.items(), key=lambda item: item[1])\n              if sorted_counts:\n                  movable_digit = sorted_counts[0][0] # Assume least frequent non-0/7 is movable\n              else:\n                    raise ValueError(\"Could not definitively identify movable digit.\")\n\n    else:\n         # No simple border, pick least frequent?\n         sorted_counts = sorted(counts.items(), key=lambda item: item[1])\n         if sorted_counts:\n             movable_digit = sorted_counts[0][0]\n         else:\n            # This case happens if grid only has 0s and 7s, or just 0s.\n            movable_digit = -1 # Indicate no movable object found\n\n    if movable_digit == -1 and len(potential_movable) > 0:\n         # Default guess if logic failed: assume the first potential one found\n         # This is risky and likely needs refinement based on more examples.\n         # Let's stick to the least frequent as the primary guess if ambiguity remains.\n         sorted_counts = sorted(counts.items(), key=lambda item: item[1])\n         if sorted_counts:\n             movable_digit = sorted_counts[0][0]\n         else:\n              movable_digit = -1 # No movable object\n\n    if movable_digit == -1:\n         movable_coords = []\n         static_coords = find_digit_coords(grid, -1) # Find all non-zero coords\n         all_non_zero = np.argwhere(grid != 0)\n         static_coords = [tuple(coord) for coord in all_non_zero]\n\n    else:\n        movable_coords = find_digit_coords(grid, movable_digit)\n        \n        static_coords = []\n        non_zero_coords = np.argwhere(grid != 0)\n        movable_set = set(movable_coords)\n        for r, c in non_zero_coords:\n            if (r, c) not in movable_set:\n                static_coords.append((r,c))\n\n    return movable_digit, movable_coords, static_coords\n\n\ndef calculate_center(coords):\n    \"\"\"Calculates the geometric center (average row, col) of a list of coordinates.\"\"\"\n    if not coords:\n        return (0, 0)\n    avg_row = sum(r for r, c in coords) / len(coords)\n    avg_col = sum(c for r, c in coords) / len(coords)\n    return (avg_row, avg_col)\n\ndef determine_direction(movable_center, target_center):\n    \"\"\"Determines the primary cardinal direction (dr, dc) from movable to target.\"\"\"\n    dr = target_center[0] - movable_center[0]\n    dc = target_center[1] - movable_center[1]\n\n    if abs(dr) >= abs(dc):\n        # Move vertically\n        return (1 if dr > 0 else -1, 0) if dr != 0 else (0, 0) # Return (0,0) if centers coincide\n    else:\n        # Move horizontally\n        return (0, 1 if dc > 0 else -1) if dc != 0 else (0, 0) # Return (0,0) if centers coincide\n\ndef check_adjacency(grid_shape, movable_coords, static_coords):\n    \"\"\"Checks if any movable cell is adjacent to any static cell.\"\"\"\n    rows, cols = grid_shape\n    static_set = set(static_coords)\n    for r, c in movable_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds implicitly by checking membership in static_set\n            if (nr, nc) in static_set:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Moves a block of digits towards the '7' block until adjacent.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Identify components\n    movable_digit, movable_coords, static_coords = find_movable_and_static(grid)\n    target_coords = find_digit_coords(grid, 7)\n    \n    # Add target coordinates to static coordinates for adjacency check\n    all_static_coords = list(set(static_coords + target_coords))\n\n\n    # Handle cases with no movable object\n    if movable_digit == -1 or not movable_coords:\n        return output_grid.tolist() # Return original grid if no movable object\n\n    # 2. Determine movement direction\n    movable_center = calculate_center(movable_coords)\n    target_center = calculate_center(target_coords)\n    \n    # If no target 7s, maybe move towards center? Or stay put? Let's assume stay put.\n    if not target_coords:\n         dr, dc = (0,0)\n    else:\n         dr, dc = determine_direction(movable_center, target_center)\n\n    # If direction is (0,0), no movement needed\n    if dr == 0 and dc == 0:\n         return output_grid.tolist()\n\n    # 3. Iterative movement\n    current_movable_coords = list(movable_coords) # Work with a copy\n\n    while True:\n        # 3a. Check stopping condition (adjacency to ANY static element, including 7)\n        if check_adjacency((rows, cols), current_movable_coords, all_static_coords):\n            break\n\n        # 3b. Calculate next positions\n        next_movable_coords = []\n        valid_move = True\n        for r, c in current_movable_coords:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                valid_move = False\n                break\n            # Check if the target cell is currently occupied by another static object (shouldn't happen if adjacency works)\n            # Or if it's part of the *current* movable object (relevant for multi-cell objects moving onto their own space)\n            if (nr, nc) in all_static_coords:\n                 valid_move = False # Cannot move into a static cell\n                 break\n            # Check collision with self (important for larger shapes)\n            is_part_of_current_movable = False\n            for rr, cc in current_movable_coords:\n                if nr == rr and nc == cc:\n                    is_part_of_current_movable = True\n                    break\n            # Allow moving into '0' or into a space previously occupied by another part of the *same* object in this step\n            if output_grid[nr, nc] != 0 and not is_part_of_current_movable:\n                 # This case should ideally be covered by static check, but double check just in case.\n                 # Or, this handles collision if multiple different movable objects were present.\n                 # Since we assume one type, this should mainly catch static obj collision.\n                 valid_move = False\n                 break\n\n            next_movable_coords.append((nr, nc))\n\n        if not valid_move:\n            # Should ideally stop due to adjacency check before hitting this,\n            # but acts as a failsafe (e.g., if somehow moving into border).\n            break\n\n        # 3c. Update grid state if move is valid\n        # Clear old positions\n        for r, c in current_movable_coords:\n            output_grid[r, c] = 0\n        # Place in new positions\n        for nr, nc in next_movable_coords:\n            output_grid[nr, nc] = movable_digit\n\n        # Update coordinates for the next iteration\n        current_movable_coords = next_movable_coords\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2338,
    "candidates_token_count": 3676,
    "total_token_count": 6014,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.076202,
  "retries": 1
}