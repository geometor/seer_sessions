{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms an input grid by moving a single, specifically selected, non-zero cell horizontally.\n1. Find all non-zero cells and determine the overall minimum and maximum column indices they occupy.\n2. Identify all non-zero cells that are \"horizontally isolated\" (left and right neighbors are 0 or grid boundary).\n3. From the isolated cells, select the one with the maximum row index. If there's a tie in row index, select the one with the maximum column index among the tied cells. This is the 'moving cell'.\n4. Calculate the destination column for the moving cell by reflecting its original column across the center of the global non-zero column range (destination_col = min_col + max_col - original_col).\n5. Create the output grid by copying the input, setting the original position of the moving cell to 0, and setting the calculated destination position (same row, new column) to the moving cell's original value.\n\"\"\"\n\n\ndef find_non_zero_cells(grid):\n    \"\"\"Finds all cells with non-zero values.\"\"\"\n    non_zero_cells = []\n    height = len(grid)\n    if height == 0:\n        return non_zero_cells\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] != 0:\n                non_zero_cells.append({'r': r, 'c': c, 'v': grid[r][c]})\n    return non_zero_cells\n\ndef get_global_column_range(non_zero_cells):\n    \"\"\"Calculates the min and max column index containing non-zero cells.\"\"\"\n    if not non_zero_cells:\n        # Return default or signal no range if appropriate\n        return None, None\n    min_c = min(cell['c'] for cell in non_zero_cells)\n    max_c = max(cell['c'] for cell in non_zero_cells)\n    return min_c, max_c\n\ndef find_all_horizontally_isolated_cells(grid):\n    \"\"\"Finds all non-zero cells horizontally isolated by zeros or boundaries.\"\"\"\n    isolated_cells = []\n    height = len(grid)\n    if height == 0: return isolated_cells\n    width = len(grid[0])\n    if width == 0: return isolated_cells\n\n    for r in range(height):\n        for c in range(width):\n            value = grid[r][c]\n            if value != 0:\n                # Check left neighbor\n                is_left_bg = (c == 0) or (grid[r][c - 1] == 0)\n                # Check right neighbor\n                is_right_bg = (c == width - 1) or (grid[r][c + 1] == 0)\n\n                if is_left_bg and is_right_bg:\n                    isolated_cells.append({'r': r, 'c': c, 'v': value})\n    return isolated_cells\n\ndef select_moving_cell(isolated_cells):\n    \"\"\"Selects the cell to move: max row index, then max col index.\"\"\"\n    if not isolated_cells:\n        return None\n    # Sort primarily by row (descending), then by column (descending)\n    # The max element according to this key is the first element after sorting reversed\n    # Alternatively, use max with a tuple key\n    # Key: (row_index, column_index) -> max finds the largest tuple lexicographically\n    moving_cell = max(isolated_cells, key=lambda cell: (cell['r'], cell['c']))\n    return moving_cell\n\n\ndef transform(input_grid):\n    # initialize output_grid as a deep copy to avoid modifying the input\n    output_grid = copy.deepcopy(input_grid)\n    height = len(output_grid)\n    if height == 0:\n        return output_grid\n    width = len(output_grid[0])\n    if width == 0:\n        return output_grid\n\n    # 1. Analyze Input Grid & 2. Determine Global Column Boundaries\n    non_zero_cells = find_non_zero_cells(output_grid)\n    if not non_zero_cells:\n        return output_grid # No non-zero cells, nothing to move\n\n    min_nz_col, max_nz_col = get_global_column_range(non_zero_cells)\n    if min_nz_col is None: # Should not happen if non_zero_cells is not empty\n         return output_grid\n\n    # 3. Identify Candidate Cells\n    isolated_cells = find_all_horizontally_isolated_cells(output_grid)\n    if not isolated_cells:\n         # No isolated cell found, return the original grid\n        return output_grid\n\n    # 4. Select the Moving Cell\n    moving_cell = select_moving_cell(isolated_cells)\n    if not moving_cell: # Should not happen if isolated_cells is not empty\n         return output_grid\n\n    r_move = moving_cell['r']\n    c_move = moving_cell['c']\n    v_move = moving_cell['v']\n\n    # 5. Calculate the Destination Column\n    # Reflect c_move across the center point (min_nz_col + max_nz_col) / 2\n    # Formula: new_pos = min + max - old_pos\n    c_new = min_nz_col + max_nz_col - c_move\n\n    # Ensure destination column is within grid bounds\n    if 0 <= c_new < width:\n        # 6. Construct the Output Grid (modify the copy)\n        # a. Clear the original position\n        output_grid[r_move][c_move] = 0\n        # b. Place the value at the new position\n        output_grid[r_move][c_new] = v_move\n    # else: If destination is out of bounds, the logic might be flawed or the\n    #       problem guarantees this won't happen. Based on examples, it seems\n    #       c_new will always be valid relative to min/max_nz_col, but checking\n    #       against grid width adds robustness. For now, assume it's valid.\n\n    # 7. Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10690,
    "candidates_token_count": 1914,
    "total_token_count": 12604,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.076987,
  "retries": 1
}