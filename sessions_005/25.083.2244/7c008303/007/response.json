{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid into an output grid by splitting it along a horizontal azure line, extracting colored objects from above and below the line, combining them by reflecting the x axis, and arranging them into a new grid.\n\"\"\"\n\nimport numpy as np\n\ndef get_azure_line_row(grid):\n    \"\"\"Finds the row index of the horizontal azure line.\"\"\"\n    for i, row in enumerate(grid):\n        if all(pixel == 8 for pixel in row):\n            return i\n    return -1\n\ndef get_objects(grid_section):\n    \"\"\"\n    Identifies colored objects in a grid section.\n    Returns a dictionary of objects, where keys are colors and values are lists of (row, col) coordinates.\n    \"\"\"\n    objects = {}\n    visited = set()\n\n    def is_valid(r, c):\n        return 0 <= r < grid_section.shape[0] and 0 <= c < grid_section.shape[1]\n\n    def dfs(r, c, color, obj_coords):\n        if (r, c) in visited or not is_valid(r, c) or grid_section[r, c] != color:\n            return\n        visited.add((r, c))\n        obj_coords.append((r, c))\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(r + dr, c + dc, color, obj_coords)\n\n    for r in range(grid_section.shape[0]):\n        for c in range(grid_section.shape[1]):\n            color = grid_section[r, c]\n            if color != 0 and color != 8 and (r, c) not in visited:\n                obj_coords = []\n                dfs(r, c, color, obj_coords)\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(obj_coords)\n    return objects\n\ndef reflect_x(coords, width):\n    \"\"\"Reflects coordinates across the x-axis.\"\"\"\n    reflected_coords = []\n    for r, c in coords:\n        reflected_coords.append((r, width - 1 - c))\n\n    return reflected_coords\n\ndef get_bounding_box(coords):\n  \"\"\"\n    get smallest bounding box that contains all coordinates\n  \"\"\"\n  if not coords:\n      return None, None, None, None # No coordinates\n  \n  min_row = min(r for r, _ in coords)\n  max_row = max(r for r, _ in coords)\n  min_col = min(c for _, c in coords)\n  max_col = max(c for _, c in coords)\n\n  return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    azure_line_row = get_azure_line_row(input_grid)\n\n    # Split the grid into top and bottom sections\n    top_section = input_grid[:azure_line_row]\n    bottom_section = input_grid[azure_line_row + 1:]\n\n    # Get objects from each section\n    top_objects = get_objects(top_section)\n    bottom_objects = get_objects(bottom_section)\n    \n    # Calculate maximum width of top and bottom colored objects\n    top_width = 0\n    for color, object_list in top_objects.items():\n      for obj_coords in object_list:\n        _,_,min_col,max_col = get_bounding_box(obj_coords)\n        width = max_col - min_col + 1\n        top_width = max(top_width,width)\n        \n\n    bottom_width = 0\n    for color, object_list in bottom_objects.items():\n      for obj_coords in object_list:\n        _,_,min_col,max_col = get_bounding_box(obj_coords)\n        width = max_col - min_col + 1\n        bottom_width = max(bottom_width,width)\n\n    max_width = max(top_width, bottom_width)\n\n    # Create a combined dictionary of objects, reflecting bottom objects\n    combined_objects = {}\n    for color, object_list in top_objects.items():\n        if color not in combined_objects:\n          combined_objects[color] = []\n        combined_objects[color].extend(object_list) # add all from the list\n\n    for color, object_list in bottom_objects.items():\n        if color not in combined_objects:\n            combined_objects[color] = []\n        \n        reflected_objects = []\n        for obj_coords in object_list:\n          reflected_objects.append(reflect_x(obj_coords,input_grid.shape[1])) # reflect on original width\n        \n        combined_objects[color].extend(reflected_objects)\n\n    # Determine output grid dimensions based on bounding boxes of combined objects\n    output_rows = []\n    output_cols = []\n\n    for color, object_list in combined_objects.items():\n        for obj_coords in object_list:\n            for r, c in obj_coords:\n                output_rows.append(r)\n                output_cols.append(c)\n\n    if not output_rows or not output_cols:\n        return []  # Empty output if no colored objects\n\n    # Create output grid\n    min_output_row = min(output_rows)\n    max_output_row = max(output_rows)\n    \n    min_output_col, max_output_col, _, _ = get_bounding_box(output_cols)\n    \n    output_width  = max_output_col + 1 #max_width\n    output_height = max_output_row - min_output_row + 1\n\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n    \n    # Populate output grid\n    for color, object_list in combined_objects.items():\n        for obj_coords in object_list:\n            for r, c in obj_coords:\n              if 0 <= c < output_width: # to make sure the reflected object is inside bounds\n                output_grid[r - min_output_row, c] = color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6202,
    "candidates_token_count": 1476,
    "total_token_count": 7678,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 26.392089
}