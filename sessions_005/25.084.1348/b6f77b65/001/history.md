
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

*   **Perception of Task Elements:**
    *   The input and output grids are the same size in all examples (12x12).
    *   Each grid contains various small, distinct geometric shapes composed of different colors (blue, red, green, yellow, gray, magenta, orange, azure, maroon) on a white background (0).
    *   The pixel at the top-left corner (index 0, 0) appears to be a special control pixel, as its color varies between examples (maroon, yellow, magenta, orange) and seems to dictate the transformation.
    *   The remaining part of the grid (excluding the top-left pixel) contains the shapes or 'content'.
    *   The transformation involves shifting the entire 'content' portion of the grid. The direction and magnitude of the shift depend on the color of the control pixel.
    *   Pixels shifted outside the grid boundaries are discarded.
    *   Areas vacated by the shift are filled with the background color (white, 0).
    *   The control pixel itself remains unchanged in the output grid at position (0, 0).

*   **Facts:**
    
```yaml
    task_type: grid_transformation
    grid_properties:
      size: constant (12x12 in examples)
      background_color: 0 (white)
    objects:
      - type: control_pixel
        location: grid[0][0]
        property: color (determines action)
        persistence: remains unchanged in output
      - type: content_grid
        location: grid[1:, :] and grid[:, 1:] relative to control pixel (effectively the entire grid excluding grid[0][0])
        elements: various colored shapes/pixels
        action: undergoes transformation based on control_pixel color
    transformations:
      - type: shift
        target: content_grid
        details:
          - direction: determined by control_pixel color (down, right, left observed)
          - magnitude: determined by control_pixel color (3, 5, 4 observed)
          - boundary_handling: pixels shifted out are lost
          - fill_vacated_area: with background_color (0)
      - type: no_operation
        target: content_grid
        condition: control_pixel color is 9 (maroon)
    control_logic:
      - mapping:
          color_9: no operation
          color_4: shift down by 3
          color_6: shift right by 5
          color_7: shift left by 4
    ```


*   **Natural Language Program:**
    1.  Identify the control pixel at grid position (0, 0).
    2.  Store the color of the control pixel.
    3.  Create a new output grid of the same dimensions as the input grid, initially filled with the background color (white, 0).
    4.  Copy the control pixel's color from the input grid to the output grid at position (0, 0).
    5.  Determine the required shift operation based on the control pixel's color:
        *   If the color is 9 (maroon), perform no shift. Copy the rest of the input grid (excluding the control pixel) directly to the corresponding positions in the output grid.
        *   If the color is 4 (yellow), shift the content down by 3 rows. Iterate through each pixel (r, c) in the input grid *except* for the control pixel (0, 0). If the new row `r + 3` is within the grid bounds, copy the color from input `grid[r][c]` to output `grid[r + 3][c]`.
        *   If the color is 6 (magenta), shift the content right by 5 columns. Iterate through each pixel (r, c) in the input grid *except* for the control pixel (0, 0). If the new column `c + 5` is within the grid bounds, copy the color from input `grid[r][c]` to output `grid[r][c + 5]`.
        *   If the color is 7 (orange), shift the content left by 4 columns. Iterate through each pixel (r, c) in the input grid *except* for the control pixel (0, 0). If the new column `c - 4` is non-negative and within the grid bounds, copy the color from input `grid[r][c]` to output `grid[r][c - 4]`.
    6.  Return the completed output grid.
