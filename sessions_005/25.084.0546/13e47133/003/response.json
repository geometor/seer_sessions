{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid into an output grid based on the following rules:\n\n1.  **Identify \"Anchor\" Pixels:** Locate all pixels in the input grid with the color red (value 2). These act as primary anchor points for the transformation. Gray (value 5) acts as secondary anchors.\n\n2.  **Process Rows with Anchors:**\n    *   Iterate through each row of the input.\n    *   If a row contains anchor pixels, process that row; otherwise, the row remains unchanged in the output.\n    *   The red pixels remain unchanged in the output.\n\n3. **Horizontal Propagation (Left of Anchor):**\n   * Colors to the left of the leftmost red anchor are transformed based on a specific mapping, and propagated to the left edge of the grid.\n       * input color 1 becomes 8\n       * input color 3 becomes 3\n       * input color 4 becomes 4\n       * input color 7 becomes 7\n\n4. **Horizontal Propagation (Right of Anchor):**\n    *   Colors to the right of the rightmost red anchor in a row are handled, with transformations, to the right edge.\n    * Input values to right of red anchors are transformed and propagated based on these rules.\n       * input color 1 becomes 8\n       * input color 4 becomes 8, unless there is a red pixel to the left, in which case it is 4\n       * input color 8 becomes 8\n       * input color 0 becomes 0\n       * input color 5 becomes 5\n\n5. **Horizontal Propagation (Between Anchors):**\n    *  If there are multiple red anchors, colors between them.\n        *  From the left anchor moving towards the right anchor.\n        *  The color is determined based on the mirrored position of the value from the left anchor.\n\n6. **Gray Anchor (5) Behavior:**\n    * Gray pixels act as secondary anchors and also stop propagation\n\n7.  **Process all Rows:** Ensure all rows have been processed and that un-processed rows remain the same.\n\n\"\"\"\n\nimport numpy as np\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Find anchor pixels (red = 2)\n    anchor_positions = np.where(input_grid == 2)\n    anchor_rows = anchor_positions[0]\n    anchor_cols = anchor_positions[1]\n\n    anchor_col_map = {}\n    for r,c in zip(anchor_rows, anchor_cols):\n        if r not in anchor_col_map:\n            anchor_col_map[r] = []\n        anchor_col_map[r].append(c)\n\n    # Iterate through rows\n    for row in range(rows):\n        if row in anchor_col_map:\n            anchors = sorted(anchor_col_map[row])\n            # print(f\"row:{row} anchors: {anchors}\")\n\n            # process to left of first anchor\n            first_anchor = anchors[0]\n            for col in range(first_anchor):\n                 # Check for gray anchor to the left\n                if 5 in input_grid[row, :col+1]:\n                    gray_anchor_pos = np.where(input_grid[row, :col+1] == 5)[0][-1]\n                    output_grid[row,col] = output_grid[row, col]\n                else:\n                    output_grid[row, col] = transform_left(input_grid[row, col])\n\n            # print(f\"   left of {first_anchor} complete: {output_grid[row]}\")\n\n\n            # process between anchors\n            for i in range(len(anchors)-1):\n                anchor1 = anchors[i]\n                anchor2 = anchors[i+1]\n                for col in range(anchor1+1, anchor2):\n                    input_val_index = anchor1 + (anchor2-col)\n                    output_grid[row,col] = transform_right(input_grid[row, input_val_index], input_grid, row, col)\n                # print(f\"   middle {anchor1}-{anchor2} complete: {output_grid[row]}\")\n\n            # process to right of last anchor\n            last_anchor = anchors[-1]\n            for col in range(last_anchor+1, cols):\n                input_val_index = last_anchor + (cols - col)\n                if input_val_index >= cols:\n                    input_val_index = cols - 1\n\n                # Check for gray anchor\n                if 5 in input_grid[row, last_anchor:col+1]:\n                    gray_anchor_pos = np.where(input_grid[row,last_anchor:col+1] == 5)[0][0] + last_anchor\n                    if col > gray_anchor_pos:\n                        input_val_index = gray_anchor_pos + (col - gray_anchor_pos)\n                        # print(f\"   col: {col} gray at: {gray_anchor_pos}, using {input_val_index}\")\n                        output_grid[row,col] = transform_right(input_grid[row, input_val_index], input_grid, row, col)\n\n                    else:\n                        output_grid[row, col] = input_grid[row,col]\n\n                else:\n                    output_grid[row, col] = transform_right(input_grid[row, input_val_index], input_grid, row, col)\n            # print(f\"   right of {last_anchor} complete: {output_grid[row]}\")\n\n    return output_grid.tolist()\n\ndef transform_left(input_val):\n    if input_val == 1:\n        return 8\n    elif input_val == 3:\n        return 3\n    elif input_val == 4:\n        return 4\n    elif input_val == 7:\n        return 7\n    else:\n        return input_val\n\ndef transform_right(input_val, input_grid, row, col):\n    rows, cols = input_grid.shape\n\n    if input_val == 1:\n        return 8\n    elif input_val == 4:\n        if 2 in input_grid[row, col:]:\n            return 4\n        return 8\n    elif input_val == 8:\n        return 8\n    elif input_val == 0:\n        return 0\n    elif input_val == 5:\n        return 5\n    else:\n        return input_val\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7573,
    "candidates_token_count": 1521,
    "total_token_count": 9094,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 22.21638
}