{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Convert Blue to Red:** Change all blue pixels to red.\n2.  **Identify Isolated Red Regions:** Find all connected regions of red pixels. A region is isolated if none of its pixels are adjacent (horizontally, vertically, or diagonally) to a green pixel.\n3.  **Conditional Green Expansion:** For *each* green pixel in the grid *after* step 1, if it's adjacent (horizontally or vertically) to a red pixel, extend the green vertically (both up and down). Stop the expansion when encountering a background pixel or another green pixel.\n4.  **Insert Green to the Left of Isolated Red:** For each isolated red region, find the top row and the leftmost column of the region. Insert green pixels in all columns to the left of the region's leftmost column, starting from the top row of the region.\n5. **Expand Inserted Green**: Expand the green inserted (from step 4).\n    * From the top row of the isolated red region to the top of the grid.\n    * From the bottom row of the isolated red region to the bottom of the grid.\n    Stopping expansion at background (8) or other green (3) pixels.\n\"\"\"\n\nimport numpy as np\n\ndef get_neighbors(grid, r, c, include_diagonal=False):\n    \"\"\"Get the neighbors of a cell.\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            if not include_diagonal and (i != 0 and j != 0):\n              continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef get_connected_regions(grid, value, include_diagonal=False):\n    \"\"\"Find connected regions of a specific value.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(r, c, current_region):\n        if (\n            r < 0\n            or r >= rows\n            or c < 0\n            or c >= cols\n            or visited[r, c]\n            or grid[r, c] != value\n        ):\n            return\n        visited[r, c] = True\n        current_region.append((r, c))\n        for nr, nc in get_neighbors(grid, r, c, include_diagonal):\n            dfs(nr, nc, current_region)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == value and not visited[r, c]:\n                current_region = []\n                dfs(r, c, current_region)\n                regions.append(current_region)\n    return regions\n\ndef is_isolated(region, grid):\n    \"\"\"Checks if a region is isolated (not adjacent to green).\"\"\"\n    for r, c in region:\n        for nr, nc in get_neighbors(grid, r, c, include_diagonal=True):\n            if grid[nr, nc] == 3:\n                return False\n    return True\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Convert Blue to Red\n    output_grid[output_grid == 1] = 2\n\n    # 2. Identify Isolated Red Regions\n    red_regions = get_connected_regions(output_grid, 2)\n    isolated_red_regions = [region for region in red_regions if is_isolated(region, output_grid)]\n\n    # 3. Conditional Green Expansion\n    green_pixels = np.argwhere(output_grid == 3)\n    for r, c in green_pixels:\n        for nr, nc in get_neighbors(output_grid, r, c):\n            if output_grid[nr, nc] == 2:\n                # Expand upwards\n                ur = r - 1\n                while ur >= 0 and output_grid[ur, c] != 8 and output_grid[ur,c] != 3:\n                    output_grid[ur, c] = 3\n                    ur -= 1\n                # Expand downwards\n                dr = r + 1\n                while dr < rows and output_grid[dr, c] != 8 and output_grid[dr,c] != 3:\n                    output_grid[dr, c] = 3\n                    dr += 1\n\n    # 4. Insert Green to the Left of Isolated Red Regions\n    for region in isolated_red_regions:\n        min_row = min(r for r, _ in region)\n        max_row = max(r for r, _ in region)\n        min_col = min(c for _, c in region)\n        for c in range(min_col):\n            output_grid[min_row, c] = 3\n\n    # 5. Expand Inserted Green\n    for region in isolated_red_regions:\n      min_row = min(r for r, _ in region)\n      max_row = max(r for r, _ in region)\n      min_col = min(c for _, c in region)\n\n      # expand up\n      ur = min_row - 1\n      while ur >= 0:\n        all_green = True\n        for c in range(min_col):\n          if output_grid[ur,c] == 8 or output_grid[ur,c] == 3:\n            all_green = False\n            break\n          else:\n            output_grid[ur,c] = 3\n        if not all_green:\n          break\n        ur -= 1\n      # expand down\n      dr = max_row + 1\n      while dr < rows:\n        all_green = True\n        for c in range(min_col):\n          if output_grid[dr,c] == 8 or output_grid[dr,c] == 3:\n            all_green = False\n            break\n          else:\n            output_grid[dr,c] = 3\n        if not all_green:\n          break\n        dr += 1\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10937,
    "candidates_token_count": 1465,
    "total_token_count": 12402,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 16.898928
}