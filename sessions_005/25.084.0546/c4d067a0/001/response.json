{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying and duplicating specific pattern rows.\n\nThe transformation identifies \"pattern rows\" based on specific criteria:\n- Rows with alternating color sequences (e.g., 8 4 8 4).\n- Rows with solid color blocks adjacent to alternating color sequences.\n\nThese pattern rows, and sometimes adjacent rows, are duplicated and inserted \nat specific locations in the grid, potentially overwriting existing content.\nThe direction of duplication (above or below) and the insertion point vary.\n\"\"\"\n\nimport numpy as np\n\ndef find_pattern_rows(grid):\n    \"\"\"Identifies pattern rows based on alternating colors or solid blocks.\"\"\"\n    pattern_rows = []\n    height, width = grid.shape\n    for i in range(height):\n        row = grid[i]\n        if is_alternating(row) or is_adjacent_to_alternating(grid, i):\n          if i not in pattern_rows:\n            pattern_rows.append(i)\n        elif is_three_section_pattern(row):\n            if i not in pattern_rows:\n                pattern_rows.append(i)\n\n    return pattern_rows\n\ndef is_alternating(row):\n    \"\"\"Checks if a row has an alternating color pattern (e.g., A B A B).\"\"\"\n    if len(row) < 2:\n        return False\n    first_color = row[0]\n    second_color = None\n    for i, cell in enumerate(row):\n      if i == 0: continue\n\n      if cell != first_color:\n        second_color = cell\n        break\n\n    if second_color is None: return False\n\n    for i, cell in enumerate(row):\n        if i % 2 == 0:\n            if cell != first_color:\n                return False\n        else:\n            if cell != second_color:\n                return False\n    return True\n\ndef is_adjacent_to_alternating(grid, row_index):\n    \"\"\"Checks if a row with color blocks is adjacent to an alternating row.\"\"\"\n    height, _ = grid.shape\n    if row_index > 0 and is_alternating(grid[row_index - 1]):\n        return True\n    if row_index < height - 1 and is_alternating(grid[row_index + 1]):\n        return True\n    return False\n\ndef is_three_section_pattern(row):\n    \"\"\"Checks if a row follows the three-section pattern (e.g., 1 3 3 1 1 1 4 4 1).\"\"\"\n    if len(row) < 5 or row[0] != 1 or row[-1] != 1:  # Must start and end with 1\n        return False\n\n    # Find the first section boundary\n    first_section_end = -1\n    for i in range(1, len(row)):\n        if row[i] == 1 and row[i-1] != 1:\n            first_section_end = i\n            break\n    if first_section_end == -1: return False\n\n    #find the second section boundary\n    second_section_end = -1\n    for i in range(first_section_end+1,len(row)):\n        if row[i] != 1:\n          second_section_end = i\n          break\n\n    if second_section_end == -1: return False #all 1's\n\n    first_color = -1\n    #check colors are different\n    for i in range(0, first_section_end):\n      if row[i] != 1:\n        first_color = row[i]\n        break\n\n    second_color = -1\n    for i in range(second_section_end, len(row)):\n      if row[i] != 1:\n        second_color = row[i]\n        break\n\n    if first_color == second_color or first_color == -1 or second_color == -1: return False\n\n    return True\n\ndef duplicate_row(grid, source_row_index, destination_row_index):\n    \"\"\"Duplicates a row and inserts it at the destination index.\"\"\"\n    height, width = grid.shape\n    new_grid = np.copy(grid)  # Start with a copy of the grid.\n    new_grid[destination_row_index] = np.copy(grid[source_row_index]) #duplicate by overwriting\n    return new_grid\n    \n\ndef transform(input_grid):\n    # Initialize output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n    \n    # Find pattern rows in input\n    pattern_rows = find_pattern_rows(input_grid)\n\n    # Duplicate pattern rows based on example\n    # Examples 1 and 2 logic\n    if any(is_alternating(input_grid[row]) for row in pattern_rows):\n      offset = 0\n      for row_index in pattern_rows:\n          if is_alternating(input_grid[row_index]):\n            if row_index < 6: #row indices 2-5 are duplicated from row number 6\n              destination_index = row_index + 4\n              if destination_index < height:\n                output_grid = duplicate_row(output_grid, row_index, destination_index + offset) #first alternating row\n              \n                #duplicate adjacent as well, if existing\n                if row_index + 1 < height and not is_alternating(input_grid[row_index + 1]):\n                  destination_index = row_index + 5 #overwrite adjacent to first alternating\n                  if destination_index < height:\n                    output_grid = duplicate_row(output_grid, row_index + 1, destination_index + offset) #first alternating row\n              offset+=2\n            else:\n              #overwrite repeating 1 pattern\n              destination_index = row_index + 3\n              if destination_index < height:\n                output_grid = duplicate_row(output_grid, row_index, destination_index-6) #first alternating row\n\n                #duplicate adjacent as well, if existing\n                if row_index + 1 < height and not is_alternating(input_grid[row_index + 1]):\n                  destination_index = row_index + 4\n                  if destination_index < height:\n                      output_grid = duplicate_row(output_grid, row_index + 1, destination_index - 6)\n\n    # Example 3 logic\n    elif any(is_three_section_pattern(input_grid[row]) for row in pattern_rows):\n        for row_index in pattern_rows:\n          if is_three_section_pattern(input_grid[row_index]):\n                destination_index = 10  # Fixed destination index\n                output_grid = duplicate_row(output_grid, row_index, destination_index)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8514,
    "candidates_token_count": 1597,
    "total_token_count": 10111,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 29.526943
}