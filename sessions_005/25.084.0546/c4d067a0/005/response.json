{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying and duplicating specific pattern rows.\n\nThe transformation identifies \"pattern rows\" based on specific criteria:\n- Rows with alternating color sequences (e.g., 8 4 8 4).\n- Rows with solid color blocks adjacent to alternating color sequences.\n- Rows with a specific three-section pattern: starting and ending with 1, with two distinct sections of other colors in between (e.g., 1 3 3 1 1 1 4 4 1).  These are duplicated multiple times.\n\nThese pattern rows are duplicated and inserted at specific locations in the grid. The location is determined based on the pattern type and its initial position in the grid.\n\"\"\"\n\nimport numpy as np\n\ndef find_pattern_rows(grid):\n    \"\"\"Identifies pattern rows based on alternating colors or the three-section pattern.\"\"\"\n    pattern_rows = []\n    height, width = grid.shape\n    for i in range(height):\n        row = grid[i]\n        if is_alternating(row) or is_three_section_pattern(row):\n            pattern_rows.append(i)\n    return pattern_rows\n\ndef is_alternating(row):\n    \"\"\"Checks if a row has an alternating color pattern (e.g., A B A B).\"\"\"\n    if len(row) < 2:\n        return False\n    first_color = row[0]\n    second_color = None\n    for i, cell in enumerate(row):\n        if i == 0: continue\n        if cell != first_color:\n            second_color = cell\n            break\n    if second_color is None: return False\n    for i, cell in enumerate(row):\n        if i % 2 == 0:\n            if cell != first_color:\n                return False\n        else:\n            if cell != second_color:\n                return False\n    return True\n\ndef is_three_section_pattern(row):\n    \"\"\"Checks if a row follows the three-section pattern (e.g., 1 3 3 1 1 1 4 4 1).\"\"\"\n    if len(row) < 5 or row[0] != 1 or row[-1] != 1:  # Must start and end with 1\n        return False\n\n    # Find the first section boundary\n    first_section_end = -1\n    for i in range(1, len(row)):\n        if row[i] == 1 and row[i-1] != 1:\n            first_section_end = i\n            break\n    if first_section_end == -1: return False\n\n    #find the second section boundary\n    second_section_end = -1\n    for i in range(first_section_end+1,len(row)):\n        if row[i] != 1:\n          second_section_end = i\n          break\n\n    if second_section_end == -1: return False #all 1's\n\n    first_color = -1\n    #check colors are different\n    for i in range(0, first_section_end):\n      if row[i] != 1:\n        first_color = row[i]\n        break\n\n    second_color = -1\n    for i in range(second_section_end, len(row)):\n      if row[i] != 1:\n        second_color = row[i]\n        break\n\n    if first_color == second_color or first_color == -1 or second_color == -1: return False\n\n    return True\n\ndef duplicate_row(grid, source_row_index, insert_index):\n    \"\"\"Duplicates a row and inserts it at the insert index, shifting existing rows.\"\"\"\n    height, width = grid.shape\n\n    # Create a new grid with an additional row\n    new_grid = np.insert(grid, insert_index, grid[source_row_index], axis=0)\n    return new_grid\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid based on identified patterns, duplicating rows.\"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    pattern_rows = find_pattern_rows(input_grid)\n\n    # Offset to account for inserted rows\n    offset = 0\n\n    for row_index in pattern_rows:\n\n        if is_alternating(input_grid[row_index]):\n            # Example 1 and 2: Duplicate alternating rows and place after the original alternating sequence\n\n            insert_index = row_index + 1 + offset\n\n            output_grid = duplicate_row(output_grid, row_index + offset, insert_index)\n            offset += 1 # Increment offset after inserting a row\n\n            #Handle adjacent solid block row, insert below inserted alternating\n            if row_index + 1 < height and not is_alternating(input_grid[row_index + 1]):\n                output_grid = duplicate_row(output_grid, row_index + 1 + offset, insert_index + 1)\n                offset += 1 # Increment offset after inserting a row\n\n        elif is_three_section_pattern(input_grid[row_index]):\n            #find other three section patterns\n            other_three_section = []\n            for i in range(height):\n              if i != row_index and is_three_section_pattern(input_grid[i]):\n                other_three_section.append(i)\n            insert_index = row_index + 1 + offset\n            output_grid = duplicate_row(output_grid, row_index + offset, insert_index) #insert after original\n            offset +=1\n\n            for other_row in other_three_section:\n              insert_index = other_row + 1 + offset\n              output_grid = duplicate_row(output_grid, other_row + offset, insert_index)\n              offset += 1\n\n\n    return output_grid\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12635,
    "candidates_token_count": 1355,
    "total_token_count": 13990,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 14.11923
}