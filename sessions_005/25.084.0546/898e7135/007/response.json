{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by identifying objects, determining a new background color,\nand rearranging the objects within a new grid size based on the original positioning\nof objects of color 3, while preserving the relative sizes and positions of other colored objects.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"Find contiguous blocks of the same color.\"\"\"\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    def dfs(row, col, color, obj):\n        if (\n            row < 0\n            or row >= grid.shape[0]\n            or col < 0\n            or col >= grid.shape[1]\n            or visited[row, col]\n            or grid[row, col] != color\n        ):\n            return\n        visited[row, col] = True\n        obj.append((row, col))\n        dfs(row + 1, col, color, obj)\n        dfs(row - 1, col, color, obj)\n        dfs(row, col + 1, color, obj)\n        dfs(row, col - 1, color, obj)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if not visited[row, col]:\n                obj = []\n                dfs(row, col, grid[row, col], obj)\n                if obj: # avoid empty objects\n                   objects.append((grid[row, col], obj))\n    return objects\n\ndef get_bounding_box(obj):\n    \"\"\"Calculates the bounding box for set of pixels\"\"\"\n    min_row = min(p[0] for p in obj)\n    min_col = min(p[1] for p in obj)\n    max_row = max(p[0] for p in obj)\n    max_col = max(p[1] for p in obj)\n    return min_row, min_col, max_row, max_col\n\ndef get_output_size(input_grid):\n    \"\"\"Determine output grid size based on longest runs of color 3 and object sizes\"\"\"\n    grid = np.array(input_grid)\n    objects = get_objects(grid)\n\n    # Find longest vertical and horizontal runs of 3s if they exists\n    max_vertical = 0\n    max_horizontal = 0\n\n    for color, obj_pixels in objects:\n       if color == 3:\n           min_row, min_col, max_row, max_col = get_bounding_box(obj_pixels)\n           max_vertical = max(max_vertical, max_row - min_row + 1)\n           max_horizontal = max(max_horizontal, max_col - min_col+1)\n           \n\n    # Add extra space for other objects.  This is a heuristic and might need adjustment.\n    extra_height = 0\n    extra_width = 0\n    for color, obj_pixels in objects:\n        if color != 3:  # Don't double-count the 3s\n            min_row, min_col, max_row, max_col = get_bounding_box(obj_pixels)\n            extra_height = max(extra_height, max_row - min_row + 1)\n            extra_width = max(extra_width, max_col-min_col + 1)\n\n    if max_vertical == 0: # color 3 not found, return the input size\n        height = input_grid.shape[0]\n        width = input_grid.shape[1]\n\n    else: # example 2 case\n        #find the biggest object by color\n        color_sizes = {}\n        for color, obj_pixels in objects:\n            if color !=3:\n                min_row, min_col, max_row, max_col = get_bounding_box(obj_pixels)\n                height = max_row - min_row + 1\n                width = max_col - min_col + 1\n                if color not in color_sizes:\n                    color_sizes[color] = (height, width)\n                else:\n                    color_sizes[color] = (max(color_sizes[color][0],height),max(color_sizes[color][1], width) )\n\n        height = max_vertical\n        width = max_horizontal\n\n        for color in color_sizes:\n           height = max(color_sizes[color][0] + max_vertical , height)\n           width = max(color_sizes[color][1] + max_horizontal , width )\n        height += extra_height + 2\n        width += extra_width + 2\n\n    return height, width\n\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    objects = get_objects(input_grid)\n\n    # Determine output size and background\n    output_height, output_width = get_output_size(input_grid)\n\n    # Determine background color and removed colors.\n    background_color = 2  # Default to 2\n    removed_colors = {0, 7}\n    if any(c == 3 for c, _ in objects):\n        background_color = 3\n        removed_colors = {0, 8}\n\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    # Place objects, preserving relative positions and sizes.\n    for color, obj_pixels in objects:\n        if color not in removed_colors:\n            min_row, min_col, max_row, max_col = get_bounding_box(obj_pixels)\n            obj_height = max_row - min_row + 1\n            obj_width = max_col - min_col + 1\n\n            if background_color == 3: # use color 3 objects as base\n                # find the object 3 with largest area\n                color3_max_area = 0\n                color3_top_left = (0,0)\n\n                for color2, obj_pixels2 in objects:\n                    if color2 == 3:\n                        min_row2, min_col2, max_row2, max_col2 = get_bounding_box(obj_pixels2)\n                        area = (max_row2-min_row2) * (max_col2-min_col2)\n                        if area > color3_max_area:\n                            color3_max_area = area\n                            color3_top_left = (min_row2, min_col2)\n\n                # place relative to color 3 top left\n                new_row = min_row - color3_top_left[0]\n                new_col = min_col - color3_top_left[1]\n\n                # make sure it does not overflow\n                new_row = min(new_row, output_height-obj_height)\n                new_col = min(new_col, output_width - obj_width)\n\n\n                for r in range(obj_height):\n                    for c in range(obj_width):\n                        if 0 <= new_row + r < output_height and 0 <= new_col + c < output_width:\n                            output_grid[new_row + r, new_col + c] = color\n\n            else:  # Example 1 logic (background is 2)\n                #find the biggest object with color 2\n                color2_max_area = 0\n                color2_top_left = (0,0)\n\n                for color2, obj_pixels2 in objects:\n                    if color2 == 2:\n                        min_row2, min_col2, max_row2, max_col2 = get_bounding_box(obj_pixels2)\n                        area = (max_row2-min_row2) * (max_col2-min_col2)\n                        if area>color2_max_area:\n                            color2_max_area = area\n                            color2_top_left = (min_row2,min_col2)\n\n                # place relative to color 2 objects\n                new_row = min_row - color2_top_left[0]\n                new_col = min_col - color2_top_left[1]\n                for r in range(obj_height):\n                    for c in range(obj_width):\n                            if 0 <= new_row + r < output_height and 0 <= new_col + c < output_width:\n                                output_grid[new_row + r, new_col + c] = color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13596,
    "candidates_token_count": 1976,
    "total_token_count": 15572,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 26.968619
}