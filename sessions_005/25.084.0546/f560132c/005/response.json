{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify Objects: Find all contiguous regions (objects) of non-zero pixels in the input grid. Two pixels are considered part of the same object if they share a side (not just a corner).\n2. Bounding Boxes: For each identified object, determine its bounding box. The bounding box is the smallest rectangle (defined by `min_row`, `min_col`, `max_row`, `max_col`) that completely encloses the object.\n3. Color Mapping:  Map the original color of each object to a new color based on the following rules:\n    *   Red (2) becomes Blue (1)\n    *   Blue (1) remains Blue (1)\n    * Gray (5) remains Gray (5)\n    * Orange (7) becomes Gray (5)\n    *   Azure (8) remains Azure (8)\n    *   Maroon (9) remains Maroon (9)\n    *   Yellow (4) becomes Maroon(9)\n    *   Green (3) becomes Azure (8)\n    *   If an object's color is not in this mapping, it is mapped to 0 (white)\n4. Arrange Objects: Create an output grid by arranging bounding boxes of the objects. Objects are placed in rows. The total width of a row should not exceed 8. If the next object can fit, combine it by expanding the row height to fit and concatenating the object to the row, otherwise move to the next row.\n5. Combine Rows - combine rows vertically to construct final output.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"Find contiguous regions of non-zero pixels.\"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_pixels):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or\n                visited[r, c] or grid[r, c] != color):\n            return\n        visited[r, c] = True\n        obj_pixels.append((r, c))\n        dfs(r + 1, c, color, obj_pixels)\n        dfs(r - 1, c, color, obj_pixels)\n        dfs(r, c + 1, color, obj_pixels)\n        dfs(r, c - 1, color, obj_pixels)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_pixels = []\n                dfs(r, c, grid[r, c], obj_pixels)\n                objects.append(obj_pixels)\n    return objects\n\ndef bounding_box(obj_pixels):\n    \"\"\"Calculate the bounding box of a set of pixels.\"\"\"\n    min_r = min(p[0] for p in obj_pixels)\n    max_r = max(p[0] for p in obj_pixels)\n    min_c = min(p[1] for p in obj_pixels)\n    max_c = max(p[1] for p in obj_pixels)\n    return min_r, min_c, max_r, max_c\n\ndef color_map(input_color):\n    \"\"\"Maps input colors to output colors.\"\"\"\n    mapping = {\n        2: 1,\n        1: 1,\n        5: 5,\n        7: 5,\n        8: 8,\n        9: 9,\n        4: 9,\n        3: 8\n    }\n    return mapping.get(input_color, 0) # Default to 0 (white) if not in mapping\n\n\ndef transform(input_grid):\n    # Convert to numpy array\n    input_grid = np.array(input_grid)\n\n    # 1. Identify Objects\n    objects = get_objects(input_grid)\n\n    # 2. Bounding Boxes and 3. Color Mapping\n    bbox_list = []\n    for obj in objects:\n        min_r, min_c, max_r, max_c = bounding_box(obj)\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        input_color = input_grid[obj[0]]  # Get color from the first pixel of the object\n        output_color = color_map(input_color)\n        bbox_list.append((min_r, min_c, height, width, output_color))\n\n    # 4. Arrange Objects in Output Grid\n    output_grid = []\n    current_row = []\n    current_row_width = 0\n\n    for min_r, min_c, height, width, output_color in bbox_list:\n        if current_row and current_row_width + width > 8:\n            output_grid.append(current_row)\n            current_row = []\n            current_row_width = 0\n\n        if not current_row:\n          row_height = height\n        else:\n          row_height = max(height, current_row.shape[0])\n\n        new_row = np.full((row_height, width), output_color, dtype=int)\n\n        if not current_row:\n            current_row = new_row\n        else:\n            # Pad the shorter row with 0s to match heights before concatenation\n            if current_row.shape[0] < row_height:\n                padding = np.zeros((row_height - current_row.shape[0], current_row.shape[1]), dtype=int)\n                current_row = np.concatenate((current_row, padding), axis=0)\n            elif new_row.shape[0] < row_height:\n                padding = np.zeros((row_height - new_row.shape[0], new_row.shape[1]), dtype=int)\n                new_row = np.concatenate((new_row, padding), axis=0)\n\n            current_row = np.concatenate((current_row, new_row), axis=1)\n        current_row_width += width\n\n    if current_row.size > 0:  # Append the last row if it's not empty\n        output_grid.append(current_row)\n\n\n    # 5. Combine the rows vertically.\n    if output_grid:  # Check if output_grid is not empty\n      output_grid = np.vstack(output_grid)\n    else: # Return an empty grid.\n      return []\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7049,
    "candidates_token_count": 1509,
    "total_token_count": 8558,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 19.229098
}