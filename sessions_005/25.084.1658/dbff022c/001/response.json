{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies 'H' shapes made of a single color in the input grid. An 'H' shape \nis defined as a contiguous object of a single color that completely encloses \nexactly two distinct regions of white (color 0) pixels. \n\nThe transformation rule fills these enclosed white regions based on the color \nof the 'H' shape and its aspect ratio:\n- Green (3) H-shape: Fill with Green (3).\n- Azure (8) H-shape: Fill with Blue (1).\n- Red (2) H-shape: Fill with Orange (7).\n- Yellow (4) H-shape:\n    - If height > width: Fill with Magenta (6).\n    - If width > height: Fill with Gray (5).\n    - If height == width: No fill.\n- H-shapes of other colors (e.g., Orange 7, Gray 5) are not filled.\n- Objects that are not H-shapes (do not enclose exactly two white regions) are \n  left unchanged.\n- White regions not enclosed by a single object are left unchanged.\n\nEnclosure check: A white region is considered enclosed by an object if it does \nnot touch the grid boundary and all its adjacent (4-directionally) non-white \nneighbors belong to that single object.\n\"\"\"\n\ndef find_objects_and_map(grid, H, W):\n    \"\"\"\n    Finds all contiguous non-white objects using 8-way connectivity.\n    Returns:\n        objects (dict): {object_id: {'coords': set((r,c)), 'color': int}}\n        object_map (np.array): Grid where each cell contains the object_id it belongs to, or -1.\n    \"\"\"\n    object_map = np.full((H, W), -1, dtype=int)\n    objects = {}\n    visited = np.zeros((H, W), dtype=bool)\n    object_id_counter = 0\n\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != 0:\n                color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_id = object_id_counter\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    object_map[row, col] = current_id\n                    \n                    # 8-way connectivity for object pixels\n                    for dr in range(-1, 2):\n                        for dc in range(-1, 2):\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < H and 0 <= nc < W and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                objects[current_id] = {'coords': component_coords, 'color': color}\n                object_id_counter += 1\n                \n    return objects, object_map\n\ndef find_enclosed_white_regions(grid, H, W, object_map):\n    \"\"\"\n    Finds white regions enclosed by single objects.\n    Uses 4-way connectivity for white regions and neighbor checking.\n    Returns:\n        enclosed_regions_by_object (dict): {object_id: [set((r,c)), ...]}\n    \"\"\"\n    visited_white = np.zeros((H, W), dtype=bool)\n    enclosed_regions_by_object = {} \n\n    for r in range(H):\n        for c in range(W):\n            if not visited_white[r, c] and grid[r, c] == 0:\n                white_component_coords = set()\n                q = deque([(r, c)])\n                visited_white[r, c] = True\n                is_on_boundary = False\n                neighbor_object_ids = set()\n\n                component_queue_for_neighbor_check = deque([(r,c)]) # Keep track for neighbor check after finding component\n\n                while q:\n                    row, col = q.popleft()\n                    white_component_coords.add((row, col))\n\n                    if row == 0 or row == H - 1 or col == 0 or col == W - 1:\n                        is_on_boundary = True # Mark but continue BFS to find full component\n\n                    # 4-way connectivity for white region pixels\n                    for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < H and 0 <= nc < W:\n                            if grid[nr, nc] == 0:\n                                if not visited_white[nr, nc]:\n                                    visited_white[nr, nc] = True\n                                    q.append((nr, nc))\n                                    component_queue_for_neighbor_check.append((nr,nc))\n                            # else: # Non-white neighbor, check handled below\n                                \n                # After finding the component, check its neighbors if not on boundary\n                if not is_on_boundary:\n                    unique_neighbor_id = -1\n                    is_enclosed_"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2322,
    "candidates_token_count": 1252,
    "total_token_count": 3574,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 205.11933
}