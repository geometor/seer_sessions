{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies 'cross' shaped objects in the input grid and expands them into solid squares of the same color in the output grid. The expanded square is then shifted based on the original position of the cross.\n\"\"\"\n\nimport numpy as np\n\ndef find_cross_center(grid):\n    \"\"\"Finds the center of cross-shaped objects in the grid.\"\"\"\n    centers = []\n    rows, cols = grid.shape\n\n    def is_cross_like(r, c, color):\n\n        if not (0 <= r < rows and 0 <= c < cols):\n            return False\n        if grid[r,c] != color:\n            return False\n\n        # check counts of rows and cols\n        row_counts = {}\n        col_counts = {}\n\n        pixels = []\n        visited = set()\n        def dfs(row, col):\n          nonlocal row_counts, col_counts, pixels\n          if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] != color:\n            return\n          visited.add((row,col))\n          pixels.append((row,col))\n          row_counts[row] = row_counts.get(row,0) + 1\n          col_counts[col] = col_counts.get(col,0) + 1\n          for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(row + dr, col + dc)\n\n        dfs(r,c)\n        \n        # modification: allow more than 5\n        if len(pixels) < 5:\n          return False\n        \n        if len(row_counts) >= 3 and len(col_counts) >= 3:\n           # check for center\n           has_center = False\n           for row in row_counts:\n               for col in col_counts:\n                   if (row,col) in pixels:\n                       # count neighbors:\n                       neighbor_count = 0\n                       for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                           nrow, ncol = row + dr, col + dc\n                           if 0 <= nrow < rows and 0 <= ncol < cols and (nrow, ncol) in pixels:\n                               neighbor_count+=1\n                       if neighbor_count >=3:\n                          has_center = True\n                          break\n               if has_center:\n                 break\n\n           return has_center\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if is_cross_like(r, c, grid[r,c]):\n                \n                pixels = []\n                visited = set()\n                def dfs(row, col,color):\n                    if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] != color:\n                        return\n                    visited.add((row,col))\n                    pixels.append((row,col))\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        dfs(row + dr, col + dc, color)\n                dfs(r,c,grid[r,c])\n\n                rows, cols = zip(*pixels)\n                centers.append( ( int(round(np.mean(rows))), int(round(np.mean(cols))))    )\n\n    return centers\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies distinct objects in the grid.\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, obj):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        obj.append((r, c))\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(r + dr, c + dc, color, obj)\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != 0:\n                obj = []\n                dfs(r, c, grid[r, c], obj)\n                objects.append(obj)\n    return objects\n\ndef is_cross_shaped(grid, object_pixels):\n    \"\"\"\n    Checks if an object has a 'cross' shape.\n    \"\"\"\n    if len(object_pixels) < 5: # optimization: a cross needs at least 5 pixels\n      return False\n\n    rows, cols = zip(*object_pixels)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    # check counts of rows and cols\n    row_counts = {}\n    col_counts = {}\n\n    for r,c in object_pixels:\n      row_counts[r] = row_counts.get(r,0) + 1\n      col_counts[c] = col_counts.get(c,0) + 1\n      \n    if len(row_counts) >= 3 and len(col_counts) >= 3:\n        # check for center\n        has_center = False\n        for row in row_counts:\n            for col in col_counts:\n                if (row,col) in object_pixels:\n                    # count neighbors:\n                    neighbor_count = 0\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nrow, ncol = row + dr, col + dc\n                        if 0 <= nrow < len(grid) and 0 <= ncol < len(grid[0]) and (nrow, ncol) in object_pixels:\n                            neighbor_count+=1\n                    if neighbor_count >=3:\n                        has_center = True\n                        break\n            if has_center:\n                break\n\n        return has_center\n  \n    return False\n\n\ndef expand_to_square(object_pixels):\n    \"\"\"\n    Expands the object to its bounding square.\n    \"\"\"\n    rows, cols = zip(*object_pixels)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    square_pixels = []\n    for r in range(min_row, max_row + 1):\n        for c in range(min_col, max_col + 1):\n            square_pixels.append((r, c))\n    return square_pixels\n\ndef calculate_shift(input_grid, cross_center):\n    \"\"\"Calculates target center based on an alignment strategy.\"\"\"\n    rows, cols = input_grid.shape\n    r, c = cross_center\n\n    # find closest non-zero edge in input\n    #   if no non-zero edge exists, use grid edge\n    \n    # for now, return cross_center - but eventually we need to calculate a shift\n\n    return cross_center\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n    \n    # Find objects\n    objects = find_objects(input_grid)\n    \n    # Process each object\n    for obj in objects:\n        color = input_grid[obj[0]]\n        if is_cross_shaped(input_grid, obj):\n            # Expand to square if cross-shaped\n            square = expand_to_square(obj)\n            # find the center of cross\n            cross_center = find_cross_center(input_grid)\n            if len(cross_center) > 0: # there should only ever be 1\n              target_center = calculate_shift(input_grid, cross_center[0])\n\n\n              # shift the expanded object\n              row_shift = target_center[0] - cross_center[0]\n              col_shift = target_center[1] - cross_center[1]\n\n              for r, c in square:\n                  shifted_r, shifted_c = r + row_shift, c + col_shift\n                  if 0 <= shifted_r < output_grid.shape[0] and 0 <= shifted_c < output_grid.shape[1]:\n                    output_grid[shifted_r, shifted_c] = color\n        # else skip - no other objects need to be transformed\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13323,
    "candidates_token_count": 2020,
    "total_token_count": 15343,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 22.887661
}