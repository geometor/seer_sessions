"""
The transformation rule identifies all non-zero pixels (objects) in the input grid. Each object's row and column serve as reflection axes. The output grid is generated by reflecting the input grid across these axes. For each output pixel, the algorithm iterates through each input object, calculates the mirrored position, and if the mirrored position in the input is non-zero, the value from the input grid's mirrored position is copied to the output.
"""

import numpy as np

def find_objects(grid):
    """Finds the coordinates and values of all non-zero pixels."""
    grid = np.array(grid)
    non_zero_pixels = np.nonzero(grid)
    objects = []
    for row, col in zip(non_zero_pixels[0], non_zero_pixels[1]):
        objects.append(
            {
                "row": int(row),
                "col": int(col),
                "value": int(grid[row, col]),
            }
        )
    return objects

def transform(input_grid):
    """Transforms the input grid according to the reflection rule."""
    input_grid = np.array(input_grid)
    output_grid = np.zeros_like(input_grid)
    input_objects = find_objects(input_grid)
    rows, cols = input_grid.shape

    # Iterate through each pixel in the output grid
    for out_row in range(rows):
        for out_col in range(cols):
            # Iterate through each object in the input grid
            for obj in input_objects:
                # Calculate mirrored position
                mirrored_row = obj["row"] - (out_row - obj["row"])
                mirrored_col = obj["col"] - (out_col - obj["col"])

                # Check if mirrored position is within bounds
                if 0 <= mirrored_row < rows and 0 <= mirrored_col < cols:
                    # If the mirrored position in input is non-zero, copy the value
                    if input_grid[mirrored_row, mirrored_col] != 0:
                        output_grid[out_row, out_col] = input_grid[mirrored_row, mirrored_col]
                        break # Prioritize objects in order

    return output_grid.tolist()