facts:
  - task_id: "ReflectAndSym"
  - example_1:
      input:
        objects:
          - { row: 0, col: 4, value: 6 }
          - { row: 0, col: 5, value: 6 }
          - { row: 3, col: 3, value: 2 }
          - { row: 3, col: 4, value: 3 }
          - { row: 3, col: 5, value: 7 }
          - { row: 3, col: 6, value: 9 }
          - { row: 3, col: 7, value: 5 }
          - { row: 3, col: 8, value: 1 }
          - { row: 3, col: 9, value: 8 }
          - { row: 4, col: 0, value: 4 }
          - { row: 5, col: 0, value: 4 }
        unique_colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        height: 10
        width: 10
      output:
        objects:  # Many objects; see tool output for full list.
          - { row: 0, col: 0, value: 2 }
          # ... (rest of the objects)
        unique_colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        height: 10
        width: 10
      observations: |
        The output grid appears to be generated by reflecting the input grid both horizontally and vertically.
        The reflection seems to consider all non-zero pixels as sources of reflection. There are multiple reflection
        axis present.
  - example_2:
      input:
        objects:
          - { row: 0, col: 4, value: 7 }
          - { row: 0, col: 5, value: 7 }
          - { row: 4, col: 4, value: 8 }
          - { row: 4, col: 9, value: 9 }
          - { row: 5, col: 4, value: 4 }
          - { row: 5, col: 9, value: 9 }
          - { row: 6, col: 4, value: 6 }
          - { row: 7, col: 4, value: 3 }
          - { row: 8, col: 4, value: 2 }
          - { row: 9, col: 4, value: 1 }
        unique_colors: [0, 1, 2, 3, 4, 6, 7, 8, 9]
        height: 10
        width: 10
      output:
        objects: # Many objects.
          - {row: 0, col: 0, value: 8}
          # ...
        unique_colors: [0, 1, 2, 3, 4, 6, 7, 8, 9]
        height: 10
        width: 10
      observations: |
         Similar to example 1, horizontal and vertical reflection seem to be the key transformations. The pattern
         is complex, and it appears as if reflections interact with each other when they overlap.
  - example_3:
      input:
        objects:
          - { row: 1, col: 0, value: 8 }
          - { row: 1, col: 2, value: 3 }
          - { row: 2, col: 0, value: 8 }
          - { row: 2, col: 2, value: 2 }
          - { row: 3, col: 2, value: 4 }
        unique_colors: [0, 2, 3, 4, 8]
        height: 4
        width: 4
      output:
        objects:
          - {row: 0, col: 0, value: 2}
          # ...
        unique_colors: [0, 2, 3, 4, 8]
        height: 4
        width: 4
      observations: |
        This smaller example also shows reflection.  It's crucial to understand how the values are mirrored across
        the axes created by the non-zero input pixels.