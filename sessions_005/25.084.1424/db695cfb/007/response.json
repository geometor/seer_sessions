{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  **Initialization**: Create an output grid as a copy of the input grid.\n2.  **Identify Roles**:\n    *   Find all blue pixels (color 1); these are the 'sources'.\n    *   Find all magenta pixels (color 6); these are the potential 'destinations'.\n    *   Determine the 'background color' by finding the most frequent color in the input grid, excluding blue (1) and magenta (6). If only blue/magenta exist or the grid is empty otherwise, use white (0) as the background.\n3.  **Determine Actual Destinations**:\n    *   If any magenta pixels exist, they are the 'actual destinations'.\n    *   If no magenta pixels exist, the blue pixels themselves serve as the 'actual destinations' for each other (a blue pixel cannot be its own destination).\n4.  **Path Generation and Drawing**:\n    *   Iterate through every unique pair of a source pixel `S` and an actual destination pixel `D`.\n    *   If `S` is the same pixel as `D`, skip this pair.\n    *   Set the `path_color` to blue (1).\n    *   Calculate a path sequence from `S` towards `D`:\n        *   Start at `current_pos = S`. Maintain a set `visited_on_this_path` containing only `S`.\n        *   While true (loop broken internally):\n            *   Find all valid 8-directional neighbors of `current_pos`, sorted by row then column index.\n            *   Calculate the Manhattan distance from each neighbor to `D`.\n            *   Find the minimum distance (`min_dist`) among these neighbors.\n            *   Identify all neighbors (`min_dist_neighbors`) that achieve this `min_dist`.\n            *   Apply tie-breaking to select the `next_step_info` (containing position and move delta) from `min_dist_neighbors`:\n                1.  Prefer neighbors reached by a diagonal move (change in both row and column) over axial moves (change in only row or column).\n                2.  If ties remain within diagonal or axial groups, the pre-sorting by row/column determines the choice (smallest row, then smallest column).\n            *   Get the selected `next_pos` from `next_step_info`.\n            *   If `next_pos` *is* the destination `D`, stop calculating this path segment (reached destination).\n            *   If `next_pos` is already in `visited_on_this_path`, stop calculating this path segment (cycle detected).\n            *   Mark `next_pos`: If the pixel at `next_pos` in the *current output grid* has the `background_color`, change its color to `path_color` (blue, 1).\n            *   Add `next_pos` to `visited_on_this_path`.\n            *   Update `current_pos = next_pos`.\n            *   If no valid neighbors were found (e.g., current_pos is surrounded or only neighbor is D which was handled), stop this path segment.\n5.  **Final Output**: Return the modified output grid after processing all source-destination pairs.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    return list(zip(*np.where(grid == color)))\n\ndef get_background_color(grid):\n    \"\"\"Finds the most common color excluding blue (1) and magenta (6). Defaults to 0.\"\"\"\n    counts = Counter(grid.flatten())\n    if 1 in counts: del counts[1]\n    if 6 in counts: del counts[6]\n    if not counts: return 0 # Default to white if only 1/6 or empty\n    # Check if 0 exists and is most common, otherwise return the most common\n    if 0 in counts and counts[0] >= counts.most_common(1)[0][1]:\n        return 0\n    elif counts:\n         return counts.most_common(1)[0][0]\n    else: # Should only happen on truly empty grid after filtering\n         return 0\n\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points (tuples).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid 8-directional neighbors for a given coordinate.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              ((neighbor_row, neighbor_col), (delta_row, delta_col)).\n              Sorted by row, then column index.\n    \"\"\"\n    neighbors = []\n    # Order matters for tie-breaking: check smaller row/col first implicitly\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append(((nr, nc), (dr, dc)))\n    # Sort neighbors for consistent tie-breaking: row, then column\n    neighbors.sort(key=lambda x: (x[0][0], x[0][1]))\n    return neighbors\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the path-drawing transformation based on blue sources and magenta/blue destinations.\n    Paths are drawn with blue (1), avoiding cycles and stopping before the destination.\n    \"\"\"\n    # 1. Initialization\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify Roles\n    source_pixels = find_pixels(input_grid, 1) # Blue\n    magenta_pixels = find_pixels(input_grid, 6) # Magenta\n    background_color = get_background_color(input_grid)\n\n    # 3. Determine Actual Destinations\n    if magenta_pixels:\n        destination_pixels = magenta_pixels\n    else:\n        # If no magenta, blue pixels target each other\n        destination_pixels = source_pixels\n\n    # Exit early if no sources or destinations to pair with\n    if not source_pixels or not destination_pixels:\n        return output_grid\n    # Specific check for blue->blue case where only one blue exists\n    if not magenta_pixels and len(source_pixels) <= 1:\n        return output_grid\n\n    # 4. Path Generation and Drawing\n    path_color = 1 # Paths are always blue\n\n    for start_pos in source_pixels:\n        for end_pos in destination_pixels:\n            # 4a. Skip if source is the same as destination (relevant for blue->blue)\n            if start_pos == end_pos:\n                continue\n\n            # 4c. Calculate path sequence from S towards D\n            current_pos = start_pos\n            visited_on_this_path = {start_pos} # Track visited for cycle detection\n\n            while True:\n                # Find neighbors and calculate distances to the end_pos\n                neighbors_info = get_neighbors(current_pos[0], current_pos[1], height, width)\n\n                valid_next_steps = []\n                min_dist = float('inf')\n\n                for neighbor_pos, move_delta in neighbors_info:\n                    # Calculate distance for all neighbors\n                    dist = manhattan_distance(neighbor_pos, end_pos)\n                    valid_next_steps.append({'pos': neighbor_pos, 'delta': move_delta, 'dist': dist})\n                    # Find minimum distance among potential next steps\n                    # Important: Don't filter out end_pos here, let tie-breaking handle it if needed\n                    # Only exclude it from being a *step* later.\n                    if neighbor_pos != current_pos: # Avoid comparing distance from current pos to itself if somehow included\n                         min_dist = min(min_dist, dist)\n\n\n                # If no valid moves possible (e.g., trapped)\n                if not valid_next_steps:\n                    break\n\n                # Filter neighbors with the minimum distance\n                min_dist_neighbors = [n for n in valid_next_steps if n['dist'] == min_dist]\n\n                # Handle cases where the only min_dist neighbor is the current position itself (shouldn't happen with get_neighbors)\n                # or if min_dist_neighbors is empty (should also not happen if valid_next_steps wasn't empty)\n                if not min_dist_neighbors:\n                     break # Cannot proceed\n\n                # Tie-breaking logic\n                diagonal_moves = [n for n in min_dist_neighbors if abs(n['delta'][0]) == 1 and abs(n['delta'][1]) == 1]\n                axial_moves = [n for n in min_dist_neighbors if abs(n['delta'][0]) != abs(n['delta'][1])] # Includes 0,1 and 1,0 moves\n\n                next_step_info = None\n                if diagonal_moves:\n                    # Select the first diagonal move based on pre-sorted neighbors (row, then col)\n                    next_step_info = diagonal_moves[0]\n                elif axial_moves:\n                     # Select the first axial move based on pre-sorted neighbors (row, then col)\n                    next_step_info = axial_moves[0]\n                else:\n                     # This might happen if the only min_dist neighbor is the destination itself,\n                     # and it's neither diagonal nor axial relative to current_pos (e.g. distance 1 away)\n                     # Or if multiple neighbors have same min dist but none fit diagonal/axial cleanly - use first overall.\n                     if min_dist_neighbors:\n                         next_step_info = min_dist_neighbors[0]\n                     else:\n                         break # Cannot determine next step\n\n                if next_step_info is None: # Safety break\n                    break\n\n                next_pos = next_step_info['pos']\n\n                # Termination condition: Stop if the chosen next step *is* the destination\n                if next_pos == end_pos:\n                    break\n\n                # Cycle detection: Stop if we are about to move to a previously visited pixel on this path\n                if next_pos in visited_on_this_path:\n                    break\n\n                # Mark the pixel if it's background color\n                # Check the *current* state of the output grid\n                if output_grid[next_pos] == background_color:\n                    output_grid[next_pos] = path_color # Use blue (1)\n\n                # Update path tracking\n                visited_on_this_path.add(next_pos)\n                current_pos = next_pos\n\n\n    # 5. Final Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8484,
    "candidates_token_count": 2487,
    "total_token_count": 10971,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.385367
}