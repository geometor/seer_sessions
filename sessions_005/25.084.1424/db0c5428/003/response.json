{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_background_color(grid):\n  \"\"\"\n  Determines the background color of the grid.\n  Assumes the background color is the color present at the corners.\n  Uses the top-left corner.\n  \n  Args:\n    grid: A numpy array representing the input grid.\n  \n  Returns:\n    The integer color value of the background.\n  \"\"\"\n  return grid[0, 0]\n\ndef find_pattern_bbox(grid, bg_color):\n  \"\"\"\n  Finds the bounding box of non-background pixels.\n  \n  Args:\n    grid: A numpy array representing the input grid.\n    bg_color: The background color integer.\n  \n  Returns:\n    A tuple (min_r, max_r, min_c, max_c) representing the bounding box \n    of non-background pixels, or None if no non-background pixels are found.\n  \"\"\"\n  # Find coordinates of all pixels that are not the background color\n  non_bg_pixels = np.where(grid != bg_color)\n  \n  # If there are no non-background pixels, return None\n  if len(non_bg_pixels[0]) == 0:\n    return None \n    \n  # Determine the minimum and maximum row and column indices\n  min_r = np.min(non_bg_pixels[0])\n  max_r = np.max(non_bg_pixels[0])\n  min_c = np.min(non_bg_pixels[1])\n  max_c = np.max(non_bg_pixels[1])\n  \n  return min_r, max_r, min_c, max_c\n\ndef extract_pattern(grid, bbox):\n   \"\"\"\n   Extracts the subgrid (pattern) defined by the bounding box.\n   \n   Args:\n     grid: A numpy array representing the input grid.\n     bbox: A tuple (min_r, max_r, min_c, max_c) defining the bounding box.\n     \n   Returns:\n     A numpy array representing the extracted pattern.\n   \"\"\"\n   min_r, max_r, min_c, max_c = bbox\n   # Slice the grid using the bounding box coordinates\n   # Note: slicing is exclusive of the end index, so add 1 to max_r and max_c\n   return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef place_pattern(output_grid, pattern, r_start, c_start):\n    \"\"\"\n    Places a pattern onto the output grid at the specified top-left corner.\n    Overwrites existing pixels in the output grid. Handles partial placements\n    if the pattern goes out of bounds, though the calling logic should try\n    to prevent completely out-of-bounds placements.\n    \n    Args:\n      output_grid: The numpy array representing the grid to place the pattern onto.\n      pattern: The numpy array representing the pattern to place.\n      r_start: The starting row index for the top-left corner of the placement.\n      c_start: The starting column index for the top-left corner of the placement.\n    \"\"\"\n    pH, pW = pattern.shape\n    H, W = output_grid.shape\n    \n    # Calculate the actual end row and column, respecting grid boundaries\n    r_end = min(r_start + pH, H)\n    c_end = min(c_start + pW, W)\n    \n    # Calculate the height and width of the slice to take from the pattern\n    # This handles cases where the pattern placement goes partially off the grid\n    slice_pH = r_end - r_start\n    slice_pW = c_end - c_start\n\n    # Ensure we only try to place if the starting indices are within bounds\n    # and the calculated slice dimensions are positive\n    if r_start < H and c_start < W and slice_pH > 0 and slice_pW > 0:\n        # Place the potentially sliced pattern onto the output grid\n        output_grid[r_start:r_end, c_start:c_end] = pattern[:slice_pH, :slice_pW]\n\n\ndef transform(input_grid):\n    \"\"\"\n    The transformation identifies the background color (typically the color at the corners). \n    It finds the bounding box of the central rectangular pattern formed by non-background pixels. \n    Let this pattern be P, its height pH, its width pW, and its top-left corner in the input be (r0, c0). \n    An output grid of the same dimensions as the input is created, initially filled with the background color. \n    Four versions of the pattern P are placed onto the output grid:\n    1. The 180-degree rotated version of P is placed at the top-left corner (0, 0).\n    2. The vertically flipped version of P is placed at the top-right corner (0, W-pW).\n    3. The horizontally flipped version of P is placed at the bottom-left corner (H-pH, 0).\n    4. The original pattern P is placed at its original position (r0, c0).\n    Placements overwrite existing pixels, with the final placement of the original pattern P taking precedence in case of overlaps.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n\n    # Determine the background color (assumed from top-left corner)\n    bg_color = find_background_color(input_np)\n\n    # Initialize the output grid filled with the background color\n    output_np = np.full_like(input_np, bg_color)\n\n    # Find the bounding box enclosing all non-background pixels\n    bbox = find_pattern_bbox(input_np, bg_color)\n\n    # If no non-background pattern is found, return the grid filled with background color\n    if bbox is None:\n      return output_np.tolist()\n\n    # Unpack bounding box coordinates\n    min_r, max_r, min_c, max_c = bbox\n    \n    # Extract the pattern P based on the bounding box\n    pattern_P = extract_pattern(input_np, bbox)\n    pH, pW = pattern_P.shape # Get height and width of the pattern\n\n    # Check if pattern dimensions are valid (e.g., not exceeding grid size)\n    # This is a safeguard, should not happen if bbox is correct.\n    if pH <= 0 or pW <= 0:\n        return output_np.tolist() \n      \n    # Calculate the geometrically transformed versions of the pattern\n    P_rot180 = np.rot90(pattern_P, 2)   # Rotate 180 degrees\n    P_flipV = np.flipud(pattern_P)    # Flip vertically (up-down)\n    P_flipH = np.fliplr(pattern_P)    # Flip horizontally (left-right)\n\n    # --- Place the transformed patterns onto the output grid ---\n    # The order matters if there are overlaps. We place the corner patterns first.\n\n    # 1. Place 180-degree rotated pattern at the top-left corner (0, 0)\n    # Check if placement is possible within grid bounds before calling place_pattern\n    if 0 + pH <= H and 0 + pW <= W:\n        place_pattern(output_np, P_rot180, 0, 0)\n  \n    # 2. Place vertically flipped pattern at the top-right corner (0, W-pW)\n    # Check if placement is possible within grid bounds\n    if 0 + pH <= H and W - pW >= 0:\n        place_pattern(output_np, P_flipV, 0, W - pW)\n\n    # 3. Place horizontally flipped pattern at the bottom-left corner (H-pH, 0)\n    # Check if placement is possible within grid bounds\n    if H - pH >= 0 and 0 + pW <= W:\n        place_pattern(output_np, P_flipH, H - pH, 0)\n\n    # 4. Place the original pattern P at its original position (min_r, min_c)\n    # This is placed last, so it overwrites parts of the corner patterns in case of overlap.\n    place_pattern(output_np, pattern_P, min_r, min_c)\n\n    # Convert the final numpy array back to a list of lists for the required output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7639,
    "candidates_token_count": 1979,
    "total_token_count": 9618,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 154.974305
}