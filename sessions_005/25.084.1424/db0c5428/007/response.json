{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid containing a single central pattern on a uniform background.\nThe transformation involves extracting the pattern, creating four transformed versions\n(original, rotated 90 degrees clockwise, rotated 90 degrees counter-clockwise, rotated 180 degrees),\nand placing them onto an output grid of the same size, initially filled with the background color.\nThe placement is determined by aligning the center of each transformed pattern with a corner\nof the bounding box of the original pattern in the input grid. Overlapping pixels are overwritten,\nwith later placements taking precedence. The specific alignment is:\n- Rotated 90 CW: Center aligns with BBox Top-Left.\n- Rotated 90 CCW: Center aligns with BBox Top-Right.\n- Rotated 180: Center aligns with BBox Bottom-Left.\n- Original: Center aligns with BBox Bottom-Right.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background_color(grid):\n  \"\"\"\n  Determines the background color of the grid.\n  Assumes the background color is the color present at the top-left corner.\n\n  Args:\n    grid: A numpy array representing the input grid.\n\n  Returns:\n    The integer color value of the background.\n  \"\"\"\n  if grid.size == 0:\n      raise ValueError(\"Input grid is empty\")\n  return grid[0, 0]\n\ndef find_pattern_bbox(grid, bg_color):\n  \"\"\"\n  Finds the bounding box of non-background pixels.\n\n  Args:\n    grid: A numpy array representing the input grid.\n    bg_color: The background color integer.\n\n  Returns:\n    A tuple (min_r, max_r, min_c, max_c) representing the bounding box\n    of non-background pixels, or None if no non-background pixels are found.\n  \"\"\"\n  non_bg_pixels = np.where(grid != bg_color)\n\n  if len(non_bg_pixels[0]) == 0:\n    return None\n\n  min_r = np.min(non_bg_pixels[0])\n  max_r = np.max(non_bg_pixels[0])\n  min_c = np.min(non_bg_pixels[1])\n  max_c = np.max(non_bg_pixels[1])\n\n  return int(min_r), int(max_r), int(min_c), int(max_c) # Cast to int\n\ndef extract_pattern(grid, bbox):\n   \"\"\"\n   Extracts the subgrid (pattern) defined by the bounding box.\n\n   Args:\n     grid: A numpy array representing the input grid.\n     bbox: A tuple (min_r, max_r, min_c, max_c) defining the bounding box.\n\n   Returns:\n     A numpy array representing the extracted pattern.\n   \"\"\"\n   if bbox is None:\n       return np.array([[]], dtype=int) # Return empty array if no bbox\n   min_r, max_r, min_c, max_c = bbox\n   # Slice the grid using the bounding box coordinates\n   # Note: slicing is exclusive of the end index, so add 1 to max_r and max_c\n   return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef place_pattern(output_grid, pattern, r_start, c_start):\n    \"\"\"\n    Places a pattern onto the output grid at the specified top-left corner.\n    Overwrites existing pixels in the output grid. Handles partial placements\n    if the pattern goes out of bounds (clipping).\n\n    Args:\n      output_grid: The numpy array representing the grid to place the pattern onto.\n      pattern: The numpy array representing the pattern to place.\n      r_start: The starting row index for the top-left corner of the placement.\n      c_start: The starting column index for the top-left corner of the placement.\n    \"\"\"\n    if pattern.size == 0: # Do nothing if the pattern is empty\n        return\n\n    pH, pW = pattern.shape\n    H, W = output_grid.shape\n\n    # Determine the slice of the output grid to modify\n    out_r_start = max(0, r_start)\n    out_c_start = max(0, c_start)\n    out_r_end = min(H, r_start + pH)\n    out_c_end = min(W, c_start + pW)\n\n    # Determine the corresponding slice of the pattern to use\n    pattern_r_start = max(0, -r_start)\n    pattern_c_start = max(0, -c_start)\n    pattern_r_end = pattern_r_start + (out_r_end - out_r_start)\n    pattern_c_end = pattern_c_start + (out_c_end - out_c_start)\n\n    # Place the pattern slice if the slice dimensions are positive\n    if out_r_end > out_r_start and out_c_end > out_c_start:\n        output_grid[out_r_start:out_r_end, out_c_start:out_c_end] = \\\n            pattern[pattern_r_start:pattern_r_end, pattern_c_start:pattern_c_end]\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation based on the natural language program.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # Handle potentially empty input grid gracefully\n    if input_np.size == 0:\n        return [] # Return empty list for empty input\n\n    H, W = input_np.shape\n\n    # 1. Identify Background color\n    bg_color = find_background_color(input_np)\n\n    # 2. Initialize the output grid filled with the background color\n    output_np = np.full_like(input_np, bg_color)\n\n    # 3. Find the bounding box enclosing all non-background pixels\n    bbox = find_pattern_bbox(input_np, bg_color)\n\n    # If no non-background pattern is found, return the grid filled with background color\n    if bbox is None:\n      return output_np.tolist()\n\n    min_r, max_r, min_c, max_c = bbox\n\n    # 4. Extract the pattern P based on the bounding box\n    pattern_P = extract_pattern(input_np, bbox)\n\n    # Check if pattern extraction resulted in an empty pattern (shouldn't happen if bbox is not None, but safe check)\n    if pattern_P.size == 0:\n        return output_np.tolist() # Return background grid if pattern is empty\n\n    pH, pW = pattern_P.shape # Get height and width of the pattern\n\n    # Ensure pattern dimensions are valid\n    if pH <= 0 or pW <= 0:\n        return output_np.tolist()\n\n    # 5. Calculate Pattern Center (relative to the pattern's top-left)\n    # Using integer division for center calculation\n    center_r = (pH - 1) // 2\n    center_c = (pW - 1) // 2\n\n    # 6. Create geometrically transformed versions of the pattern\n    P_rot90_cw = np.rot90(pattern_P, k=-1)   # Rotate 90 degrees clockwise\n    P_rot90_ccw = np.rot90(pattern_P, k=1)   # Rotate 90 degrees counter-clockwise\n    P_rot180 = np.rot90(pattern_P, k=2)      # Rotate 180 degrees\n    P_original = pattern_P                   # Original pattern\n\n    # --- 7. Calculate Placement Origins (top-left corner for each pattern placement) ---\n    # These origins ensure the center of the placed pattern aligns with the target bbox corner\n\n    # Origin for P_rot90_cw (aligns center with bbox top-left: min_r, min_c)\n    origin_cw_r = min_r - center_r\n    origin_cw_c = min_c - center_c\n\n    # Origin for P_rot90_ccw (aligns center with bbox top-right: min_r, max_c)\n    origin_ccw_r = min_r - center_r\n    origin_ccw_c = max_c - center_c\n\n    # Origin for P_rot180 (aligns center with bbox bottom-left: max_r, min_c)\n    origin_180_r = max_r - center_r\n    origin_180_c = min_c - center_c\n\n    # Origin for P_original (aligns center with bbox bottom-right: max_r, max_c)\n    origin_orig_r = max_r - center_r\n    origin_orig_c = max_c - center_c\n\n    # --- 8. Place the transformed patterns onto the output grid ---\n    # The order determines which pattern's pixels overwrite others in case of overlap.\n    # Using the order: CW, CCW, 180, Original as specified in analysis.\n    place_pattern(output_np, P_rot90_cw, origin_cw_r, origin_cw_c)\n    place_pattern(output_np, P_rot90_ccw, origin_ccw_r, origin_ccw_c)\n    place_pattern(output_np, P_rot180, origin_180_r, origin_180_c)\n    place_pattern(output_np, P_original, origin_orig_r, origin_orig_c)\n\n    # 9. Convert the final numpy array back to a list of lists for the required output format\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15840,
    "candidates_token_count": 2301,
    "total_token_count": 18141,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.114522
}