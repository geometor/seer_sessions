{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid containing a single central pattern on a uniform background.\nThe transformation involves:\n1. Identifying the background color (from the top-left corner).\n2. Finding the bounding box and extracting the central pattern (P).\n3. Creating an output grid of the same size, filled with the background color.\n4. Placing four transformed versions of the pattern P into the corners of the output grid:\n   - Top-Left: P rotated 90 degrees clockwise.\n   - Top-Right: P rotated 90 degrees counter-clockwise.\n   - Bottom-Left: P rotated 180 degrees.\n   - Bottom-Right: The original pattern P.\nThe original location of P in the input is left as the background color in the output.\n\"\"\"\n\n# --- Helper Functions (copied from previous iteration) ---\n\ndef find_background_color(grid):\n  \"\"\"\n  Determines the background color of the grid.\n  Assumes the background color is the color present at the top-left corner.\n  \n  Args:\n    grid: A numpy array representing the input grid.\n  \n  Returns:\n    The integer color value of the background.\n  \"\"\"\n  # Check if grid is empty or has zero size\n  if grid.size == 0:\n      # Handle empty grid case, perhaps return a default or raise error\n      # For now, let's assume valid grids and return 0 (common default)\n      # or handle based on task specification if available\n      # Returning 0 might be problematic if 0 is a valid non-bg color.\n      # A safer default might be -1 or None, requiring calling code to check.\n      # Given ARC context, grids are non-empty, so [0,0] is usually safe.\n      raise ValueError(\"Input grid is empty\") \n  return grid[0, 0]\n\ndef find_pattern_bbox(grid, bg_color):\n  \"\"\"\n  Finds the bounding box of non-background pixels.\n  \n  Args:\n    grid: A numpy array representing the input grid.\n    bg_color: The background color integer.\n  \n  Returns:\n    A tuple (min_r, max_r, min_c, max_c) representing the bounding box \n    of non-background pixels, or None if no non-background pixels are found.\n  \"\"\"\n  # Find coordinates of all pixels that are not the background color\n  non_bg_pixels = np.where(grid != bg_color)\n  \n  # If there are no non-background pixels, return None\n  if len(non_bg_pixels[0]) == 0:\n    return None \n    \n  # Determine the minimum and maximum row and column indices\n  min_r = np.min(non_bg_pixels[0])\n  max_r = np.max(non_bg_pixels[0])\n  min_c = np.min(non_bg_pixels[1])\n  max_c = np.max(non_bg_pixels[1])\n  \n  return min_r, max_r, min_c, max_c\n\ndef extract_pattern(grid, bbox):\n   \"\"\"\n   Extracts the subgrid (pattern) defined by the bounding box.\n   \n   Args:\n     grid: A numpy array representing the input grid.\n     bbox: A tuple (min_r, max_r, min_c, max_c) defining the bounding box.\n     \n   Returns:\n     A numpy array representing the extracted pattern.\n   \"\"\"\n   if bbox is None:\n       return np.array([[]]) # Return empty array if no bbox\n   min_r, max_r, min_c, max_c = bbox\n   # Slice the grid using the bounding box coordinates\n   # Note: slicing is exclusive of the end index, so add 1 to max_r and max_c\n   return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef place_pattern(output_grid, pattern, r_start, c_start):\n    \"\"\"\n    Places a pattern onto the output grid at the specified top-left corner.\n    Overwrites existing pixels in the output grid. Handles partial placements\n    if the pattern goes out of bounds.\n    \n    Args:\n      output_grid: The numpy array representing the grid to place the pattern onto.\n      pattern: The numpy array representing the pattern to place.\n      r_start: The starting row index for the top-left corner of the placement.\n      c_start: The starting column index for the top-left corner of the placement.\n    \"\"\"\n    if pattern.size == 0: # Do nothing if the pattern is empty\n        return\n        \n    pH, pW = pattern.shape\n    H, W = output_grid.shape\n    \n    # Ensure starting indices are non-negative\n    r_start = max(0, r_start)\n    c_start = max(0, c_start)\n\n    # Calculate the actual end row and column, respecting grid boundaries\n    r_end = min(r_start + pH, H)\n    c_end = min(c_start + pW, W)\n    \n    # Calculate the height and width of the slice to take from the pattern\n    # This handles cases where the pattern placement starts off the grid or goes partially off\n    slice_pH = r_end - r_start\n    slice_pW = c_end - c_start\n    \n    # Determine the corresponding slice from the pattern\n    pattern_r_start = 0\n    pattern_c_start = 0\n    # Adjust pattern slice start if placement started off-grid (negative r_start/c_start initially)\n    # Although we clamped r_start/c_start to 0, this logic would handle it if we hadn't.\n    # The main purpose here is to ensure we take the correct part of the pattern\n    # if only a portion fits onto the grid.\n    \n    pattern_r_end = slice_pH\n    pattern_c_end = slice_pW\n    \n    # Place the pattern slice if the slice dimensions are positive\n    if slice_pH > 0 and slice_pW > 0:\n        output_grid[r_start:r_end, c_start:c_end] = pattern[pattern_r_start:pattern_r_end, pattern_c_start:pattern_c_end]\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the revised transformation based on multi-example analysis.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Handle potentially empty input grid gracefully\n    if input_np.size == 0:\n        return [] # Or handle as per specific requirements for empty input\n\n    H, W = input_np.shape\n\n    # 1. Determine the background color\n    bg_color = find_background_color(input_np)\n\n    # 2. Initialize the output grid filled with the background color\n    output_np = np.full_like(input_np, bg_color)\n\n    # 3. Find the bounding box enclosing all non-background pixels\n    bbox = find_pattern_bbox(input_np, bg_color)\n\n    # If no non-background pattern is found, return the grid filled with background color\n    if bbox is None:\n      return output_np.tolist()\n\n    # 4. Extract the pattern P based on the bounding box\n    pattern_P = extract_pattern(input_np, bbox)\n    \n    # Check if pattern extraction was successful (bbox wasn't None)\n    if pattern_P.size == 0:\n        return output_np.tolist() # Return background grid if pattern is empty\n        \n    pH, pW = pattern_P.shape # Get height and width of the pattern\n\n    # Ensure pattern dimensions are valid\n    if pH <= 0 or pW <= 0:\n        # This check might be redundant given the size check above, but doesn't hurt\n        return output_np.tolist() \n      \n    # 5. Calculate the geometrically transformed versions of the pattern\n    P_rot90_cw = np.rot90(pattern_P, k=-1)   # Rotate 90 degrees clockwise (k=3 is equivalent)\n    P_rot90_ccw = np.rot90(pattern_P, k=1)   # Rotate 90 degrees counter-clockwise\n    P_rot180 = np.rot90(pattern_P, k=2)      # Rotate 180 degrees\n    P_original = pattern_P                   # Original pattern\n\n    # --- 6. Place the transformed patterns onto the output grid corners ---\n\n    # Place rotated 90 deg CW pattern at top-left (0, 0)\n    place_pattern(output_np, P_rot90_cw, 0, 0)\n\n    # Place rotated 90 deg CCW pattern at top-right (0, W-pW)\n    place_pattern(output_np, P_rot90_ccw, 0, W - pW)\n\n    # Place rotated 180 deg pattern at bottom-left (H-pH, 0)\n    place_pattern(output_np, P_rot180, H - pH, 0)\n\n    # Place the original pattern P at bottom-right (H-pH, W-pW)\n    place_pattern(output_np, P_original, H - pH, W - pW)\n\n    # 7. Convert the final numpy array back to a list of lists for the required output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13139,
    "candidates_token_count": 2232,
    "total_token_count": 15371,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.892734
}