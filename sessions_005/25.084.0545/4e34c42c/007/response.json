{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the bounding box of non-background pixels in the input grid and constructs a 5-row output grid. The top and bottom rows are created by extracting non-background pixels from the top and bottom rows of the bounding box, respectively.  The three middle rows are constructed by extracting all rows with non-background pixels. The selected rows are padded as required.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects in a grid.\n    Returns a list of objects, where each object is a list of (row, col) coordinates.\n    \"\"\"\n    visited = set()\n    objects = []\n\n    def dfs(row, col, color, current_object):\n        if (row, col) in visited or not (0 <= row < grid.shape[0] and 0 <= col < grid.shape[1]) or grid[row, col] != color:\n            return\n        visited.add((row, col))\n        current_object.append((row, col))\n        dfs(row + 1, col, color, current_object)\n        dfs(row - 1, col, color, current_object)\n        dfs(row, col + 1, color, current_object)\n        dfs(row, col - 1, color, current_object)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if (row, col) not in visited:\n                current_object = []\n                dfs(row, col, grid[row, col], current_object)\n                if current_object:\n                    objects.append(current_object)\n    return objects\n\ndef get_background_colors(grid, objects):\n    \"\"\"\n    Get background color by finding largest objects\n    \"\"\"\n    objects_by_size = sorted(objects, key=len, reverse=True)\n    background_colors = []\n    for obj in objects_by_size:\n      if len(obj) > .10 * grid.size:\n        background_colors.append(grid[obj[0][0], obj[0][1]])\n    return background_colors\n\n\ndef get_object_bounding_box(objects):\n    \"\"\"Calculates the bounding box encompassing all given objects.\"\"\"\n    if not objects:\n        return (0, 0, 0, 0)  # Empty case\n\n    min_row = float('inf')\n    max_row = float('-inf')\n    min_col = float('inf')\n    max_col = float('-inf')\n\n    for obj in objects:\n        for row, col in obj:\n            min_row = min(min_row, row)\n            max_row = max(max_row, row)\n            min_col = min(min_col, col)\n            max_col = max(max_col, col)\n\n    return (min_row, max_row, min_col, max_col)\n\ndef get_row_within_bbox(grid, row_index, min_col, max_col, background_colors):\n    \"\"\"Extracts non-background pixels from a specified row within the bounding box.\"\"\"\n\n    row_pixels = []\n    for col in range(min_col, max_col + 1):\n        if grid[row_index, col] not in background_colors:\n            row_pixels.append(grid[row_index, col])\n    return row_pixels\n\ndef get_top_bottom_row(grid, min_row, max_row, min_col, max_col, background_colors):\n    \"\"\"Gets the top or bottom row based on non-background pixels.\"\"\"\n\n    # Find the first row with a non-background pixel within the bounding box.\n    \n    first_row = -1\n    for r in range(min_row, max_row+1):\n        for c in range(min_col, max_col + 1):\n            if grid[r,c] not in background_colors:\n                first_row = r\n                break  # move to the next column\n        if first_row >= 0:\n            break\n    \n    last_row = -1\n    for r in range(max_row, min_row-1, -1):\n       for c in range(min_col, max_col + 1):\n            if grid[r,c] not in background_colors:\n                last_row = r\n                break\n       if last_row >= 0:\n           break\n    \n    if first_row == -1:\n        return [], [] # No non-background pixels\n\n    top_row = get_row_within_bbox(grid, first_row, min_col, max_col, background_colors)\n    bottom_row = get_row_within_bbox(grid, last_row, min_col, max_col, background_colors)\n    return top_row, bottom_row\n\n\ndef pad_row(row, target_width, background_color):\n    \"\"\"Pads a row with the background color to reach the target width.\"\"\"\n    if not row:\n      return [background_color] * target_width\n    \n    padding_needed = target_width - len(row)\n    if padding_needed <= 0:\n        return row[:target_width]  # Truncate if longer\n\n    left_padding = padding_needed // 2\n    right_padding = padding_needed - left_padding\n    return [background_color] * left_padding + row + [background_color] * right_padding\n\ndef get_middle_rows(grid, min_row, max_row, min_col, max_col, background_colors, target_width):\n    middle_rows_data = []\n    for r in range(min_row, max_row + 1):\n        row_pixels = []\n        has_non_background = False\n        for c in range(0, grid.shape[1]): # Iterate through the *entire* row\n            pixel = grid[r, c]\n            if pixel not in background_colors:\n                has_non_background = True\n                row_pixels.append(pixel)\n            elif has_non_background: # and pixel in background_colors\n                row_pixels.append(pixel) # include background after non-background\n\n        if has_non_background:\n              middle_rows_data.append(row_pixels)\n\n    # ensure exactly 3 middle rows\n    while len(middle_rows_data) < 3:\n      if middle_rows_data:\n        middle_rows_data.append(middle_rows_data[-1]) # Duplicate last if not enough\n      else:\n        middle_rows_data.append([background_colors[0]] * target_width)  # fill with background\n    \n    if len(middle_rows_data) > 3:\n      middle_rows_data = middle_rows_data[:3]  # Truncate if there are more than 3\n    \n    padded_middle_rows = []\n    for row in middle_rows_data:\n      padded_middle_rows.append(pad_row(row, target_width, background_colors[0]))\n\n    return padded_middle_rows\n\n\n\ndef transform(input_grid):\n    # Convert input to numpy array\n    input_grid = np.array(input_grid)\n\n    # Find objects\n    objects = find_objects(input_grid)\n\n    # Find background\n    background_colors = get_background_colors(input_grid, objects)\n\n    # Identify non-background objects\n    non_background_objects = [obj for obj in objects if input_grid[obj[0][0], obj[0][1]] not in background_colors]\n\n    # Get bounding box of the non-background objects\n    min_row, max_row, min_col, max_col = get_object_bounding_box(non_background_objects)\n\n    # Get the top and bottom rows based on non-background pixels within the bounding box\n    top_row, bottom_row = get_top_bottom_row(input_grid, min_row, max_row, min_col, max_col, background_colors)\n\n    # Find max width - use max of top/bottom and full grid scan\n    max_width_top_bottom = max(len(top_row), len(bottom_row))\n\n     # Create the output grid\n    output_grid = np.full((5, max_width_top_bottom), background_colors[0],  dtype=int)\n\n    # Get Middle Rows\n    middle_rows = get_middle_rows(input_grid, min_row, max_row, min_col, max_col, background_colors, max_width_top_bottom)\n\n    output_grid_list = [pad_row(top_row, max_width_top_bottom, background_colors[0])] + middle_rows + [pad_row(bottom_row, max_width_top_bottom, background_colors[0])]\n\n    output_grid = np.array(output_grid_list)\n    \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 2112,
            "end_index": 2305,
            "uri": "https://github.com/comhendrik/adventofcode",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18592,
    "candidates_token_count": 2084,
    "total_token_count": 20676,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 27.131034
}