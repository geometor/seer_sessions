{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Background:** The background color is consistently color '8' (azure).\n2.  **Identify Enclosed Regions:** Find all distinct regions enclosed by the background color.  These regions are completely surrounded by the background color and do not touch the edges of the entire grid.  Each enclosed region should be treated independently.\n3.  **Identify Objects:** Within each enclosed region, identify \"objects.\" An object is a group of connected pixels (horizontally, vertically, or diagonally) that share the same color and are *not* the background color.\n4.  **Gravity within Regions:**  For each enclosed region, apply a \"gravity\" effect.  All objects within the region fall downwards.  The movement stops when an object hits:\n    *   The bottom boundary of its enclosed region.\n    *   Another object within the same region.\n5. **Preserve Boundaries:** The surrounding boundary of azure (8) must remain unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid, region_mask):\n    \"\"\"Finds contiguous regions (objects) of the same color within a region.\"\"\"\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    def dfs(row, col, color, object_pixels):\n        if (row < 0 or row >= grid.shape[0] or col < 0 or col >= grid.shape[1] or\n                visited[row, col] or not region_mask[row, col] or grid[row, col] != color):\n            return\n        visited[row, col] = True\n        object_pixels.append((row, col))\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                dfs(row + dr, col + dc, color, object_pixels)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if not visited[row, col] and region_mask[row, col] and grid[row,col] != 8:  # Ensure we stay within the region\n                object_pixels = []\n                dfs(row, col, grid[row, col], object_pixels)\n                if object_pixels:\n                    objects.append({'color': grid[row, col], 'pixels': object_pixels})\n    return objects\n\ndef find_enclosed_regions(grid, background_color):\n    \"\"\"Finds regions enclosed by the background color.\"\"\"\n    # Invert the background to find non-background areas\n    non_background_mask = grid != background_color\n\n    # Use a flood-fill algorithm to identify regions connected to the border\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or\n                visited[r, c] or not non_background_mask[r, c]):\n            return\n        visited[r, c] = True\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0: continue\n                dfs(r + dr, c + dc)\n\n    # Mark all non-background pixels connected to the edges as visited\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if non_background_mask[r,c]:\n                dfs(r,c)\n    for c in range(cols):\n      for r in [0, rows -1]:\n        if non_background_mask[r,c]:\n            dfs(r,c)\n\n    # The enclosed regions are the non-visited, non-background pixels\n    enclosed_mask = np.logical_and(non_background_mask, ~visited)\n    return enclosed_mask\n\n\ndef shift_objects_in_region(grid, region_mask, background_color):\n    \"\"\"Shifts objects down within a specific region.\"\"\"\n    # Create a copy to work on\n    grid_copy = np.copy(grid)\n    objects = find_objects(grid_copy, region_mask)\n\n    # Clear the original object positions within this region\n    for obj in objects:\n      for r, c in obj['pixels']:\n        if region_mask[r,c]: # only clear if inside the region\n          grid_copy[r,c] = background_color\n\n    # Move each object within the region\n    for obj in objects:\n        pixels = obj['pixels']\n        pixels.sort(key=lambda p: p[0], reverse=True)  # Sort by row, descending\n        color = obj['color']\n\n        for r, c in pixels:\n            new_r = r\n            # Move down until blocked by boundary or another object\n            while (new_r + 1 < grid.shape[0] and region_mask[new_r + 1, c] and\n                   grid_copy[new_r + 1, c] == background_color ):\n                new_r += 1\n            grid_copy[new_r, c] = color\n            \n    return grid_copy\n\n\ndef transform(input_grid):\n    # 1. Identify Background\n    background_color = 8\n    output_grid = np.copy(input_grid)\n\n    # 2. Identify Enclosed Regions\n    enclosed_regions_mask = find_enclosed_regions(output_grid, background_color)\n\n    # Get all the individual enclosed region masks\n    visited = np.zeros_like(enclosed_regions_mask, dtype=bool)\n    regions = []\n\n    def dfs_regions(row,col,current_region):\n        if(row < 0 or row >= enclosed_regions_mask.shape[0] or col < 0 or col >= enclosed_regions_mask.shape[1]\n          or visited[row,col] or not enclosed_regions_mask[row,col]):\n            return\n\n        visited[row,col] = True\n        current_region.append((row,col))\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue;\n                dfs_regions(row+dr,col+dc,current_region)\n\n\n\n    for row in range(enclosed_regions_mask.shape[0]):\n        for col in range(enclosed_regions_mask.shape[1]):\n            if enclosed_regions_mask[row,col] and not visited[row,col]:\n                current_region = []\n                dfs_regions(row,col,current_region)\n                regions.append(current_region)\n    \n\n    # 3. & 4. Process Each Region and Shift Objects\n    for region_pixels in regions:\n        # create region mask for current region\n        region_mask = np.zeros_like(output_grid, dtype = bool)\n        for r,c in region_pixels:\n            region_mask[r,c] = True\n\n        output_grid = shift_objects_in_region(output_grid, region_mask, background_color)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6057,
    "candidates_token_count": 1676,
    "total_token_count": 7733,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 19.553518
}