{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:**\n    *   A **border object** consisting of connected pixels of colors 3 and 8.  This object forms a single-pixel-wide, continuous line around the edges and within the grid.\n    *   An **irregular object** composed of pixels with color 7.\n    *   The **background**, consisting of all pixels with color 0.\n\n2.  **Border Transformation (Color Swap):**\n    *   Within the *connected* border object, pixels of color 8 change to color 3, and pixels of color 3 change to color 8.\n\n3.  **Irregular Object Transformation (Color Change):**\n    *   All pixels of color 7 (the irregular object) change to color 6.\n\n4.  **Adjacent Propagation:**\n    *   Any pixel of color 8 that is *adjacent* (horizontally, vertically, or diagonally) to a pixel of color 6 changes to color 6. This propagation continues iteratively until no more color 8 pixels are adjacent to color 6 pixels.\n\n5.  **Row Adjustment:**\n    *  If the bottom row is all the same color, and it is different from the row above it, the entire row is deleted. The other rows shift down to fill the space, preserving all features.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef get_adjacent_pixels(grid, row, col):\n    # returns the adjacent pixels to (row, col) including diagonals, but NOT including (row, col)\n    height, width = grid.shape\n    adjacent_pixels = []\n    for i in range(max(0, row - 1), min(height, row + 2)):\n        for j in range(max(0, col - 1), min(width, col + 2)):\n            if (i, j) != (row, col):\n                adjacent_pixels.append((i, j))\n    return adjacent_pixels\n\ndef flood_fill(grid, start_row, start_col, target_color, replacement_color):\n    # Performs a flood fill, but only changes connected pixels.\n    rows, cols = grid.shape\n    if grid[start_row, start_col] != target_color:\n        return\n    q = deque([(start_row, start_col)])\n    while q:\n        row, col = q.popleft()\n        if grid[row, col] == target_color:\n            grid[row, col] = replacement_color\n            for adj_row, adj_col in get_adjacent_pixels(grid, row, col):\n                if 0 <= adj_row < rows and 0 <= adj_col < cols:\n                    q.append((adj_row, adj_col))\n\n\ndef find_connected_border(grid):\n    # Finds the connected border object of colors 3 and 8\n    rows, cols = grid.shape\n    border_pixels = set()\n    visited = set()\n\n    def dfs(row, col):\n      # recursive depth first search to visit the boarder\n        if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] not in (3, 8):\n            return\n        visited.add((row, col))\n        border_pixels.add((row, col))\n        for adj_row, adj_col in get_adjacent_pixels(grid, row, col):\n            dfs(adj_row, adj_col)\n\n    # Iterate through the grid's boundary to start DFS\n    for r in range(rows):\n        if grid[r, 0] in (3, 8):\n            dfs(r, 0)\n        if grid[r, cols - 1] in (3, 8):\n            dfs(r, cols - 1)\n    for c in range(1, cols - 1):  # Avoid corners (already checked)\n        if grid[0, c] in (3, 8):\n            dfs(0, c)\n        if grid[rows - 1, c] in (3, 8):\n            dfs(rows - 1, c)\n    \n    # now add internal pixels of color 3 and 8 that connect to the border\n    visited = set()\n    def dfs_internal(row,col):\n      # recursive depth first search for connected internal pixels\n        if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] not in (3, 8):\n            return\n        visited.add((row,col))\n        # only add to border_pixels if connected to existing border\n        is_connected = False\n        for ar, ac in get_adjacent_pixels(grid,row,col):\n            if (ar,ac) in border_pixels:\n                is_connected = True\n                break\n        if is_connected:\n            border_pixels.add((row,col))\n            for ar, ac in get_adjacent_pixels(grid,row,col):\n                dfs_internal(ar,ac)\n\n    # add internal connected pixels\n    for r in range(1, rows - 1):\n      for c in range(1, cols - 1):\n          dfs_internal(r,c)\n\n    return border_pixels\n\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Identify Objects (Border)\n    border_pixels = find_connected_border(output_grid)\n\n    # 2. Border Transformation (Color Swap)\n    for row, col in border_pixels:\n        if output_grid[row, col] == 3:\n            output_grid[row, col] = 8\n        elif output_grid[row, col] == 8:\n            output_grid[row, col] = 3\n\n    # 3. Irregular Object Transformation (Color Change)\n    for row in range(rows):\n        for col in range(cols):\n            if output_grid[row, col] == 7:\n                output_grid[row, col] = 6\n\n    # 4. Adjacent Propagation\n    while True:\n        changed = False\n        new_grid = np.copy(output_grid)  # Create a copy for modifications\n        for row in range(rows):\n            for col in range(cols):\n                if output_grid[row, col] == 8:\n                    for adj_row, adj_col in get_adjacent_pixels(output_grid, row, col):\n                        if 0 <= adj_row < rows and 0 <= adj_col < cols and output_grid[adj_row, adj_col] == 6:\n                            new_grid[row, col] = 6  # Modify the copy\n                            changed = True\n                            break\n        output_grid = new_grid  # Update output_grid\n        if not changed:\n            break\n\n    # 5. Row Adjustment\n    if rows > 1:  # Ensure there's a row above to compare with\n      last_row = output_grid[-1]\n      if np.all(last_row == last_row[0]) and not np.array_equal(last_row, output_grid[-2]):\n          output_grid = output_grid[:-1,:]\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10983,
    "candidates_token_count": 1691,
    "total_token_count": 12674,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 24.042453
}