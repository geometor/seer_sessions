{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:**\n    *   A **connected_border** object: A single-pixel-wide, continuous line of pixels of colors 3 and 8, forming a boundary around and potentially inside the grid. \"Continuous\" means each pixel in the border is adjacent (horizontally, vertically, or diagonally) to at least one other pixel in the border, forming a closed loop or loops.\n    *   An **irregular_object**: One or more pixels of color 7 inside the region(s) defined by the connected_border.\n    *   **Background:** All pixels with color 0.\n\n2.  **Border Color Swap:**\n    *   Within the *connected_border* object, swap colors: 3 becomes 8, and 8 becomes 3.\n\n3.  **Irregular Object Color Change:**\n    *   Change all pixels of color 7 to color 6.\n\n4.  **Bounded Propagation:**\n    *   Within the area enclosed by the `connected_border`, any pixel of color 8 that is *adjacent* (horizontally, vertically, or diagonally) to a pixel of color 6 changes to color 6. This propagation happens iteratively until no more color 8 pixels adjacent to color 6 pixels within the border are found.\n\n5. **Row Adjustment**:\n\n    *  Check if all pixels in the last row of the grid have the same color.\n    *  If they do, check if that color is different from the color of all pixels in the row above it.\n    * If both conditions are true, delete the last row and allow the remaining rows to shift down.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef get_adjacent_pixels(grid, row, col):\n    # returns the adjacent pixels to (row, col) including diagonals, but NOT including (row, col)\n    height, width = grid.shape\n    adjacent_pixels = []\n    for i in range(max(0, row - 1), min(height, row + 2)):\n        for j in range(max(0, col - 1), min(width, col + 2)):\n            if (i, j) != (row, col):\n                adjacent_pixels.append((i, j))\n    return adjacent_pixels\n\ndef find_connected_border(grid):\n    # Finds the connected border object of colors 3 and 8.\n    rows, cols = grid.shape\n    border_pixels = set()\n    visited = set()\n\n    def dfs(row, col):\n        # Recursive depth-first search to identify connected border pixels.\n        if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] not in (3, 8):\n            return\n        visited.add((row, col))\n        border_pixels.add((row, col))\n\n        # Explore adjacent cells.\n        for adj_row, adj_col in get_adjacent_pixels(grid, row, col):\n            dfs(adj_row, adj_col)\n\n    # Start DFS from the outer boundary.  This will find the *outer* border.\n    for r in range(rows):\n        dfs(r, 0)  # Left edge\n        dfs(r, cols - 1)  # Right edge\n    for c in range(1, cols - 1):\n        dfs(0, c)  # Top edge\n        dfs(rows - 1, c)  # Bottom edge\n\n    # Now find internal borders by checking 3 and 8 pixels connected to existing borders\n    \n    internal_visited = set()\n    def dfs_internal(row, col):\n      # recursive depth first search for connected internal pixels\n        if (row, col) in internal_visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] not in (3, 8):\n            return\n        internal_visited.add((row,col))\n        # only add to border_pixels if connected to existing border\n        is_connected = False\n        for ar, ac in get_adjacent_pixels(grid,row,col):\n            if (ar,ac) in border_pixels:\n                is_connected = True\n                break\n        if is_connected:\n            border_pixels.add((row,col))\n            for ar, ac in get_adjacent_pixels(grid,row,col):\n                dfs_internal(ar,ac)\n\n    # add internal connected pixels\n    for r in range(1, rows - 1):\n      for c in range(1, cols - 1):\n          dfs_internal(r,c)\n\n    return border_pixels\n\ndef bounded_flood_fill(grid, start_row, start_col, border_pixels):\n    # Performs a flood fill of 8's to 6's, but *only* within the border,\n    # starting from seeds of 6's (originally 7's)\n    rows, cols = grid.shape\n    if grid[start_row, start_col] != 6:\n        return\n\n    q = deque([(start_row, start_col)])\n    visited = set() # avoid infinite loops\n    visited.add((start_row,start_col))\n\n    while q:\n        row, col = q.popleft()\n        # find neighbors that are 8 and inside border\n        for adj_row, adj_col in get_adjacent_pixels(grid, row, col):\n            if (adj_row,adj_col) not in visited:\n                if (0 <= adj_row < rows and 0 <= adj_col < cols and\n                        grid[adj_row, adj_col] == 8 and (adj_row,adj_col) not in border_pixels\n                   ):\n                    # if neighbor is an 8, is *inside* the border (not ON border)\n                    # convert to a 6, and add to queue\n                    grid[adj_row, adj_col] = 6\n                    q.append((adj_row, adj_col))\n                    visited.add((adj_row,adj_col))\n\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Identify Objects (Border)\n    border_pixels = find_connected_border(output_grid)\n\n    # 2. Border Transformation (Color Swap)\n    for row, col in border_pixels:\n        if output_grid[row, col] == 3:\n            output_grid[row, col] = 8\n        elif output_grid[row, col] == 8:\n            output_grid[row, col] = 3\n\n    # 3. Irregular Object Transformation (Color Change)\n    for row in range(rows):\n        for col in range(cols):\n            if output_grid[row, col] == 7:\n                output_grid[row, col] = 6\n\n    # 4. Bounded Propagation.\n    # Iterate and find starting points for flood fill\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r,c] == 6:\n                bounded_flood_fill(output_grid, r, c, border_pixels)\n\n    # 5. Row Adjustment\n    if rows > 1: # make sure there is a row to delete\n      last_row = output_grid[-1, :]\n      if np.all(last_row == last_row[0]):  # Check if the last row is all the same color\n          second_last_row = output_grid[-2, :]\n          if not np.array_equal(last_row, second_last_row):  # Compare with the row above\n              output_grid = output_grid[:-1, :]  # Delete the last row\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6653,
    "candidates_token_count": 1798,
    "total_token_count": 8451,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 18.018769
}