{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation identifies a region of change in the input and replaces it with a pattern extracted from the output. For the special case where the changed region is the bottom-right quadrant, it performs a 2x upscale of that quadrant. Otherwise, it identifies a repeating pattern from output change region and repeats.\n\"\"\"\n\nimport numpy as np\n\ndef get_object_bounds(grid):\n    \"\"\"\n    Find bounding boxes of connected regions\n\n    returns a dictionary\n    \"\"\"\n\n    visited = set()\n    objects = {}\n\n    rows, cols = len(grid), len(grid[0])\n\n    def dfs(row, col, color, object_id):\n        if (\n            row < 0\n            or row >= rows\n            or col < 0\n            or col >= cols\n            or (row, col) in visited\n            or grid[row][col] != color\n        ):\n            return []\n\n        visited.add((row, col))\n        coords = [(row, col)]\n\n        coords.extend(dfs(row + 1, col, color, object_id))\n        coords.extend(dfs(row - 1, col, color, object_id))\n        coords.extend(dfs(row, col + 1, color, object_id))\n        coords.extend(dfs(row, col - 1, color, object_id))\n\n        return coords\n\n    object_id_counter = 0\n    for row in range(rows):\n        for col in range(cols):\n            if (row, col) not in visited:\n                color = grid[row][col]\n                object_coords = dfs(row, col, color, object_id_counter)\n\n                min_row = min(object_coords, key=lambda x: x[0])[0]\n                max_row = max(object_coords, key=lambda x: x[0])[0]\n                min_col = min(object_coords, key=lambda x: x[1])[1]\n                max_col = max(object_coords, key=lambda x: x[1])[1]\n\n                objects[object_id_counter] = {\n                    \"color\": color,\n                    \"min_row\": min_row,\n                    \"max_row\": max_row,\n                    \"min_col\": min_col,\n                    \"max_col\": max_col,\n                }\n                object_id_counter += 1\n\n    return objects\n\ndef find_changing_pixels(input_grid, output_grid):\n    \"\"\"Finds coordinates of pixels that change between input and output.\"\"\"\n    changing_pixels = []\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[0])):\n            if input_grid[i][j] != output_grid[i][j]:\n                changing_pixels.append((i, j))\n    return changing_pixels\n\ndef get_bounds(coords):\n    \"\"\"Gets the bounding box of a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_row = min(coords, key=lambda x: x[0])[0]\n    max_row = max(coords, key=lambda x: x[0])[0]\n    min_col = min(coords, key=lambda x: x[1])[1]\n    max_col = max(coords, key=lambda x: x[1])[1]\n    return min_row, max_row, min_col, max_col\n\ndef quadrant_replication(input_grid):\n  \"\"\"\n  replicates the bottom-right quadrant\n  \"\"\"\n  input_grid = np.array(input_grid)\n  rows, cols = input_grid.shape\n  mid_row, mid_col = rows // 2, cols // 2\n  quadrant = input_grid[mid_row:, mid_col:]\n  return np.kron(quadrant, np.ones((2, 2))).tolist()\n\ndef get_output_dimensions(input_grid, seed_region_input, seed_pattern_output):\n    \"\"\"Calculates output dimensions.\"\"\"\n    \n    in_rows, in_cols = len(input_grid), len(input_grid[0])\n    pattern_h = len(seed_pattern_output)\n    out_rows =  seed_region_input[0] + pattern_h\n   \n    return out_rows, in_cols\n\n\ndef transform(input_grid):\n  # initialize output_grid\n  input_grid = np.array(input_grid)\n  in_rows, in_cols = input_grid.shape\n\n  # use training pairs to define the seed pattern and target area\n  for train_input, train_output in zip(train_inputs, train_outputs):\n        \n        t_in = np.array(train_input)\n        t_out = np.array(train_output)\n\n        # Find changing pixels\n        t_changing_pixels_input = find_changing_pixels(t_in, t_out)\n        t_changing_pixels_output = find_changing_pixels(t_out, t_in)\n\n        # Get bounds of changing pixels\n        t_in_seed_min_row, t_in_seed_max_row, t_in_seed_min_col, t_in_seed_max_col = get_bounds(t_changing_pixels_input)\n        t_out_seed_min_row, t_out_seed_max_row, t_out_seed_min_col, t_out_seed_max_col = get_bounds(t_changing_pixels_output)\n                \n        # check for quadrant repl\n        if (t_in_seed_min_row == in_rows // 2 and t_in_seed_min_col == in_cols // 2 and\n            t_in_seed_max_row == in_rows - 1 and t_in_seed_max_col == in_cols - 1):\n          return quadrant_replication(input_grid)\n\n  # extract sub_grid, get dimensions and calc output size\n  t_seed_pattern = t_out[t_out_seed_min_row:t_out_seed_max_row+1, t_out_seed_min_col:t_out_seed_max_col+1]\n\n  # output size\n  out_rows, out_cols = get_output_dimensions(t_in,(t_in_seed_min_row, t_in_seed_max_row, t_in_seed_min_col, t_in_seed_max_col), t_seed_pattern)  \n  output_grid = np.full((out_rows, out_cols), -1, dtype=int)  # Initialize with -1\n \n  # copy unchanged\n  for i in range(min(in_rows, out_rows)):\n        for j in range(min(in_cols,out_cols)):\n          if i < t_in_seed_min_row or i > t_in_seed_max_row or j < t_in_seed_min_col or j > t_in_seed_max_col:\n            if i < out_rows and j < out_cols: # Check output bounds\n              output_grid[i,j] = input_grid[i,j]\n\n\n    # replicate pattern\n  seed_h, seed_w = t_seed_pattern.shape\n  for i in range(t_in_seed_min_row, min(t_in_seed_max_row + 1,out_rows)): # Limit by output rows\n      for j in range(t_in_seed_min_col, min(t_in_seed_max_col + 1, out_cols)): # Limit by output cols\n          output_grid[i, j] = t_seed_pattern[(i - t_in_seed_min_row) % seed_h, (j - t_in_seed_min_col) % seed_w]\n\n\n  return output_grid.tolist()\n\n# store training pairs globally\ntrain_inputs = [\n    [\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 4, 4, 4, 4, 4, 2, 2, 4, 2, 4, 4],\n        [4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 8, 3, 8, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 8, 3, 8, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n    ],\n    [\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 1, 1, 1, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 8, 2, 8, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    ],\n[\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 6, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 8, 9, 9, 8, 1, 1, 1],\n        [1, 1, 1, 1, 1, 9, 4, 4, 9, 1, 1, 1],\n        [1, 1, 1, 1, 1, 9, 4, 4, 9, 1, 1, 1],\n        [1, 1, 1, 1, 1, 8, 9, 9, 8, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    ]\n]\n\ntrain_outputs = [\n  [\n    [8, 3, 8, 8, 3, 8, 4, 4, 4, 8, 3, 8],\n    [3, 4, 3, 3, 4, 3, 4, 4, 4, 3, 4, 3],\n    [8, 3, 8, 8, 3, 8, 4, 4, 4, 8, 3, 8],\n    [8, 3, 8, 4, 4, 4, 8, 3, 8, 8, 3, 8],\n    [3, 4, 3, 4, 4, 4, 3, 4, 3, 3, 4, 3],\n    [8, 3, 8, 4, 4, 4, 8, 3, 8, 8, 3, 8],\n    [4, 4, 4, 8, 3, 8, 4, 4, 4, 8, 3, 8],\n    [4, 4, 4, 3, 4, 3, 4, 4, 4, 3, 4, 3],\n    [4, 4, 4, 8, 3, 8, 4, 4, 4, 8, 3, 8],\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n],\n  [\n        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [8, 2, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 2, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 2, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    ],\n[\n        [8, 9, 9, 8, 8, 9, 9, 8, 8, 9, 9, 8],\n        [9, 4, 4, 9, 9, 4, 4, 9, 9, 4, 4, 9],\n        [9, 4, 4, 9, 9, 4, 4, 9, 9, 4, 4, 9],\n        [8, 9, 9, 8, 8, 9, 9, 8, 8, 9, 9, 8],\n        [8, 9, 9, 8, 1, 1, 1, 1, 8, 9, 9, 8],\n        [9, 4, 4, 9, 1, 1, 1, 1, 9, 4, 4, 9],\n        [9, 4, 4, 9, 1, 1, 1, 1, 9, 4, 4, 9],\n        [8, 9, 9, 8, 1, 1, 1, 1, 8, 9, 9, 8],\n        [1, 1, 1, 1, 8, 9, 9, 8, 1, 1, 1, 1],\n        [1, 1, 1, 1, 9, 4, 4, 9, 1, 1, 1, 1],\n        [1, 1, 1, 1, 9, 4, 4, 9, 1, 1, 1, 1],\n        [1, 1, 1, 1, 8, 9, 9, 8, 1, 1, 1, 1]\n    ]\n\n]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 2464,
            "end_index": 2660,
            "uri": "https://github.com/ZainMunir/aoc-2023",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28976,
    "candidates_token_count": 4991,
    "total_token_count": 33967,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 55.147329
}