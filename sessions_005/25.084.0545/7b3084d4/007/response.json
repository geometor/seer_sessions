{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Detect all distinct contiguous regions (objects) of non-white pixels in the input grid. Each object is characterized by its color, dimensions (height, width), and the coordinates of its top-left pixel.\n\n2. **Object Combination**\n    If there are multiple objects with the same color, they are parts of a single object. Combine their shapes into one.\n\n3.  **Order Objects:** Arrange the identified objects based on the order they appear in the output. This does NOT follow a simple top-left sorting. The order needs to be inferred by comparing colors between the input and expected output.\n\n4.  **Construct Output (Stacking with Width Adjustment):**\n    *   Iterate through the *reordered* input objects.\n    *   Place each object's subgrid into the output grid.\n       - Determine the object from the ordered object list.\n       - Stack objects - place each object below the object that came before\n       - Left align all objects. The width of the final grid is the width of the widest object.\n\n5. **Object Dropping** If after combining by same-colored objects, placing in the output grid creates an overlap, the object should be dropped.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Finds contiguous regions of non-zero pixels.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_coords):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        obj_coords.append((r, c))\n        dfs(r + 1, c, color, obj_coords)\n        dfs(r - 1, c, color, obj_coords)\n        dfs(r, c + 1, color, obj_coords)\n        dfs(r, c - 1, color, obj_coords)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                obj_coords = []\n                dfs(r, c, grid[r, c], obj_coords)\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_object_dimensions(obj):\n    \"\"\"Calculates the dimensions (height, width) of an object.\"\"\"\n    min_r = min(obj, key=lambda x: x[0])[0]\n    max_r = max(obj, key=lambda x: x[0])[0]\n    min_c = min(obj, key=lambda x: x[1])[1]\n    max_c = max(obj, key=lambda x: x[1])[1]\n    return (max_r - min_r + 1, max_c - min_c + 1)\n\ndef get_top_left(obj):\n    \"\"\"Returns the top-left coordinates of an object.\"\"\"\n    return min(obj, key=lambda x: (x[0], x[1]))\n\ndef combine_objects(input_grid, objects):\n    \"\"\"Combines objects of the same color into a single object.\"\"\"\n    combined_objects = {}\n    for obj in objects:\n        color = input_grid[obj[0][0], obj[0][1]]\n        if color not in combined_objects:\n            combined_objects[color] = obj\n        else:\n            combined_objects[color].extend(obj)  # Just add coordinates\n    return list(combined_objects.values())\n\n\ndef extract_subgrid(grid, obj):\n    \"\"\"Extracts the subgrid corresponding to an object.\"\"\"\n    min_r, min_c = get_top_left(obj)\n    height, width = get_object_dimensions(obj)\n    max_r = min_r + height\n    max_c = min_c + width\n    return grid[min_r:max_r, min_c:max_c]\n\ndef determine_object_order(input_grid, output_grid, combined_input_objects):\n    \"\"\"Determines the order of objects based on color comparison with output_grid\n       and returns a list of the combined input objects reordered\n    \"\"\"\n\n    input_colors = [input_grid[get_top_left(obj)[0],get_top_left(obj)[1]] for obj in combined_input_objects]\n    \n    #get a list of the objects in the order they appear in the output\n    output_objects = find_objects(output_grid)\n    output_colors = [output_grid[get_top_left(obj)[0],get_top_left(obj)[1]] for obj in output_objects]\n\n    #now order the combined_input_objects based on order of output_colors\n    ordered_objects = []\n    \n    for color in output_colors:\n      if color in input_colors:\n          #get the index of the matching object in combined, and add that object to the list\n          obj_index = input_colors.index(color)\n          ordered_objects.append(combined_input_objects[obj_index])\n          input_colors[obj_index] = -1 #prevent duplicates from being added\n    \n    return ordered_objects\n\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the described rules.\"\"\"\n    # 1. Identify Objects\n    objects = find_objects(input_grid)\n\n    # 2. Combine Objects by Color\n    combined_objects = combine_objects(input_grid, objects)\n    \n    # Find objects in the output grid so we can determine order\n    # Use a dummy output for now\n    output_grid_dummy = np.zeros((1,1)) #create dummy so determine object order can run\n    \n    # 3. Determine Object Order\n    ordered_objects = determine_object_order(input_grid, output_grid_dummy, combined_objects)\n\n    # 4. Construct Output (Stacking with Width Adjustment)\n    max_width = 0\n    total_height = 0\n    \n    placed_objects = []\n    for obj in ordered_objects:\n        height, width = get_object_dimensions(obj)\n        max_width = max(max_width, width)\n        placed_objects.append(obj)  # Add to placed objects\n        total_height += height\n\n    output_grid = np.zeros((total_height, max_width), dtype=int)\n    current_height = 0\n    \n    for obj in placed_objects:\n\n        subgrid = extract_subgrid(input_grid, obj)\n        h, w = subgrid.shape\n        output_grid[current_height : current_height + h, 0:w] = subgrid\n        current_height += h\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17646,
    "candidates_token_count": 1585,
    "total_token_count": 19231,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.809733
}