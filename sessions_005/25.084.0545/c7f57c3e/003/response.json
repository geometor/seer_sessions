{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies contiguous regions of the same color as distinct objects. It detects changes by comparing the input and output grids.\nFor each changed pixel location in the output, it finds a matching object in the input grid, or creates a new object if no exact match is found.\nThe best match is moved to the target location. Objects can be moved or created. Objects left behind are deleted.\nThe most frequent color in the grid is considered the background and remains unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_objects(grid):\n    \"\"\"Identifies contiguous regions of the same color as distinct objects.\"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_id):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or visited[r, c] or grid[r, c] != color):\n            return []\n        visited[r, c] = True\n        region = [(r, c)]\n        region.extend(dfs(r + 1, c, color, obj_id))\n        region.extend(dfs(r - 1, c, color, obj_id))\n        region.extend(dfs(r, c + 1, color, obj_id))\n        region.extend(dfs(r, c - 1, color, obj_id))\n        return region\n\n    obj_id_counter = 0\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c]:\n                color = grid[r, c]\n                region = dfs(r, c, color, obj_id_counter)\n                if region:\n                    objects.append({\n                        \"id\": obj_id_counter,\n                        \"color\": color,\n                        \"pixels\": region,\n                        \"shape\": \"irregular\",  # Initial shape\n                        \"size\": len(region)\n                    })\n                    obj_id_counter +=1\n    return objects\n\ndef calculate_object_bounds(pixels):\n    \"\"\"Calculate the bounding box of an object.\"\"\"\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    for r, c in pixels:\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n    return (min_r, min_c), (max_r, max_c)\n\ndef get_object_shape(pixels):\n   bounds = calculate_object_bounds(pixels)\n   height = bounds[1][0] - bounds[0][0] + 1\n   width = bounds[1][1] - bounds[0][1] + 1\n\n   if height == 1 or width == 1:\n      return \"line\"\n   if height == width:\n       return \"square\"\n   return \"rectangle\"\n\n\n\n\ndef find_best_match(input_objects, color, size, shape, target_r, target_c, output_grid):\n    \"\"\"Find the best matching object in the input grid.\"\"\"\n    best_match = None\n    best_score = -1\n\n    for obj in input_objects:\n           \n        # Check if the object can explain the changed pixel\n        \n        # Calculate object dimensions\n        bounds = calculate_object_bounds(obj['pixels'])\n        obj_height = bounds[1][0] - bounds[0][0] + 1\n        obj_width = bounds[1][1] - bounds[0][1] + 1\n        \n        \n        if obj['color'] == color and len(obj['pixels']) >=1: #size\n            score = 0\n            \n            if get_object_shape(obj['pixels']) == shape:\n               score +=1\n           \n            \n            # Prioritize objects with some overlap with existing\n            overlap = False\n            for r,c in obj['pixels']:\n               if 0 <= target_r < output_grid.shape[0] and 0<= target_c < output_grid.shape[1]:\n\n                   if output_grid[r,c] == obj['color']:\n                      overlap = True\n                      break\n            if overlap:\n               score+=2\n            \n            if score > best_score:\n               best_score = score\n               best_match = obj\n\n\n    return best_match\n\ndef move_object(grid, obj, target_r, target_c):\n    \"\"\"Moves an object to a new location.\"\"\"\n    new_grid = np.copy(grid)\n    # Calculate object bounds\n    bounds = calculate_object_bounds(obj['pixels'])\n    obj_height = bounds[1][0] - bounds[0][0] + 1\n    obj_width = bounds[1][1] - bounds[0][1] + 1\n\n    # Calculate the offset\n    dr = target_r - bounds[0][0]\n    dc = target_c - bounds[0][1]\n\n     #Clear old position, but preserve background\n    for r,c in obj['pixels']:\n        new_grid[r,c] = get_background_color(grid)\n    \n    # Move object\n    new_pixels = []\n    for r, c in obj['pixels']:\n         new_r = r + dr\n         new_c = c + dc\n         if 0<= new_r < new_grid.shape[0] and 0 <= new_c < new_grid.shape[1]:\n            new_grid[new_r, new_c] = obj['color']\n            new_pixels.append((new_r, new_c))\n    obj['pixels'] = new_pixels #update object pixels\n\n    return new_grid, obj\n\ndef get_background_color(grid):\n    \"\"\"Determines the background color.\"\"\"\n    return Counter(grid.flatten()).most_common(1)[0][0]\n\ndef create_object(color, size, shape, r, c, output_grid):\n    new_obj = {\n        'id': -1, # Placeholder ID, will be corrected later\n        'color': color,\n        'pixels': [],\n        'shape':shape,\n        'size': size\n    }\n\n    height = 0\n    width = 0\n    if shape == 'square':\n       height = int(np.sqrt(size))\n       width = int(np.sqrt(size))\n    elif shape == 'rectangle':\n\n        if r+1 < output_grid.shape[0] and output_grid[r,c] != output_grid[r+1,c]:\n            width = size\n            height = 1\n        elif c+1 < output_grid.shape[1] and output_grid[r,c] != output_grid[r,c+1]:\n            height = size\n            width = 1\n    elif shape == 'line':\n         if r+1 < output_grid.shape[0] and output_grid[r,c] == output_grid[r+1,c]:\n             height = size\n             width=1\n         elif c+1 < output_grid.shape[1] and output_grid[r,c] == output_grid[r,c+1]:\n             width = size\n             height = 1\n    \n    for i in range(height):\n        for j in range(width):\n             curr_r = r + i\n             curr_c = c + j\n             if 0<= curr_r < output_grid.shape[0] and 0<= curr_c < output_grid.shape[1]:\n                new_obj['pixels'].append((curr_r,curr_c))\n                output_grid[curr_r,curr_c] = color\n\n    return output_grid, new_obj\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the identified rule.\"\"\"\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    background_color = get_background_color(input_grid)\n\n    # Find objects in the input grid\n    input_objects = find_objects(input_grid)\n    created_objects = []\n\n    # Detect changed pixels (between input and expected output, in practice we don't have this)\n    # Here, for demonstration purposes, I assume a hypothetical 'expected_output'\n    # In a real scenario, we would analyze changes and infer them.\n    \n    # Find changes\n    changed_pixels = []\n    for obj in find_objects(output_grid):\n        initial_color = -1\n        for r,c in obj['pixels']:\n           if input_grid[r,c] != output_grid[r,c]:\n              initial_color = input_grid[r,c]\n              changed_pixels.append((r,c,obj['color'], initial_color, get_object_shape(obj['pixels']), obj['size']))\n\n    \n    processed = []\n    for r, c, new_color, initial_color, shape, size in changed_pixels:\n        \n      if (r,c) not in processed:\n        # Find the best matching object\n        best_match = find_best_match(input_objects, new_color,size, shape, r,c, output_grid) # use output grid for overlap detection\n\n        if best_match is not None:\n            # Move the object\n            output_grid, best_match = move_object(output_grid, best_match, r, c)\n            for rp, cp in best_match['pixels']:\n                processed.append((rp,cp))\n        else:\n\n            output_grid, new_obj = create_object(new_color, size, shape, r, c, output_grid)\n            if len(new_obj['pixels']) > 0:\n               created_objects.append(new_obj)\n            for rp, cp in new_obj['pixels']:\n                processed.append((rp,cp))\n    \n    # Correct the IDs of created objects\n    next_id = max([obj['id'] for obj in input_objects], default=-1) + 1\n    for obj in created_objects:\n      obj['id'] = next_id\n      next_id+=1\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13265,
    "candidates_token_count": 2413,
    "total_token_count": 15678,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 38.833768
}