{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify the Frame:** Determine the outermost rows and columns (the \"frame\") of the input grid. Note the colors present in the frame.\n2.  **Identify Inside Objects:** Identify all contiguous objects (clusters of the same color) that are *not* part of the frame. Preserve their color and order from top-to-bottom, and left-to-right.\n3. **Create Output:**\n   * Example 1 - The frame of the input is represented as the first column of the output. The objects inside the frame from the input grid are stacked next to the frame, preserving order.\n   * Example 2 - The frame of the input is presented as the first *row* of the output. The objects inside the input frame are stacked *above* the frame, preserving order.\n4. **Resize and Populate:**\n    *  Example 1: The output grid has the same number of rows (height) as the input. The output width is equal to the number of inside objects + 1 (for the frame).\n   * Example 2: The output grid has the same number of columns (width) as the input grid. The output height is determined by the number of inside objects, plus one (for the frame).\n5. **Object Placement:** Inside objects are placed next to the frame, preserving their colors and original order.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"\n    Finds contiguous objects (regions of the same color) in a grid.\n    Returns a list of objects, where each object is a list of (row, col) coordinates.\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(row, col, color, current_object):\n        if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] != color:\n            return\n        visited.add((row, col))\n        current_object.append((row, col))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dfs(row + dr, col + dc, color, current_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                current_object = []\n                dfs(r, c, grid[r, c], current_object)\n                if current_object:\n                    objects.append(current_object)\n    return objects\n\ndef get_frame_coords(grid):\n    \"\"\"Returns a set of (row, col) tuples representing the frame.\"\"\"\n    rows, cols = grid.shape\n    frame = set()\n    for r in range(rows):\n        frame.add((r, 0))\n        frame.add((r, cols - 1))\n    for c in range(1, cols - 1):\n        frame.add((0, c))\n        frame.add((rows - 1, c))\n    return frame\n\n\ndef get_inside_objects(grid, frame_coords):\n    \"\"\"\n    Returns a list of objects inside the frame, preserving their original order.\n    \"\"\"\n    all_objects = find_objects(grid)\n    inside_objects = []\n    for obj in all_objects:\n        if not any((r, c) in frame_coords for r, c in obj):\n            inside_objects.append(obj)\n    return inside_objects\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify the Frame\n    frame_coords = get_frame_coords(input_grid)\n    frame_objects = []\n    for obj in find_objects(input_grid):\n      if any((r,c) in frame_coords for r, c in obj):\n        frame_objects.append(obj)\n\n    # 2. Identify Inside Objects\n    inside_objects = get_inside_objects(input_grid, frame_coords)\n\n    # 3. & 4. Create and Resize Output Grid\n    if rows > cols:  # Example 1 type\n        output_grid = np.full((rows, len(inside_objects) + 1), -1)\n\n        # Place frame objects in the first column\n        frame_row_index = 0\n        for obj in frame_objects:\n            for r, c in obj:\n              if frame_row_index < output_grid.shape[0]:\n                output_grid[frame_row_index, 0] = input_grid[r,c]\n                frame_row_index += 1\n\n        # Place inside objects starting from the second column\n        col_index = 1\n        for obj in inside_objects:\n            for r, c in obj:\n              if r < output_grid.shape[0]:\n                output_grid[r, col_index] = input_grid[r, c]\n            \n            col_index += 1\n\n\n    else:  # Example 2 type\n        output_grid = np.full((len(inside_objects) + 1, cols), -1)\n\n        # Place frame along first row\n        frame_col_index = 0\n        for obj in frame_objects:\n            for r,c in obj:\n                if frame_col_index < output_grid.shape[1]:\n                    output_grid[0, frame_col_index] = input_grid[r,c]\n                    frame_col_index+=1\n\n        # Place inside objects, stacked\n        row_index = 1\n        for obj in inside_objects:\n          for r, c in obj:\n              if c < output_grid.shape[1]:\n                output_grid[row_index, c] = input_grid[r, c]\n\n          row_index += 1\n            \n    output_grid = np.where(output_grid == -1, 9, output_grid) # Fill empty with 9\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12291,
    "candidates_token_count": 1389,
    "total_token_count": 13680,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 19.515431
}