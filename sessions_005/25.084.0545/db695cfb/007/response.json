{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Background:** Find the most frequent color in the input grid. This is the background color.\n2.  **Identify Objects:**\n    *   Locate all contiguous regions (connected horizontally or vertically) of non-background color. Each region is a distinct object.\n    *   Record the initial positions and color of each object.\n3.  **Check for Single Object and Shift Condition**:\n    *  Count object locations.\n    *  If a single color is present in the input grid, and its number of start locations is less than or equal to two, then perform a vertical shift:\n      *  Move the entire object upwards (as a unit) in the grid until a non-background pixel is adjacent vertically to another non-background pixel, or the object has reached the top row.\n4.  **Expansion (if not shifted):** If shift condition is not met (i.e. more than 1 object, or a single object with more than 2 start locations), perform iterative cross expansion:\n    *   Iterate through each object's pixels.  For each pixel:\n        *   Expand the object's color into all adjacent (up, down, left, right) background pixels.\n        *   If multiple objects try to expand into the same background pixel:\n            *   If one of the competing colors is 6 and another is 1, color 6 overwrites color 1.\n            *   Other interactions are not defined by the given examples, so apply no change.\n        * repeat expansion until no pixels change.\n5.  **Output:** Return the final grid after either shifting or expansion.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef get_background_color(grid):\n    flat_grid = grid.flatten()\n    color_counts = Counter(flat_grid)\n    return color_counts.most_common(1)[0][0]\n\ndef find_objects(grid, background_color):\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = {}\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, object_pixels):\n        if not is_valid(r, c) or visited[r, c] or grid[r, c] != color:\n            return\n        visited[r, c] = True\n        object_pixels.append((r, c))\n        dfs(r + 1, c, color, object_pixels)\n        dfs(r - 1, c, color, object_pixels)\n        dfs(r, c + 1, color, object_pixels)\n        dfs(r, c - 1, color, object_pixels)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                object_pixels = []\n                dfs(r, c, color, object_pixels)\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(object_pixels)\n    return objects\n\ndef shift_object(grid, object_pixels, color, background_color):\n    # shift object up\n    rows, cols = grid.shape\n    min_row = min(r for r, c in object_pixels)\n    height = max(r for r, c in object_pixels) - min_row + 1\n    new_grid = np.full(grid.shape, background_color, dtype=grid.dtype)\n\n    # Calculate the shift amount, preventing out-of-bounds access\n    shift = min_row\n\n    # Copy object to new location\n    for r, c in object_pixels:\n        new_grid[r-shift,c] = color\n        \n    return new_grid\n\ndef expand_object(grid, object_pixels, color, background_color):\n    new_pixels = set()\n    rows, cols = grid.shape\n    for r, c in object_pixels:\n      #Check neighbors and add them to new_pixels if they are background\n      neighbors = [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]\n      for nr, nc in neighbors:\n          if 0 <= nr < rows and 0 <= nc < cols and grid[nr,nc] == background_color:\n              new_pixels.add((nr,nc))\n\n    return new_pixels\n\ndef transform(input_grid):\n    # Convert input_grid to numpy array\n    input_grid = np.array(input_grid)\n\n    # 1. Identify the Background\n    background_color = get_background_color(input_grid)\n\n    # 2. Identify Objects\n    objects = find_objects(input_grid, background_color)\n    \n    # 3. Construct Output Grid (initialize with background)\n    output_grid = np.full(input_grid.shape, background_color, dtype=input_grid.dtype)\n\n    # Check for single object and shift condition\n    if len(objects) == 1 and sum(len(obj) for obj in objects.values()) <= 2:\n        color = list(objects.keys())[0]\n        # shift only one object\n        object_pixels = objects[color][0]  # Assuming single object\n        output_grid = shift_object(input_grid, object_pixels, color, background_color)\n    else:\n        # 4. Expansion\n       \n        # first copy initial object locations\n        output_grid = np.copy(input_grid)\n\n        while True:\n            new_pixels_to_add = {} # (r,c) : color\n            \n            # gather new pixels from each object\n            all_objects = find_objects(output_grid, background_color)\n            for color, object_instances in all_objects.items():\n                for object_pixels in object_instances:\n                    expanded_pixels = expand_object(output_grid, object_pixels, color, background_color)\n                    for r,c in expanded_pixels:\n                        if (r,c) not in new_pixels_to_add:\n                            new_pixels_to_add[(r,c)] = color\n                        else:\n                            # color interactions\n                            if color == 6 and new_pixels_to_add[(r,c)] == 1:\n                                new_pixels_to_add[(r,c)] = 6\n                            elif color == 1 and new_pixels_to_add[(r,c)] == 6:\n                                 new_pixels_to_add[(r,c)] = 6 # 6 wins\n                                \n\n            if not new_pixels_to_add:\n              break\n\n            # Apply changes, handle collision\n            for (r,c), color in new_pixels_to_add.items():\n                output_grid[r,c] = color\n                \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16380,
    "candidates_token_count": 1605,
    "total_token_count": 17985,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 22.664256
}