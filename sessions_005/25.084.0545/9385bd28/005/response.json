{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation involves a series of color expansions, some of which are localized (top/bottom halves of the grid) and some are global. The expansion of a color is defined by what colors it can overwrite and what colors stop it.\n\n1.  **Local Expansions (Top/Bottom Half):**\n    *   If the top half contains color 3 (green), expand color 3 upwards, overwriting color 0 (white), and stopping at colors 1, 2, 4, 5, 6, 7, 8, and 9.\n    *   If the top half contains color 4 (yellow), expand color 4 upwards, overwriting color 0, and stopping at colors 1, 2, 3, 5, 6, 7, 8, and 9.\n    * If the bottom half contains color 6(magenta) and 7(orange), expand the region of 6, overwriting 0 and stopping at colors 1, 2, 3, 4, 5, 7, 8 and 9. Within the expanded region of 6, expand 7 overwriting 0 and 6, stopping at colors 1, 2, 3, 4, 5, 8 and 9.\n    *   If the bottom half contains color 7 (orange) *without* color 6, expand color 7, overwriting color 0 and stopping at colors 1, 2, 3, 4, 5, 6, 8 and 9.\n\n2.  **Global Expansions:**\n    *   Expand color 5 (gray), overwriting color 0 (white) and stopping at colors 1, 2, 3, 4, 6, 7, 8, and 9.\n    *   Expand color 6 (magenta), overwriting colors 0, 3, 4, 5, 7, 8, and 9, and stopping at colors 1 and 2.\n    *   Expand color 9 (maroon), overwriting colors 0, 4, 5, 6, 7, and 8, and stopping at colors 1, 2, and 3.\n\n3.  **Masked Expansion**\n     * If color 3 and 5 are both in the output: Expand color 3, overwriting colors 0 and 5, and stopping at colors at 1, 2, 4, 6, 7, 8 and 9. *Only* expand color 3 *within* regions that were previously color 5.\n\n4. Order of operations: Local top, Local bottom, Global 5, Global 6, Global 9, Masked 3.\n\"\"\"\n\nimport numpy as np\n\ndef find_regions(grid, color):\n    \"\"\"Finds contiguous regions of a given color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(row, col):\n        \"\"\"Depth-first search to find contiguous region.\"\"\"\n        if (row < 0 or row >= rows or col < 0 or col >= cols or\n                visited[row, col] or grid[row, col] != color):\n            return []\n\n        visited[row, col] = True\n        region = [(row, col)]\n\n        region.extend(dfs(row + 1, col))\n        region.extend(dfs(row - 1, col))\n        region.extend(dfs(row, col + 1))\n        region.extend(dfs(row, col - 1))\n        return region\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                regions.append(dfs(r, c))\n    return regions\n\ndef expand_region(grid, region, fill_color, overwrite_colors, stop_colors):\n    \"\"\"Expands a region, replacing specified colors and stopping at others.\"\"\"\n    expanded_region = set(region)\n    queue = region[:]\n    rows, cols = grid.shape\n\n    while queue:\n        row, col = queue.pop(0)\n        neighbors = [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\n        for nr, nc in neighbors:\n            if (0 <= nr < rows and 0 <= nc < cols and\n                (nr, nc) not in expanded_region):\n                pixel_color = grid[nr, nc]\n                if pixel_color in overwrite_colors:\n                    expanded_region.add((nr, nc))\n                    queue.append((nr, nc))\n                elif pixel_color in stop_colors:\n                    continue\n\n    return list(expanded_region)\n\ndef apply_transformation_pass(input_grid, anchor_color, fill_color, overwrite_colors, stop_colors, local_region=None):\n    \"\"\"Applies a single pass of the transformation, expanding from anchor color.\"\"\"\n    output_grid = np.copy(input_grid)\n    if local_region == \"top_half\":\n        grid_slice = output_grid[:output_grid.shape[0] // 2, :]\n    elif local_region == \"bottom_half\":\n        grid_slice = output_grid[output_grid.shape[0] // 2:, :]\n    else:\n        grid_slice = output_grid\n\n    anchor_regions = find_regions(grid_slice, anchor_color)\n\n    for region in anchor_regions:\n      expanded = expand_region(grid_slice, region, fill_color, overwrite_colors, stop_colors)\n      for r, c in expanded:\n          if local_region == \"top_half\":\n              output_grid[r,c] = fill_color #no offset needed\n          elif local_region == \"bottom_half\":\n              output_grid[r + output_grid.shape[0] // 2, c] = fill_color\n          else:\n            output_grid[r,c] = fill_color\n\n    return output_grid\n\ndef apply_masked_expansion(grid, fill_color, mask_color, overwrite_colors, stop_colors):\n     \"\"\"Expands fill_color within the mask, overwriting specified colors.\"\"\"\n     output_grid = np.copy(grid)\n     mask = (grid == mask_color)\n     regions = find_regions(grid, fill_color)\n     for region in regions:\n        expanded = expand_region(grid, region, fill_color, overwrite_colors, stop_colors)\n        for r, c in expanded:\n            if mask[r,c]:\n                output_grid[r,c] = fill_color\n     return output_grid\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Local Expansions (Top/Bottom Half)\n    # Top half: Expand 3 upwards\n    output_grid = apply_transformation_pass(output_grid, 3, 3, [0], [1, 2, 4, 5, 6, 7, 8, 9], local_region=\"top_half\")\n    # Top half: Expand 4 upwards\n    output_grid = apply_transformation_pass(output_grid, 4, 4, [0], [1, 2, 3, 5, 6, 7, 8, 9], local_region=\"top_half\")\n\n    # Bottom half: Expand 6, then 7 within 6 (if both present)\n    if 6 in output_grid[rows // 2:, :] and 7 in output_grid[rows // 2:, :]:\n        output_grid = apply_transformation_pass(output_grid, 6, 6, [0], [1, 2, 3, 4, 5, 7, 8, 9], local_region=\"bottom_half\")\n        output_grid = apply_masked_expansion(output_grid, 7, 6, [0, 6], [1, 2, 3, 4, 5, 8, 9])\n\n    # Bottom half: Expand 7 (if 6 is not present)\n    elif 7 in output_grid[rows // 2:, :]:\n        output_grid = apply_transformation_pass(output_grid, 7, 7, [0], [1, 2, 3, 4, 5, 6, 8, 9], local_region=\"bottom_half\")\n\n    # 2. Global Expansions\n    output_grid = apply_transformation_pass(output_grid, 5, 5, [0], [1, 2, 3, 4, 6, 7, 8, 9])  # Expand 5\n    output_grid = apply_transformation_pass(output_grid, 6, 6, [0, 3, 4, 5, 7, 8, 9], [1, 2])  # Expand 6\n    output_grid = apply_transformation_pass(output_grid, 9, 9, [0, 4, 5, 6, 7, 8], [1, 2, 3])  # Expand 9\n\n    # 3. Masked expansion\n    output_grid = apply_masked_expansion(output_grid, 3, 5, [0,5], [1,2,4,6,7,8,9])\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9177,
    "candidates_token_count": 2233,
    "total_token_count": 11410,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 25.84044
}