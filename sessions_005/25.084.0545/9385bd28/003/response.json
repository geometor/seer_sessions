{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms input grids by performing a series of region expansions. The\ntransformations can be local (top/bottom halves) or global, with specific rules\nfor each color regarding what it can overwrite and what colors stop its\nexpansion. The order of expansions is important and can vary between examples.\n\"\"\"\n\nimport numpy as np\n\ndef find_regions(grid, color):\n    \"\"\"Finds contiguous regions of a given color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(row, col):\n        \"\"\"Depth-first search to find contiguous region.\"\"\"\n        if (row < 0 or row >= rows or col < 0 or col >= cols or\n                visited[row, col] or grid[row, col] != color):\n            return []\n\n        visited[row, col] = True\n        region = [(row, col)]\n\n        region.extend(dfs(row + 1, col))\n        region.extend(dfs(row - 1, col))\n        region.extend(dfs(row, col + 1))\n        region.extend(dfs(row, col - 1))\n        return region\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                regions.append(dfs(r, c))\n    return regions\n\ndef expand_region(grid, region, fill_color, overwrite_colors, stop_colors):\n    \"\"\"Expands a region, replacing specified colors and stopping at others.\"\"\"\n    expanded_region = set(region)  # Use a set for efficient membership checking\n    queue = region[:]\n    rows, cols = grid.shape\n\n    while queue:\n        row, col = queue.pop(0)\n        # Consider neighbors (up, down, left, right)\n        neighbors = [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\n        for nr, nc in neighbors:\n            if (0 <= nr < rows and 0 <= nc < cols and\n                (nr, nc) not in expanded_region):\n                pixel_color = grid[nr, nc]\n                if pixel_color in overwrite_colors:\n                    expanded_region.add((nr, nc))\n                    queue.append((nr, nc))\n                elif pixel_color in stop_colors:  #stop the spread, dont add to queue\n                    continue\n\n    return list(expanded_region)\n\ndef apply_transformation_pass(input_grid, anchor_color, fill_color, overwrite_colors, stop_colors):\n    \"\"\"Applies a single pass of the transformation, expanding from anchor color.\"\"\"\n    output_grid = np.copy(input_grid)\n    anchor_regions = find_regions(input_grid, anchor_color)\n\n    for region in anchor_regions:\n      expanded = expand_region(input_grid, region, fill_color, overwrite_colors, stop_colors)\n      for r, c in expanded:\n        output_grid[r,c] = fill_color\n\n    return output_grid\n\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Check for top/bottom split behavior (Examples 1 and 4)\n    top_half = input_grid[:rows // 2, :]\n    bottom_half = input_grid[rows // 2:, :]\n\n    # Example 1: Green (3) expands upwards in the top half.\n    if 3 in top_half and not np.array_equal(top_half, apply_transformation_pass(top_half, 3, 3, [0], [1, 2])):\n        output_grid[:rows // 2, :] = apply_transformation_pass(top_half, 3, 3, [0], [1, 2,4,5,6,7,8,9])\n\n    # Example 4: Green(3) and Yellow(4)\n    if 3 in top_half:\n      output_grid[:rows // 2, :] = apply_transformation_pass(top_half, 3, 3, [0], [1, 2,4,5,6,7,8,9])\n    if 4 in top_half:\n      output_grid[:rows // 2, :] = apply_transformation_pass(top_half, 4, 4, [0], [1, 2,3,5,6,7,8,9])\n\n    # example 4: color 7 within color 6 region\n    if 6 in bottom_half and 7 in bottom_half:\n        # First expand 6 in the bottom half\n        bottom_half_expanded_6 = apply_transformation_pass(bottom_half, 6, 6, [0], [1,2,3,4,5,7,8,9])\n\n        # Create a mask for the expanded 6 region\n        mask_6 = (bottom_half_expanded_6 == 6)\n\n        # Expand 7, but only within the masked region\n        bottom_half_expanded_7 = np.copy(bottom_half_expanded_6)\n        regions_7 = find_regions(bottom_half, 7) #find initial regions\n        for region in regions_7:\n           expanded_7 = expand_region(bottom_half_expanded_6, region, 7, [0,6], [1,2,3,4,5,8,9]) # expand\n           for r, c in expanded_7:  # apply expansion based on mask\n              if mask_6[r,c]:\n                bottom_half_expanded_7[r, c] = 7  # only change where it was 6\n\n        output_grid[rows // 2:, :] = bottom_half_expanded_7\n\n    elif 7 in bottom_half: # example 1, bottom half has 3\n        output_grid[rows // 2:, :] = apply_transformation_pass(bottom_half, 7, 7, [0], [1,2,3,4,5,6,8,9])\n\n    # 2. Example 2: color 5 expands to fill adjacent 0\n    output_grid = apply_transformation_pass(output_grid, 5, 5, [0], [1,2,3,4,6,7,8,9]) # expand 5 to fill adjacent\n\n    # 3. Global operations (Example 3) - Apply *after* local expansions\n    # example 3: Color 6 first, overwrites all except 1 and 2\n    output_grid = apply_transformation_pass(output_grid, 6, 6, [0,3,4,5,7,8,9], [1,2])\n    # example 3: Color 9 second, overwrites all except 1, 2, and 3\n    output_grid = apply_transformation_pass(output_grid, 9, 9, [0,4,5,6,7,8], [1,2,3])\n\n\n    # 4. Example 2: Color 3 (green) expands inside color 5\n    if 3 in output_grid and 5 in output_grid:\n        mask_5 = (output_grid == 5)  # Create color 5 mask\n        output_grid_expanded_3 = np.copy(output_grid)\n        regions_3 = find_regions(output_grid, 3)  # Find color 3 initial regions\n\n        for region in regions_3:\n           expanded_3 = expand_region(output_grid, region, 3, [0,5], [1,2,4,6,7,8,9]) #expand 3\n           for r,c in expanded_3:\n              if mask_5[r,c]:\n                output_grid_expanded_3[r,c]=3\n\n        output_grid = output_grid_expanded_3\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11565,
    "candidates_token_count": 1880,
    "total_token_count": 13445,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 19.552402
}