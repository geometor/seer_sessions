{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis module transforms an input grid containing white (0) and azure (8) pixels\ninto an output grid of the same dimensions. The transformation involves identifying\ndistinct azure objects, analyzing their properties (specifically, whether they enclose\na \"hole\" of white pixels and their top-right position), and recoloring them\neither blue (1) or red (2) based on specific rules.\n\nThe rules are:\n1. Identify all connected components (objects) of azure (8) pixels.\n2. For each object, determine its bounding box and if it contains a hole (enclosed white area).\n3. Count the number of objects with holes.\n4. If exactly one object has a hole:\n    - This object with the hole is colored blue (1).\n    - Among the objects *without* holes, find the \"top-right-most\" one (minimum row index of the bounding box top edge, breaking ties with maximum column index of the bounding box right edge). This object is colored red (2).\n    - All other objects (without holes, not selected as red) are colored blue (1).\n5. If zero objects have holes:\n    - Among *all* objects, find the \"top-right-most\" one (minimum row index, maximum column index tie-breaker). This object is colored red (2).\n    - All other objects are colored blue (1).\n6. The background white (0) pixels remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, binary_erosion, generate_binary_structure\n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n    Uses 8-connectivity (including diagonals).\n    \"\"\"\n    binary_grid = (grid == color)\n    # Use 8-connectivity\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool)\n    labeled_grid, num_labels = label(binary_grid, structure=structure)\n    \n    objects = []\n    if num_labels > 0:\n        # find_objects returns slices, convert them to coordinates\n        object_slices = find_objects(labeled_grid)\n        for i in range(num_labels):\n            label_id = i + 1\n            coords = tuple(zip(*np.where(labeled_grid == label_id)))\n            # coords is a list of (row, col) tuples\n            objects.append(set(coords)) \n            \n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not obj_pixels:\n        return None\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef has_hole(obj_pixels, grid_shape):\n    \"\"\"\n    Checks if an object, defined by its pixels, encloses a hole of background (0).\n    \n    Args:\n        obj_pixels (set): Set of (row, col) tuples for the object.\n        grid_shape (tuple): (height, width) of the original grid.\n\n    Returns:\n        bool: True if the object has a hole, False otherwise.\n    \"\"\"\n    if not obj_pixels:\n        return False\n\n    min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n    \n    # Create a small grid representing the bounding box area plus a 1-pixel border\n    # The border helps handle objects touching the grid edges correctly.\n    padded_min_r = max(0, min_r - 1)\n    padded_min_c = max(0, min_c - 1)\n    padded_max_r = min(grid_shape[0] - 1, max_r + 1)\n    padded_max_c = min(grid_shape[1] - 1, max_c + 1)\n\n    # Create a boolean grid: True for background, False for object pixels within padded bbox\n    subgrid_shape = (padded_max_r - padded_min_r + 1, padded_max_c - padded_min_c + 1)\n    background_mask = np.ones(subgrid_shape, dtype=bool)\n\n    for r_obj, c_obj in obj_pixels:\n        # Map object coordinates to the padded subgrid coordinates\n        sr, sc = r_obj - padded_min_r, c_obj - padded_min_c\n        if 0 <= sr < subgrid_shape[0] and 0 <= sc < subgrid_shape[1]:\n            background_mask[sr, sc] = False # Mark object pixels as False (not background)\n\n    # Label connected components of the background within the padded bounding box\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool) # 8-connectivity\n    labeled_background, num_labels = label(background_mask, structure=structure)\n\n    if num_labels <= 1:\n        # If there's 0 or 1 background component, no enclosed hole is possible\n        return False\n\n    # Identify the background component connected to the outer border\n    # Any pixel on the border of background_mask corresponds to the outer region\n    border_indices = set()\n    if subgrid_shape[0] > 0:\n        border_indices.update((0, c) for c in range(subgrid_shape[1]))\n        border_indices.update((subgrid_shape[0] - 1, c) for c in range(subgrid_shape[1]))\n    if subgrid_shape[1] > 0:\n        border_indices.update((r, 0) for r in range(subgrid_shape[0]))\n        border_indices.update((r, subgrid_shape[1] - 1) for r in range(subgrid_shape[0]))\n\n    outer_label = None\n    for r_border, c_border in border_indices:\n         # Check bounds just in case shape is 1xN or Nx1\n        if 0 <= r_border < subgrid_shape[0] and 0 <= c_border < subgrid_shape[1]:\n            label_val = labeled_background[r_border, c_border]\n            if label_val > 0: # If it's part of a labeled background component\n                outer_label = label_val\n                break # Found the label connected to the outside\n\n    # If there is any background label (num_labels > 1) that is NOT the outer_label,\n    # it represents an enclosed hole.\n    for i in range(1, num_labels + 1):\n        if i != outer_label:\n            # Check if this component actually exists (sometimes label skips numbers)\n            if np.any(labeled_background == i):\n                 # We found an internal background component, thus a hole exists.\n                 # We must ensure this internal component wasn't caused purely by padding\n                 # Check if any pixel of this component maps back to the original grid's non-padded bbox\n                 component_pixels = np.argwhere(labeled_background == i)\n                 for r_comp, c_comp in component_pixels:\n                     orig_r, orig_c = r_comp + padded_min_r, c_comp + padded_min_c\n                     if min_r <= orig_r <= max_r and min_c <= orig_c <= max_c:\n                         # This hole component exists within the original object's bbox\n                         return True\n\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying azure objects, checking for holes,\n    and applying coloring rules based on hole count and object position.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    output_grid = np.zeros_like(input_grid) # Initialize with background color 0\n    grid_shape = input_grid.shape\n\n    # 1. Identify all separate connected objects composed of azure (8) pixels\n    azure_objects_pixels = find_connected_components(input_grid, 8)\n\n    if not azure_objects_pixels:\n        return output_grid.tolist() # Return background if no objects found\n\n    # 2. Analyze objects: calculate properties\n    objects_data = []\n    for obj_pixels in azure_objects_pixels:\n        min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n        hole = has_hole(obj_pixels, grid_shape)\n        objects_data.append({\n            \"pixels\": obj_pixels,\n            \"min_row\": min_r,\n            \"max_col\": max_c,\n            \"has_hole\": hole\n        })\n\n    # 3. Count objects with holes\n    hole_objects = [obj for obj in objects_data if obj[\"has_hole\"]]\n    non_hole_objects = [obj for obj in objects_data if not obj[\"has_hole\"]]\n    hole_count = len(hole_objects)\n\n    red_object = None\n    blue_objects = []\n\n    # 4-7. Apply coloring logic based on hole count\n    if hole_count == 1:\n        # Hole object is blue\n        blue_objects.append(hole_objects[0])\n        \n        # Find top-right-most among non-hole objects to be red\n        if non_hole_objects:\n            min_row_non_hole = min(obj[\"min_row\"] for obj in non_hole_objects)\n            top_non_hole = [obj for obj in non_hole_objects if obj[\"min_row\"] == min_row_non_hole]\n            \n            max_col_top_non_hole = max(obj[\"max_col\"] for obj in top_non_hole)\n            red_object = next(obj for obj in top_non_hole if obj[\"max_col\"] == max_col_top_non_hole)\n\n            # Add remaining non-hole objects to blue list\n            blue_objects.extend([obj for obj in non_hole_objects if obj != red_object])\n        # Else (no non-hole objects), red_object remains None, and only the hole_object is blue.\n\n    elif hole_count == 0:\n        # Find top-right-most among all objects to be red\n        if objects_data: # Check if there are any objects at all\n            min_row_all = min(obj[\"min_row\"] for obj in objects_data)\n            top_all = [obj for obj in objects_data if obj[\"min_row\"] == min_row_all]\n            \n            max_col_top_all = max(obj[\"max_col\"] for obj in top_all)\n            red_object = next(obj for obj in top_all if obj[\"max_col\"] == max_col_top_all)\n\n            # Add all other objects to blue list\n            blue_objects.extend([obj for obj in objects_data if obj != red_object])\n            \n    # Handle potential cases not explicitly covered by examples (e.g., hole_count > 1)\n    # Based on the examples, we assume hole_count is 0 or 1. \n    # If it could be > 1, the logic might need adjustment. For now, assume 0 or 1.\n    # If hole_count > 1, the current logic results in red_object = None and blue_objects = []\n    # which means nothing gets colored. Let's refine this default - maybe color all blue?\n    # Let's stick to the logic derived strictly from examples for now. If hole_count > 1, nothing is coloured.\n    \n    # 8. Color the red object\n    if red_object:\n        for r, c in red_object[\"pixels\"]:\n            output_grid[r, c] = 2 # Red\n\n    # 9. Color the blue objects\n    for blue_obj in blue_objects:\n        for r, c in blue_obj[\"pixels\"]:\n             # Avoid overwriting red if somehow an object ended up in both lists (shouldn't happen with current logic)\n            if output_grid[r, c] == 0:\n                output_grid[r, c] = 1 # Blue\n\n    # 10. Return the completed output grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3771,
    "candidates_token_count": 2913,
    "total_token_count": 6684,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.573004,
  "retries": null
}