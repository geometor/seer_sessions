
## train_1

**input:**
```
0 0 0 0 6 6 6 6 6 6 6 5 6 6 6 6
0 0 6 0 6 6 6 6 6 6 6 5 6 6 6 6
6 0 0 0 0 6 6 6 6 6 6 5 6 6 6 6
0 0 0 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


**output:**
```
6 6 6 6 6 0 0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 0 0 6 0 6 6 5 6 6 6 6
6 6 6 6 6 6 0 0 0 0 6 5 6 6 6 6
6 6 6 6 6 0 0 0 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


## train_2

**input:**
```
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
```


**output:**
```
6 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 0 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
```


## train_3

**input:**
```
6 0 0 0 0 0 6 5 6 6
6 0 6 6 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 0 6 0 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 0 6 6 0 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 6 6 6 6 6 6 5 6 6
```


**output:**
```
6 6 0 0 0 0 0 5 6 6
6 6 0 6 6 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 0 5 6 6
6 6 0 6 0 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
```

*   **Perception:**
    *   The input and output grids are the same size in each example.
    *   Each grid contains a single vertical line of gray pixels (color 5). This line appears to be static and acts as a separator.
    *   To the left of the gray line, the input grid contains patterns made of white pixels (color 0) on a magenta background (color 6).
    *   To the right of the gray line, the input grid consists entirely of magenta pixels (color 6).
    *   In the output grid, the gray line remains unchanged.
    *   The white pattern to the left of the gray line is shifted horizontally to the left. The amount of shift seems determined by the initial empty space (magenta columns) on the far left of the pattern area. The area vacated by the shift on the right (just before the gray line) is filled with magenta.
    *   To the right of the gray line in the output grid, some rows change from magenta (6) to red (2). This change seems conditional. Specifically, it occurs in rows where the pixel immediately to the *left* of the gray line in the *output* grid is white (0).

*   **Facts:**
    
```yaml
    task_type: grid_transformation
    grid_properties:
        - dimensions_preserved: True
        - static_elements:
            - object_type: line
            - color: gray (5)
            - orientation: vertical
            - function: separator
    objects:
        - object_type: pattern
          color: white (0)
          location: left_of_gray_line (input)
          background: magenta (6)
          action: horizontal_shift (left)
        - object_type: background_fill
          color: magenta (6)
          location: right_of_gray_line (input), fills empty space (output)
        - object_type: conditional_fill
          color: red (2)
          location: right_of_gray_line (output)
          condition: depends_on_adjacent_pixel_in_output
    relationships_and_actions:
        - action: identify_separator
          element: gray_vertical_line
        - action: partition_grid
          based_on: gray_line
          partitions: [left_area, gray_line, right_area]
        - action: determine_shift
          source_area: left_area (input)
          method: find first column index 'c' containing a white pixel
          result: shift_amount = c
        - action: apply_shift
          target_area: left_area (input)
          direction: left
          amount: shift_amount
          fill_vacated_space_with: magenta (6)
          result: left_area (output)
        - action: determine_conditional_color
          source_area: right_area (input/output)
          trigger_pixel_location: column immediately left of gray_line (output)
          trigger_pixel_color: white (0)
          affected_rows: rows where trigger_pixel is white
          affected_columns: columns in right_area
          result_color: red (2)
          default_color: magenta (6)
        - action: assemble_output
          components: [shifted_left_area, static_gray_line, conditional_right_area]

    ```


*   **Natural Language Program:**
    1.  Identify the column index (`gray_col_idx`) containing the vertical gray line (color 5).
    2.  Define the "left area" as all columns from 0 up to (but not including) `gray_col_idx`.
    3.  Define the "right area" as all columns starting from `gray_col_idx + 1` to the end of the grid.
    4.  Initialize the output grid as a copy of the input grid.
    5.  Examine the left area of the input grid. Find the smallest column index (`shift_amount`) within this area that contains at least one white pixel (color 0). If no white pixels exist in the left area, set `shift_amount` to 0.
    6.  If `shift_amount` is greater than 0:
        a.  For each row, shift the pixels from columns `shift_amount` to `gray_col_idx - 1` of the input grid to columns 0 to `gray_col_idx - 1 - shift_amount` in the output grid.
        b.  Fill the remaining columns in the left area of the output grid (from `gray_col_idx - shift_amount` to `gray_col_idx - 1`) with magenta (color 6).
    7.  Iterate through each row of the grid:
        a.  Check the color of the pixel in the output grid at the column index `gray_col_idx - 1` (immediately to the left of the gray line).
        b.  If this pixel is white (color 0), change all pixels in the current row within the right area (columns `gray_col_idx + 1` onwards) to red (color 2).
        c.  (Implicitly, if the pixel is not white, the pixels in the right area remain as they were copied initially, which should be magenta).
    8.  The final output grid is constructed.
