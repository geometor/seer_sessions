
## train_1

**input:**
```
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 8 8 8 1 1 1 1
1 8 4 8 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 8 1
1 1 1 1 8 8 4 1
1 1 1 1 1 1 8 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 8 1 8 1 1 1 1
1 8 4 8 1 1 1 1
1 8 1 8 1 1 1 1
1 8 8 8 1 1 1 1
1 1 1 1 1 4 1 1
```


**output:**
```
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1
1 1 1 1 8 4 8 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 8 1 1
1 1 1 8 8 4 1 1
1 1 1 1 1 8 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 8 1 8 1
1 1 1 1 8 4 8 1
1 1 1 1 8 1 8 1
1 1 1 1 8 8 8 1
1 1 1 1 1 4 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 3 1 3 8 8 8 8 8 8 8 8 8
1 8 4 8 3 3 3 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 4 8 3 8 3 8 8 8 8 8 8 8 8 8 8 3 8 8 8
8 8 6 8 3 8 3 8 8 8 8 8 8 8 3 1 3 3 8 8 8
8 8 8 8 3 1 3 8 8 8 8 8 8 8 8 8 8 3 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 3 3 3 8 8 8 8 8 8 3 8 8 8
1 8 4 8 3 1 3 8 3 1 3 8 8 8 3 1 3 3 8 8 8
8 8 4 8 8 8 8 8 3 3 3 8 8 8 8 8 8 3 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 8 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
3 3 3 3 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3 3
3 3 1 3 3 3 3 3 3 3 3
3 3 2 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 1 1 3 3 3
3 3 3 1 3 3 3 1 3 3 3
3 3 3 1 1 1 2 1 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3
3 3 3 1 1 2 1 1 3 3 3
3 3 3 3 3 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 1 1 1 1 1 3 3 3 3 3
3 1 3 3 3 1 3 3 3 3 3
3 1 1 1 2 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 1 1 2 1 1 3 3 3 3
3 3 3 3 1 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
```

Okay, let's analyze the task examples.

## Perception

1.  **Grid Structure:** The input and output are grids of colored pixels. The size varies between examples.
2.  **Background:** Each example has a dominant background color (Blue=1 in Ex1, Azure=8 in Ex2, Green=3 in Ex3) which remains unchanged in the output grid.
3.  **Objects:** There are distinct objects composed of connected pixels of non-background colors. These objects retain their shape and internal colors in the output.
4.  **Transformation:** The core transformation is a horizontal shift (translation) of these objects. The background pixels do not move.
5.  **Shift Amount (S):** The number of columns objects shift seems to depend on specific colors present *anywhere* in the input grid:
    *   If Green (3) is present, the shift amount S = 7. (Ex 2)
    *   Else if Yellow (4) is present, the shift amount S = 4. (Ex 1)
    *   Else if Red (2) is present, the shift amount S = 2. (Ex 3)
6.  **Shift Direction:** The direction (left or right) depends on the object's horizontal position relative to vertical divisions of the grid. The *number* of divisions (N) also seems linked to the color determining the shift amount:
    *   If Green (3) is present (N=3 divisions, S=7): Objects fully in the left third shift right (+S). Objects fully in the middle or right thirds shift left (-S).
    *   If Yellow (4) is present (N=2 divisions, S=4): Objects fully in the left half shift right (+S). Objects fully in the right half shift left (-S).
    *   If Red (2) is present (N=2 divisions, S=2): Objects fully in the left half shift right (+S). Objects fully in the right half shift left (-S).
7.  **Spanning Objects:** Objects whose horizontal extent (bounding box) crosses the boundary between these defined regions consistently shift left (-S) in all examples observed.
8.  **Boundaries:** Pixels shifted beyond the grid boundaries horizontally appear to be discarded (no wrapping).
9.  **Overlaps:** The examples don't clearly show how overlaps after shifting are handled, but since objects retain their internal structure, it seems pixels are just copied to their new locations, potentially overwriting existing pixels (or background).

## Facts


```yaml
# Overall Task Structure
task_type: grid_transformation
grid_properties:
  dimensionality: 2D
  cell_values: integers 0-9 (colors)
  size_range: 1x1 to 30x30

# Key Elements and Properties
background:
  definition: The most frequent pixel color in the input grid.
  behavior: Remains static in the output grid.
objects:
  definition: Contiguous block(s) of non-background pixels.
  properties:
    - color: The color(s) making up the object.
    - shape: The spatial arrangement of the object's pixels.
    - position: Location within the grid, often represented by a bounding box.
  behavior:
    - retain_shape: Yes
    - retain_color: Yes
    - movement: Horizontal translation only.

# Transformation Details
transformation_name: conditional_regional_horizontal_shift
parameters:
  shift_amount_S:
    determination: Based on the presence of specific colors (priority order) in the input grid.
    rules:
      - if Green(3) exists: S = 7
      - else if Yellow(4) exists: S = 4
      - else if Red(2) exists: S = 2
  number_of_regions_N:
    determination: Based on the color that determined S.
    rules:
      - if Green(3) determined S: N = 3
      - else if Yellow(4) determined S: N = 2
      - else if Red(2) determined S: N = 2
  grid_width_W: The number of columns in the input grid.
  regions:
    definition: Vertical sections of the grid based on N and W. Columns are 0-indexed.
    calculation:
      - if N=2: Left=[0, floor(W/2)-1], Right=[floor(W/2), W-1]
      - if N=3: Left=[0, floor(W/3)-1], Middle=[floor(W/3), floor(2W/3)-1], Right=[floor(2W/3), W-1]
  shift_direction:
    determination: Based on object's bounding box horizontal position relative to regions.
    rules:
      - if object bounding_box_cols fully within Left region: shift Right (+S)
      - if N=2 and object bounding_box_cols fully within Right region: shift Left (-S)
      - if N=3 and object bounding_box_cols fully within Middle region: shift Left (-S)
      - if N=3 and object bounding_box_cols fully within Right region: shift Left (-S)
      - if object bounding_box_cols spans across region boundaries: shift Left (-S)

# Boundary and Overlap Handling
boundary_handling: Pixels shifted outside the grid width are discarded.
overlap_handling: Assumed that shifted pixels overwrite the destination cells.

```


## Natural Language Program

1.  **Identify Background:** Determine the background color by finding the most frequent pixel value in the input grid.
2.  **Determine Shift Parameters (N, S):**
    a. Check if the color Green (3) exists anywhere in the input grid. If yes, set the number of regions N = 3 and the shift amount S = 7.
    b. If Green (3) is not present, check if Yellow (4) exists anywhere. If yes, set N = 2 and S = 4.
    c. If neither Green (3) nor Yellow (4) is present, check if Red (2) exists anywhere. If yes, set N = 2 and S = 2.
    d. (Assumption: At least one of Green, Yellow, or Red will be present to define the shift).
3.  **Define Regions:** Calculate the column ranges for the Left, Middle (if N=3), and Right regions based on the grid width (W) and the value of N (using integer division for boundaries).
4.  **Identify Objects:** Find all connected components (objects) consisting of non-background pixels in the input grid. For each object, determine its horizontal bounding box (minimum and maximum column index).
5.  **Calculate Shifts for Each Object:**
    a. For each object:
        i.  Determine which region(s) its bounding box occupies or spans.
        ii. If the bounding box is entirely within the Left region, the horizontal shift is `+S` (Right).
        iii. If N=2 and the bounding box is entirely within the Right region, the shift is `-S` (Left).
        iv. If N=3 and the bounding box is entirely within the Middle region, the shift is `-S` (Left).
        v.  If N=3 and the bounding box is entirely within the Right region, the shift is `-S` (Left).
        vi. If the bounding box spans across any region boundary, the shift is `-S` (Left).
6.  **Construct Output Grid:**
    a. Create a new grid of the same dimensions as the input, filled with the background color.
    b. For each object identified in step 4:
        i.  Calculate its target position by applying its determined horizontal shift (from step 5) to the coordinates of each of its pixels.
        ii. For each pixel of the object, if its new column coordinate is within the grid boundaries (0 to W-1), copy the pixel's original color to the corresponding row and new column in the output grid. Overwrite any existing pixel (background or from a previously processed object) at that location.
7.  **Return Output Grid:** The final constructed grid is the result.
