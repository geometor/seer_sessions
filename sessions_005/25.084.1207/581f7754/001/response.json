{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Identify Background:** Determine the background color (most frequent pixel value).\n2.  **Determine Shift Parameters (N, S):**\n    - Check for Green (3): If present, N = 3 regions, S = 7 shift amount.\n    - Else check for Yellow (4): If present, N = 2 regions, S = 4 shift amount.\n    - Else check for Red (2): If present, N = 2 regions, S = 2 shift amount.\n    - (Assumes at least one of 3, 4, or 2 is present).\n3.  **Define Regions:** Divide the grid width (W) into N vertical regions.\n    - N=2: Left=[0, floor(W/2)-1], Right=[floor(W/2), W-1]\n    - N=3: Left=[0, floor(W/3)-1], Middle=[floor(W/3), floor(2W/3)-1], Right=[floor(2W/3), W-1]\n4.  **Identify Objects:** Find connected components of non-background pixels.\n5.  **Calculate Shifts:** For each object, determine its horizontal bounding box (min/max columns).\n    - If bbox is fully within the Left region: shift right by S (+S).\n    - If N=2 and bbox is fully within the Right region: shift left by S (-S).\n    - If N=3 and bbox is fully within the Middle region: shift left by S (-S).\n    - If N=3 and bbox is fully within the Right region: shift left by S (-S).\n    - If bbox spans across any region boundary: shift left by S (-S).\n6.  **Construct Output:** Create a new grid filled with the background color. Shift the pixels of each object according to its calculated shift. Discard pixels shifted outside the grid boundaries. Overwrite existing pixels at the destination.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent pixel value in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Common case: If 0 (white) is most frequent, assume it's padding/irrelevant,\n    # and pick the next most frequent. If not, pick the absolute most frequent.\n    # However, in these examples, the background is the actual most frequent.\n    # Let's stick to the absolute most frequent.\n    if not counts:\n        return 0 # Default if grid is empty\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds connected objects (8-way connectivity) of non-background pixels.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] != background_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                bounding_box = (min_r, min_c, max_r, max_c)\n                objects.append({'pixels': obj_pixels, 'bbox': bounding_box})\n                \n    return objects\n\ndef determine_shift_parameters(grid):\n    \"\"\"Determines the number of regions (N) and shift amount (S).\"\"\"\n    unique_colors = np.unique(grid)\n    if 3 in unique_colors: # Green\n        return 3, 7\n    elif 4 in unique_colors: # Yellow\n        return 2, 4\n    elif 2 in unique_colors: # Red\n        return 2, 2\n    else:\n        # Default or error case if none of the trigger colors are found\n        # Based on the problem description, one should be present.\n        # If not, perhaps no shift occurs. Let's return N=0, S=0 for no shift.\n        return 0, 0 \n\ndef calculate_region_boundaries(width, N):\n    \"\"\"Calculates the column boundaries for N regions.\"\"\"\n    if N == 2:\n        mid = width // 2\n        # Left: [0, mid-1], Right: [mid, width-1]\n        return [(0, mid - 1), (mid, width - 1)]\n    elif N == 3:\n        third1 = width // 3\n        third2 = (2 * width) // 3\n        # Left: [0, third1-1], Middle: [third1, third2-1], Right: [third2, width-1]\n        return [(0, third1 - 1), (third1, third2 - 1), (third2, width - 1)]\n    else: # N=0 or other invalid N\n        # No regions defined, return empty or a single region covering all\n         return [(0, width - 1)] # Treat as one region for no shift case\n\n\ndef determine_object_shift(bbox, regions, N, S):\n    \"\"\"Determines the shift direction and amount for an object.\"\"\"\n    if S == 0: # No shift determined\n        return 0\n        \n    min_c, max_c = bbox[1], bbox[3]\n    \n    # Check if object spans boundaries\n    spans = False\n    if N == 2:\n        boundary = regions[1][0] # Start of Right region\n        if min_c < boundary and max_c >= boundary:\n            spans = True\n    elif N == 3:\n        boundary1 = regions[1][0] # Start of Middle region\n        boundary2 = regions[2][0] # Start of Right region\n        if (min_c < boundary1 and max_c >= boundary1) or \\\n           (min_c < boundary2 and max_c >= boundary2):\n            spans = True\n\n    if spans:\n        return -S # Shift Left\n\n    # Check which region the object is fully within\n    for i, (start_c, end_c) in enumerate(regions):\n        if min_c >= start_c and max_c <= end_c:\n            if i == 0: # Fully in Left region\n                return S # Shift Right\n            else: # Fully in Middle (N=3) or Right (N=2 or N=3)\n                return -S # Shift Left\n                \n    # Should not happen if logic is correct and object is within grid bounds\n    # But as a fallback, maybe shift left? Or 0? Let's default to left shift.\n    print(f\"Warning: Object bbox {bbox} did not fit cleanly into regions {regions}. Defaulting shift left.\")\n    return -S\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional regional horizontal shift transformation.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Identify Background color\n    background_color = find_background_color(input_np)\n\n    # 2. Determine Shift Parameters (N, S)\n    N, S = determine_shift_parameters(input_np)\n\n    # 3. Define Regions\n    regions = calculate_region_boundaries(width, N)\n\n    # 4. Identify Objects\n    objects = find_objects(input_np, background_color)\n\n    # 6. Construct Output Grid - Initialize with background\n    output_grid = np.full_like(input_np, background_color)\n\n    # 5. & 6. Calculate Shifts and Apply to Objects\n    for obj in objects:\n        bbox = obj['bbox']\n        pixels = obj['pixels']\n        \n        # 5. Calculate shift for this object\n        shift = determine_object_shift(bbox, regions, N, S)\n\n        # 6. Apply shift to object pixels\n        for r, c in pixels:\n            new_c = c + shift\n            # Check if the new column is within grid bounds\n            if 0 <= new_c < width:\n                # Copy the original pixel color to the new location\n                output_grid[r, new_c] = input_np[r, c]\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5306,
    "candidates_token_count": 2179,
    "total_token_count": 7485,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.494284
}