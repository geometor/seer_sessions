{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1.  Initialization: Create the output grid as a copy of the input grid.\n2.  Identify Background: Determine the background color (assumed Azure, 8) as the most frequent color in the input grid.\n3.  Find Marker Object:\n    *   Find all distinct, contiguous objects composed of blue (1) pixels using cardinal neighbors.\n    *   Identify the 'marker' object as the blue object that extends furthest down (i.e., has the pixel(s) with the maximum row index). If no blue objects exist, return the input grid.\n    *   Determine the top-most row index (`marker_top_row`) occupied by the marker object.\n4.  Find Single-Pixel Objects: Find all objects in the grid consisting of exactly one pixel, whose color is not the background color.\n5.  Identify Active Pixels: Filter the single-pixel objects found in step 4, keeping only those whose color is *not* blue (1). These are the 'active pixels'. Store their location (r, c) and color.\n6.  Handle No Active Pixels: If there are no active pixels, return the input grid.\n7.  Identify Adjacent Active Pixels: Check each active pixel for adjacency (including diagonals) to *any* pixel belonging to the marker object. Collect the active pixels that are adjacent.\n8.  Determine Pattern Columns: Create a sorted list of the unique column indices from the adjacent active pixels found in step 7.\n9.  Determine Pattern Color Sequence:\n    *   Filter the active pixels (from step 5) to keep only those whose row index is *greater than* `marker_top_row`.\n    *   Sort these filtered active pixels first by row index in descending order (bottom-to-top), and then by column index in ascending order (left-to-right).\n    *   Create the color sequence by taking the colors of these sorted pixels in order. Keep only the *first* occurrence of each unique color encountered.\n10. Determine Pattern Bottom Row: Find the minimum row index among the adjacent active pixels found in step 7.\n11. Draw Pattern (if applicable):\n    *   If there are adjacent active pixels (step 7) AND the pattern color sequence (step 9) is not empty:\n        *   Iterate through each column index in the `Pattern Columns` (step 8).\n        *   For each column, iterate through rows from 0 down to the `Pattern Bottom Row` (step 10), inclusive.\n        *   Set the pixel color in the `output_grid` at `(row, column)` using the `Pattern Color Sequence`, cycling through the sequence based on the `row` index (`color = sequence[row % len(sequence)]`).\n12. Cleanup Active Pixels: Iterate through all active pixels identified in step 5. For each active pixel at `(r, c)`:\n    *   Check if the location `(r, c)` falls within the area where the pattern was drawn (i.e., if step 11 was executed, `c` is in `Pattern Columns` and `r` is less than or equal to `Pattern Bottom Row`).\n    *   If the location is *not* within the pattern area, set `output_grid[r, c]` to the background color. (If it *is* within the pattern area, it has already been overwritten by the pattern drawing step).\n13. Return: Return the modified output grid.\n\"\"\"\n\ndef _get_neighbors(r, c, height, width, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given cell.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects(grid, color_to_find=None, ignore_color=None, min_size=None, max_size=None):\n    \"\"\"\n    Finds all contiguous objects based on cardinal adjacency.\n    Returns a list of dictionaries, each containing 'color', 'pixels' (set of (r,c)), 'size', 'locations' (list of {'r':r, 'c':c}), 'min_r', 'max_r'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Skip if already visited or if it's the ignore_color\n            if visited[r, c] or (ignore_color is not None and color == ignore_color):\n                continue\n            # Skip if looking for a specific color and this isn't it\n            if color_to_find is not None and color != color_to_find:\n                continue\n\n            # Start Flood Fill (BFS) for a new object\n            obj_pixels = set()\n            q = [(r, c)]\n            visited[r, c] = True\n            current_color = grid[r, c] # Color of the object being traced\n            pixel_locations_list = []\n            min_r_obj, max_r_obj = r, r\n\n            while q:\n                curr_r, curr_c = q.pop(0)\n                obj_pixels.add((curr_r, curr_c))\n                pixel_locations_list.append({'r': curr_r, 'c': curr_c})\n                min_r_obj = min(min_r_obj, curr_r)\n                max_r_obj = max(max_r_obj, curr_r)\n\n                # Explore cardinal neighbors\n                for nr, nc in _get_neighbors(curr_r, curr_c, height, width, include_diagonal=False):\n                    # Check if neighbor has the same color and hasn't been visited\n                    if grid[nr, nc] == current_color and not visited[nr, nc]:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            # Check size constraints after finding the whole object\n            obj_size = len(obj_pixels)\n            valid_size = True\n            if min_size is not None and obj_size < min_size:\n                valid_size = False\n            if max_size is not None and obj_size > max_size:\n                valid_size = False\n\n            if valid_size:\n                objects.append({\n                    'color': current_color,\n                    'pixels': obj_pixels,\n                    'size': obj_size,\n                    'locations': sorted(pixel_locations_list, key=lambda p: (p['r'], p['c'])), # Sorted list of dicts\n                    'min_r': min_r_obj,\n                    'max_r': max_r_obj,\n                })\n    return objects\n\n\ndef _is_adjacent(pixel_coord, object_pixel_set):\n    \"\"\"Checks if a pixel coordinate is adjacent (including diagonals) to any pixel in a given set.\"\"\"\n    pr, pc = pixel_coord\n    # Check all 8 neighbors of the pixel_coord\n    height, width = 30, 30 # Assume max possible grid size for neighbor generation bound checking - safe but potentially inefficient. It's better if grid dimensions are known/passed.\n                            # However, we only need to check if a neighbour *exists in the set*, so grid dimensions aren't strictly necessary here.\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            neighbor_coord = (pr + dr, pc + dc)\n            if neighbor_coord in object_pixel_set:\n                return True\n    return False\n\n\ndef transform(input_grid):\n    # 1. Initialization\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify Background Color (most frequent)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 3. Find Marker Object (lowest blue object)\n    marker_color = 1 # Blue\n    blue_objects = _find_objects(input_grid, color_to_find=marker_color)\n\n    if not blue_objects:\n        return output_grid # No blue objects found\n\n    marker_object = None\n    max_marker_row = -1\n    for obj in blue_objects:\n        current_max_row = obj['max_r']\n        if current_max_row > max_marker_row:\n            max_marker_row = current_max_row\n            marker_object = obj\n        # Tie-breaking: if rows are equal, does it matter? NL program doesn't specify. Assume first found is fine.\n\n    if marker_object is None: # Should not happen if blue_objects wasn't empty\n         return output_grid\n\n    marker_top_row = marker_object['min_r']\n    marker_pixels = marker_object['pixels']\n\n    # 4. Find Single-Pixel Objects (non-background)\n    single_pixel_objects = _find_objects(input_grid, ignore_color=background_color, max_size=1)\n\n    # 5. Identify Active Pixels (single-pixel, non-blue)\n    active_pixels = []\n    for obj in single_pixel_objects:\n        if obj['color'] != marker_color:\n            # Store only essential info: location and color\n            loc = obj['locations'][0] # It's a single pixel object\n            active_pixels.append({'r': loc['r'], 'c': loc['c'], 'color': obj['color']})\n\n    # 6. Handle No Active Pixels\n    if not active_pixels:\n        return output_grid # Nothing to do, return original grid\n\n    # 7. Identify Adjacent Active Pixels (adjacent to marker)\n    adjacent_active_pixels = []\n    for p_info in active_pixels:\n        if _is_adjacent((p_info['r'], p_info['c']), marker_pixels):\n            adjacent_active_pixels.append(p_info)\n\n    # Initialize pattern variables\n    pattern_columns = []\n    pattern_colors = []\n    pattern_bottom_row = -1\n    pattern_drawn = False\n\n    # Determine pattern parameters only if there are adjacent active pixels\n    if adjacent_active_pixels:\n        # 8. Determine Pattern Columns\n        pattern_columns = sorted(list(set(p['c'] for p in adjacent_active_pixels)))\n\n        # 9. Determine Pattern Color Sequence\n        # Filter active pixels below marker's top row\n        relevant_for_color = [p for p in active_pixels if p['r'] > marker_top_row]\n        # Sort: bottom-up, then left-right\n        relevant_for_color.sort(key=lambda p: (-p['r'], p['c']))\n        # Get unique colors in order\n        seen_colors = set()\n        for p in relevant_for_color:\n            if p['color'] not in seen_colors:\n                pattern_colors.append(p['color'])\n                seen_colors.add(p['color'])\n\n        # 10. Determine Pattern Bottom Row\n        pattern_bottom_row = min(p['r'] for p in adjacent_active_pixels)\n\n        # 11. Draw Pattern (if colors and columns exist)\n        if pattern_columns and pattern_colors:\n            num_pattern_colors = len(pattern_colors)\n            for c in pattern_columns:\n                for r in range(pattern_bottom_row + 1): # From row 0 down to bottom row inclusive\n                    color_index = r % num_pattern_colors\n                    output_grid[r, c] = pattern_colors[color_index]\n            pattern_drawn = True # Mark that the pattern was drawn for cleanup logic\n\n    # 12. Cleanup Active Pixels\n    for p in active_pixels:\n        r, c = p['r'], p['c']\n        # Check if this pixel location falls within the drawn pattern area\n        is_in_pattern_area = pattern_drawn and (c in pattern_columns) and (r <= pattern_bottom_row)\n\n        # If the pixel wasn't overwritten by the pattern, set it to background\n        if not is_in_pattern_area:\n            output_grid[r, c] = background_color\n\n    # 13. Return\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14795,
    "candidates_token_count": 2955,
    "total_token_count": 17750,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.015655
}