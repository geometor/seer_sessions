{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (azure, 8).\n2. Find all blue (1) objects and identify the 'marker' object as the one positioned lowest in the grid.\n3. Find all 'isolated' single pixels (non-background pixels surrounded by background).\n4. Identify 'active' isolated pixels (those whose color is not blue).\n5. If no active pixels exist, return the input grid.\n6. Identify 'adjacent active' pixels (active pixels adjacent, including diagonals, to the marker object).\n7. Determine the columns for the new pattern based on the columns of the adjacent active pixels.\n8. Determine the color sequence for the pattern by collecting the unique colors of *all* active pixels, ordered by their first appearance scanning bottom-to-top, then left-to-right.\n9. Determine the bottom row for the pattern as the minimum row index (highest position on grid) among adjacent active pixels.\n10. Create the output grid by copying the input.\n11. Draw a vertical repeating pattern in the determined columns from row 0 down to the determined bottom row, using the determined color sequence.\n12. Set the original locations of all active isolated pixels to the background color in the output grid.\n13. Return the modified grid.\n\"\"\"\n\ndef _find_background_color(grid):\n    \"\"\"Finds the most frequent color, assumed to be the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef _get_neighbors(r, c, height, width, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given cell.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a given color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    obj_pixels.add((curr_r, curr_c))\n                    # Use cardinal neighbors for object definition\n                    for nr, nc in _get_neighbors(curr_r, curr_c, height, width, include_diagonal=False):\n                        if grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef _find_isolated_pixels(grid, background_color):\n    \"\"\"Finds all pixels surrounded entirely by the background color.\"\"\"\n    height, width = grid.shape\n    isolated = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color:\n                is_isolated = True\n                for nr, nc in _get_neighbors(r, c, height, width, include_diagonal=True):\n                    if grid[nr, nc] != background_color:\n                        is_isolated = False\n                        break\n                if is_isolated:\n                    isolated.append({'r': r, 'c': c, 'color': grid[r, c]})\n    return isolated\n\ndef _is_adjacent(pixel_coord, object_coords):\n    \"\"\"Checks if a pixel is adjacent (including diagonals) to any pixel in an object.\"\"\"\n    pr, pc = pixel_coord\n    height, width = 30, 30 # Use max possible size for bounds check, actual grid size better\n    # Ideally, pass grid dimensions or calculate from object_coords max/min\n    for r_obj, c_obj in object_coords:\n         # Check if pr, pc is one of the 8 neighbours of r_obj, c_obj\n         if max(abs(pr - r_obj), abs(pc - c_obj)) == 1:\n              return True\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify background color\n    background_color = _find_background_color(input_grid)\n\n    # 2. Find marker object (lowest blue object)\n    marker_color = 1 # Blue\n    blue_objects = _find_objects(input_grid, marker_color)\n    if not blue_objects:\n        return output_grid # No blue objects, maybe return input? Task implies marker exists.\n\n    marker_object = None\n    max_row = -1\n    for obj in blue_objects:\n        current_max_row = max(r for r, c in obj)\n        if current_max_row > max_row:\n            max_row = current_max_row\n            marker_object = obj\n\n    if marker_object is None:\n         # Should not happen based on examples, but handle defensively\n         return output_grid\n\n    # 3. Find isolated pixels\n    isolated_pixels = _find_isolated_pixels(input_grid, background_color)\n\n    # 4. Identify 'active' isolated pixels (non-blue)\n    active_pixels = [p for p in isolated_pixels if p['color'] != marker_color]\n\n    # 5. If no active pixels, return input\n    if not active_pixels:\n        return output_grid\n\n    # 6. Identify 'adjacent active' pixels\n    adjacent_active_pixels = []\n    for pixel_info in active_pixels:\n        if _is_adjacent((pixel_info['r'], pixel_info['c']), marker_object):\n            adjacent_active_pixels.append(pixel_info)\n\n    # If no active pixels are adjacent to the marker, no pattern is generated\n    # but the active pixels are still removed later.\n    if not adjacent_active_pixels:\n        # 12. Clean up active pixels even if no pattern is drawn\n        for p in active_pixels:\n            output_grid[p['r'], p['c']] = background_color\n        return output_grid\n\n    # 7. Determine pattern columns\n    pattern_columns = sorted(list(set(p['c'] for p in adjacent_active_pixels)))\n\n    # 8. Determine pattern colors (order based on *all* active pixels)\n    # Sort active pixels: bottom-to-top (descending row), then left-to-right (ascending col)\n    sorted_active_pixels = sorted(active_pixels, key=lambda p: (-p['r'], p['c']))\n    pattern_colors = []\n    seen_colors = set()\n    for p in sorted_active_pixels:\n        if p['color'] not in seen_colors:\n            pattern_colors.append(p['color'])\n            seen_colors.add(p['color'])\n\n    if not pattern_colors: # Should not happen if active_pixels is not empty\n        return output_grid # Or handle error\n\n    # 9. Determine pattern bottom row (min row index of adjacent active pixels)\n    pattern_bottom_row = min(p['r'] for p in adjacent_active_pixels)\n\n    # 11. Draw the pattern\n    num_pattern_colors = len(pattern_colors)\n    for c in pattern_columns:\n        for r in range(pattern_bottom_row + 1): # Iterate from row 0 down to pattern_bottom_row inclusive\n            color_index = r % num_pattern_colors\n            output_grid[r, c] = pattern_colors[color_index]\n\n    # 12. Clean up: Set original active pixel locations to background\n    for p in active_pixels:\n        # Make sure not to erase parts of the newly drawn pattern if an active pixel was there\n        # Check if the pixel location is part of the pattern area\n        is_in_pattern_area = (p['c'] in pattern_columns and p['r'] <= pattern_bottom_row)\n        if not is_in_pattern_area:\n             output_grid[p['r'], p['c']] = background_color\n        # If it IS in the pattern area, it was already overwritten by step 11.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5011,
    "candidates_token_count": 2066,
    "total_token_count": 7077,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.894447
}