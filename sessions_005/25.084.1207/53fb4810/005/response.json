{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1.  Initialization: Create the output grid as a copy of the input grid.\n2.  Identify Background: Determine the background color as the most frequent color in the input grid.\n3.  Find Marker Object:\n    *   Find all distinct, contiguous objects composed of blue (1) pixels using cardinal neighbors.\n    *   If no blue objects exist, return the input grid.\n    *   Identify the 'marker' object(s) as the blue object(s) that extend furthest down (maximum row index).\n    *   Determine the maximum row index (`marker_max_row`) among all marker objects.\n    *   Collect all pixel coordinates `(r, c)` from all marker objects where `r == marker_max_row`. Call this set `marker_bottom_pixels`.\n4.  Find Potential Trigger Pixels: Find all objects consisting of exactly one pixel, whose color is neither the background color nor blue (1). Store their location `(r, c)` and color.\n5.  Identify Trigger Pixels: Filter the potential trigger pixels found in step 4. Keep only those `(r, c)` where `r < marker_max_row` and there exists some `(br, bc)` in `marker_bottom_pixels` such that `c == bc`.\n6.  Handle No Trigger Pixels: If no trigger pixels are found, return the input grid.\n7.  Determine Pattern Columns: Create a sorted list of the unique column indices `c` from the identified trigger pixels.\n8.  Determine Pattern Top Row: Find the maximum row index `r` among the identified trigger pixels. This is the row index down to which the pattern will be drawn.\n9.  Determine Pattern Color Sequence:\n    *   Sort the trigger pixels found in step 5, first by row index in descending order (bottom-to-top), and then by column index in ascending order (left-to-right).\n    *   Create the color sequence by taking the colors of these sorted pixels in order. Keep only the *first* occurrence of each unique color encountered.\n10. Draw Pattern:\n    *   If the pattern color sequence is empty, skip drawing.\n    *   Iterate through each column index `c` in the `Pattern Columns`.\n    *   Iterate through rows `r` from 0 to the `Pattern Top Row`, inclusive.\n    *   Set the pixel color in the `output_grid` at `(r, c)` using the `Pattern Color Sequence`, cycling through the sequence based on the `row` index (`color = sequence[r % len(sequence)]`).\n11. Cleanup Single Pixels: Iterate through all potential trigger pixels identified in step 4. For each pixel at `(r, c)`:\n    *   Check if the location `(r, c)` falls within the area where the pattern was drawn (i.e., if drawing occurred, `c` is in `Pattern Columns` and `r` is less than or equal to `Pattern Top Row`).\n    *   If the location is *not* within the pattern area, set `output_grid[r, c]` to the background color.\n12. Return: Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef _get_neighbors(r, c, height, width, include_diagonal=False):\n    \"\"\"Gets valid neighbor coordinates for a given cell.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects(grid, color_to_find=None, ignore_color=None, min_size=None, max_size=None):\n    \"\"\"\n    Finds all contiguous objects based on cardinal adjacency.\n    Returns a list of dictionaries, each containing 'color', 'pixels' (set of (r,c)), 'size', 'locations' (list of {'r':r, 'c':c}), 'min_r', 'max_r', 'min_c', 'max_c'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Skip if already visited or if it's the ignore_color\n            if visited[r, c] or (ignore_color is not None and color == ignore_color):\n                continue\n            # Skip if looking for a specific color and this isn't it\n            if color_to_find is not None and color != color_to_find:\n                continue\n\n            # Start Flood Fill (BFS) for a new object\n            obj_pixels = set()\n            q = [(r, c)]\n            visited[r, c] = True\n            current_color = grid[r, c] # Color of the object being traced\n            pixel_locations_list = []\n            min_r_obj, max_r_obj = r, r\n            min_c_obj, max_c_obj = c, c\n\n\n            while q:\n                curr_r, curr_c = q.pop(0)\n                obj_pixels.add((curr_r, curr_c))\n                pixel_locations_list.append({'r': curr_r, 'c': curr_c})\n                min_r_obj = min(min_r_obj, curr_r)\n                max_r_obj = max(max_r_obj, curr_r)\n                min_c_obj = min(min_c_obj, curr_c)\n                max_c_obj = max(max_c_obj, curr_c)\n\n                # Explore cardinal neighbors\n                for nr, nc in _get_neighbors(curr_r, curr_c, height, width, include_diagonal=False):\n                    # Check if neighbor has the same color and hasn't been visited\n                    if grid[nr, nc] == current_color and not visited[nr, nc]:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            # Check size constraints after finding the whole object\n            obj_size = len(obj_pixels)\n            valid_size = True\n            if min_size is not None and obj_size < min_size:\n                valid_size = False\n            if max_size is not None and obj_size > max_size:\n                valid_size = False\n\n            if valid_size:\n                objects.append({\n                    'color': current_color,\n                    'pixels': obj_pixels,\n                    'size': obj_size,\n                    'locations': sorted(pixel_locations_list, key=lambda p: (p['r'], p['c'])), # Sorted list of dicts\n                    'min_r': min_r_obj,\n                    'max_r': max_r_obj,\n                    'min_c': min_c_obj,\n                    'max_c': max_c_obj\n                })\n    return objects\n\n\ndef transform(input_grid):\n    # 1. Initialization\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify Background Color (most frequent)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    if colors.size > 0:\n        background_color = colors[np.argmax(counts)]\n    else: # Handle empty grid case\n        background_color = 0 # Default to black/white? Task spec says 0 is white.\n\n    # 3. Find Marker Object(s) and Bottom Pixels\n    marker_color = 1 # Blue\n    blue_objects = _find_objects(input_grid, color_to_find=marker_color)\n\n    if not blue_objects:\n        return output_grid # No blue objects found\n\n    marker_max_row = -1\n    for obj in blue_objects:\n        marker_max_row = max(marker_max_row, obj['max_r'])\n\n    marker_bottom_pixels = set()\n    marker_bottom_cols = set() # Keep track of columns containing bottom pixels\n    for obj in blue_objects:\n        if obj['max_r'] == marker_max_row:\n            for r_coord, c_coord in obj['pixels']:\n                if r_coord == marker_max_row:\n                    marker_bottom_pixels.add((r_coord, c_coord))\n                    marker_bottom_cols.add(c_coord)\n\n    # 4. Find Potential Trigger Pixels (single, non-bg, non-blue)\n    potential_trigger_pixels_info = []\n    single_pixel_objects = _find_objects(input_grid, ignore_color=background_color, max_size=1)\n    for obj in single_pixel_objects:\n        if obj['color'] != marker_color:\n            loc = obj['locations'][0] # It's a single pixel object\n            potential_trigger_pixels_info.append({'r': loc['r'], 'c': loc['c'], 'color': obj['color']})\n\n    # 5. Identify Trigger Pixels\n    trigger_pixels = []\n    for p_info in potential_trigger_pixels_info:\n        r, c = p_info['r'], p_info['c']\n        # Check if pixel is above the marker's bottom row and shares a column with a marker bottom pixel\n        if r < marker_max_row and c in marker_bottom_cols:\n            trigger_pixels.append(p_info)\n\n    # 6. Handle No Trigger Pixels\n    if not trigger_pixels:\n        # If no triggers, clean up ALL potential triggers identified in step 4\n        for p in potential_trigger_pixels_info:\n           output_grid[p['r'], p['c']] = background_color\n        return output_grid\n\n    # 7. Determine Pattern Columns\n    pattern_columns = sorted(list(set(p['c'] for p in trigger_pixels)))\n\n    # 8. Determine Pattern Top Row (inclusive boundary for drawing)\n    pattern_top_row = -1\n    if trigger_pixels:\n        pattern_top_row = max(p['r'] for p in trigger_pixels)\n\n    # 9. Determine Pattern Color Sequence\n    # Sort triggers: bottom-up (desc row), then left-right (asc col)\n    trigger_pixels.sort(key=lambda p: (-p['r'], p['c']))\n    pattern_colors = []\n    seen_colors = set()\n    for p in trigger_pixels:\n        if p['color'] not in seen_colors:\n            pattern_colors.append(p['color'])\n            seen_colors.add(p['color'])\n\n    # 10. Draw Pattern\n    pattern_drawn = False\n    if pattern_columns and pattern_colors and pattern_top_row >= 0:\n        num_pattern_colors = len(pattern_colors)\n        for c in pattern_columns:\n            for r in range(pattern_top_row + 1): # From row 0 down to pattern_top_row inclusive\n                color_index = r % num_pattern_colors\n                output_grid[r, c] = pattern_colors[color_index]\n        pattern_drawn = True # Mark that the pattern was drawn for cleanup logic\n\n    # 11. Cleanup Single Pixels (potential triggers)\n    for p in potential_trigger_pixels_info:\n        r, c = p['r'], p['c']\n        # Check if this pixel location falls within the drawn pattern area\n        is_in_pattern_area = pattern_drawn and (c in pattern_columns) and (r <= pattern_top_row)\n\n        # If the pixel wasn't overwritten by the pattern, set it to background\n        if not is_in_pattern_area:\n            output_grid[r, c] = background_color\n\n    # 12. Return\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8222,
    "candidates_token_count": 2825,
    "total_token_count": 11047,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.165627
}