{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies a background color (most frequent) and a fill color (least frequent non-background color).\nPerforms a flood fill starting from the background pixels adjacent to the grid border,\nreplacing the background color with the fill color. The fill stops at non-background pixels.\nConnectivity is 4-directional (up, down, left, right).\n\"\"\"\n\ndef find_most_frequent_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    # Flatten the grid and count color occurrences\n    counts = Counter(grid.flatten())\n    # If the grid is empty or has no colors, return a default (e.g., 0 or handle error)\n    if not counts:\n        return 0 # Default to white/0 if grid is empty\n    # Return the color with the highest frequency\n    most_common = counts.most_common(1)\n    return most_common[0][0]\n\ndef find_fill_color(grid, background_color):\n    \"\"\"\n    Finds the color to use for filling.\n    It's assumed to be the non-background color with the fewest occurrences.\n    If there's a tie for the minimum count, the color with the smallest numerical value is chosen.\n    \"\"\"\n    counts = Counter()\n    # Iterate through the grid to count non-background colors\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            # Only count colors that are not the background\n            if color != background_color:\n                counts[color] += 1\n\n    # If there are no non-background colors, return the background color itself\n    if not counts:\n        return background_color\n\n    # Find the minimum count among non-background colors\n    min_count = float('inf')\n    for count in counts.values():\n        if count < min_count:\n            min_count = count\n\n    # Collect all colors that have this minimum count\n    min_colors = []\n    for color, count in counts.items():\n        if count == min_count:\n            min_colors.append(color)\n\n    # Apply tie-breaking rule: return the smallest color value among those with the minimum count\n    if min_colors:\n        return min(min_colors)\n    else:\n        # This case should not be reached if counts is not empty\n        return background_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by flood-filling the outer background region.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input state for checks\n    output_grid = input_grid_np.copy()\n    height, width = input_grid_np.shape\n\n    # If grid is empty, return it as is\n    if height == 0 or width == 0:\n        return output_grid.tolist()\n\n    # 1. Identify the background color (most frequent)\n    background_color = find_most_frequent_color(input_grid_np)\n\n    # 2. Identify the fill color (least frequent non-background color)\n    fill_color = find_fill_color(input_grid_np, background_color)\n\n    # If the identified fill color is the same as the background,\n    # it implies either only one color exists or something unexpected.\n    # In this scenario, no transformation should occur.\n    if fill_color == background_color:\n        return output_grid.tolist()\n\n    # 3. Perform flood fill starting from background pixels connected to the border\n    visited = set()  # Keep track of visited cells to avoid cycles and redundant work\n    queue = deque()  # Queue for BFS\n\n    # Initialize the queue with all background-colored pixels located on the grid's border\n    for r in range(height):\n        for c in range(width):\n            # Check if the pixel is on the border\n            is_border = (r == 0 or r == height - 1 or c == 0 or c == width - 1)\n            # Check if it's the background color\n            if is_border and input_grid_np[r, c] == background_color:\n                # If not already visited, add to queue and visited set\n                if (r, c) not in visited:\n                    visited.add((r, c))\n                    queue.append((r, c))\n\n    # Perform Breadth-First Search (BFS) based flood fill\n    while queue:\n        r, c = queue.popleft()\n\n        # Change the color of the current background pixel to the fill color in the output grid\n        output_grid[r, c] = fill_color\n\n        # Explore 4-directional neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within the grid boundaries\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is a background pixel and has not been visited yet\n                if input_grid_np[nr, nc] == background_color and (nr, nc) not in visited:\n                    # Mark as visited and add to the queue for processing\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4851,
    "candidates_token_count": 1331,
    "total_token_count": 6182,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.809788
}