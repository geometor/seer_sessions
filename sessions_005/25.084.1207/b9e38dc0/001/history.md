
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's analyze the provided examples for this task.

**Perception**

1.  **Grid Structure:** All examples involve transforming a 2D grid of colored pixels. The input and output grids have the same dimensions in each example.
2.  **Background Color:** Each input grid has a predominant background color (blue in ex1, white in ex2, orange in ex3). This background color appears to be the most frequent color in the input.
3.  **Boundary/Structure Colors:** There are other colors present that often form lines, shapes, or scattered points (green/gray in ex1, gray in ex2, maroon/magenta/azure in ex3). These colors seem to remain unchanged in the output grid.
4.  **Seed Color:** In each input grid, there is exactly one pixel of a specific color that is neither the background nor part of the main structures (maroon in ex1, yellow in ex2, green in ex3). This pixel's color becomes important in the output.
5.  **Transformation:** The core transformation seems to be a "flood fill" or "paint bucket" operation. The area connected to the unique "seed" pixel, consisting of the background color, is filled with the "seed" color.
6.  **Fill Propagation:** The fill spreads outwards from the seed pixel's location. It only changes pixels that originally had the background color.
7.  **Fill Boundaries:** The fill stops when it encounters any pixel whose color is *not* the background color (this includes the boundary/structure colors, the original seed pixel, and any other non-background colors) or the edge of the grid. Pixels that are not the background color are never overwritten by the fill.

**Facts**


```yaml
task_type: flood_fill

components:
  - role: background
    description: The most frequent color in the input grid. This color is subject to being replaced by the fill_color in specific regions.
    example_colors: [blue (1), white (0), orange (7)]
  - role: seed_pixel
    description: A single pixel in the input grid whose color is unique and distinct from the background and other structural elements.
    properties:
      - count: 1 per grid
      - color: determines the fill_color
      - location: determines the starting point for the fill
    example_colors: [maroon (9), yellow (4), green (3)]
  - role: fill_color
    description: The color used to fill the target region. It is the same as the color of the seed_pixel.
    example_colors: [maroon (9), yellow (4), green (3)]
  - role: boundary_pixels
    description: Pixels whose color is not the background color. They block the spread of the fill and are not modified by the transformation. This includes the original seed pixel and any other non-background colors.
    example_colors: [green (3), gray (5), maroon (9), magenta (6), azure (8)]
  - role: fill_region
    description: The connected area of background-colored pixels reachable from the seed_pixel without crossing any boundary_pixels.

transformation:
  type: conditional_replacement
  predicate: A pixel is replaced if it has the background color AND it is part of the fill_region.
  replacement_value: fill_color
  connectivity: 4-directional (up, down, left, right)

input_output_relationship:
  - dimensions: Input and output grids have identical dimensions.
  - preservation: All pixels that are not the background color in the input retain their original color and position in the output.
  - modification: Some background-colored pixels in the input are changed to the fill_color in the output.
```


**Natural Language Program**

1.  Identify the background color by finding the most frequent color in the input grid.
2.  Scan the input grid to find the unique "seed" pixel â€“ the single pixel whose color is different from the background color and appears only once (or is otherwise uniquely identifiable as the starting point, possibly by being enclosed). Determine the color (this is the `fill_color`) and location (this is the `start_point`) of this seed pixel.
3.  Initialize the output grid as a copy of the input grid.
4.  Perform a flood fill operation on the output grid, starting from the `start_point`:
    *   Maintain a list or queue of locations to visit, initially containing only the `start_point`.
    *   Maintain a set of visited locations to avoid redundant processing.
    *   While the list of locations to visit is not empty:
        *   Take a location (row, col) from the list.
        *   If this location has already been visited, continue to the next location.
        *   Mark the location (row, col) as visited.
        *   Check the color of the pixel at (row, col) in the *input* grid.
        *   If the color at (row, col) in the input grid is the background color:
            *   Change the color of the pixel at (row, col) in the *output* grid to the `fill_color`.
            *   Add its four neighbors (up, down, left, right), if they are within the grid boundaries, to the list of locations to visit.
        *   If the color at (row, col) in the input grid is *not* the background color, do nothing (it acts as a boundary).
5.  Return the modified output grid.
