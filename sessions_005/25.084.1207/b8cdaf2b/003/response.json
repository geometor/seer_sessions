{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransformation Rule:\n1. Identify a 'trigger point': a location (r, c) where a non-background pixel C1 is directly above a *different* non-background pixel C2 at (r+1, c).\n2. Identify the 'emitter segment': the maximal horizontal contiguous segment of color C2 located at row r+1 that includes the trigger point's lower pixel.\n3. Determine the emitter segment's color (C2), width, and center coordinates (row 'emitter_y = r+1', column 'emitter_center_x').\n4. Based on the emitter's color and width, select a predefined pattern of relative coordinate offsets {(dy, dx)}.\n5. Create the output grid by copying the input grid.\n6. For each offset (dy, dx) in the pattern, calculate the target coordinates (emitter_y + dy, emitter_center_x + dx).\n7. If the target coordinates are within the grid boundaries, set the pixel at the target coordinates in the output grid to the emitter's color (C2).\n\"\"\"\n\ndef find_emitter_segment(grid):\n    \"\"\"\n    Finds the emitter segment in the grid based on the trigger condition.\n\n    The trigger condition is a non-background pixel C1 at (r, c) directly\n    above a different non-background pixel C2 at (r+1, c).\n    The emitter segment is the horizontal segment of color C2 at row r+1\n    containing the pixel at (r+1, c).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        A tuple (emitter_y, emitter_x_min, emitter_x_max, emitter_color)\n        representing the emitter segment's row, start column, end column,\n        and color, or None if no emitter segment is found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1): # Iterate rows up to the second to last\n        for c in range(width):\n            color_above = grid[r, c]\n            color_below = grid[r + 1, c]\n\n            # Check for the trigger condition at (r, c)\n            if color_above != 0 and color_below != 0 and color_above != color_below:\n                # Found a trigger point. Identify the emitter segment below it.\n                emitter_color = color_below\n                emitter_y = r + 1\n                \n                # Find the horizontal extent of the segment at emitter_y containing column c\n                emitter_x_min = c\n                emitter_x_max = c\n\n                # Extend to the left\n                while emitter_x_min > 0 and grid[emitter_y, emitter_x_min - 1] == emitter_color:\n                    emitter_x_min -= 1\n\n                # Extend to the right\n                while emitter_x_max < width - 1 and grid[emitter_y, emitter_x_max + 1] == emitter_color:\n                    emitter_x_max += 1\n                \n                # Found the unique emitter segment (assumption based on examples)\n                return emitter_y, emitter_x_min, emitter_x_max, emitter_color\n\n    return None # No trigger point and thus no emitter found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # 1. & 2. Identify the Emitter Segment based on trigger points\n    emitter_info = find_emitter_segment(input_np)\n\n    # If no emitter segment is found, return the original grid\n    if emitter_info is None:\n        return output_grid.tolist()\n\n    # 3. Determine Emitter Properties\n    emitter_y, emitter_x_min, emitter_x_max, emitter_color = emitter_info\n    emitter_width = emitter_x_max - emitter_x_min + 1\n    # Calculate center column using integer division\n    emitter_center_x = (emitter_x_min + emitter_x_max) // 2\n\n    # 4. Select Offset Pattern based on emitter properties\n    offsets = []\n    if emitter_color == 1 and emitter_width == 3: # Blue, Width 3\n        offsets = [(-2, -2), (-2, +2)]\n    elif emitter_color == 3 and emitter_width == 1: # Green, Width 1\n        offsets = [(-3, -2), (-3, +2), (-2, -1), (-2, +1)]\n    elif emitter_color == 4 and emitter_width == 3: # Yellow, Width 3\n        offsets = [(-3, -3), (-3, +3), (-2, -2), (-2, +2)]\n    elif emitter_color == 4 and emitter_width == 1: # Yellow, Width 1\n        offsets = [(-2, -1), (-2, +1)]\n    # Add more patterns here if discovered in new examples\n\n    # 5. & 6. & 7. Apply Offsets and Modify Output Grid\n    for dy, dx in offsets:\n        # Calculate target coordinates relative to the emitter's center\n        target_y = emitter_y + dy\n        target_x = emitter_center_x + dx\n\n        # Check if the target coordinates are within the grid boundaries\n        if 0 <= target_y < height and 0 <= target_x < width:\n            # Set the pixel at the target coordinates to the emitter's color\n            output_grid[target_y, target_x] = emitter_color\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6040,
    "candidates_token_count": 1368,
    "total_token_count": 7408,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.610205
}