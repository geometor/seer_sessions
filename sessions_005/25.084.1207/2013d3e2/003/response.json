{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nExtracts a 3x3 subgrid from the input grid. The extraction anchor point depends on the presence of a blue pixel (color 1).\n1. Search for the top-leftmost blue pixel (minimum row, then minimum column).\n2. If a blue pixel is found, its coordinates (r, c) become the anchor point.\n3. If no blue pixel is found, find the top-left corner (min_r, min_c) of the bounding box containing all non-white pixels (color > 0). This corner becomes the anchor point.\n4. Extract the 3x3 subgrid starting at the determined anchor point (anchor_r, anchor_c), covering input[anchor_r : anchor_r + 3, anchor_c : anchor_c + 3].\n\"\"\"\n\nimport numpy as np\n\ndef find_top_left_color(grid, color):\n    \"\"\"\n    Finds the row and column of the top-leftmost pixel with the specified color.\n    Scans row by row, then column by column.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        tuple or None: A tuple (row, col) if the color is found, otherwise None.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color:\n                return (r, c)\n    return None\n\ndef find_non_white_bbox_top_left(grid):\n    \"\"\"\n    Finds the minimum row and minimum column index of any non-white pixel.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple or None: A tuple (min_row, min_col) if non-white pixels exist,\n                       otherwise None.\n    \"\"\"\n    non_white_indices = np.argwhere(grid != 0) # Find indices where color is not 0 (white)\n    if non_white_indices.size == 0:\n        return None  # Grid contains only white pixels (or is empty)\n    min_row = non_white_indices[:, 0].min() # Minimum row index among non-white pixels\n    min_col = non_white_indices[:, 1].min() # Minimum column index among non-white pixels\n    return (min_row, min_col)\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts a 3x3 subgrid from the input grid based on the anchor point rules.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        np.array: A 3x3 numpy array representing the extracted output grid.\n                  Returns a 3x3 grid of zeros if no anchor point can be determined\n                  (e.g., input is all white).\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    blue_color = 1\n    start_row, start_col = -1, -1 # Initialize with invalid values\n\n    # 1. Search for the top-leftmost blue pixel\n    blue_pixel_loc = find_top_left_color(input_grid_np, blue_color)\n\n    # 2. If blue pixel found, use its location as anchor\n    if blue_pixel_loc is not None:\n        start_row, start_col = blue_pixel_loc\n        # print(f\"Blue pixel found at: ({start_row}, {start_col})\") # Debug info\n\n    # 3. Else (no blue pixel), use non-white bounding box top-left as anchor\n    else:\n        bbox_top_left = find_non_white_bbox_top_left(input_grid_np)\n        if bbox_top_left is not None:\n            # Use the bounding box top-left directly as the anchor\n            start_row, start_col = bbox_top_left\n            # print(f\"No blue pixel. Bbox TL: {bbox_top_left}. Start: ({start_row}, {start_col})\") # Debug info\n        else:\n            # Handle case where no blue pixel AND no non-white pixels are found\n            # (e.g., input is all white). Return a 3x3 white grid.\n            # print(\"Warning: No blue pixel and no non-white pixels found. Returning 3x3 white grid.\") # Debug info\n            return np.zeros((3, 3), dtype=int)\n\n    # Basic check if calculated anchor is somehow invalid (should not happen based on ARC task examples)\n    # An anchor point should always allow for a 3x3 extraction if found according to rules.\n    if start_row < 0 or start_col < 0 or start_row + 3 > height or start_col + 3 > width:\n         # print(f\"Warning: Calculated extraction start ({start_row}, {start_col}) leads to out-of-bounds for input size ({height}x{width}). Returning 3x3 white grid.\") # Debug info\n         # Returning a default; this suggests an issue either with the input violating assumptions or a flaw in the logic if it occurs.\n         return np.zeros((3, 3), dtype=int)\n\n    # 4. Extract the 3x3 subgrid using the determined anchor point\n    output_grid = input_grid_np[start_row : start_row + 3, start_col : start_col + 3]\n\n    # Final check to ensure output is 3x3 (numpy slicing should handle this correctly if anchor is valid)\n    if output_grid.shape != (3, 3):\n         # print(f\"Warning: Extracted grid shape is {output_grid.shape}, expected (3, 3). Problem with start indices ({start_row}, {start_col}) or input size. Returning 3x3 white grid.\") # Debug info\n         # Fallback for unexpected slicing results\n         return np.zeros((3, 3), dtype=int)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5267,
    "candidates_token_count": 1417,
    "total_token_count": 6684,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.12604
}