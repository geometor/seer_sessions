{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Identify the single contiguous White object (W) and its dimensions.\n2. Identify the single contiguous Red object (R) and its dimensions.\n3. Identify all contiguous Blue objects (B_list) and their dimensions.\n4. Create an output grid, initially a copy of the input.\n5. Change the pixels of W to Blue in the output grid.\n6. Check if any Blue object in B_list has dimensions matching R's dimensions.\n7. If a match exists: Change the pixels of R to White in the output grid.\n8. If no match exists: Find the first Blue object (B_match_W) in B_list with dimensions matching W's dimensions. If found, change the pixels of B_match_W to White in the output grid.\n9. Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (a set of (row, col) tuples) and\n              'dims' (a tuple of (height, width)). Returns an empty list if no\n              objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start BFS to find a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Calculate bounding box dimensions\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                objects.append({'coords': obj_coords, 'dims': (height, width)})\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on White, Red, and Blue object dimensions.\n    \"\"\"\n    # 4. Create an output grid, initially a copy of the input.\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify the single white_object (W).\n    white_objects = find_objects(input_grid, 0)\n    if not white_objects:\n        return output_grid # Should not happen based on examples, but safe check\n    white_object = white_objects[0] # Assume exactly one\n    white_coords = white_object['coords']\n    white_dims = white_object['dims']\n\n    # 2. Identify the single red_object (R).\n    red_objects = find_objects(input_grid, 2)\n    if not red_objects:\n        return output_grid # Should not happen based on examples\n    red_object = red_objects[0] # Assume exactly one\n    red_coords = red_object['coords']\n    red_dims = red_object['dims']\n\n    # 3. Identify all blue_objects (B_list).\n    blue_objects = find_objects(input_grid, 1)\n\n    # 5. Change the pixels of W to Blue in the output grid.\n    for r, c in white_coords:\n        if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n             output_grid[r, c] = 1\n\n    # 6. Check if any Blue object in B_list has dimensions matching R's dimensions.\n    found_blue_matching_red = False\n    for blue_obj in blue_objects:\n        if blue_obj['dims'] == red_dims:\n            found_blue_matching_red = True\n            break\n\n    # 7. If a match exists: Change the pixels of R to White in the output grid.\n    if found_blue_matching_red:\n        for r, c in red_coords:\n             if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                output_grid[r, c] = 0\n    # 8. If no match exists: Find the first Blue object (B_match_W) matching W's dimensions.\n    else:\n        found_blue_matching_white = None\n        for blue_obj in blue_objects:\n            if blue_obj['dims'] == white_dims:\n                found_blue_matching_white = blue_obj\n                break # Found the first match\n\n        # If found, change the pixels of B_match_W to White in the output grid.\n        if found_blue_matching_white:\n            for r, c in found_blue_matching_white['coords']:\n                 if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                    output_grid[r, c] = 0\n\n    # 9. Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16710,
    "candidates_token_count": 1442,
    "total_token_count": 18152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.410074
}