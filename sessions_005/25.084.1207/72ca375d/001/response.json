{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis program identifies all distinct objects (contiguous blocks of the same \nnon-background color) in the input grid. For each object, it calculates its \nbounding box and the ratio of the object's pixels to the area of its bounding \nbox (fill ratio). It then selects the object with the highest fill ratio. \nIf there's a tie in fill ratios, it selects the object whose bounding box's \ntop-left corner is highest up, and then furthest to the left. Finally, it \nextracts the rectangular region corresponding to the selected object's bounding \nbox from the input grid and returns this subgrid as the output.\n\"\"\"\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all distinct connected objects of the same non-background color.\n    Uses 8-way connectivity (including diagonals).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color designated as background.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with \n              'color' and 'coords' (a set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            # Check if pixel is part of an object and not yet visited\n            if grid[r, c] != background_color and not visited[r, c]:\n                object_color = grid[r, c]\n                current_object_coords = set()\n                q = deque([(r, c)]) # Use a queue for BFS\n                visited[r, c] = True\n                \n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_coords.add((curr_r, curr_c))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                                \n                            nr, nc = curr_r + dr, curr_c + dc\n                            \n                            # Check bounds, color match, and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == object_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                # Store the found object if it has pixels\n                if current_object_coords: \n                    objects.append({'color': object_color, 'coords': current_object_coords})\n                    \n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimal bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples representing object pixels.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None \n\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    \n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    return (min_r, max_r, min_c, max_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies objects, calculates fill ratios, selects the object with the \n    maximum fill ratio (using top-left tie-breaking), and extracts its \n    bounding box from the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The extracted subgrid corresponding to the selected \n                       object's bounding box. Returns [[]] if no objects found.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    \n    # Handle empty input grid edge case\n    if grid.size == 0:\n        return [[]]\n        \n    height, width = grid.shape\n    background_color = 0\n\n    # Find all objects in the grid\n    objects = find_objects(grid, background_color)\n\n    # If no objects are found, return an empty grid representation\n    if not objects:\n        return [[]] \n\n    max_fill_ratio = -1.0\n    selected_object_bbox = None\n    selected_object_coords = None # Keep track of coordinates for tie-breaking comparison\n\n    # Iterate through each found object to calculate properties and find the best one\n    for obj in objects:\n        coords = obj['coords']\n        pixel_count = len(coords)\n        \n        # Should not happen with current find_objects logic, but safety check\n        if pixel_count == 0: \n             continue\n\n        # Calculate the bounding box of the object\n        bbox = get_bounding_box(coords)\n        if bbox is None: # Should not happen if pixel_count > 0\n            continue\n            \n        min_r, max_r, min_c, max_c = bbox\n        \n        # Calculate bounding box dimensions and area\n        bbox_height = max_r - min_r + 1\n        bbox_width = max_c - min_c + 1\n        bbox_area = bbox_height * bbox_width\n\n        # Calculate the fill ratio\n        fill_ratio = pixel_count / bbox_area\n\n        # Check if this object has a higher fill ratio or wins the tie-breaker\n        update_selection = False\n        if fill_ratio > max_fill_ratio:\n            update_selection = True\n        elif fill_ratio == max_fill_ratio:\n            # Tie-breaking: prefer top-most (min_r), then left-most (min_c)\n            current_min_r, _, current_min_c, _ = selected_object_bbox\n            if min_r < current_min_r:\n                update_selection = True\n            elif min_r == current_min_r and min_c < current_min_c:\n                update_selection = True\n\n        # Update the selected object if necessary\n        if update_selection:\n            max_fill_ratio = fill_ratio\n            selected_object_bbox = bbox\n            # selected_object_coords = coords # Not strictly needed after selection\n\n    # If somehow no object was selected (e.g., all objects had issues), return empty\n    if selected_object_bbox is None:\n         return [[]]\n\n    # Extract the subgrid corresponding to the selected object's bounding box\n    min_r, max_r, min_c, max_c = selected_object_bbox\n    output_grid = grid[min_r:max_r+1, min_c:max_c+1]\n\n    # Return the output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2535,
    "candidates_token_count": 1658,
    "total_token_count": 4193,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.203702
}