
## train_1

**input:**
```
0 4 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```


**output:**
```
0 4 0 0 0 0 0
4 0 4 0 0 0 0
0 4 0 0 0 0 0
4 0 4 0 0 0 0
0 4 0 0 0 0 0
4 0 4 0 0 0 0
```


## train_2

**input:**
```
0 2 0 0 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 2 0 0 0 8 0 0 0 0
2 0 2 0 8 0 8 0 0 0
0 2 0 0 0 8 0 0 0 0
2 0 2 0 8 0 8 0 0 0
0 2 0 0 0 8 0 0 0 0
2 0 2 0 8 0 8 0 0 0
```

Okay, let's analyze the provided examples.

## Perception

1.  **Grid Structure:** Both input and output are 2D grids of pixels represented by integer color codes (0-9). The grid dimensions remain the same between input and output for each example (6x7 for train_1, 6x10 for train_2).
2.  **Background:** The background is predominantly white (0).
3.  **Input Objects:** The inputs contain one or more isolated non-white pixels. In `train_1`, there's a single yellow (4) pixel. In `train_2`, there's a red (2) pixel and an azure (8) pixel. These initial non-white pixels appear in the first row (row 0) in both examples.
4.  **Output Transformation:** The output grids retain the original non-white pixels. Additionally, new pixels of the same color are added in the rows below the original pixels. These new pixels form a distinct vertical pattern extending downwards.
5.  **Pattern Details:**
    *   For an initial colored pixel at `(row, col)`, its color appears directly below it at `(row + 2, col)`, `(row + 4, col)`, etc., in the even-numbered rows relative to the initial row.
    *   In the odd-numbered rows relative to the initial row (`row + 1`, `row + 3`, etc.), the color appears diagonally adjacent to the column of the pixel above it, specifically at `(row + 1, col - 1)` and `(row + 1, col + 1)`, then `(row + 3, col - 1)` and `(row + 3, col + 1)`, and so on.
    *   This pattern continues down to the bottom of the grid.
    *   If multiple colored pixels exist in the input (like in `train_2`), each one generates its pattern independently using its specific color.
    *   The generation respects grid boundaries; pixels are not placed outside the grid.

## Facts


```yaml
task_type: pattern_generation
grid_properties:
  - dimensions_preserved: true
  - background_color: 0 # white

objects:
  - type: pixel
    properties:
      - color: non-zero integer (1-9)
      - location: (row, column) coordinate in the input grid

actions:
  - name: identify_source_pixels
    inputs: input_grid
    outputs: list of source_pixel_objects (non-white pixels)

  - name: generate_vertical_pattern
    inputs:
      - source_pixel_object (color C, location (r, c))
      - grid_dimensions (height H, width W)
    outputs: set of new_pixel_locations and their color C
    description: |
      For each source pixel (C, (r, c)):
      1. Initialize a set of output pixels with {(r, c): C}.
      2. Iterate through rows i from r + 1 to H - 1.
      3. Calculate relative row difference: diff = i - r.
      4. If diff is odd:
         - Add (i, c - 1): C to the output set if c - 1 >= 0.
         - Add (i, c + 1): C to the output set if c + 1 < W.
      5. If diff is even:
         - Add (i, c): C to the output set.

  - name: construct_output_grid
    inputs:
      - grid_dimensions (H, W)
      - background_color (0)
      - list_of_generated_patterns (sets of {location: color})
    outputs: output_grid
    description: |
      1. Create an empty grid of dimensions H x W filled with the background color.
      2. For each generated pattern set associated with a source pixel:
         - Iterate through the {location: color} pairs in the set.
         - Place the color at the specified location in the output grid.
      (Note: Order might matter if patterns overlap, but in examples, they don't. Assume overwriting is acceptable if needed).

relationships:
  - The pattern generated by a source pixel depends only on its color, its location (r, c), and the grid dimensions.
  - The placement of new pixels in subsequent rows depends on the parity (odd/even) of the row difference relative to the source pixel's row.
  - Patterns from different source pixels are generated independently.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid. (Alternatively, start with a blank grid of the same dimensions filled with the background color, white (0)).
2.  Identify all non-white pixels in the input grid. Let each such pixel be a "source pixel" with color `C` at location `(r, c)`.
3.  For each source pixel found:
    a.  Ensure the pixel at `(r, c)` in the output grid has color `C`.
    b.  Iterate through the rows `i` starting from `r + 1` down to the last row of the grid.
    c.  Calculate the difference in rows: `diff = i - r`.
    d.  If `diff` is an odd number:
        i.  If the column `c - 1` is within the grid bounds (>= 0), set the pixel at `(i, c - 1)` in the output grid to color `C`.
        ii. If the column `c + 1` is within the grid bounds (< grid width), set the pixel at `(i, c + 1)` in the output grid to color `C`.
    e.  If `diff` is an even number:
        i.  Set the pixel at `(i, c)` in the output grid to color `C`. (This location is guaranteed to be within bounds since `c` was).
4.  Return the final output grid.
