{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a pattern found inside a blue rectangular frame using colors from the \ninput grid's corners as replacement colors based on quadrants.\n\n1.  Identify Corner Colors: Record the colors of the four pixels at the \n    absolute corners (top-left, top-right, bottom-left, bottom-right) of the \n    input grid (TL_color, TR_color, BL_color, BR_color).\n2.  Locate Central Azure Pattern: Find the bounding box of all Azure (8) pixels \n    in the input grid.\n3.  Identify Inner Frame Boundaries: Assume the relevant Blue (1) frame is \n    exactly one pixel outside the bounding box of the Azure pixels. Calculate \n    the frame's min/max row/column indices.\n4.  Extract Inner Pattern: Extract the subgrid located strictly *inside* the \n    inner frame boundaries. Let its dimensions be H_inner x W_inner.\n5.  Initialize Output Grid: Create a new grid of size H_inner x W_inner, \n    filled with White (0).\n6.  Map Colors: Iterate through each pixel (r, c) in the extracted inner pattern.\n    - If the inner pattern pixel is White (0), the output pixel remains White (0).\n    - If the inner pattern pixel is Azure (8):\n        - Determine its quadrant within the inner pattern relative to the center \n          (H_inner // 2, W_inner // 2).\n        - Assign the corresponding corner color (TL_color, TR_color, BL_color, \n          BR_color) to the output pixel.\n    - Other colors in the inner pattern map to White (0).\n7.  Return the resulting output grid.\n\"\"\"\n\ndef _find_azure_bbox(grid: np.ndarray) -> tuple[int, int, int, int] | None:\n    \"\"\"\n    Finds the bounding box of Azure (8) pixels in the grid.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple (min_row, max_row, min_col, max_col) representing the \n        bounding box (inclusive). Returns None if no Azure pixels are found.\n    \"\"\"\n    azure_coords = np.argwhere(grid == 8)\n    if azure_coords.size == 0:\n        return None\n    min_row = np.min(azure_coords[:, 0])\n    max_row = np.max(azure_coords[:, 0])\n    min_col = np.min(azure_coords[:, 1])\n    max_col = np.max(azure_coords[:, 1])\n    return min_row, max_row, min_col, max_col\n\ndef _get_corner_colors(grid: np.ndarray) -> tuple[int, int, int, int]:\n    \"\"\"\n    Extracts the colors of the four corner pixels.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple (TL_color, TR_color, BL_color, BR_color).\n    \"\"\"\n    H, W = grid.shape\n    TL_color = grid[0, 0]\n    TR_color = grid[0, W - 1]\n    BL_color = grid[H - 1, 0]\n    BR_color = grid[H - 1, W - 1]\n    return TL_color, TR_color, BL_color, BR_color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the quadrant-based color replacement transformation.\n\n    Args:\n        input_grid: The input grid represented as a 2D list.\n\n    Returns:\n        The transformed output grid as a 2D list. Returns empty list\n        if the expected structure (Azure pattern, frame) is not found.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n\n    # Handle grids too small to contain corners, frame, and pattern\n    if H < 3 or W < 3:\n        # print(\"Warning: Input grid too small.\")\n        return [] \n\n    # --- Step 1: Identify Corner Colors ---\n    TL_color, TR_color, BL_color, BR_color = _get_corner_colors(input_np)\n\n    # --- Step 2: Locate Central Azure Pattern ---\n    azure_bbox = _find_azure_bbox(input_np)\n    if azure_bbox is None:\n        # print(\"Warning: No Azure (8) pixels found.\")\n        # Fallback or error handling could be added here if needed.\n        # Based on examples, Azure pattern is expected.\n        return [] # Return empty list if core pattern element is missing\n\n    azure_min_r, azure_max_r, azure_min_c, azure_max_c = azure_bbox\n\n    # --- Step 3: Identify Inner Frame Boundaries ---\n    # Assume the frame is exactly one pixel outside the Azure bbox\n    frame_min_r = azure_min_r - 1\n    frame_max_r = azure_max_r + 1\n    frame_min_c = azure_min_c - 1\n    frame_max_c = azure_max_c + 1\n\n    # Basic validation: Check if frame boundaries are within grid limits\n    if not (0 <= frame_min_r < frame_max_r < H and 0 <= frame_min_c < frame_max_c < W):\n         # print(\"Warning: Deduced frame boundaries extend outside grid or are invalid.\")\n         # This might indicate an unexpected input structure.\n         return []\n\n    # Optional: Verify frame pixels are actually Blue (1) - might be needed for robustness\n    # Example check (can be expanded):\n    # if not np.all(input_np[frame_min_r, frame_min_c+1:frame_max_c] == 1): return [] # Check top edge\n    # ... check other edges ...\n\n    # --- Step 4: Extract Inner Pattern ---\n    # The inner pattern is strictly inside the frame boundaries\n    inner_min_r = frame_min_r + 1\n    inner_max_r = frame_max_r # Slice index is exclusive\n    inner_min_c = frame_min_c + 1\n    inner_max_c = frame_max_c # Slice index is exclusive\n\n    inner_pattern = input_np[inner_min_r:inner_max_r, inner_min_c:inner_max_c]\n    H_inner, W_inner = inner_pattern.shape\n\n    # Check if inner pattern is valid\n    if H_inner <= 0 or W_inner <= 0:\n        # print(\"Warning: Invalid frame or no inner pattern extracted.\")\n        return [] \n\n    # --- Step 5: Initialize Output Grid ---\n    # Initialize with White (0), as White pixels map directly\n    output_grid = np.zeros_like(inner_pattern)\n\n    # --- Step 6: Map Colors ---\n    # Calculate the midpoints for quadrant division (integer division)\n    # Note: If H_inner or W_inner is odd, the middle row/col falls into \n    # the bottom/right quadrant respectively due to zero-based indexing \n    # and '<' vs '>=' comparisons. This matches the examples' implied logic.\n    mid_row = H_inner // 2\n    mid_col = W_inner // 2\n\n    # Iterate through each pixel of the inner pattern\n    for r in range(H_inner):\n        for c in range(W_inner):\n            current_color = inner_pattern[r, c]\n\n            if current_color == 8: # Azure pixel\n                # Determine the quadrant based on row and column relative to midpoints\n                if r < mid_row and c < mid_col: # Top-Left Quadrant\n                    output_grid[r, c] = TL_color\n                elif r < mid_row and c >= mid_col: # Top-Right Quadrant\n                    output_grid[r, c] = TR_color\n                elif r >= mid_row and c < mid_col: # Bottom-Left Quadrant\n                    output_grid[r, c] = BL_color\n                elif r >= mid_row and c >= mid_col: # Bottom-Right Quadrant\n                    output_grid[r, c] = BR_color\n            # White (0) pixels are already handled by initialization\n            # Other colors in inner_pattern also remain 0 in output_grid\n\n    # --- Step 7: Return Output Grid ---\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8724,
    "candidates_token_count": 2016,
    "total_token_count": 10740,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.121659
}