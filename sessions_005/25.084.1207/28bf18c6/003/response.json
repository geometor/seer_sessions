{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the single contiguous non-white object in the input grid.\nDetermines its minimal bounding box (height H, width W).\nCreates an output grid of size H x (2*W).\nExtracts the object's pattern relative to its bounding box.\nPlaces this pattern twice into the output grid, side-by-side, filling the grid completely.\nThe first pattern occupies columns 0 to W-1.\nThe second pattern occupies columns W to 2*W-1.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_colored_object(grid):\n    \"\"\"\n    Finds the first contiguous non-white object in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - set: Coordinates (row, col) of the object's pixels.\n            - int: The color of the object.\n        Returns (None, -1) if no non-white object is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    q = deque()\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start search from the first non-white, unvisited pixel\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                object_pixels = set()\n                q.append((r, c))\n                visited.add((r, c))\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    object_pixels.add((row, col))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Assuming only one non-white object per task requirements\n                return object_pixels, int(color) \n\n    # No non-white object found\n    return None, -1\n\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the minimal bounding box for a set of pixel coordinates.\n\n    Args:\n        pixels (set): A set of (row, col) tuples representing the object pixels.\n\n    Returns:\n        tuple: (min_row, min_col, height, width)\n               Returns (0, 0, 0, 0) if the pixels set is empty or None.\n    \"\"\"\n    if not pixels:\n        return 0, 0, 0, 0\n\n    # Find the min/max row and column indices from the object pixels\n    min_row = min(r for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n\n    # Calculate height and width\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    return min_row, min_col, height, width\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by duplicating the found object's pattern side-by-side.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Find the single contiguous non-white object and its color.\n    object_pixels, color = find_colored_object(input_np)\n\n    # Handle case where no object is found (return empty or original, based on convention)\n    if object_pixels is None:\n        # Let's return an empty grid if no object is found.\n        return [[]] \n\n    # 2. Determine the minimal bounding box of the object.\n    min_row, min_col, height, width = get_bounding_box(object_pixels)\n    \n    # Handle edge case of zero-dimension bounding box (shouldn't happen if object_pixels is not None)\n    if height == 0 or width == 0:\n        return [[]]\n\n    # 3. Create the object pattern grid (size: height x width).\n    # Initialize with white (0).\n    object_pattern = np.zeros((height, width), dtype=int)\n    # Populate the pattern grid with the object's color at relative coordinates.\n    for r, c in object_pixels:\n        relative_r = r - min_row\n        relative_c = c - min_col\n        # Ensure coordinates are within the pattern bounds (sanity check)\n        if 0 <= relative_r < height and 0 <= relative_c < width:\n            object_pattern[relative_r, relative_c] = color\n\n    # 4. Create the new output grid with dimensions height x (2 * width).\n    # Initialize with white (0).\n    output_height = height\n    output_width = 2 * width\n    output_grid_np = np.zeros((output_height, output_width), dtype=int)\n\n    # 5. Place the object pattern into the left half of the output grid.\n    # Slicing handles the copy: output[rows, cols] = pattern\n    output_grid_np[0:height, 0:width] = object_pattern\n\n    # 6. Place the object pattern into the right half of the output grid.\n    output_grid_np[0:height, width:output_width] = object_pattern\n\n    # 7. Convert the output NumPy array back to a list of lists format.\n    output_grid = output_grid_np.tolist()\n\n    # 8. Return the resulting grid.\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6573,
    "candidates_token_count": 1465,
    "total_token_count": 8038,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 13.714326
}