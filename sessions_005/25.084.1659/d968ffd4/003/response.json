{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct rectangular objects within a background color.\nDetermines if the objects are aligned horizontally or vertically with a gap of background color between them.\nFills the gap between the objects, within the bounding box encompassing both objects, based on proximity.\nIf horizontally aligned:\n  - The gap is defined by the columns between the right edge of the left object and the left edge of the right object.\n  - The rows to be filled span from the minimum row of both objects to the maximum row of both objects.\n  - The gap columns are split roughly in half horizontally. Columns closer to the left object get its color, columns closer to the right object get its color. If the gap width is odd, the middle column remains the background color.\nIf vertically aligned:\n  - The gap is defined by the rows between the bottom edge of the top object and the top edge of the bottom object.\n  - The columns to be filled span from the minimum column of both objects to the maximum column of both objects.\n  - The gap rows are split roughly in half vertically. Rows closer to the top object get its color (using ceiling division for the split), rows closer to the bottom object get its color (using floor division).\nIf exactly two objects are not found, or they are not aligned horizontally or vertically with a gap, the original grid is returned.\n\"\"\"\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples),\n              'min_row', 'min_col', 'max_row', 'max_col'.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store found object details\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'min_row': min_r,\n                    'min_col': min_c,\n                    'max_row': max_r,\n                    'max_col': max_c\n                })\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the gap between two aligned objects based on their colors and proximity,\n    considering the combined bounding box of the objects.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Identify the background color (most frequent color)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    if len(counts) > 0:\n        background_color = colors[np.argmax(counts)]\n    else: # Handle empty grid case\n        return output_grid \n\n    # 2. Find all contiguous non-background objects\n    objects = _find_objects(output_grid, background_color)\n\n    # 3. Ensure exactly two objects are found\n    if len(objects) != 2:\n        return output_grid \n\n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # Extract bounding boxes\n    bb1_min_row, bb1_min_col, bb1_max_row, bb1_max_col = obj1['min_row'], obj1['min_col'], obj1['max_row'], obj1['max_col']\n    bb2_min_row, bb2_min_col, bb2_max_row, bb2_max_col = obj2['min_row'], obj2['min_col'], obj2['max_row'], obj2['max_col']\n\n    # Calculate the union bounding box\n    union_min_row = min(bb1_min_row, bb2_min_row)\n    union_max_row = max(bb1_max_row, bb2_max_row)\n    union_min_col = min(bb1_min_col, bb2_min_col)\n    union_max_col = max(bb1_max_col, bb2_max_col)\n\n    # 4. Determine alignment (Horizontal or Vertical)\n    \n    # Check for Horizontal Alignment: Separated columns, potentially overlapping rows\n    # A gap must exist between the objects horizontally.\n    col_separated_gap_exists = (bb1_max_col + 1 < bb2_min_col) or (bb2_max_col + 1 < bb1_min_col)\n\n    if col_separated_gap_exists:\n        # Identify Left and Right objects\n        if bb1_min_col < bb2_min_col:\n            left_obj = obj1\n            right_obj = obj2\n        else:\n            left_obj = obj2\n            right_obj = obj1\n            \n        # Calculate gap columns\n        gap_start_col = left_obj['max_col'] + 1\n        gap_end_col = right_obj['min_col'] - 1\n        gap_width = gap_end_col - gap_start_col + 1\n\n        # Check if the gap consists only of background color within the union rows\n        is_gap_background = True\n        if gap_width > 0:\n            for r in range(union_min_row, union_max_row + 1):\n                for c in range(gap_start_col, gap_end_col + 1):\n                     if 0 <= r < rows and 0 <= c < cols: # Boundary check\n                        if output_grid[r, c] != background_color:\n                            is_gap_background = False\n                            break\n                if not is_gap_background:\n                    break\n        else: # No gap width means no horizontal alignment case to fill\n             is_gap_background = False\n\n\n        if gap_width > 0 and is_gap_background:\n            # Calculate fill counts (integer division for floor)\n            fill_count = gap_width // 2 \n            \n            # Fill left part of the gap within the union bounding box rows\n            output_grid[union_min_row : union_max_row + 1, \n                        gap_start_col : gap_start_col + fill_count] = left_obj['color']\n            \n            # Fill right part of the gap within the union bounding box rows\n            # Note: The start index calculation ensures the middle column is skipped if gap_width is odd\n            output_grid[union_min_row : union_max_row + 1, \n                        gap_end_col - fill_count + 1 : gap_end_col + 1] = right_obj['color']\n            \n            # Successfully filled, return the result\n            return output_grid \n\n    # Check for Vertical Alignment: Separated rows, potentially overlapping columns\n    # A gap must exist between the objects vertically.\n    row_separated_gap_exists = (bb1_max_row + 1 < bb2_min_row) or (bb2_max_row + 1 < bb1_min_row)\n    \n    if row_separated_gap_exists:\n        # Identify Top and Bottom objects\n        if bb1_min_row < bb2_min_row:\n            top_obj = obj1\n            bottom_obj = obj2\n        else:\n            top_obj = obj2\n            bottom_obj = obj1\n\n        # Calculate gap rows\n        gap_start_row = top_obj['max_row'] + 1\n        gap_end_row = bottom_obj['min_row'] - 1\n        gap_height = gap_end_row - gap_start_row + 1\n\n        # Check if the gap consists only of background color within the union columns\n        is_gap_background = True\n        if gap_height > 0:\n            for r in range(gap_start_row, gap_end_row + 1):\n                for c in range(union_min_col, union_max_col + 1):\n                    if 0 <= r < rows and 0 <= c < cols: # Boundary check\n                        if output_grid[r, c] != background_color:\n                            is_gap_background = False\n                            break\n                if not is_gap_background:\n                    break\n        else: # No gap height means no vertical alignment case to fill\n            is_gap_background = False\n\n        if gap_height > 0 and is_gap_background:\n            # Calculate fill counts using ceiling for top and floor for bottom\n            top_fill_count = (gap_height + 1) // 2 \n            bottom_fill_count = gap_height // 2\n            \n            # Fill top part of the gap within the union bounding box columns\n            output_grid[gap_start_row : gap_start_row + top_fill_count, \n                        union_min_col : union_max_col + 1] = top_obj['color']\n            \n            # Fill bottom part of the gap within the union bounding box columns\n            output_grid[gap_end_row - bottom_fill_count + 1 : gap_end_row + 1, \n                        union_min_col : union_max_col + 1] = bottom_obj['color']\n\n            # Successfully filled, return the result\n            return output_grid\n\n    # 6. If no alignment or gap fill condition was met, return the original grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4609,
    "candidates_token_count": 2567,
    "total_token_count": 7176,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 132.07522
}