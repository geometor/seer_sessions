{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies exactly two distinct, non-background objects in a grid.\nDetermines if these objects are aligned horizontally or vertically with a gap of background color strictly between their bounding boxes.\nIf aligned, fills the rectangular region defined by the gap rows/columns, extending across the full grid dimension orthogonal to the alignment. The fill is based on proximity to the objects, using their respective colors.\n\nSpecifically:\n- The background color is the most frequent color in the grid.\n- Objects are contiguous areas of the same non-background color.\n- Alignment requires a gap (at least one row/column) of only background color between the bounding boxes.\n\nGap Filling Logic:\n- Calculate the number of rows/columns to fill from each side towards the center: `fill_count = gap_size // 2` (integer division).\n- If horizontally aligned (left_obj, right_obj, gap_width):\n    - Fill `fill_count` columns starting from the gap's left edge with left_obj's color, across all rows.\n    - Fill `fill_count` columns ending at the gap's right edge with right_obj's color, across all rows.\n    - If `gap_width` is odd, the middle column remains the background color.\n- If vertically aligned (top_obj, bottom_obj, gap_height):\n    - Fill `fill_count` rows starting from the gap's top edge with top_obj's color, across all columns.\n    - Fill `fill_count` rows ending at the gap's bottom edge with bottom_obj's color, across all columns.\n    - If `gap_height` is odd, the middle row remains the background color.\n\nIf exactly two objects are not found, or they are not aligned with a gap, the original grid is returned.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples),\n              'min_row', 'min_col', 'max_row', 'max_col'. Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store found object details\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'min_row': min_r,\n                    'min_col': min_c,\n                    'max_row': max_r,\n                    'max_col': max_c\n                })\n\n    return objects\n\ndef transform(input_grid):\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Handle empty grid case\n    if input_grid.size == 0:\n        return output_grid\n        \n    rows, cols = output_grid.shape\n\n    # 1. Identify the background color (most frequent color)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    if len(counts) == 0: # Should not happen if grid.size != 0, but safe check\n        return output_grid \n    background_color = colors[np.argmax(counts)]\n    \n    # Handle case where grid might be all one color (no distinct objects)\n    if len(colors) <= 1:\n        return output_grid\n\n    # 2. Find all contiguous non-background objects\n    objects = _find_objects(output_grid, background_color)\n\n    # 3. Ensure exactly two objects are found\n    if len(objects) != 2:\n        return output_grid \n\n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # 4. Check for Horizontal Alignment and Gap\n    # Determine potential left and right objects\n    if obj1['min_col'] < obj2['min_col']:\n        left_obj = obj1\n        right_obj = obj2\n    else:\n        left_obj = obj2\n        right_obj = obj1\n    \n    # Check if there's a horizontal gap (at least one column wide)\n    if left_obj['max_col'] < right_obj['min_col'] - 1:\n        gap_start_col = left_obj['max_col'] + 1\n        gap_end_col = right_obj['min_col'] - 1\n        \n        # Verify the gap contains only background color\n        is_gap_clear = np.all(output_grid[:, gap_start_col : gap_end_col + 1] == background_color)\n        \n        if is_gap_clear:\n            gap_width = gap_end_col - gap_start_col + 1\n            fill_count = gap_width // 2 # Number of columns to fill from each side\n            \n            # Fill left part of the gap across ALL rows\n            output_grid[:, gap_start_col : gap_start_col + fill_count] = left_obj['color']\n            \n            # Fill right part of the gap across ALL rows\n            # Start index calculation handles even/odd gap widths correctly\n            output_grid[:, gap_end_col - fill_count + 1 : gap_end_col + 1] = right_obj['color']\n            \n            # Successfully filled horizontally, return the result\n            return output_grid \n\n    # 5. Check for Vertical Alignment and Gap\n    # Determine potential top and bottom objects\n    if obj1['min_row'] < obj2['min_row']:\n        top_obj = obj1\n        bottom_obj = obj2\n    else:\n        top_obj = obj2\n        bottom_obj = obj1\n\n    # Check if there's a vertical gap (at least one row wide)\n    if top_obj['max_row'] < bottom_obj['min_row'] - 1:\n        gap_start_row = top_obj['max_row'] + 1\n        gap_end_row = bottom_obj['min_row'] - 1\n        \n        # Verify the gap contains only background color\n        is_gap_clear = np.all(output_grid[gap_start_row : gap_end_row + 1, :] == background_color)\n\n        if is_gap_clear:\n            gap_height = gap_end_row - gap_start_row + 1\n            fill_count = gap_height // 2 # Number of rows to fill from each side\n\n            # Fill top part of the gap across ALL columns\n            output_grid[gap_start_row : gap_start_row + fill_count, :] = top_obj['color']\n            \n            # Fill bottom part of the gap across ALL columns\n            # Start index calculation handles even/odd gap heights correctly\n            output_grid[gap_end_row - fill_count + 1 : gap_end_row + 1, :] = bottom_obj['color']\n\n            # Successfully filled vertically, return the result\n            return output_grid\n\n    # 6. If no alignment with a clear gap was found, return the original grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8935,
    "candidates_token_count": 2067,
    "total_token_count": 11002,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.653796
}