{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct objects within a background color.\nDetermines if the objects are aligned horizontally or vertically with a gap of background color between their bounding boxes.\nFills the rectangular region defined by the gap rows/columns, extending across the full grid dimension orthogonal to the alignment, based on proximity to the objects.\n\nIf horizontally aligned:\n  - The gap is defined by the columns between the right edge of the left object's bounding box and the left edge of the right object's bounding box.\n  - The rows to be filled span the entire height of the grid (0 to grid_height - 1).\n  - The gap columns are split roughly in half. Columns closer to the left object get its color, columns closer to the right object get its color. If the gap width is odd, the middle column remains the background color.\n\nIf vertically aligned:\n  - The gap is defined by the rows between the bottom edge of the top object's bounding box and the top edge of the bottom object's bounding box.\n  - The columns to be filled span the entire width of the grid (0 to grid_width - 1).\n  - The gap rows are split roughly in half. Rows closer to the top object get its color (using ceiling division for the split), rows closer to the bottom object get its color (using floor division). If the gap height is odd, the middle row remains the background color.\n\nIf exactly two objects are not found, or they are not aligned horizontally or vertically with a gap between their bounding boxes, the original grid is returned.\n\"\"\"\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples),\n              'min_row', 'min_col', 'max_row', 'max_col'. Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store found object details\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'min_row': min_r,\n                    'min_col': min_c,\n                    'max_row': max_r,\n                    'max_col': max_c\n                })\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the gap between two aligned objects based on their colors and proximity,\n    extending the fill across the full grid dimension orthogonal to the alignment.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # Handle empty grid case\n    if input_grid.size == 0:\n        return output_grid\n\n    # 1. Identify the background color (most frequent color)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    # Check if grid contains only one color or is empty\n    if len(counts) == 0:\n        return output_grid # Return unchanged if empty\n    background_color = colors[np.argmax(counts)]\n    # Handle case where grid might be all one color (no distinct objects)\n    if len(colors) <= 1:\n        return output_grid\n\n\n    # 2. Find all contiguous non-background objects\n    objects = _find_objects(output_grid, background_color)\n\n    # 3. Ensure exactly two objects are found\n    if len(objects) != 2:\n        return output_grid \n\n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # 4. Determine alignment (Horizontal or Vertical) based on bounding box separation\n    \n    # Check for Horizontal Alignment: BBoxes separated by columns\n    # Determine left and right objects first\n    if obj1['min_col'] < obj2['min_col']:\n        left_obj = obj1\n        right_obj = obj2\n    else:\n        left_obj = obj2\n        right_obj = obj1\n    \n    # Check if there's a horizontal gap\n    if left_obj['max_col'] < right_obj['min_col']:\n        gap_start_col = left_obj['max_col'] + 1\n        gap_end_col = right_obj['min_col'] - 1\n        gap_width = gap_end_col - gap_start_col + 1\n\n        if gap_width > 0:\n            # Calculate fill counts (integer division for floor)\n            fill_count = gap_width // 2 \n            \n            # Fill left part of the gap across ALL rows\n            output_grid[:, gap_start_col : gap_start_col + fill_count] = left_obj['color']\n            \n            # Fill right part of the gap across ALL rows\n            # Note: The start index calculation ensures the middle column is skipped if gap_width is odd\n            output_grid[:, gap_end_col - fill_count + 1 : gap_end_col + 1] = right_obj['color']\n            \n            # Successfully filled horizontally, return the result\n            return output_grid \n\n    # Check for Vertical Alignment: BBoxes separated by rows\n    # Determine top and bottom objects first\n    if obj1['min_row'] < obj2['min_row']:\n        top_obj = obj1\n        bottom_obj = obj2\n    else:\n        top_obj = obj2\n        bottom_obj = obj1\n\n    # Check if there's a vertical gap\n    if top_obj['max_row'] < bottom_obj['min_row']:\n        gap_start_row = top_obj['max_row'] + 1\n        gap_end_row = bottom_obj['min_row'] - 1\n        gap_height = gap_end_row - gap_start_row + 1\n\n        if gap_height > 0:\n            # Calculate fill counts using ceiling for top and floor for bottom\n            top_fill_count = (gap_height + 1) // 2 \n            bottom_fill_count = gap_height // 2\n            \n            # Fill top part of the gap across ALL columns\n            output_grid[gap_start_row : gap_start_row + top_fill_count, :] = top_obj['color']\n            \n            # Fill bottom part of the gap across ALL columns\n            output_grid[gap_end_row - bottom_fill_count + 1 : gap_end_row + 1, :] = bottom_obj['color']\n\n            # Successfully filled vertically, return the result\n            return output_grid\n\n    # 5. If no alignment or gap fill condition was met, return the original grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11271,
    "candidates_token_count": 1975,
    "total_token_count": 13246,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.340058
}