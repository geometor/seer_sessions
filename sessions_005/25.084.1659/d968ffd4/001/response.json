{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct rectangular objects within a background color. \nDetermines if the objects are aligned horizontally or vertically with a gap of background color between them.\nFills the gap between the objects, within their overlapping rows/columns, based on proximity.\nIf horizontally aligned, the gap is split roughly in half, with the side closer to an object getting that object's color. If the gap width is odd, the middle column remains background.\nIf vertically aligned, the gap is split, with the top portion (ceiling of half the gap height) getting the top object's color and the bottom portion (floor of half the gap height) getting the bottom object's color.\n\"\"\"\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples),\n              'min_row', 'min_col', 'max_row', 'max_col'.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store found object details\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'min_row': min_r,\n                    'min_col': min_c,\n                    'max_row': max_r,\n                    'max_col': max_c\n                })\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the gap between two aligned objects based on their colors and proximity.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Identify the background color (most frequent color)\n    colors, counts = np.unique(input_grid, return_counts=True)\n    if len(counts) > 0:\n        background_color = colors[np.argmax(counts)]\n    else: # Handle empty grid case, though unlikely per ARC constraints\n        return output_grid \n\n    # 2. Find all contiguous non-background objects\n    objects = _find_objects(output_grid, background_color)\n\n    # 3. Ensure exactly two objects are found\n    if len(objects) != 2:\n        # If not exactly two objects, return the original grid unchanged\n        return output_grid \n\n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # Extract bounding boxes for easier comparison\n    bb1_min_row, bb1_min_col, bb1_max_row, bb1_max_col = obj1['min_row'], obj1['min_col'], obj1['max_row'], obj1['max_col']\n    bb2_min_row, bb2_min_col, bb2_max_row, bb2_max_col = obj2['min_row'], obj2['min_col'], obj2['max_row'], obj2['max_col']\n\n    # 4. Determine alignment (Horizontal or Vertical)\n    \n    # Check for Horizontal Alignment: Overlapping rows, separated columns\n    row_overlap = max(bb1_min_row, bb2_min_row) <= min(bb1_max_row, bb2_max_row)\n    col_separated = bb1_max_col < bb2_min_col or bb2_max_col < bb1_min_col\n    \n    if row_overlap and col_separated:\n        # Identify Left and Right objects\n        if bb1_min_col < bb2_min_col:\n            left_obj = obj1\n            right_obj = obj2\n        else:\n            left_obj = obj2\n            right_obj = obj1\n            \n        # Calculate overlapping rows and gap columns\n        min_overlap_row = max(left_obj['min_row'], right_obj['min_row'])\n        max_overlap_row = min(left_obj['max_row'], right_obj['max_row'])\n        gap_start_col = left_obj['max_col'] + 1\n        gap_end_col = right_obj['min_col'] - 1\n        gap_width = gap_end_col - gap_start_col + 1\n\n        if gap_width > 0:\n            # Calculate fill counts (integer division for floor)\n            fill_count = gap_width // 2 \n            \n            # Fill left part of the gap\n            output_grid[min_overlap_row : max_overlap_row + 1, \n                        gap_start_col : gap_start_col + fill_count] = left_obj['color']\n            \n            # Fill right part of the gap\n            # Note: The start index calculation ensures the middle column is skipped if gap_width is odd\n            output_grid[min_overlap_row : max_overlap_row + 1, \n                        gap_end_col - fill_count + 1 : gap_end_col + 1] = right_obj['color']\n\n    else:\n        # Check for Vertical Alignment: Overlapping columns, separated rows\n        col_overlap = max(bb1_min_col, bb2_min_col) <= min(bb1_max_col, bb2_max_col)\n        row_separated = bb1_max_row < bb2_min_row or bb2_max_row < bb1_min_row\n\n        if col_overlap and row_separated:\n            # Identify Top and Bottom objects\n            if bb1_min_row < bb2_min_row:\n                top_obj = obj1\n                bottom_obj = obj2\n            else:\n                top_obj = obj2\n                bottom_obj = obj1\n\n            # Calculate overlapping columns and gap rows\n            min_overlap_col = max(top_obj['min_col'], bottom_obj['min_col'])\n            max_overlap_col = min(top_obj['max_col'], bottom_obj['max_col'])\n            gap_start_row = top_obj['max_row'] + 1\n            gap_end_row = bottom_obj['min_row'] - 1\n            gap_height = gap_end_row - gap_start_row + 1\n\n            if gap_height > 0:\n                # Calculate fill counts using integer division for ceiling and floor\n                # top_fill_count = ceil(gap_height / 2)\n                # bottom_fill_count = floor(gap_height / 2)\n                top_fill_count = (gap_height + 1) // 2 \n                bottom_fill_count = gap_height // 2\n                \n                # Fill top part of the gap\n                output_grid[gap_start_row : gap_start_row + top_fill_count, \n                            min_overlap_col : max_overlap_col + 1] = top_obj['color']\n                \n                # Fill bottom part of the gap\n                output_grid[gap_end_row - bottom_fill_count + 1 : gap_end_row + 1, \n                            min_overlap_col : max_overlap_col + 1] = bottom_obj['color']\n\n    # 6. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4008,
    "candidates_token_count": 2099,
    "total_token_count": 6107,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.814384
}