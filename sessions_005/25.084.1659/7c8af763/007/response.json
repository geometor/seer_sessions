{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by performing a conditional flood fill on white (0) pixels within contiguous regions bounded by gray (5) pixels. The fill color for each distinct region is determined by the presence and priority of marker pixels (red=2, blue=1) within that region in the input grid. Red markers have higher priority than blue markers. If a region contains only white (0) pixels, it defaults to being filled with blue (1). Gray (5) boundary pixels and original marker pixels (1 and 2) within the regions remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_regions_and_determine_fills(grid):\n    \"\"\"\n    Identifies contiguous regions of non-gray pixels using Breadth-First Search (BFS),\n    determines the fill color for each region based on marker priority, and\n    identifies the coordinates of originally white pixels within each region.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries. Each dictionary represents a region and contains:\n        - 'fill_color': The color (1 or 2) to fill the white pixels in this region.\n        - 'white_coords': A list of (row, col) tuples for pixels that were originally\n                          white (0) in this region.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions_data = []\n    gray_color = 5\n    white_color = 0\n    blue_color = 1\n    red_color = 2\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start a BFS if the pixel is not gray and not yet visited\n            if grid[r, c] != gray_color and not visited[r, c]:\n                current_region_white_coords = []\n                markers_present = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Process the starting pixel itself\n                pixel_value = grid[r, c]\n                if pixel_value == white_color:\n                    current_region_white_coords.append((r, c))\n                elif pixel_value == blue_color or pixel_value == red_color:\n                    markers_present.add(pixel_value)\n\n                # Perform BFS to find all connected pixels in the region\n                while q:\n                    row, col = q.popleft()\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds and if neighbor is valid for the region\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != gray_color and not visited[nr, nc]:\n                            \n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                            # Check the color of the neighbor to update region info\n                            neighbor_value = grid[nr, nc]\n                            if neighbor_value == white_color:\n                                current_region_white_coords.append((nr, nc))\n                            elif neighbor_value == blue_color or neighbor_value == red_color:\n                                markers_present.add(neighbor_value)\n                \n                # After exploring the whole region, determine the fill color\n                if red_color in markers_present:\n                    fill_color = red_color # Red priority\n                elif blue_color in markers_present:\n                    fill_color = blue_color # Blue secondary\n                else:\n                    # Default case: If region contains only white (0), fill with blue.\n                    fill_color = blue_color\n\n                # Store the results for this region\n                if current_region_white_coords: # Only store if there's something to fill\n                     regions_data.append({\n                        'fill_color': fill_color,\n                        'white_coords': current_region_white_coords\n                     })\n                     \n    return regions_data\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional flood fill transformation based on marker priorities\n    within regions, filling only originally white pixels.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid.\n    # Gray pixels and original marker pixels will remain unchanged by default.\n    output_grid = np.copy(input_grid)\n    \n    # Step 1: Identify all distinct contiguous regions of non-gray pixels,\n    # determine the fill color for each based on markers, and find coordinates\n    # of white pixels within each region.\n    regions_fill_info = find_regions_and_determine_fills(input_grid)\n\n    # Step 2: Apply the determined fill color to the originally white pixels\n    # within each region in the output grid.\n    for region_info in regions_fill_info:\n        fill_color = region_info['fill_color']\n        white_coords = region_info['white_coords']\n        \n        for r, c in white_coords:\n            output_grid[r, c] = fill_color\n\n    # Step 3: Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9168,
    "candidates_token_count": 1241,
    "total_token_count": 10409,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.627774
}