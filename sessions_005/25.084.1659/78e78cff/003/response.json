{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nPerforms a bounded flood fill operation on a 2D grid. It identifies three key colors: \na background color (most frequent), a seed color (unique occurrence), and a boundary \ncolor (the third distinct color). Starting from the seed pixel's location, it fills \nconnected background pixels with the seed color using a Breadth-First Search (BFS). \nThe fill expansion stops at pixels with the boundary color and the grid edges. \nPixels with the boundary color and background pixels outside the filled area remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter, deque\n\ndef _find_colors(input_grid):\n    \"\"\"\n    Identifies background, seed, and boundary colors and seed location.\n\n    Args:\n        input_grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, seed_color, seed_loc, boundary_color)\n               Returns None for any value if identification fails based on assumptions.\n    \n    Raises:\n        ValueError: If the assumptions about color counts (most frequent, unique, third) are not met.\n    \"\"\"\n    color_counts = Counter(input_grid.flatten())\n    \n    if len(color_counts) < 3:\n         raise ValueError(f\"Expected at least 3 distinct colors, found {len(color_counts)}.\")\n\n    # Find background color (most frequent)\n    background_color = color_counts.most_common(1)[0][0]\n\n    # Find seed color and location (appears exactly once)\n    seed_color = -1\n    seed_loc = None\n    unique_colors = [color for color, count in color_counts.items() if count == 1]\n\n    if len(unique_colors) == 1:\n        seed_color = unique_colors[0]\n        seed_indices = np.where(input_grid == seed_color)\n        # Ensure it's truly unique location-wise as well\n        if len(seed_indices[0]) == 1: \n             seed_loc = (seed_indices[0][0], seed_indices[1][0])\n        else:\n             # Should not happen if count is 1, but safety check\n             raise ValueError(\"Seed color found in multiple locations despite unique count.\")\n    else:\n        # If no unique color, the core assumption is violated.\n        # Adding a check based on the previous error analysis for potential 3-color scenarios without a unique seed.\n        # However, the primary logic relies on a unique seed. Let's stick to that based on the prompt's goal.\n        raise ValueError(f\"Expected exactly one unique color (seed), found {len(unique_colors)}.\")\n\n\n    # Find boundary color (the one that's not background or seed)\n    boundary_color = -1\n    remaining_colors = set(color_counts.keys()) - {background_color, seed_color}\n    if len(remaining_colors) == 1:\n         boundary_color = list(remaining_colors)[0]\n    else:\n        # This implies more than 3 colors or an issue with previous identification\n        raise ValueError(f\"Expected exactly one boundary color, found {len(remaining_colors)} remaining colors.\")\n\n    if boundary_color == -1:\n         raise ValueError(\"Could not identify a distinct boundary color.\")\n         \n    return background_color, seed_color, seed_loc, boundary_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a bounded flood fill transformation to the input grid.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    \n    # Get grid dimensions\n    height, width = input_grid.shape\n\n    # --- 1. Identify Colors ---\n    try:\n        background_color, seed_color, seed_loc, boundary_color = _find_colors(input_grid)\n    except ValueError as e:\n        print(f\"Color identification failed: {e}\")\n        # Return input grid or handle error as appropriate for the context\n        # For ARC, returning the input might be a safe fallback if assumptions fail.\n        return np.copy(input_grid) \n        \n    # --- 2. Create Output Grid ---\n    output_grid = np.copy(input_grid)\n    \n    # --- 3. Initialize BFS ---\n    queue = deque([seed_loc])\n    \n    # --- 4. Initialize Visited Set ---\n    visited = set()\n    visited.add(seed_loc) # Add seed location initially\n\n    # --- 5. Perform Bounded Flood Fill (BFS) ---\n    while queue:\n        r, c = queue.popleft()\n        \n        # Check the color in the *original* input grid\n        current_input_color = input_grid[r, c]\n\n        # --- 5a. Check if current pixel should be filled ---\n        # Fill if it's the background color OR the starting seed pixel\n        if current_input_color == background_color or (r, c) == seed_loc:\n            \n            # --- 5b. Color the pixel in the output grid ---\n            output_grid[r, c] = seed_color\n\n            # --- 5c. Explore neighbors ---\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Cardinal directions\n                nr, nc = r + dr, c + dc\n                neighbor_loc = (nr, nc)\n\n                # --- 5d. Check neighbor validity ---\n                # Check bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check not visited\n                    if neighbor_loc not in visited:\n                        # Check neighbor is not a boundary pixel in the *input* grid\n                        if input_grid[nr, nc] != boundary_color:\n                            # --- 5e. Add valid neighbor to queue and visited set ---\n                            visited.add(neighbor_loc)\n                            queue.append(neighbor_loc)\n                            \n        # If the current pixel (r, c) was originally a boundary pixel or something else,\n        # we do not color it (it retains its original color in the output_grid copy) \n        # and we do not explore its neighbors from here. This prevents the fill\n        # from \"jumping\" over boundaries.\n\n    # --- 6. Return the modified output grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5739,
    "candidates_token_count": 1485,
    "total_token_count": 7224,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.157457
}