{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies three key colors: a background color (most frequent), a seed color (unique occurrence), and a boundary color (the third distinct color). \nPerforms a bounded flood fill operation on a 2D grid starting from the seed pixel's location. \nIt identifies the region of background pixels enclosed by the boundary color that contains the seed. \nThis is done by finding background pixels reachable from the seed and subtracting background pixels reachable from the grid borders (without crossing the boundary color).\nFinally, it fills the identified enclosed background pixels and the original seed pixel location with the seed color. \nPixels with the boundary color and background pixels outside the filled area remain unchanged.\n\"\"\"\n\ndef _find_colors(input_grid):\n    \"\"\"\n    Identifies background, seed, and boundary colors and seed location based on frequency and uniqueness.\n\n    Args:\n        input_grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, seed_color, seed_loc, boundary_color)\n               Returns None for any value if identification fails based on assumptions.\n    \n    Raises:\n        ValueError: If the assumptions about color counts (most frequent, unique, exactly 3 distinct) are not met.\n    \"\"\"\n    color_counts = Counter(input_grid.flatten())\n    \n    if len(color_counts) != 3:\n         raise ValueError(f\"Expected exactly 3 distinct colors, found {len(color_counts)}.\")\n\n    # Find background color (most frequent)\n    background_color = color_counts.most_common(1)[0][0]\n\n    # Find seed color and location (appears exactly once)\n    seed_color = -1\n    seed_loc = None\n    unique_colors = [color for color, count in color_counts.items() if count == 1]\n\n    if len(unique_colors) == 1:\n        seed_color = unique_colors[0]\n        seed_indices = np.where(input_grid == seed_color)\n        # Ensure it's truly unique location-wise as well\n        if len(seed_indices[0]) == 1: \n             seed_loc = (seed_indices[0][0], seed_indices[1][0])\n        else:\n             # Should not happen if count is 1, but safety check\n             raise ValueError(\"Seed color found in multiple locations despite unique count.\")\n    else:\n        raise ValueError(f\"Expected exactly one unique color (seed), found {len(unique_colors)}.\")\n\n\n    # Find boundary color (the one that's not background or seed)\n    boundary_color = -1\n    remaining_colors = set(color_counts.keys()) - {background_color, seed_color}\n    # Since we checked for exactly 3 colors, there must be exactly one remaining\n    boundary_color = list(remaining_colors)[0]\n         \n    return background_color, seed_color, seed_loc, boundary_color\n\ndef _flood_fill_reachable(grid, start_coords, allowed_color, boundary_color):\n    \"\"\"\n    Performs a flood fill to find all reachable coordinates with the allowed_color,\n    starting from start_coords, without crossing boundary_color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_coords (iterable): An iterable of (row, col) tuples to start the fill from.\n        allowed_color (int): The color of pixels that can be visited and included.\n        boundary_color (int): The color of pixels that block the fill.\n\n    Returns:\n        set: A set of (row, col) tuples representing the reachable coordinates\n             (including starting coordinates if they match allowed_color).\n    \"\"\"\n    height, width = grid.shape\n    queue = deque()\n    visited = set()\n\n    # Initialize queue and visited set with valid starting points\n    for r, c in start_coords:\n        if 0 <= r < height and 0 <= c < width and (r, c) not in visited:\n             # Check if the start coordinate itself is valid (is allowed color)\n             # This is important if a start_coord happens to be a boundary or other color\n             if grid[r,c] == allowed_color:\n                 visited.add((r, c))\n                 queue.append((r, c))\n             # Also add the start coord if it *is* the initial seed position, even if not background.\n             # This check is implicitly handled later, focusing here only on allowed_color spread.\n\n    while queue:\n        r, c = queue.popleft()\n\n        # Explore neighbors (cardinal directions)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_loc = (nr, nc)\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check not visited\n                if neighbor_loc not in visited:\n                    # Check neighbor has the allowed color (is not boundary or other)\n                    if grid[nr, nc] == allowed_color:\n                        visited.add(neighbor_loc)\n                        queue.append(neighbor_loc)\n                        \n    return visited\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a bounded flood fill transformation to the input grid. It identifies \n    a background, a unique seed, and a boundary color. It then fills the area \n    of background pixels enclosed by the boundary and containing the seed, using \n    the seed color.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    \n    height, width = input_grid.shape\n\n    # --- 1. Identify Colors ---\n    try:\n        background_color, seed_color, seed_loc, boundary_color = _find_colors(input_grid)\n    except ValueError as e:\n        print(f\"Color identification failed: {e}\")\n        # Return input grid as fallback if assumptions about colors fail\n        return np.copy(input_grid) \n        \n    # --- 2. Initialize Output Grid ---\n    output_grid = np.copy(input_grid)\n    \n    # --- 3. Find Background Pixels Reachable from Seed ---\n    # Note: The _flood_fill_reachable expects start_coords to be iterable\n    # The seed_loc itself might not be background_color, but the fill explores neighbors from it.\n    # We only care about the background pixels reachable *around* the seed.\n    reachable_from_seed = _flood_fill_reachable(input_grid, [seed_loc], background_color, boundary_color)\n\n    # --- 4. Find Background Pixels Reachable from Borders ---\n    border_seeds = set()\n    # Top and bottom rows\n    for c in range(width):\n        if input_grid[0, c] == background_color:\n            border_seeds.add((0, c))\n        if input_grid[height - 1, c] == background_color:\n            border_seeds.add((height - 1, c))\n    # Left and right columns (excluding corners already checked)\n    for r in range(1, height - 1):\n        if input_grid[r, 0] == background_color:\n            border_seeds.add((r, 0))\n        if input_grid[r, width - 1] == background_color:\n            border_seeds.add((r, width - 1))\n            \n    reachable_from_border = _flood_fill_reachable(input_grid, list(border_seeds), background_color, boundary_color)\n\n    # --- 5. Determine Enclosed Background Pixels ---\n    # These are pixels reachable from the seed BUT NOT reachable from the border.\n    enclosed_background_coords = reachable_from_seed - reachable_from_border\n\n    # --- 6. Fill the Enclosed Area and the Seed Location ---\n    # Fill the background pixels determined to be inside the enclosure\n    for r, c in enclosed_background_coords:\n        output_grid[r, c] = seed_color\n        \n    # Ensure the original seed location is also filled with the seed color\n    # (This handles cases where the seed might be on an already-filled spot,\n    # or if the seed itself wasn't background color initially)\n    if seed_loc: # Check if seed_loc was successfully found\n         output_grid[seed_loc] = seed_color\n\n    # --- 7. Return the modified output grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10295,
    "candidates_token_count": 1997,
    "total_token_count": 12292,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.779075
}