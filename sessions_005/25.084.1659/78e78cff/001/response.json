{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies three distinct colors in the input grid: a background color (most frequent), \na seed color (unique occurrence), and a boundary color. Performs a flood fill starting \nfrom the seed pixel's location, replacing the background color with the seed color. \nThe fill is bounded by pixels of the boundary color and the grid edges. Pixels with \nthe boundary color and pixels outside the fill area remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter, deque\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a bounded flood fill transformation to the input grid.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    \n    # Get grid dimensions\n    height, width = input_grid.shape\n\n    # --- Identify Colors ---\n    \n    # Count occurrences of each color\n    color_counts = Counter(input_grid.flatten())\n    \n    # Find the background color (most frequent)\n    background_color = color_counts.most_common(1)[0][0]\n    \n    # Find the seed color and location (appears only once)\n    seed_color = -1\n    seed_loc = None\n    unique_colors = [color for color, count in color_counts.items() if count == 1]\n    \n    # There should be exactly one unique color which is the seed\n    if len(unique_colors) == 1:\n        seed_color = unique_colors[0]\n        # Find its location\n        seed_indices = np.where(input_grid == seed_color)\n        if len(seed_indices[0]) == 1: # Should always be true if count is 1\n             seed_loc = (seed_indices[0][0], seed_indices[1][0])\n        else:\n             # This case shouldn't happen based on the logic but added for robustness\n             raise ValueError(\"Seed color found multiple times despite unique count.\")\n    else:\n        # Handle cases where assumption of one unique color fails\n        # Could try other heuristics, but based on examples, this holds.\n        # For now, raise an error if the assumption doesn't fit.\n        # A possible fallback: check if there's a color surrounded by background? \n        # Or check if exactly 3 colors exist and pick the one not most frequent?\n        # Trying the 3-color heuristic:\n        if len(color_counts) == 3:\n            all_colors = set(color_counts.keys())\n            possible_boundary = list(all_colors - {background_color})\n            # Often the boundary color count > seed color count. \n            # Assuming seed is the least frequent non-background.\n            counts_sorted = sorted([(count, color) for color, count in color_counts.items()])\n            if counts_sorted[0][0] == 1: # If the least frequent has count 1, it's the seed.\n                 seed_color = counts_sorted[0][1]\n                 seed_indices = np.where(input_grid == seed_color)\n                 seed_loc = (seed_indices[0][0], seed_indices[1][0])\n            else:\n                # If no unique color, maybe the single pixel is the same as boundary? Unlikely in ARC.\n                # Or maybe the 'seed' point is actually the boundary color? Example 1 contradicts this.\n                # Fallback needed or rethink assumptions if this path is hit.\n                # For now, stick to the unique color assumption seems safest based on examples.\n                raise ValueError(\"Could not definitively identify a unique seed color.\")\n        else:\n             raise ValueError(f\"Expected 3 distinct colors or 1 unique seed color, found {len(color_counts)}.\")\n\n\n    # Find the boundary color (the one that's not background or seed)\n    boundary_color = -1\n    for color in color_counts.keys():\n        if color != background_color and color != seed_color:\n            boundary_color = color\n            break\n            \n    if boundary_color == -1:\n        # This might happen if there are only 2 colors (e.g., background and seed, no boundary)\n        # Or if the logic above failed. Handle or raise error.\n        # Based on examples, 3 colors are present.\n         raise ValueError(\"Could not identify a distinct boundary color.\")\n\n    # --- Perform Flood Fill ---\n    \n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Queue for BFS flood fill, starting with the seed location\n    queue = deque([seed_loc])\n    \n    # Set to keep track of visited cells to avoid cycles and redundant work\n    visited = set()\n    visited.add(seed_loc) # Add seed location initially\n\n    # Perform the fill\n    while queue:\n        r, c = queue.popleft()\n        \n        # The seed location itself should adopt the seed color (it already does, but conceptually important)\n        # Change background pixels connected to the seed to the seed color\n        if input_grid[r, c] == background_color or (r,c) == seed_loc:\n             output_grid[r, c] = seed_color\n\n        # Explore neighbors (cardinal directions: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbor_loc = (nr, nc)\n                \n                # Check if already visited\n                if neighbor_loc in visited:\n                    continue\n                    \n                # Check if neighbor is a boundary pixel (stop condition)\n                if input_grid[nr, nc] == boundary_color:\n                    continue # Don't add boundary pixels to queue, don't visit them\n                    \n                # If the neighbor is valid (within bounds, not boundary, not visited),\n                # add it to visited set and the queue for processing.\n                visited.add(neighbor_loc)\n                queue.append(neighbor_loc)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3062,
    "candidates_token_count": 1451,
    "total_token_count": 4513,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.851877
}