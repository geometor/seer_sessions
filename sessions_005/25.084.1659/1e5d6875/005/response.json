{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by changing the color of specific orange (7) objects based on adjacent colors, ignoring the single largest orange object (considered background).\n\n1. Find all distinct contiguous objects composed of orange (7) pixels.\n2. Identify the orange object with the largest number of pixels (the background).\n3. For all *other* orange objects (non-background):\n    a. Check if any pixel within the object is adjacent (8-way, including diagonals) to a red (2) pixel located *outside* the object. If yes, the entire object is marked to turn green (3).\n    b. If not adjacent to red, check if any pixel within the object is adjacent (8-way) to a gray (5) pixel located *outside* the object. If yes, the entire object is marked to turn yellow (4).\n    c. If adjacent to neither red nor gray, the object remains orange (7).\n4. Apply the determined color changes to the output grid. The largest orange object and all non-orange pixels remain unchanged.\n\"\"\"\n\ndef _find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a list of coordinates \n              [(r1, c1), (r2, c2), ...] representing the pixels of the object. Returns empty list if none found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                current_object_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n                            \n                            # Check if neighbor is within bounds, is the correct color, and hasn't been visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                # Add the found object (list of coordinates) to the list of objects\n                if current_object_coords:\n                    objects.append(current_object_coords)\n                \n    return objects\n\ndef _check_object_neighbors_refined(grid, object_coords):\n    \"\"\"\n    Checks if any pixel within the object is adjacent to a red(2) or gray(5) pixel outside the object.\n    Prioritizes red.\n\n    Args:\n        grid (np.array): The input grid.\n        object_coords (list): A list of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (is_near_red, is_near_gray) - booleans indicating adjacency.\n               If is_near_red is True, is_near_gray will be False due to priority.\n    \"\"\"\n    height, width = grid.shape\n    object_coords_set = set(object_coords) # For efficient lookup\n    is_near_red = False\n    is_near_gray = False\n\n    for r, c in object_coords:\n        # Check 8 neighbors of the current pixel (r, c)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n                \n                # Check if neighbor is within grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if the neighbor is *outside* the object itself\n                    if (nr, nc) not in object_coords_set: \n                        neighbor_color = grid[nr, nc]\n                        if neighbor_color == 2: # red\n                            # Found a red neighbor, red has priority, no need to check further.\n                            return True, False \n                        elif neighbor_color == 5: # gray\n                            # Found a gray neighbor, note it but continue checking\n                            # in case a red neighbor is found later for this object.\n                            is_near_gray = True\n                            \n    # If the loop completes without finding any red neighbors\n    return False, is_near_gray\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color transformation based on object adjacency, ignoring the largest orange object.\n\n    Args:\n        input_grid (list of lists or np.array): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_np)\n\n    # Find all orange objects\n    orange_objects = _find_objects(input_np, 7) # 7 is orange\n\n    # If no orange objects, return the copy\n    if not orange_objects:\n        return output_grid.tolist()\n\n    # Find the largest orange object (by number of pixels)\n    largest_object_index = -1\n    max_size = -1\n    if len(orange_objects) > 0:\n         sizes = [len(obj) for obj in orange_objects]\n         max_size = max(sizes)\n         # Find the index of the first object with the maximum size\n         largest_object_index = sizes.index(max_size) \n         \n         # Handle potential ties: if multiple objects have the same max size,\n         # the problem description implies a single \"background\". We assume\n         # the first one found is sufficient, or that ties won't occur in test cases,\n         # or that the specific tie-breaking rule doesn't matter if they all behave like background.\n         # For now, we just exclude the first one found with max size.\n\n\n    # Iterate through each found orange object\n    for i, obj_coords in enumerate(orange_objects):\n        # Skip the largest object (the background)\n        if i == largest_object_index:\n            continue\n\n        # Check the neighbors of the current (non-background) object\n        is_near_red, is_near_gray = _check_object_neighbors_refined(input_np, obj_coords)\n\n        # Determine the target color based on neighbors\n        target_color = 7 # Default to orange (no change)\n        if is_near_red:\n            target_color = 3 # Green if near red\n        elif is_near_gray:\n            target_color = 4 # Yellow if near gray (and not near red)\n\n        # If the target color is different from orange, update the output grid\n        if target_color != 7:\n            for r, c in obj_coords:\n                output_grid[r, c] = target_color\n\n    # Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16991,
    "candidates_token_count": 1794,
    "total_token_count": 18785,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.920157
}