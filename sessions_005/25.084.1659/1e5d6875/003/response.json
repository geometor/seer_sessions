{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on the proximity of contiguous orange (7) objects to red (2) and gray (5) pixels.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Find all contiguous objects composed of orange (7) pixels in the input grid.\n3. For each distinct orange object found:\n    a. Check all pixels adjacent (including diagonals) to any pixel belonging to the current orange object.\n    b. Determine if any of these adjacent pixels (that are not part of the object itself) are red (2). Let this be `object_near_red`.\n    c. Determine if any of these adjacent pixels (that are not part of the object itself) are gray (5). Let this be `object_near_gray`.\n    d. If `object_near_red` is true, change the color of *all* pixels constituting this orange object in the output grid to green (3).\n    e. Else if `object_near_gray` is true (and `object_near_red` is false), change the color of *all* pixels constituting this orange object in the output grid to yellow (4).\n    f. Otherwise (the orange object is not adjacent to any red or gray pixels), the pixels of the object remain orange (7) in the output grid.\n4. Pixels that were not part of any orange object remain unchanged.\n5. Return the final output grid.\n\"\"\"\n\ndef _find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a list of coordinates \n              [(r1, c1), (r2, c2), ...] representing the pixels of the object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) to find the connected object\n                current_object_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft() # Use popleft for BFS\n                    current_object_coords.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n                            \n                            # Check if neighbor is within bounds, is the correct color, and hasn't been visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                # Add the found object (list of coordinates) to the list of objects\n                if current_object_coords:\n                    objects.append(current_object_coords)\n                \n    return objects\n\ndef _check_object_neighbors(grid, object_coords):\n    \"\"\"\n    Checks the neighbors surrounding an entire object for red (2) and gray (5) pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        object_coords (list): A list of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (is_near_red, is_near_gray) - booleans indicating presence of neighbors.\n               Priority is given to red. If red is found, is_near_gray is returned as False.\n    \"\"\"\n    height, width = grid.shape\n    is_near_red = False\n    is_near_gray = False\n    \n    # Use a set for efficient checking if a neighbor is part of the object itself\n    object_coords_set = set(object_coords) \n    \n    # Check for red neighbors first due to priority rule\n    for r, c in object_coords:\n        # Check 8 neighbors of this pixel\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n                \n                # Check if neighbor is within grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if the neighbor is *outside* the object itself\n                    if (nr, nc) not in object_coords_set: \n                        neighbor_color = grid[nr, nc]\n                        if neighbor_color == 2: # red\n                            is_near_red = True\n                            # Found red, no need to check further for red or gray\n                            return True, False \n                            \n    # If no red neighbors were found, check for gray neighbors\n    for r, c in object_coords:\n        # Check 8 neighbors of this pixel\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                    \n                nr, nc = r + dr, c + dc\n                \n                # Check if neighbor is within grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if the neighbor is *outside* the object itself\n                    if (nr, nc) not in object_coords_set: \n                        neighbor_color = grid[nr, nc]\n                        if neighbor_color == 5: # gray\n                            is_near_gray = True\n                            # Found gray, no need to check further for gray\n                            return False, True \n                            \n    # If neither red nor gray neighbors were found\n    return False, False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color transformation based on object neighbor proximity.\n\n    Args:\n        input_grid (list of lists or np.array): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_np)\n\n    # Find all orange objects\n    orange_objects = _find_objects(input_np, 7) # 7 is orange\n\n    # Iterate through each found orange object\n    for obj_coords in orange_objects:\n        # Check the neighbors of the current object\n        is_near_red, is_near_gray = _check_object_neighbors(input_np, obj_coords)\n\n        # Determine the target color based on neighbors\n        target_color = 7 # Default to orange (no change)\n        if is_near_red:\n            target_color = 3 # Green if near red\n        elif is_near_gray:\n            target_color = 4 # Yellow if near gray (and not near red)\n\n        # If the target color is different from orange, update the output grid\n        if target_color != 7:\n            for r, c in obj_coords:\n                output_grid[r, c] = target_color\n\n    # Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2986,
    "candidates_token_count": 1806,
    "total_token_count": 4792,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.116875
}