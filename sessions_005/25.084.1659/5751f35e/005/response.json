{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport heapq\n\n\"\"\"\nFill specific white pixels based on a propagation method from non-white pixels using Manhattan distance, with a lowest-index tie-breaker.\n\nRule:\n1. Check if the input grid has a complete, connected, single-pixel-wide border consisting only of white (0) pixels.\n2. Identify the white pixels to be filled ('target pixels'):\n    - If a complete white border exists, targets are all white pixels NOT on this border.\n    - Otherwise, targets are ALL white pixels.\n3. Simulate a simultaneous propagation outwards from all non-white pixels:\n    a. Initialize a 'distance' grid with 0 for non-white pixels and infinity for white pixels.\n    b. Initialize a 'source_color' grid, initially copying the input grid (non-white pixels hold their color, white pixels hold 0 or another placeholder).\n    c. Use a priority queue (min-heap) storing tuples of (distance, row, col, color) initialized with all non-white pixels (distance 0).\n    d. While the priority queue is not empty:\n        i. Extract the pixel (r, c) with the smallest distance `d` and its source `color`.\n        ii. If `d` is greater than the already recorded distance for (r, c) in the distance grid, skip (we've found a shorter path already).\n        iii. For each Manhattan neighbor (nr, nc) of (r, c):\n            - Calculate the new distance `new_dist = d + 1`.\n            - If `new_dist` is less than the current distance recorded for (nr, nc):\n                - Update distance grid at (nr, nc) to `new_dist`.\n                - Update source_color grid at (nr, nc) to `color`.\n                - Add (`new_dist`, nr, nc, `color`) to the priority queue.\n            - Else if `new_dist` is equal to the current distance recorded for (nr, nc):\n                - Update the source_color grid at (nr, nc) to `min(current_source_color[nr, nc], color)`.\n                # No need to re-add to queue, as distance hasn't improved, just potentially tie-breaking.\n4. Fill the target white pixels in the output grid:\n    a. Create the output grid as a copy of the input.\n    b. For each coordinate (r, c) identified as a target pixel in step 2:\n        - Get the final color from the `source_color` grid at (r, c) determined by the propagation.\n        - Set the `output_grid[r, c]` to this color.\n5. Non-target white pixels and original non-white pixels retain their original color in the output grid.\n\"\"\"\n\ndef _has_complete_white_border(grid: np.ndarray) -> bool:\n    \"\"\"Checks if the grid has a complete, connected, single-pixel white border.\"\"\"\n    height, width = grid.shape\n    if height <= 1 or width <= 1: # Cannot have a complete border\n        return False\n\n    # Check top and bottom rows\n    for c in range(width):\n        if grid[0, c] != 0: return False\n        if grid[height - 1, c] != 0: return False\n    # Check left and right columns (excluding corners already checked)\n    for r in range(1, height - 1):\n        if grid[r, 0] != 0: return False\n        if grid[r, width - 1] != 0: return False\n\n    return True # If we passed all checks\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the propagation-based filling rule with border preservation\n    and lowest-index tie-breaking.\n    \"\"\"\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Check for complete white border\n    has_border = _has_complete_white_border(input_grid)\n\n    # 2. Identify target white pixels\n    target_coords = []\n    border_pixel_locations = set()\n    if has_border:\n        # Define border coordinates only if a border exists\n        for c in range(width):\n            border_pixel_locations.add((0, c))\n            border_pixel_locations.add((height - 1, c))\n        for r in range(1, height - 1):\n            border_pixel_locations.add((r, 0))\n            border_pixel_locations.add((r, width - 1))\n\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] == 0:\n                is_on_border = (r,c) in border_pixel_locations\n                # Target if (no border exists) OR (border exists AND pixel is not on border)\n                if not has_border or not is_on_border:\n                    target_coords.append((r, c))\n\n    # If there are no white pixels to target, return the original grid\n    if not target_coords:\n        return output_grid\n\n    # 3. Simulate propagation using Dijkstra's algorithm / BFS with priority queue\n    distance_grid = np.full((height, width), float('inf'))\n    source_color_grid = np.zeros_like(input_grid) # Store the winning color index\n    pq = [] # Min-heap: (distance, row, col, color_index)\n\n    # Initialize queue and grids with non-white pixels\n    non_white_coords = np.argwhere(input_grid != 0)\n    if non_white_coords.size == 0:\n        # No non-white pixels, no filling can occur\n        return output_grid\n\n    for r, c in non_white_coords:\n        color = input_grid[r, c]\n        distance_grid[r, c] = 0\n        source_color_grid[r, c] = color\n        heapq.heappush(pq, (0, r, c, color))\n\n    # Run the propagation\n    while pq:\n        dist, r, c, color = heapq.heappop(pq)\n\n        # If we found a shorter path already, skip\n        if dist > distance_grid[r, c]:\n            continue\n        # If distance is same, but color is higher, skip (already processed with lower/equal color index)\n        # Note: This check is implicitly handled by the update logic below,\n        # but explicitly checking source_color_grid[r,c] here could optimize slightly.\n        # if dist == distance_grid[r, c] and color > source_color_grid[r, c]:\n        #     continue\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_dist = dist + 1\n                current_neighbor_dist = distance_grid[nr, nc]\n\n                # Found a shorter path to the neighbor\n                if new_dist < current_neighbor_dist:\n                    distance_grid[nr, nc] = new_dist\n                    source_color_grid[nr, nc] = color\n                    heapq.heappush(pq, (new_dist, nr, nc, color))\n                # Found a path of the same length - apply tie-breaking\n                elif new_dist == current_neighbor_dist:\n                    # Update color only if the new color index is lower\n                    if color < source_color_grid[nr, nc]:\n                        source_color_grid[nr, nc] = color\n                        # Re-push with the same distance but lower color index\n                        # Ensures processing favors lower color index if distances are equal\n                        # Note: Technically Dijkstra doesn't require re-pushing on equal dist,\n                        # but we need to ensure the lowest color propagates correctly in ties.\n                        # An alternative is to only update source_color_grid here,\n                        # and the final color will be correct when the target pixel is processed.\n                        # Let's stick to just updating the source_color_grid for simplicity.\n                        # heapq.heappush(pq, (new_dist, nr, nc, color)) # Avoid re-pushing\n\n    # 4. Fill the target white pixels in the output grid\n    for r, c in target_coords:\n        # Only fill if the pixel was reached by the propagation\n        if distance_grid[r, c] != float('inf'):\n             output_grid[r, c] = source_color_grid[r, c]\n        # Else: it remains white (0) as initialized in the copy\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15353,
    "candidates_token_count": 2032,
    "total_token_count": 17385,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.371763
}