{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nFill specific white pixels based on nearest non-white pixels using Manhattan distance.\n\nRule:\n1. Check if the input grid has a complete, connected, single-pixel-wide border consisting only of white (0) pixels.\n2. Identify the white pixels to be filled ('target pixels'):\n    - If a complete white border exists, targets are all white pixels NOT on this border.\n    - Otherwise, targets are ALL white pixels.\n3. For each target white pixel:\n    a. Find all non-white pixels in the original input grid.\n    b. Calculate the Manhattan distance from the target pixel to all non-white pixels.\n    c. Identify the minimum distance found.\n    d. Collect the colors of all non-white pixels that are at this minimum distance.\n    e. Apply tie-breaking to determine the fill color:\n        i. If green (3) is among the tied colors, the fill color is green (3).\n        ii. Else, count the occurrences of each tied color. If one color has a strictly higher count, use that color.\n        iii. Else (counts are tied, or only one nearest pixel), use the color with the lowest numerical index among the tied colors.\n    f. Set the target white pixel's color in the output grid to the determined fill color.\n4. Non-target white pixels and original non-white pixels retain their color.\n\"\"\"\n\ndef _has_complete_white_border(grid: np.ndarray) -> bool:\n    \"\"\"Checks if the grid has a complete, connected, single-pixel white border.\"\"\"\n    height, width = grid.shape\n    if height <= 1 or width <= 1: # Cannot have a complete border\n        return False\n\n    border_coords = set()\n    # Check top and bottom rows\n    for c in range(width):\n        if grid[0, c] != 0: return False\n        border_coords.add((0, c))\n        if grid[height - 1, c] != 0: return False\n        border_coords.add((height - 1, c))\n    # Check left and right columns (excluding corners already checked)\n    for r in range(1, height - 1):\n        if grid[r, 0] != 0: return False\n        border_coords.add((r, 0))\n        if grid[r, width - 1] != 0: return False\n        border_coords.add((r, width - 1))\n\n    # Verify connectivity (optional but good for robustness, assuming border pixels are correct)\n    # Simple check: are all expected border pixels white? Already done above.\n    # A full connectivity check (BFS/DFS) could be added if needed, but\n    # the initial checks cover the \"all white\" and \"single-pixel-wide\" aspects implicitly.\n    # If any non-white pixel exists on the border, the first checks return False.\n    return True # If we passed all checks\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the nearest non-white pixel filling rule with border preservation\n    and complex tie-breaking to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Check for complete white border\n    has_border = _has_complete_white_border(input_grid)\n\n    # 2. Identify target white pixels\n    target_coords = []\n    border_pixel_locations = set()\n    if has_border:\n        for c in range(width):\n            border_pixel_locations.add((0, c))\n            border_pixel_locations.add((height - 1, c))\n        for r in range(1, height - 1):\n            border_pixel_locations.add((r, 0))\n            border_pixel_locations.add((r, width - 1))\n\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] == 0:\n                is_on_border = (r,c) in border_pixel_locations\n                if has_border and is_on_border:\n                    continue # Skip border white pixels if a complete border exists\n                else:\n                    target_coords.append((r, c)) # Target all others\n\n    # 4. Find coordinates and colors of non-white pixels\n    non_white_pixels = []\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] != 0:\n                non_white_pixels.append(((r, c), input_grid[r, c]))\n\n    # If there are no non-white pixels, no filling can occur\n    if not non_white_pixels:\n        return output_grid\n\n    # 5. Process each target white pixel\n    for r_white, c_white in target_coords:\n        min_distance = float('inf')\n        nearest_pixels_info = [] # Stores (distance, color)\n\n        # 5a-c. Calculate distances and find minimum\n        for (r_non_white, c_non_white), color in non_white_pixels:\n            distance = abs(r_white - r_non_white) + abs(c_white - c_non_white)\n            if distance < min_distance:\n                min_distance = distance\n                nearest_pixels_info = [(distance, color)]\n            elif distance == min_distance:\n                nearest_pixels_info.append((distance, color))\n\n        # 5d. Collect tied colors\n        tied_colors = [info[1] for info in nearest_pixels_info]\n\n        # 5e. Apply tie-breaking rules\n        final_color = 0 # Should always be replaced if non_white_pixels exist\n        if not tied_colors: # Should not happen if non_white_pixels exist\n             continue\n\n        if 3 in tied_colors: # i. Green wins\n            final_color = 3\n        else:\n            if len(tied_colors) == 1:\n                 final_color = tied_colors[0] # No tie\n            else:\n                 # ii. Check counts\n                 color_counts = Counter(tied_colors)\n                 max_count = 0\n                 max_freq_colors = []\n                 for color, count in color_counts.items():\n                     if count > max_count:\n                         max_count = count\n                         max_freq_colors = [color]\n                     elif count == max_count:\n                         max_freq_colors.append(color)\n\n                 if len(max_freq_colors) == 1:\n                     final_color = max_freq_colors[0] # One color had max frequency\n                 else:\n                     # iii. Tie in counts, use lowest index\n                     final_color = min(max_freq_colors)\n\n        # 5f. Update the output grid\n        output_grid[r_white, c_white] = final_color\n\n    # 6. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11356,
    "candidates_token_count": 1640,
    "total_token_count": 12996,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.732743
}