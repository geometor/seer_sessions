{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransformation Rule:\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Identify the pixels belonging to the gray (5) vertical bar in the first column (column 0).\n3.  Find all colored pixels (not white 0 and not gray 5) in the input grid.\n4.  Identify which of these colored pixels are adjacent (horizontally, vertically, or diagonally) to any pixel of the gray bar.\n5.  If no colored pixels are adjacent to the gray bar, return the unchanged input grid copy.\n6.  Determine the minimum (`min_row_sel`) and maximum (`max_row_sel`) row indices spanned by these adjacent colored pixels.\n7.  Define the \"pattern block\" as the rectangular region of the *input* grid covering rows from `min_row_sel` to `max_row_sel` and all columns *except* the first one (column 0).\n8.  Determine the maximum row index (`max_row_orig`) occupied by any non-white (0), non-gray (5) pixel in the *entire* input grid.\n9.  Set the starting destination row for copying the pattern, `current_dest_row`, to be `max_row_orig + 1`.\n10. Calculate the height of the pattern block.\n11. Repeatedly copy the pattern block vertically downwards into the output grid, starting at `current_dest_row`. Each subsequent copy starts immediately below the previous one. Copying stops when the bottom of the grid is reached. If a copy would extend beyond the grid boundary, only the part that fits within the grid is copied.\n12. Return the modified output grid.\n\"\"\"\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Replicates a pattern derived from objects adjacent to a leftmost gray bar\n    downwards into the empty space of the grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify gray bar pixels in column 0\n    gray_bar_coords = set()\n    for r in range(height):\n        if input_grid[r, 0] == 5:\n            gray_bar_coords.add((r, 0))\n\n    # If no gray bar, maybe return original (though examples imply it exists)\n    if not gray_bar_coords:\n        # According to examples, gray bar seems mandatory.\n        # If it could be missing, this would be the place to handle it.\n        # For now, assume it exists based on training data.\n        pass # Proceed assuming it exists or the logic below handles empty sets gracefully.\n\n    # 2. Find all non-white (0), non-gray (5) pixels\n    colored_pixels = set()\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] not in [0, 5]:\n                colored_pixels.add((r, c))\n\n    # 3. Identify colored pixels adjacent to the gray bar\n    adjacent_colored_pixels = set()\n    neighbor_offsets = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    for r, c in colored_pixels:\n        # Only consider pixels not in the first column for adjacency check source\n        # (though colored pixels are defined as non-gray, so c==0 shouldn't happen anyway)\n        if c == 0: continue \n        \n        is_adj = False\n        for dr, dc in neighbor_offsets:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor coordinates are within bounds and are part of the gray bar\n            if 0 <= nr < height and 0 <= nc < width and (nr, nc) in gray_bar_coords:\n                is_adj = True\n                break\n        if is_adj:\n            adjacent_colored_pixels.add((r, c))\n\n    # 4. If no adjacent colored pixels, return the original grid copy\n    if not adjacent_colored_pixels:\n        return output_grid\n\n    # 5. Determine the row range of adjacent colored pixels\n    selected_rows = {r for r, c in adjacent_colored_pixels}\n    min_row_sel = min(selected_rows)\n    max_row_sel = max(selected_rows)\n\n    # 6. Define the pattern block (excluding column 0)\n    # Ensure width > 1 before slicing column 1 onwards\n    if width <= 1:\n         # If only one column, pattern block is empty, nothing to copy\n         return output_grid\n         \n    pattern_block = input_grid[min_row_sel : max_row_sel + 1, 1:width]\n    pattern_height = pattern_block.shape[0]\n\n    if pattern_height == 0:\n         # Should not happen if adjacent_colored_pixels is not empty, but safety check\n         return output_grid\n\n    # 7. Determine the max row index of any original non-white, non-gray pixel\n    if colored_pixels:\n        max_row_orig = max(r for r, c in colored_pixels)\n    else:\n        # This case should not be reachable if adjacent_colored_pixels is not empty\n        max_row_orig = -1 \n\n    # 8. Set the starting row for the first copy\n    current_dest_row = max_row_orig + 1\n\n    # 9. Replicate the pattern downwards\n    while current_dest_row < height:\n        # Calculate how many rows of the pattern can fit\n        rows_to_copy = min(pattern_height, height - current_dest_row)\n\n        # If no rows can be copied, stop\n        if rows_to_copy <= 0:\n            break\n            \n        # Get the slice of the pattern block to copy\n        source_block_slice = pattern_block[:rows_to_copy, :]\n\n        # Determine destination slice in the output grid\n        dest_slice_rows = slice(current_dest_row, current_dest_row + rows_to_copy)\n        dest_slice_cols = slice(1, width) # Copy to columns 1 onwards\n\n        # Perform the copy\n        output_grid[dest_slice_rows, dest_slice_cols] = source_block_slice\n\n        # Update the destination row for the next potential copy\n        current_dest_row += pattern_height\n\n    # 10. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3566,
    "candidates_token_count": 1523,
    "total_token_count": 5089,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.553391
}