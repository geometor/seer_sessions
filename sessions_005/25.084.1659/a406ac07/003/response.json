{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis program transforms an input grid based on patterns found in its last row.\n\n1.  Initialize an output grid of the same size as the input, filled with the background color (0, white).\n2.  Copy the last row and the last column from the input grid to the corresponding positions in the output grid. This acts as a border or frame.\n3.  Analyze the last row of the input grid (excluding the bottom-right corner pixel which belongs to both borders) to identify contiguous horizontal segments (blocks) of identical, non-background colors.\n4.  For each identified segment:\n    a.  Record its color (C).\n    b.  Record its length (n).\n    c.  Record the starting column index (idx) of the segment.\n    d.  Determine the drawing area for a square based on this segment:\n        i.  Top row: `row_start = idx`\n        ii. Bottom row (exclusive): `row_end = min(idx + n, height - 1)` (Clip to not overwrite the last row border)\n        iii.Left column: `col_start = idx`\n        iv. Right column (exclusive): `col_end = min(idx + n, width - 1)` (Clip to not overwrite the last column border)\n    e.  If the calculated drawing area has valid dimensions (`row_start < row_end` and `col_start < col_end`), fill this rectangular area `output_grid[row_start : row_end, col_start : col_end]` with the color C. Note that this might not be a perfect square if clipped by the boundaries.\n5.  Re-copy the last row and the last column from the input grid to the output grid. This ensures that the border pixels retain their original input values, even if the drawing process in step 4 overwrote them.\n6.  Return the modified output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by drawing shapes based on color blocks in the last row,\n    preserving the last row and column as borders.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output_grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n    \n    # --- Step 2: Copy initial borders ---\n    # Copy the last row and last column from input to output\n    if height > 0:\n        output_grid[height - 1, :] = input_np[height - 1, :]\n    if width > 0:\n        output_grid[:, width - 1] = input_np[:, width - 1]\n        \n    # Handle edge case of 1x1 grid - already copied\n    if height <= 1 or width <= 1:\n        return output_grid.tolist()\n\n    # --- Step 3 & 4: Analyze last row and draw shapes ---\n    last_row = input_np[height - 1, :]\n    \n    current_color = None\n    start_index = -1\n    segment_length = 0\n    \n    # Iterate through the last row to find contiguous blocks\n    # Iterate up to width-1 because the last pixel is part of the vertical border\n    for col in range(width -1): # Exclude the last column pixel\n        color = last_row[col]\n        \n        # Check if the current segment ends\n        if color == 0 or color != current_color:\n            # If a non-background segment just ended, process it\n            if current_color is not None and current_color != 0:\n                # --- Step 4d: Determine drawing area ---\n                row_start = start_index\n                row_end = min(start_index + segment_length, height - 1)\n                col_start = start_index\n                col_end = min(start_index + segment_length, width - 1)\n\n                # --- Step 4e: Draw the shape if area is valid ---\n                if row_start < row_end and col_start < col_end:\n                    output_grid[row_start : row_end, col_start : col_end] = current_color\n\n            # Reset or start a new segment\n            if color != 0:\n                current_color = color\n                start_index = col\n                segment_length = 1\n            else: # color is 0 (background)\n                current_color = None\n                start_index = -1\n                segment_length = 0\n        # Continue the current segment\n        elif color == current_color:\n            segment_length += 1\n\n    # After the loop, check if the last segment needs to be processed\n    if current_color is not None and current_color != 0:\n        # --- Step 4d: Determine drawing area ---\n        row_start = start_index\n        row_end = min(start_index + segment_length, height - 1)\n        col_start = start_index\n        col_end = min(start_index + segment_length, width - 1)\n\n        # --- Step 4e: Draw the shape if area is valid ---\n        if row_start < row_end and col_start < col_end:\n             output_grid[row_start : row_end, col_start : col_end] = current_color\n\n    # --- Step 5: Re-copy borders to ensure they are preserved ---\n    if height > 0:\n        output_grid[height - 1, :] = input_np[height - 1, :]\n    if width > 0:\n        output_grid[:, width - 1] = input_np[:, width - 1]\n            \n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4239,
    "candidates_token_count": 1391,
    "total_token_count": 5630,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 163.537192
}