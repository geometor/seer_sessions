{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid by drawing colored rectangles based on matching color \nsegments found in the last row and last column, while preserving these borders.\n\n1.  **Initialization:** Create an output grid of the same dimensions as the input, filled with the background color (0, white).\n2.  **Border Preservation (Initial):** Copy the last row and the last column from the input grid onto the output grid.\n3.  **Identify Row Segments:** Scan the last row of the input grid (excluding the last pixel). Identify contiguous horizontal segments of non-background colors. Record each segment's color (Cr), starting column index (Sr), and length (Lr).\n4.  **Identify Column Segments:** Scan the last column of the input grid (excluding the last pixel). Identify contiguous vertical segments of non-background colors. Record each segment's color (Cc), starting row index (Sc), and length (Lc).\n5.  **Match Segments and Draw Rectangles:**\n    a.  For each row segment (Cr, Sr, Lr):\n    b.  Find the unique column segment (Cc, Sc, Lc) where Cc equals Cr.\n    c.  Define the rectangle's parameters:\n        i.  Color: C = Cr\n        ii. Top row: row_start = Sc\n        iii.Bottom row (exclusive): row_end = Sc + Lc\n        iv. Left column: col_start = Sr\n        v.  Right column (exclusive): col_end = Sr + Lr\n    d.  Fill the area output_grid[row_start : row_end, col_start : col_end] with color C, ensuring drawing stays within the bounds defined by height-1 and width-1.\n6.  **Border Preservation (Final):** Re-copy the last row and last column from the input grid onto the output grid to restore any overwritten border pixels.\n7.  **Return:** Return the final output grid.\n\"\"\"\n\ndef get_segments(line):\n    \"\"\"\n    Finds contiguous segments of non-zero colors in a 1D array.\n\n    Args:\n        line (np.ndarray): A 1D numpy array of integers (colors).\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a segment\n              and has keys 'color' (int), 'start' (int), and 'length' (int).\n    \"\"\"\n    segments = []\n    current_color = 0\n    start_index = -1\n    # Ensure iteration works even if line is empty\n    line_length = len(line) if line is not None else 0\n    \n    for i in range(line_length):\n        color = int(line[i]) # Convert numpy int to standard int\n        \n        # Check if the current segment ends\n        if color == 0 or color != current_color:\n            # If a non-background segment just ended, record it\n            if current_color != 0:\n                segments.append({'color': current_color, 'start': start_index, 'length': i - start_index})\n\n            # Reset or start a new segment\n            if color != 0:\n                current_color = color\n                start_index = i\n            else: # color is 0 (background)\n                current_color = 0\n                start_index = -1\n        # Continue the current segment (color != 0 and color == current_color)\n        # No action needed here, segment length increases implicitly\n\n    # After the loop, check if the last segment needs to be recorded\n    if current_color != 0:\n        segments.append({'color': current_color, 'start': start_index, 'length': line_length - start_index})\n        \n    return segments\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on border segment matching.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # 1. Initialization: Create output_grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n    \n    # 2. Border Preservation (Initial): Copy last row and column\n    # Check if dimensions are valid before copying\n    if height > 0:\n        output_grid[height - 1, :] = input_np[height - 1, :]\n    if width > 0:\n        output_grid[:, width - 1] = input_np[:, width - 1]\n        \n    # Handle edge cases: If grid is too small for drawing area, return borders only\n    if height <= 1 or width <= 1:\n        return output_grid.tolist()\n\n    # 3. Identify Row Segments (excluding last pixel)\n    last_row_data = input_np[height - 1, :width - 1]\n    row_segments = get_segments(last_row_data)\n    \n    # 4. Identify Column Segments (excluding last pixel)\n    last_col_data = input_np[:height - 1, width - 1]\n    col_segments = get_segments(last_col_data)\n\n    # --- Create a lookup map for column segments by color for efficiency ---\n    col_segment_map = {seg['color']: seg for seg in col_segments}\n\n    # 5. Match Segments and Draw Rectangles\n    for row_seg in row_segments:\n        row_color = row_seg['color']\n        \n        # Find the matching column segment by color\n        if row_color in col_segment_map:\n            col_seg = col_segment_map[row_color]\n            \n            # Define rectangle parameters\n            color_to_draw = row_color\n            row_start = col_seg['start']\n            row_end = col_seg['start'] + col_seg['length']\n            col_start = row_seg['start']\n            col_end = row_seg['start'] + row_seg['length']\n            \n            # Clip drawing bounds to stay within the inner grid area (not overwrite borders)\n            row_end_clipped = min(row_end, height - 1)\n            col_end_clipped = min(col_end, width - 1)\n            \n            # Ensure the clipped area is valid before drawing\n            if row_start < row_end_clipped and col_start < col_end_clipped:\n                 output_grid[row_start : row_end_clipped, col_start : col_end_clipped] = color_to_draw\n\n    # 6. Border Preservation (Final): Re-copy borders to ensure they weren't overwritten\n    if height > 0:\n        output_grid[height - 1, :] = input_np[height - 1, :]\n    if width > 0:\n        output_grid[:, width - 1] = input_np[:, width - 1]\n            \n    # 7. Return: Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10100,
    "candidates_token_count": 1656,
    "total_token_count": 11756,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.073435
}