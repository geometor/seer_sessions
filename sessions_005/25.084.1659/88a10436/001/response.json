{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a single gray pixel (color 5) as a target location.\nIdentifies a contiguous shape composed of colors other than white (0) and gray (5).\nCalculates the center of the bounding box of this source shape.\nCopies the source shape to the target location, aligning the shape's calculated center with the gray pixel's coordinates.\nThe copied shape overwrites existing pixels at the target location. The original shape remains in place.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_pixels(grid, color_value):\n    \"\"\"Finds all coordinates of pixels with a specific color value.\"\"\"\n    coords = np.argwhere(grid == color_value)\n    return [(int(r), int(c)) for r, c in coords] # Ensure integer indices\n\ndef get_connected_component(grid, start_r, start_c):\n    \"\"\"\n    Finds all connected pixels belonging to the same object, starting from (start_r, start_c).\n    Connectivity is 8-way (including diagonals).\n    The object is defined as contiguous pixels that are not background (0) and not the marker color (5).\n    \"\"\"\n    height, width = grid.shape\n    q = deque([(start_r, start_c)])\n    component = set()\n    visited = set()\n\n    # Check if starting point itself is valid\n    start_color = grid[start_r, start_c]\n    if start_color == 0 or start_color == 5:\n        return component # Start point is not part of a valid shape\n\n    while q:\n        r, c = q.popleft()\n\n        # Check bounds\n        if not (0 <= r < height and 0 <= c < width):\n            continue\n\n        # Check if already visited\n        if (r, c) in visited:\n            continue\n\n        # Check if pixel is part of the shape (not background or marker)\n        color = grid[r, c]\n        if color == 0 or color == 5:\n            continue\n\n        # Add to component and mark visited\n        visited.add((r, c))\n        component.add((r, c))\n\n        # Explore neighbors (8-way connectivity)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                # Add neighbor to queue only if within bounds (further checks happen when popped)\n                if 0 <= nr < height and 0 <= nc < width:\n                     if (nr, nc) not in visited:\n                        q.append((nr, nc))\n\n    return component\n\ndef transform(input_grid):\n    \"\"\"\n    Copies a shape identified by non-background, non-marker colors to a location\n    specified by a gray marker pixel. The shape is centered on the marker.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Locate the coordinates (Gy, Gx) of the single gray pixel (color 5)\n    gray_coords = find_pixels(input_grid_np, 5)\n    if not gray_coords:\n        # Task guarantees one gray pixel, but handle defensively\n        print(\"Warning: No gray marker (color 5) found.\")\n        return output_grid.tolist() # Return original if no marker\n    Gy, Gx = gray_coords[0] # Assuming exactly one gray pixel\n\n    # 2. Identify the \"source shape\"\n    source_pixels = set()\n    for r in range(height):\n        for c in range(width):\n            color = input_grid_np[r, c]\n            # Check if it's a potential start of the shape and not already found\n            if color != 0 and color != 5:\n                 # Check if this pixel is already part of the found shape to avoid re-running BFS\n                 is_part_of_found_shape = False\n                 for pr, pc in source_pixels:\n                     if r == pr and c == pc:\n                         is_part_of_found_shape = True\n                         break\n                 if not is_part_of_found_shape:\n                    component = get_connected_component(input_grid_np, r, c)\n                    if component: # Found the shape\n                        source_pixels = component\n                        break # Stop searching once the shape is found\n        if source_pixels:\n            break # Stop outer loop as well\n\n    if not source_pixels:\n        # Handle case where no source shape is found\n        print(\"Warning: No source shape (non-0, non-5 pixels) found.\")\n        return output_grid.tolist()\n\n    # 3. Determine the bounding box and calculate the reference center\n    rows = [p[0] for p in source_pixels]\n    cols = [p[1] for p in source_pixels]\n    min_y, max_y = min(rows), max(rows)\n    min_x, max_x = min(cols), max(cols)\n\n    # Calculate center reference point (integer division for center)\n    Ref_y = min_y + (max_y - min_y) // 2\n    Ref_x = min_x + (max_x - min_x) // 2\n\n    # 4. Iterate through source shape pixels and copy them to the target location\n    for Sy, Sx in source_pixels:\n        color = input_grid_np[Sy, Sx] # Get the color of the source pixel\n\n        # Calculate the corresponding target coordinates (Ty, Tx)\n        # Offset from shape center = (Sy - Ref_y, Sx - Ref_x)\n        # Target coord = Marker coord + Offset\n        Ty = Gy + (Sy - Ref_y)\n        Tx = Gx + (Sx - Ref_x)\n\n        # Check if the target coordinates are within the grid bounds\n        if 0 <= Ty < height and 0 <= Tx < width:\n            # Update the output grid at the target coordinates\n            output_grid[Ty, Tx] = color\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3266,
    "candidates_token_count": 1471,
    "total_token_count": 4737,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.28849
}