{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis module transforms an input grid according to the following rule:\n1. Identify distinct connected objects within the grid that are not the border color (assumed magenta 6) or the background color (assumed orange 7).\n2. For each object:\n    a. Determine the border (top, bottom, left, right) closest to the object's geometric center. Tie-breaking: Top > Left > Bottom > Right.\n    b. Find the row (for left/right projection) or column (for top/bottom projection) where the object has the most pixels. Tie-breaking: Smallest index.\n    c. Project the object's color onto the cell of the closest border corresponding to the determined row/column.\n    d. Set the cell on the directly opposite border, in the same row/column, to white (0).\n3. The internal area and non-projected border cells remain unchanged.\n\"\"\"\n\ndef find_objects(grid, border_color, background_color):\n    \"\"\"\n    Finds connected components (objects) in the grid that are not of the border or background color.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color of the border.\n        background_color (int): The color of the internal background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (r, c) tuples),\n              'center' (r, c tuple).\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != border_color and color != background_color and not visited[r, c]:\n                obj_pixels = []\n                obj_color = color\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                sum_r, sum_c = 0, 0\n\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    obj_pixels.append((curr_r, curr_c))\n                    sum_r += curr_r\n                    sum_c += curr_c\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check 4 neighbors (von Neumann)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    center_r = sum_r / len(obj_pixels)\n                    center_c = sum_c / len(obj_pixels)\n                    objects.append({\n                        'color': obj_color,\n                        'pixels': obj_pixels,\n                        'center': (center_r, center_c)\n                    })\n    return objects\n\ndef get_projection_coordinate(pixels, axis):\n    \"\"\"\n    Finds the row (axis=0) or column (axis=1) index with the maximum pixel count.\n    Tie-breaking: smallest index.\n    \"\"\"\n    coords = [p[axis] for p in pixels]\n    if not coords:\n        return -1 # Should not happen for valid objects\n        \n    counts = Counter(coords)\n    max_count = 0\n    best_coord = float('inf')\n\n    # Find the maximum count first\n    for coord, count in counts.items():\n         max_count = max(max_count, count)\n\n    # Find the minimum coordinate with that maximum count\n    for coord, count in counts.items():\n        if count == max_count:\n            best_coord = min(best_coord, coord)\n            \n    return best_coord\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by projecting object colors onto the nearest border\n    and setting the opposite border cell to white.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # --- Assumptions based on examples ---\n    border_color = 6 # magenta\n    background_color = 7 # orange\n    opposite_color = 0 # white\n    # ------------------------------------\n\n    # 1. Find all distinct objects\n    objects = find_objects(grid, border_color, background_color)\n\n    # 2. Process each object\n    for obj in objects:\n        obj_color = obj['color']\n        center_r, center_c = obj['center']\n        pixels = obj['pixels']\n\n        # 2a. Calculate distances to borders\n        dist_top = center_r\n        dist_bottom = (rows - 1) - center_r\n        dist_left = center_c\n        dist_right = (cols - 1) - center_c\n\n        distances = [\n            (dist_top, 'top'),\n            (dist_left, 'left'),\n            (dist_bottom, 'bottom'),\n            (dist_right, 'right')\n        ]\n\n        # 2b. Find the closest border with tie-breaking\n        # Sort by distance, then by tie-breaking order (Top > Left > Bottom > Right)\n        # The tie-breaker is implicitly handled by the order in the list if distances are equal\n        # Python's sort is stable, but explicitly defining order is safer.\n        # Let's map names to priority: top=0, left=1, bottom=2, right=3\n        priority_map = {'top': 0, 'left': 1, 'bottom': 2, 'right': 3}\n        distances.sort(key=lambda x: (x[0], priority_map[x[1]]))\n        \n        closest_border_name = distances[0][1]\n\n        # 2c. Determine projection coordinate\n        if closest_border_name in ['top', 'bottom']:\n            # Vertical projection: find column with max pixels\n            proj_coord = get_projection_coordinate(pixels, axis=1) # axis 1 for columns\n            \n            if closest_border_name == 'top':\n                target_r, target_c = 0, proj_coord\n                opp_r, opp_c = rows - 1, proj_coord\n            else: # bottom\n                target_r, target_c = rows - 1, proj_coord\n                opp_r, opp_c = 0, proj_coord\n\n        else: # left or right\n            # Horizontal projection: find row with max pixels\n            proj_coord = get_projection_coordinate(pixels, axis=0) # axis 0 for rows\n\n            if closest_border_name == 'left':\n                target_r, target_c = proj_coord, 0\n                opp_r, opp_c = proj_coord, cols - 1\n            else: # right\n                target_r, target_c = proj_coord, cols - 1\n                opp_r, opp_c = proj_coord, 0\n\n        # 2d. Apply projection to output grid\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n             output_grid[target_r, target_c] = obj_color\n        if 0 <= opp_r < rows and 0 <= opp_c < cols:\n             output_grid[opp_r, opp_c] = opposite_color\n\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3567,
    "candidates_token_count": 1917,
    "total_token_count": 5484,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 86.004308
}