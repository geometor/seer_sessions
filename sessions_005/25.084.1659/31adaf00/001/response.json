{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nIdentifies all maximal contiguous rectangular regions composed entirely of white (0) pixels in the input grid.\nFor each such region found, if its height is 2 or more AND its width is 2 or more, \nall the pixels within that region are changed to blue (1) in the output grid.\nAll other pixels, including gray (5) pixels and white (0) pixels belonging to regions \nthat do not meet the size criteria (height < 2 or width < 2), remain unchanged.\n\"\"\"\n\ndef find_maximal_white_rectangles(grid, visited):\n    \"\"\"\n    Finds all maximal contiguous rectangular regions of white pixels (0).\n\n    Args:\n        grid (np.array): The input grid.\n        visited (np.array): A boolean grid of the same shape as grid,\n                           marking cells that have already been included\n                           in a previously found rectangle.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a rectangle\n              in the format (row, col, height, width).\n    \"\"\"\n    height, width = grid.shape\n    rectangles = []\n    # Iterate through each cell as a potential top-left corner\n    for r in range(height):\n        for c in range(width):\n            # Check if the cell is white (0) and hasn't been visited yet\n            if grid[r, c] == 0 and not visited[r, c]:\n                # Found a potential top-left corner of a new maximal rectangle\n\n                # 1. Determine the maximum possible width starting at (r, c)\n                #    This width is limited by non-white cells or grid boundaries in the current row 'r'.\n                max_w = 0\n                while c + max_w < width and grid[r, c + max_w] == 0:\n                    max_w += 1\n\n                # 2. Determine the maximum possible height for this rectangle\n                #    starting at (r, c) with width max_w.\n                #    Check subsequent rows to see how far down the rectangle of width max_w extends.\n                max_h = 0\n                for h_check in range(height - r):\n                    is_row_segment_white = True\n                    for w_check in range(max_w):\n                        if grid[r + h_check, c + w_check] != 0:\n                            is_row_segment_white = False\n                            break\n                    if is_row_segment_white:\n                        max_h += 1\n                    else:\n                        # Stop extending height as soon as a non-white cell is found\n                        # within the potential rectangle's bounds for the current width.\n                        break\n                \n                # 3. Store the found maximal rectangle\n                #    The rectangle found is guaranteed to be maximal because we started\n                #    from the top-leftmost unvisited white cell of this region,\n                #    extended width fully first, then extended height fully for that width.\n                if max_h > 0 and max_w > 0: # Ensure valid rectangle found\n                    rectangles.append((r, c, max_h, max_w))\n                    \n                    # 4. Mark all cells within this found rectangle as visited\n                    #    This prevents finding sub-rectangles or overlapping regions later.\n                    visited[r:r+max_h, c:c+max_w] = True\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replacing white rectangular regions (>= 2x2) with blue.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output_grid as a copy of the input_array\n    output_array = np.copy(input_array)\n    \n    # Initialize a visited grid to keep track of cells already part of a found rectangle\n    visited = np.full((height, width), False, dtype=bool)\n\n    # Find all maximal white rectangles\n    # Note: The finding function modifies the 'visited' array in place.\n    white_rectangles = find_maximal_white_rectangles(input_array, visited)\n\n    # Iterate through the found rectangles\n    for r, c, h, w in white_rectangles:\n        # Check if the rectangle meets the size criteria (height >= 2 and width >= 2)\n        if h >= 2 and w >= 2:\n            # If criteria met, change the corresponding region in the output_array to blue (1)\n            output_array[r:r+h, c:c+w] = 1\n            \n    # Convert the resulting NumPy array back to a list of lists\n    output_grid = output_array.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3296,
    "candidates_token_count": 1151,
    "total_token_count": 4447,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.366767
}