{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies a 3x3 'Red Cross' object (red border, green center) and other isolated 'Green Dots' in the input grid. \nCalculates the average position of the Green Dots relative to the Red Cross center.\nDetermines a movement direction (Up, Down, Left, Right) based on the larger absolute difference between the average dot position and the cross center (row or column).\nMoves the Red Cross object 2 steps if the movement is vertical (Up/Down) or 1 step if the movement is horizontal (Left/Right) in the determined direction. \nThe original position of the Red Cross is filled with white pixels. Green Dots remain stationary. If no Green Dots are found or no Red Cross is found, the grid remains unchanged.\n\"\"\"\n\ndef find_red_cross(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the center coordinates of the 3x3 Red Cross object.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (row, col) of the center coordinates, or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            # Check center pixel first\n            if grid[r + 1, c + 1] == 3:\n                # Check border pixels\n                if (grid[r, c] == 2 and grid[r, c + 1] == 2 and grid[r, c + 2] == 2 and\n                        grid[r + 1, c] == 2 and grid[r + 1, c + 2] == 2 and\n                        grid[r + 2, c] == 2 and grid[r + 2, c + 1] == 2 and grid[r + 2, c + 2] == 2):\n                    return (r + 1, c + 1)\n    return None\n\ndef find_green_dots(grid: np.ndarray, cross_center: Optional[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of all green dots, excluding the cross center.\n\n    Args:\n        grid: The input grid as a numpy array.\n        cross_center: The coordinates of the red cross center, if found.\n\n    Returns:\n        A list of (row, col) tuples for each green dot.\n    \"\"\"\n    green_dots = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 3:\n                if cross_center is None or (r, c) != cross_center:\n                    green_dots.append((r, c))\n    return green_dots\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed output grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # 1. Find the Red Cross object and its center\n    cross_center = find_red_cross(grid)\n\n    # If no Red Cross is found, return the original grid\n    if cross_center is None:\n        return input_grid\n\n    # 2. Find all other Green Dots\n    green_dots = find_green_dots(grid, cross_center)\n\n    # 3. If there are no Green Dots, return the original grid\n    if not green_dots:\n        return input_grid\n\n    # 4. Calculate the average position of Green Dots\n    avg_row = sum(r for r, c in green_dots) / len(green_dots)\n    avg_col = sum(c for r, c in green_dots) / len(green_dots)\n\n    # 5. Calculate differences relative to the Red Cross center\n    cross_r, cross_c = cross_center\n    row_diff = avg_row - cross_r\n    col_diff = avg_col - cross_c\n\n    # 6. Determine movement direction and distance\n    move_row, move_col = 0, 0\n    if abs(row_diff) > abs(col_diff):\n        # Vertical movement is primary\n        move_row = 2 if row_diff > 0 else -2\n    elif abs(col_diff) > abs(row_diff):\n        # Horizontal movement is primary\n        move_col = 1 if col_diff > 0 else -1\n    # Else (abs(row_diff) == abs(col_diff)), no movement\n\n    # 7. If there is movement, update the output grid\n    if move_row != 0 or move_col != 0:\n        # Calculate new center\n        new_cross_r = cross_r + move_row\n        new_cross_c = cross_c + move_col\n\n        # Define the Red Cross pattern\n        cross_pattern = np.array([\n            [2, 2, 2],\n            [2, 3, 2],\n            [2, 2, 2]\n        ])\n\n        # Calculate original cross boundaries (top-left corner)\n        orig_r_start = cross_r - 1\n        orig_c_start = cross_c - 1\n\n        # Clear the original Red Cross location in the output grid\n        if 0 <= orig_r_start < height - 2 and 0 <= orig_c_start < width - 2:\n             output_grid[orig_r_start:orig_r_start + 3, orig_c_start:orig_c_start + 3] = 0\n\n        # Calculate new cross boundaries (top-left corner)\n        new_r_start = new_cross_r - 1\n        new_c_start = new_cross_c - 1\n\n        # Draw the Red Cross at the new location, checking boundaries\n        if (0 <= new_r_start < height - 2 and 0 <= new_c_start < width - 2):\n             # Ensure we only overwrite parts that were potentially cleared or are background\n             # Create a mask of the original shape at the new location to preserve existing green dots\n             original_patch = grid[new_r_start:new_r_start + 3, new_c_start:new_c_start + 3]\n             mask = (original_patch != 3) | (cross_pattern == 3) # Allow overwriting if the new pixel is the green center\n             \n             # Apply the pattern where the mask allows\n             output_grid[new_r_start:new_r_start + 3, new_c_start:new_c_start + 3][mask] = cross_pattern[mask]\n             \n             # Explicitly set the center to green, in case it was masked out\n             output_grid[new_cross_r, new_cross_c] = 3 \n        # else: The cross would move off-grid, implied rule is likely to not move,\n        #       which is covered by returning the unmodified output_grid if no move occurred.\n        #       Or maybe it should clip? The examples don't show this case.\n        #       Current implementation assumes it fits or the move doesn't happen effectively.\n\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3792,
    "candidates_token_count": 1784,
    "total_token_count": 5576,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.483611
}