{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies a 3x3 'Red Cross' object (red border, green center) and other isolated 'Green Dots' in the input grid.\nCalculates the average position of the Green Dots relative to the Red Cross center.\nDetermines a primary movement direction (Up, Down, Left, Right) based on the larger absolute difference between the average dot position and the cross center (row or column).\nCalculates the target position by moving the Red Cross center 2 steps in the determined direction.\nIf the target 3x3 area for the Red Cross is fully within the grid boundaries:\n  - Clears the red border pixels (value 2) of the original Red Cross position to white (0), leaving the original green center pixel (value 3) untouched.\n  - Draws the complete 3x3 Red Cross pattern at the target position, overwriting any existing pixels.\nIf no Red Cross is found, no Green Dots are found, the average dot position is equidistant in row and column from the cross center, or the target position is outside the grid boundaries, the grid remains unchanged.\nGreen Dots themselves never move.\n\"\"\"\n\ndef find_red_cross(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the center coordinates of the 3x3 Red Cross object.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (row, col) of the center coordinates, or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            # Check center pixel first (must be green)\n            if grid[r + 1, c + 1] == 3:\n                # Check border pixels (must be red)\n                is_cross = True\n                for i in range(3):\n                    for j in range(3):\n                        if i == 1 and j == 1: # Skip center\n                            continue\n                        if grid[r + i, c + j] != 2:\n                            is_cross = False\n                            break\n                    if not is_cross:\n                        break\n                if is_cross:\n                    return (r + 1, c + 1) # Return center coordinates\n    return None\n\ndef find_green_dots(grid: np.ndarray, cross_center: Optional[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of all green dots, excluding the cross center if found.\n\n    Args:\n        grid: The input grid as a numpy array.\n        cross_center: The coordinates of the red cross center, if found.\n\n    Returns:\n        A list of (row, col) tuples for each green dot found.\n    \"\"\"\n    green_dots = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 3:\n                # Exclude the cross center if it exists and matches current position\n                if cross_center is None or (r, c) != cross_center:\n                    green_dots.append((r, c))\n    return green_dots\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed output grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Create a copy to modify\n    height, width = grid.shape\n\n    # 1. Find the Red Cross object and its center\n    cross_center = find_red_cross(grid)\n\n    # If no Red Cross is found, return the original grid\n    if cross_center is None:\n        # print(\"No Red Cross found.\")\n        return input_grid\n\n    # 2. Find all other Green Dots\n    green_dots = find_green_dots(grid, cross_center)\n\n    # 3. If there are no Green Dots, return the original grid\n    if not green_dots:\n        # print(\"No Green Dots found.\")\n        return input_grid\n\n    # 4. Calculate the average position of Green Dots\n    avg_row = sum(r for r, c in green_dots) / len(green_dots)\n    avg_col = sum(c for r, c in green_dots) / len(green_dots)\n\n    # 5. Calculate differences relative to the Red Cross center\n    cross_r, cross_c = cross_center\n    row_diff = avg_row - cross_r\n    col_diff = avg_col - cross_c\n\n    # 6. Determine movement direction and calculate movement vector (distance is 2)\n    move_row, move_col = 0, 0\n    move_distance = 2\n    if abs(row_diff) > abs(col_diff):\n        # Vertical movement is primary\n        move_row = move_distance if row_diff > 0 else -move_distance\n    elif abs(col_diff) > abs(row_diff):\n        # Horizontal movement is primary\n        move_col = move_distance if col_diff > 0 else -move_distance\n    # Else (abs(row_diff) == abs(col_diff)), no movement -> move_row, move_col remain 0\n\n    # 7. Check if movement is required\n    if move_row == 0 and move_col == 0:\n        # print(\"No movement required (equidistant or zero diff).\")\n        return input_grid # No movement, return original grid\n\n    # 8. Calculate the potential new center and boundaries\n    new_cross_r = cross_r + move_row\n    new_cross_c = cross_c + move_col\n    new_r_start = new_cross_r - 1\n    new_c_start = new_cross_c - 1\n    new_r_end = new_r_start + 3 # Exclusive end index for slicing\n    new_c_end = new_c_start + 3 # Exclusive end index for slicing\n\n    # 9. Boundary Check: Ensure the *entire* 3x3 new cross fits within the grid\n    if (0 <= new_r_start and new_r_end <= height and\n            0 <= new_c_start and new_c_end <= width):\n        # print(f\"Moving cross from {cross_center} to ({new_cross_r}, {new_cross_c})\")\n\n        # 10. Clear the *border* of the original Red Cross location\n        orig_r_start = cross_r - 1\n        orig_c_start = cross_c - 1\n        for r_offset in range(3):\n            for c_offset in range(3):\n                # Skip the center pixel\n                if r_offset == 1 and c_offset == 1:\n                    continue\n                # Clear only if it was a red border pixel\n                if output_grid[orig_r_start + r_offset, orig_c_start + c_offset] == 2:\n                     output_grid[orig_r_start + r_offset, orig_c_start + c_offset] = 0 # Set to white\n\n        # 11. Draw the Red Cross at the new location (overwrite)\n        cross_pattern = np.array([\n            [2, 2, 2],\n            [2, 3, 2],\n            [2, 2, 2]\n        ])\n        output_grid[new_r_start:new_r_end, new_c_start:new_c_end] = cross_pattern\n\n    else:\n        # print(f\"Skipping move: New position ({new_r_start}:{new_r_end}, {new_c_start}:{new_c_end}) out of bounds ({height}x{width}).\")\n        return input_grid # New position is invalid, return original grid\n\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4775,
    "candidates_token_count": 1915,
    "total_token_count": 6690,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.187554
}