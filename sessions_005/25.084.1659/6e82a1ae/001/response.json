{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color):\n    \"\"\"Finds connected objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a list of (row, col) tuples.\n              Objects are ordered by their top-most, then left-most coordinate.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n    \n    # Find all potential starting points first to process them in order\n    potential_starts = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color:\n                potential_starts.append((r, c))\n\n    # Process starting points in row-major order\n    for r_start, c_start in potential_starts:\n        if (r_start, c_start) in visited:\n            continue\n\n        # Start BFS for a new object\n        obj_coords = set()\n        q = deque([(r_start, c_start)])\n        visited.add((r_start, c_start))\n        obj_coords.add((r_start, c_start))\n\n        while q:\n            r, c = q.popleft()\n\n            # Check 8 neighbors (including diagonals)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n\n                    # Check bounds\n                    if 0 <= nr < height and 0 <= nc < width:\n                        # Check if neighbor is the target color and not visited\n                        if grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n        \n        # Add the found object (as a list of coordinates) to the list\n        if obj_coords:\n            # Convert set to list for consistent ordering if needed later, \n            # though size is the primary use here.\n            # The order of objects in the 'objects' list is determined by the\n            # row-major scan of potential_starts.\n            objects.append(list(obj_coords)) \n\n    # Sort objects based on the top-most, then left-most coordinate to ensure\n    # consistent ordering for the size 3 rule splitting.\n    objects.sort(key=lambda coords: min(coords))\n            \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding connected gray objects (color 5)\n    and recoloring them based on their size and the set of sizes present.\n\n    Rule:\n    1. Find all connected gray (5) objects using BFS with diagonal connectivity.\n       Order objects based on their top-most, then left-most pixel.\n    2. Determine the size (pixel count) of each object.\n    3. Identify the set of unique object sizes present in the grid (`unique_sizes`).\n    4. Initialize the output grid as a copy of the input.\n    5. Create a list to hold the coordinates of Size 3 objects, maintaining their discovery order.\n    6. Iterate through the found objects:\n       - If Size is 1, paint Blue (1).\n       - If Size is 2, paint Green (3).\n       - If Size is 4, paint Blue (1).\n       - If Size is 3, add its coordinates to the Size 3 list.\n    7. After processing all objects, handle the Size 3 objects:\n       - If Size 4 is present in `unique_sizes`: Paint all Size 3 objects Red (2).\n       - If Size 4 is NOT present in `unique_sizes`:\n         - Let N be the number of Size 3 objects.\n         - Paint the first N // 2 objects (in order) Red (2).\n         - Paint the remaining Size 3 objects Blue (1).\n    8. Return the modified grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    gray_color = 5\n\n    # Find all gray objects, ordered by top-leftmost pixel\n    # Each object in the list is itself a list of (row, col) coordinates\n    objects = find_objects(input_grid_np, gray_color)\n\n    # Calculate sizes and find unique sizes\n    object_sizes = [len(obj_coords) for obj_coords in objects]\n    unique_sizes = set(object_sizes)\n    \n    # Store coordinates of size 3 objects in the order they appear in 'objects'\n    size_3_object_coords_list = [] \n\n    # Process non-size-3 objects and collect size 3 object coordinates\n    for i, obj_coords in enumerate(objects):\n        size = len(obj_coords)\n        color_to_paint = -1 # Default: no color determined yet\n\n        if size == 1:\n            color_to_paint = 1 # Blue\n        elif size == 2:\n            color_to_paint = 3 # Green\n        elif size == 4:\n            color_to_paint = 1 # Blue\n        elif size == 3:\n            # Store coordinates for later processing, maintaining order\n            size_3_object_coords_list.append(obj_coords)\n        # else: # Handle potential future sizes if necessary\n            # pass # Keep original color\n\n        # Paint if color determined (sizes 1, 2, 4)\n        if color_to_paint != -1:\n            for r, c in obj_coords:\n                output_grid[r, c] = color_to_paint\n\n    # Process size 3 objects based on the context (presence of size 4)\n    if size_3_object_coords_list:\n        num_size_3 = len(size_3_object_coords_list)\n        \n        if 4 in unique_sizes:\n            # If size 4 exists, all size 3 objects become Red(2)\n            color_for_size_3 = 2 \n            for obj_coords in size_3_object_coords_list:\n                 for r, c in obj_coords:\n                    output_grid[r, c] = color_for_size_3\n        else:\n            # If size 4 does not exist, split Size 3 into Red(2) and Blue(1)\n            # The list size_3_object_coords_list is already sorted by discovery order\n            num_red = num_size_3 // 2 # Integer division determines the split point\n            \n            # First num_red objects become Red(2)\n            for i in range(num_red):\n                obj_coords = size_3_object_coords_list[i]\n                for r, c in obj_coords:\n                    output_grid[r, c] = 2 # Red\n            \n            # Remaining objects become Blue(1)\n            for i in range(num_red, num_size_3):\n                obj_coords = size_3_object_coords_list[i]\n                for r, c in obj_coords:\n                    output_grid[r, c] = 1 # Blue\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10318,
    "candidates_token_count": 1748,
    "total_token_count": 12066,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 50.909728
}