{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify closed regions (\"containers\") made of gray (5) pixels. \nFor each container, find if there is exactly one distinct, non-white (0), non-gray (5) colored object adjacent to its exterior boundary. \nIf such a unique adjacent object (\"filler source\") exists:\n1. Fill the interior area enclosed by the gray container with the color of the filler source.\n2. Remove the filler source object by replacing its pixels with white (0).\nObjects not involved in this interaction remain unchanged. Adjacency includes diagonals.\n\"\"\"\n\ndef find_connected_components(grid, target_colors=None, ignore_colors=None):\n    \"\"\"\n    Finds all connected components of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_colors (set, optional): Set of colors to find components for. \n                                        If None, finds components for all colors.\n        ignore_colors (set, optional): Set of colors to ignore during traversal.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, set_of_coords).\n              set_of_coords contains (row, col) tuples for the component.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    if ignore_colors is None:\n        ignore_colors = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            \n            # Skip if visited, ignored color, or not a target color (if specified)\n            if visited[r, c] or \\\n               color in ignore_colors or \\\n               (target_colors is not None and color not in target_colors):\n                continue\n\n            component_coords = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            component_coords.add((r, c))\n\n            while q:\n                row, col = q.popleft()\n\n                # Check 8 neighbors (including diagonals)\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        \n                        nr, nc = row + dr, col + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == color and \\\n                           color not in ignore_colors:\n                            \n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n            \n            if component_coords:\n                components.append((color, component_coords))\n\n    return components\n\ndef get_neighbors(r, c, rows, cols, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) > 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_interior(grid, container_coords):\n    \"\"\"\n    Finds the interior pixels enclosed by a container.\n    Uses flood fill from the grid borders to identify exterior pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    exterior_visited = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Add border cells that are not part of the container to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if (r, c) not in container_coords and not exterior_visited[r, c]:\n                q.append((r, c))\n                exterior_visited[r, c] = True\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if (r, c) not in container_coords and not exterior_visited[r, c]:\n                q.append((r, c))\n                exterior_visited[r, c] = True\n\n    # Flood fill from borders (4-connectivity is sufficient for finding exterior reachable area)\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not exterior_visited[nr, nc] and \\\n               (nr, nc) not in container_coords:\n                exterior_visited[nr, nc] = True\n                q.append((nr, nc))\n\n    # Interior points are those not visited by exterior flood fill and not part of the container\n    interior_coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if not exterior_visited[r, c] and (r, c) not in container_coords:\n                interior_coords.add((r, c))\n                \n    # Check if interior is empty or contains only gray pixels - means it wasn't a proper enclosure\n    is_valid_enclosure = False\n    for r,c in interior_coords:\n        if grid[r,c] != 5: # If any non-gray pixel is inside\n            is_valid_enclosure = True\n            break\n            \n    if not is_valid_enclosure:\n         return set() # Return empty set if not a valid enclosure\n\n    return interior_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the container-filler transformation rule.\n    1. Finds gray containers and potential filler objects.\n    2. For each container, identifies its interior.\n    3. Finds unique filler objects adjacent to the container's exterior.\n    4. If exactly one unique filler is found, fills the interior with its color \n       and removes the filler object (sets to white).\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # 1. Identify potential containers (gray=5) and fillers (not white=0, not gray=5)\n    all_components = find_connected_components(input_grid)\n    \n    containers = []\n    potential_fillers = []\n    filler_map = {} # Map coord -> filler index for quick lookup\n    \n    for i, (color, coords) in enumerate(all_components):\n        if color == 5:\n            containers.append((color, coords))\n        elif color != 0:\n            potential_fillers.append({'id': i, 'color': color, 'coords': coords})\n            for coord in coords:\n                filler_map[coord] = i # Store the component id for this coord\n\n    # Process each container\n    for _, container_coords in containers:\n        \n        # 2. Determine interior pixels (if any)\n        interior_pixels = find_interior(input_grid, container_coords)\n        if not interior_pixels: # Skip if no valid interior found\n            continue\n\n        # 3. Find adjacent filler objects to the *exterior* boundary\n        adjacent_filler_ids = set()\n        exterior_boundary_pixels = set()\n\n        for r, c in container_coords:\n            is_exterior_boundary = False\n            for nr, nc in get_neighbors(r, c, rows, cols, include_diagonal=True):\n                 # If neighbor is outside the container (not gray) and not interior, it's exterior adjacent\n                 if (nr, nc) not in container_coords and (nr, nc) not in interior_pixels:\n                     is_exterior_boundary = True\n                     # Check if this exterior neighbor belongs to a potential filler\n                     if (nr, nc) in filler_map:\n                         adjacent_filler_ids.add(filler_map[(nr, nc)])\n            if is_exterior_boundary:\n                 exterior_boundary_pixels.add((r,c)) # Keep track for potential debugging\n\n        # 4. Check condition: exactly one unique adjacent filler\n        if len(adjacent_filler_ids) == 1:\n            filler_id = list(adjacent_filler_ids)[0]\n            \n            # Find the actual filler object data\n            unique_filler = None\n            for filler in potential_fillers:\n                if filler['id'] == filler_id:\n                    unique_filler = filler\n                    break\n            \n            if unique_filler:\n                filler_color = unique_filler['color']\n                filler_coords = unique_filler['coords']\n                \n                # 5a. Fill interior in output grid\n                for r_int, c_int in interior_pixels:\n                    output_grid[r_int, c_int] = filler_color\n                    \n                # 5b. Remove filler source in output grid\n                for r_fill, c_fill in filler_coords:\n                    output_grid[r_fill, c_fill] = 0 # Set to white\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3552,
    "candidates_token_count": 2166,
    "total_token_count": 5718,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.788484
}