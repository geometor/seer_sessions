{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies all maximal contiguous rectangular blocks composed solely of white (0) pixels in the input grid.\nCalculates the area for each maximal white rectangle.\nSelects a single rectangle based on the following ordered criteria:\n1. Maximum Area (largest height * width).\n2. Maximum Height (tallest, to break ties in area).\n3. Minimum Row index (top-most, to break ties in area and height).\n4. Minimum Column index (left-most, to break ties in area, height, and row).\nCopies the input grid to the output grid, then changes the color of all pixels within the bounds of the selected rectangle to magenta (6).\nIf no white rectangles are found, the output grid is identical to the input grid.\n\"\"\"\n\ndef find_all_white_rectangles(grid):\n    \"\"\"\n    Finds all possible rectangular blocks of white (0) pixels.\n    This generates rectangles anchored at every white pixel and extending\n    as far right and down as possible while remaining white. Includes\n    sub-rectangles, which will be filtered later for maximality.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a\n              rectangle {'r': row, 'c': col, 'h': height, 'w': width, 'area': area}.\n    \"\"\"\n    rows, cols = grid.shape\n    all_rects = []\n    # Iterate through each cell as a potential top-left corner\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is white, start searching for rectangles\n            if grid[r, c] == 0:\n                max_w = 0\n                # Find the maximum width of consecutive white cells in the current row starting at (r, c)\n                while c + max_w < cols and grid[r, c + max_w] == 0:\n                    max_w += 1\n                \n                # Now, for each possible width (1 to max_w), find the max height\n                for w in range(1, max_w + 1):\n                    max_h = 1 # Start with height 1 (the current row)\n                    # Check subsequent rows to see how far down this rectangle of width 'w' can extend\n                    while r + max_h < rows:\n                        is_solid_row = True\n                        # Check if the entire segment grid[r + max_h, c : c + w] is white\n                        for k in range(w):\n                            if grid[r + max_h, c + k] != 0:\n                                is_solid_row = False\n                                break\n                        if is_solid_row:\n                            max_h += 1 # If the row is solid white, increment height\n                        else:\n                            break # Stop extending height if a non-white cell is found\n                    \n                    # Add the found rectangle (with height max_h and width w) to the list\n                    area = max_h * w\n                    all_rects.append({'r': r, 'c': c, 'h': max_h, 'w': w, 'area': area})\n    return all_rects\n\ndef filter_maximal_rectangles(rectangles):\n    \"\"\"\n    Filters a list of rectangles to keep only the maximal ones.\n    A rectangle R1 is maximal if no other rectangle R2 in the list fully contains R1.\n\n    Args:\n        rectangles (list): A list of rectangle dictionaries.\n\n    Returns:\n        list: A list of maximal rectangle dictionaries.\n    \"\"\"\n    if not rectangles:\n        return []\n\n    maximal_rects_candidates = []\n    # Iterate through each rectangle and check if it's contained within any other\n    for i, r1 in enumerate(rectangles):\n        is_maximal = True\n        for j, r2 in enumerate(rectangles):\n            # Don't compare a rectangle with itself\n            if i == j:\n                continue\n            \n            # Check if r2 strictly contains r1 (same dimensions allowed, but different location is okay)\n            # Check if r2 contains r1\n            # r2 contains r1 if:\n            # r2.r <= r1.r\n            # r2.c <= r1.c\n            # r2.r + r2.h >= r1.r + r1.h\n            # r2.c + r2.w >= r1.c + r1.w\n            # And r2 is not identical to r1 (either bigger or same size at diff location)\n            if (r2['r'] <= r1['r'] and\n                r2['c'] <= r1['c'] and\n                r2['r'] + r2['h'] >= r1['r'] + r1['h'] and\n                r2['c'] + r2['w'] >= r1['c'] + r1['w']):\n                \n                # If r2 is strictly larger than r1 in at least one dimension or area\n                if r2['area'] > r1['area'] or r2['h'] > r1['h'] or r2['w'] > r1['w']:\n                   is_maximal = False\n                   break\n                # Handle case where r1 and r2 are identical but found from different starts\n                # If they are identical, we only want one copy eventually, but\n                # don't mark as non-maximal yet based on an identical copy.\n                # Let the duplicate removal handle this.\n\n        if is_maximal:\n            maximal_rects_candidates.append(r1)\n            \n    # Remove duplicates. Since identical rectangles might be generated starting\n    # from different top-left corners but deemed maximal, we need to ensure uniqueness.\n    unique_maximal_rects_set = set()\n    for rect in maximal_rects_candidates:\n        # Use a tuple representation for hashing in the set\n        unique_maximal_rects_set.add( (rect['r'], rect['c'], rect['h'], rect['w'], rect['area']) )\n        \n    # Convert back to list of dictionaries\n    final_maximal_rects = [{'r': r, 'c': c, 'h': h, 'w': w, 'area': area} for r, c, h, w, area in unique_maximal_rects_set]\n    \n    return final_maximal_rects\n\ndef select_rectangle(rectangles):\n    \"\"\"\n    Selects a single rectangle from a list based on sorting criteria:\n    1. Max Area (descending)\n    2. Max Height (descending)\n    3. Min Row (ascending)\n    4. Min Col (ascending)\n\n    Args:\n        rectangles (list): A list of maximal rectangle dictionaries.\n\n    Returns:\n        dict or None: The selected rectangle dictionary, or None if the list is empty.\n    \"\"\"\n    if not rectangles:\n        return None\n\n    # Sort using a lambda function with multiple keys.\n    # Negative sign is used for descending order for numeric types.\n    sorted_rects = sorted(rectangles, key=lambda r: (-r['area'], -r['h'], r['r'], r['c']))\n    \n    # The first element after sorting is the desired rectangle\n    return sorted_rects[0]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic: find the specific maximal white rectangle\n    based on area, height, and position, and fill it with magenta.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed grid.\n    \"\"\"\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Step 1 & 2: Identify all possible white rectangles\n    # Note: This function might generate many sub-rectangles.\n    all_rects = find_all_white_rectangles(input_grid)\n    \n    # Step 3: Filter to get only the maximal ones\n    maximal_rects = filter_maximal_rectangles(all_rects)\n    \n    # Step 4 & 5: Select the target rectangle based on the specified criteria\n    selected_rect = select_rectangle(maximal_rects)\n\n    # Step 6 & 7: If a rectangle was successfully selected, fill it\n    if selected_rect:\n        # Extract coordinates and dimensions\n        r, c, h, w = selected_rect['r'], selected_rect['c'], selected_rect['h'], selected_rect['w']\n        \n        # Fill the selected rectangular area in the output grid with magenta (6)\n        output_grid[r:r+h, c:c+w] = 6\n\n    # Step 8: Return the modified grid (or the original copy if no rectangle was selected)\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6857,
    "candidates_token_count": 2019,
    "total_token_count": 8876,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.643247
}