{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nFinds all rectangular blocks composed entirely of white (0) pixels in the input grid.\nSelects the block based on the following criteria in order:\n1. Maximum height.\n2. Maximum area (width * height). If heights are equal, this means maximum width.\n3. Minimum row index of the top-left corner (top-most).\n4. Minimum column index of the top-left corner (left-most).\nCopies the input grid to the output grid and then fills the selected white rectangular block with magenta (6).\n\"\"\"\n\ndef find_white_rectangles(grid):\n    \"\"\"\n    Identifies all maximal rectangular blocks of white (0) pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a rectangle\n              (row, col, height, width).\n    \"\"\"\n    rows, cols = grid.shape\n    rectangles = []\n    visited = np.zeros_like(grid, dtype=bool) # To avoid redundant checks\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is white and hasn't been part of a found maximal rectangle starting at an earlier point\n            if grid[r, c] == 0 and not visited[r, c]:\n                max_w = cols - c\n                # Find the maximum possible height for a rectangle starting at (r, c) with width 1\n                h = 0\n                while r + h < rows and grid[r + h, c] == 0:\n                    h += 1\n                \n                # Now expand width, reducing height if necessary\n                for current_h in range(1, h + 1):\n                    current_w = 1\n                    # Check how far right we can go for this height\n                    while c + current_w < cols:\n                        is_white_column = True\n                        # Check the column at c + current_w from row r to r + current_h - 1\n                        for row_idx in range(r, r + current_h):\n                           if grid[row_idx, c + current_w] != 0:\n                               is_white_column = False\n                               break\n                        if not is_white_column:\n                           break # Cannot extend width further for this height\n                        current_w += 1\n                    \n                    # Record this rectangle\n                    rectangles.append((r, c, current_h, current_w))\n                    # Mark visited cells within this rectangle to avoid redundant checks? \n                    # No, finding *all* rectangles, not just maximal ones for now.\n                    # Let's reconsider: the prompt says \"all possible rectangular blocks\".\n                    # Does this mean *maximal* blocks or *any* sub-block?\n                    # Example 1: input[0, 2:7] is 0 0 0 0 0. This contains 1x1, 1x2, ..., 1x5 blocks.\n                    # The output fills the whole 2x5 block. This suggests we look for maximal blocks.\n                    # However, the description says \"all possible\". Let's try finding *all* first.\n                    # If we find *all*, the criteria (max height, max area) should still pick the largest one.\n\n    # The above loop finds many overlapping rectangles. We need a better approach\n    # to find just the potential *maximal* rectangles efficiently, or filter later.\n    # Let's try finding *all* rectangles first, as it's simpler to implement.\n    \n    all_rects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] == 0:\n                # Try expanding from (r,c) as top-left\n                max_h = 0\n                while r + max_h < rows and grid[r + max_h, c] == 0:\n                    max_w = 0\n                    while c + max_w < cols:\n                        is_solid = True\n                        # Check the rectangle from (r,c) to (r+max_h, c+max_w)\n                        for i in range(r, r + max_h + 1):\n                           for j in range(c, c + max_w + 1):\n                               if grid[i,j] != 0:\n                                   is_solid = False\n                                   break\n                           if not is_solid:\n                               break\n                        \n                        if is_solid:\n                           # This rectangle (r, c, max_h+1, max_w+1) is valid white block\n                           all_rects.append((r, c, max_h + 1, max_w + 1))\n                           max_w += 1\n                        else:\n                           break # Cannot expand width further for this height\n                    max_h += 1 # Try next potential height\n\n    if not all_rects:\n        return []\n\n    # Filter based on criteria\n    # 1. Max height\n    max_height = 0\n    for _, _, h, _ in all_rects:\n        if h > max_height:\n            max_height = h\n    \n    height_filtered_rects = [(r, c, h, w) for r, c, h, w in all_rects if h == max_height]\n\n    # 2. Max area (equivalent to max width since height is fixed now)\n    max_width = 0 # Area = max_height * width\n    for _, _, _, w in height_filtered_rects:\n         if w > max_width:\n             max_width = w\n\n    area_filtered_rects = [(r, c, h, w) for r, c, h, w in height_filtered_rects if w == max_width]\n\n    # 3. Top-most (min row)\n    min_row = rows # Initialize with a value larger than any possible row index\n    for r, _, _, _ in area_filtered_rects:\n        if r < min_row:\n            min_row = r\n            \n    row_filtered_rects = [(r, c, h, w) for r, c, h, w in area_filtered_rects if r == min_row]\n\n    # 4. Left-most (min col)\n    min_col = cols # Initialize with a value larger than any possible col index\n    for _, c, _, _ in row_filtered_rects:\n         if c < min_col:\n             min_col = c\n\n    # There should be exactly one rectangle left matching all criteria\n    final_rect = [(r, c, h, w) for r, c, h, w in row_filtered_rects if c == min_col]\n\n    # Return just the single best rectangle if found\n    return final_rect # Should be a list containing zero or one rectangle tuple\n\ndef transform(input_grid):\n    \"\"\"\n    Finds the largest white (0) rectangle based on height, then area, then position,\n    and fills it with magenta (6).\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all potential white rectangles and select the best one based on criteria\n    selected_rects = find_white_rectangles(output_grid)\n\n    # If a rectangle was selected\n    if selected_rects:\n        # There should be only one rectangle in the list after filtering\n        r, c, h, w = selected_rects[0]\n        \n        # Fill the selected rectangle in the output grid with magenta (6)\n        output_grid[r:r+h, c:c+w] = 6\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3050,
    "candidates_token_count": 1806,
    "total_token_count": 4856,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.798656
}