{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies all maximal contiguous rectangular blocks composed solely of white (0) pixels in the input grid.\nCalculates the area and height for each maximal white rectangle.\nSelects a single rectangle based on the following ordered criteria:\n1. Maximum Height (tallest).\n2. Maximum Area (largest height * width, to break ties in height).\n3. Minimum Row index (top-most, to break ties in height and area).\n4. Minimum Column index (left-most, to break ties in height, area, and row).\nCopies the input grid to the output grid, then changes the color of all pixels within the bounds of the selected rectangle to magenta (6).\nIf no white rectangles are found, the output grid is identical to the input grid.\n\"\"\"\n\ndef find_all_white_rectangles(grid):\n    \"\"\"\n    Finds all possible rectangular blocks of white (0) pixels.\n    This generates rectangles anchored at every white pixel and extending\n    as far right and down as possible while remaining white. Includes\n    sub-rectangles, which will be filtered later for maximality.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a\n              rectangle {'r': row, 'c': col, 'h': height, 'w': width, 'area': area}.\n    \"\"\"\n    rows, cols = grid.shape\n    all_rects = []\n    # Iterate through each cell as a potential top-left corner\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is white, start searching for rectangles\n            if grid[r, c] == 0:\n                max_w = 0\n                # Find the maximum width of consecutive white cells in the current row starting at (r, c)\n                while c + max_w < cols and grid[r, c + max_w] == 0:\n                    max_w += 1\n                \n                # Now, for each possible width (1 to max_w), find the max height\n                for w in range(1, max_w + 1):\n                    max_h = 1 # Start with height 1 (the current row)\n                    # Check subsequent rows to see how far down this rectangle of width 'w' can extend\n                    while r + max_h < rows:\n                        is_solid_row = True\n                        # Check if the entire segment grid[r + max_h, c : c + w] is white\n                        for k in range(w):\n                            if grid[r + max_h, c + k] != 0:\n                                is_solid_row = False\n                                break\n                        if is_solid_row:\n                            max_h += 1 # If the row is solid white, increment height\n                        else:\n                            break # Stop extending height if a non-white cell is found\n                    \n                    # Add the found rectangle (with height max_h and width w) to the list\n                    area = max_h * w\n                    all_rects.append({'r': r, 'c': c, 'h': max_h, 'w': w, 'area': area})\n    return all_rects\n\ndef filter_maximal_rectangles(rectangles):\n    \"\"\"\n    Filters a list of rectangles to keep only the maximal ones.\n    A rectangle R1 is maximal if no other rectangle R2 in the list fully contains R1.\n\n    Args:\n        rectangles (list): A list of rectangle dictionaries.\n\n    Returns:\n        list: A list of maximal rectangle dictionaries.\n    \"\"\"\n    if not rectangles:\n        return []\n\n    maximal_rects_candidates = []\n    # Iterate through each rectangle and check if it's contained within any other\n    for i, r1 in enumerate(rectangles):\n        is_maximal = True\n        for j, r2 in enumerate(rectangles):\n            # Don't compare a rectangle with itself\n            if i == j:\n                continue\n            \n            # Check if r2 contains r1\n            # r2 contains r1 if:\n            # r2.r <= r1.r\n            # r2.c <= r1.c\n            # r2.r + r2.h >= r1.r + r1.h\n            # r2.c + r2.w >= r1.c + r1.w\n            if (r2['r'] <= r1['r'] and\n                r2['c'] <= r1['c'] and\n                r2['r'] + r2['h'] >= r1['r'] + r1['h'] and\n                r2['c'] + r2['w'] >= r1['c'] + r1['w']):\n                \n                # If r2 is strictly larger than r1 in at least one dimension or area, \n                # or if they are the same size but r2 starts at an earlier position (meaning r1 is a duplicate found later)\n                if (r2['area'] > r1['area'] or \n                    r2['h'] > r1['h'] or \n                    r2['w'] > r1['w'] or \n                    (r2['area'] == r1['area'] and (r2['r'] < r1['r'] or (r2['r'] == r1['r'] and r2['c'] < r1['c'])))):\n                   is_maximal = False\n                   break\n\n        if is_maximal:\n            maximal_rects_candidates.append(r1)\n            \n    # Remove exact duplicates that might have passed the maximality check against each other.\n    # Using a set of tuples guarantees uniqueness based on all properties.\n    unique_maximal_rects_set = set()\n    for rect in maximal_rects_candidates:\n        unique_maximal_rects_set.add( (rect['r'], rect['c'], rect['h'], rect['w'], rect['area']) )\n        \n    # Convert back to list of dictionaries\n    final_maximal_rects = [{'r': r, 'c': c, 'h': h, 'w': w, 'area': area} for r, c, h, w, area in unique_maximal_rects_set]\n    \n    return final_maximal_rects\n\ndef select_rectangle(rectangles):\n    \"\"\"\n    Selects a single rectangle from a list based on sorting criteria:\n    1. Max Height (descending)\n    2. Max Area (descending)\n    3. Min Row (ascending)\n    4. Min Col (ascending)\n\n    Args:\n        rectangles (list): A list of maximal rectangle dictionaries.\n\n    Returns:\n        dict or None: The selected rectangle dictionary, or None if the list is empty.\n    \"\"\"\n    if not rectangles:\n        return None\n\n    # Sort using a lambda function with multiple keys according to the revised criteria.\n    # Negative sign is used for descending order for numeric types (height, area).\n    sorted_rects = sorted(rectangles, key=lambda r: (-r['h'], -r['area'], r['r'], r['c']))\n    \n    # The first element after sorting is the desired rectangle\n    return sorted_rects[0]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic: find the specific maximal white rectangle\n    based on height, area, and position, and fill it with magenta.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed grid.\n    \"\"\"\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Step 1: Identify all possible white rectangles (including sub-rectangles)\n    all_rects = find_all_white_rectangles(input_grid)\n    \n    # Step 2: Filter to get only the maximal ones\n    maximal_rects = filter_maximal_rectangles(all_rects)\n    \n    # Step 3: Select the target rectangle based on the specified criteria (max height -> max area -> min row -> min col)\n    selected_rect = select_rectangle(maximal_rects)\n\n    # Step 4: If a rectangle was successfully selected, fill it with magenta\n    if selected_rect:\n        # Extract coordinates and dimensions\n        r, c, h, w = selected_rect['r'], selected_rect['c'], selected_rect['h'], selected_rect['w']\n        \n        # Fill the selected rectangular area in the output grid with magenta (6)\n        output_grid[r:r+h, c:c+w] = 6\n\n    # Step 5: Return the modified grid (or the original copy if no rectangle was selected)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5353,
    "candidates_token_count": 2003,
    "total_token_count": 7356,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 67.968766
}