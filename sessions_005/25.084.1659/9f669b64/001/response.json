{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\nimport sys\n\n# Set higher recursion depth for deep object searches if needed, though BFS is preferred.\n# sys.setrecursionlimit(2000) \n\n\"\"\"\nIdentifies three non-background objects in the input grid: stable, moving, and split.\nThe moving object is typically positioned between the other two along one axis.\nIt moves towards the nearest grid edge along the axis perpendicular to the alignment with the other objects.\nAs it moves, it effectively splits the object it moves towards (the split object) into two halves.\nThe split occurs along an axis perpendicular to the moving object's direction of travel.\nA gap is created in the split object, matching the dimension of the moving object along the split axis.\nThe two halves of the split object are shifted outwards from this gap, each by half the gap's dimension.\nThe moving object ends up positioned at the edge it moved towards, aligned with its original position along the axis parallel to its movement.\nThe stable object remains unchanged.\nThe output grid is composed of the stable object in its original place, the two pieces of the split object in their new shifted positions, and the moving object in its final position at the edge, all on the original background color.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        dict: A dictionary where keys are colors (int) and values are lists of sets,\n              each set containing (row, col) tuples for a distinct object of that color.\n              Example: {1: [{(0,0), (0,1)}, {(2,2)}], 2: [{(1,1)}]}\n    \"\"\"\n    objects = defaultdict(list)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects[color].append(obj_pixels)\n    return objects\n\ndef get_object_properties(obj_pixels):\n    \"\"\"\n    Calculates properties for a given set of object pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        dict: A dictionary containing 'pixels', 'bbox' (min_r, min_c, max_r, max_c),\n              'center' (center_r, center_c), 'height', 'width'. Returns None if obj_pixels is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n        \n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    \n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    center_r = (min_r + max_r) / 2\n    center_c = (min_c + max_c) / 2\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    return {\n        'pixels': obj_pixels,\n        'bbox': (min_r, min_c, max_r, max_c),\n        'center': (center_r, center_c),\n        'height': height,\n        'width': width\n    }\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the identified transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Find background color (most frequent color)\n    background_color = Counter(input_np.flatten()).most_common(1)[0][0]\n\n    # 2. Find all distinct objects and their properties\n    objects_by_color = find_objects(input_np, background_color)\n    all_objects = []\n    for color, obj_list in objects_by_color.items():\n        for obj_pixels in obj_list:\n            props = get_object_properties(obj_pixels)\n            if props:\n                all_objects.append({'color': color, **props})\n\n    if len(all_objects) != 3:\n        # This specific task assumes exactly 3 objects besides background\n        print(f\"Warning: Expected 3 objects, found {len(all_objects)}. Returning input.\")\n        return input_grid \n\n    # 3. Identify roles: stable, moving, split\n    # Hypothesis: Moving object's center is between the other two along one axis.\n    moving_obj, stable_obj, split_obj = None, None, None\n    identified_axis = None # 'row' or 'col' where the mover is between others\n\n    for i in range(3):\n        potential_mover = all_objects[i]\n        others = [all_objects[j] for j in range(3) if i != j]\n        obj_a, obj_b = others[0], others[1]\n\n        # Check if mover is between a and b vertically\n        mover_r, mover_c = potential_mover['center']\n        a_r, a_c = obj_a['center']\n        b_r, b_c = obj_b['center']\n\n        is_between_rows = (a_r < mover_r < b_r) or (b_r < mover_r < a_r)\n        # Check rough alignment horizontally (centers are relatively close, or bboxes overlap)\n        cols_overlap = max(potential_mover['bbox'][1], obj_a['bbox'][1], obj_b['bbox'][1]) - \\\n                       min(potential_mover['bbox'][3], obj_a['bbox'][3], obj_b['bbox'][3]) <= (potential_mover['width'] + obj_a['width'] + obj_b['width']) # A loose check\n\n        if is_between_rows and cols_overlap: # Found potential vertical alignment\n            moving_obj = potential_mover\n            # Determine which is split and stable based on which side the mover is likely to move (towards nearest edge HORIZONTALLY)\n            dist_left = moving_obj['bbox'][1]\n            dist_right = cols - 1 - moving_obj['bbox'][3]\n            if dist_left < dist_right: # Moving left\n                split_obj = obj_a if a_c < b_c else obj_b \n                stable_obj = obj_b if a_c < b_c else obj_a\n            else: # Moving right\n                split_obj = obj_a if a_c > b_c else obj_b\n                stable_obj = obj_b if a_c > b_c else obj_a\n            identified_axis = 'row' # Mover is between others along row axis\n            break \n\n        # Check if mover is between a and b horizontally\n        is_between_cols = (a_c < mover_c < b_c) or (b_c < mover_c < a_c)\n        # Check rough alignment vertically\n        rows_overlap = max(potential_mover['bbox'][0], obj_a['bbox'][0], obj_b['bbox'][0]) - \\\n                       min(potential_mover['bbox'][2], obj_a['bbox'][2], obj_b['bbox'][2]) <= (potential_mover['height'] + obj_a['height'] + obj_b['height'])\n\n        if is_between_cols and rows_overlap: # Found potential horizontal alignment\n            moving_obj = potential_mover\n             # Determine which is split and stable based on which side the mover is likely to move (towards nearest edge VERTICALLY)\n            dist_up = moving_obj['bbox'][0]\n            dist_down = rows - 1 - moving_obj['bbox'][2]\n            if dist_up < dist_down: # Moving up\n                 split_obj = obj_a if a_r < b_r else obj_b\n                 stable_obj = obj_b if a_r < b_r else obj_a\n            else: # Moving down\n                 split_obj = obj_a if a_r > b_r else obj_b\n                 stable_obj = obj_b if a_r > b_r else obj_a\n            identified_axis = 'col' # Mover is between others along col axis\n            break\n\n    if not moving_obj:\n        # Fallback or error if roles couldn't be identified\n        print(\"Warning: Could not identify object roles based on position. Returning input.\")\n        return input_grid\n        \n    # 4. Determine movement direction\n    mover_min_r, mover_min_c, mover_max_r, mover_max_c = moving_obj['bbox']\n    direction = None\n    if identified_axis == 'row': # Mover between others vertically, so moves horizontally\n        dist_left = mover_min_c\n        dist_right = cols - 1 - mover_max_c\n        direction = 'Left' if dist_left <= dist_right else 'Right'\n    elif identified_axis == 'col': # Mover between others horizontally, so moves vertically\n        dist_up = mover_min_r\n        dist_down = rows - 1 - mover_max_r\n        direction = 'Up' if dist_up <= dist_down else 'Down'\n    else:\n         # Should not happen if roles were identified correctly\n         print(\"Error: Could not determine movement direction.\")\n         return input_grid\n\n\n    # 5. Determine split axis (perpendicular to movement)\n    split_axis = 'Vertical' if direction in ['Left', 'Right'] else 'Horizontal'\n\n    # 6. Calculate gap size and location based on MOVER's original position\n    gap_dim = 0\n    gap_indices = set()\n    if split_axis == 'Horizontal':\n        gap_dim = moving_obj['width']\n        gap_indices = set(range(mover_min_c, mover_max_c + 1)) # Columns defining the gap\n    else: # Vertical split\n        gap_dim = moving_obj['height']\n        gap_indices = set(range(mover_min_r, mover_max_r + 1)) # Rows defining the gap\n        \n    if gap_dim == 0:\n         print(\"Error: Calculated gap dimension is zero.\")\n         return input_grid\n\n    # 7. Calculate shift distance (integer division)\n    # Need careful handling if gap_dim is odd, but examples suggest even dimensions.\n    # Let's assume integer division works as intended by the task design.\n    shift = gap_dim // 2 \n    if shift == 0 and gap_dim == 1: # Handle single-pixel dimension gap\n        shift = 1 # Split by pushing one side by 1\n\n    # 8. Initialize output grid\n    output_grid = np.full_like(input_np, background_color)\n\n    # 9. Draw stable object\n    for r, c in stable_obj['pixels']:\n        output_grid[r, c] = stable_obj['color']\n\n    # 10. Draw split object pieces\n    split_color = split_obj['color']\n    for r, c in split_obj['pixels']:\n        nr, nc = r, c\n        if split_axis == 'Horizontal':\n            min_gap_idx = min(gap_indices)\n            max_gap_idx = max(gap_indices)\n            if c < min_gap_idx: # Pixel is to the left of the gap\n                nc = c - shift\n            elif c > max_gap_idx: # Pixel is to the right of the gap\n                nc = c + shift\n            # Pixels originally *in* the gap area are removed (not drawn)\n            else: \n                continue \n        else: # Vertical split\n            min_gap_idx = min(gap_indices)\n            max_gap_idx = max(gap_indices)\n            if r < min_gap_idx: # Pixel is above the gap\n                nr = r - shift\n            elif r > max_gap_idx: # Pixel is below the gap\n                nr = r + shift\n            # Pixels originally *in* the gap area are removed\n            else:\n                continue\n        \n        # Draw pixel if within bounds\n        if 0 <= nr < rows and 0 <= nc < cols:\n            output_grid[nr, nc] = split_color\n\n    # 11. Calculate final position of moving object at the edge\n    final_r, final_c = -1, -1\n    mover_h, mover_w = moving_obj['height'], moving_obj['width']\n    mover_color = moving_obj['color']\n\n    if direction == 'Up':\n        final_r, final_c = 0, mover_min_c\n    elif direction == 'Down':\n        final_r, final_c = rows - mover_h, mover_min_c\n    elif direction == 'Left':\n        final_r, final_c = mover_min_r, 0\n    elif direction == 'Right':\n        final_r, final_c = mover_min_r, cols - mover_w\n        \n    # 12. Draw moving object at its final position\n    for r_offset in range(mover_h):\n        for c_offset in range(mover_w):\n            # Check if the relative position corresponds to an original pixel of the mover\n            original_pixel = (mover_min_r + r_offset, mover_min_c + c_offset)\n            if original_pixel in moving_obj['pixels']:\n                 target_r, target_c = final_r + r_offset, final_c + c_offset\n                 if 0 <= target_r < rows and 0 <= target_c < cols:\n                    output_grid[target_r, target_c] = mover_color\n\n\n    # 13. Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3995,
    "candidates_token_count": 3490,
    "total_token_count": 7485,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.093944
}