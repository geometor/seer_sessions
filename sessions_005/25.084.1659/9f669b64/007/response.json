{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\nimport sys\nimport math\n\n# Optional: Set higher recursion depth if deep object searches are needed,\n# but BFS (implemented below) is generally preferred and avoids recursion limits.\n# sys.setrecursionlimit(2000)\n\n\"\"\"\nAnalyzes three non-background objects in a grid. One object (mover) is positioned between the other two along a primary axis (vertical or horizontal), and its span along the perpendicular axis overlaps with both other objects' spans along that perpendicular axis. The mover moves towards the closer of the other two objects (split_object) along the primary axis until it reaches the grid edge. The split_object is split perpendicular to the mover's path, creating a gap aligned with the mover's dimension along that perpendicular axis. The resulting pieces of the split_object are shifted away from the gap along the primary axis by ceil(mover's dimension perpendicular to path / 2). The third object (stable_object) remains unchanged. The output grid shows the stable_object, the shifted split_object pieces, and the mover at the grid edge.\n\nNote: The rule for determining the 'split_object' (and thus direction) based on proximity might be incorrect, as suggested by Example 2. This implementation uses the proximity rule ('closer' object is the split_object). If results are inconsistent, this rule needs re-evaluation.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of the same color in the grid using BFS (4-way connectivity).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        dict: A dictionary where keys are colors (int) and values are lists of sets,\n              each set containing (row, col) tuples for a distinct object of that color.\n    \"\"\"\n    objects = defaultdict(list)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)] # Use list as a queue for BFS\n                visited[r, c] = True\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    obj_pixels.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    objects[color].append(obj_pixels)\n    return objects\n\ndef get_object_properties(obj_pixels):\n    \"\"\"\n    Calculates properties for a given set of object pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        dict: A dictionary containing 'pixels', 'bbox' (min_r, min_c, max_r, max_c),\n              'center' (center_r, center_c), 'height', 'width'. Returns None if obj_pixels is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Use geometric center of the bounding box\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    return {\n        'pixels': obj_pixels,\n        'bbox': (min_r, min_c, max_r, max_c),\n        'center': (center_r, center_c),\n        'height': height,\n        'width': width\n    }\n\ndef check_overlap(bbox1, bbox2, axis):\n    \"\"\" Checks if two bounding boxes overlap along a specified axis ('vertical' for rows, 'horizontal' for columns). \"\"\"\n    if axis == 'horizontal': # Check column overlap\n        min1, max1 = bbox1[1], bbox1[3]\n        min2, max2 = bbox2[1], bbox2[3]\n    elif axis == 'vertical': # Check row overlap\n        min1, max1 = bbox1[0], bbox1[2]\n        min2, max2 = bbox2[0], bbox2[2]\n    else:\n        return False\n    # Overlap exists if the interval [max(min1, min2), min(max1, max2)] is valid\n    return max(min1, min2) <= min(max1, max2)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the background color (most frequent color).\n    counts = Counter(input_np.flatten())\n    background_color = counts.most_common(1)[0][0] if counts else 0 # Default to 0 if grid is empty\n\n    # 2. Find all distinct, contiguous non-background objects and calculate their properties.\n    objects_by_color = find_objects(input_np, background_color)\n    all_objects = []\n    for color, obj_list in objects_by_color.items():\n        for obj_pixels in obj_list:\n            props = get_object_properties(obj_pixels)\n            if props:\n                all_objects.append({'color': color, **props})\n\n    # Ensure exactly three such objects exist.\n    if len(all_objects) != 3:\n        # print(f\"Warning: Expected 3 objects, found {len(all_objects)}. Returning input.\")\n        return input_grid # Return original grid if rule assumption fails\n\n    # 3. Determine the roles of the three objects (mover, split_object, stable_object) and the axis/direction of movement.\n    mover = None\n    stable = None\n    split_obj = None\n    direction = None\n    movement_axis = None # 'vertical' or 'horizontal'\n\n    for i in range(3):\n        potential_mover = all_objects[i]\n        others = [all_objects[j] for j in range(3) if i != j]\n        obj_a, obj_b = others[0], others[1]\n\n        mover_r, mover_c = potential_mover['center']\n        mover_bbox = potential_mover['bbox']\n        a_r, a_c = obj_a['center']\n        a_bbox = obj_a['bbox']\n        b_r, b_c = obj_b['center']\n        b_bbox = obj_b['bbox']\n\n        # a. Check for vertical alignment and horizontal overlap\n        is_between_rows = (a_r < mover_r < b_r) or (b_r < mover_r < a_r)\n        mover_overlaps_a_cols = check_overlap(mover_bbox, a_bbox, 'horizontal')\n        mover_overlaps_b_cols = check_overlap(mover_bbox, b_bbox, 'horizontal')\n\n        if is_between_rows and mover_overlaps_a_cols and mover_overlaps_b_cols:\n            mover = potential_mover\n            movement_axis = 'vertical'\n            # b. Determine Split (closer) and Stable (further) based on center distance along the alignment axis\n            dist_a = abs(a_r - mover_r)\n            dist_b = abs(b_r - mover_r)\n            if dist_a <= dist_b: # Using <= to handle equidistant cases, arbitrarily choosing A\n                split_obj = obj_a\n                stable = obj_b\n                direction = 'Up' if a_r < mover_r else 'Down'\n            else:\n                split_obj = obj_b\n                stable = obj_a\n                direction = 'Up' if b_r < mover_r else 'Down'\n            break # Roles identified\n\n        # c. If no vertical alignment, check for horizontal alignment and vertical overlap\n        is_between_cols = (a_c < mover_c < b_c) or (b_c < mover_c < a_c)\n        mover_overlaps_a_rows = check_overlap(mover_bbox, a_bbox, 'vertical')\n        mover_overlaps_b_rows = check_overlap(mover_bbox, b_bbox, 'vertical')\n\n        if is_between_cols and mover_overlaps_a_rows and mover_overlaps_b_rows:\n            mover = potential_mover\n            movement_axis = 'horizontal'\n            # d. Determine Split (closer) and Stable (further) based on center distance along the alignment axis\n            dist_a = abs(a_c - mover_c)\n            dist_b = abs(b_c - mover_c)\n            if dist_a <= dist_b: # Using <= to handle equidistant cases\n                split_obj = obj_a\n                stable = obj_b\n                direction = 'Left' if a_c < mover_c else 'Right'\n            else:\n                split_obj = obj_b\n                stable = obj_a\n                direction = 'Left' if b_c < mover_c else 'Right'\n            break # Roles identified\n\n    # e. If neither alignment is found, the rule may not apply.\n    if not mover or not stable or not split_obj:\n        # print(\"Warning: Could not definitively identify object roles based on alignment and overlap. Returning input.\")\n        return input_grid\n\n    # 4. Create a new grid filled with the background color, matching the input dimensions.\n    output_grid = np.full_like(input_np, background_color)\n\n    # 5. Place the `stable_object` onto the new grid at its original location.\n    for r, c in stable['pixels']:\n        if 0 <= r < rows and 0 <= c < cols:\n             output_grid[r, c] = stable['color']\n\n    # 6. Process the `split_object` using the corrected logic.\n    split_color = split_obj['color']\n    mover_min_r, mover_min_c, mover_max_r, mover_max_c = mover['bbox']\n\n    if movement_axis == 'vertical':\n        # Movement is Up/Down. Split is horizontal. Gap uses mover's width. Shift is vertical.\n        gap_extent = mover['width'] # Dimension along perpendicular axis (horizontal)\n        shift = math.ceil(gap_extent / 2)\n        gap_range = (mover_min_c, mover_max_c) # Column range for the gap\n\n        for r, c in split_obj['pixels']:\n            nr, nc = r, c\n            # Check if pixel is vertically aligned with the gap\n            if gap_range[0] <= c <= gap_range[1]:\n                 # Determine shift direction based on mover's movement direction\n                if direction == 'Up': # Mover moves Up, split pieces shift Up/Down away from center\n                    if r < mover['center'][0]: # Pixel is above mover's center (relative to split obj) - shift Up\n                        nr = r - shift\n                    else: # Pixel is below or at mover's center - shift Down\n                         nr = r + shift\n                else: # direction == 'Down'. Mover moves Down.\n                    if r > mover['center'][0]: # Pixel is below mover's center - shift Down\n                        nr = r + shift\n                    else: # Pixel is above or at mover's center - shift Up\n                        nr = r - shift\n            # Pixels not aligned with gap horizontally are kept in place relative to shift axis\n            # No, the specification implies *all* pixels shift if they aren't removed by the gap.\n            # Let's re-read: \"split perpendicular ... creating a gap ... resulting pieces ... shifted away\"\n            # This implies two pieces are formed and both shift.\n\n            # Let's try the new interpretation: Split perpendicular to movement. Shift parallel to movement.\n            # If movement is Vertical (Up/Down), split is Horizontal.\n            # Split line is related to mover's vertical position relative to split object.\n            # This seems overly complex. Let's use the interpretation from YAML analysis.\n\n            # --- Start Revised Split Logic ---\n            # Split Axis: Perpendicular to Movement Axis.\n            # Gap Location: Corresponds to Mover's span along the Perpendicular Axis.\n            # Shift Axis: Parallel to Movement Axis.\n            # Shift Amount: ceil(Mover_Dimension_Along_Perpendicular_Axis / 2).\n\n            # Movement = Vertical (Up/Down)\n            # Perpendicular Axis = Horizontal\n            # Split = Vertical cut\n            # Gap Range = Columns covered by mover (mover_min_c to mover_max_c)\n            # Shift = Horizontal shift\n            # Shift Amount = ceil(mover_width / 2)\n\n            if c < gap_range[0]:   # Pixel is left of the gap\n                nc = c - shift\n            elif c > gap_range[1]: # Pixel is right of the gap\n                nc = c + shift\n            else: # Pixel is within the horizontal range of the gap, discard it\n                continue # Discard pixel within the gap columns\n\n            # Draw shifted pixel if within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = split_color\n            # --- End Revised Split Logic ---\n\n\n    else: # movement_axis == 'horizontal'\n        # Movement is Left/Right. Split is vertical. Gap uses mover's height. Shift is horizontal.\n        gap_extent = mover['height'] # Dimension along perpendicular axis (vertical)\n        shift = math.ceil(gap_extent / 2)\n        gap_range = (mover_min_r, mover_max_r) # Row range for the gap\n\n        for r, c in split_obj['pixels']:\n            nr, nc = r, c\n\n            # --- Start Revised Split Logic ---\n            # Movement = Horizontal (Left/Right)\n            # Perpendicular Axis = Vertical\n            # Split = Horizontal cut\n            # Gap Range = Rows covered by mover (mover_min_r to mover_max_r)\n            # Shift = Vertical shift\n            # Shift Amount = ceil(mover_height / 2)\n\n            if r < gap_range[0]:   # Pixel is above the gap\n                nr = r - shift\n            elif r > gap_range[1]: # Pixel is below the gap\n                nr = r + shift\n            else: # Pixel is within the vertical range of the gap, discard it\n                continue # Discard pixel within the gap rows\n\n            # Draw shifted pixel if within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = split_color\n            # --- End Revised Split Logic ---\n\n\n    # 7. Determine the final position of the `mover` object at the grid edge.\n    mover_color = mover['color']\n    mover_h = mover['height']\n    mover_w = mover['width']\n    mover_orig_min_r, mover_orig_min_c = mover['bbox'][0], mover['bbox'][1]\n    final_min_r, final_min_c = -1, -1 # Top-left corner of the mover's final bbox\n\n    if direction == 'Up':\n        final_min_r, final_min_c = 0, mover_orig_min_c # Top edge, same columns\n    elif direction == 'Down':\n        final_min_r, final_min_c = rows - mover_h, mover_orig_min_c # Bottom edge, same columns\n    elif direction == 'Left':\n        final_min_r, final_min_c = mover_orig_min_r, 0 # Left edge, same rows\n    elif direction == 'Right':\n        final_min_r, final_min_c = mover_orig_min_r, cols - mover_w # Right edge, same rows\n    else:\n         # Should not happen if roles/direction were identified\n         # print(\"Error: Invalid movement direction determined.\")\n         return input_grid # Or raise error\n\n    # 8. Draw the `mover` object onto the new grid at its calculated final position.\n    # Iterate through the original relative coordinates within the mover's bbox\n    for r_offset in range(mover_h):\n        for c_offset in range(mover_w):\n            # Check if this relative position corresponds to an actual pixel of the mover\n            original_pixel = (mover_orig_min_r + r_offset, mover_orig_min_c + c_offset)\n            if original_pixel in mover['pixels']:\n                # Calculate target position in the output grid\n                target_r = final_min_r + r_offset\n                target_c = final_min_c + c_offset\n                # Draw if within bounds\n                if 0 <= target_r < rows and 0 <= target_c < cols:\n                    output_grid[target_r, target_c] = mover_color\n\n    # 9. Return the new grid.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12046,
    "candidates_token_count": 4150,
    "total_token_count": 16196,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 99.121526
}