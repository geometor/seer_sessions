{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\nimport sys\nimport math\n\n# Optional: Set higher recursion depth if deep object searches are needed,\n# but BFS (implemented below) is generally preferred and avoids recursion limits.\n# sys.setrecursionlimit(2000)\n\n\"\"\"\nIdentifies three non-background objects aligned along a primary axis (vertical or horizontal).\nOne object (mover) is positioned between the other two.\nThe mover moves towards the closer of the other two objects (the split object), continuing to the nearest grid edge along that path.\nThe split object is divided perpendicular to the mover's path.\nA gap is created in the split object, matching the mover's dimension along the split axis.\nThe pieces of the split object shift away from this gap.\nThe third object (stable) remains unchanged.\nThe output grid contains the stable object, the shifted pieces of the split object, and the mover at its final position on the edge.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of the same color in the grid using BFS (4-way connectivity).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        dict: A dictionary where keys are colors (int) and values are lists of sets,\n              each set containing (row, col) tuples for a distinct object of that color.\n    \"\"\"\n    objects = defaultdict(list)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)] # Use list as a queue for BFS\n                visited[r, c] = True\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    obj_pixels.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    objects[color].append(obj_pixels)\n    return objects\n\ndef get_object_properties(obj_pixels):\n    \"\"\"\n    Calculates properties for a given set of object pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        dict: A dictionary containing 'pixels', 'bbox' (min_r, min_c, max_r, max_c),\n              'center' (center_r, center_c), 'height', 'width'. Returns None if obj_pixels is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Use geometric center of the bounding box\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    return {\n        'pixels': obj_pixels,\n        'bbox': (min_r, min_c, max_r, max_c),\n        'center': (center_r, center_c),\n        'height': height,\n        'width': width\n    }\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Find background color (most frequent color)\n    background_color = Counter(input_np.flatten()).most_common(1)[0][0]\n\n    # 2. Find all distinct objects and their properties\n    objects_by_color = find_objects(input_np, background_color)\n    all_objects = []\n    for color, obj_list in objects_by_color.items():\n        for obj_pixels in obj_list:\n            props = get_object_properties(obj_pixels)\n            if props:\n                all_objects.append({'color': color, **props})\n\n    # 3. Validate: Ensure exactly 3 objects\n    if len(all_objects) != 3:\n        print(f\"Warning: Expected 3 objects, found {len(all_objects)}. Returning input.\")\n        return input_grid\n\n    # 4. Identify Roles (Mover, Stable, Split) and Movement Direction\n    mover = None\n    stable = None\n    split_obj = None # Renamed from 'split' to avoid confusion with function name\n    direction = None\n    movement_axis = None # 'vertical' or 'horizontal'\n\n    for i in range(3):\n        potential_mover = all_objects[i]\n        others = [all_objects[j] for j in range(3) if i != j]\n        obj_a, obj_b = others[0], others[1]\n\n        mover_r, mover_c = potential_mover['center']\n        a_r, a_c = obj_a['center']\n        b_r, b_c = obj_b['center']\n\n        # Check for vertical alignment (mover between A and B vertically)\n        # Use a small tolerance for center comparison? No, strict betweenness seems intended.\n        is_between_rows = (a_r < mover_r < b_r) or (b_r < mover_r < a_r)\n        # Check rough horizontal overlap (their column ranges overlap significantly)\n        cols_overlap = max(potential_mover['bbox'][1], obj_a['bbox'][1], obj_b['bbox'][1]) < \\\n                       min(potential_mover['bbox'][3], obj_a['bbox'][3], obj_b['bbox'][3]) + 1\n\n        if is_between_rows and cols_overlap:\n            mover = potential_mover\n            movement_axis = 'vertical'\n            # Determine Split (closer) and Stable (further)\n            dist_a = abs(a_r - mover_r)\n            dist_b = abs(b_r - mover_r)\n            if dist_a < dist_b:\n                split_obj = obj_a\n                stable = obj_b\n            else:\n                split_obj = obj_b\n                stable = obj_a\n            # Determine direction towards split object\n            direction = 'Up' if split_obj['center'][0] < mover_r else 'Down'\n            break # Roles identified\n\n        # Check for horizontal alignment (mover between A and B horizontally)\n        is_between_cols = (a_c < mover_c < b_c) or (b_c < mover_c < a_c)\n        # Check rough vertical overlap\n        rows_overlap = max(potential_mover['bbox'][0], obj_a['bbox'][0], obj_b['bbox'][0]) < \\\n                       min(potential_mover['bbox'][2], obj_a['bbox'][2], obj_b['bbox'][2]) + 1\n\n        if is_between_cols and rows_overlap:\n            mover = potential_mover\n            movement_axis = 'horizontal'\n            # Determine Split (closer) and Stable (further)\n            dist_a = abs(a_c - mover_c)\n            dist_b = abs(b_c - mover_c)\n            if dist_a < dist_b:\n                split_obj = obj_a\n                stable = obj_b\n            else:\n                split_obj = obj_b\n                stable = obj_a\n             # Determine direction towards split object\n            direction = 'Left' if split_obj['center'][1] < mover_c else 'Right'\n            break # Roles identified\n\n    if not mover or not stable or not split_obj:\n        print(\"Warning: Could not definitively identify object roles based on alignment and proximity. Returning input.\")\n        return input_grid\n\n    # 5. Create the Output Grid\n    output_grid = np.full_like(input_np, background_color)\n\n    # 6. Place the Stable Object\n    for r, c in stable['pixels']:\n        # Check bounds just in case, though should be original position\n        if 0 <= r < rows and 0 <= c < cols:\n             output_grid[r, c] = stable['color']\n\n    # 7. Perform the Split and Shift on the Split Object\n    split_color = split_obj['color']\n    split_axis = 'Horizontal' if movement_axis == 'vertical' else 'Vertical'\n    mover_min_r, mover_min_c, mover_max_r, mover_max_c = mover['bbox']\n\n    if split_axis == 'Horizontal':\n        gap_dim = mover['width']\n        # Columns covered by the mover's bounding box define the gap\n        gap_indices = range(mover_min_c, mover_max_c + 1)\n        min_gap_idx = min(gap_indices)\n        max_gap_idx = max(gap_indices)\n        shift = (gap_dim + 1) // 2 # Integer division, handles odd gaps slightly better\n\n        for r, c in split_obj['pixels']:\n            nr, nc = r, c\n            if c < min_gap_idx:   # Pixel is left of the gap\n                nc = c - shift\n            elif c > max_gap_idx: # Pixel is right of the gap\n                nc = c + shift\n            else: # Pixel is within the horizontal range of the gap, remove it\n                continue\n\n            # Draw shifted pixel if within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = split_color\n\n    else: # Vertical split\n        gap_dim = mover['height']\n        # Rows covered by the mover's bounding box define the gap\n        gap_indices = range(mover_min_r, mover_max_r + 1)\n        min_gap_idx = min(gap_indices)\n        max_gap_idx = max(gap_indices)\n        shift = (gap_dim + 1) // 2\n\n        for r, c in split_obj['pixels']:\n            nr, nc = r, c\n            if r < min_gap_idx:   # Pixel is above the gap\n                nr = r - shift\n            elif r > max_gap_idx: # Pixel is below the gap\n                nr = r + shift\n            else: # Pixel is within the vertical range of the gap, remove it\n                continue\n\n            # Draw shifted pixel if within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = split_color\n\n    # 8. Place the Mover Object at the Target Edge\n    mover_color = mover['color']\n    mover_h = mover['height']\n    mover_w = mover['width']\n    final_min_r, final_min_c = -1, -1 # Top-left corner of the mover's final bbox\n\n    if direction == 'Up':\n        final_min_r, final_min_c = 0, mover_min_c\n    elif direction == 'Down':\n        final_min_r, final_min_c = rows - mover_h, mover_min_c\n    elif direction == 'Left':\n        final_min_r, final_min_c = mover_min_r, 0\n    elif direction == 'Right':\n        final_min_r, final_min_c = mover_min_r, cols - mover_w\n    else:\n         # Should not happen if roles/direction were identified\n         print(\"Error: Invalid movement direction determined.\")\n         return input_grid # Or raise error\n\n    # Copy mover pixels relative to its final position\n    # Iterate through the original relative coordinates within the mover's bbox\n    for r_offset in range(mover_h):\n        for c_offset in range(mover_w):\n            # Check if this relative position corresponds to an actual pixel of the mover\n            original_pixel = (mover_min_r + r_offset, mover_min_c + c_offset)\n            if original_pixel in mover['pixels']:\n                # Calculate target position in the output grid\n                target_r = final_min_r + r_offset\n                target_c = final_min_c + c_offset\n                # Draw if within bounds\n                if 0 <= target_r < rows and 0 <= target_c < cols:\n                    output_grid[target_r, target_c] = mover_color\n\n    # 9. Convert back to list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16300,
    "candidates_token_count": 3123,
    "total_token_count": 19423,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.104862
}