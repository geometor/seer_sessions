{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify all connected components of green pixels (value 3) using 4-way (von Neumann) adjacency.\n2. Select components with a size (number of pixels) of 3 or more.\n3. For each selected component:\n    a. Check if it consists *exactly* of 5 pixels forming a 2x2 square plus one additional green pixel connected (4-way) to exactly one pixel of the square (a \"tail\").\n    b. If it is the specific \"2x2 plus tail\" shape (size 5), mark only the 4 pixels forming the 2x2 square for color change.\n    c. Otherwise (if the component size is >= 3 but not the specific \"2x2 plus tail\" shape), mark all pixels in the component for color change.\n4. Change the color of all marked pixels from green (3) to azure (8).\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\nimport itertools\n\ndef find_connected_components_4way(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in a grid using 4-way connectivity.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int): The color of the pixels to form components.\n\n    Returns:\n        list: A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    # Define 4 directions for neighbors (no diagonals)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                current_component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                # Start Breadth-First Search (BFS)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_component.append((curr_r, curr_c))\n\n                    # Check all 4 neighbors\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor is the target color and not visited\n                            if grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Add the found component to the list\n                components.append(current_component)\n\n    return components\n\ndef check_if_2x2(coords):\n    \"\"\"Checks if a set of 4 coordinates forms a 2x2 square.\"\"\"\n    if len(coords) != 4: \n        return False\n    coords_set = set(coords)\n    rows = sorted(list(set(r for r, c in coords_set)))\n    cols = sorted(list(set(c for r, c in coords_set)))\n    # Must have exactly 2 unique rows and 2 unique columns\n    if len(rows) != 2 or len(cols) != 2: \n        return False\n    # Rows must be adjacent, cols must be adjacent\n    if rows[1] != rows[0] + 1 or cols[1] != cols[0] + 1: \n        return False\n    # Check if all 4 combinations exist by reconstructing the square\n    expected_coords = set([(r, c) for r in rows for c in cols])\n    return coords_set == expected_coords\n\ndef count_4way_neighbors_in_set(pixel, target_set):\n    \"\"\"Counts how many 4-way neighbors of pixel are in target_set.\"\"\"\n    r, c = pixel\n    count = 0\n    neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]\n    target_coords_set = set(target_set) # Ensure it's a set for efficient lookup\n    for nr, nc in neighbors:\n        if (nr, nc) in target_coords_set:\n            count += 1\n    return count\n\ndef is_2x2_plus_tail(component):\n    \"\"\"\n    Checks if a component is exactly a 2x2 square plus a single pixel tail \n    connected to exactly one square pixel (4-way).\n    \n    Args:\n        component (list): List of (row, col) tuples for the component pixels.\n\n    Returns:\n        tuple: (bool, list | None)\n               - bool: True if it matches the pattern, False otherwise.\n               - list | None: If True, returns the list of 4 coordinates \n                              forming the 2x2 square. Otherwise, None.\n    \"\"\"\n    if len(component) != 5:\n        return False, None\n    \n    component_set = set(component)\n    \n    # Iterate through all combinations of 4 pixels out of 5\n    for square_candidate_tuple in itertools.combinations(component, 4):\n        square_candidate_list = list(square_candidate_tuple)\n        if check_if_2x2(square_candidate_list):\n            # Found a potential 2x2 square within the component\n            square_candidate_set = set(square_candidate_list)\n            # Find the 5th pixel (tail)\n            tail_pixel = (component_set - square_candidate_set).pop() \n            \n            # Check if the tail is 4-way adjacent to exactly one pixel in the square\n            neighbor_count = count_4way_neighbors_in_set(tail_pixel, square_candidate_set)\n            \n            if neighbor_count == 1:\n                # Pattern matched!\n                return True, square_candidate_list \n                \n    # If no combination of 4 forms a square with the 5th attached correctly\n    return False, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on 4-way green components.\n    Changes components >= size 3, with special handling for \"2x2 plus tail\" shape.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Define colors\n    target_color = 3  # green\n    replacement_color = 8  # azure\n\n    # Find all 4-way connected components of green pixels\n    components = find_connected_components_4way(output_grid, target_color)\n\n    # Set to store coordinates of pixels to be changed\n    pixels_to_change = set()\n\n    # Process each component\n    for component in components:\n        # Only consider components of size 3 or more\n        if len(component) >= 3:\n            # Check for the special \"2x2 plus tail\" case (which requires size 5)\n            is_special_case, square_pixels = is_2x2_plus_tail(component)\n            \n            if is_special_case:\n                # If it's the special case, only mark the square pixels\n                pixels_to_change.update(square_pixels)\n            else:\n                # Otherwise, mark all pixels in the component\n                pixels_to_change.update(component)\n\n    # Apply the color change to the marked pixels\n    for r, c in pixels_to_change:\n        # Ensure the pixel is actually green before changing (safety check)\n        if output_grid[r, c] == target_color:\n            output_grid[r, c] = replacement_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10606,
    "candidates_token_count": 1848,
    "total_token_count": 12454,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.285424
}