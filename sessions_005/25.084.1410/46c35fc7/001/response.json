{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Identify connected components of non-orange (7) pixels using 8-way adjacency.\n2. For each component, determine its bounding box.\n3. If a component's bounding box is exactly 3x3 pixels in size:\n    a. Identify the 8 pixels forming the perimeter of this 3x3 box in the input grid.\n    b. Rotate the values of these 8 perimeter pixels one step counter-clockwise.\n    c. Place these rotated values into the corresponding perimeter positions in the output grid.\n    d. The central pixel of the 3x3 box remains unchanged.\n4. All pixels outside of these identified 3x3 bounding boxes remain unchanged from the input grid.\nThe output grid is initially a copy of the input grid, and modifications are applied based on the identified 3x3 components.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\ndef find_connected_components(grid: np.ndarray, background_color: int) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of non-background pixels using 8-way adjacency.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new component\n                component = []\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    component.append((row, col))\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue  # Skip self\n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds and if it's a non-background pixel and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != background_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                components.append(component)\n    return components\n\ndef get_bounding_box(component: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box of a component.\n\n    Args:\n        component: A list of (row, col) tuples representing the pixels of the component.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    if not component:\n        return -1, -1, -1, -1 # Or raise an error\n\n    rows = [p[0] for p in component]\n    cols = [p[1] for p in component]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef rotate_perimeter(input_grid: np.ndarray, output_grid: np.ndarray, r: int, c: int):\n    \"\"\"\n    Rotates the perimeter of the 3x3 subgrid starting at (r, c) counter-clockwise.\n    Reads from input_grid and writes to output_grid.\n\n    Args:\n        input_grid: The original input grid.\n        output_grid: The grid to be modified.\n        r: The top row index of the 3x3 box.\n        c: The left column index of the 3x3 box.\n    \"\"\"\n    # Store the original perimeter values from the input_grid\n    p = [\n        input_grid[r, c],     input_grid[r, c+1],   input_grid[r, c+2],\n        input_grid[r+1, c+2], input_grid[r+2, c+2], input_grid[r+2, c+1],\n        input_grid[r+2, c],   input_grid[r+1, c]\n    ]\n\n    # Apply rotated values to the output_grid perimeter\n    output_grid[r, c]   = p[2]  # Top-Right   -> Top-Left\n    output_grid[r, c+1] = p[7]  # Middle-Left -> Top-Center\n    output_grid[r, c+2] = p[4]  # Bottom-Right-> Top-Right\n    output_grid[r+1, c] = p[6]  # Bottom-Left -> Middle-Left\n    # Center output_grid[r+1, c+1] remains unchanged (already copied)\n    output_grid[r+1, c+2]= p[1]  # Top-Center  -> Middle-Right\n    output_grid[r+2, c] = p[0]  # Top-Left    -> Bottom-Left\n    output_grid[r+2, c+1]= p[3]  # Middle-Right-> Bottom-Center\n    output_grid[r+2, c+2]= p[5]  # Bottom-Center->Bottom-Right\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by finding 3x3 components of non-orange pixels\n    and rotating their perimeters counter-clockwise.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input_grid\n    output_grid = np.copy(input_grid)\n    \n    # Define background color\n    background_color = 7\n\n    # Find all connected components of non-background pixels\n    components = find_connected_components(input_grid, background_color)\n\n    # Process each component\n    for component in components:\n        if not component:\n            continue\n            \n        # Calculate the bounding box\n        min_r, min_c, max_r, max_c = get_bounding_box(component)\n\n        # Check if the bounding box is exactly 3x3\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        if height == 3 and width == 3:\n            # If it's a 3x3 box, rotate its perimeter\n            # The rotation uses values from the original input_grid\n            # and writes the results to the output_grid.\n            rotate_perimeter(input_grid, output_grid, min_r, min_c)\n            # Note: The center pixel output_grid[min_r+1, min_c+1] is already\n            # correct because output_grid started as a copy of input_grid.\n\n    # Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3040,
    "candidates_token_count": 1663,
    "total_token_count": 4703,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.251521
}