{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies rectangular regions separated by yellow (4) lines.\nWithin these regions, identifies 'source' regions containing exactly one pixel of a color other than white (0), blue (1), or yellow (4).\nIdentifies 'target' regions containing blue (1) pixels and no 'source' color pixels.\nDetermines a mapping between target regions and source regions based on adjacency across a yellow separator (either horizontally or vertically).\nCreates an output grid where all blue (1) pixels within each target region are replaced by the color found in its corresponding source region.\nAll other pixels (white, yellow, source colors) remain unchanged.\n\"\"\"\n\ndef find_regions(grid):\n    \"\"\"\n    Identifies rectangular regions bounded by yellow (4) lines or grid edges.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a region's boundaries\n              as (start_row, end_row_exclusive, start_col, end_col_exclusive).\n    \"\"\"\n    height, width = grid.shape\n    # Find horizontal separator rows (full yellow line)\n    h_seps = [-1] + [r for r in range(height) if np.all(grid[r, :] == 4)] + [height]\n    # Find vertical separator columns (full yellow line)\n    v_seps = [-1] + [c for c in range(width) if np.all(grid[:, c] == 4)] + [width]\n\n    regions = []\n    # Iterate through horizontal bands defined by h_seps\n    for i in range(len(h_seps) - 1):\n        r_start = h_seps[i] + 1\n        r_end = h_seps[i+1] # exclusive end\n        # Skip zero-height bands caused by adjacent separators\n        if r_start >= r_end: continue\n\n        # Iterate through vertical bands defined by v_seps\n        for j in range(len(v_seps) - 1):\n            c_start = v_seps[j] + 1\n            c_end = v_seps[j+1] # exclusive end\n            # Skip zero-width bands caused by adjacent separators\n            if c_start >= c_end: continue\n\n            # Store region boundaries using exclusive upper bounds, common for slicing\n            regions.append((r_start, r_end, c_start, c_end))\n    return regions\n\ndef find_source_and_target_regions(grid, regions):\n    \"\"\"\n    Categorizes regions into source regions and target regions.\n\n    Args:\n        grid (np.array): The input grid.\n        regions (list): A list of region boundaries.\n\n    Returns:\n        tuple: (source_regions, target_regions)\n               source_regions (dict): Maps region coordinates tuple to its source color.\n               target_regions (list): A list of region coordinates tuples for target regions.\n    \"\"\"\n    source_regions_map = {} # Map region_coords -> source_color\n    target_regions_list = [] # List of region_coords\n\n    # First pass: Identify Source Regions\n    for r_start, r_end, c_start, c_end in regions:\n        region_coords = (r_start, r_end, c_start, c_end)\n        subgrid = grid[r_start:r_end, c_start:c_end]\n        if subgrid.size == 0: continue # Skip empty regions\n\n        source_pixels = []\n        # Find all pixels within the region that are not white(0), blue(1), or yellow(4)\n        for r in range(r_start, r_end):\n            for c in range(c_start, c_end):\n                color = grid[r, c]\n                if color not in [0, 1, 4]:\n                    source_pixels.append(color)\n\n        # A source region has exactly one such pixel\n        if len(source_pixels) == 1:\n            source_regions_map[region_coords] = source_pixels[0]\n\n    # Second pass: Identify Target Regions\n    source_region_coords_set = set(source_regions_map.keys())\n    for r_start, r_end, c_start, c_end in regions:\n        region_coords = (r_start, r_end, c_start, c_end)\n        # Skip regions already identified as source regions\n        if region_coords in source_region_coords_set: continue\n\n        subgrid = grid[r_start:r_end, c_start:c_end]\n        if subgrid.size == 0: continue\n\n        # Check if the region contains any blue pixels\n        has_blue = 1 in np.unique(subgrid)\n\n        if has_blue:\n            # Verify that the region contains *no* source-like colors\n            # (This check is slightly redundant if source regions are correctly ID'd, but adds robustness)\n            has_source_color = False\n            for r in range(r_start, r_end):\n                for c in range(c_start, c_end):\n                    if grid[r,c] not in [0, 1, 4]:\n                        has_source_color = True\n                        break\n                if has_source_color: break\n\n            # If it has blue and no source colors, it's a target region\n            if not has_source_color:\n                target_regions_list.append(region_coords)\n\n    return source_regions_map, target_regions_list\n\ndef map_regions(grid, source_regions, target_regions):\n    \"\"\"\n    Finds the corresponding source region for each target region based on adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        source_regions (dict): Map of source region coords to source color.\n        target_regions (list): List of target region coords.\n\n    Returns:\n        dict: Maps target region coordinates tuple to the corresponding source color.\n    \"\"\"\n    target_to_source_color = {}\n\n    for tr_coords in target_regions:\n        tr_r_start, tr_r_end, tr_c_start, tr_c_end = tr_coords\n        found_match = False\n        for sr_coords, sr_color in source_regions.items():\n            sr_r_start, sr_r_end, sr_c_start, sr_c_end = sr_coords\n\n            # Check 1: Horizontal alignment (same row band) and vertical adjacency\n            if tr_r_start == sr_r_start and tr_r_end == sr_r_end:\n                is_adjacent_h = False\n                # Case 1a: Source is immediately left of Target\n                if sr_c_end == tr_c_start:\n                    sep_col = tr_c_start - "
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3071,
    "candidates_token_count": 1591,
    "total_token_count": 4662,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 185.221282
}