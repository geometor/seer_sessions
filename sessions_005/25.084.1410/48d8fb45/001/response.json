{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_coords_of_color(grid, color):\n    \"\"\"Finds all coordinates (row, col) of a given color in the grid.\"\"\"\n    coords = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                coords.append((r, c))\n    return coords\n\ndef find_primary_color(grid):\n    \"\"\"Finds the first color in the grid that is not white (0) or gray (5).\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and color != 5:\n                return color\n    return None # Should not happen based on task description\n\ndef find_contiguous_object(grid, start_coords_set, target_color):\n    \"\"\"\n    Finds all connected pixels of target_color starting from any coordinate\n    in start_coords_set using Breadth-First Search (BFS).\n    Includes the start_coords themselves if they match the target_color.\n    \"\"\"\n    if not start_coords_set:\n        return set()\n\n    rows, cols = grid.shape\n    object_coords = set()\n    queue = deque()\n    visited = set()\n\n    # Initialize queue and visited with starting coordinates\n    # that actually match the target color\n    for r, c in start_coords_set:\n         if 0 <= r < rows and 0 <= c < cols and grid[r,c] == target_color and (r,c) not in visited:\n            queue.append((r, c))\n            visited.add((r,c))\n\n    while queue:\n        r, c = queue.popleft()\n        object_coords.add((r, c))\n\n        # Check 8 neighbors (including diagonals)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue  # Skip self\n\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if neighbor has target color and hasn't been visited\n                    if grid[nr, nc] == target_color and (nr, nc) not in visited:\n                        visited.add((nr, nc))\n                        queue.append((nr, nc))\n\n    return object_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following logic:\n    1. Finds the single gray pixel (5).\n    2. Determines the primary color (non-white, non-gray).\n    3. Identifies the primary color object adjacent (including diagonals) to the gray pixel.\n    4. Calculates the bounding box of this selected object.\n    5. Creates an output grid matching the bounding box size.\n    6. Copies the shape of the selected object into the output grid, relative to its top-left corner.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Find the single gray pixel (5)\n    gray_coords_list = find_coords_of_color(grid, 5)\n    if not gray_coords_list:\n        # Handle error: No gray pixel found (though task implies one exists)\n        return [] # Or raise an error\n    gray_r, gray_c = gray_coords_list[0]\n\n    # 2. Determine the primary color\n    primary_color = find_primary_color(grid)\n    if primary_color is None:\n        # Handle error: No primary color found\n        return [] # Or raise an error\n\n    # 3. Identify the primary color object adjacent to the gray pixel\n    # Find initial neighbors of the gray pixel that have the primary color\n    start_primary_coords = set()\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = gray_r + dr, gray_c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == primary_color:\n                start_primary_coords.add((nr, nc))\n\n    # Find the full contiguous object starting from these neighbors\n    selected_object_coords = find_contiguous_object(grid, start_primary_coords, primary_color)\n\n    if not selected_object_coords:\n         # Handle case where gray is not adjacent to any primary color pixel\n         # Based on examples, this shouldn't happen. If it does, return empty grid?\n         # Or maybe the gray pixel itself defines a 1x1 object if no neighbors?\n         # Let's assume based on examples an adjacent object is always found.\n         # If this assumption is wrong, the code might need adjustment.\n         # For now, return an empty grid if no object found.\n         return []\n\n\n    # 4. Calculate the minimum bounding box\n    min_r = min(r for r, c in selected_object_coords)\n    max_r = max(r for r, c in selected_object_coords)\n    min_c = min(c for r, c in selected_object_coords)\n    max_c = max(c for r, c in selected_object_coords)\n\n    # 5. Determine the height and width and create the output grid\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    output_grid = np.zeros((height, width), dtype=int) # Fill with white (0)\n\n    # 6. Map the selected object pixels to the output grid\n    for r, c in selected_object_coords:\n        relative_r = r - min_r\n        relative_c = c - min_c\n        output_grid[relative_r, relative_c] = primary_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2722,
    "candidates_token_count": 1441,
    "total_token_count": 4163,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.693655
}