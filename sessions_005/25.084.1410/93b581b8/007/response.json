{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by first copying it, then identifying a unique 2x2 \nnon-background (non-white) object within the original grid. Four new 2x2 \nsolid-colored squares are drawn onto the copied grid's corners, overwriting \nany existing content. The color of each corner square is determined by the \ncolor of the diagonally opposite pixel within the identified 2x2 object:\n- Top-left output corner gets the color of the input object's bottom-right pixel.\n- Top-right output corner gets the color of the input object's bottom-left pixel.\n- Bottom-left output corner gets the color of the input object's top-right pixel.\n- Bottom-right output corner gets the color of the input object's top-left pixel.\n\"\"\"\n\nimport numpy as np\n\ndef find_2x2_object(grid):\n    \"\"\"\n    Finds the top-left corner coordinates (r, c) of the first 2x2 block\n    where all cells are non-zero (non-white/background).\n    Assumes exactly one such block exists based on the task's examples.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: The row and column (r, c) of the top-left corner of the \n               2x2 object, or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Check if all four cells in the 2x2 block are non-zero (non-white)\n            # using numpy slicing for potential efficiency\n            if np.all(grid[r:r+2, c:c+2] != 0):\n                return r, c\n    return None # Should not be reached based on task description if assumptions hold\n\ndef draw_2x2_square(grid, r, c, color):\n    \"\"\"\n    Fills a 2x2 area in the grid starting at (r, c) with the specified color.\n    Modifies the grid in place. Ensures drawing stays within grid boundaries.\n\n    Args:\n        grid (np.array): The grid to modify.\n        r (int): The starting row index for the 2x2 square.\n        c (int): The starting column index for the 2x2 square.\n        color (int): The color value to fill with.\n    \"\"\"\n    height, width = grid.shape\n    # Calculate the actual range to draw, clipping at grid boundaries\n    r_end = min(r + 2, height)\n    c_end = min(c + 2, width)\n    \n    # Ensure start indices are valid before attempting to draw\n    # and that the slice dimensions are not zero\n    if r < height and c < width and r_end > r and c_end > c:\n        grid[r:r_end, c:c_end] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        np.array: The transformed grid as a NumPy array.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    \n    # 1. Create the output grid as an exact copy of the input grid.\n    output_grid = np.copy(input_np)\n    height, width = output_grid.shape # H and W\n\n    # 2. Scan the input grid to find the unique 2x2 non-background block.\n    obj_coords = find_2x2_object(input_np)\n    \n    # If no object found (unexpected based on task examples), return the unchanged copy.\n    if obj_coords is None:\n        # Consider adding logging or raising an error if strict adherence requires an object\n        return output_grid \n        \n    obj_r, obj_c = obj_coords\n\n    # 3. Extract the colors of the four pixels within this 2x2 block from the INPUT grid.\n    # Ensure indices are within bounds, though find_2x2_object should guarantee this\n    # if an object was found.\n    color_tl = input_np[obj_r, obj_c]     # Top-Left\n    color_tr = input_np[obj_r, obj_c+1]   # Top-Right\n    color_bl = input_np[obj_r+1, obj_c]   # Bottom-Left\n    color_br = input_np[obj_r+1, obj_c+1] # Bottom-Right\n\n    # 4. Modify the output grid by drawing 2x2 squares in the corners,\n    #    using the diagonally opposite colors from the source object.\n    \n    # Draw top-left corner (0, 0) using color_BR.\n    draw_2x2_square(output_grid, 0, 0, color_br)\n    \n    # Draw top-right corner (0, W-2) using color_BL.\n    # Check if width allows for a 2x2 square starting at W-2\n    if width >= 2:\n      draw_2x2_square(output_grid, 0, width-2, color_bl)\n    \n    # Draw bottom-left corner (H-2, 0) using color_TR.\n    # Check if height allows for a 2x2 square starting at H-2\n    if height >= 2:\n      draw_2x2_square(output_grid, height-2, 0, color_tr)\n    \n    # Draw bottom-right corner (H-2, W-2) using color_TL.\n    # Check if both height and width allow for this square\n    if height >= 2 and width >= 2:\n      draw_2x2_square(output_grid, height-2, width-2, color_tl)\n\n    # 5. The final modified output grid is the result.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8007,
    "candidates_token_count": 1419,
    "total_token_count": 9426,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.139926
}