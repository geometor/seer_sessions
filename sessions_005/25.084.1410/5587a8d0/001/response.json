{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentify the background color (most frequent color) in the input grid.\nFind all contiguous objects of non-background colors (treating black/0 as an object color).\nFor each unique object color, determine the size (pixel count) of the largest object of that color.\nCount the number of unique object colors (N).\nSort these unique colors in descending order based on the size of their largest corresponding object (C1, C2, ..., CN).\nCalculate the output grid dimension: dim = 2 * N - 1.\nCreate a square output grid of size dim x dim.\nFill the grid with concentric square frames:\n- The outermost frame (border of dim x dim) uses color C1.\n- The next frame inwards (border of (dim-2) x (dim-2)) uses color C2.\n- Continue inwards, with the k-th frame using color Ck.\n- The center pixel (frame N) uses color CN.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds contiguous objects and returns their color and size.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = [] # List to store (color, size) tuples\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                size = 0\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    size += 1\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds and if valid neighbor\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'color': color, 'size': size})\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the sizes of distinct colored objects.\n    Constructs an output grid with concentric frames corresponding to sorted object colors by size.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify background color\n    if rows * cols == 0:\n        return np.array([[]]) # Handle empty input\n        \n    color_counts = Counter(input_np.flatten())\n    # Assume background is the most frequent color\n    # If tie, behavior might be ambiguous, but taking the first one found is common.\n    # Handle case where grid is empty or has uniform color (technically background)\n    if not color_counts:\n         return np.array([[]]) # Should not happen based on ARC constraints but safe guard\n         \n    background_color = color_counts.most_common(1)[0][0]\n    \n    # 2. Find all non-background objects\n    objects = find_objects(input_np, background_color)\n\n    # 3. Group by color and find the maximum size for each color\n    max_size_by_color = {}\n    for obj in objects:\n        color = obj['color']\n        size = obj['size']\n        if color not in max_size_by_color:\n            max_size_by_color[color] = 0\n        max_size_by_color[color] = max(max_size_by_color[color], size)\n\n    # Handle case with no non-background objects\n    if not max_size_by_color:\n        # Behavior undefined by examples, return empty or small grid?\n        # Let's return 1x1 background color? Or maybe empty? Based on examples, objects exist.\n        # Returning a 1x1 of background seems plausible if needed. Let's assume objects always exist for now.\n         return np.array([[background_color]]) # Or perhaps np.array([[]]) ?\n\n    # 4. Count unique object colors\n    unique_colors = list(max_size_by_color.keys())\n    N = len(unique_colors)\n\n    # 5. Sort colors by max size (descending)\n    # We sort items (color, max_size) by max_size (descending), then extract the colors\n    sorted_color_size_pairs = sorted(max_size_by_color.items(), key=lambda item: item[1], reverse=True)\n    sorted_colors = [item[0] for item in sorted_color_size_pairs]\n\n    # 6. Calculate output dimension\n    output_dimension = 2 * N - 1\n\n    # 7. Create output grid (initialize maybe with -1 or a placeholder)\n    # Initialize with a value that won't be a valid color, like -1,\n    # or start with the innermost color and overwrite outwards/inwards.\n    # Let's initialize with the center color CN\n    center_color = sorted_colors[-1] # CN is the last color in the sorted list\n    output_grid = np.full((output_dimension, output_dimension), center_color, dtype=int)\n\n    # 8. Fill concentric frames (from outermost inwards)\n    # Iterate from k=0 (outermost frame C1) up to N-2 (frame CN-1). Frame CN is the center, already filled.\n    for k in range(N - 1): # Corresponds to colors C1 through C(N-1)\n        color = sorted_colors[k]\n        # The frame is defined by the top-left (k, k) and bottom-right (dim-1-k, dim-1-k) corners\n        top = k\n        bottom = output_dimension - 1 - k\n        left = k\n        right = output_dimension - 1 - k\n\n        # Fill top row of the frame\n        output_grid[top, left:right+1] = color\n        # Fill bottom row of the frame\n        output_grid[bottom, left:right+1] = color\n        # Fill left column of the frame (excluding corners already filled)\n        output_grid[top+1:bottom, left] = color\n        # Fill right column of the frame (excluding corners already filled)\n        output_grid[top+1:bottom, right] = color\n        \n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3727,
    "candidates_token_count": 1562,
    "total_token_count": 5289,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.770825
}