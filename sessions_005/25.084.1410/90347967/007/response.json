{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the number of edges touched by non-white pixels.\n1. Receive the input grid.\n2. Identify all non-white pixels (pixels with value > 0).\n3. If there are no non-white pixels, return the input grid unchanged.\n4. Determine which of the four grid edges (Top, Bottom, Left, Right) contain at least one non-white pixel. Count how many distinct edges are touched (`E`).\n5. Create an intermediate grid by rotating the original input grid 180 degrees.\n6. Check the value of `E` calculated in step 4:\n    a.  If `E` is exactly 1: Create the final output grid by taking the intermediate (rotated) grid and shifting its content up by 2 rows. Fill the newly empty bottom 2 rows with white pixels (0).\n    b.  If `E` is 0, 2, 3, or 4: The final output grid is the intermediate (rotated) grid itself.\n7. Return the final output grid.\n\"\"\"\n\nimport numpy as np\n\ndef count_edges_touched(grid):\n    \"\"\"\n    Counts the number of grid edges (Top, Bottom, Left, Right)\n    touched by any non-white pixels (value != 0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        int: The number of edges touched (0-4).\n    \"\"\"\n    height, width = grid.shape\n\n    # Find coordinates of non-white pixels\n    non_white_coords = np.argwhere(grid != 0)\n\n    # Handle case where the grid is all white (no non-white pixels)\n    if non_white_coords.shape[0] == 0:\n        return 0\n\n    # Find the minimum and maximum row and column indices of non-white pixels\n    r_min = non_white_coords[:, 0].min()\n    r_max = non_white_coords[:, 0].max()\n    c_min = non_white_coords[:, 1].min()\n    c_max = non_white_coords[:, 1].max()\n\n    # Check if the bounding box of non-white pixels touches each edge\n    touches_top = (r_min == 0)\n    touches_bottom = (r_max == height - 1)\n    touches_left = (c_min == 0)\n    touches_right = (c_max == width - 1)\n\n    # Sum the boolean values (True=1, False=0) to get the count\n    num_edges_touched = sum([touches_top, touches_bottom, touches_left, touches_right])\n\n    return num_edges_touched\n\ndef rotate_180(grid):\n    \"\"\"\n    Rotates a 2D numpy array by 180 degrees.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The grid rotated by 180 degrees.\n    \"\"\"\n    # Use numpy's rot90 function for efficient 180-degree rotation (k=2)\n    return np.rot90(grid, 2)\n\ndef shift_up(grid, rows):\n    \"\"\"\n    Shifts a grid's content up by a specified number of rows,\n    filling the vacated bottom rows with white (0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        rows (int): The number of rows to shift up.\n\n    Returns:\n        np.ndarray: The shifted grid.\n    \"\"\"\n    height, width = grid.shape\n\n    # Initialize the output grid with the background color (white = 0)\n    shifted_grid = np.zeros_like(grid)\n\n    # If shifting by 0 or negative rows, no change is needed\n    if rows <= 0:\n        return grid\n\n    # If shifting by height or more, the result is an all-white grid\n    if rows >= height:\n        return shifted_grid\n\n    # Copy the portion of the original grid that remains after the shift\n    # Source rows: from index 'rows' to the end ('height')\n    # Destination rows: from index 0 to 'height - rows'\n    shifted_grid[0 : height - rows, :] = grid[rows : height, :]\n\n    return shifted_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional rotation and shift transformation to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n\n    # Step 3: Handle the edge case of an all-white grid. If so, return it unchanged.\n    # This is implicitly handled by count_edges_touched returning 0, leading to step 6b.\n    # Rotating an all-white grid results in an all-white grid.\n    if np.all(grid == 0):\n        return input_grid # Return original list of lists format\n\n    # Step 4: Calculate the number of edges touched by non-white pixels in the original grid.\n    num_edges = count_edges_touched(grid)\n\n    # Step 5: Rotate the input grid by 180 degrees.\n    rotated_grid = rotate_180(grid)\n\n    # Step 6: Check the condition based on the number of edges touched.\n    if num_edges == 1:\n        # Step 6a: If exactly one edge was touched, shift the rotated grid up by 2 rows.\n        output_grid = shift_up(rotated_grid, 2)\n    else:\n        # Step 6b: Otherwise (0, 2, 3, or 4 edges touched), use the rotated grid directly.\n        output_grid = rotated_grid\n\n    # Step 7: Convert the final numpy array back to a list of lists format and return.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6233,
    "candidates_token_count": 1406,
    "total_token_count": 7639,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 13.716597
}