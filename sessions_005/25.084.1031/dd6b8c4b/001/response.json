{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify a 3x3 block containing green (3) and red (2) pixels.\nDetermine if this block has a magenta (6) border.\nCheck if any maroon (9) pixel is adjacent (including diagonals) to the block or its border.\n\nRule 1: If a magenta border exists AND a maroon pixel is adjacent:\n  - Change all green (3) and red (2) pixels within the 3x3 block to maroon (9).\n\nRule 2: If a magenta border exists AND NO maroon pixel is adjacent:\n  - Find the location (r, c) of the original red (2) pixel.\n  - Change the green (3) pixels at (r-1, c-1) and (r-1, c) to maroon (9).\n  - Additionally, find any magenta (6) pixel that is NOT part of the immediate border but IS adjacent to any maroon (9) pixel in the input, and change its color to orange (7).\n\nRule 3: If NO magenta border exists:\n  - Find the location (r, c) of the original red (2) pixel.\n  - Within the 3x3 block:\n    - Change green (3) pixels to maroon (9) if their row is above 'r'.\n    - Change green (3) pixels to maroon (9) if their row is 'r' and their column is left of 'c'.\n  - Change the original red (2) pixel at (r, c) to green (3).\n  - Additionally, find all maroon (9) pixels in the input grid. If a maroon pixel has NO adjacent (including diagonal) maroon neighbors in the input grid, change its color to orange (7).\n\nAll other pixels remain unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_central_block(grid):\n    \"\"\"\n    Finds the 3x3 block containing green (3) and red (2) pixels.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (top_left_r, top_left_c, red_r, red_c) or (None, None, None, None) if not found.\n               Returns the coordinates of the top-left corner of the 3x3 block\n               and the coordinates of the red (2) pixel within the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows - 2):\n        for c in range(cols - 2):\n            block = grid[r:r+3, c:c+3]\n            red_pixels = np.where(block == 2)\n            green_pixels = np.where(block == 3)\n\n            if len(red_pixels[0]) == 1 and len(green_pixels[0]) > 0:\n                # Found the block\n                red_r_local, red_c_local = red_pixels[0][0], red_pixels[1][0]\n                red_r, red_c = r + red_r_local, c + red_c_local\n                return r, c, red_r, red_c\n    return None, None, None, None\n\ndef get_neighbors(grid_shape, r, c, include_diagonal=True):\n    \"\"\"\n    Gets the coordinates of valid neighbors for a pixel.\n\n    Args:\n        grid_shape (tuple): The shape (rows, cols) of the grid.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n        include_diagonal (bool): Whether to include diagonal neighbors.\n\n    Returns:\n        list: A list of neighbor coordinates (nr, nc).\n    \"\"\"\n    rows, cols = grid_shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) == 2:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef check_magenta_border(grid, br, bc):\n    \"\"\"\n    Checks if the 3x3 block starting at (br, bc) has a solid magenta (6) border.\n\n    Args:\n        grid (np.array): The input grid.\n        br (int): Top row index of the block.\n        bc (int): Left column index of the block.\n\n    Returns:\n        bool: True if a complete magenta border exists, False otherwise.\n        set: Coordinates of the border pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    border_coords = set()\n    has_border = True\n\n    # Define potential border coordinates relative to br, bc\n    potential_border_indices = [\n        (-1, -1), (-1, 0), (-1, 1), (-1, 2), (-1, 3),\n        (0, -1),                          (0, 3),\n        (1, -1),                          (1, 3),\n        (2, -1),                          (2, 3),\n        (3, -1), (3, 0), (3, 1), (3, 2), (3, 3),\n    ]\n\n    for dr, dc in potential_border_indices:\n        r, c = br + dr, bc + dc\n        if 0 <= r < rows and 0 <= c < cols:\n            border_coords.add((r, c))\n            if grid[r, c] != 6:\n                has_border = False\n                # Don't break early, collect all potential border coords\n        else:\n            # If a border pixel would be off-grid, it can't be a complete border\n             # Update: The examples imply borders can be incomplete at edges.\n             # Let's assume the rule applies if *all existing* border cells are magenta.\n             # However, for simplicity and based on examples, let's require the full 5x5 area\n             # to be checkable within bounds for a border to be 'present'.\n             # A strict interpretation: if br=0 or bc=0 or br+3>=rows or bc+3>=cols, border cannot be complete.\n             if br == 0 or bc == 0 or br + 3 >= rows or bc + 3 >= cols:\n                 # If the block touches the edge, we consider the border check to fail\n                 # unless the problem statement implies otherwise. Example 1/2 block is not at edge.\n                 # Let's assume full border means the 5x5 area is within bounds.\n                 return False, set() # Cannot have a full border if block is too close to edge\n\n    # If we got here, the 5x5 area is within bounds. Now check colors.\n    for r, c in border_coords:\n        if grid[r, c] != 6:\n            return False, border_coords # Found a non-magenta cell in the border area\n\n    # If all checks passed\n    return True, border_coords\n\n\ndef check_maroon_adjacency(grid, br, bc, border_coords, has_border):\n    \"\"\"\n    Checks if any maroon (9) pixel is adjacent (incl. diagonal) to the block or its border.\n\n    Args:\n        grid (np.array): The input grid.\n        br (int): Top row index of the block.\n        bc (int): Left column index of the block.\n        border_coords (set): Coordinates of the border pixels (if has_border is True).\n        has_border (bool): Whether a magenta border exists.\n\n    Returns:\n        bool: True if an adjacent maroon pixel is found, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    block_coords = set((r, c) for r in range(br, br + 3) for c in range(bc, bc + 3))\n    target_coords = block_coords\n    if has_border:\n        target_coords.update(border_coords)\n\n    maroon_locations = np.argwhere(grid == 9)\n\n    for mr, mc in maroon_locations:\n        neighbors = get_neighbors(grid.shape, mr, mc, include_diagonal=True)\n        for nr, nc in neighbors:\n            if (nr, nc) in target_coords:\n                return True\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify the central block and red pixel\n    br, bc, r_red, c_red = find_central_block(input_grid)\n\n    if br is None:\n        # No block found, return the original grid\n        return output_grid.tolist()\n\n    # 2. Determine if a magenta border exists\n    has_magenta_border, border_coords = check_magenta_border(input_grid, br, bc)\n\n    # 3. Check for maroon adjacency\n    is_maroon_adjacent = check_maroon_adjacency(input_grid, br, bc, border_coords, has_magenta_border)\n\n    # 4. Apply rules based on border and adjacency\n    if has_magenta_border:\n        if is_maroon_adjacent:\n            # Rule 1: Change block green/red to maroon\n            for r in range(br, br + 3):\n                for c in range(bc, bc + 3):\n                    if input_grid[r, c] == 3 or input_grid[r, c] == 2:\n                        output_grid[r, c] = 9\n        else:\n            # Rule 2: Change specific greens to maroon, modify stray magentas\n            # Ensure target pixels are within bounds before changing\n            if 0 <= r_red - 1 < rows and 0 <= c_red - 1 < cols:\n                 if output_grid[r_red - 1, c_red - 1] == 3: # Check if it's green before changing\n                     output_grid[r_red - 1, c_red - 1] = 9\n            if 0 <= r_red - 1 < rows and 0 <= c_red < cols:\n                 if output_grid[r_red - 1, c_red] == 3: # Check if it's green before changing\n                      output_grid[r_red - 1, c_red] = 9\n\n            # Modify stray magentas adjacent to maroons\n            magenta_locations = np.argwhere(input_grid == 6)\n            maroon_locations = np.argwhere(input_grid == 9) # Find maroon locations once\n\n            for mag_r, mag_c in magenta_locations:\n                if (mag_r, mag_c) not in border_coords: # Check if it's NOT part of the border\n                    is_adj_to_maroon = False\n                    neighbors = get_neighbors(input_grid.shape, mag_r, mag_c, include_diagonal=True)\n                    for nr, nc in neighbors:\n                        if input_grid[nr, nc] == 9:\n                            is_adj_to_maroon = True\n                            break\n                    if is_adj_to_maroon:\n                        output_grid[mag_r, mag_c] = 7 # Change to orange\n\n    else: # No magenta border\n        # Rule 3: Change specific greens, change red to green, modify isolated maroons\n        for r in range(br, br + 3):\n            for c in range(bc, bc + 3):\n                if input_grid[r, c] == 3:\n                    if r < r_red:\n                        output_grid[r, c] = 9\n                    elif r == r_red and c < c_red:\n                        output_grid[r, c] = 9\n        # Change original red to green\n        output_grid[r_red, c_red] = 3\n\n        # Modify isolated maroons\n        maroon_locations = np.argwhere(input_grid == 9)\n        for mr, mc in maroon_locations:\n            is_isolated = True\n            neighbors = get_neighbors(input_grid.shape, mr, mc, include_diagonal=True)\n            for nr, nc in neighbors:\n                if input_grid[nr, nc] == 9:\n                    is_isolated = False\n                    break\n            if is_isolated:\n                # Check if this maroon pixel was changed in the block modification step above\n                # This check is important if a green turned into maroon and is isolated\n                # We only want to change *original* isolated maroons to orange\n                if input_grid[mr, mc] == 9: # Only change if it was maroon in the input\n                   output_grid[mr, mc] = 7 # Change to orange\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4224,
    "candidates_token_count": 3025,
    "total_token_count": 7249,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.507613
}