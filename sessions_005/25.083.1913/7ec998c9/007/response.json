{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying a single \"target\" pixel (the non-dominant color) and replacing pixels of the dominant color with '1's, extending outwards from the target pixel to the edges of the grid in all orthogonal directions.\n\"\"\"\n\nimport numpy as np\n\ndef find_target_pixel(grid):\n    # Find the dominant color\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    dominant_color_index = np.argmax(counts)\n    dominant_color = unique_colors[dominant_color_index]\n\n    # Find the target pixel (non-dominant color)\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != dominant_color:\n                return (r, c), dominant_color # Return target coordinates and dominant color\n\n    return None, dominant_color #should not happen, based on task definition\n\ndef transform(input_grid):\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # Find target\n    target_coords, dominant_color = find_target_pixel(input_grid)\n\n    if target_coords is None:\n       return output_grid #should not happen\n\n    target_row, target_col = target_coords\n\n    # Extend Up\n    for r in range(target_row -1, -1, -1):\n        if output_grid[r, target_col] == dominant_color:\n            output_grid[r, target_col] = 1\n        else:\n            break\n\n    # Extend Down\n    for r in range(target_row + 1, rows):\n        if output_grid[r, target_col] == dominant_color:\n            output_grid[r, target_col] = 1\n        else:\n            break\n\n    # Extend Left\n    for c in range(target_col - 1, -1, -1):\n        if output_grid[target_row, c] == dominant_color:\n             output_grid[target_row, c] = 1\n        else:\n            break\n\n    # Extend Right\n    for c in range(target_col + 1, cols):\n        if output_grid[target_row, c] == dominant_color:\n            output_grid[target_row, c] = 1\n        else:\n            break\n\n    # Extend Up-Left - we can stop at edges\n    r, c = target_row, target_col\n    while r>0 and c>0:\n      r -= 1\n      c -= 1\n      if output_grid[r,c] == dominant_color:\n        output_grid[r,c] = 1\n      else:\n        break    \n\n    # Extend Up-Right - we can stop at edges\n    r, c = target_row, target_col\n    while r>0 and c<cols-1:\n      r -= 1\n      c += 1\n      if output_grid[r,c] == dominant_color:\n        output_grid[r,c] = 1\n      else:\n        break\n\n    # Extend Down-Left - we can stop at edges\n    r, c = target_row, target_col\n    while r<rows-1 and c>0:\n      r += 1\n      c -= 1\n      if output_grid[r,c] == dominant_color:\n        output_grid[r,c] = 1\n      else:\n        break\n\n    # Extend Down-Right - we can stop at edges\n    r, c = target_row, target_col\n    while r<rows-1 and c<cols-1:\n      r += 1\n      c += 1\n      if output_grid[r,c] == dominant_color:\n        output_grid[r,c] = 1\n      else:\n        break\n\n    # now find the boundaries in each of the four directions and fill\n    # Extend Up\n    for r in range(target_row -1, -1, -1):\n        if output_grid[r, target_col] != 1:\n          break;\n        # now we've reach the limit in this direction - fill the diagonals\n        for d in range(1,target_col+1): #left\n          if target_col-d >= 0:\n            if output_grid[r,target_col-d] == dominant_color:\n              output_grid[r,target_col-d] = 1\n        for d in range(1,cols-target_col): #left\n          if target_col+d < cols:\n            if output_grid[r,target_col+d] == dominant_color:\n              output_grid[r,target_col+d] = 1\n\n    # Extend Down\n    for r in range(target_row + 1, rows):\n        if output_grid[r, target_col] != 1:\n          break;\n        # now we've reach the limit in this direction - fill the diagonals\n        for d in range(1,target_col+1): #left\n          if target_col-d >= 0:\n            if output_grid[r,target_col-d] == dominant_color:\n              output_grid[r,target_col-d] = 1\n        for d in range(1,cols-target_col): #left\n          if target_col+d < cols:\n            if output_grid[r,target_col+d] == dominant_color:\n              output_grid[r,target_col+d] = 1\n    \n    # Extend Left\n    for c in range(target_col - 1, -1, -1):\n        if output_grid[target_row, c] != 1:\n          break;\n        # now we've reach the limit in this direction - fill the diagonals\n        for d in range(1,target_row+1): #up\n          if target_row-d >= 0:\n            if output_grid[target_row-d,c] == dominant_color:\n              output_grid[target_row-d,c] = 1\n        for d in range(1,rows-target_row): #down\n          if target_row+d < rows:\n            if output_grid[target_row+d,c] == dominant_color:\n              output_grid[target_row+d,c] = 1\n\n    # Extend Right\n    for c in range(target_col + 1, cols):\n        if output_grid[target_row, c] != 1:\n          break;\n        # now we've reach the limit in this direction - fill the diagonals\n        for d in range(1,target_row+1): #up\n          if target_row-d >= 0:\n            if output_grid[target_row-d,c] == dominant_color:\n              output_grid[target_row-d,c] = 1\n        for d in range(1,rows-target_row): #down\n          if target_row+d < rows:\n            if output_grid[target_row+d,c] == dominant_color:\n              output_grid[target_row+d,c] = 1\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3578,
    "candidates_token_count": 1705,
    "total_token_count": 5283,
    "cached_content_token_count": 0
  },
  "response_time": 18.607779
}