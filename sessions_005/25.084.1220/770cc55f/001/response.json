{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a horizontal red line (color 2) separating the grid.\nFinds a colored shape above the red line and another shape of the same color below it.\nCalculates the intersection of the column indices occupied by these two shapes.\nDetermines a vertical region (either between the top shape and the red line, or between the red line and the bottom shape) based on whether the intersection columns match the columns of the top shape, the bottom shape, or neither (proper subset).\nFills the determined vertical region within the intersection columns with yellow (color 4).\n\nSpecifically:\n1. Find the row index of the red line.\n2. Find the properties (max row, column set) of the shape above the red line.\n3. Find the properties (min row, column set) of the shape below the red line.\n4. Calculate the intersection of the top and bottom column sets.\n5. If the intersection columns match the bottom shape's columns, fill rows between the top shape's max row and the red line row.\n6. Else if the intersection columns match the top shape's columns, fill rows between the red line row and the bottom shape's min row.\n7. Else (intersection is a proper subset of both), fill rows between the top shape's max row and the red line row.\n8. Fill only within the intersection columns, using color 4 (yellow).\n\"\"\"\n\ndef find_red_line_row(grid):\n    \"\"\"Finds the row index of the horizontal red line (color 2).\"\"\"\n    red_line_rows = np.where(np.all(grid == 2, axis=1))[0]\n    if len(red_line_rows) == 1:\n        return red_line_rows[0]\n    # Handle cases with multiple red lines or no red line if necessary,\n    # but based on examples, assume exactly one.\n    return -1 # Indicate error or unexpected input\n\ndef get_shape_properties(grid, start_row, end_row):\n    \"\"\"\n    Finds the first non-background (0) and non-red (2) shape in the given row range.\n    Returns its color, min/max row index within the range, and the set of column indices it occupies.\n    Returns None if no such shape is found.\n    \"\"\"\n    shape_color = -1\n    coords = []\n    min_r, max_r = float('inf'), float('-inf')\n    cols = set()\n\n    for r in range(start_row, end_row):\n        for c in range(grid.shape[1]):\n            pixel = grid[r, c]\n            if pixel != 0 and pixel != 2:\n                if shape_color == -1:\n                    shape_color = pixel # Found the shape's color\n                # Find all pixels of this color within the range\n                if grid[r, c] == shape_color:\n                    coords.append((r, c))\n                    min_r = min(min_r, r)\n                    max_r = max(max_r, r)\n                    cols.add(c)\n\n    if shape_color != -1:\n        return {'color': shape_color, 'min_row': min_r, 'max_row': max_r, 'cols': cols}\n    else:\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the detected shapes and red line.\n    Adds a yellow rectangle based on the column intersection and relative positions.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # 1. Find the red line row index\n    red_row = find_red_line_row(grid)\n    if red_row == -1:\n        # Handle error: No single red line found\n        return output_grid # Or raise an error\n\n    # 2. Find the properties of the shape above the red line\n    top_shape_props = get_shape_properties(grid, 0, red_row)\n    if top_shape_props is None:\n        # Handle error: No shape found above red line\n        return output_grid\n\n    # 3. Find the properties of the shape below the red line\n    bottom_shape_props = get_shape_properties(grid, red_row + 1, height)\n    if bottom_shape_props is None:\n         # Handle error: No shape found below red line\n        return output_grid\n\n    # Ensure colors match (as per observation, though not strictly enforced here)\n    # if top_shape_props['color'] != bottom_shape_props['color']:\n    #     print(\"Warning: Top and bottom shape colors do not match.\")\n\n    # 4. Calculate the intersection of column sets\n    top_cols = top_shape_props['cols']\n    bottom_cols = bottom_shape_props['cols']\n    intersection_cols = top_cols.intersection(bottom_cols)\n\n    if not intersection_cols:\n        # No intersection, no yellow rectangle to draw\n        return output_grid\n\n    # 5. Determine the vertical region to fill\n    fill_above = False\n    if intersection_cols == bottom_cols:\n        fill_above = True\n    elif intersection_cols == top_cols:\n        fill_above = False\n    else:\n        # Intersection is a proper subset of both (or just top if bottom==intersection)\n        # Based on examples (train_1, train_3), default to filling above in this subset case.\n        # Based on train_2, if intersection == bottom_cols, fill above.\n        # Based on train_4, if intersection == top_cols, fill below.\n        # Let's refine the logic to match observations precisely:\n        if intersection_cols == bottom_cols:\n             fill_above = True\n        elif intersection_cols == top_cols:\n             fill_above = False\n        elif intersection_cols.issubset(top_cols) and intersection_cols.issubset(bottom_cols):\n             # Proper subset of both (like train_1, train_3)\n             fill_above = True\n        else:\n             # This case might not occur based on examples, but default to above\n             fill_above = True\n\n\n    # 6. Define the rows to be filled\n    fill_rows = []\n    if fill_above:\n        start_fill_row = top_shape_props['max_row'] + 1\n        end_fill_row = red_row\n        fill_rows = range(start_fill_row, end_fill_row)\n    else: # Fill below\n        start_fill_row = red_row + 1\n        end_fill_row = bottom_shape_props['min_row']\n        fill_rows = range(start_fill_row, end_fill_row)\n\n    # 7. Iterate and fill the output grid with yellow (4)\n    for r in fill_rows:\n        for c in intersection_cols:\n            # Ensure we are drawing on background (white=0) pixels only\n            # Although examples suggest this region is always white, it's safer to check.\n            if output_grid[r, c] == 0:\n                 output_grid[r, c] = 4\n\n    return output_grid.tolist() # Convert back to list of lists if needed\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3821,
    "candidates_token_count": 1691,
    "total_token_count": 5512,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.684245
}