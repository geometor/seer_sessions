{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies blue shapes (color 1) that enclose exactly one single white pixel (color 0).\nFor each such identified blue shape and its single white hole:\n1. The original white hole pixel is changed to red (color 2).\n2. The four orthogonal neighbors of the white hole pixel (which must be part of the blue shape) are also changed to red (color 2). These five red pixels form a '+' shape centered on the original hole.\n3. All other pixels belonging to the original blue shape (those not part of the red '+') are changed to white (color 0).\n4. All other pixels in the grid retain their original colors.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n    Uses 4-connectivity (up, down, left, right).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int): The color of the components to find.\n\n    Returns:\n        list: A list of components. Each component is a set of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel has the target color and hasn't been visited yet\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start a BFS to find the connected component\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                component.add((nr, nc))\n                                q.append((nr, nc))\n                # Add the found component to the list\n                components.append(component)\n    return components\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    height, width = input_grid.shape\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Find all blue components (color 1)\n    blue_components = find_connected_components(input_grid, 1)\n\n    # 2. Find all white components (color 0)\n    white_components = find_connected_components(input_grid, 0)\n\n    # 3. Create a mapping from pixel coordinate to the index of the blue component it belongs to\n    pixel_to_blue_component_idx = {}\n    for idx, component in enumerate(blue_components):\n        for r, c in component:\n            pixel_to_blue_component_idx[(r, c)] = idx\n\n    # 4. Identify target transformations: (blue_component_coords, hole_coord)\n    targets = []\n    for white_component in white_components:\n        # Check if the white component is a single pixel\n        if len(white_component) == 1:\n            hole_coord = list(white_component)[0]\n            r, c = hole_coord\n\n            # Check if the hole touches the boundary\n            if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n                continue # Holes touching boundary are ignored\n\n            # Check the 4 orthogonal neighbors\n            neighbors = []\n            valid_neighbors = True\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Neighbor must be within bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    neighbors.append((nr, nc))\n                else:\n                    # Should not happen if hole isn't on boundary, but check for safety\n                    valid_neighbors = False\n                    break\n\n            if not valid_neighbors or len(neighbors) != 4: # Ensure exactly 4 neighbors exist\n                continue\n\n            # Check if all neighbors are blue and belong to the *same* blue component\n            enclosing_blue_idx = None\n            is_valid_hole = True\n            for nr, nc in neighbors:\n                if input_grid[nr, nc] != 1: # Neighbor is not blue\n                    is_valid_hole = False\n                    break\n                # Neighbor is blue, check which component it belongs to\n                if (nr, nc) not in pixel_to_blue_component_idx:\n                     # This blue pixel isn't part of any found component? Should not happen.\n                     is_valid_hole = False\n                     break\n\n                current_blue_idx = pixel_to_blue_component_idx[(nr, nc)]\n                if enclosing_blue_idx is None:\n                    enclosing_blue_idx = current_blue_idx # First blue neighbor found\n                elif enclosing_blue_idx != current_blue_idx:\n                    # Neighbor belongs to a different blue component\n                    is_valid_hole = False\n                    break\n\n            # If all checks passed, store the target\n            if is_valid_hole and enclosing_blue_idx is not None:\n                targets.append((blue_components[enclosing_blue_idx], hole_coord))\n\n    # 5. Apply transformations based on identified targets\n    for blue_shape_coords, hole_coord in targets:\n        r, c = hole_coord\n\n        # Define the coordinates for the red '+' shape\n        plus_coords = set()\n        plus_coords.add(hole_coord) # Center\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Add neighbor if within bounds (should always be true for valid targets)\n            if 0 <= nr < height and 0 <= nc < width:\n                plus_coords.add((nr, nc))\n\n        # Iterate through the original blue shape pixels\n        for br, bc in blue_shape_coords:\n            # Check if this blue pixel is part of the '+' shape\n            if (br, bc) in plus_coords:\n                # Change to red (color 2)\n                if 0 <= br < height and 0 <= bc < width: # Bounds check for safety\n                    output_grid[br, bc] = 2\n            else:\n                # Change to white (color 0)\n                 if 0 <= br < height and 0 <= bc < width: # Bounds check for safety\n                    output_grid[br, bc] = 0\n\n        # Ensure the center (original hole) is red\n        if 0 <= r < height and 0 <= c < width: # Bounds check for safety\n             output_grid[r, c] = 2\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6456,
    "candidates_token_count": 1747,
    "total_token_count": 8203,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.795459
}