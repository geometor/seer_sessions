{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies blue shapes (color 1) in the input grid that fully enclose exactly \none contiguous area of white pixels (color 0, a 'hole'). For each such identified \nblue shape, its pixels are changed to white (color 0), and the pixels of the \nsingle hole it encloses are changed to red (color 2) in the output grid. \nAll other pixels retain their original colors.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n    Uses 4-connectivity (up, down, left, right).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int): The color of the components to find.\n\n    Returns:\n        list: A list of components. Each component is a set of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel has the target color and hasn't been visited yet\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start a BFS to find the connected component\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                component.add((nr, nc))\n                                q.append((nr, nc))\n                # Add the found component to the list\n                components.append(component)\n    return components\n\ndef touches_boundary(component, grid_shape):\n    \"\"\"\n    Checks if any pixel in the component is on the grid boundary.\n\n    Args:\n        component (set): A set of (row, col) tuples representing the component.\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        bool: True if the component touches the boundary, False otherwise.\n    \"\"\"\n    height, width = grid_shape\n    for r, c in component:\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            return True\n    return False\n\ndef get_neighbors(component, grid_shape):\n    \"\"\"\n    Gets all unique neighboring coordinates of a component.\n    Neighbors are defined using 4-connectivity.\n\n    Args:\n        component (set): A set of (row, col) tuples.\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        set: A set of (row, col) tuples representing neighboring coordinates\n             that are within the grid bounds but not part of the component itself.\n    \"\"\"\n    height, width = grid_shape\n    neighbors = set()\n    for r, c in component:\n        # Check 4 neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds and not part of the component itself\n            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in component:\n                neighbors.add((nr, nc))\n    return neighbors\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    height, width = input_grid.shape\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Find all blue components (shapes)\n    blue_components = find_connected_components(input_grid, 1)\n\n    # 2. Find all white components\n    white_components = find_connected_components(input_grid, 0)\n\n    # 3. Create a mapping from pixel coordinate to the index of the blue component it belongs to\n    # This allows quick checking of which blue component a neighbor belongs to.\n    pixel_to_blue_component_idx = {}\n    for idx, component in enumerate(blue_components):\n        for r, c in component:\n            pixel_to_blue_component_idx[(r, c)] = idx\n\n    # 4. Identify which blue component encloses which white components (potential holes)\n    # A dictionary to store the list of hole-components associated with each blue component index\n    blue_component_holes = {idx: [] for idx in range(len(blue_components))}\n\n    # Iterate through each white component to see if it's a hole\n    for white_component in white_components:\n        # A hole cannot touch the grid boundary\n        if not touches_boundary(white_component, (height, width)):\n            # Get all neighbors of the white component\n            neighbors = get_neighbors(white_component, (height, width))\n\n            # Check if this white component is a valid hole enclosed by a SINGLE blue component\n            enclosing_blue_idx = -1 # Track the index of the potential enclosing blue component\n            is_valid_hole = True\n            if not neighbors: # A non-boundary component must have neighbors\n                 is_valid_hole = False\n\n            for nr, nc in neighbors:\n                pixel_color = input_grid[nr, nc]\n                # All neighbors MUST be blue (color 1)\n                if pixel_color == 1:\n                    # Check which blue component this neighbor belongs to\n                    if (nr, nc) in pixel_to_blue_component_idx:\n                        current_blue_idx = pixel_to_blue_component_idx[(nr, nc)]\n                        # If this is the first blue neighbor found, record its component index\n                        if enclosing_blue_idx == -1:\n                            enclosing_blue_idx = current_blue_idx\n                        # If a neighbor belongs to a DIFFERENT blue component, it's not a valid hole\n                        elif enclosing_blue_idx != current_blue_idx:\n                            is_valid_hole = False\n                            break\n                    else:\n                        # This neighbor is blue but not part of any pre-identified component?\n                        # This shouldn't happen if find_connected_components is correct.\n                        # Treat as invalid for safety.\n                        is_valid_hole = False\n                        break\n                else:\n                    # If any neighbor is not blue, it's not a valid hole (must be fully surrounded by blue)\n                    is_valid_hole = False\n                    break\n\n            # If the loop completed, all neighbors were blue, and they all belonged to the same blue component\n            if is_valid_hole and enclosing_blue_idx != -1:\n                # Add this white component (hole) to the list for the identified blue component\n                blue_component_holes[enclosing_blue_idx].append(white_component)\n\n    # 5. Modify the output grid based on blue components with exactly one hole\n    for blue_idx, holes in blue_component_holes.items():\n        # Check if this blue component has exactly one associated hole\n        if len(holes) == 1:\n            # Get the coordinates of the single hole\n            single_hole_coords = holes[0]\n            # Get the coordinates of the enclosing blue shape\n            enclosing_blue_coords = blue_components[blue_idx]\n\n            # Change the color of the enclosing blue pixels to white (0)\n            for r, c in enclosing_blue_coords:\n                # Check bounds just in case, although component coords should be valid\n                if 0 <= r < height and 0 <= c < width:\n                     output_grid[r, c] = 0\n\n            # Change the color of the hole pixels to red (2)\n            for r, c in single_hole_coords:\n                # Check bounds just in case\n                if 0 <= r < height and 0 <= c < width:\n                     output_grid[r, c] = 2\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9123,
    "candidates_token_count": 2003,
    "total_token_count": 11126,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.550501
}