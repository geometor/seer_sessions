{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms pixels based on their color and Manhattan distance to a specific target color (Red(2) if present, else Green(3)).\n\n1.  Identify Target Color: Red(2) if present, otherwise Green(3). If neither is found, return the input grid.\n2.  Calculate Manhattan Distances: Compute the distance 'd' from each pixel to the nearest target pixel.\n3.  Initialize Output: Create a copy of the input grid.\n4.  Apply Transformations: Iterate through each pixel (r, c) with input color 'I' and distance 'd'.\n    - If Target is Red(2):\n        - Invariant: Red(2), Magenta(6), Gray(5).\n        - If I is Yellow(4):\n            - d=1: Magenta(6) if c<=1, else Yellow(4).\n            - d=2: Yellow(4).\n            - d=3: Gray(5).\n            - d=4: Gray(5).\n            - d=5: Yellow(4).\n            - d=6: Red(2).\n            - d>6: Yellow(4).\n            - d=0: Yellow(4) (implicitly handled by target invariance if Yellow was target, but target is Red).\n    - If Target is Green(3):\n        - Invariant: Green(3), Yellow(4), Maroon(9).\n        - If I is White(0):\n            - d=1: Maroon(9) if c == 4, else White(0).\n            - d=2: Green(3) if c <= 2, Yellow(4) if c >= 6, else White(0).\n            - d=3: Green(3) if c <= 2 or (c == 3 and r % 2 != 0), Yellow(4) if c >= 6 or (c == 5 and r % 2 != 0), else White(0).\n            - d=4: Green(3) if c <= 1, Yellow(4) if c >= 6, else White(0).\n            - d=5: Green(3).\n            - d=0 or d > 5: White(0) (d=0 case handled by target invariance).\n5.  Return the modified output grid.\n\"\"\"\n\n\ndef get_manhattan_distances(grid, target_color):\n    \"\"\"\n    Calculates the Manhattan distance from each cell to the nearest target_color cell.\n    Returns a grid of distances. Returns inf if target_color is not found.\n    \"\"\"\n    height, width = grid.shape\n    target_coords = np.argwhere(grid == target_color)\n\n    if target_coords.size == 0:\n        # Return infinite distance if target color not found\n        return np.full(grid.shape, np.inf)\n\n    # Create coordinate grids\n    r_coords, c_coords = np.indices(grid.shape)\n\n    # Calculate distances from each cell to all target cells\n    # Use broadcasting for efficiency\n    distances = np.abs(r_coords[:, :, np.newaxis] - target_coords[:, 0]) + \\\n                np.abs(c_coords[:, :, np.newaxis] - target_coords[:, 1])\n\n    # Find the minimum distance for each cell\n    min_distances = np.min(distances, axis=2)\n\n    return min_distances.astype(int)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    height, width = input_grid.shape\n    # Initialize output_grid\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify Target Color\n    unique_colors = np.unique(input_grid)\n    target_color = -1\n    if 2 in unique_colors: # Red\n        target_color = 2\n    elif 3 in unique_colors: # Green\n        target_color = 3\n    else:\n        # No specific target color identified, return input\n        return output_grid\n\n    # 2. Calculate Distances\n    distance_grid = get_manhattan_distances(input_grid, target_color)\n\n    # 3. Apply Transformations\n    for r in range(height):\n        for c in range(width):\n            input_color = input_grid[r, c]\n            distance = distance_grid[r, c]\n\n            # Apply rules based on identified target color\n            if target_color == 2: # Red Target\n                # Check invariant colors first (implicitly handles target color itself)\n                if input_color in [2, 6, 5]:\n                    output_grid[r, c] = input_color # No change\n                elif input_color == 4: # Yellow transformation logic\n                    if distance == 1:\n                        if c <= 1:\n                            output_grid[r, c] = 6 # Magenta\n                        else: # c > 1\n                            output_grid[r, c] = 4 # Yellow\n                    elif distance == 2:\n                         output_grid[r, c] = 4 # Yellow\n                    elif distance == 3:\n                        output_grid[r, c] = 5 # Gray\n                    elif distance == 4:\n                        output_grid[r, c] = 5 # Gray\n                    elif distance == 5:\n                         output_grid[r, c] = 4 # Yellow\n                    elif distance == 6:\n                        output_grid[r, c] = 2 # Red\n                    else: # d=0 (is target=Red) or d > 6\n                         # If d=0, input_color would be 2 (handled above).\n                         # If d > 6, output is Yellow.\n                         output_grid[r, c] = 4 # Yellow\n                # Other colors (if any existed) would remain unchanged by default\n\n            elif target_color == 3: # Green Target\n                # Check invariant colors first (implicitly handles target color itself)\n                if input_color in [3, 4, 9]:\n                    output_grid[r, c] = input_color # No change\n                elif input_color == 0: # White transformation logic\n                    if distance == 1:\n                        if c == 4: # Column of Green pixel\n                            output_grid[r, c] = 9 # Maroon\n                        else:\n                            output_grid[r, c] = 0 # White\n                    elif distance == 2:\n                        if c <= 2:\n                            output_grid[r, c] = 3 # Green\n                        elif c >= 6:\n                            output_grid[r, c] = 4 # Yellow\n                        else: # 2 < c < 6\n                            output_grid[r, c] = 0 # White\n                    elif distance == 3:\n                        if c <= 2 or (c == 3 and r % 2 != 0):\n                            output_grid[r, c] = 3 # Green\n                        elif c >= 6 or (c == 5 and r % 2 != 0):\n                            output_grid[r, c] = 4 # Yellow\n                        else:\n                            output_grid[r, c] = 0 # White\n                    elif distance == 4:\n                        if c <= 1:\n                             output_grid[r, c] = 3 # Green\n                        elif c >= 6:\n                             output_grid[r, c] = 4 # Yellow\n                        else: # 1 < c < 6\n                             output_grid[r, c] = 0 # White\n                    elif distance == 5:\n                        output_grid[r, c] = 3 # Green\n                    else: # d=0 (is target=Green) or d > 5\n                        # If d=0, input_color would be 3 (handled above).\n                        # If d > 5, output is White.\n                        output_grid[r, c] = 0 # White\n                # Other colors (if any existed) would remain unchanged by default\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10144,
    "candidates_token_count": 1842,
    "total_token_count": 11986,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.82234
}