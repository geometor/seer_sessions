{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify all distinct connected objects in the input grid.\nSeparate objects into two groups: 'target' objects (composed solely of azure color 8) \nand 'pattern' objects (composed of any other non-background color).\nSort both groups based on their top-left coordinate (row first, then column).\nInitialize an output grid of the same size as the input, filled with the background color (white 0).\nIterate through the sorted target objects. For each target object at index 'i', \nselect the pattern object at index 'i mod num_patterns'.\nCopy the pixel pattern of the selected pattern object onto the output grid, \naligning the top-left corner of the pattern with the top-left corner of the target object's original position.\nEnsure copying respects grid boundaries.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected objects of non-background colors in the grid.\n\n    Args:\n        grid: A numpy array representing the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains:\n        'pixels': list of (row, col, color) tuples.\n        'min_row', 'min_col': top-left coordinates.\n        'is_target': boolean, True if the object is entirely azure (8).\n        'pattern_pixels': list of (rel_row, rel_col, color) for pattern objects.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                object_pixels = []\n                is_target_candidate = True\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                current_object_pixels_coords = set()\n                \n                while q:\n                    row, col = q.pop(0)\n                    \n                    # Check if pixel already processed for this object to handle complex shapes\n                    if (row, col) in current_object_pixels_coords:\n                        continue\n                    current_object_pixels_coords.add((row, col))\n\n                    px_color = grid[row, col]\n                    object_pixels.append((row, col, px_color))\n                    \n                    if px_color != 8:\n                        is_target_candidate = False # Found a non-azure color\n                        \n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != 0:\n                           # Check if neighbor belongs to the same object (initially, check for same color, but ARC objects can be multi-color)\n                           # For this task, target objects are defined as *only* azure. Pattern objects can be multi-color.\n                           # Let's assume connectivity means any non-background color adjacent.\n                           visited[nr, nc] = True\n                           q.append((nr, nc))\n                           \n                # Post-processing for the found object\n                is_target = is_target_candidate # It's a target ONLY if all pixels were azure\n                \n                # Check if all pixels were actually azure for is_target\n                if is_target:\n                     for pr, pc, pcol in object_pixels:\n                         if pcol != 8:\n                             # This case should technically not happen if is_target_candidate logic is correct, but double-checking\n                             is_target = False \n                             break\n\n                # Calculate relative pattern pixels only if it's NOT a target\n                pattern_pixels_rel = []\n                if not is_target:\n                    for px_r, px_c, px_col in object_pixels:\n                        pattern_pixels_rel.append((px_r - min_r, px_c - min_c, px_col))\n                        \n                objects.append({\n                    'pixels': object_pixels,\n                    'min_row': min_r,\n                    'min_col': min_c,\n                    'is_target': is_target,\n                    'pattern_pixels': pattern_pixels_rel # Only relevant for pattern objects\n                })\n\n    # Sort objects by top-left coordinate (row, then column)\n    objects.sort(key=lambda obj: (obj['min_row'], obj['min_col']))\n    \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replacing azure objects with patterns from other objects.\n    \"\"\"\n    rows, cols = input_grid.shape\n    # Initialize output_grid with background color (0)\n    output_grid = np.zeros((rows, cols), dtype=int)\n\n    # Find all objects in the input grid\n    all_objects = find_objects(input_grid)\n\n    # Separate objects into target (azure) and pattern objects\n    target_objects = [obj for obj in all_objects if obj['is_target']]\n    pattern_objects = [obj for obj in all_objects if not obj['is_target']]\n\n    # Check if there are any patterns to use\n    if not pattern_objects:\n        return output_grid # Or return input_grid? Task implies replacement, so empty grid if no patterns.\n\n    num_patterns = len(pattern_objects)\n\n    # Iterate through sorted target objects and place corresponding patterns\n    for i, target_obj in enumerate(target_objects):\n        # Determine which pattern to use (cyclical)\n        pattern_index = i % num_patterns\n        pattern_to_use = pattern_objects[pattern_index]\n        \n        # Get the top-left corner where the pattern should be placed\n        target_start_row = target_obj['min_row']\n        target_start_col = target_obj['min_col']\n        \n        # Get the relative pixel data for the pattern\n        pattern_pixels_rel = pattern_to_use['pattern_pixels']\n        \n        # \"Stamp\" the pattern onto the output grid\n        for rel_r, rel_c, color in pattern_pixels_rel:\n            output_row = target_start_row + rel_r\n            output_col = target_start_col + rel_c\n            \n            # Ensure the pixel is within the grid bounds\n            if 0 <= output_row < rows and 0 <= output_col < cols:\n                output_grid[output_row, output_col] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3343,
    "candidates_token_count": 1633,
    "total_token_count": 4976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.417046
}