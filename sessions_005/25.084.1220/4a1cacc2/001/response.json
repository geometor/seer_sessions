{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef _find_unique_pixel(grid_np, background_color=8):\n    \"\"\"\n    Finds the color and coordinates (row, column) of the unique pixel \n    in the grid that does not match the background color.\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n        background_color (int): The color value considered as background.\n\n    Returns:\n        tuple: (color, row, column) of the unique pixel. \n               Returns (None, -1, -1) if no unique non-background pixel is found \n               or if more than one is found.\n    \"\"\"\n    coords = np.where(grid_np != background_color)\n    num_unique = len(coords[0])\n\n    if num_unique == 1:\n        r, c = coords[0][0], coords[1][0]\n        color = grid_np[r, c]\n        return color, r, c\n    elif num_unique > 1:\n        # According to the task description, there should only be one unique pixel.\n        # Handle this case defensively, though it might indicate a misunderstanding\n        # or unexpected input. Returning the first one found.\n        # print(f\"Warning: Found {num_unique} non-background pixels. Using the first one.\")\n        r, c = coords[0][0], coords[1][0]\n        color = grid_np[r, c]\n        return color, r, c\n    else:\n        # No non-background pixel found\n        return None, -1, -1\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the position of a single unique pixel.\n    Finds the unique non-background pixel in the input grid. Calculates the areas\n    of the four quadrants defined by this pixel's location (relative to the pixel itself).\n    Identifies the quadrant with the smallest area. Creates an output grid of the \n    same size filled with the background color (azure/8), and draws a solid rectangle \n    in the corner corresponding to the smallest quadrant, using the unique pixel's color \n    and the quadrant's dimensions. In case of ties in area, the priority for choosing \n    the corner is Top-Left > Top-Right > Bottom-Left > Bottom-Right.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape  # Grid Height and Width\n    background_color = 8   # Azure color is the background\n\n    # Step 1: Find the unique pixel's color and location (R, C)\n    source_color, R, C = _find_unique_pixel(input_np, background_color)\n\n    # If no unique pixel found, return a grid filled with background color\n    if source_color is None:\n        return np.full((H, W), background_color, dtype=int).tolist()\n\n    # Step 2: Initialize the output grid with the background color\n    output_np = np.full((H, W), background_color, dtype=int)\n\n    # Step 3: Calculate dimensions and areas of the four quadrants\n    # Quadrant dimensions are inclusive of the pixel's row/column\n    h_tl, w_tl = R + 1, C + 1  # Top-Left height, width\n    area_tl = h_tl * w_tl      # Top-Left area\n\n    h_tr, w_tr = R + 1, W - C  # Top-Right height, width\n    area_tr = h_tr * w_tr      # Top-Right area\n\n    h_bl, w_bl = H - R, C + 1  # Bottom-Left height, width\n    area_bl = h_bl * w_bl      # Bottom-Left area\n\n    h_br, w_br = H - R, W - C  # Bottom-Right height, width\n    area_br = h_br * w_br      # Bottom-Right area\n\n    # Step 4: Store quadrant info with priority (TL > TR > BL > BR)\n    # This order ensures correct selection during tie-breaking\n    quadrants = [\n        {'label': 'TL', 'area': area_tl, 'h': h_tl, 'w': w_tl},\n        {'label': 'TR', 'area': area_tr, 'h': h_tr, 'w': w_tr},\n        {'label': 'BL', 'area': area_bl, 'h': h_bl, 'w': w_bl},\n        {'label': 'BR', 'area': area_br, 'h': h_br, 'w': w_br},\n    ]\n\n    # Step 5: Find the minimum area among the quadrants\n    min_area_value = min(q['area'] for q in quadrants)\n    \n    # Step 6: Select the quadrant corresponding to the minimum area, respecting priority\n    chosen_quadrant = None\n    for quad in quadrants:\n        if quad['area'] == min_area_value:\n            chosen_quadrant = quad\n            break  # Stop at the first match (highest priority due to list order)\n\n    # Should always find a quadrant if input was valid\n    if chosen_quadrant is None:\n        # Fallback: return background grid if something went wrong\n        return output_np.tolist() \n\n    target_h = chosen_quadrant['h']\n    target_w = chosen_quadrant['w']\n    corner_label = chosen_quadrant['label']\n\n    # Step 7: Fill the determined corner region in the output grid\n    # Check for positive dimensions before slicing to avoid errors/empty operations\n    if target_h > 0 and target_w > 0:\n        if corner_label == 'TL':\n            # Fill top-left corner: rows 0 to target_h, columns 0 to target_w\n            output_np[0:target_h, 0:target_w] = source_color\n        elif corner_label == 'TR':\n            # Fill top-right corner: rows 0 to target_h, columns W-target_w to W\n            output_np[0:target_h, W-target_w:W] = source_color\n        elif corner_label == 'BL':\n            # Fill bottom-left corner: rows H-target_h to H, columns 0 to target_w\n            output_np[H-target_h:H, 0:target_w] = source_color\n        elif corner_label == 'BR':\n            # Fill bottom-right corner: rows H-target_h to H, columns W-target_w to W\n            output_np[H-target_h:H, W-target_w:W] = source_color\n\n    # Convert the output NumPy array back to a list of lists before returning\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3330,
    "candidates_token_count": 1614,
    "total_token_count": 4944,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.468012
}