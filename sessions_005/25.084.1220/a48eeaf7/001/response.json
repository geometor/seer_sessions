{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nMove gray pixels (color 5) towards the nearest part of a static red object (color 2) \nuntil they become adjacent (including diagonals) to any part of the red object.\nThe red object and background (color 0) remain unchanged.\n\"\"\"\n\ndef find_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef manhattan_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:\n    \"\"\"Calculates the Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef is_adjacent(p1: Tuple[int, int], p2: Tuple[int, int]) -> bool:\n    \"\"\"Checks if two points are adjacent (including diagonals).\"\"\"\n    return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) == 1\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Moves gray pixels towards the nearest red pixel until adjacency is reached.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Identify all pixels belonging to the static red (2) object\n    red_pixels = find_pixels(grid, 2)\n\n    # 2. Identify all gray (5) pixels in the input grid\n    gray_pixels_initial = find_pixels(grid, 5)\n\n    # Handle cases with no red or no gray pixels\n    if not red_pixels or not gray_pixels_initial:\n        return output_grid.tolist() # Return the original grid\n\n    # 3. For each identified gray pixel:\n    for initial_pos in gray_pixels_initial:\n        r_init, c_init = initial_pos\n\n        # a. Remove the gray pixel from its original position in the output grid\n        output_grid[r_init, c_init] = 0\n\n        # b. Calculate distances to red pixels\n        min_dist = float('inf')\n        target_red_pixels = []\n        for red_pos in red_pixels:\n            dist = manhattan_distance(initial_pos, red_pos)\n            if dist < min_dist:\n                min_dist = dist\n                target_red_pixels = [red_pos]\n            elif dist == min_dist:\n                target_red_pixels.append(red_pos)\n\n        # c. Select one target red pixel consistently (e.g., smallest row, then col)\n        target_red_pixels.sort()\n        target_red_pos = target_red_pixels[0]\n        r_target, c_target = target_red_pos\n\n        # d. Set the gray pixel's current position to its initial position\n        current_pos = initial_pos\n\n        # e. Start a movement loop:\n        while True:\n            # i. Check adjacency to *any* red pixel\n            is_adj = False\n            for red_pos in red_pixels:\n                if is_adjacent(current_pos, red_pos):\n                    is_adj = True\n                    break\n            \n            # ii. If adjacent, exit the loop\n            if is_adj:\n                break\n\n            # Check if we are already at the target (can happen if initial pos is the target)\n            # Although the problem description implies movement towards, this handles a theoretical edge case.\n            # More importantly, stops if movement calculation yields (0,0) but not adjacent.\n            if current_pos == target_red_pos:\n                 break # Should ideally not happen unless initial pos is target itself.\n\n            # iii. Calculate the next step direction towards the target red pixel\n            r_curr, c_curr = current_pos\n            dr = np.sign(r_target - r_curr) # -1, 0, or 1\n            dc = np.sign(c_target - c_curr) # -1, 0, or 1\n\n            # iv. Update the gray pixel's current position\n            next_r, next_c = r_curr + dr, c_curr + dc\n            \n            # Boundary check (should not be strictly necessary if target is within grid, but good practice)\n            next_r = max(0, min(height - 1, next_r))\n            next_c = max(0, min(width - 1, next_c))\n            \n            current_pos = (next_r, next_c)\n            \n            # Safety break to prevent infinite loops in unforeseen circumstances\n            # (e.g., if somehow dr=0 and dc=0 but not adjacent)\n            if dr == 0 and dc == 0:\n                 # print(f\"Warning: Stuck at {current_pos} for target {target_red_pos}\")\n                 break\n\n\n        # f. Place the gray (5) color at the final position in the output grid\n        final_r, final_c = current_pos\n        # Ensure the final position is within bounds (redundant with boundary check above but safe)\n        if 0 <= final_r < height and 0 <= final_c < width:\n             # Check if the final spot is occupied by the static red object itself. \n             # If so, we shouldn't overwrite it (although the adjacency check should prevent this).\n             # It's more likely another gray pixel might end up here. We allow overwriting white.\n             # Based on examples, gray pixels can end up next to each other, possibly overwriting previous gray final spots.\n             # Let's assume the last gray pixel processed 'wins' the spot if there's overlap.\n            if output_grid[final_r, final_c] != 2: # Don't overwrite red\n                 output_grid[final_r, final_c] = 5\n\n\n    # 4. Return the modified output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3180,
    "candidates_token_count": 1455,
    "total_token_count": 4635,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.965354
}