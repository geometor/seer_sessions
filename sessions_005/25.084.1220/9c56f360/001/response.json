{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\nIdentifies green (3) pixels in the input grid. For each green pixel, determines a target destination column within the same row by scanning leftwards until an azure (8) pixel (obstacle) or the grid edge (column 0) is encountered. The target column is the one immediately to the right of the obstacle, or column 0 if no obstacle is found. If multiple green pixels in the same row target the same initial column, they stack horizontally to the right, preserving their original relative left-to-right order. The leftmost original pixel takes the target column, the next takes the column to its right, and so on. Azure pixels (8) remain static. Original positions of moved green pixels become white (0).\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving azure pixels and background\n    output_np = input_np.copy()\n    rows, cols = input_np.shape\n\n    # --- Step 1: Identify green pixels and clear their original positions ---\n    green_pixels_orig = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 3:\n                green_pixels_orig.append((r, c))\n                # Clear the original position in the output grid\n                # Obstacles (8) are not cleared as they are static\n                if output_np[r, c] == 3:\n                     output_np[r, c] = 0\n\n    # --- Step 2: Calculate initial target column for each green pixel ---\n    # Stores dictionaries: {'orig': (r, c_orig), 'target_col': c_target}\n    moves = []\n    for r, c_orig in green_pixels_orig:\n        c_target = 0 # Default target is the leftmost column (0)\n        # Scan leftwards from the column just left of the original position\n        for c_scan in range(c_orig - 1, -1, -1):\n            # Check for an obstacle (azure pixel, color 8) in the input grid\n            if input_np[r, c_scan] == 8:\n                # Target column is the one immediately to the right of the obstacle\n                c_target = c_scan + 1\n                break # Stop scanning left once the first obstacle is found\n        moves.append({'orig': (r, c_orig), 'target_col': c_target})\n\n    # --- Step 3: Process moves row by row to handle stacking ---\n    # Stores the final (r, c_dest) coordinates where green pixels will be placed\n    final_placements = []\n\n    # Group moves by row for independent processing\n    moves_by_row = {}\n    for move in moves:\n        r = move['orig'][0]\n        if r not in moves_by_row:\n            moves_by_row[r] = []\n        moves_by_row[r].append(move)\n\n    # Process each row that contains green pixels\n    for r, row_moves in moves_by_row.items():\n        # Sort moves within the row:\n        # Primary key: target_col (ascending) - groups pixels aiming for the same spot\n        # Secondary key: original column c_orig (ascending) - preserves relative order\n        sorted_row_moves = sorted(row_moves, key=lambda m: (m['target_col'], m['orig'][1]))\n\n        # Keep track of columns occupied by static obstacles (8) or already placed green pixels in this row\n        # Initialize with the positions of azure (8) pixels in the current row\n        occupied_cols_in_row = set()\n        for c in range(cols):\n             if output_np[r, c] == 8: # Check the output grid copy which holds static elements\n                 occupied_cols_in_row.add(c)\n\n        # Determine final destination for each move in the sorted list\n        for move in sorted_row_moves:\n            c_target = move['target_col']\n            # Start checking for placement at the initial target column\n            c_dest = c_target\n\n            # Resolve collisions/stacking: find the first available column >= c_target\n            while c_dest in occupied_cols_in_row:\n                c_dest += 1 # Move one column to the right\n\n            # Check if the destination is within grid bounds\n            if c_dest < cols:\n                # Record the final placement coordinates\n                final_placements.append((r, c_dest))\n                # Mark this column as occupied for subsequent pixels in the same row\n                occupied_cols_in_row.add(c_dest)\n            # else: Pixel would be pushed off the grid edge. Based on examples, this case might not occur or is handled implicitly.\n\n    # --- Step 4: Place green pixels in their final determined positions ---\n    # Update the output grid with the final positions of the green pixels\n    for r, c_dest in final_placements:\n         # Ensure coordinates are valid (redundant check if logic is perfect, but safe)\n         if 0 <= r < rows and 0 <= c_dest < cols:\n             # Place the green pixel (3)\n             output_np[r, c_dest] = 3\n\n    # Convert the final NumPy array back to a list of lists for the required output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3101,
    "candidates_token_count": 1325,
    "total_token_count": 4426,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.5786
}