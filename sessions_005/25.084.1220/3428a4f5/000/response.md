Okay, let's analyze the task based on the provided examples.

## Perception

1.  **Input Grid Structure:** The input grids consistently have dimensions of 13 rows by 5 columns.
2.  **Output Grid Structure:** The output grids consistently have dimensions of 6 rows by 5 columns.
3.  **Color Palette:**
    *   Inputs use white (0), red (2), and yellow (4).
    *   Outputs use white (0) and green (3).
4.  **Key Feature - Separator:** Each input grid contains a single, full row of yellow (4) pixels. In all examples, this yellow line is located at row index 6 (the 7th row).
5.  **Grid Division:** The yellow line acts as a separator, dividing the input grid into two distinct subgrids of equal size (6x5):
    *   An "upper grid" consisting of rows 0-5.
    *   A "lower grid" consisting of rows 7-12.
    *   The yellow line itself (row 6) is not directly represented in the output.
6.  **Transformation:** The output grid (6x5) seems to be generated by combining information from the corresponding upper grid and lower grid. The dimensions match exactly.
7.  **Pixel-wise Operation:** Comparing the upper grid, lower grid, and output grid at the same coordinates `(row, column)` suggests a pixel-wise rule:
    *   Let `U(r, c)` be the pixel value in the upper grid at `(r, c)`.
    *   Let `L(r, c)` be the pixel value in the lower grid at `(r, c)`.
    *   Let `O(r, c)` be the pixel value in the output grid at `(r, c)`.
    *   Observing the examples:
        *   If `U(r, c)` is white (0) and `L(r, c)` is white (0), then `O(r, c)` is white (0).
        *   If `U(r, c)` is red (2) and `L(r, c)` is white (0), then `O(r, c)` is green (3).
        *   If `U(r, c)` is white (0) and `L(r, c)` is red (2), then `O(r, c)` is green (3).
        *   If `U(r, c)` is red (2) and `L(r, c)` is red (2), then `O(r, c)` is white (0).
8.  **Logical Equivalence:** This combination rule is equivalent to a bitwise XOR operation if we temporarily map white (0) to 0 and red (2) to 1. The result 0 maps back to white (0) and the result 1 maps to green (3).
    *   `0 XOR 0 = 0` (white)
    *   `1 XOR 0 = 1` (green)
    *   `0 XOR 1 = 1` (green)
    *   `1 XOR 1 = 0` (white)

## Facts


```yaml
InputGrid:
  properties:
    height: 13
    width: 5
    colors_present: [white, red, yellow]
  objects:
    - type: horizontal_line
      color: yellow
      location: row_index_6
      role: separator
    - type: subgrid
      name: UpperGrid
      location: rows 0 through 5
      height: 6
      width: 5
      colors_present: [white, red]
    - type: subgrid
      name: LowerGrid
      location: rows 7 through 12
      height: 6
      width: 5
      colors_present: [white, red]

OutputGrid:
  properties:
    height: 6
    width: 5
    colors_present: [white, green]
  derivation: derived from combining UpperGrid and LowerGrid

Transformation:
  type: pixel_wise_combination
  input_elements: Corresponding pixels from UpperGrid and LowerGrid at position (r, c)
  output_element: Pixel in OutputGrid at position (r, c)
  rule:
    - if UpperGrid(r, c) is white AND LowerGrid(r, c) is white: OutputGrid(r, c) is white
    - if UpperGrid(r, c) is red AND LowerGrid(r, c) is white: OutputGrid(r, c) is green
    - if UpperGrid(r, c) is white AND LowerGrid(r, c) is red: OutputGrid(r, c) is green
    - if UpperGrid(r, c) is red AND LowerGrid(r, c) is red: OutputGrid(r, c) is white
  logical_equivalent: Bitwise XOR (white=0, red=1 -> white=0, green=1)
```


## Natural Language Program

1.  Identify the row index containing the horizontal line of yellow (4) pixels in the input grid.
2.  Extract the portion of the input grid located above this yellow line; call this the `UpperGrid`.
3.  Extract the portion of the input grid located below this yellow line; call this the `LowerGrid`.
4.  Create a new output grid with the same dimensions as the `UpperGrid` (which will also match the dimensions of the `LowerGrid`).
5.  Iterate through each cell position `(row, column)` within the dimensions of the `UpperGrid`.
6.  For the current position `(row, column)`:
    a.  Get the pixel value `upper_pixel` from `UpperGrid` at `(row, column)`.
    b.  Get the pixel value `lower_pixel` from `LowerGrid` at `(row, column)`.
    c.  Apply the combination rule:
        i.  If both `upper_pixel` and `lower_pixel` are red (2), set the output grid pixel at `(row, column)` to white (0).
        ii. If both `upper_pixel` and `lower_pixel` are white (0), set the output grid pixel at `(row, column)` to white (0).
        iii. Otherwise (one pixel is red (2) and the other is white (0)), set the output grid pixel at `(row, column)` to green (3).
7.  Return the completed output grid.