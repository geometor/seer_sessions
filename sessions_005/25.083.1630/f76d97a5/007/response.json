{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify \"X\" Shape:** Examine the input grid and identify if a diagonally connected \"X\" shape exists.\n    *   An \"X\" shape is formed by a single color.\n    *   The \"X\" must have diagonal contiguity.\n    *   The central part of the \"X\" can be either a single pixel or a 2x2 block of pixels of the same color.\n\n2.  **Preserve \"X\" Color:** If an \"X\" shape is found, preserve *only* the pixels of that color in the output grid. All other pixels in the output grid should be set to 0 (background).\n\n3. **Handle \"+\" Shape:** If no \"X\" shape exists, then try to identify a \"+\" shape.\n    * A plus is identified by a single color.\n    * The center of the \"+\" shape is a single pixel that is the same color above, below, left, and right.\n\n4. **Preserve \"+\" Color:** If a \"+\" shape is found, preserve only the color in the shape.\n\n5. **Update \"+\" Color:** It seems that the + should use the color present in the corners of the grid\n\n\"\"\"\n\nimport numpy as np\n\ndef find_x_shape(grid):\n    \"\"\"\n    Finds the color forming a contiguous 'X' shape in the grid.\n    Returns the color if found, otherwise returns None. Considers both 1x1 and 2x2 centers.\n    \"\"\"\n    rows, cols = grid.shape\n    colors = np.unique(grid)\n\n    for color in colors:\n        if color == 0:\n            continue\n\n        coords = np.argwhere(grid == color)\n        if len(coords) < 5: #minimum for an x\n          continue\n\n        # Check for 2x2 center\n        center_2x2 = False\n        for r in range(rows - 1):\n            for c in range(cols - 1):\n                if (grid[r, c] == color and grid[r + 1, c] == color and\n                    grid[r, c + 1] == color and grid[r + 1, c + 1] == color):\n                    center_2x2 = True\n                    break\n            if center_2x2:\n                break\n\n        # check for 1x1 center\n        center_1x1 = False\n        if not center_2x2:\n          for r in range(1,rows - 1):\n            for c in range(1, cols - 1):\n              if grid[r,c] == color:\n                # check diagonals\n                if (grid[r-1,c-1] == color or grid[r-1, c+1] == color) and \\\n                    (grid[r+1, c-1] == color or grid[r+1, c+1] == color):\n                  center_1x1 = True\n                  break\n            if center_1x1: break\n          \n        if not center_1x1 and not center_2x2: continue\n\n        # Check for contiguity from the center outwards\n        min_r, min_c = np.min(coords, axis=0)\n        max_r, max_c = np.max(coords, axis=0)\n        \n        is_x = True\n        \n        # this part is still very difficult to get right, use the min/max rows\n        if center_1x1:\n\n          for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n              # check to see if part of x\n              on_diag = False\n              \n              # check primary diags\n              if (r - min_r) == (c - min_c):\n                on_diag = True\n              \n              if center_2x2:\n                if (r - min_r) == (c - min_c -1):\n                  on_diag = True\n                if (r - min_r - 1) == (c - min_c):\n                  on_diag = True\n              # check cross diag\n              if (r-min_r) == (max_c - c):\n                on_diag = True\n              \n              if center_2x2:\n                if (r - min_r -1 ) == (max_c - c):\n                  on_diag = True\n                if (r - min_r) == (max_c - c - 1):\n                  on_diag = True\n                \n              if on_diag and grid[r,c] != color:\n                  is_x = False\n                  break\n              if not on_diag and grid[r,c] == color:\n                  is_x = False\n                  break\n            if not is_x: break\n\n        if is_x:\n            return color\n\n    return None\n\ndef find_plus_shape(grid):\n    \"\"\"\n    Identifies a '+' shape in the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    colors = np.unique(grid)\n\n    for color in colors:\n      if color == 0: continue\n      \n      for r in range(1, rows - 1):\n          for c in range(1, cols - 1):\n            if grid[r,c] == color:\n              if (grid[r+1, c] == color and grid[r-1, c] == color and grid[r, c+1] == color and grid[r, c-1] == color):\n                return color\n    return None\n    \ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Find X shape color\n    x_color = find_x_shape(input_grid)\n\n    if x_color is not None:\n        # Preserve X shape color\n        for r in range(input_grid.shape[0]):\n            for c in range(input_grid.shape[1]):\n                if input_grid[r, c] == x_color:\n                    output_grid[r, c] = x_color\n    else:\n      #look for plus\n      plus_color = find_plus_shape(input_grid)\n      \n      if plus_color is not None:\n        # use color from upper left\n        plus_new_color = input_grid[0,0]\n        for r in range(input_grid.shape[0]):\n          for c in range(input_grid.shape[1]):\n            if input_grid[r, c] == plus_color:\n              output_grid[r,c] = plus_new_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5925,
    "candidates_token_count": 1532,
    "total_token_count": 7457,
    "cached_content_token_count": 0
  },
  "response_time": 20.982547
}