
## train_1

**input:**
```
0 0 0 0 0 0 7 7 7 7 7 7
```


**output:**
```
0 0 7 7 7 7 7 7 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 7 7 0 0 0
```


**output:**
```
0 0 0 7 7 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 7 7 0 0 0 0 0
```


**output:**
```
0 7 7 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 6 6 6
```


**output:**
```
0 0 0 0 0 6 6 6 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 1 1 1 0
```


**output:**
```
0 0 0 0 1 1 1 0 0 0 0 0
```


## train_6

**input:**
```
0 0 0 0 0 7 7 7 7 7 0 0
```


**output:**
```
0 7 7 7 7 7 0 0 0 0 0 0
```


## train_7

**input:**
```
0 0 0 0 0 6 6 0 0 0 0 0
```


**output:**
```
0 6 6 0 0 0 0 0 0 0 0 0
```

*   **Perception**: The task involves manipulating sequences of 12 digits. Each input sequence contains a single contiguous block of identical non-zero digits, surrounded by zeros. The output sequence is generated by shifting this non-zero block exactly 4 positions to the left. The positions vacated by the shift, as well as the original positions of the leading zeros (up to the new start of the block), are filled with zeros. The length of the sequence remains 12.

*   **Facts**:
    
```yaml
    task_elements:
      - item: sequence
        properties:
          - type: list of digits
          - length: 12
          - content: primarily zeros with one contiguous block of identical non-zero digits
      - item: block
        properties:
          - type: contiguous sub-sequence
          - content: identical non-zero digits (e.g., 7, 6, 1)
          - location: defined by start and end indices within the sequence
        relationships:
          - part_of: sequence
      - item: zero
        properties:
          - type: digit
          - value: 0
          - role: background/filler
      - item: non_zero_digit
        properties:
          - type: digit
          - value: 1, 6, or 7 (based on examples)
          - role: constitutes the block
    transformation:
      - action: identify
        target: block
        details: Find the start index, end index, and value of the non-zero block in the input sequence.
      - action: calculate_new_position
        target: block
        details: Subtract 4 from the original start and end indices to determine the new position.
      - action: construct_output
        details:
          - Create a new sequence of 12 zeros.
          - Place the identified block into the new sequence at the calculated new position.
    constraints:
      - The input sequence length is always 12.
      - There is exactly one contiguous block of identical non-zero digits in the input.
      - The shift amount is consistently 4 positions to the left.
    ```


*   **Natural Language Program**:
    1.  Read the input sequence of 12 digits.
    2.  Identify the contiguous block of identical non-zero digits. Record its value, its start index, and its end index in the input sequence.
    3.  Create a new output sequence of 12 zeros.
    4.  Calculate the new start index for the block by subtracting 4 from its original start index.
    5.  Calculate the new end index for the block by subtracting 4 from its original end index.
    6.  Copy the identified block (using its recorded value) into the output sequence, starting at the calculated new start index and ending at the calculated new end index.
    7.  Return the modified output sequence.
```python
import numpy as np
from typing import List, Tuple, Optional

def find_block(sequence: List[int]) -> Optional[Tuple[int, int, int]]:
    """
    Finds the contiguous block of identical non-zero digits in a sequence.

    Args:
        sequence: The input list of digits.

    Returns:
        A tuple containing (start_index, end_index, value) of the block,
        or None if no such block is found.
    """
    start_index = -1
    block_value = -1
    for i, digit in enumerate(sequence):
        if digit != 0:
            if start_index == -1:
                start_index = i
                block_value = digit
            elif digit != block_value: # Should not happen based on description, but good practice
                return None # Or handle error: Found different non-zero digit
        elif start_index != -1: # We found a zero after the block started
            # Block ends at the previous index
            return start_index, i - 1, block_value
    # Handle case where block goes to the end of the sequence
    if start_index != -1:
        return start_index, len(sequence) - 1, block_value
    return None # No non-zero block found


def transform(input_sequence_str: str) -> str:
    """
    Identifies a contiguous block of identical non-zero digits in a 12-digit input sequence
    (represented as a string) and shifts this block 4 positions to the left, filling the
    rest of the sequence with zeros.

    Args:
        input_sequence_str: A string representing the input sequence of 12 digits,
                           separated by spaces.

    Returns:
        A string representing the transformed sequence of 12 digits, separated by spaces.
    """
    # 1. Read the input sequence and convert to list of integers
    input_sequence = [int(d) for d in input_sequence_str.split()]
    n = len(input_sequence)
    if n != 12:
        raise ValueError("Input sequence must have length 12")

    # 2. Identify the contiguous block of identical non-zero digits
    block_info = find_block(input_sequence)

    # 3. Create a new output sequence of 12 zeros.
    output_sequence = [0] * n

    if block_info:
        start_index, end_index, block_value = block_info

        # 4. Calculate the new start index for the block
        new_start_index = start_index - 4

        # 5. Calculate the new end index for the block
        new_end_index = end_index - 4

        # Check bounds (although examples imply this is always safe)
        if new_start_index >= 0 and new_end_index < n:
             # 6. Copy the identified block into the output sequence at the new position
            for i in range(new_start_index, new_end_index + 1):
                output_sequence[i] = block_value
        else:
            # Handle cases where the shift would go out of bounds if necessary
            # Based on examples, this doesn't seem to be required. The block simply
            # gets placed starting at the new calculated index.
             pass # Or log a warning/error if strict bounds checking is needed

    # 7. Return the modified output sequence as a space-separated string
    return " ".join(map(str, output_sequence))

```
