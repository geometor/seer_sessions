{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport re\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies the location of the digit '2' and a contiguous block of identical digits (not '0' or '2').\nIf there is a sequence composed entirely of '0's between the block and '2', swaps the block and the sequence of '0's, moving the block adjacent to '2'.\nIf the block is already adjacent to '2', or if the space between them contains non-zero digits (other than the block itself), no changes are made.\n\"\"\"\n\ndef find_digit_index(data: List[int], digit: int) -> Optional[int]:\n    \"\"\"Finds the index of the first occurrence of a digit.\"\"\"\n    try:\n        return data.index(digit)\n    except ValueError:\n        return None\n\ndef find_digit_block(data: List[int]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the contiguous block of identical digits that are not 0 or 2.\n    Returns (digit_value, start_index, end_index) or None if not found.\n    \"\"\"\n    block_digit = -1\n    start_index = -1\n    end_index = -1\n    in_block = False\n\n    for i, digit in enumerate(data):\n        if digit != 0 and digit != 2:\n            if not in_block:\n                # Start of a potential block\n                block_digit = digit\n                start_index = i\n                in_block = True\n            elif digit == block_digit:\n                # Continue the current block\n                pass\n            else:\n                # Found a different non-zero/non-2 digit, meaning the previous block ended\n                end_index = i - 1\n                return block_digit, start_index, end_index\n        elif in_block:\n            # End of the block detected (found 0 or 2)\n            end_index = i - 1\n            return block_digit, start_index, end_index\n\n    # Handle case where block goes to the end of the list\n    if in_block:\n        end_index = len(data) - 1\n        return block_digit, start_index, end_index\n\n    return None # No block found\n\ndef is_all_zeros(sub_list: List[int]) -> bool:\n    \"\"\"Checks if a list contains only zeros.\"\"\"\n    if not sub_list: # Empty list doesn't count as all zeros for swapping purpose\n        return False\n    return all(digit == 0 for digit in sub_list)\n\ndef transform(input_str: str) -> str:\n    \"\"\"\n    Applies the transformation rule to the input string sequence.\n\n    1. Parses the input string into a list of integers.\n    2. Finds the index of '2'.\n    3. Finds the contiguous block of identical non-zero, non-'2' digits.\n    4. Checks if intermediate zeros exist between the block and '2'.\n    5. If yes, swaps the block and the zeros.\n    6. Returns the transformed sequence as a string.\n    \"\"\"\n    # Parse input string into a list of integers\n    input_list = [int(x) for x in input_str.split()]\n    output_list = list(input_list) # Start with a copy\n\n    # Find the index of '2'\n    two_index = find_digit_index(output_list, 2)\n    if two_index is None:\n        # Should not happen based on examples, but handle defensively\n        return input_str # Return original if '2' is missing\n\n    # Find the digit block\n    block_info = find_digit_block(output_list)\n    if block_info is None:\n         # Should not happen based on examples, but handle defensively\n        return input_str # Return original if block is missing\n\n    block_digit, block_start, block_end = block_info\n    block_len = block_end - block_start + 1\n\n    # Determine relative position and check for intermediate zeros\n    if block_end < two_index:\n        # Case: Block is to the left of '2'\n        intermediate_slice = output_list[block_end + 1 : two_index]\n        \n        # Check if the intermediate slice consists only of zeros and is not empty\n        if is_all_zeros(intermediate_slice):\n            # Perform swap: Move block next to '2', zeros to block's original start\n            zeros_slice = intermediate_slice\n            block_slice = output_list[block_start : block_end + 1]\n            \n            # Reconstruct the list\n            new_list = (output_list[:block_start] + \n                        zeros_slice + \n                        block_slice + \n                        output_list[two_index:])\n            output_list = new_list\n            \n    elif block_start > two_index:\n        # Case: Block is to the right of '2'\n        intermediate_slice = output_list[two_index + 1 : block_start]\n\n        # Check if the intermediate slice consists only of zeros and is not empty\n        if is_all_zeros(intermediate_slice):\n            # Perform swap: Move block next to '2', zeros after block's original end\n            zeros_slice = intermediate_slice\n            block_slice = output_list[block_start : block_end + 1]\n\n            # Reconstruct the list\n            new_list = (output_list[:two_index + 1] +\n                        block_slice +\n                        zeros_slice +\n                        output_list[block_end + 1:])\n            output_list = new_list\n\n    # Else (block is adjacent to '2' or separated by non-zeros): No change needed\n\n    # Format output list back into a string\n    return \" \".join(map(str, output_list))\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1855,
    "candidates_token_count": 2209,
    "total_token_count": 4064,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.145652,
  "retries": 1
}