{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport re\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies the location of the digit '2' and a contiguous block of identical digits (not '0' or '2') within an input sequence of 12 integers.\nIf there is a non-empty sequence composed entirely of '0's between the block and '2', swaps the block and the sequence of '0's, moving the block adjacent to '2'.\nIf the block is already adjacent to '2', or if the space between them contains non-zero digits (other than the block itself), or if the space is empty, no changes are made.\nReturns the potentially modified sequence.\n\"\"\"\n\ndef find_digit_index(data: List[int], digit: int) -> Optional[int]:\n    \"\"\"Finds the index of the first occurrence of a digit.\"\"\"\n    try:\n        return data.index(digit)\n    except ValueError:\n        return None\n\ndef find_digit_block(data: List[int]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the contiguous block of identical digits that are not 0 or 2.\n    Returns (digit_value, start_index, end_index) or None if not found.\n    Assumes only one such block exists per sequence based on examples.\n    \"\"\"\n    block_digit = -1\n    start_index = -1\n    end_index = -1\n    in_block = False\n\n    for i, digit in enumerate(data):\n        if digit != 0 and digit != 2:\n            if not in_block:\n                # Start of a potential block\n                block_digit = digit\n                start_index = i\n                in_block = True\n            elif digit == block_digit:\n                # Continue the current block\n                pass\n            else:\n                # Found a different non-zero/non-2 digit, meaning the previous block ended.\n                # This case assumes only one block type exists based on examples.\n                # If multiple *different* blocks existed, this logic would need adjustment.\n                end_index = i - 1\n                return block_digit, start_index, end_index\n        elif in_block:\n            # End of the block detected (found 0 or 2)\n            end_index = i - 1\n            return block_digit, start_index, end_index\n\n    # Handle case where block goes to the end of the list\n    if in_block:\n        end_index = len(data) - 1\n        return block_digit, start_index, end_index\n\n    return None # No block found\n\ndef is_all_zeros(sub_list: List[int]) -> bool:\n    \"\"\"Checks if a list contains only zeros and is not empty.\"\"\"\n    if not sub_list: # Empty list is not considered \"all zeros\" for the swap condition\n        return False\n    return all(digit == 0 for digit in sub_list)\n\ndef transform(input_list: List[int]) -> List[int]:\n    \"\"\"\n    Applies the transformation rule to the input list of integers.\n    \"\"\"\n    # Initialize output_list as a copy of the input\n    output_list = list(input_list)\n\n    # 1. Identify the index of '2'\n    two_index = find_digit_index(output_list, 2)\n    if two_index is None:\n        # Should not happen based on examples, return original if '2' is missing\n        return output_list\n\n    # 2. Identify the non-zero/non-2 digit block\n    block_info = find_digit_block(output_list)\n    if block_info is None:\n         # Should not happen based on examples, return original if block is missing\n        return output_list\n\n    block_digit, block_start, block_end = block_info\n    # block_len = block_end - block_start + 1 # Not strictly needed for reconstruction\n\n    # 3. Determine relative position and check for intermediate zeros\n    if block_end < two_index:\n        # Case: Block is to the left of '2'\n        # 4a. Examine the intermediate subsequence\n        intermediate_slice = output_list[block_end + 1 : two_index]\n\n        # 5a. Check if intermediate slice is non-empty and all zeros\n        if is_all_zeros(intermediate_slice):\n            # Perform swap: Move block next to '2', zeros to block's original start\n            zeros_slice = intermediate_slice\n            block_slice = output_list[block_start : block_end + 1]\n\n            # Reconstruct the list\n            new_list = (output_list[:block_start] +\n                        zeros_slice +\n                        block_slice +\n                        output_list[two_index:])\n            output_list = new_list # Update the list to be returned\n\n    elif block_start > two_index:\n        # Case: Block is to the right of '2'\n        # 4b. Examine the intermediate subsequence\n        intermediate_slice = output_list[two_index + 1 : block_start]\n\n        # 5b. Check if intermediate slice is non-empty and all zeros\n        if is_all_zeros(intermediate_slice):\n            # Perform swap: Move block next to '2', zeros after block's original end\n            zeros_slice = intermediate_slice\n            block_slice = output_list[block_start : block_end + 1]\n\n            # Reconstruct the list\n            new_list = (output_list[:two_index + 1] +\n                        block_slice +\n                        zeros_slice +\n                        output_list[block_end + 1:])\n            output_list = new_list # Update the list to be returned\n\n    # 6. Else (block is adjacent to '2', separated by non-zeros, or intermediate space is empty):\n    # No changes were made to output_list in these cases.\n\n    # 7. Return the resulting sequence\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6566,
    "candidates_token_count": 1615,
    "total_token_count": 8181,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.020397,
  "retries": 1
}