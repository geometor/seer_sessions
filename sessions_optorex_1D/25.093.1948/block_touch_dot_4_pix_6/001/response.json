{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport sys\nimport math\n# Add any other necessary imports here (e.g., numpy if needed for complex grid operations)\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Find the index of the digit `2` in the input sequence.\n2.  Check the segment immediately to the left of `2`. Scan leftwards, collecting consecutive `0`s (`intervening_zeros`).\n3.  If `intervening_zeros` are found and they are immediately preceded by a non-zero digit `d`, identify the full block of `d` digits (`adjacent_block`).\n4.  If such a block and zeros are found on the left, move the `intervening_zeros` to the position immediately before the start of the `adjacent_block`. Reconstruct and return the sequence.\n5.  If no change was made on the left, check the segment immediately to the right of `2`. Scan rightwards, collecting consecutive `0`s (`intervening_zeros`).\n6.  If `intervening_zeros` are found and they are immediately followed by a non-zero digit `d`, identify the full block of `d` digits (`adjacent_block`).\n7.  If such a block and zeros are found on the right, move the `intervening_zeros` to the position immediately after the end of the `adjacent_block`. Reconstruct and return the sequence.\n8.  If no changes were made on either side, return the original sequence.\n\"\"\"\n\ndef find_block_left(grid, start_scan_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits ending at start_scan_idx.\n    Returns the block's digit, start index, and end index, or None if no such block exists.\n    \"\"\"\n    if start_scan_idx < 0 or grid[start_scan_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[start_scan_idx]\n    block_end_idx = start_scan_idx\n    block_start_idx = block_end_idx\n    while block_start_idx > 0 and grid[block_start_idx - 1] == block_digit:\n        block_start_idx -= 1\n    return block_digit, block_start_idx, block_end_idx\n\ndef find_block_right(grid, start_scan_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits starting at start_scan_idx.\n    Returns the block's digit, start index, and end index, or None if no such block exists.\n    \"\"\"\n    if start_scan_idx >= len(grid) or grid[start_scan_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[start_scan_idx]\n    block_start_idx = start_scan_idx\n    block_end_idx = block_start_idx\n    while block_end_idx < len(grid) - 1 and grid[block_end_idx + 1] == block_digit:\n        block_end_idx += 1\n    return block_digit, block_start_idx, block_end_idx\n\n\ndef transform(input_str):\n    \"\"\"\n    Applies the transformation rule to the input string sequence.\n    \"\"\"\n    # Parse input string into a list of integers\n    grid = [int(d) for d in input_str.split()]\n    n = len(grid)\n\n    # Find the index of '2'\n    try:\n        idx2 = grid.index(2)\n    except ValueError:\n        # '2' not found, which shouldn't happen based on the problem description\n        # Return original string as a fallback\n        return input_str\n\n    # --- Check Left Side ---\n    num_zeros_left = 0\n    scan_idx_left = idx2 - 1\n    # Scan leftwards for zeros immediately preceding '2'\n    while scan_idx_left >= 0 and grid[scan_idx_left] == 0:\n        num_zeros_left += 1\n        scan_idx_left -= 1\n\n    # If zeros were found, check for an adjacent non-zero block\n    if num_zeros_left > 0:\n        block_digit_left, block_start_idx_left, block_end_idx_left = find_block_left(grid, scan_idx_left)\n        # Ensure the block found is indeed adjacent (ends right before the zeros)\n        if block_digit_left is not None and block_end_idx_left == idx2 - num_zeros_left - 1:\n            # Perform the move: Move zeros from [block_end+1, idx2-1] to before block_start\n            segment_before_block = grid[:block_start_idx_left]\n            moved_zeros = grid[block_end_idx_left + 1 : idx2]\n            the_block = grid[block_start_idx_left : block_end_idx_left + 1]\n            segment_after_2 = grid[idx2:] # Includes the '2'\n\n            # Reconstruct the grid\n            new_grid = segment_before_block + moved_zeros + the_block + segment_after_2\n            return \" \".join(map(str, new_grid))\n\n    # --- Check Right Side (only if no change was made on the left) ---\n    num_zeros_right = 0\n    scan_idx_right = idx2 + 1\n    # Scan rightwards for zeros immediately following '2'\n    while scan_idx_right < n and grid[scan_idx_right] == 0:\n        num_zeros_right += 1\n        scan_idx_right += 1\n\n    # If zeros were found, check for an adjacent non-zero block\n    if num_zeros_right > 0:\n        block_digit_right, block_start_idx_right, block_end_idx_right = find_block_right(grid, scan_idx_right)\n         # Ensure the block found is indeed adjacent (starts right after the zeros)\n        if block_digit_right is not None and block_start_idx_right == idx2 + num_zeros_right + 1:\n            # Perform the move: Move zeros from [idx2+1, block_start-1] to after block_end\n            segment_before_2 = grid[:idx2 + 1] # Includes the '2'\n            moved_zeros = grid[idx2 + 1 : block_start_idx_right]\n            the_block = grid[block_start_idx_right : block_end_idx_right + 1]\n            segment_after_block = grid[block_end_idx_right + 1:]\n\n            # Reconstruct the grid\n            new_grid = segment_before_2 + the_block + moved_zeros + segment_after_block\n            return \" \".join(map(str, new_grid))\n\n    # If no changes were made on either side, return the original string\n    return input_str\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1912,
    "candidates_token_count": 5041,
    "total_token_count": 6953,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.967301,
  "retries": 1
}