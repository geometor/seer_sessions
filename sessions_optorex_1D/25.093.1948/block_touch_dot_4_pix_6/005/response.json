{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport sys\nimport math\n# No special imports seem necessary for this logic\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Receive the input sequence of digits (as a list, array, or similar iterable). Convert it into a standard list of integers if necessary.\n2.  Find the index (`idx2`) of the unique digit `2` in the sequence. If `2` is not present, return the original sequence formatted as a space-separated string.\n3.  Check Left Side:\n    a.  Scan leftwards from `idx2 - 1` counting consecutive `0`s (`zeros_left_count`).\n    b.  If `zeros_left_count > 0`:\n        i.  Determine the potential end index of the non-zero block: `block_end_idx = idx2 - zeros_left_count - 1`.\n        ii. Check if `block_end_idx` is valid (>= 0) and if the digit at this index (`grid[block_end_idx]`) is non-zero (`block_digit`).\n        iii. If it is a non-zero digit, scan further left from `block_end_idx` to find the start index (`block_start_idx`) of the contiguous block of `block_digit`.\n        iv. If a valid block (`block_digit > 0`) is confirmed to end exactly at `block_end_idx`:\n            1.  Extract the sequence segments: `before_block` (elements up to `block_start_idx`), `the_zeros` (elements from `block_end_idx + 1` to `idx2 - 1`), `the_block` (elements from `block_start_idx` to `block_end_idx`), `marker_and_after` (elements from `idx2` onwards).\n            2.  Reconstruct the sequence as `before_block + the_zeros + the_block + marker_and_after`.\n            3.  Format the reconstructed sequence as a space-separated string and return it.\n4.  Check Right Side (only if no change was made on the left):\n    a.  Initialize `zeros_right_count = 0`. Scan rightwards from `idx2 + 1`. While the index is valid and the digit is `0`, increment `zeros_right_count` and move one step right.\n    b.  If `zeros_right_count > 0`:\n        i.  Determine the potential start index of the non-zero block: `block_start_idx = idx2 + zeros_right_count + 1`.\n        ii. Check if `block_start_idx` is valid (< sequence length) and if the digit at this index (`grid[block_start_idx]`) is non-zero (`block_digit`).\n        iii. If it is a non-zero digit, scan further right from `block_start_idx` to find the end index (`block_end_idx`) of the contiguous block of `block_digit`.\n        iv. If a valid block (`block_digit > 0`) is confirmed to start exactly at `block_start_idx`:\n            1.  Extract the sequence segments: `up_to_marker` (elements up to `idx2`), `the_zeros` (elements from `idx2 + 1` to `block_start_idx - 1`), `the_block` (elements from `block_start_idx` to `block_end_idx`), `after_block` (elements from `block_end_idx + 1` onwards).\n            2.  Reconstruct the sequence as `up_to_marker + the_block + the_zeros + after_block`.\n            3.  Format the reconstructed sequence as a space-separated string and return it.\n5.  No Change: If neither the left nor the right pattern resulted in a transformation, format the original input sequence as a space-separated string and return it.\n\"\"\"\n\ndef find_block_left(grid, end_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits ending at end_idx.\n    Returns the block's digit, start index, and end index, or (None, -1, -1)\n    if no such block exists or if the digit at end_idx is zero.\n    \"\"\"\n    if end_idx < 0 or grid[end_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[end_idx]\n    block_end_idx = end_idx\n    block_start_idx = block_end_idx\n    # Scan left to find the start of the block\n    while block_start_idx > 0 and grid[block_start_idx - 1] == block_digit:\n        block_start_idx -= 1\n    return block_digit, block_start_idx, block_end_idx\n\ndef find_block_right(grid, start_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits starting at start_idx.\n    Returns the block's digit, start index, and end index, or (None, -1, -1)\n    if no such block exists or if the digit at start_idx is zero.\n    \"\"\"\n    n = len(grid)\n    if start_idx >= n or grid[start_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[start_idx]\n    block_start_idx = start_idx\n    block_end_idx = block_start_idx\n    # Scan right to find the end of the block\n    while block_end_idx < n - 1 and grid[block_end_idx + 1] == block_digit:\n        block_end_idx += 1\n    return block_digit, block_start_idx, block_end_idx\n\ndef format_output(grid):\n    \"\"\"Converts a list of integers to a space-separated string.\"\"\"\n    return \" \".join(map(str, grid))\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid (sequence of digits).\n    \"\"\"\n    # Convert input to a list of integers, handling potential non-string iterables\n    try:\n        # Attempt direct conversion if it's already an iterable of numbers/strings\n        grid = [int(d) for d in input_grid]\n    except (TypeError, ValueError):\n        # Fallback if it's a single string needing split (less likely based on errors)\n        try:\n             grid = [int(d) for d in input_grid.split()]\n        except Exception as e:\n             # If input format is truly unexpected, return original or raise error\n             print(f\"Unexpected input format: {type(input_grid)}, value: {input_grid}. Error: {e}\")\n             # Returning original as string representation for robustness in testing\n             return str(input_grid)\n\n\n    n = len(grid)\n\n    # Find the index of the marker '2'\n    try:\n        idx2 = grid.index(2)\n    except ValueError:\n        # '2' not found, return the original grid formatted as string\n        return format_output(grid)\n\n    # --- Check Left Side ---\n    zeros_left_count = 0\n    scan_idx = idx2 - 1\n    # Scan leftwards for zeros immediately preceding '2'\n    while scan_idx >= 0 and grid[scan_idx] == 0:\n        zeros_left_count += 1\n        scan_idx -= 1\n\n    # If zeros were found, check for an adjacent non-zero block to their left\n    if zeros_left_count > 0:\n        block_end_check_idx = idx2 - zeros_left_count - 1\n        if block_end_check_idx >= 0: # Check if there's space for a block\n             # Find the block potentially ending at this position\n             block_digit, block_start_idx, block_end_idx = find_block_left(grid, block_end_check_idx)\n             # Verify that a valid non-zero block was found and it ends exactly where expected\n             if block_digit is not None and block_end_idx == block_end_check_idx:\n                # Perform the move: (elements before block) + (zeros) + (block) + (2 and elements after)\n                segment_before_block = grid[:block_start_idx]\n                # The zeros are located between the block end and index 2\n                the_zeros = grid[block_end_idx + 1 : idx2]\n                the_block = grid[block_start_idx : block_end_idx + 1]\n                segment_from_2_onwards = grid[idx2:] # Includes the '2'\n\n                # Reconstruct the grid\n                output_grid = segment_before_block + the_zeros + the_block + segment_from_2_onwards\n                return format_output(output_grid) # Return transformed result\n\n    # --- Check Right Side (only if no change was made on the left) ---\n    zeros_right_count = 0\n    scan_idx = idx2 + 1\n    # Scan rightwards for zeros immediately following '2'\n    while scan_idx < n and grid[scan_idx] == 0:\n        zeros_right_count += 1\n        scan_idx += 1\n\n    # If zeros were found, check for an adjacent non-zero block to their right\n    if zeros_right_count > 0:\n        block_start_check_idx = idx2 + zeros_right_count + 1\n        if block_start_check_idx < n: # Check if there's space for a block\n            # Find the block potentially starting at this position\n            block_digit, block_start_idx, block_end_idx = find_block_right(grid, block_start_check_idx)\n            # Verify that a valid non-zero block was found and it starts exactly where expected\n            if block_digit is not None and block_start_idx == block_start_check_idx:\n                 # Perform the move: (elements before 2, including 2) + (block) + (zeros) + (elements after block)\n                 segment_up_to_2 = grid[:idx2 + 1] # Includes the '2'\n                 # The zeros are located between index 2 and the block start\n                 the_zeros = grid[idx2 + 1 : block_start_idx]\n                 the_block = grid[block_start_idx : block_end_idx + 1]\n                 segment_after_block = grid[block_end_idx + 1:]\n\n                 # Reconstruct the grid\n                 output_grid = segment_up_to_2 + the_block + the_zeros + segment_after_block\n                 return format_output(output_grid) # Return transformed result\n\n    # If no changes were made on either side, return the original grid formatted as string\n    return format_output(grid)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10500,
    "candidates_token_count": 3015,
    "total_token_count": 13515,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.569827,
  "retries": 1
}