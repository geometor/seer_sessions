{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport sys\nimport math\nimport numpy as np # Import numpy for handling potential ndarray inputs\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Receive the input sequence of digits (potentially as a string, list, or NumPy array). Convert it into a flat, 1D list of integers (`grid`). Handle potential nesting (e.g., `[[...]]`).\n2.  Find the index (`idx2`) of the unique digit `2` in the `grid`. If `2` is not found, return the `grid` formatted as a space-separated string.\n3.  Check Left Side Pattern:\n    a.  Scan leftwards from `idx2 - 1` counting consecutive `0`s (`zeros_left_count`).\n    b.  If `zeros_left_count > 0`, check if there's a non-zero digit (`block_digit`) immediately preceding these zeros (at index `idx2 - zeros_left_count - 1`).\n    c.  If such a `block_digit` exists, find the full contiguous block of this digit ending at that position (`block_start_idx`, `block_end_idx`).\n    d.  If the pattern (Block - Zeros - 2) is confirmed, reconstruct the sequence: (elements before block) + (zeros) + (block) + (2 and elements after). Format as a string and return.\n4.  Check Right Side Pattern (only if no change was made on the left):\n    a.  Scan rightwards from `idx2 + 1` counting consecutive `0`s (`zeros_right_count`).\n    b.  If `zeros_right_count > 0`, check if there's a non-zero digit (`block_digit`) immediately following these zeros (at index `idx2 + zeros_right_count + 1`).\n    c.  If such a `block_digit` exists, find the full contiguous block of this digit starting at that position (`block_start_idx`, `block_end_idx`).\n    d.  If the pattern (2 - Zeros - Block) is confirmed, reconstruct the sequence: (elements before 2, including 2) + (block) + (zeros) + (elements after block). Format as a string and return.\n5.  No Change: If neither pattern triggered a reconstruction, format the original `grid` as a space-separated string and return it.\n\"\"\"\n\ndef parse_input(input_data):\n    \"\"\"\n    Parses various input formats (string, list, numpy array) into a 1D list of integers.\n    Handles potential nesting like [[...]].\n    \"\"\"\n    if isinstance(input_data, str):\n        try:\n            return [int(d) for d in input_data.split()]\n        except ValueError:\n             # Handle cases where string might not be space-separated digits\n             print(f\"Warning: Could not parse string input '{input_data}' as space-separated digits.\")\n             return [] # Or raise an error, depending on desired strictness\n    elif isinstance(input_data, np.ndarray):\n        # Flatten the array and convert elements to int\n        return [int(d) for d in input_data.flatten()]\n    elif isinstance(input_data, (list, tuple)):\n        # Attempt to flatten if nested and convert\n        try:\n            if input_data and isinstance(input_data[0], (list, tuple, np.ndarray)):\n                # Handle nested lists/tuples/arrays, assuming one level like [[...]]\n                 flat_list = [item for sublist in input_data for item in sublist]\n                 return [int(d) for d in flat_list]\n            else:\n                 # Assume it's already a flat list/tuple\n                 return [int(d) for d in input_data]\n        except (ValueError, TypeError) as e:\n             print(f\"Warning: Could not parse list/tuple input. Error: {e}. Input: {input_data}\")\n             return []\n    else:\n        print(f\"Warning: Unhandled input type: {type(input_data)}. Input: {input_data}\")\n        return []\n\n\ndef find_block_left(grid, end_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits ending at end_idx.\n    Returns the block's digit, start index, and end index, or (None, -1, -1)\n    if no such block exists or if the digit at end_idx is zero.\n    \"\"\"\n    if end_idx < 0 or end_idx >= len(grid) or grid[end_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[end_idx]\n    block_end_idx = end_idx\n    block_start_idx = block_end_idx\n    # Scan left to find the start of the block\n    while block_start_idx > 0 and grid[block_start_idx - 1] == block_digit:\n        block_start_idx -= 1\n    return block_digit, block_start_idx, block_end_idx\n\ndef find_block_right(grid, start_idx):\n    \"\"\"\n    Finds a contiguous block of identical non-zero digits starting at start_idx.\n    Returns the block's digit, start index, and end index, or (None, -1, -1)\n    if no such block exists or if the digit at start_idx is zero.\n    \"\"\"\n    n = len(grid)\n    if start_idx < 0 or start_idx >= n or grid[start_idx] == 0:\n        return None, -1, -1\n\n    block_digit = grid[start_idx]\n    block_start_idx = start_idx\n    block_end_idx = block_start_idx\n    # Scan right to find the end of the block\n    while block_end_idx < n - 1 and grid[block_end_idx + 1] == block_digit:\n        block_end_idx += 1\n    return block_digit, block_start_idx, block_end_idx\n\ndef format_output(grid):\n    \"\"\"Converts a list of integers to a space-separated string.\"\"\"\n    return \" \".join(map(str, grid))\n\ndef transform(input_data):\n    \"\"\"\n    Applies the transformation rule to the input grid (sequence of digits).\n    \"\"\"\n    # --- Step 1 & 2: Parse Input and Find Marker '2' ---\n    grid = parse_input(input_data)\n    if not grid: # Handle empty list from parsing failure\n        # Returning raw input string representation might be safest fallback\n        return str(input_data) \n\n    n = len(grid)\n    try:\n        idx2 = grid.index(2)\n    except ValueError:\n        # '2' not found, return the original grid formatted as string\n        return format_output(grid)\n\n    # --- Step 3: Check Left Side Pattern ---\n    zeros_left_count = 0\n    scan_idx = idx2 - 1\n    # Scan leftwards for zeros immediately preceding '2'\n    while scan_idx >= 0 and grid[scan_idx] == 0:\n        zeros_left_count += 1\n        scan_idx -= 1\n\n    # If zeros were found, check for an adjacent non-zero block to their left\n    if zeros_left_count > 0:\n        block_end_check_idx = idx2 - zeros_left_count - 1\n        if block_end_check_idx >= 0: # Ensure there's space for a block\n            # Find the block potentially ending at this position\n            block_digit, block_start_idx, block_end_idx = find_block_left(grid, block_end_check_idx)\n            # Verify that a valid non-zero block was found and it ends exactly where expected\n            if block_digit is not None and block_end_idx == block_end_check_idx:\n                # Perform the move: (before block) + (zeros) + (block) + (2 and after)\n                segment_before_block = grid[:block_start_idx]\n                the_zeros = grid[block_end_idx + 1 : idx2] # The zeros found\n                the_block = grid[block_start_idx : block_end_idx + 1]\n                segment_from_2_onwards = grid[idx2:] # Includes the '2'\n                # Reconstruct and return\n                output_grid = segment_before_block + the_zeros + the_block + segment_from_2_onwards\n                return format_output(output_grid)\n\n    # --- Step 4: Check Right Side Pattern (only if no change on left) ---\n    zeros_right_count = 0\n    scan_idx = idx2 + 1\n    # Scan rightwards for zeros immediately following '2'\n    while scan_idx < n and grid[scan_idx] == 0:\n        zeros_right_count += 1\n        scan_idx += 1\n\n    # If zeros were found, check for an adjacent non-zero block to their right\n    if zeros_right_count > 0:\n        block_start_check_idx = idx2 + zeros_right_count + 1\n        if block_start_check_idx < n: # Ensure there's space for a block\n            # Find the block potentially starting at this position\n            block_digit, block_start_idx, block_end_idx = find_block_right(grid, block_start_check_idx)\n            # Verify that a valid non-zero block was found and it starts exactly where expected\n            if block_digit is not None and block_start_idx == block_start_check_idx:\n                # Perform the move: (up to 2) + (block) + (zeros) + (after block)\n                segment_up_to_2 = grid[:idx2 + 1] # Includes the '2'\n                the_zeros = grid[idx2 + 1 : block_start_idx] # The zeros found\n                the_block = grid[block_start_idx : block_end_idx + 1]\n                segment_after_block = grid[block_end_idx + 1:]\n                # Reconstruct and return\n                output_grid = segment_up_to_2 + the_block + the_zeros + segment_after_block\n                return format_output(output_grid)\n\n    # --- Step 5: No Change ---\n    # If no changes were made on either side, return the original grid formatted\n    return format_output(grid)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15376,
    "candidates_token_count": 2757,
    "total_token_count": 18133,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.170651,
  "retries": 1
}