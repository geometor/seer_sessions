{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy # For creating a mutable copy of the input list\n\n\"\"\"\nTransforms an input list of 12 integers based on two prioritized local patterns involving the numbers 0 and 2.\n\n1.  **Pattern 1 (Swap - Highest Priority):** Searches for the first occurrence (left-to-right) \n    of a sub-sequence `X, 0, 2`, where `X` is any integer other than 0 or 2. \n    If found, it swaps `X` and `0` to `0, X, 2` and the transformation is complete.\n\n2.  **Pattern 2 (Shift - Lower Priority):** If Pattern 1 is not found, searches for the \n    first occurrence (left-to-right) of a sub-sequence starting with `2`, followed by \n    one or more `0`s, followed immediately by a non-empty contiguous block `Y` of integers \n    that are neither `0` nor `2`. If found, it moves block `Y` to be immediately after \n    the initial `2`, followed by the block of `0`s that were originally between the `2` \n    and `Y`. The transformation is then complete.\n\n3.  **No Change:** If neither pattern is found, the original input list is returned unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_pattern1_swap(grid):\n    \"\"\"\n    Finds the index of the first occurrence (left-to-right) of the pattern X, 0, 2.\n    X must not be 0 or 2.\n    Returns the index 'i' of X if found, otherwise returns -1.\n    \"\"\"\n    n = len(grid)\n    # Iterate up to n-3 because the pattern is 3 elements long (indices i, i+1, i+2)\n    for i in range(n - 2):\n        x = grid[i]\n        zero = grid[i+1]\n        two = grid[i+2]\n        # Check if the pattern conditions are met\n        if x != 0 and x != 2 and zero == 0 and two == 2:\n            return i  # Return the index of X (start of the pattern)\n    return -1 # Pattern not found\n\ndef find_pattern2_shift(grid):\n    \"\"\"\n    Finds the details of the first occurrence (left-to-right) of the pattern 2, 0..., 0, Y.\n    - '2' is the literal number 2.\n    - '0..., 0' is one or more zeros (Zero_Block).\n    - 'Y' is a non-empty contiguous block of numbers != 0 and != 2 (Movable_Block).\n    \n    Returns a tuple: (idx_2, num_zeros, block_y, idx_block_end) \n    if the pattern is found, otherwise returns None.\n    \n    - idx_2: index of the '2'\n    - num_zeros: count of zeros in the Zero_Block\n    - block_y: list containing the elements of the Movable_Block Y\n    - idx_block_end: ending index (exclusive) of the original Movable_Block Y\n    \"\"\"\n    n = len(grid)\n    for i in range(n):\n        # Find the first '2'\n        if grid[i] == 2:\n            idx_2 = i\n            \n            # --- Find the contiguous block of zeros following the '2' ---\n            idx_after_2 = idx_2 + 1\n            if idx_after_2 >= n: # Check if '2' is the last element\n                continue # Cannot have zeros or block Y after it\n\n            num_zeros = 0\n            idx_first_non_zero = -1\n            for j in range(idx_after_2, n):\n                if grid[j] == 0:\n                    num_zeros += 1\n                else:\n                    idx_first_non_zero = j\n                    break\n            \n            # Check if at least one zero was found\n            if num_zeros == 0:\n                continue # Pattern requires at least one zero after '2'\n            \n            # --- Find the contiguous block Y (non-zero, non-2) following the zeros ---\n            if idx_first_non_zero == -1: # No non-zero element found after zeros\n                continue \n\n            block_y = []\n            idx_block_end = idx_first_non_zero # Start of block Y determines initial end\n            for k in range(idx_first_non_zero, n):\n                val = grid[k]\n                # Check if element belongs to a valid Movable_Block\n                if val != 0 and val != 2:\n                    block_y.append(val)\n                    idx_block_end = k + 1 # Update end index (exclusive)\n                else:\n                    # Block Y ends if 0 or 2 is encountered\n                    break \n                    \n            # Check if a valid, non-empty block Y was found\n            if len(block_y) > 0:\n                # Found the complete pattern 2, return its details\n                # Note: idx_block_start is idx_first_non_zero\n                return (idx_2, num_zeros, block_y, idx_block_end)\n                \n            # If we reach here, this '2' did not start a valid Pattern 2.\n            # Continue the outer loop to check for the next '2'.\n\n    # If the loop completes without finding the pattern\n    return None\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid (list of integers).\n    \"\"\"\n    # Create a deep copy to avoid modifying the original input list\n    output_grid = copy.deepcopy(input_grid)\n    n = len(output_grid) # Should always be 12 based on examples\n\n    # --- Rule 1: Check for Pattern 1 (X, 0, 2 swap) ---\n    # Scan for the first occurrence of the pattern.\n    swap_index = find_pattern1_swap(output_grid)\n    \n    # If Pattern 1 is found, perform the swap and return immediately.\n    if swap_index != -1:\n        # Perform the swap of X (at swap_index) and 0 (at swap_index + 1)\n        output_grid[swap_index], output_grid[swap_index + 1] = output_grid[swap_index + 1], output_grid[swap_index]\n        return output_grid # Transformation complete\n\n    # --- Rule 2: Check for Pattern 2 (2, 0s, Y shift) ---\n    # This section executes only if Pattern 1 was NOT found.\n    # Scan for the first occurrence of the pattern.\n    shift_details = find_pattern2_shift(output_grid)\n    \n    # If Pattern 2 is found, perform the shift and return.\n    if shift_details is not None:\n        # Unpack the details found by the helper function\n        idx_2, num_zeros, block_y, idx_block_end = shift_details\n        \n        # Reconstruct the list segments for the shift operation\n        prefix = output_grid[:idx_2 + 1]          # Elements up to and including the '2'\n        moved_block_y = block_y                   # The Movable_Block Y itself\n        moved_zeros = [0] * num_zeros             # The Zero_Block that was between '2' and 'Y'\n        suffix = output_grid[idx_block_end:]      # Elements originally after the Movable_Block Y\n        \n        # Combine the segments to form the new grid arrangement\n        new_grid_list = prefix + moved_block_y + moved_zeros + suffix\n        \n        # Defensive check: Ensure the list length remains correct (12). \n        # Pad with 0s or truncate if necessary, although reconstruction should preserve length.\n        if len(new_grid_list) < n:\n            new_grid_list.extend([0] * (n - len(new_grid_list)))\n        elif len(new_grid_list) > n:\n            new_grid_list = new_grid_list[:n]\n            \n        # Update the output grid with the rearranged list\n        output_grid = new_grid_list\n        return output_grid # Transformation complete\n\n    # --- No Change ---\n    # If neither Pattern 1 nor Pattern 2 was found and executed, \n    # return the unmodified (copied) input grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9771,
    "candidates_token_count": 2436,
    "total_token_count": 12207,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.883568,
  "retries": 1
}