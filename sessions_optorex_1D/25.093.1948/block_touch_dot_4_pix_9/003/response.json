{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math # Not strictly required for this logic, but good practice\nimport copy # To ensure the input list isn't modified directly\n\n\"\"\"\nTransforms an input list of 12 integers based on two prioritized local patterns involving the numbers 0 and 2.\n\n1.  **Pattern 1 (Swap - Highest Priority):** Searches for the first occurrence (left-to-right) \n    of a sub-sequence `X, 0, 2`, where `X` is any integer other than 0 or 2. \n    If found, it swaps `X` and `0` to `0, X, 2` and the transformation is complete.\n\n2.  **Pattern 2 (Shift - Lower Priority):** If Pattern 1 is not found, searches for the \n    first occurrence (left-to-right) of a sub-sequence starting with `2`, followed by \n    one or more `0`s, followed immediately by a non-empty contiguous block `Y` of integers \n    that are neither `0` nor `2`. If found, it moves block `Y` to be immediately after \n    the initial `2`, followed by the block of `0`s that were originally between the `2` \n    and `Y`. The transformation is then complete.\n\n3.  **No Change:** If neither pattern is found, the original input list is returned unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_pattern1_swap(grid):\n    \"\"\"\n    Finds the index of the first occurrence of the pattern X, 0, 2.\n    X must not be 0 or 2.\n    Returns the index 'i' of X if found, otherwise returns -1.\n    \"\"\"\n    n = len(grid)\n    for i in range(n - 2):\n        x = grid[i]\n        zero = grid[i+1]\n        two = grid[i+2]\n        if x != 0 and x != 2 and zero == 0 and two == 2:\n            return i  # Return the index of X\n    return -1\n\ndef find_pattern2_shift(grid):\n    \"\"\"\n    Finds the details of the first occurrence of the pattern 2, 0..., 0, Y.\n    - '2' is the literal number 2.\n    - '0..., 0' is one or more zeros.\n    - 'Y' is a non-empty contiguous block of numbers != 0 and != 2.\n    \n    Returns a tuple: (idx_2, num_zeros, block_y, idx_block_start, idx_block_end) \n    if the pattern is found, otherwise returns None.\n    \n    - idx_2: index of the '2'\n    - num_zeros: count of zeros between '2' and 'Y'\n    - block_y: list containing the elements of block Y\n    - idx_block_start: starting index of the original block Y\n    - idx_block_end: ending index (exclusive) of the original block Y\n    \"\"\"\n    n = len(grid)\n    for i in range(n):\n        # Find the first '2'\n        if grid[i] == 2:\n            idx_2 = i\n            \n            # Check if there are elements after '2'\n            if idx_2 + 1 < n:\n                # Find the block of zeros\n                idx_first_zero = idx_2 + 1\n                num_zeros = 0\n                idx_first_non_zero_after_zeros = -1\n                for j in range(idx_first_zero, n):\n                    if grid[j] == 0:\n                        num_zeros += 1\n                    else:\n                        idx_first_non_zero_after_zeros = j\n                        break\n                \n                # Check if at least one zero was found and there's something after zeros\n                if num_zeros > 0 and idx_first_non_zero_after_zeros != -1:\n                    # Find the block Y (non-zero, non-2 elements)\n                    idx_block_start = idx_first_non_zero_after_zeros\n                    idx_block_end = idx_block_start\n                    block_y = []\n                    contains_invalid_in_block = False # Checks for 0 or 2 within Y\n                    \n                    for k in range(idx_block_start, n):\n                        val = grid[k]\n                        if val != 0 and val != 2:\n                            block_y.append(val)\n                            idx_block_end = k + 1\n                        else:\n                            # Block Y ends if 0 or 2 is encountered.\n                            # Note: The description implies Y *only* contains valid numbers,\n                            # so encountering 0 or 2 means the block ends *before* it.\n                            break \n                            \n                    # Check if a valid, non-empty block Y was found\n                    if len(block_y) > 0:\n                        # Found the complete pattern 2, return its details\n                        return (idx_2, num_zeros, block_y, idx_block_start, idx_block_end)\n                        \n            # If we found a '2' but the rest of the pattern didn't match, \n            # continue searching for the next '2' that might start a valid pattern.\n            # However, the rule is to act on the *first* valid pattern occurrence.\n            # So if we found a valid pattern above, we returned. If we are here, \n            # it means this '2' didn't lead to a valid pattern 2. We need to break\n            # the outer loop only AFTER finding the first complete pattern.\n            # The 'return' inside the successful pattern check handles this.\n\n    # If the loop completes without finding the pattern\n    return None\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid (list of integers).\n    \"\"\"\n    # Initialize output_grid as a deep copy to avoid modifying the original input list\n    output_grid = copy.deepcopy(input_grid)\n    n = len(output_grid)\n\n    # --- Rule 1: Check for Pattern 1 (X, 0, 2 swap) ---\n    swap_index = find_pattern1_swap(output_grid)\n    if swap_index != -1:\n        # Perform the swap\n        output_grid[swap_index], output_grid[swap_index + 1] = output_grid[swap_index + 1], output_grid[swap_index]\n        # Return immediately after the first swap\n        return output_grid\n\n    # --- Rule 2: Check for Pattern 2 (2, 0s, Y shift) ---\n    # This runs only if Rule 1 did not apply\n    shift_details = find_pattern2_shift(output_grid)\n    if shift_details is not None:\n        idx_2, num_zeros, block_y, idx_block_start, idx_block_end = shift_details\n        \n        # Perform the shift by reconstructing the list\n        prefix = output_grid[:idx_2 + 1]          # Elements up to and including '2'\n        moved_part = block_y                      # The block Y\n        zeros_part = [0] * num_zeros              # The zeros that were between 2 and Y\n        suffix = output_grid[idx_block_end:]      # Elements after the original block Y\n        \n        # Combine parts\n        new_grid_list = prefix + moved_part + zeros_part + suffix\n        \n        # Ensure the list remains the correct length (it should, but defensively check/pad/truncate)\n        if len(new_grid_list) < n:\n            new_grid_list.extend([0] * (n - len(new_grid_list)))\n        elif len(new_grid_list) > n:\n            new_grid_list = new_grid_list[:n]\n            \n        # Return the result of the shift\n        return new_grid_list\n\n    # --- No Change ---\n    # If neither pattern was found and applied, return the original grid copy\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8918,
    "candidates_token_count": 2176,
    "total_token_count": 11094,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.061771,
  "retries": 1
}