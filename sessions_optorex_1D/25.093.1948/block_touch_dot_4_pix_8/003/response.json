{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np # Although not explicitly used in the final logic, good practice to import common libs if needed.\n\n\"\"\"\nRearrange a sequence of digits (provided as a list of integers) based on the relative positions of a 'value block' (contiguous identical digits other than 0 or 2) and the digit '2' (the pivot). \nIf a value block exists and is separated from the '2' by one or more zeros ('intermediate zeros'):\n- If the block is to the left of '2', move the block immediately to the left of '2' and move the intermediate zeros to the start of the sequence.\n- If the block is to the right of '2', move the block immediately to the right of '2' and move the intermediate zeros to the end of the sequence.\n- If the block is adjacent to '2' or no such value block exists, the sequence remains unchanged.\nThe output is the rearranged list of integers.\n\"\"\"\n\ndef _find_pivot_index(grid, pivot_value=2):\n    \"\"\"Finds the index of the pivot value (2) in the grid.\"\"\"\n    try:\n        # Convert potential numpy array to list for index method\n        grid_list = list(grid) \n        return grid_list.index(pivot_value)\n    except ValueError:\n        return -1 # Pivot not found\n\ndef _find_first_value_block(grid, pivot_index):\n    \"\"\"\n    Finds the first contiguous block of identical digits != 0 and != 2.\n    Returns (start_index, end_index, value) or (None, None, None).\n    end_index is exclusive.\n    \"\"\"\n    n = len(grid)\n    for i in range(n):\n        # Skip 0s and the pivot value itself\n        if grid[i] == 0 or grid[i] == 2:\n            continue\n        \n        # Found a potential start of a block\n        block_value = grid[i]\n        j = i + 1\n        # Find the end of the contiguous block\n        while j < n and grid[j] == block_value:\n            j += 1\n            \n        # Check if it's a valid block (length > 0)\n        # No need to explicitly check j > i because the outer loop ensures grid[i] is a valid start\n        return i, j, block_value # Found the first block\n            \n    return None, None, None # No value block found\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input list of digits based on the described rules.\n    \n    Args:\n        input_grid: A list or numpy array of integers.\n\n    Returns:\n        A list of integers representing the transformed sequence.\n    \"\"\"\n    # 1. Ensure input is a standard Python list for easier manipulation\n    grid = list(input_grid) \n    n = len(grid)\n\n    # 2. Locate the index of the pivot digit 2.\n    pivot_index = _find_pivot_index(grid, 2)\n    if pivot_index == -1:\n        # Pivot '2' must be present based on examples\n        return grid # Return original if pivot not found (defensive)\n\n    # 3. Search for the first value block B.\n    block_start, block_end, block_value = _find_first_value_block(grid, pivot_index)\n\n    # 4. If no such block B is found, return the original input list unchanged.\n    if block_start is None:\n        return grid\n\n    # 5. & 6. Determine relative position (left/right)\n    block_is_left = False\n    if block_end <= pivot_index: # Block ends before or at the pivot index\n        block_is_left = True\n    elif block_start > pivot_index: # Block starts after the pivot index\n        block_is_left = False\n    # Note: block containing pivot is implicitly handled by _find_first_value_block skipping pivot value\n\n    # 7. Identify the intermediate sequence Z (only zeros) between B and 2.\n    intermediate_zeros = []\n    if block_is_left:\n        # Z is between block_end and pivot_index\n        for i in range(block_end, pivot_index):\n            if grid[i] == 0:\n                intermediate_zeros.append(0)\n            # else: Non-zero found between block and pivot - deviates from pattern\n                # This case isn't expected based on examples. If it occurs,\n                # current logic might misbehave. Treat as adjacent for now.\n                # return grid \n    else: # block is right\n        # Z is between pivot_index + 1 and block_start\n        for i in range(pivot_index + 1, block_start):\n             if grid[i] == 0:\n                intermediate_zeros.append(0)\n             # else: Non-zero found - treat as adjacent for now.\n                # return grid\n\n    # 8. If Z is empty (B and 2 are adjacent), return original list unchanged.\n    if not intermediate_zeros:\n        # Check adjacency explicitly based on indices\n        if block_is_left and block_end == pivot_index:\n            return grid\n        if not block_is_left and block_start == pivot_index + 1:\n            return grid\n        # If intermediate_zeros is empty but they weren't adjacent (e.g., non-zero between)\n        # the current logic will proceed, potentially incorrectly if the pattern assumption is violated.\n        # However, based *strictly* on examples, empty intermediate_zeros means adjacency.\n\n    # --- Perform Rearrangement ---\n\n    # 9. Create a new list `temp_list` by removing B and Z.\n    temp_list = []\n    indices_to_remove = set(range(block_start, block_end)) # Block indices\n    if block_is_left:\n        indices_to_remove.update(range(block_end, pivot_index)) # Zero indices\n    else: # block is right\n        indices_to_remove.update(range(pivot_index + 1, block_start)) # Zero indices\n\n    for i in range(n):\n        if i not in indices_to_remove:\n            temp_list.append(grid[i])\n            \n    # 10. Find the index `new_pivot_index` of 2 within the reduced `temp_list`.\n    # We know the pivot '2' was never in indices_to_remove.\n    new_pivot_index = _find_pivot_index(temp_list, 2) \n    \n    # 11. Create list `value_block_elements`.\n    value_block_elements = [block_value] * (block_end - block_start)\n\n    # 12. `intermediate_zeros` list already created in step 7.\n\n    # 13. If block B was originally to the left of 2:\n    if block_is_left:\n        # a. Prepend intermediate zeros.\n        # b. Insert block elements before the pivot.\n        # Need to find pivot index *after* prepending zeros\n        final_grid = intermediate_zeros + temp_list\n        final_pivot_index = _find_pivot_index(final_grid, 2)\n        final_grid = final_grid[:final_pivot_index] + value_block_elements + final_grid[final_pivot_index:]\n        \n    # 14. If block B was originally to the right of 2:\n    else: # block_is_right\n        # a. Insert block elements immediately after the pivot in temp_list.\n        # b. Append intermediate zeros.\n        # Use new_pivot_index found in temp_list *before* appending zeros.\n        final_grid = temp_list[:new_pivot_index+1] + value_block_elements + temp_list[new_pivot_index+1:]\n        final_grid = final_grid + intermediate_zeros\n\n    # 15. Return the final constructed list.\n    return final_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7057,
    "candidates_token_count": 2100,
    "total_token_count": 9157,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.064219,
  "retries": 1
}