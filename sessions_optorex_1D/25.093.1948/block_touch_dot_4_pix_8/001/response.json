{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport re\n\n\"\"\"\nRearrange a sequence of digits based on the relative positions of a 'value block' (contiguous identical digits other than 0 or 2) and the digit '2'. \nIf a value block exists and is separated from the '2' by zeros:\n- If the block is to the left of '2', move the block immediately to the left of '2' and move the intervening zeros to the start of the sequence.\n- If the block is to the right of '2', move the block immediately to the right of '2' and move the intervening zeros to the end of the sequence.\n- If the block is adjacent to '2' or no such block exists, the sequence remains unchanged.\n\"\"\"\n\ndef _find_pivot_index(grid, pivot_value=2):\n    \"\"\"Finds the index of the pivot value (2) in the grid.\"\"\"\n    try:\n        return grid.index(pivot_value)\n    except ValueError:\n        return -1 # Pivot not found\n\ndef _find_first_value_block(grid, pivot_index):\n    \"\"\"\n    Finds the first contiguous block of identical digits != 0 and != 2.\n    Returns (start_index, end_index, value) or (None, None, None).\n    end_index is exclusive.\n    \"\"\"\n    n = len(grid)\n    for i in range(n):\n        # Skip 0s and the pivot value\n        if grid[i] == 0 or grid[i] == 2:\n            continue\n        \n        # Found a potential start of a block\n        block_value = grid[i]\n        j = i + 1\n        while j < n and grid[j] == block_value:\n            j += 1\n            \n        # Check if it's a block (length > 0)\n        if j > i: \n            return i, j, block_value # Found the first block\n            \n    return None, None, None # No value block found\n\n\ndef transform(input_str):\n    \"\"\"\n    Transforms the input string based on the described rules.\n    \n    Args:\n        input_str: A string of space-separated digits.\n\n    Returns:\n        A string of space-separated digits representing the transformed sequence.\n    \"\"\"\n    # 1. Parse the input string into a list of digits.\n    grid = [int(d) for d in input_str.split()]\n    n = len(grid)\n\n    # 2. Locate the index of the digit 2.\n    pivot_index = _find_pivot_index(grid, 2)\n    if pivot_index == -1:\n        # Should not happen based on examples, but good practice\n        return input_str \n\n    # 3. Search for the first value block B.\n    block_start, block_end, block_value = _find_first_value_block(grid, pivot_index)\n\n    # 4. If no such block B is found, return the original input sequence unchanged.\n    if block_start is None:\n        return input_str\n\n    # Determine intermediate zeros Z and relative position\n    intermediate_zeros = []\n    block_is_left = False\n    \n    if block_end <= pivot_index: # Block is to the left of or touching the pivot from left\n        block_is_left = True\n        # 6. Identify the sub-sequence of digits Z between B and 2.\n        for i in range(block_end, pivot_index):\n            if grid[i] == 0:\n                intermediate_zeros.append(0)\n            # else: Should ideally only be zeros based on problem description\n                # pass # Or handle unexpected values\n        # If adjacent, intermediate_zeros will be empty\n        if not intermediate_zeros and block_end == pivot_index: # Check for adjacency\n             return input_str # Return unchanged if adjacent\n\n    elif block_start > pivot_index: # Block is to the right of the pivot\n        block_is_left = False\n        # 6. Identify the sub-sequence of digits Z between 2 and B.\n        for i in range(pivot_index + 1, block_start):\n             if grid[i] == 0:\n                intermediate_zeros.append(0)\n             # else: Should ideally only be zeros based on problem description\n                # pass # Or handle unexpected values\n        # If adjacent, intermediate_zeros will be empty\n        if not intermediate_zeros and block_start == pivot_index + 1: # Check for adjacency\n            return input_str # Return unchanged if adjacent\n    else:\n        # This case (block contains pivot) shouldn't occur if block value != 2\n        return input_str\n\n\n    # 7. Construct the output sequence by removing B and Z.\n    output_grid = []\n    indices_to_remove = set(range(block_start, block_end))\n    \n    if block_is_left:\n        indices_to_remove.update(range(block_end, pivot_index))\n    else: # block is right\n        indices_to_remove.update(range(pivot_index + 1, block_start))\n\n    for i in range(n):\n        if i not in indices_to_remove:\n            output_grid.append(grid[i])\n\n    # Find the new pivot index after removals\n    # Since we know pivot was never removed, we can find it again\n    new_pivot_index = _find_pivot_index(output_grid, 2) \n    \n    # Extract the block elements\n    value_block_elements = [block_value] * (block_end - block_start)\n\n    # 8. If B was originally to the left of 2:\n    if block_is_left:\n        # a. Insert Z at the beginning.\n        final_grid = intermediate_zeros + output_grid\n        # Find pivot index again after adding zeros at start\n        new_pivot_index = _find_pivot_index(final_grid, 2) \n        # b. Insert B immediately before 2.\n        final_grid = final_grid[:new_pivot_index] + value_block_elements + final_grid[new_pivot_index:]\n        \n    # 9. If B was originally to the right of 2:\n    else: # block_is_right\n        # a. Insert B immediately after 2.\n        # We use the pivot index found *before* adding zeros at the end\n        final_grid = output_grid[:new_pivot_index+1] + value_block_elements + output_grid[new_pivot_index+1:]\n        # b. Append Z to the end.\n        final_grid = final_grid + intermediate_zeros\n\n    # 10. Format the resulting list back into a string.\n    return \" \".join(map(str, final_grid))\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1964,
    "candidates_token_count": 2220,
    "total_token_count": 4184,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.501395,
  "retries": 1
}