{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule operates on a sequence of 12 single-digit integers.\nIt identifies the position of the number 2 as a pivot.\n\n1.  **Locate the Pivot (2):** Find the first occurrence of the number 2 in the sequence. If 2 is not present, the sequence remains unchanged.\n\n2.  **Check Before the Pivot:**\n    *   Look immediately before the position of 2.\n    *   Check if the element at `index(2) - 1` is 0.\n    *   If it is 0, check if the element at `index(2) - 2` is non-zero.\n    *   If both conditions are true, identify the contiguous block of non-zero numbers ending at `index(2) - 2`.\n    *   Perform a right cyclic shift on the segment consisting of this non-zero block and the zero at `index(2) - 1`. For example, `[..., X, Y, Z, 0, 2, ...]` becomes `[..., 0, X, Y, Z, 2, ...]`. Only this shift is performed.\n\n3.  **Check After the Pivot (if no shift before):**\n    *   If the check *before* the pivot did not result in a shift, look immediately after the position of 2.\n    *   Check if the element at `index(2) + 1` is 0.\n    *   If it is 0, check if the element at `index(2) + 2` is non-zero.\n    *   If both conditions are true, identify the contiguous block of non-zero numbers starting at `index(2) + 2`.\n    *   Perform a left cyclic shift on the segment consisting of the zero at `index(2) + 1` and this non-zero block. For example, `[..., 2, 0, A, B, C, ...]` becomes `[..., 2, A, B, C, 0, ...]`.\n\n4.  **No Change:** If the pivot 2 is not found, or if neither the condition before nor the condition after the pivot triggers a shift, the original sequence is returned.\n\"\"\"\n\nimport collections\n\n# Helper function to find the first index of a value\ndef find_first_index(seq, value):\n    try:\n        return seq.index(value)\n    except ValueError:\n        return -1\n\n# Helper function to find contiguous non-zero block ending before a given index\ndef find_block_before(seq, end_index):\n    if end_index < 0:\n        return -1 # Invalid end index\n    if seq[end_index] == 0:\n        return -1 # Must end with non-zero\n\n    start_index = end_index\n    while start_index >= 0 and seq[start_index] != 0:\n        start_index -= 1\n    return start_index + 1 # Return the actual start index of the non-zero block\n\n# Helper function to find contiguous non-zero block starting after a given index\ndef find_block_after(seq, start_index):\n    if start_index >= len(seq):\n        return -1 # Invalid start index\n    if seq[start_index] == 0:\n        return -1 # Must start with non-zero\n\n    end_index = start_index\n    while end_index < len(seq) and seq[end_index] != 0:\n        end_index += 1\n    return end_index - 1 # Return the actual end index of the non-zero block\n\ndef transform(input_str: str) -> str:\n    \"\"\"\n    Applies the described cyclic shift transformation based on the position of '2'.\n    \"\"\"\n    # Convert input string to list of integers\n    input_list = [int(x) for x in input_str.split()]\n    n = len(input_list)\n    output_list = list(input_list) # Create a mutable copy\n\n    # 1. Locate the Pivot (2)\n    pivot_index = find_first_index(output_list, 2)\n\n    # If 2 is not found, return the original list as a string\n    if pivot_index == -1:\n        return \" \".join(map(str, output_list))\n\n    shifted = False # Flag to track if a shift has occurred\n\n    # 2. Check Before the Pivot\n    # Check if pattern [non-zero block, 0] exists immediately before index(2)\n    if pivot_index > 0 and output_list[pivot_index - 1] == 0:\n        # Check if there's a non-zero number before the zero\n        if pivot_index > 1 and output_list[pivot_index - 2] != 0:\n            # Find the start of the non-zero block ending at pivot_index - 2\n            block_start_index = find_block_before(output_list, pivot_index - 2)\n            if block_start_index != -1:\n                 # Perform right cyclic shift on the segment [block_start_index, pivot_index - 1]\n                 segment_end_index = pivot_index - 1\n                 segment = output_list[block_start_index : segment_end_index + 1]\n                 # The zero is the last element, move it to the front\n                 shifted_segment = [segment[-1]] + segment[:-1]\n                 output_list[block_start_index : segment_end_index + 1] = shifted_segment\n                 shifted = True\n\n    # 3. Check After the Pivot (only if no shift happened before)\n    if not shifted:\n        # Check if pattern [0, non-zero block] exists immediately after index(2)\n        if pivot_index < n - 1 and output_list[pivot_index + 1] == 0:\n            # Check if there's a non-zero number after the zero\n             if pivot_index < n - 2 and output_list[pivot_index + 2] != 0:\n                 # Find the end of the non-zero block starting at pivot_index + 2\n                 block_end_index = find_block_after(output_list, pivot_index + 2)\n                 if block_end_index != -1:\n                     # Perform left cyclic shift on the segment [pivot_index + 1, block_end_index]\n                     segment_start_index = pivot_index + 1\n                     segment = output_list[segment_start_index : block_end_index + 1]\n                     # The zero is the first element, move it to the end\n                     shifted_segment = segment[1:] + [segment[0]]\n                     output_list[segment_start_index : block_end_index + 1] = shifted_segment\n                     shifted = True # Not strictly necessary here, but good practice\n\n    # Convert the result back to a space-separated string\n    return \" \".join(map(str, output_list))\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1287,
    "candidates_token_count": 2077,
    "total_token_count": 3364,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 94.711569,
  "retries": 2
}