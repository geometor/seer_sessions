{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms an input sequence (1D NumPy array of 12 integers) based on the \nposition of the integer '2'. Contiguous blocks of non-zero integers \n(excluding '2') are identified. Blocks located before '2' and not immediately \nadjacent to it are shifted one position to the right in a copy of the sequence. \nBlocks located after '2' and not immediately adjacent to it are shifted one \nposition to the left. The position vacated by a shift (the original start for a \nright shift, the original end for a left shift) is filled with '0'. The integer \n'2' itself and any blocks immediately adjacent to it remain unchanged.\n\"\"\"\n\ndef _find_integer_2(grid):\n    \"\"\"\n    Finds the index of the first occurrence of the integer 2 in the grid.\n\n    Args:\n        grid: A 1D NumPy array of integers.\n\n    Returns:\n        The index of the integer 2, or -1 if not found.\n    \"\"\"\n    # Use np.where to find indices where the value is 2\n    indices = np.where(grid == 2)[0]\n    # Return the first index if found, otherwise -1\n    if len(indices) > 0:\n        return indices[0]\n    else:\n        return -1\n\ndef _find_blocks(grid, index_of_2):\n    \"\"\"\n    Finds contiguous blocks of non-zero integers (excluding the integer 2)\n    in the grid. Uses standard Python iteration.\n\n    Args:\n        grid: A 1D NumPy array of integers.\n        index_of_2: The index of the integer 2 in the grid, or -1 if not present.\n\n    Returns:\n        A list of tuples, where each tuple represents a block and contains\n        its (start_index, end_index).\n    \"\"\"\n    blocks = []\n    n = len(grid)\n    i = 0\n    while i < n:\n        # Check if the current element is the start of a potential block\n        # It must be non-zero and not be the marker '2' (if '2' exists)\n        is_start_of_block = (grid[i] != 0) and (i != index_of_2)\n        \n        if is_start_of_block:\n            start_index = i\n            # Extend the block: move 'i' forward as long as elements \n            # are non-zero, not '2', and within bounds.\n            # Check i+1 < n *before* accessing grid[i+1]\n            while (i + 1 < n) and (grid[i + 1] != 0) and ((i + 1) != index_of_2):\n                i += 1\n            # The block ends at the current index 'i'\n            end_index = i\n            blocks.append((start_index, end_index))\n        # Move to the next potential start position\n        i += 1\n    return blocks\n\ndef transform(input_grid):\n    # Ensure input is a NumPy array for consistency\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid, dtype=int) \n\n    # Create a modifiable copy of the input sequence to store the output\n    output_grid = np.copy(input_grid)\n    n = len(input_grid) # Length of the sequence\n\n    # Find the index (position) of the integer '2' in the original input sequence\n    index_of_2 = _find_integer_2(input_grid)\n\n    # If '2' is not found, the transformation rules don't apply; return the original grid copy\n    if index_of_2 == -1:\n        return output_grid \n\n    # Identify all contiguous blocks of non-zero integers (not '2') in the *original input* sequence\n    # This ensures shifts of one block don't affect the identification/position of others\n    blocks = _find_blocks(input_grid, index_of_2)\n\n    # Iterate through each identified block (defined by start and end index)\n    for start_index, end_index in blocks:\n        \n        # Check if the block is immediately adjacent to '2'\n        # Adjacent if it ends right before '2' OR starts right after '2'\n        is_adjacent_before = (end_index == index_of_2 - 1)\n        is_adjacent_after = (start_index == index_of_2 + 1)\n\n        # If the block is adjacent, make no changes for this block; continue to the next block\n        if is_adjacent_before or is_adjacent_after:\n            continue\n        else:\n            # Block is not adjacent. Determine its relative location.\n            # Check if the block is located entirely before '2'\n            block_is_before_2 = (end_index < index_of_2)\n            # Check if the block is located entirely after '2'\n            block_is_after_2 = (start_index > index_of_2)\n\n            if block_is_before_2:\n                # Shift right: check if the shifted block fits within the grid bounds\n                if end_index + 1 < n:\n                    # Extract block content from the *original* input grid\n                    block_content = input_grid[start_index : end_index + 1]\n                    # Place block content in the new shifted position in the *output_grid*\n                    output_grid[start_index + 1 : end_index + 2] = block_content\n                    # Set the original starting position (vacated space) to 0 in the *output_grid*\n                    output_grid[start_index] = 0\n            elif block_is_after_2:\n                # Shift left: check if the shifted block fits within the grid bounds\n                if start_index - 1 >= 0:\n                    # Extract block content from the *original* input grid\n                    block_content = input_grid[start_index : end_index + 1]\n                    # Place block content in the new shifted position in the *output_grid*\n                    output_grid[start_index - 1 : end_index] = block_content\n                    # Set the original ending position (vacated space) to 0 in the *output_grid*\n                    output_grid[end_index] = 0\n\n    # Return the final modified output sequence\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10048,
    "candidates_token_count": 1844,
    "total_token_count": 11892,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.258073,
  "retries": 1
}