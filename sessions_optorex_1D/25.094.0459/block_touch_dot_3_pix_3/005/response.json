{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule operates on a sequence of single-digit integers, represented as a space-separated string.\n\n1.  **Identify Pivot:** Find the index of the first occurrence of the digit '2'. If '2' is not present, the sequence remains unchanged.\n2.  **Partition:** Split the sequence into three parts: the elements *before* the first '2' (`before_2`), the '2' itself (`pivot`), and the elements *after* the first '2' (`after_2`).\n3.  **Process `after_2`:** Rearrange this section by moving all '0's to the end, while preserving the relative order of the non-zero digits. The non-zero digits come first, followed by the '0's.\n4.  **Process `before_2`:**\n    *   Identify the '0's and non-zero digits in this section.\n    *   **Special Case Check:** Determine if *all* non-zero digits in `before_2` are '3's AND if there is at least one '0' present in `before_2`.\n    *   **Special Case Execution:** If the special case conditions are met, rearrange `before_2` by placing all '0's except one at the very beginning, followed by all the '3's, and finally placing the single remaining '0' at the end of this section (just before the pivot '2').\n    *   **General Case Execution:** If the special case conditions are *not* met, rearrange `before_2` by moving all '0's to the beginning, followed by the non-zero digits, preserving the relative order of the non-zero digits.\n5.  **Combine:** Concatenate the processed `before_2` section, the `pivot` ('2'), and the processed `after_2` section.\n6.  **Format:** Convert the resulting list of integers back into a space-separated string for the final output.\n\"\"\"\n\nimport math # Although not strictly used, kept as per template allowance\n\n# Helper Functions\n\ndef parse_input(input_str: str) -> list[int]:\n    \"\"\"Converts the space-separated string of digits into a list of integers.\"\"\"\n    # Handles potential empty strings or extra spaces gracefully\n    # Filters out non-digit characters defensively\n    return [int(digit) for digit in input_str.split() if digit.isdigit()]\n\ndef format_output(output_list: list[int]) -> str:\n    \"\"\"Converts the list of integers back into a space-separated string.\"\"\"\n    return \" \".join(map(str, output_list))\n\ndef process_before_section(section: list[int]) -> list[int]:\n    \"\"\"\n    Rearranges the section before the pivot '2' according to the rules,\n    including the special case for '3's.\n\n    Args:\n        section: The list of integers before the pivot '2'.\n\n    Returns:\n        The rearranged list section.\n    \"\"\"\n    if not section:\n        return [] # Return empty list if section is empty\n\n    # Separate zeros and non-zeros\n    zeros = [digit for digit in section if digit == 0]\n    non_zeros = [digit for digit in section if digit != 0]\n    num_zeros = len(zeros)\n    num_non_zeros = len(non_zeros)\n\n    # Check for special case: all non-zeros are '3' AND there are both zeros and non-zeros present\n    all_are_threes = all(digit == 3 for digit in non_zeros) if num_non_zeros > 0 else False # Check only if non-zeros exist\n    special_case = all_are_threes and num_non_zeros > 0 and num_zeros > 0\n\n    if special_case:\n        # Special case: Place all but one zero at the start, then non-zeros (all 3s), then the last zero\n        # Example: [3, 3, 0, 0, 0] -> [0, 0, 3, 3, 0]\n        # Need at least one zero for this logic:\n        return zeros[:-1] + non_zeros + [0]\n    else:\n        # General case: All zeros first, then non-zeros preserving relative order\n        # Example: [0, 9, 0, 9] -> [0, 0, 9, 9]\n        # Example: [3, 3, 3] -> [3, 3, 3]\n        # Example: [0, 0, 0] -> [0, 0, 0]\n        return zeros + non_zeros\n\ndef process_after_section(section: list[int]) -> list[int]:\n    \"\"\"\n    Rearranges the section after the pivot '2'. Moves zeros to the end,\n    preserving the relative order of non-zeros.\n\n    Args:\n        section: The list of integers after the pivot '2'.\n\n    Returns:\n        The rearranged list section.\n    \"\"\"\n    if not section:\n        return [] # Return empty list if section is empty\n\n    # Separate zeros and non-zeros\n    zeros = [digit for digit in section if digit == 0]\n    non_zeros = [digit for digit in section if digit != 0]\n\n    # Non-zeros first (preserving relative order), then zeros\n    # Example: [0, 5, 0, 5] -> [5, 5, 0, 0]\n    # Example: [8, 8] -> [8, 8]\n    # Example: [0, 0] -> [0, 0]\n    return non_zeros + zeros\n\n# Main Transformation Function\n\ndef transform(input_str: str) -> str:\n    \"\"\"\n    Applies the transformation rule to the input string sequence.\n    Note: The input parameter name 'input_grid' from the template was changed\n    to 'input_str' to match the 1D string nature of the data.\n    \"\"\"\n    # 1. Parse input string to list of integers\n    input_list = parse_input(input_str)\n    if not input_list: # Handle empty or invalid input\n        return \"\"\n\n    # 2. Find the index of the first '2' (pivot)\n    pivot_index = -1\n    try:\n        pivot_index = input_list.index(2)\n    except ValueError:\n        # If '2' is not found, return the original string as per rule\n        return input_str\n\n    # 3. Partition the list based on the pivot\n    before_part = input_list[:pivot_index]\n    pivot_part = [2]  # Keep the pivot as a list for easy concatenation\n    after_part = input_list[pivot_index + 1:]\n\n    # 4. Process the section *after* the '2'\n    processed_after_part = process_after_section(after_part)\n\n    # 5. Process the section *before* the '2' using its specific rules\n    processed_before_part = process_before_section(before_part)\n\n    # 6. Combine the processed sections with the pivot\n    output_list = processed_before_part + pivot_part + processed_after_part\n\n    # 7. Format the result list back into a space-separated string\n    output_str = format_output(output_list)\n\n    # Return the final transformed string\n    return output_str\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7543,
    "candidates_token_count": 2016,
    "total_token_count": 9559,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.290641,
  "retries": 1
}