{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule operates on a 1D NumPy array of single-digit integers.\n\n1.  **Identify Pivot:** Find the index of the first occurrence of the integer '2'. If '2' is not present, the array remains unchanged.\n2.  **Partition:** Split the array into three parts: the elements *before* the first '2' (`before_2`), the '2' itself (`pivot`), and the elements *after* the first '2' (`after_2`).\n3.  **Process `after_2`:** Rearrange this section by moving all '0's to the end, while preserving the relative order of the non-zero digits. The non-zero digits come first, followed by the '0's.\n4.  **Process `before_2`:**\n    *   Identify the '0's and non-zero digits in this section.\n    *   **Special Case Check:** Determine if *all* non-zero digits in `before_2` are '3's AND if there is at least one '0' present in `before_2`.\n    *   **Special Case Execution:** If the special case conditions are met, rearrange `before_2` by placing all '0's except one at the very beginning, followed by all the '3's, and finally placing the single remaining '0' at the end of this section (just before the pivot '2').\n    *   **General Case Execution:** If the special case conditions are *not* met, rearrange `before_2` by moving all '0's to the beginning, followed by the non-zero digits, preserving the relative order of the non-zero digits.\n5.  **Combine:** Concatenate the processed `before_2` section, the `pivot` ('2'), and the processed `after_2` section into a new NumPy array.\n6.  **Return:** Return the resulting NumPy array.\n\"\"\"\n\nimport numpy as np\n\n# Helper function to process the section *before* the pivot '2'\ndef _process_before_section(section: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Rearranges the section before the pivot '2' according to the rules,\n    including the special case for '3's.\n\n    Args:\n        section: The 1D NumPy array of integers before the pivot '2'.\n\n    Returns:\n        The rearranged 1D NumPy array section.\n    \"\"\"\n    if section.size == 0:\n        return np.array([], dtype=int) # Return empty array if section is empty\n\n    # Separate zeros and non-zeros\n    zeros = section[section == 0]\n    non_zeros = section[section != 0]\n    num_zeros = zeros.size\n    num_non_zeros = non_zeros.size\n\n    # Check for special case: all non-zeros are '3' AND there are both zeros and non-zeros present\n    all_are_threes = np.all(non_zeros == 3) if num_non_zeros > 0 else False # Check only if non-zeros exist\n    special_case = all_are_threes and num_non_zeros > 0 and num_zeros > 0\n\n    if special_case:\n        # Special case: Place all but one zero at the start, then non-zeros (all 3s), then the last zero\n        # Need at least one zero for this logic:\n        if num_zeros > 0:\n             return np.concatenate((zeros[:-1], non_zeros, zeros[-1:]))\n        else: # Should not happen if special_case is True, but safe fallback\n             return non_zeros # Only 3s, no zeros\n    else:\n        # General case: All zeros first, then non-zeros preserving relative order\n        return np.concatenate((zeros, non_zeros))\n\n# Helper function to process the section *after* the pivot '2'\ndef _process_after_section(section: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Rearranges the section after the pivot '2'. Moves zeros to the end,\n    preserving the relative order of non-zeros.\n\n    Args:\n        section: The 1D NumPy array of integers after the pivot '2'.\n\n    Returns:\n        The rearranged 1D NumPy array section.\n    \"\"\"\n    if section.size == 0:\n        return np.array([], dtype=int) # Return empty array if section is empty\n\n    # Separate zeros and non-zeros\n    zeros = section[section == 0]\n    non_zeros = section[section != 0]\n\n    # Non-zeros first (preserving relative order), then zeros\n    return np.concatenate((non_zeros, zeros))\n\n\ndef transform(input_array: np.ndarray) -> np.ndarray:\n    # Ensure input is a NumPy array (might be redundant if guaranteed by caller)\n    if not isinstance(input_array, np.ndarray):\n        # Attempt conversion if possible, or raise error/return input\n        try:\n            input_array = np.array(input_array)\n        except Exception as e:\n             print(f\"Error: Input could not be converted to NumPy array: {e}\")\n             return input_array # Or raise TypeError\n\n    # 1. Find the index of the first '2' (pivot)\n    pivot_indices = np.where(input_array == 2)[0]\n\n    # If '2' is not found, return the original array\n    if pivot_indices.size == 0:\n        return input_array.copy() # Return a copy to avoid modifying original\n\n    pivot_index = pivot_indices[0]\n\n    # 2. Partition the array based on the pivot\n    before_part = input_array[:pivot_index]\n    pivot_part = np.array([2], dtype=int) # Keep the pivot as an array\n    after_part = input_array[pivot_index + 1:]\n\n    # 3. Process the section *after* the '2'\n    processed_after_part = _process_after_section(after_part)\n\n    # 4. Process the section *before* the '2' using its specific rules\n    processed_before_part = _process_before_section(before_part)\n\n    # 5. Combine the processed sections with the pivot\n    output_array = np.concatenate((processed_before_part, pivot_part, processed_after_part))\n\n    # 6. Return the final transformed array\n    return output_array\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9101,
    "candidates_token_count": 1905,
    "total_token_count": 11006,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.500393,
  "retries": 1
}