{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport collections\n\n\"\"\"\nRearranges a sequence of digits based on the position of the digit '2'.\n1. Finds the index of the digit '2'.\n2. Finds the first contiguous block of non-zero digits (excluding '2').\n3. If a block is found and separated from '2' only by zeros, the block and the intervening zeros are swapped.\n4. If the block is to the left of '2', the zeros move to the left of the block.\n5. If the block is to the right of '2', the zeros move to the right of the block.\n6. Otherwise, the sequence remains unchanged.\n\"\"\"\n\ndef find_digit(sequence, digit):\n    \"\"\"Finds the index of the first occurrence of a digit.\"\"\"\n    try:\n        return sequence.index(digit)\n    except ValueError:\n        return -1 # Digit not found\n\ndef find_block(sequence, pivot_index):\n    \"\"\"\n    Finds the first contiguous block of non-zero digits, excluding the pivot digit (2).\n    Returns (start_index, end_index, block_value) or (None, None, None) if no block found.\n    \"\"\"\n    block_start = -1\n    block_end = -1\n    block_value = None\n\n    for i, val in enumerate(sequence):\n        if val != 0 and val != 2:\n            # Found the start of a potential block\n            block_start = i\n            block_value = val\n            # Find the end of the block\n            for j in range(i, len(sequence)):\n                if sequence[j] == block_value:\n                    block_end = j\n                else:\n                    break # End of contiguous block of this value\n            # We only care about the first block found\n            return block_start, block_end, block_value\n        elif val == 2 and i == pivot_index:\n            continue # Skip the pivot digit itself\n\n    # If loop finishes without finding a block\n    return None, None, None\n\ndef transform(input_sequence):\n    \"\"\"\n    Transforms the input sequence according to the described rules.\n\n    Args:\n        input_sequence: A list of single-digit integers.\n\n    Returns:\n        A new list representing the transformed sequence.\n    \"\"\"\n    # Make a copy to avoid modifying the original input list if no transformation occurs\n    output_sequence = list(input_sequence)\n\n    # 1. Locate the index (position) of the digit 2.\n    idx_2 = find_digit(output_sequence, 2)\n    if idx_2 == -1:\n        return output_sequence # No '2', return original\n\n    # 2. Find the contiguous block of non-zero digits that are not 2.\n    block_start, block_end, block_value = find_block(output_sequence, idx_2)\n\n    # If no such block exists, the sequence remains unchanged.\n    if block_start is None:\n        return output_sequence\n\n    # 3. Determine the segment between the block and '2'. Check if it's all zeros.\n    all_zeros = True\n    if block_start > idx_2: # Block is to the right of '2'\n        # Check segment between '2' (exclusive) and block_start (exclusive)\n        segment_start = idx_2 + 1\n        segment_end = block_start\n        # Check adjacency: If block starts immediately after '2'\n        if segment_start == segment_end:\n             return output_sequence # Adjacent, no move needed\n        for i in range(segment_start, segment_end):\n            if output_sequence[i] != 0:\n                all_zeros = False\n                break\n\n    elif block_end < idx_2: # Block is to the left of '2'\n        # Check segment between block_end (exclusive) and '2' (exclusive)\n        segment_start = block_end + 1\n        segment_end = idx_2\n        # Check adjacency: If block ends immediately before '2'\n        if segment_start == segment_end:\n            return output_sequence # Adjacent, no move needed\n        for i in range(segment_start, segment_end):\n            if output_sequence[i] != 0:\n                all_zeros = False\n                break\n    else:\n        # This case should ideally not happen if find_block correctly excludes '2'\n        # Or if the block somehow overlaps with '2', which isn't expected\n        return output_sequence\n\n\n    # 4. If the segment consists entirely of zeros and block isn't adjacent:\n    if all_zeros:\n        # Extract parts of the sequence\n        block = output_sequence[block_start : block_end + 1]\n\n        if block_start > idx_2: # Block is RIGHT of '2'\n            # Segment of zeros is between '2' and block\n            zeros_segment = output_sequence[idx_2 + 1 : block_start]\n            part_before_2 = output_sequence[:idx_2]\n            part_after_block = output_sequence[block_end + 1 :]\n\n            # Reconstruct: Swap block and zeros\n            output_sequence = part_before_2 + [2] + block + zeros_segment + part_after_block\n\n        elif block_end < idx_2: # Block is LEFT of '2'\n            # Segment of zeros is between block and '2'\n            zeros_segment = output_sequence[block_end + 1 : idx_2]\n            part_before_block = output_sequence[:block_start]\n            part_after_2 = output_sequence[idx_2 + 1 :]\n\n            # Reconstruct: Swap block and zeros\n            output_sequence = part_before_block + zeros_segment + block + [2] + part_after_2\n\n    # 5. Return the potentially rearranged sequence.\n    return output_sequence\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1722,
    "candidates_token_count": 3110,
    "total_token_count": 4832,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.062268,
  "retries": 1
}