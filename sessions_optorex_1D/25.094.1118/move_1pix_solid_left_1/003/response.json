{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input 1D NumPy array of integers by finding the first \ncontiguous block of identical non-zero digits and shifting this block \none position to the left. The array maintains its original length, and \npositions outside the shifted block are filled with zeros in the output.\n\"\"\"\n\nimport numpy as np\n\ndef find_first_block_np(data):\n    \"\"\"\n    Finds the start index, end index (exclusive), and value of the first \n    contiguous block of identical non-zero numbers in a NumPy array.\n\n    Args:\n        data: A 1D NumPy array of numbers.\n\n    Returns:\n        A tuple (start_index, end_index, value) if a block is found,\n        otherwise (None, None, None).\n    \"\"\"\n    # Find indices of all non-zero elements\n    non_zero_indices = np.nonzero(data)[0]\n\n    # If no non-zero element found, no block exists\n    if len(non_zero_indices) == 0:\n        return None, None, None\n\n    # The start index is the first non-zero index\n    start_index = non_zero_indices[0]\n    block_value = data[start_index]\n    \n    # Find the end of the block (index after the last element)\n    end_index = start_index + 1\n    n = len(data)\n    while end_index < n and data[end_index] == block_value:\n        end_index += 1\n        \n    # Verify that the block found corresponds to the *first* sequence \n    # of non-zeros. This check is important if there could be multiple \n    # blocks separated by zeros. np.nonzero finds all non-zeros, but we only\n    # care about the first contiguous block. The while loop starting from \n    # non_zero_indices[0] ensures this.\n\n    return start_index, end_index, block_value\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Shifts the first contiguous block of identical non-zero digits \n    one position to the left within the NumPy array.\n\n    Args:\n        input_grid: A 1D NumPy array of integers.\n\n    Returns:\n        A new 1D NumPy array with the block shifted, or a copy of the \n        input array if no such block is found or the block is already\n        at the beginning.\n    \"\"\"\n    # 1. Find the first non-zero block details\n    start_index, end_index, block_value = find_first_block_np(input_grid)\n\n    # If no block is found, return a copy of the original grid\n    if start_index is None:\n        return np.copy(input_grid) \n\n    # If the block starts at index 0, it cannot be shifted left.\n    # Based on examples, this doesn't happen, but handle defensively.\n    # The examples show blocks starting at index 1 or later being shifted.\n    # If a block starts at 0, the examples suggest no change, but the prompt\n    # implies a left shift. Let's assume based on examples that if start_index is 0, \n    # we return the original grid or handle as required if new examples clarify.\n    # The test cases provided all shift blocks starting at index >= 1.\n    # If start_index is 0, new_start_index would be -1.\n    if start_index == 0:\n         # Re-evaluate if examples with start_index=0 appear.\n         # For now, aligning with the pattern that only blocks NOT at the start move.\n         # Example output for input [2, 2, 0] -> [2, 2, 0]? or error? or [2, 0, 0]?\n         # Let's assume no change if already at the start, consistent with outputs.\n         # Example 5 output implies a shift even if starting at index 1 -> index 0.\n         # Example 1 output implies a shift starting at index 1 -> index 0.\n         # Ok, the shift should happen even if it means starting at index 0.\n         pass # Proceed with the shift calculation.\n\n    # 2. Create a new array initialized with zeros\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Calculate the new starting position and block length\n    new_start_index = start_index - 1\n    block_length = end_index - start_index\n\n    # Ensure the new start index isn't negative before slicing\n    if new_start_index < 0:\n        # This case means the block started at index 0.\n        # The problem description/examples don't explicitly cover shifting *off* the grid.\n        # Based on example 1 & 5, shifting *to* index 0 is expected.\n        # If we *must* shift left from index 0, we'd lose the first element.\n        # However, let's stick to the observed patterns where the shift target index >= 0.\n        # If start_index=0, new_start_index = -1. Let's adjust.\n        # The slice `output_grid[-1:block_length-1]` is not intuitive.\n        # Let's refine the copy logic for the edge case start_index=0\n        \n        # If the original block starts at index 0\n        # Example: [2, 2, 0, 0] -> shift left -> [2, 0, 0, 0]? lose one '2'?\n        # The examples show blocks starting >= 1. Let's assume valid shifts.\n        # If an example like [2, 2, ...] -> [2, ...] arises, we'll adapt.\n        # The current logic correctly handles shifts resulting in index 0 (e.g., from index 1).\n         pass # The slicing below handles the valid cases shown.\n\n\n    # 4. Copy the block elements to their new positions in the output grid\n    # Calculate the actual start and end for slicing in the output array\n    output_slice_start = max(0, new_start_index) \n    output_slice_end = new_start_index + block_length\n    \n    # Calculate the corresponding slice from the original block value\n    # If new_start_index is < 0, we start copying from the second element of the block\n    block_copy_len = output_slice_end - output_slice_start\n\n    # Place the block value into the output grid slice\n    if block_copy_len > 0 and output_slice_start < len(output_grid):\n       output_grid[output_slice_start:min(output_slice_end, len(output_grid))] = block_value\n\n\n    # 5. Return the newly created grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5572,
    "candidates_token_count": 2030,
    "total_token_count": 7602,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.091381,
  "retries": 1
}