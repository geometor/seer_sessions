{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nShifts a contiguous block of identical non-zero digits within a 1D sequence \n(potentially represented as the first row of a 2D NumPy array) to the left \nby a distance equal to the block's length. The rest of the elements remain \nzero. Returns the result as a 1D list.\n\"\"\"\n\nimport numpy as np\n\ndef find_non_zero_block_info(data_list):\n    \"\"\"\n    Finds the start index, length, and value of the first contiguous\n    block of identical non-zero digits in a 1D list or array.\n    Assumes exactly one such block exists if any non-zero elements are present.\n\n    Args:\n        data_list: A 1D list or 1D NumPy array of integers.\n\n    Returns:\n        A tuple (start_index, length, value) of the block's properties.\n        Returns (None, 0, 0) if no non-zero digits are found or if input is empty.\n    \"\"\"\n    if not data_list or len(data_list) == 0: # Handle empty input\n        return None, 0, 0\n\n    start_index = -1\n    block_value = 0\n    length = 0\n    in_block = False\n\n    # Iterate through the list to find the block\n    for i, val in enumerate(data_list):\n        if val != 0 and not in_block:  # Found the start of the block\n            start_index = i\n            block_value = val\n            length = 1\n            in_block = True\n        elif in_block and val == block_value:  # Continuing the block\n            length += 1\n        elif in_block and val != block_value: # Found the end of the block\n            break  # Stop searching once the single block ends\n\n    if start_index == -1: # No block found at all\n        return None, 0, 0\n    else:\n        return start_index, length, block_value\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the single non-zero block\n    and shifting it left by its own length. Handles potential 2D numpy array input.\n\n    Args:\n        input_grid: A list, 1D NumPy array, or 2D NumPy array (expected 1xN) \n                   of integers.\n\n    Returns:\n        A list of integers representing the transformed grid.\n    \"\"\"\n    \n    # --- Input Handling ---\n    # Check if input is a NumPy array and potentially 2D (1xN)\n    if isinstance(input_grid, np.ndarray):\n        # If it's 2D and has only one row, extract that row\n        if input_grid.ndim == 2 and input_grid.shape[0] == 1:\n            data_list = input_grid[0].tolist() # Convert the row to a list\n        # If it's 1D, convert it to a list\n        elif input_grid.ndim == 1:\n            data_list = input_grid.tolist()\n        else:\n             # Handle unexpected NumPy array dimensions (e.g., raise error or use first row anyway)\n             # For now, let's assume it won't happen based on test framework behavior\n             # If it does, returning all zeros might be safest default\n             print(f\"Warning: Unexpected input NumPy array shape: {input_grid.shape}. Processing first row.\")\n             if input_grid.shape[0] > 0:\n                data_list = input_grid[0].tolist()\n             else: # Handle empty 2D array case\n                data_list = []\n\n    # If input is already a list, use it directly\n    elif isinstance(input_grid, list):\n        # Check if it's a list of lists (like [[...]])\n        if len(input_grid) > 0 and isinstance(input_grid[0], list):\n             if len(input_grid) == 1: # Assume it's the [[...]] case\n                 data_list = input_grid[0]\n             else:\n                 # Handle unexpected list structure\n                 print(f\"Warning: Unexpected input list structure. Processing first inner list.\")\n                 data_list = input_grid[0]\n        else: # Assume it's already a flat list\n             data_list = input_grid\n    else:\n        # Handle other unexpected input types\n        raise TypeError(f\"Unsupported input type: {type(input_grid)}\")\n\n\n    # Determine the length of the effective 1D list\n    grid_length = len(data_list)\n\n    # Initialize the output_grid as a list of zeros with the same length\n    output_grid = [0] * grid_length\n\n    # --- Core Logic ---\n    # 1. Identify the non-zero block's properties using the helper function.\n    start_index, block_length, block_value = find_non_zero_block_info(data_list)\n\n    # 2. Handle the case where no block was found (e.g., input is all zeros).\n    if start_index is None:\n        return output_grid # Return the grid of zeros\n\n    # 3. Calculate the new starting index for the block.\n    # The shift amount is equal to the block's length.\n    new_start_index = start_index - block_length\n\n    # 4. Place the identified non-zero block into the output grid at the new position.\n    # Iterate 'block_length' times to copy each digit.\n    for i in range(block_length):\n        target_index = new_start_index + i\n        # Check if the target index is within the valid bounds of the grid\n        if 0 <= target_index < grid_length:\n             output_grid[target_index] = block_value\n        # else: This condition shouldn't be met based on the problem's examples,\n        # where start_index >= block_length, ensuring new_start_index >= 0.\n\n    # 5. Return the modified output grid (as a 1D list)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6345,
    "candidates_token_count": 1406,
    "total_token_count": 7751,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.86499,
  "retries": 1
}