{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nfrom collections import Counter\n\n\"\"\"\nTransforms a list or array of 12 integers based on the following rules:\n\n1.  Accept the input, which is a list (or array) of 12 integers.\n2.  Designate the first 10 integers as the `main_sequence` and the last two integers as the `control_digits`, referred to as `c1` (the 11th digit) and `c2` (the 12th digit).\n3.  Create a copy of the full 12-integer input list; this copy will be modified to become the output list.\n4.  Analyze the `main_sequence` to find the `target_digit`:\n    *   Count the occurrences of each non-zero digit.\n    *   If no non-zero digits exist, the process stops, and the original input list is the output.\n    *   Identify the maximum frequency count among these digits.\n    *   Find all digits that have the maximum frequency.\n    *   The `target_digit` is the smallest digit among those with the maximum frequency.\n5.  Identify the `other_digits`: Create a sorted list of all unique non-zero digits present in the `main_sequence` *except* for the `target_digit`.\n6.  Construct the `replacement_values` list: Start with the `other_digits` list, then append `c1` if `c1` is not zero, and finally append `c2` if `c2` is not zero.\n7.  If the `replacement_values` list is empty, no replacements can be made, so the process stops, and the original input list is the output.\n8.  Initialize a counter, `replacement_group_counter`, to 0. This counter tracks which replacement value to use next.\n9.  Iterate through the `main_sequence` using an index `i` from 0 to 9.\n10. If the element at the current index `i` in the *original* `main_sequence` is equal to the `target_digit`:\n    a.  This marks the beginning of a group of target digits.\n    b.  Determine the value to use for replacement: Select the element from the `replacement_values` list at the index (`replacement_group_counter` modulo length of `replacement_values`). Store this as `current_replacement_value`.\n    c.  Find the end index `j` of the contiguous block of `target_digit`s starting at `i`.\n    d.  In the *output list*, replace all elements from index `i` up to and including index `j` with the `current_replacement_value`.\n    e.  Increment the `replacement_group_counter` by 1.\n    f.  Advance the main iteration index `i` to `j` (the loop's natural increment will then move it to `j+1` for the next check).\n11. Continue the iteration until the end of the `main_sequence` is processed (index 9).\n12. Return the final modified 12-integer output list.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_target_digit(sequence: list[int]) -> int | None:\n    \"\"\"\n    Finds the most frequent non-zero digit in the sequence.\n    Handles ties by selecting the smallest digit among the most frequent ones.\n    Returns None if no non-zero digits are present.\n    \"\"\"\n    non_zero_digits = [d for d in sequence if d != 0]\n    if not non_zero_digits:\n        return None # No non-zero digits found\n\n    counts = Counter(non_zero_digits)\n    if not counts:\n         # This case should not be reachable if non_zero_digits is not empty\n         return None \n\n    # Find the maximum frequency\n    max_freq = 0\n    # More efficient way to get max frequency\n    # max_freq = max(counts.values()) \n    for digit in counts:\n        if counts[digit] > max_freq:\n            max_freq = counts[digit]\n\n    # Find all digits with that maximum frequency\n    most_frequent_digits = [digit for digit, count in counts.items() if count == max_freq]\n\n    # Return the smallest digit among those with the maximum frequency\n    return min(most_frequent_digits)\n\n\ndef find_other_digits(sequence: list[int], target_digit: int | None) -> list[int]:\n    \"\"\"Finds unique non-zero digits in the sequence, excluding the target_digit, and returns them sorted.\"\"\"\n    if target_digit is None:\n        # If there's no target, technically all non-zeros are \"other\", but based on logic,\n        # if there's no target, replacement won't happen anyway. Return empty.\n        return []\n    other_digits_set = set(d for d in sequence if d != 0 and d != target_digit)\n    return sorted(list(other_digits_set))\n\ndef construct_replacement_values(other_digits: list[int], control_digits: list[int]) -> list[int]:\n    \"\"\"Constructs the ordered list of replacement values from other_digits and non-zero control digits.\"\"\"\n    # Start with the sorted list of other non-zero digits found in the main sequence\n    replacement_values = list(other_digits) \n    \n    # Append control digits if they are non-zero\n    c1, c2 = control_digits\n    if c1 != 0:\n        replacement_values.append(c1)\n    if c2 != 0:\n        replacement_values.append(c2)\n    return replacement_values\n\n# === Main Transformation Function ===\n\ndef transform(input_list: list[int]) -> list[int]:\n    \"\"\"\n    Applies the transformation rule to the input list of 12 integers.\n    \"\"\"\n    # Basic input validation (optional, depending on framework guarantees)\n    if not isinstance(input_list, list) or len(input_list) != 12:\n         # Depending on requirements, raise error or return input\n         # raise ValueError(\"Input must be a list of 12 integers.\")\n         return input_list # Return unmodified input if invalid\n\n    # Step 2 & 3: Separate sequences and create output copy\n    main_sequence = input_list[:10]\n    control_digits = input_list[10:]\n    output_list = list(input_list) # Create a copy to modify\n\n    # --- Core Logic ---\n    # Step 4: Find the target digit \n    target_digit = find_target_digit(main_sequence)\n\n    # Step 4 (cont.) / Step 7: Early exit if no target digit\n    if target_digit is None:\n        return output_list # Return original list\n\n    # Step 5: Find other non-zero digits (excluding target)\n    other_digits = find_other_digits(main_sequence, target_digit)\n\n    # Step 6: Construct the list of replacement values\n    replacement_values = construct_replacement_values(other_digits, control_digits)\n\n    # Step 7: Early exit if no replacement values are available\n    if not replacement_values:\n        return output_list # Return original list, as no replacements can be made\n\n    # Step 8: Initialize counter for replacement value cycling\n    replacement_cycle_index = 0 \n\n    # Step 9 & 11: Iterate through the main sequence (indices 0-9)\n    i = 0\n    while i < 10:\n        # Step 10: Check if the current digit is the target digit\n        if main_sequence[i] == target_digit:\n            # Step 10.a: Found the start of a target group\n            start_index = i\n\n            # Step 10.b: Determine the replacement value for this entire group\n            # Use modulo operator for cycling through replacement values\n            current_replacement = replacement_values[replacement_cycle_index % len(replacement_values)]\n\n            # Step 10.c: Find the end of the contiguous group of target digits\n            j = i\n            # Look ahead to find where the sequence of target digits ends\n            while j < 10 and main_sequence[j] == target_digit:\n                j += 1\n            # The end index is the last position where the digit was the target\n            end_index = j - 1 \n\n            # Step 10.d: Replace the identified group in the output list\n            for k in range(start_index, end_index + 1):\n                output_list[k] = current_replacement\n\n            # Step 10.e: Move to the next replacement value for the next group\n            replacement_cycle_index += 1\n\n            # Step 10.f: Advance the main loop index past this processed group\n            # The loop condition `i < 10` and the increment `i += 1` handle continuation\n            i = end_index # Set i to the end of the group processed\n\n        # Move to the next position in the main sequence for the next iteration\n        i += 1\n\n    # Step 12: Return the modified list\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13213,
    "candidates_token_count": 2091,
    "total_token_count": 15304,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.519024,
  "retries": 1
}