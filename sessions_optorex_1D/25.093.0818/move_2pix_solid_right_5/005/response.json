{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence of 12 integers by identifying a single contiguous block of identical non-zero integers and shifting this block exactly two positions to the right. The remaining positions are filled with zeros. Input might be a NumPy array or a string representation like \"[0 0 ...]\". Output is a space-separated string.\n\"\"\"\n\nimport numpy as np\nimport re # For parsing the string input if necessary\n\ndef _parse_input(input_data):\n    \"\"\"Converts various input formats to a 1D NumPy array.\"\"\"\n    if isinstance(input_data, np.ndarray):\n        # If it's already a NumPy array, ensure it's 1D\n        if input_data.ndim > 1:\n             # Attempt to flatten if it makes sense, otherwise raise error\n             # Assuming for this task, multi-dim means rows of sequences, take first row\n             if input_data.shape[0] == 1:\n                 return input_data.flatten()\n             else:\n                 # Or handle based on specific multi-dim interpretation if needed\n                 # For now, let's assume the first row is the sequence\n                 # print(f\"Warning: Input is multi-dimensional {input_data.shape}, using first row.\")\n                 return input_data[0] \n        return input_data # It's already a 1D NumPy array\n\n    elif isinstance(input_data, str):\n        # If it's a string, clean and parse\n        # Remove potential brackets and extra whitespace\n        cleaned_str = input_data.strip().strip('[]')\n        # Split by space and convert to int\n        try:\n            int_list = [int(x) for x in cleaned_str.split()]\n            return np.array(int_list, dtype=int)\n        except ValueError as e:\n            raise ValueError(f\"Could not parse input string: '{input_data}'. Error: {e}\")\n\n    elif isinstance(input_data, list):\n         # If it's a list, convert directly\n         try:\n             return np.array(input_data, dtype=int)\n         except ValueError as e:\n             raise ValueError(f\"Could not convert input list to NumPy array: {input_data}. Error: {e}\")\n    else:\n        raise TypeError(f\"Unsupported input type: {type(input_data)}\")\n\n\ndef _find_block_indices(sequence: np.ndarray):\n    \"\"\"Finds the start and end indices of the contiguous non-zero block.\"\"\"\n    non_zero_indices = np.nonzero(sequence)[0]\n    if non_zero_indices.size == 0:\n        # No non-zero elements found\n        return None, None\n    else:\n        # Block start is the first non-zero index\n        start_index = non_zero_indices[0]\n        # Block end is the last non-zero index\n        end_index = non_zero_indices[-1]\n        # Basic check for contiguity assumption (optional but good practice)\n        # expected_length = end_index - start_index + 1\n        # if non_zero_indices.size != expected_length:\n        #     print(f\"Warning: Non-zero elements at {non_zero_indices} may not be contiguous.\")\n        return start_index, end_index\n\ndef transform(input_grid) -> str:\n    \"\"\"\n    Applies the transformation rule: finds a contiguous non-zero block\n    and shifts it 2 positions to the right.\n\n    Args:\n        input_grid: Can be a 1D NumPy array, a list of ints, or a string\n                    representation like \"[0 8 8 ...]\" or \"0 8 8 ...\".\n\n    Returns:\n        A string of space-separated integers representing the transformed sequence.\n    \"\"\"\n    # 1. Parse the input into a standard NumPy array format\n    try:\n        input_sequence = _parse_input(input_grid)\n    except (TypeError, ValueError) as e:\n        print(f\"Error processing input: {e}\")\n        # Return a default or error state if parsing fails\n        # For now, assume a fixed length and return zeros if input is bad\n        try:\n           # Attempt to guess length from string representation if possible\n           length = len(str(input_grid).split()) \n           if length < 5: length = 12 # Heuristic fallback\n        except:\n           length = 12 # Default fallback length\n        return \" \".join(['0'] * length)\n\n\n    sequence_length = input_sequence.shape[0]\n\n    # 2. Initialize output_grid as a NumPy array of zeros\n    output_grid = np.zeros_like(input_sequence)\n\n    # 3. Find the start and end indices of the non-zero block\n    start_index, end_index = _find_block_indices(input_sequence)\n\n    # 4. If a block is found, perform the shift\n    if start_index is not None and end_index is not None:\n        # Extract the block\n        block = input_sequence[start_index : end_index + 1]\n        block_len = len(block)\n\n        # Calculate the new starting position for the block\n        new_start_index = start_index + 2\n\n        # Determine the portion of the block that fits in the output grid\n        if new_start_index < sequence_length:\n            # Calculate how many elements from the block can be copied\n            num_to_copy = min(block_len, sequence_length - new_start_index)\n\n            # Define the source slice from the extracted block\n            source_slice = block[0 : num_to_copy]\n\n            # Define the target slice in the output grid\n            target_start = new_start_index\n            target_end = new_start_index + num_to_copy\n\n            # Place the relevant part of the block into the output grid\n            output_grid[target_start : target_end] = source_slice\n        # Else: If new_start_index >= sequence_length, the block shifts entirely off the grid,\n        # and output_grid remains all zeros (as initialized).\n\n    # 5. Convert the output NumPy array back to a space-separated string\n    output_str = \" \".join(map(str, output_grid))\n\n    return output_str\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5661,
    "candidates_token_count": 1440,
    "total_token_count": 7101,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.034463,
  "retries": 1
}