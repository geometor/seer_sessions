{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n\"\"\"\nIdentifies and isolates the longest contiguous sequence (run) of a single \nnon-zero digit within an input sequence of digits. The input might be \nrepresented as a 2D grid/array with a single row. If multiple runs share \nthe maximum length, the one appearing earliest (smallest start index) is chosen. \nThe output sequence retains only the digits from this chosen run in their \noriginal positions, with all other positions set to zero. The output sequence\nhas the same length as the input sequence and is returned as a 1D array.\n\"\"\"\n\n# Define a structure to hold information about a run\nRunInfo = namedtuple(\"RunInfo\", [\"digit\", \"start\", \"end\", \"length\"])\n\ndef find_runs(digit_sequence):\n    \"\"\"\n    Scans the 1D input sequence to identify all contiguous runs of non-zero digits.\n\n    Args:\n        digit_sequence: A 1D list or NumPy array of integers.\n\n    Returns:\n        A list of RunInfo objects, each describing a contiguous run.\n    \"\"\"\n    runs = []\n    n = len(digit_sequence)\n    if n == 0:\n        return runs\n\n    current_run_digit = None\n    current_run_start = -1\n\n    # Iterate through the sequence with index\n    for i in range(n):\n        current_digit_int = int(digit_sequence[i]) # Ensure comparison with standard int\n\n        if current_digit_int != 0:\n            # Check if we are continuing a run or starting a new one\n            if current_digit_int == current_run_digit:\n                # Continue existing run - no action needed here\n                pass\n            else:\n                # End previous run if one exists\n                if current_run_digit is not None:\n                    runs.append(RunInfo(current_run_digit, current_run_start, i - 1, i - current_run_start))\n\n                # Start a new run\n                current_run_digit = current_digit_int\n                current_run_start = i\n        else:\n            # Current digit is zero, end any active run\n            if current_run_digit is not None:\n                runs.append(RunInfo(current_run_digit, current_run_start, i - 1, i - current_run_start))\n\n            # Reset run tracking\n            current_run_digit = None\n            current_run_start = -1\n\n    # After the loop, check if a run was active at the end of the sequence\n    if current_run_digit is not None:\n        runs.append(RunInfo(current_run_digit, current_run_start, n - 1, n - current_run_start))\n\n    return runs\n\ndef find_longest_run(runs):\n    \"\"\"\n    Determines the run with the maximum length from a list of runs.\n    If multiple runs share the maximum length, selects the one with the\n    smallest start index.\n\n    Args:\n        runs: A list of RunInfo objects.\n\n    Returns:\n        The selected RunInfo object representing the target run,\n        or None if the input list of runs is empty.\n    \"\"\"\n    if not runs:\n        return None\n\n    # Find the maximum length among all runs\n    max_length = 0\n    for run in runs:\n        if run.length > max_length:\n            max_length = run.length\n\n    # Filter runs to keep only those with the maximum length\n    longest_runs = [run for run in runs if run.length == max_length]\n\n    # If there's only one longest run, it's the target\n    if len(longest_runs) == 1:\n        return longest_runs[0]\n\n    # If there are multiple runs with the same max length, find the earliest one\n    # Sort by start index and take the first one\n    longest_runs.sort(key=lambda r: r.start)\n    return longest_runs[0]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms an input grid (potentially 2D representing a 1D sequence)\n    based on the longest run rule.\n\n    Args:\n        input_grid: A list of lists or NumPy array representing the input digits.\n                     Expected to contain the relevant sequence, likely as the first row.\n\n    Returns:\n        A 1D NumPy array of integers representing the transformed sequence.\n    \"\"\"\n    # Convert input to numpy array for consistent handling\n    input_array = np.array(input_grid)\n\n    # --- Input Handling: Ensure we are working with a 1D sequence ---\n    # Check dimensions. If it's 2D and has one row, extract that row.\n    # If it's already 1D, use it directly.\n    # Handle other cases (e.g., empty, multiple rows) as appropriate.\n    if input_array.ndim == 0: # Handle scalar input case? Return empty or based on rules.\n        return np.array([])\n    elif input_array.ndim == 2:\n        if input_array.shape[0] == 1: # Shape (1, N)\n            sequence = input_array[0]\n        elif input_array.shape[1] == 1: # Shape (N, 1) -> Treat as column? Flatten.\n             sequence = input_array.flatten()\n        else:\n             # If it's multi-row, multi-column, the rule is ambiguous.\n             # Assuming based on examples, it's effectively 1D.\n             # Let's default to processing the first row if shape[0] > 1\n             print(f\"Warning: Input grid has multiple rows ({input_array.shape}). Processing the first row.\")\n             sequence = input_array[0]\n    elif input_array.ndim == 1:\n        sequence = input_array\n    else:\n        raise ValueError(f\"Unhandled input array dimension: {input_array.ndim}\")\n\n    n = len(sequence)\n\n    # Initialize the output sequence with zeros, matching input length and type\n    output_sequence = np.zeros_like(sequence)\n\n    # Find all contiguous runs of non-zero digits in the sequence\n    runs = find_runs(sequence)\n\n    # Determine the target run (longest, then earliest)\n    target_run = find_longest_run(runs)\n\n    # If a target run was identified, populate the output sequence\n    if target_run:\n        # Iterate through the indices covered by the target run\n        for i in range(target_run.start, target_run.end + 1):\n            # Set the corresponding elements in the output sequence to the run's digit\n            output_sequence[i] = target_run.digit\n\n    # Return the resulting 1D sequence\n    # Note: If the test harness STRICTLY expects the same shape as input (e.g., 2D),\n    # this might need reshaping back, e.g., output_sequence.reshape(1, -1)\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8992,
    "candidates_token_count": 2351,
    "total_token_count": 11343,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.822396,
  "retries": 1
}