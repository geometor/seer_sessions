{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence (list or NumPy array, treated as 1D) by keeping\nonly the first longest contiguous sequence (block) of non-zero numbers found\nwithin it. All other elements are replaced with zero. If multiple blocks share\nthe maximum length, the one occurring earliest (smallest starting index) in the\nflattened sequence is chosen. If no non-zero numbers are present, the output is\na sequence of zeros of the same length.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Dict, Optional, Union, Sequence\n\ndef _find_blocks(input_list: List[int]) -> List[Dict[str, int]]:\n    \"\"\"\n    Helper function to find all contiguous blocks of non-zero numbers.\n\n    Args:\n        input_list: The input list of integers (flattened).\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        and contains 'start', 'end', and 'length'. Returns an empty list\n        if no non-zero numbers are found.\n    \"\"\"\n    blocks = []\n    current_start = -1\n    n = len(input_list)\n\n    for i in range(n):\n        is_non_zero = input_list[i] != 0\n        is_last_element = (i == n - 1)\n\n        # Start of a potential block: current element is non-zero, and we are not already in a block\n        if is_non_zero and current_start == -1:\n            current_start = i\n\n        # End of a block: (current element is zero OR it's the last element) AND we were in a block\n        if (not is_non_zero or is_last_element) and current_start != -1:\n            # Determine the correct end index\n            # If current is zero, block ended at i-1. If current is non-zero and it's the last element, block ends at i.\n            current_end = i - 1 if not is_non_zero else i\n\n            # Calculate block length\n            block_length = current_end - current_start + 1\n            # Store block info\n            blocks.append({\n                'start': current_start,\n                'end': current_end,\n                'length': block_length\n            })\n            # Reset for the next potential block\n            current_start = -1\n\n    return blocks\n\ndef _find_target_block(blocks: List[Dict[str, int]]) -> Optional[Dict[str, int]]:\n    \"\"\"\n    Helper function to find the first block with the maximum length.\n\n    Args:\n        blocks: A list of block dictionaries found by _find_blocks.\n\n    Returns:\n        The dictionary representing the target block (first longest), or None if no blocks exist.\n    \"\"\"\n    if not blocks:\n        return None\n\n    # Find the maximum length among all identified blocks\n    max_len = 0\n    for block in blocks:\n        if block['length'] > max_len:\n            max_len = block['length']\n    \n    # Find the first block (earliest start index) that has the maximum length\n    # The blocks list is naturally ordered by start index based on how _find_blocks works.\n    target_block = None\n    for block in blocks:\n        if block['length'] == max_len:\n            target_block = block\n            break # Stop searching once the first longest block is found\n\n    return target_block\n\n\ndef transform(input_grid: Union[List[int], np.ndarray]) -> List[int]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: The input sequence (list or NumPy array).\n\n    Returns:\n        A list of integers representing the transformed sequence.\n    \"\"\"\n    # Step 1 & 2: Ensure input is a flat list\n    if isinstance(input_grid, np.ndarray):\n        flat_list = input_grid.flatten().tolist()\n    elif isinstance(input_grid, list):\n        # Quick check if it's nested (simple case)\n        if input_grid and isinstance(input_grid[0], list):\n             # Basic flattening for list of lists\n             flat_list = [item for sublist in input_grid for item in sublist]\n        else:\n            flat_list = list(input_grid) # Ensure it's a list copy\n    else:\n        # Fallback: try converting to list directly, might raise error for complex types\n        try:\n            flat_list = list(input_grid)\n        except TypeError:\n            raise TypeError(\"Input grid must be a list, NumPy array, or sequence convertible to list.\")\n\n    n = len(flat_list)\n    \n    # Step 10: Initialize output list with zeros\n    output_list = [0] * n\n\n    # Step 3-5: Find all non-zero blocks\n    blocks = _find_blocks(flat_list)\n\n    # Step 6: Handle case with no non-zero blocks\n    if not blocks:\n        return output_list # Return the list of zeros\n\n    # Step 7-9: Find the target block (first longest)\n    target_block = _find_target_block(blocks)\n\n    # Step 11: Copy the target block's elements to the output list\n    if target_block:\n        start = target_block['start']\n        end = target_block['end']\n        for i in range(start, end + 1):\n            # Basic bounds check, although logic should prevent issues\n            if 0 <= i < n:\n                output_list[i] = flat_list[i]\n\n    # Step 12: Return the final transformed list\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9181,
    "candidates_token_count": 1640,
    "total_token_count": 10821,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.494135,
  "retries": 1
}