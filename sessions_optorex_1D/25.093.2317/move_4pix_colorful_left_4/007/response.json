{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms an input sequence of integers by identifying a 'core block' \n(from the first non-zero element to the last non-zero element, inclusive) \nand shifting this block 4 positions to the left within a new sequence of \nthe same length, initialized with zeros. Zeros pad the sequence on the right \nafter the shifted block. Elements shifted beyond the beginning (index < 0) \nor end (index >= length) of the sequence are discarded. The final output is \nreturned as a list of integers.\n\"\"\"\n\n# Helper function to find the indices of the first and last non-zero elements\ndef find_non_zero_bounds_np(sequence: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the index of the first and last non-zero element in a NumPy array.\n\n    Args:\n        sequence: The input NumPy array of integers.\n\n    Returns:\n        A tuple containing the start and end indices (inclusive) of the \n        non-zero block, or None if no non-zero elements are found.\n    \"\"\"\n    # Find indices where elements are not zero\n    non_zero_indices = np.nonzero(sequence)[0] # Get indices for the first dimension (works for 1D arrays)\n    \n    # If no non-zero elements were found, return None\n    if len(non_zero_indices) == 0:\n        return None\n        \n    # Otherwise, return the first and last index from the list of non-zero indices\n    first_nz_idx = non_zero_indices[0]\n    last_nz_idx = non_zero_indices[-1]\n    return (first_nz_idx, last_nz_idx)\n\ndef transform(input_sequence_list: List[int]) -> List[int]:\n    \"\"\"\n    Applies the core block left shift transformation to the input sequence.\n\n    Args:\n        input_sequence_list: The input list of integers.\n\n    Returns:\n        The transformed list of integers.\n    \"\"\"\n    # Convert input list to a NumPy array for easier manipulation\n    input_sequence = np.array(input_sequence_list, dtype=int)\n    \n    # Get the length of the sequence\n    n = len(input_sequence)\n    \n    # Define the fixed amount to shift the core block to the left\n    shift_amount = 4\n\n    # Initialize the output sequence as a NumPy array of zeros with the same length\n    output_sequence = np.zeros(n, dtype=int) \n\n    # Find the start and end indices of the core block (first to last non-zero)\n    bounds = find_non_zero_bounds_np(input_sequence)\n\n    # If no non-zero elements exist (bounds is None), the output is all zeros.\n    # Return the initialized output sequence converted back to a list.\n    if bounds is None:\n        return output_sequence.tolist() \n\n    # Unpack the start and end indices\n    first_nz_idx, last_nz_idx = bounds\n\n    # Extract the core block from the input sequence using slicing\n    core_block = input_sequence[first_nz_idx : last_nz_idx + 1]\n    core_len = len(core_block)\n    \n    # Calculate the *intended* starting position for the core block in the output sequence\n    # This is the starting position if there were no boundaries\n    output_start_idx_intended = first_nz_idx - shift_amount\n\n    # --- Determine the actual portion of the core block to copy and its destination ---\n    # This handles cases where the block shifts partially or fully off the left edge,\n    # or would extend beyond the right edge.\n\n    # Initialize variables for slicing the core_block and placing it in the output\n    copy_start_in_core = 0          # Starting index within the core_block to copy from\n    copy_start_in_output = output_start_idx_intended # Starting index within the output_sequence to place into\n    copy_len = core_len             # Number of elements to copy\n\n    # Adjust if the intended start index is negative (shifted off the left boundary)\n    if copy_start_in_output < 0:\n        # Calculate how many elements are shifted off the left\n        off_left_amount = -copy_start_in_output \n        # Adjust the starting point within the core_block to skip these elements\n        copy_start_in_core = off_left_amount\n        # Reduce the number of elements to copy\n        copy_len -= off_left_amount\n        # The actual placement in the output sequence will start at index 0\n        copy_start_in_output = 0\n        \n    # Adjust if the block extends beyond the right boundary (index >= n)\n    # Check if the calculated end position exceeds the length of the output sequence\n    if copy_start_in_output + copy_len > n:\n         # Reduce the number of elements to copy so it fits exactly within the array length\n         copy_len = n - copy_start_in_output\n\n    # --- Perform the copy operation if there are elements to copy ---\n    # Check if after adjustments, there's still a positive number of elements to copy\n    if copy_len > 0:\n        # Slice the core block to get the exact part that needs to be copied\n        core_to_copy = core_block[copy_start_in_core : copy_start_in_core + copy_len]\n        # Place this slice into the output sequence at the calculated position\n        output_sequence[copy_start_in_output : copy_start_in_output + copy_len] = core_to_copy\n\n    # Convert the final NumPy array back to a standard Python list and return it\n    return output_sequence.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14271,
    "candidates_token_count": 1823,
    "total_token_count": 16094,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.626589,
  "retries": 1
}