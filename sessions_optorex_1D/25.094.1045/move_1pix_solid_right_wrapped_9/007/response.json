{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections # Used for defaultdict or Counter if needed, but not strictly necessary here.\n\n\"\"\"\nTransforms a 1D NumPy array of integers based on moving elements relative to the first longest contiguous block of zeros.\n\n1.  Identify all contiguous blocks composed entirely of zeros within the input sequence.\n2.  If no blocks of zeros exist, return the original sequence unchanged.\n3.  Determine the maximum length among all identified zero blocks.\n4.  Select the block of zeros that has this maximum length and starts at the earliest index in the sequence (the \"first longest block\"). Let its start index be `block_start` and end index be `block_end`.\n5.  Check if the selected block ends at the last position of the sequence (i.e., if `block_end` is the index of the last element).\n6.  If the block *is* at the end of the sequence:\n    a.  Find the index of the first non-zero element that appears *before* `block_start`. Let this be `target_index`. If no non-zero element exists before `block_start`, set `target_index` to 0.\n    b.  Identify the element to move: it is the first zero of the selected block (the element currently at `block_start`).\n    c.  Remove this element from its position (`block_start`).\n    d.  Insert the removed element into the sequence at `target_index`.\n7.  If the block is *not* at the end of the sequence:\n    a.  Identify the element to move: it is the element immediately following the selected block (the element currently at `block_end + 1`).\n    b.  Identify the target insertion index: it is the starting index of the selected block (`block_start`).\n    c.  Remove the element to move from its original position (`block_end + 1`).\n    d.  Insert the removed element into the sequence at the target insertion index (`block_start`).\n8.  Return the modified sequence as a NumPy array.\n\"\"\"\n\n\n# Helper function to find all contiguous blocks of zeros\ndef find_zero_blocks(seq):\n    \"\"\"Finds all contiguous blocks of zeros in a list.\"\"\"\n    blocks = []\n    start_index = -1\n    n = len(seq)\n    for i, val in enumerate(seq):\n        if val == 0 and start_index == -1:\n            # Start of a potential block\n            start_index = i\n        elif val != 0 and start_index != -1:\n            # End of the current block\n            end_index = i - 1\n            blocks.append({'start': start_index, 'end': end_index, 'len': end_index - start_index + 1})\n            start_index = -1 # Reset for next block\n\n    # Check if the sequence ends with a block of zeros\n    if start_index != -1:\n        end_index = n - 1\n        blocks.append({'start': start_index, 'end': end_index, 'len': end_index - start_index + 1})\n\n    return blocks\n\n# Helper function to find the first longest block of zeros\ndef find_first_longest_block(blocks):\n    \"\"\"Finds the longest block of zeros from a list of blocks, selecting the first one in case of a tie.\"\"\"\n    if not blocks:\n        return None\n\n    max_len = 0\n    # Find the maximum length among all blocks\n    for block in blocks:\n        if block['len'] > max_len:\n            max_len = block['len']\n\n    # Filter blocks that have the maximum length\n    longest_blocks = [block for block in blocks if block['len'] == max_len]\n\n    # Select the one with the smallest start index if there are multiple longest blocks\n    selected_block = min(longest_blocks, key=lambda b: b['start'])\n    return selected_block\n\n# Helper function to find the index for insertion when the block is at the end\ndef find_target_insertion_index_for_end_block(seq, block_start):\n    \"\"\"Finds the index of the first non-zero element before block_start. Returns 0 if none found.\"\"\"\n    target_index = 0 # Default to index 0\n    found = False\n    for i in range(block_start):\n        if seq[i] != 0:\n            target_index = i\n            found = True\n            break # Found the first non-zero element\n    # If no non-zero element was found before the block, target_index remains 0.\n    return target_index\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    # Convert numpy array to list for easier manipulation (pop/insert)\n    seq = input_grid.tolist()\n    n = len(seq)\n\n    # Handle empty input\n    if n == 0:\n        return input_grid # Return original empty array\n\n    # 1. Identify all contiguous blocks of zeros\n    zero_blocks = find_zero_blocks(seq)\n\n    # 2. Handle case where there are no zeros\n    if not zero_blocks:\n        return input_grid # Return original array if no zeros\n\n    # 3 & 4. Find the first longest block\n    selected_block = find_first_longest_block(zero_blocks)\n    block_start = selected_block['start']\n    block_end = selected_block['end']\n\n    # Create a mutable copy (already done by tolist())\n    output_seq = seq\n\n    # 5. Determine if the selected block is at the end of the sequence\n    is_at_end = (block_end == n - 1)\n\n    if is_at_end:\n        # 6. Block is at the end\n        # 6a. Find the target insertion index\n        target_index = find_target_insertion_index_for_end_block(output_seq, block_start)\n\n        # 6b. Identify the element to move (first zero of the block)\n        # 6c. Remove this element from its original position\n        # Check if block_start is valid before popping\n        if 0 <= block_start < len(output_seq):\n             moved_element = output_seq.pop(block_start)\n\n             # 6d. Insert the removed element into the sequence at the target index\n             # Adjust target_index if it was affected by the pop operation\n             # If target_index < block_start, it's unaffected.\n             # If target_index >= block_start, it's not possible because target must be *before* block_start\n             # So, target_index is always correct relative to the state before the pop.\n             output_seq.insert(target_index, moved_element)\n        # Else: if block_start is somehow invalid (e.g., empty sequence edge case handled earlier), do nothing extra.\n\n    else:\n        # 7. Block is *not* at the end\n        # This implies block_end + 1 < n, so an element exists after the block.\n\n        # 7a. Identify the element to move (element immediately following block)\n        move_from_index = block_end + 1\n\n        # Check if move_from_index is valid\n        if 0 <= move_from_index < len(output_seq):\n            element_to_move = output_seq[move_from_index]\n\n            # 7c. Remove this element from its original position\n            output_seq.pop(move_from_index)\n\n            # 7b & 7d. Insert the removed element at the target index (start of the block)\n            # The block_start index might have shifted if move_from_index < block_start,\n            # but this is not possible since move_from_index = block_end + 1 >= block_start + 1.\n            # So block_start is correct relative to the list after the pop.\n            output_seq.insert(block_start, element_to_move)\n        # Else: If move_from_index is invalid (shouldn't happen if block is not at end and n>0), do nothing extra.\n\n    # 8. Convert the modified list back to a NumPy array\n    # Preserve original dtype if possible, otherwise default int might be okay\n    output_grid = np.array(output_seq, dtype=input_grid.dtype)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12490,
    "candidates_token_count": 2299,
    "total_token_count": 14789,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.792869,
  "retries": 1
}