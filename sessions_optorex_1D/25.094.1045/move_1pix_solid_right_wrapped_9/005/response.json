{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1D NumPy array of integers based on swapping elements relative to the longest contiguous block of zeros.\n\n1.  Identify all contiguous blocks of zeros within the input sequence.\n2.  If no blocks of zeros are found, return the original sequence.\n3.  Find the block(s) with the greatest length. If there is more than one block with the maximum length, select the one that starts at the earliest index (the first longest block).\n4.  Determine if this selected block ends at the last index of the sequence.\n5.  If the block is at the end of the sequence:\n    a.  Search the sequence *before* the start of the block for the first non-zero element (i.e., find the smallest index `i` such that `i < block_start_index` and `sequence[i] != 0`).\n    b.  If such a non-zero element is found at index `j`:\n        i.  Identify the first zero of the selected block (at index `block_start_index`).\n        ii. Swap the element at index `j` with the element at index `block_start_index`.\n    c.  If no non-zero element is found before the block, make no changes to the sequence.\n6.  If the block is *not* at the end of the sequence:\n    a.  Identify the element immediately following the block (at index `block_end_index + 1`).\n    b.  Identify the first zero of the selected block (at index `block_start_index`).\n    c.  Swap the element immediately following the block with the first zero of the block.\n7.  Return the modified sequence as a NumPy array.\n\"\"\"\n\ndef find_zero_blocks(seq):\n    \"\"\"Finds all contiguous blocks of zeros in a list.\"\"\"\n    blocks = []\n    start_index = -1\n    n = len(seq)\n    for i, val in enumerate(seq):\n        if val == 0 and start_index == -1:\n            # Start of a potential block\n            start_index = i\n        elif val != 0 and start_index != -1:\n            # End of the current block\n            end_index = i - 1\n            blocks.append({'start': start_index, 'end': end_index, 'len': end_index - start_index + 1})\n            start_index = -1 # Reset for next block\n\n    # Check if the sequence ends with a block of zeros\n    if start_index != -1:\n        end_index = n - 1\n        blocks.append({'start': start_index, 'end': end_index, 'len': end_index - start_index + 1})\n\n    return blocks\n\ndef find_first_longest_block(blocks):\n    \"\"\"Finds the longest block of zeros from a list of blocks, selecting the first one in case of a tie.\"\"\"\n    if not blocks:\n        return None\n\n    max_len = 0\n    # Find the maximum length among all blocks\n    for block in blocks:\n        if block['len'] > max_len:\n            max_len = block['len']\n\n    # Filter blocks that have the maximum length\n    longest_blocks = [block for block in blocks if block['len'] == max_len]\n\n    # Select the one with the smallest start index if there are multiple longest blocks\n    selected_block = min(longest_blocks, key=lambda b: b['start'])\n    return selected_block\n\ndef find_first_preceding_non_zero_index(seq, block_start):\n    \"\"\"Finds the index of the first non-zero element before the block_start index.\"\"\"\n    target_index = -1 # Return -1 if no non-zero element is found\n    for i in range(block_start):\n        if seq[i] != 0:\n            target_index = i\n            break # Found the first non-zero element\n    return target_index\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    # Convert numpy array to list for easier manipulation (swapping)\n    seq = input_grid.tolist()\n    n = len(seq)\n\n    # Handle empty input\n    if n == 0:\n        return input_grid # Return original empty array\n\n    # 1. Identify all contiguous blocks of zeros\n    zero_blocks = find_zero_blocks(seq)\n\n    # 2. Handle case where there are no zeros\n    if not zero_blocks:\n        return input_grid # Return original array if no zeros\n\n    # 3. Find the longest block (select first one if tie)\n    selected_block = find_first_longest_block(zero_blocks)\n    block_start = selected_block['start']\n    block_end = selected_block['end']\n\n    # Create a mutable copy (already done by tolist())\n    output_seq = seq\n\n    # 4. Determine if the selected block is at the end of the sequence\n    is_at_end = (block_end == n - 1)\n\n    if is_at_end:\n        # 5. Block is at the end\n        # 5a. Find the index of the first non-zero element before the block\n        first_preceding_non_zero_idx = find_first_preceding_non_zero_index(output_seq, block_start)\n\n        # 5b. If found, swap it with the first zero of the block\n        if first_preceding_non_zero_idx != -1:\n            # Swap elements\n            output_seq[block_start], output_seq[first_preceding_non_zero_idx] = \\\n                output_seq[first_preceding_non_zero_idx], output_seq[block_start]\n        # 5c. If no preceding non-zero found, do nothing.\n\n    else:\n        # 6. Block is *not* at the end\n        # This implies block_end + 1 < n, so an element exists after the block.\n\n        # 6a. Identify the index of the element immediately following the block\n        following_idx = block_end + 1\n\n        # 6b & 6c. Swap the first zero of the block with the following element\n        output_seq[block_start], output_seq[following_idx] = \\\n            output_seq[following_idx], output_seq[block_start]\n\n    # 7. Convert the modified list back to a NumPy array\n    output_grid = np.array(output_seq, dtype=input_grid.dtype) # Preserve original dtype\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11620,
    "candidates_token_count": 1902,
    "total_token_count": 13522,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.55764,
  "retries": 1
}