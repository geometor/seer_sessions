{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies all contiguous groups of identical non-zero numbers in the input sequence (1D array or list).\nDetermines the maximum length among these groups.\nFinds the first group (from left to right, based on starting index) that has this maximum length.\nReplaces the numbers within this specific target group with the number 1 in a copy of the input sequence.\nAll other numbers in the sequence remain unchanged. Returns the modified sequence in the same format as the input (list or NumPy array).\n\"\"\"\n\ndef _find_groups(numbers):\n    \"\"\"\n    Identifies contiguous groups of identical non-zero numbers in a list of integers.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a group\n        and contains 'value', 'length', 'start_index', 'end_index'.\n        Returns an empty list if no non-zero groups are found.\n    \"\"\"\n    groups = []\n    # Return early if the input list is empty\n    if not numbers:\n        return groups\n\n    current_value = None\n    current_length = 0\n    start_index = -1\n\n    # Iterate through the list with index\n    for i, num in enumerate(numbers):\n        # Ensure we are working with standard Python integers\n        num_int = int(num)\n\n        if num_int != 0: # Process non-zero numbers\n            if num_int == current_value:\n                # Continue the current group\n                current_length += 1\n            else:\n                # If a previous non-zero group was being tracked, record it\n                if current_value is not None and current_value != 0:\n                    groups.append({\n                        'value': current_value,\n                        'length': current_length,\n                        'start_index': start_index,\n                        'end_index': i - 1\n                    })\n                # Start a new group\n                current_value = num_int\n                current_length = 1\n                start_index = i\n        else: # Process zero\n            # If a non-zero group was just ending, record it\n            if current_value is not None and current_value != 0:\n                groups.append({\n                    'value': current_value,\n                    'length': current_length,\n                    'start_index': start_index,\n                    'end_index': i - 1\n                })\n            # Reset tracking since we hit a zero\n            current_value = None\n            current_length = 0\n            start_index = -1\n\n    # After the loop, check if the sequence ended with a non-zero group\n    if current_value is not None and current_value != 0:\n        groups.append({\n            'value': current_value,\n            'length': current_length,\n            'start_index': start_index,\n            'end_index': len(numbers) - 1 # Group ends at the last index\n        })\n\n    return groups\n\ndef transform(input_grid):\n    # Store original type (list or ndarray) to return the same type\n    is_numpy = isinstance(input_grid, np.ndarray)\n    # Preserve original dtype if input is numpy array\n    original_dtype = input_grid.dtype if is_numpy else None\n\n    # Convert input to a standard Python list of integers for processing\n    input_numbers = [int(x) for x in input_grid]\n\n    # Find all contiguous groups of identical non-zero numbers\n    groups = _find_groups(input_numbers)\n\n    # If no non-zero groups are found, return a copy of the original input\n    if not groups:\n        if is_numpy:\n            # Return a numpy array copy\n            return np.array(input_numbers, dtype=original_dtype)\n        else:\n            # Return a list copy\n            return list(input_numbers)\n\n    # Determine the maximum length among all found groups\n    max_length = 0\n    for group in groups:\n        if group['length'] > max_length:\n            max_length = group['length']\n    # Alternative using max() and a generator expression:\n    # max_length = max(group['length'] for group in groups)\n\n    # Find the first group (minimum start index) that has the maximum length\n    target_group = None\n    for group in groups:\n        if group['length'] == max_length:\n            # Since groups are found left-to-right by _find_groups,\n            # the first one encountered with max_length is the target.\n            target_group = group\n            break\n\n    # Create a copy of the input list to serve as the output sequence\n    output_numbers = list(input_numbers)\n\n    # If a target group was identified (should always happen if groups is not empty)\n    if target_group:\n        start = target_group['start_index']\n        end = target_group['end_index']\n        # Iterate through the indices of the target group\n        for i in range(start, end + 1):\n            # Set the value in the output sequence to 1\n            output_numbers[i] = 1\n\n    # Convert the modified list back to the original input type and return it\n    if is_numpy:\n        return np.array(output_numbers, dtype=original_dtype)\n    else:\n        return output_numbers\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7223,
    "candidates_token_count": 3355,
    "total_token_count": 10578,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.274743,
  "retries": 1
}