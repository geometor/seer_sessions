{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence (list or NumPy array) of integers by:\n1. Identifying all contiguous blocks of non-zero numbers.\n2. Determining the maximum length among these blocks.\n3. Selecting the block with the maximum length. If multiple blocks share the maximum length, the one with the earliest starting index is chosen.\n4. Creating a copy of the input sequence.\n5. Modifying the copy by changing all numbers within the selected target block to 1.\n6. Returning the modified copy, preserving the original data type (list or NumPy array). Zeros and numbers in non-selected blocks remain unchanged. If no non-zero blocks are found, the original sequence is returned unchanged.\n\"\"\"\n\nimport numpy as np\n\n# Helper function to find non-zero blocks\ndef find_nonzero_blocks(int_list):\n    \"\"\"\n    Identifies contiguous blocks of non-zero numbers in a list or 1D array.\n\n    Args:\n        int_list: A list or 1D NumPy array of integers.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        with keys 'start', 'end', 'length'. Returns an empty list if\n        no non-zero numbers are found or the input is empty.\n    \"\"\"\n    blocks = []\n    if not len(int_list): # Handle empty input\n        return blocks\n        \n    in_block = False\n    start_index = -1\n    # Ensure processing as a list for consistent indexing and iteration\n    # Handle potential non-integer elements robustly\n    processed_list = []\n    for item in int_list:\n        try:\n            processed_list.append(int(item))\n        except (ValueError, TypeError):\n            processed_list.append(0) # Treat conversion errors as 0\n\n    list_len = len(processed_list)\n\n    for i, current_num in enumerate(processed_list):\n        if current_num != 0 and not in_block:\n            # Start of a new block\n            in_block = True\n            start_index = i\n        # Check for end of block condition: either a 0 is found, or it's the last element\n        if in_block and (current_num == 0 or i == list_len - 1):\n            # Determine the correct end index\n            end_index = i - 1 if current_num == 0 else i \n            # Ensure block is valid (start <= end) before appending\n            if start_index <= end_index:\n                 blocks.append({\n                    'start': start_index,\n                    'end': end_index,\n                    'length': end_index - start_index + 1\n                 })\n            # Reset block state ONLY if the current element is 0 \n            # (if it's the end of list, the loop terminates anyway)\n            if current_num == 0:\n                in_block = False \n                \n    return blocks\n\n# Helper function to select the target block\ndef find_target_block(blocks):\n    \"\"\"\n    Selects the target block based on maximum length, then earliest start index.\n\n    Args:\n        blocks: A list of block dictionaries (from find_nonzero_blocks).\n\n    Returns:\n        The dictionary representing the target block, or None if blocks is empty.\n    \"\"\"\n    if not blocks:\n        return None\n\n    # Find the maximum length using max() with a generator expression\n    try:\n        max_length = max(block['length'] for block in blocks)\n    except ValueError: # Should not happen if initial check passed, but good practice\n        return None\n\n    # Filter blocks with maximum length\n    max_length_blocks = [block for block in blocks if block['length'] == max_length]\n\n    # Find the block among the longest ones with the minimum start index\n    # Using min() with a key function is efficient\n    target_block = min(max_length_blocks, key=lambda x: x['start'])\n\n    return target_block\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input sequence.\n    \"\"\"\n    # Step 0: Determine input type and store original dtype if NumPy\n    is_numpy = isinstance(input_grid, np.ndarray)\n    original_dtype = input_grid.dtype if is_numpy else None\n\n    # Step 1: Create a mutable list copy to work with\n    if is_numpy:\n        # Convert NumPy array to list for modification\n        output_list = input_grid.tolist()\n    else:\n        # Ensure it's a list and make a copy to avoid modifying the original input\n        output_list = list(input_grid) \n\n    # Step 2: Identify all contiguous blocks of non-zero numbers in the input\n    blocks = find_nonzero_blocks(output_list) # Use the list copy\n\n    # Step 3: Find and Select the Target Block (longest, then earliest)\n    target_block = find_target_block(blocks)\n\n    # Step 4: Modify the output list based on the target block\n    # If a target block was found (i.e., there were non-zero blocks)\n    if target_block:\n        # Get the start and end indices of the target block\n        start = target_block['start']\n        end = target_block['end']\n        \n        # Iterate through the indices within the target block's range\n        for i in range(start, end + 1):\n            # Change the value at this position in the output list to 1\n            # Ensure index is within bounds (should be by logic, but safe check)\n            if 0 <= i < len(output_list):\n                 output_list[i] = 1\n    \n    # Step 5: Convert back to NumPy array if the original input was a NumPy array\n    if is_numpy:\n        # Use the original dtype for consistency\n        output_grid = np.array(output_list, dtype=original_dtype)\n    else:\n        # Otherwise, the modified list is the result\n        output_grid = output_list\n\n    # Step 6: Return the final transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11482,
    "candidates_token_count": 1629,
    "total_token_count": 13111,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.846406,
  "retries": 1
}