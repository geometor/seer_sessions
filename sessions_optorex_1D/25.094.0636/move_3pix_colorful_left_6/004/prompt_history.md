
## train_1

**input:**
```
0 0 0 0 2 8 9 2 9 8 0 0
```


**output:**
```
0 2 8 9 2 9 8 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 4 6 7 7 1 8 0 0 0
```


**output:**
```
4 6 7 7 1 8 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 5 5 5 0 0
```


**output:**
```
0 0 0 0 5 5 5 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 9 7 5 5 6 0 0 0
```


**output:**
```
0 9 7 5 5 6 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 9 0 0 0 0 0 0
```


**output:**
```
0 0 9 0 0 0 0 0 0 0 0 0
```


## train_6

**input:**
```
0 0 0 2 2 7 7 1 1 7 0 0
```


**output:**
```
2 2 7 7 1 1 7 0 0 0 0 0
```


## train_7

**input:**
```
0 0 0 0 7 8 7 4 8 6 1 8
```


**output:**
```
0 7 8 7 4 8 6 1 8 0 0 0
```

*   **Perception of Task Elements:**
    *   The input and output are both sequences of 12 single digits.
    *   The digits themselves are preserved; the transformation involves rearranging their positions.
    *   The core operation is identifying a specific segment within the input sequence and shifting it.
    *   The digit '0' acts as a background or filler element.
    *   The segment being moved consists of all digits between the first non-zero digit and the last non-zero digit (inclusive) in the input sequence.
    *   This identified segment is consistently shifted 3 positions to the left.
    *   Positions in the output sequence not occupied by the shifted segment are filled with '0'.

*   **YAML Facts:**
    
```yaml
    task_description: Shifting a segment of digits within a fixed-length sequence.
    objects:
      - name: input_sequence
        properties:
          - type: list_of_integers
          - length: 12
          - elements: digits 0-9
      - name: output_sequence
        properties:
          - type: list_of_integers
          - length: 12
          - elements: digits 0-9
      - name: non_zero_segment
        properties:
          - definition: Subsequence from the first non-zero digit to the last non-zero digit in the input sequence.
          - includes_internal_zeros: true
    actions:
      - name: identify_segment
        inputs: input_sequence
        outputs: start_index, end_index, segment_data
        description: Find the index of the first non-zero digit (start_index) and the last non-zero digit (end_index). Extract the subsequence between these indices.
      - name: calculate_new_position
        inputs: start_index
        outputs: new_start_index
        description: Subtract 3 from the start_index, ensuring the result is not less than 0. (new_start_index = max(0, start_index - 3))
      - name: construct_output
        inputs: segment_data, new_start_index, sequence_length (12)
        outputs: output_sequence
        description: Create a sequence of length 12 filled with zeros. Place the segment_data into this sequence starting at new_start_index.
    relationships:
      - type: transformation
        applies_to: input_sequence
        results_in: output_sequence
        rule: The output sequence is generated by identifying the non_zero_segment in the input, shifting it left by 3 positions (respecting boundary at index 0), and padding the remaining positions with zeros.
    constants:
      - name: shift_amount
        value: 3
      - name: direction
        value: left
      - name: sequence_length
        value: 12
      - name: padding_value
        value: 0

    ```


*   **Natural Language Program:**
    1.  Initialize an output sequence of 12 zeros.
    2.  Scan the input sequence to find the index of the first non-zero digit (`start_index`). If no non-zero digits exist, the output is the sequence of 12 zeros.
    3.  Scan the input sequence (or scan backwards from the end) to find the index of the last non-zero digit (`end_index`).
    4.  Extract the segment of the input sequence from `start_index` to `end_index` (inclusive). This segment includes any zeros between the first and last non-zero digits.
    5.  Calculate the target starting index for this segment in the output sequence by subtracting 3 from `start_index`. The target index cannot be less than 0, so use `max(0, start_index - 3)`.
    6.  Copy the extracted segment into the output sequence, starting at the calculated target index.
    7.  Return the modified output sequence.
```python
import math
import re # Using re for potentially simpler parsing if needed, though split() is likely sufficient

"""
Transforms a sequence of 12 digits based on the following rule:
1. Identify the subsequence (segment) starting from the first non-zero digit and ending at the last non-zero digit in the input sequence. This segment includes any zeros within it.
2. If no non-zero digits are found, the output is a sequence of 12 zeros.
3. Calculate the target starting index for this segment in the output sequence by subtracting 3 from the original starting index. Ensure the target index is not less than 0 (i.e., use max(0, original_start_index - 3)).
4. Construct the output sequence of length 12, initially filled with zeros.
5. Place the extracted segment into the output sequence starting at the calculated target index.
6. Return the resulting sequence.
"""

def transform(input_str: str) -> str:
    """
    Applies the described segment shifting transformation to the input string.

    Args:
        input_str: A string containing 12 space-separated digits.

    Returns:
        A string containing 12 space-separated digits representing the transformed sequence.
    """

    # Parse the input string into a list of integers
    input_digits = [int(d) for d in input_str.split()]
    n = len(input_digits) # should be 12 based on examples

    # 1. Find the index of the first non-zero digit (start_index)
    start_index = -1
    for i, digit in enumerate(input_digits):
        if digit != 0:
            start_index = i
            break

    # 2. Handle the case where all digits are zero
    if start_index == -1:
        # If no non-zero digits, return a string of 12 zeros
        return " ".join(['0'] * n)

    # 3. Find the index of the last non-zero digit (end_index)
    end_index = -1
    for i in range(n - 1, -1, -1): # Iterate backwards
        if input_digits[i] != 0:
            end_index = i
            break
    
    # This check should technically not be needed if start_index != -1, 
    # but added for robustness, though end_index will always be >= start_index here.
    # if end_index == -1: end_index = start_index 

    # 4. Extract the segment
    # Slicing goes up to, but does not include, the end value, so add 1 to end_index
    segment = input_digits[start_index : end_index + 1]

    # 5. Calculate the new starting position for the segment
    shift_amount = 3
    new_start_index = max(0, start_index - shift_amount)

    # 6. Construct the output sequence
    # Initialize output with zeros
    output_digits = [0] * n

    # Calculate where the segment ends in the output grid
    # Ensure the segment doesn't exceed the bounds of the output grid
    segment_len = len(segment)
    place_end_index = new_start_index + segment_len

    # Place the segment into the output list
    # The slicing handles the length automatically
    output_digits[new_start_index:place_end_index] = segment

    # 7. Format the output list back into a space-separated string
    output_str = " ".join(map(str, output_digits))

    return output_str

```
```python
import numpy as np

"""
Transforms a 1D NumPy array of 12 digits based on the following rule:
1. Identify the segment (sub-array) starting from the first non-zero element and ending at the last non-zero element in the input array. This segment includes any zeros within it.
2. If no non-zero elements are found, the output is a 1D NumPy array of 12 zeros.
3. Calculate the target starting index for this segment in the output array by subtracting 3 from the original starting index. Ensure the target index is not less than 0 (i.e., use max(0, original_start_index - 3)).
4. Construct the output array of length 12, initially filled with zeros.
5. Place the extracted segment into the output array starting at the calculated target index.
6. Return the resulting array.
"""

def find_segment_bounds(input_array: np.ndarray) -> tuple[int, int] | None:
    """Finds the start and end indices of the non-zero segment."""
    non_zero_indices = np.nonzero(input_array)[0]
    if len(non_zero_indices) == 0:
        return None # No non-zero elements found
    start_index = non_zero_indices[0]
    end_index = non_zero_indices[-1]
    return start_index, end_index

def calculate_new_start(start_index: int, shift_amount: int) -> int:
    """Calculates the new starting index after shifting left, clamped at 0."""
    return max(0, start_index - shift_amount)

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the segment shifting transformation to the input NumPy array.

    Args:
        input_grid: A 1D NumPy array of 12 integers.

    Returns:
        A 1D NumPy array of 12 integers representing the transformed sequence.
    """
    # Define constants
    shift_amount = 3
    array_length = len(input_grid) # Assuming consistent length, e.g., 12

    # 1. Find the indices of the first and last non-zero elements
    bounds = find_segment_bounds(input_grid)

    # 2. Handle the case where all elements are zero
    if bounds is None:
        return np.zeros(array_length, dtype=input_grid.dtype)

    start_index, end_index = bounds

    # 3. Extract the segment
    # Slicing goes up to, but does not include, the end value, so add 1 to end_index
    segment = input_grid[start_index : end_index + 1]
    segment_len = len(segment)

    # 4. Calculate the new starting position for the segment
    new_start_index = calculate_new_start(start_index, shift_amount)

    # 5. Construct the output array (initialize with zeros)
    output_grid = np.zeros(array_length, dtype=input_grid.dtype)

    # 6. Place the segment into the output array
    # Calculate the end index for placement, ensuring it doesn't exceed array bounds
    # This is implicitly handled by Python slicing assignment if the segment is too long,
    # but good practice to be aware.
    place_end_index = new_start_index + segment_len
    output_grid[new_start_index:place_end_index] = segment

    # 7. Return the resulting array
    return output_grid
```
