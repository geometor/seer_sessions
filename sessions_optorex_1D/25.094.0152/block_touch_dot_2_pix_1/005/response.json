{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n# import copy # Not strictly needed as np.copy() is used.\n\n\"\"\"\nTransforms an input sequence of integers (represented as a NumPy array) based on specific movement rules relative to the number '2'.\n\nThe transformation identifies the position of the number '2', which acts as a fixed pivot.\nNon-zero numbers located to the left of '2' are potentially shifted rightwards by two positions\nif the two positions immediately to their right (towards '2') are both zeros. This shifting\nprocess is repeated iteratively for the entire left side (from right-to-left within each pass)\nuntil no more such shifts are possible in a full pass.\nSimilarly, non-zero numbers located to the right of '2' are potentially shifted leftwards by\ntwo positions if the two positions immediately to their left (towards '2') are both zeros.\nThis shifting process is repeated iteratively for the entire right side (from left-to-right\nwithin each pass) until no more such shifts are possible in a full pass.\nNumbers immediately adjacent to '2' (at index idx2-1 or idx2+1) or separated by one zero\ndo not meet the shift conditions (i.e., the rule requires checking i+1, i+2 or i-1, i-2).\nThe pivot '2' itself never moves.\n\"\"\"\n\ndef find_pivot_index(sequence: np.ndarray, pivot_value: int = 2) -> int:\n    \"\"\"\n    Finds the index of the first occurrence of the pivot element in the sequence.\n\n    Args:\n        sequence: The input NumPy array.\n        pivot_value: The integer value to find (default is 2).\n\n    Returns:\n        The index of the first occurrence of the pivot value, or -1 if not found.\n    \"\"\"\n    indices = np.where(sequence == pivot_value)[0]\n    if len(indices) == 0:\n        # Handle case where pivot is not found.\n        # print(f\"Warning: Pivot element '{pivot_value}' not found.\") # Keep console clean\n        return -1 # Indicate not found\n    # Examples imply exactly one pivot, but if multiple exist, use the first one.\n    return indices[0]\n\ndef shift_elements(sequence: np.ndarray, start_index: int, end_index: int, direction: str) -> bool:\n    \"\"\"\n    Performs one pass of shifting elements either left or right based on the rules.\n    Modifies the sequence in place.\n\n    Args:\n        sequence: The NumPy array to modify.\n        start_index: The starting index for the pass (inclusive).\n        end_index: The ending index for the pass (inclusive).\n        direction: 'right' for shifting elements on the left side towards the pivot,\n                   'left' for shifting elements on the right side towards the pivot.\n\n    Returns:\n        True if any element was shifted during this pass, False otherwise.\n    \"\"\"\n    swapped_in_pass = False\n    n = len(sequence)\n    if direction == 'right': # Processing left side, shifting elements right\n        # Iterate right-to-left: checks elements further from pivot first in this pass\n        for i in range(end_index, start_index - 1, -1):\n            # Check boundary condition: i+2 must be a valid index within the array\n            if i + 2 < n:\n                # Check shift condition: non-zero at i, zeros at i+1, i+2\n                if sequence[i] != 0 and sequence[i+1] == 0 and sequence[i+2] == 0:\n                    # Perform swap using NumPy tuple assignment for swapping\n                    sequence[i], sequence[i+2] = sequence[i+2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    elif direction == 'left': # Processing right side, shifting elements left\n         # Iterate left-to-right: checks elements further from pivot first in this pass\n        for i in range(start_index, end_index + 1):\n             # Check boundary condition: i-2 must be a valid index within the array\n            if i - 2 >= 0:\n                # Check shift condition: non-zero at i, zeros at i-1, i-2\n                if sequence[i] != 0 and sequence[i-1] == 0 and sequence[i-2] == 0:\n                    # Perform swap using NumPy tuple assignment for swapping\n                    sequence[i], sequence[i-2] = sequence[i-2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    return swapped_in_pass\n\ndef transform(input_sequence: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the iterative shifting transformation to the input NumPy array.\n\n    Args:\n        input_sequence: A 1D NumPy array of integers.\n\n    Returns:\n        A new 1D NumPy array with elements shifted according to the rules.\n    \"\"\"\n    # Initialize output_sequence as a mutable copy of the input\n    output_sequence = input_sequence.copy()\n    n = len(output_sequence)\n\n    # Find the index of the pivot element '2'.\n    idx2 = find_pivot_index(output_sequence, 2)\n\n    # If pivot '2' is not found, return the original sequence copy as per rule assumption.\n    if idx2 == -1:\n        # print(\"Warning: Pivot element '2' not found. Returning original sequence.\") # Keep console clean\n        return output_sequence # Return the unmodified copy\n\n    # --- Process Left Side (Shift Rightwards towards '2') ---\n    # Repeat shifting passes until no more swaps occur on the left side.\n    while True:\n        # Define the range for potential starting positions 'i' on the left side pass.\n        # The rightmost element that could shift right is at idx2 - 3.\n        start_left = 0\n        end_left = idx2 - 3\n\n        # Only proceed if there are elements to check (range is valid)\n        if end_left >= start_left:\n             # Perform one pass of rightward shifts.\n             # The shift_elements function iterates right-to-left (end_left down to start_left).\n             # It modifies output_sequence in place.\n            swapped = shift_elements(output_sequence, start_left, end_left, 'right')\n            # If no elements were swapped in this pass, the left side has reached stability.\n            if not swapped:\n                break\n        else:\n             # No elements on the left side are far enough from '2' to potentially shift.\n             break\n\n\n    # --- Process Right Side (Shift Leftwards towards '2') ---\n    # Repeat shifting passes until no more swaps occur on the right side.\n    while True:\n        # Define the range for potential starting positions 'i' on the right side pass.\n        # The leftmost element that could shift left is at idx2 + 3.\n        start_right = idx2 + 3\n        end_right = n - 1\n\n        # Only proceed if there are elements to check (range is valid)\n        if start_right <= end_right:\n            # Perform one pass of leftward shifts.\n            # The shift_elements function iterates left-to-right (start_right up to end_right).\n            # It modifies output_sequence in place.\n            swapped = shift_elements(output_sequence, start_right, end_right, 'left')\n             # If no elements were swapped in this pass, the right side has reached stability.\n            if not swapped:\n                break\n        else:\n            # No elements on the right side are far enough from '2' to potentially shift.\n            break\n\n    # Return the modified sequence\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7207,
    "candidates_token_count": 4006,
    "total_token_count": 11213,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.300411,
  "retries": 1
}