{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input sequence of integers (represented as a NumPy array) based on specific movement rules relative to the number '2'.\n\nThe transformation identifies the position of the number '2', which acts as a fixed pivot.\nNon-zero numbers located to the left of '2' are potentially shifted rightwards by two positions\nif the two positions immediately to their right (towards '2') are both zeros. This shifting\nprocess is repeated iteratively for the entire left side (from right-to-left within each pass)\nuntil no more such shifts are possible in a full pass.\nSimilarly, non-zero numbers located to the right of '2' are potentially shifted leftwards by\ntwo positions if the two positions immediately to their left (towards '2') are both zeros.\nThis shifting process is repeated iteratively for the entire right side (from left-to-right\nwithin each pass) until no more such shifts are possible in a full pass.\nNumbers immediately adjacent to '2' (at index idx2-1 or idx2+1) or separated by one zero\ndo not meet the shift conditions (i.e., the rule requires checking i+1, i+2 or i-1, i-2).\nThe pivot '2' itself never moves.\n\"\"\"\n\n\ndef find_pivot_index(sequence: np.ndarray, pivot_value: int = 2) -> int:\n    \"\"\"\n    Finds the index of the first occurrence of the pivot element in the sequence.\n\n    Args:\n        sequence: The input NumPy array.\n        pivot_value: The integer value to find (default is 2).\n\n    Returns:\n        The index of the first occurrence of the pivot value, or -1 if not found.\n    \"\"\"\n    indices = np.where(sequence == pivot_value)[0]\n    if len(indices) == 0:\n        # Handle case where pivot is not found based on problem constraints/examples.\n        # If examples guarantee a pivot, this might indicate an unexpected input.\n        return -1 # Indicate not found\n    # Examples imply exactly one pivot; return the first one found.\n    return indices[0]\n\ndef shift_elements_left_side(sequence: np.ndarray, pivot_index: int) -> bool:\n    \"\"\"\n    Performs one pass of shifting elements on the left side towards the pivot '2'.\n    Modifies the sequence in place.\n\n    Args:\n        sequence: The NumPy array to modify.\n        pivot_index: The index of the pivot element '2'.\n\n    Returns:\n        True if any element was shifted during this pass, False otherwise.\n    \"\"\"\n    swapped_in_pass = False\n    n = len(sequence)\n    # Iterate right-to-left from pivot_index - 3 down to 0.\n    # This range ensures i+1 and i+2 are potentially valid indices before the pivot.\n    start_index = 0\n    end_index = pivot_index - 3\n    \n    # Only iterate if the range is valid (end_index >= start_index)\n    if end_index >= start_index:\n        for i in range(end_index, start_index - 1, -1):\n            # Check boundary: i+2 must be less than pivot_index to ensure we don't shift past the pivot.\n            # This check is inherently satisfied by the loop range, but explicit check is fine.\n            # Also check i >= 0 (guaranteed by range) and i+2 < n (array bounds).\n            if i + 2 < pivot_index: # Ensure destination is strictly before pivot\n                # Check shift condition: non-zero at i, zeros at i+1, i+2\n                if sequence[i] != 0 and sequence[i+1] == 0 and sequence[i+2] == 0:\n                    # Perform swap\n                    sequence[i], sequence[i+2] = sequence[i+2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    return swapped_in_pass\n\ndef shift_elements_right_side(sequence: np.ndarray, pivot_index: int) -> bool:\n    \"\"\"\n    Performs one pass of shifting elements on the right side towards the pivot '2'.\n    Modifies the sequence in place.\n\n    Args:\n        sequence: The NumPy array to modify.\n        pivot_index: The index of the pivot element '2'.\n\n    Returns:\n        True if any element was shifted during this pass, False otherwise.\n    \"\"\"\n    swapped_in_pass = False\n    n = len(sequence)\n    # Iterate left-to-right from pivot_index + 3 up to n - 1.\n    # This range ensures i-1 and i-2 are potentially valid indices after the pivot.\n    start_index = pivot_index + 3\n    end_index = n - 1\n    \n    # Only iterate if the range is valid (start_index <= end_index)\n    if start_index <= end_index:\n         # Iterate left-to-right: checks elements further from pivot first in this pass\n        for i in range(start_index, end_index + 1):\n             # Check boundary: i-2 must be greater than pivot_index to ensure we don't shift past the pivot.\n             # This check is inherently satisfied by the loop range, but explicit check is fine.\n             # Also check i < n (guaranteed by range) and i-2 >= 0 (array bounds).\n            if i - 2 > pivot_index: # Ensure destination is strictly after pivot\n                # Check shift condition: non-zero at i, zeros at i-1, i-2\n                if sequence[i] != 0 and sequence[i-1] == 0 and sequence[i-2] == 0:\n                    # Perform swap\n                    sequence[i], sequence[i-2] = sequence[i-2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    return swapped_in_pass\n\n\ndef transform(input_sequence: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the iterative shifting transformation to the input NumPy array.\n\n    Args:\n        input_sequence: A 1D NumPy array of integers.\n\n    Returns:\n        A new 1D NumPy array with elements shifted according to the rules.\n    \"\"\"\n    # Initialize output_sequence as a mutable copy of the input\n    # This ensures the original input_sequence is not modified.\n    output_sequence = input_sequence.copy()\n    n = len(output_sequence)\n\n    # 1. Identify Pivot: Find the index (`idx2`) of the number `2`.\n    idx2 = find_pivot_index(output_sequence, 2)\n\n    # If pivot '2' is not found, behavior based on examples is to return the original sequence.\n    if idx2 == -1:\n        # print(\"Warning: Pivot element '2' not found. Returning original sequence.\") # Optional warning\n        return output_sequence # Return the unmodified copy\n\n    # 3. Process Left Side (Elements before Pivot):\n    # Repeat shifting passes until no more swaps occur on the left side.\n    while True:\n        # Perform one pass of rightward shifts (towards the pivot).\n        # The helper function modifies output_sequence in place and returns if any swap happened.\n        swapped = shift_elements_left_side(output_sequence, idx2)\n        # If no elements were swapped in this pass, the left side has reached stability.\n        if not swapped:\n            break # Exit the while loop for the left side\n\n    # 4. Process Right Side (Elements after Pivot):\n    # Repeat shifting passes until no more swaps occur on the right side.\n    while True:\n        # Perform one pass of leftward shifts (towards the pivot).\n        # The helper function modifies output_sequence in place and returns if any swap happened.\n        swapped = shift_elements_right_side(output_sequence, idx2)\n         # If no elements were swapped in this pass, the right side has reached stability.\n        if not swapped:\n            break # Exit the while loop for the right side\n\n    # 5. Finalize: Return the modified sequence.\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12036,
    "candidates_token_count": 2317,
    "total_token_count": 14353,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.162101,
  "retries": 1
}