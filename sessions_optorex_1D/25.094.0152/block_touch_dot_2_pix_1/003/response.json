{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms an input sequence of integers based on specific movement rules relative to the number '2'.\n\nThe transformation identifies the position of the number '2', which acts as a fixed pivot.\nNon-zero numbers located to the left of '2' are potentially shifted rightwards by two positions\nif the two positions immediately to their right (towards '2') are both zeros. This shifting\nprocess is repeated iteratively for the entire left side (from right-to-left within each pass)\nuntil no more such shifts are possible in a full pass.\nSimilarly, non-zero numbers located to the right of '2' are potentially shifted leftwards by\ntwo positions if the two positions immediately to their left (towards '2') are both zeros.\nThis shifting process is repeated iteratively for the entire right side (from left-to-right\nwithin each pass) until no more such shifts are possible in a full pass.\nNumbers immediately adjacent to '2' (at index idx2-1 or idx2+1) do not shift via this rule,\nas the rule requires two intermediate zeros.\n\"\"\"\n\n\ndef find_pivot_index(sequence: list[int], pivot_value: int = 2) -> int:\n    \"\"\"Finds the index of the pivot element.\"\"\"\n    try:\n        return sequence.index(pivot_value)\n    except ValueError:\n        # Handle case where pivot is not found, though examples imply it always exists.\n        # Returning -1 or raising an error are options. For this task, we assume it exists.\n        return -1 # Indicate not found\n\ndef shift_elements(sequence: list[int], start_index: int, end_index: int, direction: str) -> bool:\n    \"\"\"\n    Performs one pass of shifting elements either left or right based on the rules.\n    Returns True if any element was shifted, False otherwise.\n    \"\"\"\n    swapped_in_pass = False\n    if direction == 'right': # Processing left side, shifting elements right\n        # Iterate right-to-left: check elements further from pivot first in this pass\n        for i in range(end_index, start_index - 1, -1):\n            # Check boundary condition (i+2 must be within sequence and before pivot)\n            # Note: The loop range already implicitly handles some bounds.\n            # Explicit check `i+2 < pivot_index` would be needed if pivot_index wasn't the boundary.\n            if i + 2 < len(sequence): # Ensure index i+2 is valid\n                # Check shift condition: non-zero at i, zeros at i+1, i+2\n                if sequence[i] != 0 and sequence[i+1] == 0 and sequence[i+2] == 0:\n                    # Perform swap\n                    sequence[i], sequence[i+2] = sequence[i+2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    elif direction == 'left': # Processing right side, shifting elements left\n         # Iterate left-to-right: check elements further from pivot first in this pass\n        for i in range(start_index, end_index + 1):\n             # Check boundary condition (i-2 must be within sequence and after pivot)\n             # Note: The loop range already implicitly handles some bounds.\n             # Explicit check `i-2 > pivot_index` would be needed if pivot_index wasn't the boundary.\n            if i - 2 >= 0: # Ensure index i-2 is valid\n                # Check shift condition: non-zero at i, zeros at i-1, i-2\n                if sequence[i] != 0 and sequence[i-1] == 0 and sequence[i-2] == 0:\n                    # Perform swap\n                    sequence[i], sequence[i-2] = sequence[i-2], sequence[i]\n                    swapped_in_pass = True # Mark that a swap occurred\n    return swapped_in_pass\n\ndef transform(input_sequence: list[int]) -> list[int]:\n    \"\"\"\n    Applies the shifting transformation to the input sequence.\n\n    Args:\n        input_sequence: A list of integers.\n\n    Returns:\n        A new list of integers with elements shifted according to the rules.\n    \"\"\"\n    # Create a mutable copy of the input sequence to work with\n    output_sequence = copy.deepcopy(input_sequence)\n    n = len(output_sequence)\n\n    # Find the index of the pivot element '2'.\n    idx2 = find_pivot_index(output_sequence, 2)\n\n    # Handle case where pivot '2' is not found. Return original sequence.\n    if idx2 == -1:\n        print(\"Warning: Pivot element '2' not found. Returning original sequence.\")\n        return output_sequence\n\n    # --- Process Left Side (Shift Rightwards towards '2') ---\n    # Repeat shifting passes as long as elements are being moved on the left side.\n    while True:\n        # Define the range for the left side pass: from index 0 up to idx2 - 3.\n        # We iterate from right-to-left within the shift_elements function.\n        start_left = 0\n        end_left = idx2 - 3 # The last index to check is idx2 - 3 for a rightward shift to idx2 - 1\n        \n        # Ensure valid range before calling shift_elements\n        if end_left >= start_left:\n             # Perform a pass of rightward shifts\n            swapped = shift_elements(output_sequence, start_left, end_left, 'right')\n            # If no elements were swapped in this pass, the left side is stable.\n            if not swapped:\n                break\n        else:\n             # No elements to process on the left side that meet the distance criteria\n             break\n\n\n    # --- Process Right Side (Shift Leftwards towards '2') ---\n    # Repeat shifting passes as long as elements are being moved on the right side.\n    while True:\n        # Define the range for the right side pass: from index idx2 + 3 up to n - 1.\n        # We iterate from left-to-right within the shift_elements function.\n        start_right = idx2 + 3 # The first index to check is idx2 + 3 for a leftward shift to idx2 + 1\n        end_right = n - 1\n\n        # Ensure valid range before calling shift_elements\n        if start_right <= end_right:\n            # Perform a pass of leftward shifts\n            swapped = shift_elements(output_sequence, start_right, end_right, 'left')\n             # If no elements were swapped in this pass, the right side is stable.\n            if not swapped:\n                break\n        else:\n            # No elements to process on the right side that meet the distance criteria\n            break\n\n\n    # Return the modified sequence\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5173,
    "candidates_token_count": 2065,
    "total_token_count": 7238,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.144623,
  "retries": 1
}