{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nShift a single contiguous block of non-zero, non-2 digits within a 1D sequence \nto be immediately adjacent to the unique digit '2', preserving the block's \ninternal order and the '2's position. If the block is already adjacent, or if \nno such block exists, or if '2' is not present, the sequence remains unchanged. \nAssumes at most one such block and at most one '2' exists per sequence.\n\"\"\"\n\ndef find_separator_index(grid: np.ndarray) -> int:\n    \"\"\"\n    Locates the index of the digit 2 (separator) in the input array.\n\n    Args:\n        grid: The 1D input NumPy array.\n\n    Returns:\n        The index of the first occurrence of 2, or -1 if not found.\n    \"\"\"\n    separator_indices = np.where(grid == 2)[0]\n    if len(separator_indices) > 0:\n        # Assuming only one '2' based on examples, take the first found\n        return separator_indices[0]\n    else:\n        return -1\n\ndef find_number_block(grid: np.ndarray):\n    \"\"\"\n    Finds the single contiguous block of digits that are not 0 and not 2.\n\n    Args:\n        grid: The 1D input NumPy array.\n\n    Returns:\n        A dictionary containing 'digits' (np.array), 'start' (int), 'end' (int), \n        and 'len' (int) of the block, or None if no such single contiguous \n        block is found.\n    \"\"\"\n    # Find indices of all potential block elements\n    candidate_indices = np.where((grid != 0) & (grid != 2))[0]\n\n    if len(candidate_indices) == 0:\n        return None # No block elements found\n\n    # Check for contiguity: difference between consecutive indices should be 1\n    if len(candidate_indices) == 1:\n        # A single element is always contiguous\n        is_contiguous = True\n    else:\n        is_contiguous = np.all(np.diff(candidate_indices) == 1)\n\n    if is_contiguous:\n        start_index = candidate_indices[0]\n        end_index = candidate_indices[-1]\n        block_digits = grid[start_index : end_index + 1]\n        return {\n            \"digits\": block_digits, # Return as numpy array\n            \"start\": start_index,\n            \"end\": end_index,\n            \"len\": len(block_digits)\n        }\n    else:\n        # Found non-zero/non-2 elements, but they don't form a single contiguous block.\n        return None\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input NumPy array.\n    \"\"\"\n    # Get the size of the input grid\n    n = input_grid.shape[0]\n\n    # Locate the index of the unique digit '2' (the separator).\n    separator_index = find_separator_index(input_grid)\n\n    # If '2' is not found, return the original sequence.\n    if separator_index == -1:\n        return input_grid.copy() \n\n    # Search the sequence for a single, contiguous block of digits that are neither '0' nor '2'.\n    block_info = find_number_block(input_grid)\n\n    # If no such block is found, return the original sequence.\n    if block_info is None:\n        return input_grid.copy()\n\n    # Determine block properties\n    block_start = block_info[\"start\"]\n    block_end = block_info[\"end\"]\n    block_digits = block_info[\"digits\"]\n    block_length = block_info[\"len\"]\n    \n    # Check if the block is already adjacent to the separator\n    is_adjacent_left = (block_end == separator_index - 1)\n    is_adjacent_right = (block_start == separator_index + 1)\n\n    # If the block *is* already adjacent, return the original sequence.\n    if is_adjacent_left or is_adjacent_right:\n        return input_grid.copy()\n\n    # If the block exists and is *not* adjacent, perform the shift.\n    \n    # Create a new output sequence of the same length as the input, filled with '0's.\n    output_grid = np.zeros_like(input_grid)\n\n    # Place the digit '2' into the output sequence at its original separator_index.\n    output_grid[separator_index] = 2\n\n    # Determine if the block was to the left or right of the separator.\n    if block_start < separator_index:\n        # Block was to the left, calculate target position so block ends at separator_index - 1.\n        target_end_index = separator_index - 1\n        target_start_index = target_end_index - block_length + 1\n    else: # block_start > separator_index \n        # Block was to the right, calculate target position so block starts at separator_index + 1.\n        target_start_index = separator_index + 1\n        target_end_index = target_start_index + block_length - 1\n\n    # Copy the block digits into the output sequence at the calculated target position.\n    # Basic boundary check included for robustness, although not expected based on examples.\n    if 0 <= target_start_index <= target_end_index < n: \n         output_grid[target_start_index : target_end_index + 1] = block_digits\n    else:\n         # In case of unexpected calculation error, fallback to returning input to avoid crash\n         print(f\"Warning: Calculated target indices [{target_start_index}, {target_end_index}] out of bounds for grid size {n}. Returning original grid.\")\n         return input_grid.copy() \n\n    # Return the newly constructed output sequence.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14615,
    "candidates_token_count": 1703,
    "total_token_count": 16318,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.445491,
  "retries": 1
}