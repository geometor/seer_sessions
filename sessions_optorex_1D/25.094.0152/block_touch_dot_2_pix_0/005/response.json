{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nShift a contiguous block of non-zero digits (excluding 2) within a 1D numerical \narray to be adjacent to the fixed digit 2, unless the block is already adjacent. \nThe digit 2 acts as a separator, and its position remains unchanged. Digits 0 \nfill the remaining space. If the block is initially to the left of 2, it moves \nrightward until its rightmost digit is immediately adjacent to the left of 2. \nIf the block is initially to the right of 2, it shifts leftward until its \nleftmost digit is immediately adjacent to the right of 2. If no such block \nexists, if 2 is not present, or if the block is already adjacent to 2, the \ninput array remains unchanged. Assumes at most one such contiguous block exists \nper input.\n\"\"\"\n\ndef find_separator_index(grid: np.ndarray) -> int:\n    \"\"\"\n    Locates the index of the digit 2 (separator) in the input array.\n\n    Args:\n        grid: The 1D input NumPy array.\n\n    Returns:\n        The index of the first occurrence of 2, or -1 if not found.\n    \"\"\"\n    separator_indices = np.where(grid == 2)[0]\n    if len(separator_indices) > 0:\n        # Assuming only one '2' based on examples, take the first found\n        return separator_indices[0]\n    else:\n        return -1\n\ndef find_number_block(grid: np.ndarray):\n    \"\"\"\n    Finds the single contiguous block of digits that are not 0 and not 2.\n\n    Args:\n        grid: The 1D input NumPy array.\n\n    Returns:\n        A dictionary containing 'digits' (list), 'start' (int), 'end' (int), \n        and 'len' (int) of the block, or None if no such single contiguous \n        block is found.\n    \"\"\"\n    # Find indices of all potential block elements\n    candidate_indices = np.where((grid != 0) & (grid != 2))[0]\n\n    if len(candidate_indices) == 0:\n        return None # No block elements found\n\n    # Check for contiguity: difference between consecutive indices should be 1\n    if len(candidate_indices) == 1:\n        # A single element is always contiguous\n        is_contiguous = True\n    else:\n        is_contiguous = np.all(np.diff(candidate_indices) == 1)\n\n    if is_contiguous:\n        start_index = candidate_indices[0]\n        end_index = candidate_indices[-1]\n        block_digits = grid[start_index : end_index + 1]\n        return {\n            \"digits\": block_digits.tolist(), # Return as list for easier slicing later\n            \"start\": start_index,\n            \"end\": end_index,\n            \"len\": len(block_digits)\n        }\n    else:\n        # Found non-zero/non-2 elements, but they don't form a single contiguous block.\n        # Based on problem description/examples, we assume this won't happen or \n        # means no valid block exists for the transformation rule.\n        return None\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input NumPy array.\n\n    Args:\n        input_grid: A 1D NumPy array of integers.\n\n    Returns:\n        A 1D NumPy array representing the transformed sequence.\n    \"\"\"\n    # Get the size of the input grid\n    n = input_grid.shape[0]\n\n    # 1. Find the index of the separator '2'.\n    separator_index = find_separator_index(input_grid)\n\n    # If separator '2' is not found, return the original grid.\n    if separator_index == -1:\n        return input_grid.copy() \n\n    # 2. Find the contiguous block of non-zero, non-2 digits.\n    block_info = find_number_block(input_grid)\n\n    # 3. If no such block exists, return the original grid.\n    if block_info is None:\n        return input_grid.copy()\n\n    # 4. Check if the block is already adjacent to the separator.\n    block_start = block_info[\"start\"]\n    block_end = block_info[\"end\"]\n    is_adjacent_left = (block_end == separator_index - 1)\n    is_adjacent_right = (block_start == separator_index + 1)\n\n    if is_adjacent_left or is_adjacent_right:\n        # Block is already in the correct position, return original grid.\n        return input_grid.copy()\n\n    # 5. If the block exists and is *not* adjacent, perform the shift.\n    \n    # 5a. Initialize the output grid with zeros.\n    output_grid = np.zeros_like(input_grid)\n\n    # 5b. Place the separator '2' in the output grid.\n    output_grid[separator_index] = 2\n\n    # 5c. Determine target position based on original relative position.\n    block_digits = np.array(block_info[\"digits\"]) # Convert back to numpy array for assignment\n    block_length = block_info[\"len\"]\n    \n    if block_start < separator_index:\n        # Block was to the left, move it right against the separator.\n        target_end_index = separator_index - 1\n        target_start_index = target_end_index - block_length + 1\n    else: # block_start > separator_index (cannot be equal due to find_number_block logic)\n        # Block was to the right, move it left against the separator.\n        target_start_index = separator_index + 1\n        target_end_index = target_start_index + block_length - 1\n\n    # 5d. Check for boundary issues (optional, assumes valid inputs based on problem)\n    # if target_start_index < 0 or target_end_index >= n:\n    #     # Handle error: block shift leads out of bounds.\n    #     # Based on examples, this shouldn't happen.\n    #     return input_grid.copy() # Or raise an error\n\n    # 5e. Copy the block digits to the target position in the output grid.\n    if 0 <= target_start_index <= target_end_index < n: # Basic boundary check\n         output_grid[target_start_index : target_end_index + 1] = block_digits\n    else:\n         # Handle unexpected boundary issue if necessary\n         print(f\"Warning: Calculated target indices [{target_start_index}, {target_end_index}] seem out of bounds for grid size {n}.\")\n         return input_grid.copy() # Fallback to input if calculation is wrong\n\n\n    # 6. Return the constructed output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12122,
    "candidates_token_count": 1956,
    "total_token_count": 14078,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.429369,
  "retries": 1
}