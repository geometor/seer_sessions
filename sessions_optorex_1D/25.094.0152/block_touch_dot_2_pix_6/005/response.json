{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Receive the input, expecting a NumPy array of 12 integers.\n2.  Convert the input NumPy array into a Python list (`input_list`).\n3.  Create an `output_list` of 12 zeros.\n4.  Find the index (`pivot_index`) of the integer `2` within the `input_list`. If `2` is not found, return the `input_list` as is (error condition).\n5.  Place the integer `2` at the `pivot_index` in the `output_list`.\n6.  Scan the `input_list` to locate the first contiguous block of non-zero integers, excluding the element at `pivot_index`. Record its starting index (`block_start`), ending index (`block_end`), and the sequence of values (`block_values`).\n7.  If no such data block is found, return the `output_list` (containing only the `2` and zeros).\n8.  Determine the relative position of the block to the `pivot_index`:\n    *   If `block_end < pivot_index`, the block is \"Left\". Calculate `gap = pivot_index - block_end - 1`.\n    *   If `block_start > pivot_index`, the block is \"Right\". Calculate `gap = block_start - pivot_index - 1`.\n    *   Otherwise (adjacent or overlapping), the `gap = 0`. Ensure gap is non-negative.\n9.  Calculate the `shift_amount`:\n    *   If `gap == 0`, `shift_amount = 0`.\n    *   If `gap == 1`, `shift_amount = 1`.\n    *   If `gap > 1`, `shift_amount = 2`.\n10. Calculate the `new_block_start` index for placing the block in the `output_list`:\n    *   If the block was \"Left\", `new_block_start = block_start + shift_amount`.\n    *   If the block was \"Right\", `new_block_start = block_start - shift_amount`.\n    *   If the block was \"Adjacent\" (`gap == 0`), `new_block_start = block_start`.\n11. Iterate through the `block_values`. For each value, determine its target index in the `output_list` (starting from `new_block_start` and incrementing). If the target index is valid (within bounds 0-11) and is *not* equal to `pivot_index`, place the value at that target index in the `output_list`.\n12. Return the completed `output_list`.\n\"\"\"\n\ndef find_pivot(sequence: List[int]) -> int:\n    \"\"\"Finds the index of the pivot element (2). Returns -1 if not found.\"\"\"\n    try:\n        return sequence.index(2)\n    except ValueError:\n        return -1 # Pivot not found\n\ndef find_data_block(sequence: List[int], pivot_index: int) -> Optional[Tuple[int, int, List[int]]]:\n    \"\"\"\n    Finds the first contiguous block of non-zero, non-pivot integers.\n    Returns (start_index, end_index, values) or None if no block found.\n    \"\"\"\n    block_start = -1\n    block_values = []\n    n = len(sequence)\n\n    for i, val in enumerate(sequence):\n        # Check if the current element qualifies as part of the data block\n        is_block_element = (val != 0 and i != pivot_index)\n\n        if is_block_element and block_start == -1:\n            # Start of a potential block\n            block_start = i\n            block_values.append(val)\n        elif is_block_element and block_start != -1:\n            # Continuing an existing block\n            block_values.append(val)\n        elif not is_block_element and block_start != -1:\n            # End of the block is detected (current element is 0 or pivot)\n            block_end = i - 1\n            return block_start, block_end, block_values\n\n    # Handle case where block runs to the very end of the sequence\n    if block_start != -1:\n        block_end = n - 1\n        return block_start, block_end, block_values\n\n    # No block was found\n    return None\n\n\ndef transform(input_grid) -> List[int]:\n    # Convert input NumPy array (or potentially other iterable) to a Python list\n    input_list = list(input_grid)\n    n = len(input_list)\n    \n    # Ensure expected length, though maybe not strictly necessary if logic is sound\n    if n != 12:\n        print(f\"Warning: Input sequence length is {n}, expected 12. Proceeding anyway.\")\n        \n    # Initialize the output list with zeros\n    output_list = [0] * n\n\n    # Find the pivot index ('2')\n    pivot_index = find_pivot(input_list)\n\n    # Handle case where pivot is missing (return original list)\n    if pivot_index == -1:\n        print(\"Warning: Pivot '2' not found.\")\n        return input_list # Return original list if pivot is missing\n\n    # Place the pivot in the output list; its position is fixed\n    output_list[pivot_index] = 2\n\n    # Find the data block (non-zero, non-pivot contiguous sequence)\n    block_data = find_data_block(input_list, pivot_index)\n\n    # If no data block exists, the output is just the pivot and zeros\n    if block_data is None:\n        return output_list\n\n    # Unpack block data\n    block_start, block_end, block_values = block_data\n\n    # Determine block position relative to pivot and calculate the gap (number of zeros between)\n    gap = 0\n    relative_position = \"Adjacent\" # Default if block touches pivot index range\n    if block_end < pivot_index:\n        relative_position = \"Left\"\n        gap = pivot_index - block_end - 1\n    elif block_start > pivot_index:\n        relative_position = \"Right\"\n        gap = block_start - pivot_index - 1\n\n    # Ensure gap is non-negative\n    gap = max(0, gap)\n\n    # Determine the shift amount based on the gap size\n    shift_amount = 0\n    if gap == 1:\n        shift_amount = 1\n    elif gap > 1:\n        shift_amount = 2\n    # else: shift_amount remains 0 for gap == 0\n\n    # Calculate the starting index for the block in the output list\n    new_block_start = block_start # Default to original position\n    if relative_position == \"Left\":\n        new_block_start += shift_amount\n    elif relative_position == \"Right\":\n        new_block_start -= shift_amount\n\n    # Place the shifted data block into the output list\n    current_output_idx = new_block_start\n    for val in block_values:\n        # Check if the target index is within bounds (0 to n-1)\n        if 0 <= current_output_idx < n:\n            # Crucially, only place the value if the target index is NOT the pivot's index\n            if current_output_idx != pivot_index:\n                output_list[current_output_idx] = val\n        # else: Value would be shifted out of bounds, so it's omitted (based on examples)\n\n        # Move to the next index for the next value in the block\n        current_output_idx += 1\n\n    # Return the final transformed list\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9693,
    "candidates_token_count": 2166,
    "total_token_count": 11859,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.469162,
  "retries": 1
}