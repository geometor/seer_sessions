{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence of 12 integers based on the following rules:\n1. Identify the single non-zero 'target digit' present in the input. If only zeros exist, return a sequence of 12 zeros.\n2. Locate the two separate, contiguous blocks of this target digit. Let the first occurring block be Block1 and the second be Block2.\n3. Compare the lengths of Block1 and Block2.\n4. If Block1 is strictly longer than Block2, the output starts with Block2, followed by a single 0, then Block1.\n5. Otherwise (if Block1 is shorter or equal in length to Block2), the output starts with Block1, followed by a single 0, then Block2.\n6. Pad the resulting sequence with trailing zeros to ensure the final output sequence has a length of 12.\n\"\"\"\n\nimport re\nimport numpy as np # Import numpy for potential input type handling\n\ndef find_target_digit(nums: list) -> int:\n    \"\"\"Finds the first non-zero digit in the list.\"\"\"\n    for num in nums:\n        if num != 0:\n            return num\n    return 0 # Return 0 if all elements are zero\n\ndef find_digit_blocks(nums: list, target_digit: int) -> tuple[list, list]:\n    \"\"\"\n    Finds the two contiguous blocks of the target_digit in the list using regex.\n    Returns two lists representing the blocks (or empty lists if not found).\n    \"\"\"\n    if target_digit == 0:\n        return [], []\n    \n    # Convert the list to a string representation for regex matching\n    text_repr = \"\".join(map(str, nums))\n    # Create a pattern to find consecutive occurrences of the target digit\n    pattern = f\"({target_digit}+)\" \n    \n    blocks_as_lists = []\n    # Find all non-overlapping matches\n    matches = re.finditer(pattern, text_repr)\n    \n    for match in matches:\n        # Convert the matched string back to a list of integers\n        block_str = match.group(1)\n        blocks_as_lists.append([int(digit) for digit in block_str])\n        \n    # Expecting exactly two blocks based on the problem description\n    if len(blocks_as_lists) == 2:\n        return blocks_as_lists[0], blocks_as_lists[1]\n    elif len(blocks_as_lists) == 1:\n         # If only one block, return it as the first block and an empty second block\n        return blocks_as_lists[0], [] \n    else:\n        # If zero or more than two blocks found, return empty lists (signals an issue or edge case)\n        return [], [] \n\ndef transform(input_sequence) -> list:\n    \"\"\"\n    Applies the transformation rule to the input sequence.\n    \n    Args:\n        input_sequence: A list or numpy array of 12 integers.\n\n    Returns:\n        A list representing the transformed 12 integers.\n    \"\"\"\n    # Define the target output size\n    output_size = 12\n\n    # --- Step 0: Ensure input is a list ---\n    if isinstance(input_sequence, np.ndarray):\n        # If input is a numpy array, convert it to a list\n        # Flatten in case it's misinterpreted as 2D (e.g., shape (1, 12))\n        input_nums = input_sequence.flatten().tolist() \n    else:\n        # Assume it's already list-like (e.g., list, tuple) and convert to list\n        input_nums = list(input_sequence) \n        \n    # Basic validation for input length\n    if len(input_nums) != output_size:\n        # Handle error or return default if input size is wrong\n        # For now, returning zeros, but an error might be better\n        # print(f\"Warning: Input sequence length is {len(input_nums)}, expected {output_size}.\")\n        return [0] * output_size \n\n    # --- Step 1: Identify the Target Digit ---\n    target = find_target_digit(input_nums)\n\n    # --- Handle All-Zeros Case ---\n    if target == 0:\n        # If the target digit is 0, the input was all zeros\n        return [0] * output_size\n\n    # --- Step 2: Locate Block1 and Block2 ---\n    block1, block2 = find_digit_blocks(input_nums, target)\n    \n    # Check if exactly two blocks were found as expected from examples\n    # If not, the input format deviates; return zeros or handle error\n    # Based on find_digit_blocks logic, if not 2 blocks, it returns [],[] or [block1],[]\n    # The padding logic below will handle these cases by padding mostly zeros.\n\n    # --- Step 3 & 4: Compare Lengths and Rearrange ---\n    output_prefix = []\n    if len(block1) > len(block2):\n        # If B1 is strictly longer, the order is B2, 0, B1\n        output_prefix.extend(block2)\n        output_prefix.append(0)\n        output_prefix.extend(block1)\n    else:\n        # Otherwise (B1 is shorter or equal), the order is B1, 0, B2\n        output_prefix.extend(block1)\n        output_prefix.append(0)\n        output_prefix.extend(block2)\n\n    # --- Step 5: Pad with Zeros ---\n    # Create the final output list starting with the rearranged prefix\n    output_nums = output_prefix[:] # Make a copy\n\n    # Calculate how many zeros are needed for padding\n    padding_needed = output_size - len(output_nums)\n    \n    if padding_needed > 0:\n        # Append the required number of zeros\n        output_nums.extend([0] * padding_needed)\n    elif padding_needed < 0:\n        # If the combined blocks + zero exceeded the output size (should not happen with valid inputs)\n        # Truncate the list to the correct size\n        output_nums = output_nums[:output_size]\n\n    # --- Step 6: Return the Result ---\n    return output_nums\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11038,
    "candidates_token_count": 1436,
    "total_token_count": 12474,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.883776,
  "retries": 1
}