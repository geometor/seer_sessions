{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid (2D NumPy array, typically 1xN) based on the following rules:\n1. Extracts the first row as the data sequence.\n2. Identifies the contiguous sub-sequence in the data sequence starting from the \n   index of the first non-zero digit and ending at the index of the last \n   non-zero digit (the \"active segment\").\n3. If no non-zero digits exist in the data sequence, the output grid is \n   identical to the input grid.\n4. Determines the digit that appears most frequently within the original \n   active segment (the \"dominant digit\").\n5. Constructs a new 1D sequence by:\n   a. Taking the elements from the original data sequence before the active segment.\n   b. Appending the dominant digit, repeated for the length of the active segment.\n   c. Appending the elements from the original data sequence after the active segment.\n6. Formats this new 1D sequence into a 2D NumPy array with the same shape as the \n   original input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef _find_active_segment_indices(sequence):\n    \"\"\"\n    Finds the start and end indices of the first and last non-zero elements \n    in a 1D sequence (list or 1D numpy array).\n    Returns (None, None) if no non-zero elements are found.\n    \"\"\"\n    # Convert to list for consistent indexing and iteration\n    sequence_list = list(sequence) \n    non_zero_indices = [i for i, x in enumerate(sequence_list) if x != 0]\n    if not non_zero_indices:\n        return None, None\n    return non_zero_indices[0], non_zero_indices[-1]\n\ndef _find_dominant_digit(segment):\n    \"\"\"\n    Finds the most frequent digit in a given segment (list or sequence of digits).\n    If there's a tie, Counter.most_common(1) returns one of the most frequent.\n    Returns None if the segment is empty.\n    \"\"\"\n    if not segment:\n        return None \n    counts = Counter(segment)\n    # most_common(1) returns a list like [(element, count)], so access [0][0]\n    dominant_digit, _ = counts.most_common(1)[0]\n    return dominant_digit\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid (2D NumPy array).\n    \"\"\"\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        # This case might occur if the testing framework deviates\n        # or for robustness. Assume list of lists if not ndarray.\n        input_grid = np.array(input_grid)\n\n    # Handle empty input grid edge case\n    if input_grid.size == 0:\n        return input_grid.copy() # Return an empty array of the same shape\n\n    # 1. Extract the first row as the data sequence (assuming 1xN or MxN where we process row 0)\n    # Use .tolist() for easier slicing and processing with helper functions\n    data_sequence = input_grid[0].tolist() \n\n    # 2. Identify the active segment indices\n    start_index, end_index = _find_active_segment_indices(data_sequence)\n\n    # 3. Handle the case where there are no non-zero digits\n    if start_index is None:\n        # Return a copy of the original grid\n        return input_grid.copy() \n\n    # 4. Extract the original active segment using the found indices\n    # Slicing is end-exclusive, so add 1 to end_index\n    active_segment = data_sequence[start_index : end_index + 1]\n\n    # 5. Find the dominant digit in the original active segment\n    dominant_digit = _find_dominant_digit(active_segment)\n    \n    # If dominant_digit is None (e.g., empty active_segment, though unlikely here), handle defensively\n    if dominant_digit is None:\n         # This shouldn't happen if start_index is not None, but good practice\n         return input_grid.copy() \n\n    # 6. Construct the output sequence (as a list first)\n    #    a. Get the part before the active segment\n    prefix = data_sequence[:start_index]\n    \n    #    b. Create the new middle part with the dominant digit\n    segment_length = end_index - start_index + 1\n    middle = [dominant_digit] * segment_length\n    \n    #    c. Get the part after the active segment\n    suffix = data_sequence[end_index + 1:]\n\n    # Combine the parts into the new 1D sequence\n    output_sequence_list = prefix + middle + suffix\n\n    # 7. Format the output sequence back into a 2D NumPy array matching the input shape\n    # Convert the list back to a numpy array, preserving original dtype if possible\n    output_row_np = np.array(output_sequence_list, dtype=input_grid.dtype)\n    \n    # Create the output grid, assuming the transformation only affects the first row\n    # If input has more rows, copy them; otherwise, just reshape the modified row.\n    # A safer assumption based on examples is that input is always (1, N)\n    output_grid = np.copy(input_grid) # Start with a copy\n    output_grid[0] = output_row_np # Replace the first row\n\n    # Alternatively, if strictly 1xN input is guaranteed:\n    # output_grid = output_row_np.reshape(input_grid.shape) \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6880,
    "candidates_token_count": 1318,
    "total_token_count": 8198,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.56134,
  "retries": 1
}