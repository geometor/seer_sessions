{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport numpy as np\nimport math # Available, but not used\n\n\"\"\"\nTransforms an input grid (typically a single row representing a sequence of digits) \nby identifying contiguous subsequences (islands) of non-zero digits. Within each \nisland, it finds the most frequently occurring digit (the dominant digit). All \ndigits within that island are then replaced by this dominant digit in the output \nsequence. Zero digits act as separators between islands and remain unchanged. \nThe output grid retains the format of the input grid (list-of-lists or NumPy array).\n\"\"\"\n\ndef _find_dominant_digit(island_digits):\n  \"\"\"\n  Helper function to find the most frequent digit in a list of non-zero digits.\n  If there's a tie, collections.Counter.most_common(1) returns one of the most common.\n  \n  Args:\n    island_digits: A list of integers representing the digits in an island.\n\n  Returns:\n    The integer digit that appears most frequently in the list. Returns None if \n    the list is empty.\n  \"\"\"\n  if not island_digits:\n    return None \n  # Count occurrences of each digit\n  counts = collections.Counter(island_digits)\n  # Find the digit with the highest count. most_common(1) returns list like [(digit, count)]\n  dominant_digit = counts.most_common(1)[0][0]\n  return dominant_digit\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the island dominance transformation to the sequence within the input grid.\n\n    Args:\n      input_grid: A NumPy array or list of lists representing the input grid. \n                  Expected to contain a single row for this task's examples.\n\n    Returns:\n      A NumPy array or list of lists (matching input type) with the transformed sequence.\n    \"\"\"\n\n    # 1. Handle input format and extract the 1D sequence\n    is_numpy = isinstance(input_grid, np.ndarray)\n    if is_numpy:\n        # Assuming the relevant data is in the first row if it's 2D, \n        # or it's already 1D. Using .tolist() for easier processing.\n        if input_grid.ndim > 1:\n            input_sequence = input_grid[0].tolist()\n        else:\n             input_sequence = input_grid.tolist()\n    elif isinstance(input_grid, list) and input_grid and isinstance(input_grid[0], list):\n         # Assumes list-of-lists format, take the first list\n         input_sequence = list(input_grid[0]) # Ensure it's a mutable list copy\n    elif isinstance(input_grid, list) and all(isinstance(item, int) for item in input_grid):\n         # Handle case where input might be a flat list directly\n         input_sequence = list(input_grid)\n         # We'll need to decide output format later, maybe default to list-of-list? \n         # For consistency with ARC, let's assume the test harness expects list-of-lists or numpy.\n         # If input was flat list, maybe return flat list? Let's stick to list-of-lists for now\n         # based on typical ARC outputs. We can adjust if tests fail.\n         # Let's track if the input was *originally* flat\n         was_flat_list = True \n    else:\n        # Handle unexpected formats or empty input\n        # Returning input as-is or raising error might be options.\n        # For now, let's try returning input if format is unknown.\n        return input_grid \n\n    n = len(input_sequence)\n    # 2. Create a mutable copy for the output sequence\n    output_sequence = list(input_sequence) \n    \n    was_flat_list = not (is_numpy or (isinstance(input_grid, list) and input_grid and isinstance(input_grid[0], list)))\n\n\n    # 3. Iterate through the sequence to identify islands and apply transformations\n    i = 0\n    while i < n:\n        # 3a. Check if the current digit is non-zero (start of a potential island)\n        if input_sequence[i] != 0:\n            start_index = i\n            current_island_digits = []\n            \n            # 3b. Find the extent of the current island (scan consecutive non-zeros)\n            while i < n and input_sequence[i] != 0:\n                current_island_digits.append(input_sequence[i])\n                i += 1\n            # Loop ends when a zero is hit or end of sequence. Last non-zero was at i-1.\n            end_index = i - 1 # Inclusive index of the island's end\n\n            # 3c. Determine the dominant digit for this island\n            dominant_digit = _find_dominant_digit(current_island_digits)\n\n            # 3d. Replace digits in the output sequence for this island's range\n            if dominant_digit is not None: # Check if island was not empty\n                for j in range(start_index, end_index + 1):\n                    output_sequence[j] = dominant_digit\n            # 'i' is already positioned at the element *after* the island, loop continues correctly.\n        \n        # 3e. If the current digit is zero, it's a separator. It's already correct in the output copy. Move on.\n        else:\n            i += 1\n\n    # 4. Format the output sequence back into the original input structure\n    if is_numpy:\n        # Reshape based on original input dimensions if possible\n        # Since examples are 1xN, reshape to (1, N) or return 1D if input was 1D\n        if input_grid.ndim > 1:\n             output_grid = np.array([output_sequence], dtype=input_grid.dtype)\n        else: # Input was 1D numpy array\n             output_grid = np.array(output_sequence, dtype=input_grid.dtype)\n    elif was_flat_list:\n         # If input was a flat list, return a flat list\n         output_grid = output_sequence\n    else: # Assumed list-of-lists input\n        output_grid = [output_sequence]\n        \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8313,
    "candidates_token_count": 1451,
    "total_token_count": 9764,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.218676,
  "retries": 1
}