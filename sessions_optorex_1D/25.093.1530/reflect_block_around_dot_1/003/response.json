{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nSwaps the relative position of a target block of identical non-zero numbers \n(not equal to 2) with respect to a fixed pivot element '2', preserving the \nnumber of zeros (gap) between them. The pivot '2' remains in its original position.\nThe input and output are lists of integers.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_pivot(grid: List[int]) -> Optional[Tuple[int, int]]:\n    \"\"\"Finds the index and value of the pivot element (2).\"\"\"\n    for i, val in enumerate(grid):\n        if val == 2:\n            return i, val\n    return None # Should not happen based on examples\n\ndef find_target_block(grid: List[int], pivot_value: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the target block (contiguous identical non-zero, non-pivot numbers).\n    Returns: (value, start_index, end_index, length) or None if not found.\n    \"\"\"\n    block_val = -1\n    block_start = -1\n    block_end = -1\n    n = len(grid)\n\n    i = 0\n    while i < n:\n        val = grid[i]\n        # Look for the start of a potential block\n        if val != 0 and val != pivot_value:\n            block_val = val\n            block_start = i\n            block_end = i\n            # Look for contiguous identical elements\n            j = i + 1\n            while j < n and grid[j] == block_val:\n                block_end = j\n                j += 1\n            # Found a complete block\n            return block_val, block_start, block_end, (block_end - block_start + 1)\n        i += 1 # Move to the next element if not start of target block\n    return None # Should not happen based on examples\n\ndef calculate_gap(grid: List[int], block_start: int, block_end: int, pivot_index: int) -> int:\n    \"\"\"Calculates the number of zeros strictly between the block and the pivot.\"\"\"\n    gap = 0\n    if block_end < pivot_index: # Block is to the left\n        start = block_end + 1\n        end = pivot_index\n    elif block_start > pivot_index: # Block is to the right\n        start = pivot_index + 1\n        end = block_start\n    else: # Should not happen if block and pivot are distinct and non-overlapping\n        return 0 # Or raise error\n\n    # Iterate through the indices *between* the block and pivot\n    for i in range(start, end):\n        if grid[i] == 0:\n            gap += 1\n    return gap\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: List[int]) -> List[int]:\n    \"\"\"\n    Applies the transformation rule to the input grid list.\n\n    Args:\n        input_grid: A list of integers representing the input sequence.\n\n    Returns:\n        A list of integers representing the transformed sequence.\n    \"\"\"\n    n = len(input_grid)\n\n    # Initialize output grid with zeros\n    output_grid = [0] * n\n\n    # 1. Find the pivot element (2)\n    pivot_info = find_pivot(input_grid)\n    if not pivot_info:\n        # Handle error: Pivot not found (though examples imply it always exists)\n        print(\"Error: Pivot '2' not found in input.\")\n        return output_grid # Return empty grid or raise an error\n    pivot_index, pivot_value = pivot_info\n\n    # 2. Place the pivot in the output grid at its original index\n    output_grid[pivot_index] = pivot_value\n\n    # 3. Find the target block\n    block_info = find_target_block(input_grid, pivot_value)\n    if not block_info:\n        # Handle error: Target block not found\n        print(\"Error: Target block not found in input.\")\n        return output_grid # Return grid with only pivot or raise an error\n    block_val, block_start, block_end, block_len = block_info\n\n    # 4. Determine relative position (left/right) of the block w.r.t. the pivot\n    is_block_left = block_end < pivot_index\n\n    # 5. Calculate the gap (number of zeros) between the block and the pivot\n    gap = calculate_gap(input_grid, block_start, block_end, pivot_index)\n\n    # 6. Calculate the new starting position for the target block in the output grid\n    new_block_start = -1\n    if is_block_left:\n        # Block was left, move it to the right of the pivot\n        # New start = pivot_index + 1 (immediately after pivot) + gap (zeros)\n        new_block_start = pivot_index + 1 + gap\n    else: # Block was right, move it to the left of the pivot\n        # New end = pivot_index - 1 (immediately before pivot) - gap (zeros)\n        new_block_end = pivot_index - 1 - gap\n        # New start = new_end - length + 1\n        new_block_start = new_block_end - block_len + 1\n\n    # 7. Place the target block into the output grid at the calculated position\n    # Add boundary checks to prevent index errors\n    if 0 <= new_block_start < n and 0 <= new_block_start + block_len - 1 < n:\n        for i in range(block_len):\n            output_grid[new_block_start + i] = block_val\n    else:\n         # Handle error: Calculated position is out of bounds\n         print(f\"Warning: Calculated block position ({new_block_start} to {new_block_start + block_len - 1}) is out of bounds for grid size {n}.\")\n         # Depending on requirements, could raise error or return partially filled grid.\n\n    # Return the final transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5074,
    "candidates_token_count": 1427,
    "total_token_count": 6501,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.804052,
  "retries": 1
}