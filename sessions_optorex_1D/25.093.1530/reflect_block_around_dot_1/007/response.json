{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence by swapping the relative position of a 'target block' \n(a contiguous sequence of identical non-zero numbers, not equal to 2) with \nrespect to a fixed 'pivot' element (2). The transformation preserves the \npivot's absolute position and the number of zeros ('gap') between the pivot \nand the block. The input and output are lists of integers.\n\"\"\"\n\nfrom typing import List, Tuple, Optional\n\n# === Helper Functions ===\n\ndef find_pivot(grid: List[int]) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the index and value of the pivot element (2).\n\n    Args:\n        grid: The input list of integers.\n\n    Returns:\n        A tuple (index, value) of the pivot, or None if not found.\n    \"\"\"\n    for i, val in enumerate(grid):\n        if val == 2:\n            return i, val\n    return None # Pivot should always exist based on examples\n\ndef find_target_block(grid: List[int], pivot_value: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the target block (contiguous identical non-zero, non-pivot numbers).\n\n    Args:\n        grid: The input list of integers.\n        pivot_value: The value of the pivot element (to exclude it).\n\n    Returns:\n        A tuple (value, start_index, end_index, length) of the block,\n        or None if not found.\n    \"\"\"\n    block_val = -1\n    block_start = -1\n    block_end = -1\n    n = len(grid)\n\n    i = 0\n    while i < n:\n        val = grid[i]\n        # Look for the start of a potential block (non-zero, non-pivot)\n        if val != 0 and val != pivot_value:\n            block_val = val\n            block_start = i\n            block_end = i\n            # Look for contiguous identical elements forming the block\n            j = i + 1\n            while j < n and grid[j] == block_val:\n                block_end = j\n                j += 1\n            # Found the complete block\n            block_len = block_end - block_start + 1\n            return block_val, block_start, block_end, block_len\n        i += 1 # Move to the next element if not the start of the target block\n    return None # Target block should always exist based on examples\n\ndef calculate_gap(grid: List[int], block_start: int, block_end: int, pivot_index: int) -> int:\n    \"\"\"\n    Calculates the number of zeros strictly between the block and the pivot.\n\n    Args:\n        grid: The input list of integers.\n        block_start: The starting index of the target block.\n        block_end: The ending index of the target block.\n        pivot_index: The index of the pivot element.\n\n    Returns:\n        The count of zeros between the block and pivot.\n    \"\"\"\n    gap = 0\n    if block_end < pivot_index: # Block is to the left of the pivot\n        # Define the range between the block and pivot\n        start_range = block_end + 1\n        end_range = pivot_index\n    elif block_start > pivot_index: # Block is to the right of the pivot\n        # Define the range between the pivot and block\n        start_range = pivot_index + 1\n        end_range = block_start\n    else: # Should not happen if block and pivot are distinct and non-overlapping\n        print(\"Warning: Pivot and block might be overlapping or adjacent.\")\n        return 0 # No gap if adjacent or overlapping\n\n    # Count zeros within the defined range\n    for i in range(start_range, end_range):\n        if grid[i] == 0:\n            gap += 1\n    return gap\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: List[int]) -> List[int]:\n    \"\"\"\n    Applies the transformation rule to the input grid list.\n    \"\"\"\n    n = len(input_grid)\n    # Initialize output_grid with zeros, same length as input\n    output_grid = [0] * n\n\n    # Step 1: Find the pivot element (2) and its index\n    pivot_info = find_pivot(input_grid)\n    if not pivot_info:\n        print(f\"Error: Pivot '2' not found in input: {input_grid}\")\n        # Return an empty or unmodified grid based on error handling strategy\n        return output_grid \n    pivot_index, pivot_value = pivot_info\n\n    # Step 2: Place the pivot in the output grid at its original index\n    if 0 <= pivot_index < n:\n        output_grid[pivot_index] = pivot_value\n    else:\n        print(f\"Error: Pivot index {pivot_index} out of bounds for grid size {n}.\")\n        return output_grid # Cannot proceed without valid pivot position\n\n    # Step 3: Find the target block (value, start/end indices, length)\n    block_info = find_target_block(input_grid, pivot_value)\n    if not block_info:\n        print(f\"Error: Target block not found in input: {input_grid}\")\n        # Return grid with only pivot placed or handle error\n        return output_grid\n    block_val, block_start, block_end, block_len = block_info\n\n    # Step 4: Determine the initial relative position (left/right) of the block w.r.t. the pivot\n    is_block_left = block_end < pivot_index\n\n    # Step 5: Calculate the gap (number of zeros) between the block and the pivot in the input\n    gap = calculate_gap(input_grid, block_start, block_end, pivot_index)\n\n    # Step 6: Calculate the new starting position for the target block in the output grid\n    new_block_start = -1\n    if is_block_left:\n        # Block was originally left, move it to the right of the pivot\n        # New position starts after pivot + gap\n        new_block_start = pivot_index + 1 + gap\n    else: # Block was originally right, move it to the left of the pivot\n        # Calculate the new ending position first (before pivot - gap)\n        new_block_end = pivot_index - 1 - gap\n        # Calculate the new starting position based on the new end and length\n        new_block_start = new_block_end - block_len + 1\n\n    # Step 7: Place the target block into the output grid at the calculated new position\n    # Check if the calculated indices are valid before writing\n    new_block_end_calculated = new_block_start + block_len - 1\n    if 0 <= new_block_start < n and 0 <= new_block_end_calculated < n:\n        for i in range(block_len):\n            output_grid[new_block_start + i] = block_val\n    else:\n         # Handle cases where the new position might be out of bounds\n         print(f\"Warning: Calculated block position ({new_block_start} to {new_block_end_calculated}) is out of bounds for grid size {n}. Input: {input_grid}. Pivot:{pivot_index}, Gap:{gap}, BlockLen:{block_len}\")\n         # Depending on requirements, might raise error or return partially filled grid.\n         # For robustness, we continue and return the partially filled grid.\n\n    # Step 8: Return the final transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10156,
    "candidates_token_count": 1764,
    "total_token_count": 11920,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.620109,
  "retries": 1
}