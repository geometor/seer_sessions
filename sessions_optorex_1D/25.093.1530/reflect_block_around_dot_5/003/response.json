{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms an input sequence of integers based on the following rules:\n1.  Locate the index of the fixed pivot element '2'.\n2.  Identify the *first* contiguous block of identical non-zero numbers (excluding the pivot), known as the 'payload'.\n3.  Create an output sequence of the same length, initialized with zeros.\n4.  Place the pivot '2' in the output sequence at its original index.\n5.  Determine the payload's new location based on its original position relative to the pivot:\n    a.  If the payload was originally *before* the pivot, count the zeros strictly between the payload's end and the pivot's start in the input. The payload is moved to the output starting at index: pivot_index + 1 + count_of_intermediate_zeros.\n    b.  If the payload was originally *after* the pivot, it is moved to the beginning of the output sequence (index 0).\n6.  Return the output sequence with the pivot and relocated payload, with remaining positions as zeros.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_pivot_np(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the index of the pivot element (2) in a NumPy array.\"\"\"\n    indices = np.where(grid == 2)[0]\n    # Return the index if found, otherwise None\n    return indices[0] if len(indices) > 0 else None\n\ndef find_payload_np(grid: np.ndarray, pivot_index: Optional[int]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the first contiguous payload block (value, start_index, end_index_inclusive)\n    in a NumPy array, excluding the pivot.\n    Returns None if no suitable payload is found.\n    \"\"\"\n    payload_value = None\n    payload_start_index = -1\n    payload_end_index = -1 # Will store the end index of the identified block\n\n    # Get indices of all non-zero elements\n    indices_non_zero = np.where(grid != 0)[0]\n\n    # Filter out the pivot index itself if it exists\n    if pivot_index is not None:\n        indices_non_zero = indices_non_zero[indices_non_zero != pivot_index]\n\n    # If no non-zero elements (besides potentially the pivot) exist, return None\n    if len(indices_non_zero) == 0:\n        return None\n\n    # Iterate through the non-zero indices to find the first contiguous block\n    current_val = -1\n    current_start = -1\n    current_end = -1\n    found_block = None # To store the first completed block\n\n    for i, idx in enumerate(indices_non_zero):\n        val = grid[idx]\n\n        if current_start == -1: # Starting a potential new block\n            current_val = val\n            current_start = idx\n            current_end = idx\n        elif val == current_val and idx == current_end + 1: # Continuing the current block\n            current_end = idx\n        else: # The previous block ended, or this element starts a different block\n            # Since we only care about the *first* block, we can store it and stop\n            payload_value = grid[current_start]\n            payload_start_index = current_start\n            payload_end_index = current_end # End index of the first block\n            found_block = (payload_value, payload_start_index, payload_end_index)\n            break # Exit the loop once the first block is fully identified\n\n    # Check if the loop finished without breaking (means the first/only block extended to the end)\n    if found_block is None and current_start != -1:\n        payload_value = grid[current_start]\n        payload_start_index = current_start\n        payload_end_index = current_end # The end index was updated correctly\n        found_block = (payload_value, payload_start_index, payload_end_index)\n\n    return found_block\n\n\ndef count_intermediate_zeros_np(grid: np.ndarray, payload_end_index: int, pivot_index: int) -> int:\n    \"\"\"Counts zeros strictly between the end of the payload and the pivot in a NumPy array.\"\"\"\n    count = 0\n    # Ensure indices allow for intermediate elements and payload is indeed before pivot\n    if payload_end_index >= 0 and pivot_index >=0 and payload_end_index < pivot_index - 1:\n        # Extract the slice between the payload end and pivot start\n        intermediate_slice = grid[payload_end_index + 1 : pivot_index]\n        # Count the number of zeros in this slice\n        count = np.count_nonzero(intermediate_slice == 0)\n    return count\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid (NumPy array).\n    \"\"\"\n    # Get the size of the input grid\n    n = len(input_grid)\n    # Initialize output_grid with zeros of the same size\n    output_grid = np.zeros(n, dtype=input_grid.dtype)\n\n    # 1. Locate the pivot index\n    pivot_index = find_pivot_np(input_grid)\n    if pivot_index is None:\n        # If no pivot '2' is found, return the zero grid (or handle as error)\n        # Based on problem description, pivot should always exist.\n        print(\"Warning: Pivot '2' not found in input.\")\n        return output_grid # Return zero grid as a fallback\n\n    # 2. Place the pivot '2' in the output grid at its original index\n    output_grid[pivot_index] = 2\n\n    # 3. Identify the payload block (value, start index, end index)\n    payload_info = find_payload_np(input_grid, pivot_index)\n    if payload_info is None:\n        # If no payload found (other than pivot), return the grid with only the pivot placed\n        # Based on problem description, a payload should always exist.\n        print(\"Warning: Payload not found in input.\")\n        return output_grid # Return grid with only pivot\n\n    # Extract payload details\n    payload_value, payload_start_index, payload_end_index = payload_info\n    payload_len = payload_end_index - payload_start_index + 1\n    # Create the payload block as a NumPy array\n    payload_block = np.full(payload_len, payload_value, dtype=input_grid.dtype)\n\n    # 4. Determine payload placement based on its position relative to the pivot\n    if payload_start_index < pivot_index:\n        # Case A: Payload was *before* the pivot\n\n        # a. Count intermediate zeros between payload end and pivot start\n        intermediate_zeros = count_intermediate_zeros_np(input_grid, payload_end_index, pivot_index)\n\n        # b. Calculate the target start index in the output grid\n        target_start_index = pivot_index + 1 + intermediate_zeros\n\n        # c. Place the payload block in the output grid, ensuring it fits within bounds\n        target_end_index_exclusive = target_start_index + payload_len\n        if target_end_index_exclusive <= n:\n            # Fits completely\n            output_grid[target_start_index : target_end_index_exclusive] = payload_block\n        else:\n            # Payload overflows the grid boundary, place only the part that fits\n            fit_len = n - target_start_index\n            if fit_len > 0:\n                output_grid[target_start_index : n] = payload_block[:fit_len]\n            # Consider logging a warning if overflow happens, as it might indicate unexpected input/logic issues\n\n    else: # payload_start_index > pivot_index\n        # Case B: Payload was *after* the pivot\n\n        # a. Place the payload block at the beginning (index 0) of the output grid\n        target_end_index_exclusive = payload_len\n        if target_end_index_exclusive <= n:\n            # Fits completely\n            output_grid[0 : target_end_index_exclusive] = payload_block\n        else:\n            # Payload is longer than the grid, place only the part that fits\n            output_grid[0 : n] = payload_block[:n]\n            # Consider logging a warning if overflow happens\n\n    # 5. Return the fully constructed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13388,
    "candidates_token_count": 1975,
    "total_token_count": 15363,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.054454,
  "retries": 1
}