{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence (1D NumPy array) of single-digit integers based on the relative positions and spacing of a 'pivot' element (2) and a contiguous 'group' of identical non-zero elements (X, where X != 2).\n\nThe transformation rule is:\n1. Find the index of the pivot element (2).\n2. Find the contiguous block of the group element (X), its value, length, start index, and end index.\n3. Keep the pivot element (2) at its original index in the output sequence.\n4. Determine if the group block was positioned before or after the pivot in the input.\n5. Calculate the gap size (number of zeros) between the pivot and the group block in the input sequence.\n6. Move the group block to the opposite side of the pivot in the output sequence, preserving the calculated gap size between them.\n7. Fill all other positions in the output sequence with zeros.\n\"\"\"\n\nimport numpy as np\n\ndef _find_pivot_index(grid):\n    \"\"\"Finds the index of the pivot element '2'.\"\"\"\n    pivot_indices = np.where(grid == 2)[0]\n    if len(pivot_indices) == 1:\n        return pivot_indices[0]\n    else:\n        # According to problem description, there should always be exactly one '2'\n        raise ValueError(\"Input grid must contain exactly one pivot element '2'.\")\n\ndef _find_group_info(grid):\n    \"\"\"\n    Finds the contiguous block of identical non-zero digits (not '2').\n    Returns:\n        tuple: (group_value, start_index, end_index, length) or raises ValueError if not found.\n    \"\"\"\n    group_value = None\n    start_index = -1\n    length = 0\n    in_group = False\n    found_group = False\n\n    for i, val in enumerate(grid):\n        if val != 0 and val != 2:\n            if not in_group:\n                # Start of a potential group\n                group_value = val\n                start_index = i\n                length = 1\n                in_group = True\n            elif val == group_value:\n                # Continue the current group\n                length += 1\n            else:\n                # Found a different non-zero, non-2 digit.\n                # Problem implies only one group type, so we stop the first one found.\n                found_group = True\n                break # Exit loop once the first complete group is identified\n        elif in_group:\n            # Group ended (hit a 0 or 2)\n            found_group = True\n            break # Exit loop once the group ends\n\n    # Handle case where group runs to the end of the array\n    if in_group and not found_group:\n        found_group = True\n\n    if found_group:\n        end_index = start_index + length - 1\n        return group_value, start_index, end_index, length\n    else:\n        # According to problem description, there should always be a group\n        raise ValueError(\"Could not find a valid group block in the input grid.\")\n\ndef _calculate_gap(pivot_index, group_start_index, group_end_index, is_before):\n    \"\"\"Calculates the number of zeros between the pivot and the group.\"\"\"\n    if is_before:\n        # Gap is between group end and pivot start\n        return pivot_index - group_end_index - 1\n    else:\n        # Gap is between pivot end and group start\n        return group_start_index - pivot_index - 1\n\ndef _calculate_output_start(pivot_index, group_length, gap_size, is_before):\n    \"\"\"Calculates the starting index for the group in the output grid.\"\"\"\n    if is_before:\n        # Group was before pivot, move it after, preserving gap\n        # Output starts at pivot_index + 1 (position after pivot) + gap_size\n        return pivot_index + 1 + gap_size\n    else:\n        # Group was after pivot, move it before, preserving gap\n        # Output ends at pivot_index - 1 (position before pivot) - gap_size\n        # Output starts at (end position) - group_length + 1\n        # Simplified: output starts at pivot_index - gap_size - group_length\n        return pivot_index - gap_size - group_length\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 1D NumPy array of single-digit integers.\n\n    Returns:\n        np.ndarray: The transformed 1D NumPy array.\n    \"\"\"\n    n = len(input_grid)\n    # Initialize output_grid with zeros\n    output_grid = np.zeros(n, dtype=input_grid.dtype) # Match input dtype\n\n    # Find the pivot element '2' and its index\n    pivot_index = _find_pivot_index(input_grid)\n\n    # Place the pivot element in the output grid\n    output_grid[pivot_index] = 2\n\n    # Find the group element block (X) details\n    group_value, group_start_index, group_end_index, group_length = _find_group_info(input_grid)\n\n    # Determine if the group was before or after the pivot in the input\n    group_was_before = group_end_index < pivot_index\n\n    # Calculate the gap size between pivot and group in the input\n    gap_size = _calculate_gap(pivot_index, group_start_index, group_end_index, group_was_before)\n\n    # Calculate the starting index for the group in the output grid\n    output_start_index = _calculate_output_start(pivot_index, group_length, gap_size, group_was_before)\n\n    # Calculate the ending index for the group in the output grid\n    output_end_index = output_start_index + group_length\n\n    # Check for boundary issues (should not happen with valid inputs and correct logic)\n    if output_start_index < 0 or output_end_index > n:\n        raise ValueError(f\"Calculated output indices [{output_start_index}:{output_end_index}] are out of bounds for grid size {n}.\")\n\n    # Place the group element block in the output grid\n    output_grid[output_start_index:output_end_index] = group_value\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9108,
    "candidates_token_count": 1488,
    "total_token_count": 10596,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.328698,
  "retries": 1
}