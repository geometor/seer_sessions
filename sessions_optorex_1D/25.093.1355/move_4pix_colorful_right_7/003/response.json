{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input NumPy array of 12 integers by identifying a single\ncontiguous block of non-zero integers and shifting this block 4 positions\nto the right, preserving the block's content and the surrounding zeros.\n\n1.  Accept the input sequence as a NumPy array.\n2.  Initialize an output NumPy array of the same size with all zeros.\n3.  Find the start index and content (`payload`) of the first contiguous\n    block of non-zero integers in the input array.\n4.  If no non-zero block is found, return the initialized zero array.\n5.  Calculate the `target_start_index` by adding 4 to the `start_index`.\n6.  Calculate the `target_end_index` based on the target start and payload length.\n7.  Copy the `payload` into the output array slice defined by the target\n    start and end indices, ensuring it stays within bounds.\n8.  Return the output array.\n\"\"\"\n\nimport numpy as np\n\ndef find_non_zero_block_np(grid: np.ndarray) -> tuple[int, np.ndarray | None]:\n    \"\"\"\n    Finds the first contiguous block of non-zero integers in a NumPy array.\n\n    Args:\n        grid: A 1D NumPy array of integers.\n\n    Returns:\n        A tuple containing:\n        - start_index: The starting index of the block (or -1 if not found).\n        - payload: A NumPy array containing the non-zero integers in the block\n                   (or None if not found).\n    \"\"\"\n    # Find indices of all non-zero elements\n    non_zero_indices = np.where(grid != 0)[0]\n\n    # Handle case with no non-zero elements\n    if non_zero_indices.size == 0:\n        return -1, None\n\n    # The start index is the first non-zero index\n    start_index = non_zero_indices[0]\n\n    # Determine the end index of the first contiguous block\n    if non_zero_indices.size == 1:\n        # Only one non-zero element\n        end_index = start_index\n    else:\n        # Check for gaps between non-zero indices\n        diffs = np.diff(non_zero_indices)\n        gaps = np.where(diffs > 1)[0]\n        if gaps.size == 0:\n            # No gaps, the block extends to the last non-zero element\n            end_index = non_zero_indices[-1]\n        else:\n            # Gaps exist, the first block ends before the first gap\n            # gaps[0] is the index *within diffs* where the first gap occurs.\n            # The corresponding index in non_zero_indices is non_zero_indices[gaps[0]]\n            end_index = non_zero_indices[gaps[0]]\n\n    # Extract the payload (the actual non-zero numbers in the block)\n    # Slicing is [start:end+1] to include the element at end_index\n    payload = grid[start_index : end_index + 1]\n\n    return start_index, payload\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input NumPy array.\n    \"\"\"\n    # Get the size of the input grid\n    n = input_grid.shape[0]\n\n    # Initialize an output grid of the same size with all zeros.\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the start index and the payload (non-zero block) using the helper function.\n    start_index, payload = find_non_zero_block_np(input_grid)\n\n    # Proceed only if a non-zero block was found\n    if start_index != -1 and payload is not None:\n        # Calculate the target start index for the shift (shift right by 4)\n        target_start_index = start_index + 4\n\n        # Calculate the target end index (exclusive) for slicing\n        payload_len = payload.shape[0]\n        target_end_index = target_start_index + payload_len\n\n        # --- Place the payload into the output grid ---\n        \n        # Determine the actual slice range within the output grid's bounds [0, n)\n        # The starting position of the slice in the output grid cannot be negative or >= n\n        actual_start = max(0, target_start_index) \n        actual_start = min(actual_start, n) # Clamp start index to be at most n\n\n        # The ending position of the slice in the output grid cannot exceed n\n        actual_end = min(target_end_index, n)\n        actual_end = max(actual_start, actual_end) # Ensure end >= start\n\n        # Determine the part of the payload to copy based on the available space in the output slice\n        # Calculate how many elements to skip from the beginning of the payload if target_start_index was < 0\n        payload_start_offset = max(0, -target_start_index) \n        # Calculate the number of elements that actually fit in the target slice\n        payload_copy_len = actual_end - actual_start\n\n        # Check if there's anything to copy\n        if payload_copy_len > 0 and payload_start_offset < payload_len:\n             # Select the correct part of the payload\n             payload_to_copy = payload[payload_start_offset : payload_start_offset + payload_copy_len]\n             # Copy the relevant part of the payload to the target slice\n             output_grid[actual_start:actual_end] = payload_to_copy\n\n    # Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4456,
    "candidates_token_count": 1309,
    "total_token_count": 5765,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.77303,
  "retries": 1
}