{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Optional, Tuple\n\n\"\"\"\nTransforms a 1D NumPy array of single-digit integers. The transformation hinges on \nthe location of the integer 2. If 2 is present, the algorithm scans left and right \nfrom the position of 2 for the *first* non-zero integer encountered. All zero elements \nsituated strictly *between* the 2 and the found non-zero element are replaced with \nthe value of that non-zero element, but only if the non-zero element is not \nimmediately adjacent to the 2 (i.e., there is at least one zero between them). \nIf 2 is not present, or if no non-zero element exists to the left/right, or if the \nnearest non-zero element is immediately adjacent to 2, no filling occurs on that side.\n\"\"\"\n\ndef _find_first_occurrence_np(data: np.ndarray, value: int) -> Optional[int]:\n    \"\"\"Finds the index of the first occurrence of a value in a NumPy array.\"\"\"\n    indices = np.where(data == value)[0]\n    if indices.size > 0:\n        return indices[0]\n    else:\n        return None\n\ndef _scan_and_find_non_zero_np(data: np.ndarray, start_index: int, end_index: int, step: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Scans a portion of the NumPy array for the first non-zero element.\n\n    Args:\n        data: The NumPy array to scan.\n        start_index: The starting index for the scan (inclusive).\n        end_index: The ending index boundary (exclusive for step=1, lower bound for step=-1).\n        step: The step direction (-1 for left, 1 for right).\n\n    Returns:\n        A tuple (value, index) of the first non-zero element found, or None.\n    \"\"\"\n    # Define the range of indices to check based on the direction (step)\n    if step == 1:\n        # Scan right: from start_index up to (but not including) end_index\n        indices = np.arange(start_index, end_index)\n    elif step == -1:\n        # Scan left: from start_index down to 0 (inclusive if end_index is -1 or less)\n        # Correctly handle the inclusive nature of the lower bound for negative step\n        actual_end = max(-1, end_index) # Ensure the stop point is at least -1 for arange\n        indices = np.arange(start_index, actual_end, step)\n    else:\n        # Invalid step value\n        return None\n\n    # Iterate through the generated indices\n    for i in indices:\n        # Basic bounds check (although arange should handle most cases)\n        if 0 <= i < len(data): \n            if data[i] != 0:\n                # Found the first non-zero element\n                return data[i], i\n    # No non-zero element found in the specified range\n    return None\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the fill transformation based on the position of '2'.\n\n    Args:\n        input_grid: A 1D NumPy array representing the input sequence.\n\n    Returns:\n        A 1D NumPy array representing the transformed sequence.\n    \"\"\"\n    # Initialize output_grid as a copy of input_grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    n = len(output_grid)\n\n    # 1. Locate the marker element '2'\n    index_of_2 = _find_first_occurrence_np(input_grid, 2)\n\n    # 2. If '2' is not found, return the original grid unchanged\n    if index_of_2 is None:\n        return output_grid\n\n    # 3. Perform Left Scan and Fill\n    # Scan leftwards from the index immediately preceding '2' down to index 0\n    left_scan_result = _scan_and_find_non_zero_np(input_grid, index_of_2 - 1, -1, -1)\n    \n    # Check if a non-zero element was found to the left\n    if left_scan_result is not None:\n        left_fill_value, left_fill_index = left_scan_result\n        \n        # Condition: Fill only if the found element is NOT adjacent to '2'\n        if left_fill_index < index_of_2 - 1:\n            # Identify the slice of elements strictly between the found non-zero and '2'\n            # Note: Slicing is [start:end], end is exclusive.\n            start_fill = left_fill_index + 1\n            end_fill = index_of_2\n            \n            # Check if the slice is valid (start < end)\n            if start_fill < end_fill:\n                 # Create a boolean mask for zeros within the target slice\n                mask = output_grid[start_fill:end_fill] == 0\n                # Apply the fill value where the mask is True\n                output_grid[start_fill:end_fill][mask] = left_fill_value\n\n\n    # 4. Perform Right Scan and Fill\n    # Scan rightwards from the index immediately following '2' up to the end of the array\n    right_scan_result = _scan_and_find_non_zero_np(input_grid, index_of_2 + 1, n, 1)\n\n    # Check if a non-zero element was found to the right\n    if right_scan_result is not None:\n        right_fill_value, right_fill_index = right_scan_result\n\n        # Condition: Fill only if the found element is NOT adjacent to '2'\n        if right_fill_index > index_of_2 + 1:\n            # Identify the slice of elements strictly between '2' and the found non-zero\n            start_fill = index_of_2 + 1\n            end_fill = right_fill_index # Slicing end is exclusive, which is correct here\n\n            # Check if the slice is valid (start < end)\n            if start_fill < end_fill:\n                # Create a boolean mask for zeros within the target slice\n                mask = output_grid[start_fill:end_fill] == 0\n                # Apply the fill value where the mask is True\n                output_grid[start_fill:end_fill][mask] = right_fill_value\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9844,
    "candidates_token_count": 1707,
    "total_token_count": 11551,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.344326,
  "retries": 1
}