{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input NumPy array of 12 digits based on a specific element transfer rule.\n\nThe rule involves:\n1. Identifying contiguous blocks of identical digits in the input array.\n2. Finding a unique digit for which its first block and last block are separated only by blocks of *different* digits.\n3. If such a pattern exists, one instance of the digit is conceptually moved from the end of the first block to the end of the last block. This is achieved by decreasing the length count of the first block by one and increasing the length count of the last block by one.\n4. This transfer happens at most once per input array.\n5. The sequence is reconstructed based on the modified block lengths and returned as a NumPy array.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\n# Helper function to identify blocks of consecutive identical digits\ndef identify_blocks(digits: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Identifies contiguous blocks of identical digits in a list.\n    Returns a list of tuples, where each tuple is (digit, length).\n    Example: [0, 0, 5, 5, 5, 0] -> [(0, 2), (5, 3), (0, 1)]\n    \"\"\"\n    if not digits:\n        return []\n\n    blocks = []\n    current_digit = digits[0]\n    current_length = 0\n    for digit in digits:\n        if digit == current_digit:\n            current_length += 1\n        else:\n            # Append the completed block\n            if current_length > 0: # Ensure we don't add empty blocks if input starts differently\n                 blocks.append((current_digit, current_length))\n            current_digit = digit\n            current_length = 1\n    # Append the last block\n    if current_length > 0:\n        blocks.append((current_digit, current_length))\n    return blocks\n\n# Helper function to reconstruct the sequence list from blocks\ndef reconstruct_sequence_list(blocks: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Reconstructs the list of digits from a list of blocks.\n    Example: [(0, 2), (5, 3), (0, 1)] -> [0, 0, 5, 5, 5, 0]\n    \"\"\"\n    output_digits = []\n    for digit, length in blocks:\n        # Only add blocks with positive length\n        if length > 0:\n            output_digits.extend([digit] * length)\n    return output_digits\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the element transfer rule to the input NumPy array.\n    \"\"\"\n    # 1. Convert input NumPy array to a list for easier processing\n    digits = input_grid.tolist()\n    if not digits:\n        return np.array([]) # Handle empty input\n\n    # 2. Identify contiguous blocks\n    blocks = identify_blocks(digits)\n    if not blocks: # Handle cases where block identification might fail (e.g., already empty list)\n        return np.array(digits)\n\n\n    # 3. Determine unique digits present\n    # Use a dictionary to preserve order of appearance, then get unique keys\n    unique_digits_ordered = list(dict.fromkeys(d[0] for d in blocks))\n\n    transformed = False\n    new_blocks = list(blocks) # Work on a copy\n\n    # 4. Iterate through unique digits to find the transfer pattern\n    for digit_to_check in unique_digits_ordered:\n        if transformed: # Stop after the first successful transformation\n            break\n\n        # 5. Find indices of the first and last blocks containing this digit\n        first_idx = -1\n        last_idx = -1\n        indices = [i for i, block in enumerate(new_blocks) if block[0] == digit_to_check]\n\n        if len(indices) >= 2:\n            first_idx = indices[0]\n            last_idx = indices[-1]\n\n        # 6. Check if blocks are distinct and separated only by other digits\n        if first_idx != -1 and first_idx < last_idx:\n            is_separated_correctly = True\n            # Check all blocks *between* the first and last\n            for i in range(first_idx + 1, last_idx):\n                if new_blocks[i][0] == digit_to_check:\n                    is_separated_correctly = False\n                    break # Found a block of the same digit in between\n\n            # 7. If conditions met, perform the transfer\n            if is_separated_correctly:\n                # Ensure the first block has elements to move\n                if new_blocks[first_idx][1] > 0:\n                    # a. Decrease length of the first block\n                    first_block_val, first_block_len = new_blocks[first_idx]\n                    new_blocks[first_idx] = (first_block_val, first_block_len - 1)\n\n                    # b. Increase length of the last block\n                    last_block_val, last_block_len = new_blocks[last_idx]\n                    new_blocks[last_idx] = (last_block_val, last_block_len + 1)\n\n                    # c. Mark as transformed and stop searching\n                    # (Block removal happens during reconstruction)\n                    transformed = True\n\n    # 8. Reconstruct the sequence list from potentially modified blocks\n    # Blocks with length 0 will be implicitly removed by reconstruct_sequence_list\n    output_list = reconstruct_sequence_list(new_blocks)\n\n    # 9. Convert the result list back to a NumPy array\n    output_grid = np.array(output_list, dtype=input_grid.dtype) # Preserve original dtype\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6577,
    "candidates_token_count": 1336,
    "total_token_count": 7913,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.638917,
  "retries": 1
}