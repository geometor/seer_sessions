{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input NumPy array representing a sequence of 12 digits.\nThe transformation identifies contiguous blocks of identical digits. It then looks for the first occurring pattern where the first block and the last block of a specific digit are separated only by blocks of different digits. If found, one digit is conceptually moved from the end of the first block to the end of the last block by adjusting their lengths. The sequence is then reconstructed from the modified block lengths and returned as a NumPy array.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\n# Helper function to identify blocks of consecutive identical digits\ndef _identify_blocks(digits: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Identifies contiguous blocks of identical digits in a list.\n    Returns a list of tuples, where each tuple is (digit, length).\n    Example: [0, 0, 5, 5, 5, 0] -> [(0, 2), (5, 3), (0, 1)]\n    \"\"\"\n    if not digits:\n        return []\n\n    blocks = []\n    # Initialize with the first element if list is not empty\n    current_digit = digits[0]\n    current_length = 0\n    \n    for digit in digits:\n        if digit == current_digit:\n            current_length += 1\n        else:\n            # Append the completed block if its length is positive\n            if current_length > 0:\n                 blocks.append((current_digit, current_length))\n            # Start the new block\n            current_digit = digit\n            current_length = 1\n            \n    # Append the very last block after the loop finishes\n    if current_length > 0:\n        blocks.append((current_digit, current_length))\n        \n    return blocks\n\n# Helper function to reconstruct the sequence list from blocks\ndef _reconstruct_sequence_list(blocks: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Reconstructs the list of digits from a list of blocks.\n    Omits blocks with zero length.\n    Example: [(0, 2), (5, 3), (0, 1)] -> [0, 0, 5, 5, 5, 0]\n    Example: [(0, 0), (5, 3), (0, 1)] -> [5, 5, 5, 0]\n    \"\"\"\n    output_digits = []\n    for digit, length in blocks:\n        # Only add blocks with positive length\n        if length > 0:\n            output_digits.extend([digit] * length)\n    return output_digits\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the element transfer rule to the input NumPy array.\n    \"\"\"\n    # 1. Flatten the input array to a 1D list of digits\n    #    This handles both 1D and potential 1xN 2D arrays correctly.\n    if input_grid.size == 0:\n        return np.array([]) # Handle empty input gracefully\n    digits = input_grid.flatten().tolist()\n    original_dtype = input_grid.dtype # Preserve original data type\n\n    # 2. Identify contiguous blocks of identical digits\n    blocks = _identify_blocks(digits)\n    if not blocks: \n        # Should not happen if input wasn't empty, but handle defensively\n        return np.array(digits, dtype=original_dtype) \n\n    # 3. Find the transfer pattern\n    #    Iterate through unique digits present in the blocks.\n    #    Using dict.fromkeys preserves the order of appearance, ensuring we find\n    #    the *first* pattern according to the order digits appear in the sequence.\n    unique_digits_ordered = list(dict.fromkeys(d[0] for d in blocks))\n    \n    transformed = False\n    new_blocks = list(blocks) # Work on a mutable copy\n\n    for digit_to_check in unique_digits_ordered:\n        if transformed: # Optimization: Stop after the first successful transformation\n            break\n\n        # 4. Find indices of the first and last blocks containing this digit\n        first_idx = -1\n        last_idx = -1\n        indices = [i for i, block in enumerate(new_blocks) if block[0] == digit_to_check]\n\n        if len(indices) >= 2: # Need at least two blocks of the same digit\n            first_idx = indices[0]\n            last_idx = indices[-1]\n\n        # 5. Check if blocks are distinct and separated only by other digits\n        if first_idx != -1: # This check implicitly covers first_idx < last_idx because indices are sorted\n            is_separated_correctly = True\n            # Check all blocks *between* the first and last candidates\n            for i in range(first_idx + 1, last_idx):\n                if new_blocks[i][0] == digit_to_check:\n                    # Found a block of the same digit in between - invalid pattern\n                    is_separated_correctly = False\n                    break \n\n            # 6. If conditions met, perform the transfer\n            if is_separated_correctly:\n                # Ensure the first block actually has elements to move\n                if new_blocks[first_idx][1] > 0:\n                    # a. Decrease length of the first block\n                    first_block_val, first_block_len = new_blocks[first_idx]\n                    new_blocks[first_idx] = (first_block_val, first_block_len - 1)\n\n                    # b. Increase length of the last block\n                    last_block_val, last_block_len = new_blocks[last_idx]\n                    new_blocks[last_idx] = (last_block_val, last_block_len + 1)\n\n                    # c. Mark as transformed and stop searching for other patterns\n                    transformed = True\n                    # Note: Block removal (if length becomes 0) happens during reconstruction\n\n    # 7. Reconstruct the sequence list from potentially modified blocks\n    #    The helper function handles skipping blocks with length 0.\n    output_list = _reconstruct_sequence_list(new_blocks)\n\n    # 8. Convert the result list back to a NumPy array with original dtype\n    output_grid = np.array(output_list, dtype=original_dtype)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8722,
    "candidates_token_count": 1466,
    "total_token_count": 10188,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.88503,
  "retries": 1
}