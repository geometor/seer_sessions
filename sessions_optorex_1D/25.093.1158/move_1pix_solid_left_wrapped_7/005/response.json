{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms a sequence of integers based on the position and grouping of non-zero elements.\n\nThe transformation follows two main rules determined by the index of the first non-zero element:\n\n1.  **Rule 1 (First non-zero element's index `i` > 0):**\n    a.  Identify the contiguous block of the same non-zero value starting at index `i`. Let this block end at index `j`.\n    b.  Shift this entire block (from `i` to `j`) one position to the left, occupying indices `i-1` to `j-1`.\n    c.  The original element at index `i-1` (which is expected to be 0) is moved to index `j`.\n\n2.  **Rule 2 (First non-zero element's index `i` == 0):**\n    a.  Identify the contiguous block of the starting non-zero value, ending at index `j`.\n    b.  Find the start index `k` of the *next* block of *any* non-zero number occurring after index `j`.\n    c.  If such a next block exists (k != -1) and the element immediately preceding it (at index `k-1`) is 0, swap the element at index `j` (the end of the first block) with the element at index `k-1` (the zero before the next block).\n\n3.  If the sequence contains only zeros or is empty, it remains unchanged.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_first_nonzero_index(grid):\n    \"\"\"Finds the index of the first non-zero element in the list.\"\"\"\n    for i, val in enumerate(grid):\n        if val != 0:\n            return i\n    return -1 # Indicate not found\n\ndef find_block_end(grid, start_index):\n    \"\"\"\n    Finds the end index (inclusive) of a contiguous block of the *same* value\n    that starts at start_index.\n    \"\"\"\n    if start_index < 0 or start_index >= len(grid):\n        return -1 # Invalid start index\n    \n    val = grid[start_index]\n    if val == 0: # Cannot have a block of zeros by definition here\n        return start_index \n        \n    end_index = start_index\n    # Iterate from the next element onwards\n    for i in range(start_index + 1, len(grid)):\n        if grid[i] == val:\n            end_index = i  # Update the end index if the value matches\n        else:\n            break # Stop when a different value or the end of the grid is encountered\n    return end_index\n\ndef find_next_nonzero_block_start(grid, search_start_index):\n    \"\"\"\n    Finds the start index of the next non-zero block (any non-zero value)\n    occurring strictly after the search_start_index.\n    \"\"\"\n    # Iterate from the element *after* the search_start_index\n    for i in range(search_start_index + 1, len(grid)):\n        if grid[i] != 0:\n            # Found the start of the next non-zero block\n            return i\n    return -1 # Indicate not found\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid (list of integers).\n    \"\"\"\n    # Ensure input is a list and create a mutable copy\n    if not isinstance(input_grid, list):\n      # If input is numpy array or other sequence, convert to list\n       output_grid = list(input_grid)\n    else:\n       output_grid = list(input_grid) # Make a copy\n\n    n = len(output_grid)\n\n    # Handle empty grid case\n    if n == 0:\n        return output_grid\n\n    # Find the index of the first non-zero element\n    first_nz_idx = find_first_nonzero_index(output_grid)\n\n    # Handle case: no non-zero elements found\n    if first_nz_idx == -1:\n        return output_grid # Return unchanged grid\n\n    # --- Apply Transformation Rules ---\n\n    # Case 1: First non-zero element is NOT at the beginning (index > 0)\n    if first_nz_idx > 0:\n        # Find the end index of the block starting at first_nz_idx\n        block_start_idx = first_nz_idx\n        block_end_idx = find_block_end(output_grid, block_start_idx)\n\n        # Ensure the element before the block is indeed 0 as expected\n        if block_start_idx > 0 and output_grid[block_start_idx - 1] == 0:\n             # Store the zero that will be moved\n            zero_to_move = output_grid[block_start_idx - 1] \n            \n            # Perform the left shift of the block\n            for i in range(block_start_idx, block_end_idx + 1):\n                output_grid[i - 1] = output_grid[i]\n                \n            # Place the stored zero at the end of the shifted block's original position\n            output_grid[block_end_idx] = zero_to_move\n        # If the preceding element isn't zero, the examples don't cover this,\n        # so we assume no change based on observed patterns.\n\n    # Case 2: First non-zero element IS at the beginning (index 0)\n    elif first_nz_idx == 0:\n        # Find the end index of the first block (starting at index 0)\n        first_block_end_idx = find_block_end(output_grid, 0)\n\n        # Find the start index of the next non-zero block occurring after the first block\n        next_block_start_idx = find_next_nonzero_block_start(output_grid, first_block_end_idx)\n\n        # Check if a next block was found\n        if next_block_start_idx != -1:\n            # Calculate the index immediately before the next block\n            zero_idx_before_next = next_block_start_idx - 1\n\n            # Check if this preceding index is valid (>=0, although implicitly true if next_block_start_idx > first_block_end_idx >= 0)\n            # and importantly, check if it contains a zero\n            if output_grid[zero_idx_before_next] == 0:\n                 # Perform the swap: element at the end of the first block swaps\n                 # with the zero preceding the next block.\n                 swap_idx1 = first_block_end_idx\n                 swap_idx2 = zero_idx_before_next\n                 output_grid[swap_idx1], output_grid[swap_idx2] = output_grid[swap_idx2], output_grid[swap_idx1]\n        # If no next block is found, or the element before it isn't zero, no swap occurs in this case.\n\n    # Return the modified sequence\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11980,
    "candidates_token_count": 1637,
    "total_token_count": 13617,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.203646,
  "retries": 1
}