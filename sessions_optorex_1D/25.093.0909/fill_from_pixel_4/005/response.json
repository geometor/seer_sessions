{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence (list of integers) based on a local pattern.\n1. Scan the input list to find the first occurrence of a specific three-element pattern centered at index `i` (where 0 < i < length-1). Let the elements be A (at i-1), B (at i, the 'Neighbor'), and C (at i+1).\n2. The patterns are:\n    - RunNeighborZero: A is non-zero, B is non-zero, C is zero, and A != B. The 'Run' value is A, and the Neighbor's position relative to the Run is 'right'.\n    - ZeroNeighborRun: A is zero, B is non-zero, C is non-zero, and B != C. The 'Run' value is C, and the Neighbor's position relative to the Run is 'left'.\n3. If a pattern is found:\n    - Determine a 'TargetLength' for the final contiguous block of the Neighbor digit (B) based on the Run value and the Neighbor's relative position ('left'/'right'). The specific rules are:\n        - Position 'right': (Run=2 -> Length=3), (Run=3 -> Length=4), (Run=5 -> Length=4)\n        - Position 'left': (Run=3 -> Length=3), (Run=5 -> Length=4), (Run=8 -> Length=2)\n    - The Neighbor digit (B) expands into adjacent zeros in the direction *away* from the Run (rightward for 'right' position, leftward for 'left' position).\n    - Expansion modifies a copy of the input list. It replaces zeros with the Neighbor digit until the total count of the Neighbor digit in the expanding block (including the original Neighbor at index `i`) reaches the TargetLength, or a non-zero digit is encountered, or the list boundary is reached.\n4. If no pattern is found, the original list is returned unchanged.\n\"\"\"\n\nimport math # Not used, but included as per template guide\n\ndef get_target_length(run_value, position):\n    \"\"\"\n    Calculates the target length of the expanded block based on the \n    adjacent run's value and the relative position of the neighbor.\n    \n    Args:\n        run_value (int): The digit value of the adjacent run.\n        position (str): 'left' if the neighbor is left of the run, \n                        'right' if the neighbor is right of the run.\n                        \n    Returns:\n        int: The calculated target length for the final block of neighbor digits,\n             or -1 if no specific rule is found.\n    \"\"\"\n    # Ensure comparison is between integers if run_value comes as str or other type\n    try:\n        run_value = int(run_value) \n    except (ValueError, TypeError):\n        return -1 # Invalid run_value type\n\n    if position == 'right': # Neighbor is to the RIGHT of the Run\n        if run_value == 2: return 3\n        if run_value == 3: return 4\n        if run_value == 5: return 4\n    elif position == 'left': # Neighbor is to the LEFT of the Run\n        if run_value == 3: return 3\n        if run_value == 5: return 4\n        if run_value == 8: return 2\n        \n    return -1 # Indicate no specific rule found for this combination\n\ndef find_pattern(grid):\n    \"\"\"\n    Scans the grid to find the first occurrence of the pattern:\n    Run-Neighbor-Zero or Zero-Neighbor-Run.\n\n    Args:\n        grid (list): The input sequence of integers.\n\n    Returns:\n        dict: A dictionary containing pattern details ('neighbor_value', \n              'neighbor_index', 'run_value', 'position') if found, \n              otherwise None.\n              'position' indicates if the neighbor is 'left' or 'right' of the run.\n    \"\"\"\n    n = len(grid)\n    # Iterate through possible neighbor positions (requires elements to the left and right)\n    for i in range(1, n - 1): \n        A = grid[i-1]\n        B = grid[i]   # Potential neighbor\n        C = grid[i+1]\n        \n        # Skip if the potential neighbor is zero\n        if B == 0: \n            continue\n            \n        # Case 1: Run-Neighbor-Zero (Neighbor right of Run)\n        # Conditions: A!=0, B!=0 (checked above), C=0, A!=B\n        if A != 0 and C == 0 and A != B:\n            return {'neighbor_value': B, 'neighbor_index': i, 'run_value': A, 'position': 'right'}\n            \n        # Case 2: Zero-Neighbor-Run (Neighbor left of Run)\n        # Conditions: A=0, B!=0 (checked above), C!=0, B!=C\n        if A == 0 and C != 0 and B != C:\n            return {'neighbor_value': B, 'neighbor_index': i, 'run_value': C, 'position': 'left'}\n            \n    return None # No pattern found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule described in the module docstring.\n    Expects input_grid to be a list of integers.\n    \"\"\"\n    # Ensure input is a list (create a copy to avoid modifying the original if passed by reference)\n    if not isinstance(input_grid, list):\n         raise TypeError(\"Input must be a list of integers.\")\n         \n    grid = list(input_grid) # Work on a copy\n    output_grid = list(grid) # Initialize output_grid as a copy to be modified\n    n = len(grid)\n\n    # Find the first occurrence of the required pattern\n    pattern_info = find_pattern(grid)\n\n    # If a pattern is found, apply the transformation\n    if pattern_info:\n        neighbor_val = pattern_info['neighbor_value']\n        neighbor_idx = pattern_info['neighbor_index']\n        run_val = pattern_info['run_value']\n        position = pattern_info['position']\n\n        # Determine the target length for the final block of neighbor digits\n        target_length = get_target_length(run_val, position)\n\n        # Only proceed if a valid target length rule exists (TargetLength > 0)\n        if target_length > 0:\n            \n            # Apply expansion based on the neighbor's position relative to the run\n            if position == 'right':\n                # Neighbor is to the right of the run, expand rightwards into zeros\n                # The block includes the neighbor, so we need to fill target_length-1 more cells\n                current_block_length = 1 # Start with the neighbor itself\n                # Iterate from the first zero to the right\n                for k in range(neighbor_idx + 1, n):\n                    # Stop if target length is reached\n                    if current_block_length >= target_length:\n                        break\n                    # Only replace zeros\n                    if grid[k] == 0: \n                        output_grid[k] = neighbor_val\n                        current_block_length += 1\n                    else: \n                        # Stop expansion if a non-zero is encountered\n                        break\n                        \n            elif position == 'left':\n                # Neighbor is to the left of the run, expand leftwards into zeros\n                # The block includes the neighbor, so we need to fill target_length-1 more cells\n                current_block_length = 1 # Start with the neighbor itself\n                # Iterate from the first zero to the left (going backwards)\n                for k in range(neighbor_idx - 1, -1, -1):\n                    # Stop if target length is reached\n                    if current_block_length >= target_length:\n                        break\n                    # Only replace zeros\n                    if grid[k] == 0:\n                        output_grid[k] = neighbor_val\n                        current_block_length += 1\n                    else:\n                        # Stop expansion if a non-zero is encountered\n                        break\n\n    # Return the modified grid (or the original copy if no pattern was found/applied)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10301,
    "candidates_token_count": 1866,
    "total_token_count": 12167,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.51458,
  "retries": 1
}