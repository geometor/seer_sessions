{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input sequence (list of integers) based on a local pattern.\n1. Parse the input (expected as a string of space-separated digits, though the function now accepts a list of integers directly) into a list of integers (the `Grid`).\n2. Scan the `Grid` to find the first occurrence of a specific three-element pattern centered at index `i` (where 0 < i < length-1). Let the elements be A (at i-1), B (at i, the 'Neighbor'), and C (at i+1).\n3. The patterns are:\n    - RunNeighborZero: A is non-zero, B is non-zero, C is zero, and A != B. The 'Run' value is A, and the Neighbor's position relative to the Run is 'right'.\n    - ZeroNeighborRun: A is zero, B is non-zero, C is non-zero, and B != C. The 'Run' value is C, and the Neighbor's position relative to the Run is 'left'.\n4. If a pattern is found:\n    - Determine a 'TargetLength' for the final contiguous block of the Neighbor digit (B) based on the Run value and the Neighbor's relative position ('left'/'right'). The specific rules are:\n        - Position 'right': (Run=2 -> Length=3), (Run=3 -> Length=4), (Run=5 -> Length=4)\n        - Position 'left': (Run=3 -> Length=3), (Run=5 -> Length=4), (Run=8 -> Length=2)\n    - The Neighbor digit (B) expands into adjacent zeros in the direction *away* from the Run (rightward for 'right' position, leftward for 'left' position).\n    - Expansion modifies a copy of the input list. It replaces zeros with the Neighbor digit until the total count of the Neighbor digit in the expanding block (including the original Neighbor at index `i`) reaches the TargetLength, or a non-zero digit is encountered, or the list boundary is reached.\n5. If no pattern is found, the original list is returned unchanged. The function returns the resulting list of integers.\n\"\"\"\n\nimport math # Not used, but included as per standard practice\n\ndef get_target_length(run_value, position):\n    \"\"\"\n    Calculates the target length of the expanded block based on the \n    adjacent run's value and the relative position of the neighbor.\n    \n    Args:\n        run_value (int): The digit value of the adjacent run.\n        position (str): 'left' if the neighbor is left of the run, \n                        'right' if the neighbor is right of the run.\n                        \n    Returns:\n        int: The calculated target length for the final block of neighbor digits,\n             or -1 if no specific rule is found.\n    \"\"\"\n    # Ensure comparison is between integers if run_value comes as str or other type\n    try:\n        run_value = int(run_value) \n    except (ValueError, TypeError):\n        return -1 # Invalid run_value type\n\n    if position == 'right': # Neighbor is to the RIGHT of the Run\n        if run_value == 2: return 3\n        if run_value == 3: return 4\n        if run_value == 5: return 4\n    elif position == 'left': # Neighbor is to the LEFT of the Run\n        if run_value == 3: return 3\n        if run_value == 5: return 4\n        if run_value == 8: return 2\n        \n    return -1 # Indicate no specific rule found for this combination\n\ndef find_pattern(grid):\n    \"\"\"\n    Scans the grid to find the first occurrence of the pattern:\n    Run-Neighbor-Zero or Zero-Neighbor-Run.\n\n    Args:\n        grid (list): The input sequence of integers.\n\n    Returns:\n        dict: A dictionary containing pattern details ('neighbor_value', \n              'neighbor_index', 'run_value', 'position') if found, \n              otherwise None.\n              'position' indicates if the neighbor is 'left' or 'right' of the run.\n    \"\"\"\n    n = len(grid)\n    # Iterate through possible neighbor positions (requires elements to the left and right)\n    # The central element 'B' is the potential Neighbor.\n    for i in range(1, n - 1): \n        A = grid[i-1] # Element to the left of potential Neighbor\n        B = grid[i]   # Potential Neighbor\n        C = grid[i+1] # Element to the right of potential Neighbor\n        \n        # Skip if the potential neighbor B is zero, as it must be non-zero\n        if B == 0: \n            continue\n            \n        # Check for Case 1: Run-Neighbor-Zero (A=Run, B=Neighbor, C=Zero)\n        # Conditions: A is non-zero (Run), B is non-zero (Neighbor), C is zero, A is different from B\n        if A != 0 and C == 0 and A != B:\n            # Found the pattern: Neighbor B is to the right of Run A\n            return {'neighbor_value': B, 'neighbor_index': i, 'run_value': A, 'position': 'right'}\n            \n        # Check for Case 2: Zero-Neighbor-Run (A=Zero, B=Neighbor, C=Run)\n        # Conditions: A is zero, B is non-zero (Neighbor), C is non-zero (Run), B is different from C\n        if A == 0 and C != 0 and B != C:\n            # Found the pattern: Neighbor B is to the left of Run C\n            return {'neighbor_value': B, 'neighbor_index': i, 'run_value': C, 'position': 'left'}\n            \n    # If the loop completes without finding a pattern\n    return None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule described in the module docstring.\n    Expects input_grid to be a list of integers.\n    \"\"\"\n    # Ensure input is a list (create a copy to avoid modifying the original if passed by reference)\n    if not isinstance(input_grid, list):\n         # If input is not a list, attempt to parse it as a space-separated string\n         if isinstance(input_grid, str):\n             try:\n                 grid = list(map(int, input_grid.split()))\n             except ValueError:\n                 raise TypeError(\"Input string must contain space-separated integers.\")\n         else:\n             raise TypeError(\"Input must be a list of integers or a string of space-separated integers.\")\n    else:\n        # If it is already a list, make a copy to work with\n        grid = list(input_grid) \n    \n    # Initialize output_grid as a copy of the potentially parsed input grid\n    output_grid = list(grid) \n    n = len(grid)\n\n    # Find the first occurrence of the required pattern using the helper function\n    pattern_info = find_pattern(grid)\n\n    # If a pattern was found, proceed with the transformation\n    if pattern_info:\n        # Extract details from the found pattern\n        neighbor_val = pattern_info['neighbor_value']\n        neighbor_idx = pattern_info['neighbor_index']\n        run_val = pattern_info['run_value']\n        position = pattern_info['position']\n\n        # Determine the target length for the final block of neighbor digits using the helper function\n        target_length = get_target_length(run_val, position)\n\n        # Only proceed with expansion if a valid target length rule exists (TargetLength > 0)\n        if target_length > 0:\n            \n            # Apply expansion based on the neighbor's position relative to the run\n            if position == 'right':\n                # Neighbor is to the right of the run, so expand rightwards into zeros\n                \n                # The block starts with the neighbor itself, so initialize count to 1\n                current_block_length = 1 \n                \n                # Iterate from the cell immediately to the right of the neighbor (index i+1) towards the end\n                for k in range(neighbor_idx + 1, n):\n                    # Stop expansion if the target length for the block is reached\n                    if current_block_length >= target_length:\n                        break\n                    \n                    # Check if the current cell contains a zero - only zeros are replaced\n                    if grid[k] == 0: \n                        # Replace the zero with the neighbor's value in the output grid\n                        output_grid[k] = neighbor_val\n                        # Increment the count of digits in the expanding block\n                        current_block_length += 1\n                    else: \n                        # Stop expansion if a non-zero digit is encountered\n                        break\n                        \n            elif position == 'left':\n                # Neighbor is to the left of the run, so expand leftwards into zeros\n                \n                # The block starts with the neighbor itself, so initialize count to 1\n                current_block_length = 1 \n                \n                # Iterate from the cell immediately to the left of the neighbor (index i-1) towards the beginning (index 0)\n                for k in range(neighbor_idx - 1, -1, -1): # Step backwards from i-1 down to 0\n                    # Stop expansion if the target length for the block is reached\n                    if current_block_length >= target_length:\n                        break\n                        \n                    # Check if the current cell contains a zero - only zeros are replaced\n                    if grid[k] == 0:\n                        # Replace the zero with the neighbor's value in the output grid\n                        output_grid[k] = neighbor_val\n                        # Increment the count of digits in the expanding block\n                        current_block_length += 1\n                    else:\n                        # Stop expansion if a non-zero digit is encountered\n                        break\n\n    # Return the modified grid (or the original copy if no pattern was found/applied)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13794,
    "candidates_token_count": 2269,
    "total_token_count": 16063,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.159839,
  "retries": 1
}