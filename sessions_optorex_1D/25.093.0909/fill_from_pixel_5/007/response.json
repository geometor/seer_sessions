{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math # Although not used in the final version, imported as per template requirement\n\n\"\"\"\nIdentifies \"single\" non-zero digits in an input sequence (list or array of 12 integers) \nand propagates their value into adjacent blocks of zeros based on the original input state.\n\nA non-zero digit is considered \"single\" if its immediate left and right neighbors \n(if they exist within the sequence bounds) have different values from it in the \noriginal input sequence. It's essentially a non-zero digit not part of a \ncontiguous block of the same non-zero digit.\n\nThe value of each identified single digit (based on the original input) replaces \nthe zeros in the contiguous block(s) of zeros immediately to its left and/or \nright in an output sequence. Propagation stops when a non-zero digit (in the \noriginal input) or the boundary of the sequence is encountered.\n\"\"\"\n\ndef _is_single(sequence, index):\n    \"\"\"\n    Helper function to check if the digit at the given index is a 'single' non-zero digit.\n\n    Args:\n        sequence: The list of integers representing the sequence.\n        index: The index of the digit to check.\n\n    Returns:\n        True if the digit at the index is single, False otherwise.\n    \"\"\"\n    n = len(sequence)\n    value = sequence[index]\n\n    # Rule 1: Must be non-zero\n    if value == 0:\n        return False\n\n    # Rule 2: Check left neighbor (if it exists) must be different\n    # True if it's the first element OR the element to the left is different\n    left_different = (index == 0) or (sequence[index - 1] != value)\n\n    # Rule 3: Check right neighbor (if it exists) must be different\n    # True if it's the last element OR the element to the right is different\n    right_different = (index == n - 1) or (sequence[index + 1] != value)\n\n    # Satisfies all rules if non-zero and different from existing neighbors\n    return left_different and right_different\n\ndef transform(input_sequence):\n    \"\"\"\n    Applies the single digit propagation rule to the input sequence.\n\n    Args:\n        input_sequence: A list, NumPy array, or similar iterable of 12 integers.\n\n    Returns:\n        A list of 12 integers representing the transformed sequence.\n    \"\"\"\n    \n    # --- Input Handling & Initialization ---\n    # Ensure input is a standard Python list of integers for consistent processing\n    if isinstance(input_sequence, np.ndarray):\n         input_list = input_sequence.astype(int).tolist() # Convert numpy array to list\n    else:\n         # Handles lists, tuples, strings of space-separated numbers etc.\n         try:\n             if isinstance(input_sequence, str):\n                 input_list = [int(d) for d in input_sequence.split()]\n             else:\n                 input_list = list(map(int, input_sequence)) # Assume iterable, convert elements to int\n         except (ValueError, TypeError):\n             raise TypeError(\"Input must be convertible to a list of integers.\")\n\n    n = len(input_list)\n    # Optional: Could add check here if n != 12 and raise error or warning\n\n    # Initialize output_sequence as a mutable copy of the processed input list.\n    # Modifications will be made to this list.\n    output_sequence = list(input_list)\n\n    # --- Step 1: Identify all single non-zero digits in the ORIGINAL input list ---\n    singles = []\n    # Iterate through each index of the input list\n    for i in range(n):\n        # Use the helper function to check if the element at index 'i' is single\n        if _is_single(input_list, i):\n            # Store the index and value of each single digit found.\n            singles.append({\"index\": i, \"value\": input_list[i]})\n\n    # --- Step 2: Propagate values from identified singles into adjacent zeros ---\n    # Iterate through the list of single digits identified in Step 1.\n    for single in singles:\n        idx = single[\"index\"] # Original index of the single digit\n        val = single[\"value\"] # Value of the single digit\n\n        # --- Propagate to the left ---\n        # Start checking from the position immediately left of the single digit.\n        j = idx - 1\n        # Keep moving left as long as we are within the sequence bounds (j >= 0)\n        # AND the element at position 'j' in the ORIGINAL input_list is 0.\n        # This prevents propagation over non-zeros or into areas potentially filled by other singles\n        # if we were checking the output_sequence directly during propagation.\n        while j >= 0 and input_list[j] == 0:\n            # Update the corresponding position in the output_sequence with the single digit's value.\n            output_sequence[j] = val\n            j -= 1 # Move one step further left.\n\n        # --- Propagate to the right ---\n        # Start checking from the position immediately right of the single digit.\n        j = idx + 1\n        # Keep moving right as long as we are within the sequence bounds (j < n)\n        # AND the element at position 'j' in the ORIGINAL input_list is 0.\n        while j < n and input_list[j] == 0:\n            # Update the corresponding position in the output_sequence with the single digit's value.\n            output_sequence[j] = val\n            j += 1 # Move one step further right.\n\n    # Return the modified output sequence as a list.\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11597,
    "candidates_token_count": 1298,
    "total_token_count": 12895,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.678326,
  "retries": 1
}