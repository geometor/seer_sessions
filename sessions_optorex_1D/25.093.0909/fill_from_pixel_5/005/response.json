{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\n# It's good practice to import numpy if dealing with array-like structures, \n# even if the core logic uses lists, as the testing harness might use numpy.\nimport numpy as np \n\n\"\"\"\nIdentifies \"single\" non-zero digits in an input sequence (list or array of 12 integers) \nand propagates their value into adjacent blocks of zeros based on the original input state.\n\nA non-zero digit is considered \"single\" if its immediate left and right neighbors \n(if they exist within the sequence bounds) have different values from it in the \noriginal input sequence. It's essentially a non-zero digit not part of a \ncontiguous block of the same non-zero digit.\n\nThe value of each identified single digit (based on the original input) replaces \nthe zeros in the contiguous block(s) of zeros immediately to its left and/or \nright in an output sequence. Propagation stops when a non-zero digit (in the \noriginal input) or the boundary of the sequence is encountered.\n\"\"\"\n\ndef is_single(sequence, index):\n    \"\"\"\n    Checks if the digit at the given index in the sequence is a 'single' non-zero digit.\n\n    A digit is 'single' if it's non-zero and its immediate neighbors (if they exist)\n    have different values.\n\n    Args:\n        sequence: The list of integers representing the sequence.\n        index: The index of the digit to check.\n\n    Returns:\n        True if the digit at the index is single, False otherwise.\n    \"\"\"\n    n = len(sequence)\n    value = sequence[index]\n\n    # Rule 1: Must be non-zero\n    if value == 0:\n        return False\n\n    # Rule 2: Check left neighbor (if it exists) must be different\n    # True if it's the first element OR the element to the left is different\n    left_different = (index == 0) or (sequence[index - 1] != value)\n\n    # Rule 3: Check right neighbor (if it exists) must be different\n    # True if it's the last element OR the element to the right is different\n    right_different = (index == n - 1) or (sequence[index + 1] != value)\n\n    # Satisfies all rules if non-zero and different from existing neighbors\n    return left_different and right_different\n\ndef transform(input_sequence):\n    \"\"\"\n    Applies the single digit propagation rule to the input sequence.\n\n    Args:\n        input_sequence: A list, NumPy array, or similar iterable of 12 integers.\n\n    Returns:\n        A list of 12 integers representing the transformed sequence.\n    \"\"\"\n    \n    # --- Input Handling & Initialization ---\n    # Ensure input is a standard Python list of integers for consistent processing\n    # This handles potential variations like NumPy arrays from the test harness.\n    if isinstance(input_sequence, str): # Handle potential string input if needed based on earlier examples\n         input_list = [int(d) for d in input_sequence.split()]\n    elif isinstance(input_sequence, np.ndarray):\n         input_list = input_sequence.astype(int).tolist() # Convert numpy array to list\n    else:\n         input_list = list(map(int, input_sequence)) # Assume iterable, convert elements to int\n\n    n = len(input_list)\n    if n != 12:\n        # Optional: Add error handling or logging if length is not 12\n        print(f\"Warning: Input sequence length is {n}, expected 12.\")\n\n    # Initialize output_sequence as a mutable copy of the processed input list.\n    # Modifications will be made to this list.\n    output_sequence = list(input_list)\n\n    # --- Step 1: Identify all single non-zero digits in the ORIGINAL input list ---\n    singles = []\n    for i in range(n):\n        # Use the helper function to check if the element at index 'i' is single\n        if is_single(input_list, i):\n            # Store the index and value of each single digit found.\n            singles.append({\"index\": i, \"value\": input_list[i]})\n\n    # --- Step 2: Propagate values from identified singles into adjacent zeros ---\n    # Iterate through the list of single digits identified in Step 1.\n    for single in singles:\n        idx = single[\"index\"] # Original index of the single digit\n        val = single[\"value\"] # Value of the single digit\n\n        # --- Propagate to the left ---\n        # Start checking from the position immediately left of the single digit.\n        j = idx - 1\n        # Keep moving left as long as we are within the sequence bounds (j >= 0)\n        # AND the element at position 'j' in the ORIGINAL input_list is 0.\n        # This prevents propagation over non-zeros or into areas filled by other singles.\n        while j >= 0 and input_list[j] == 0:\n            # Update the corresponding position in the output_sequence with the single digit's value.\n            output_sequence[j] = val\n            j -= 1 # Move one step further left.\n\n        # --- Propagate to the right ---\n        # Start checking from the position immediately right of the single digit.\n        j = idx + 1\n        # Keep moving right as long as we are within the sequence bounds (j < n)\n        # AND the element at position 'j' in the ORIGINAL input_list is 0.\n        while j < n and input_list[j] == 0:\n            # Update the corresponding position in the output_sequence with the single digit's value.\n            output_sequence[j] = val\n            j += 1 # Move one step further right.\n\n    # Return the modified output sequence as a list.\n    return output_sequence\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7343,
    "candidates_token_count": 1329,
    "total_token_count": 8672,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.67256,
  "retries": 1
}