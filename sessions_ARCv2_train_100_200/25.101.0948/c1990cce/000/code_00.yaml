task_type: pattern_generation
grid_properties:
  dimensionality: input 1D, output 2D
  input_width: variable (W)
  output_width: W (same as input)
  output_height: W (same as input)
  color_palette: [0, 1, 2] # white, blue, red
objects:
  - object_type: pixel
    properties:
      color: {0: white, 1: blue, 2: red}
      position: (row, column)
  - object_type: pattern
    description: A triangular/diamond shape originating from the initial red pixel, expanding downwards.
    generation_rule: Cellular automaton based on diagonal neighbors in the previous row.
relationships:
  - type: spatial
    description: Output grid dimensions are determined by input grid width.
  - type: generation
    description: Each row (r > 0) in the output grid is generated based on the state of the row above (r-1).
    rule: |
      A cell's state depends on the state of its top-left and top-right neighbors from the previous row.
actions:
  - action: copy
    actor: system
    target: input row
    result: output row 0
  - action: generate_pattern
    actor: system
    input: row r-1
    output: row r
    rule: |
      A cell (r, c) becomes non-white if exactly one of the cells (r-1, c-1) or (r-1, c+1) is non-white (XOR logic).
  - action: assign_color
    actor: system
    target: non-white cells generated by the pattern rule
    factors:
      - row index (r)
      - potentially predecessor colors/values
    observed_rule (partial):
      - If r=1 or r=2, color is red (2).
      - If r >= 3, color can be blue (1) or red (2), based on complex criteria. Cells where predecessors are both non-white become white (0).