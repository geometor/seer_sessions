{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms the input grid based on identified L-shapes of gray (5) or red (2) pixels.\n\n1.  Identify L-Shapes: Find all 2x2 squares containing exactly three pixels of the same color (gray 5 or red 2) and one background pixel (orange 7).\n2.  For each L-shape, determine:\n    - its color (gray or red).\n    - the coordinates of its corner pixel `C = (cr, cc)` (the shape pixel diagonally opposite the background pixel).\n    - the parity of `C` (odd/even for `cr` and `cc`).\n    - the coordinates of the missing background pixel `MP = (mr, mc)`.\n    - the relative position of MP to C: `relative_MP = (mr-cr, mc-cc)`.\n3.  Process Gray L-Shapes (color 5):\n    - If `relative_MP` is `(-1,-1)` or `(-1,+1)` (MP is \"above\" C):\n        - Secondary color is Green (3) if `C_parity` is (odd, odd), else Yellow (4).\n        - Add Yellow (4) at `MP+(-1,0)` and `MP`.\n        - Add the secondary color at `MP+(0,+1)` and `MP+(+1,+1)`.\n    - If `relative_MP` is `(+1,-1)` or `(+1,+1)` (MP is \"below\" C):\n        - Add Yellow (4) at `MP+(-1,-1)`, `MP+(0,-1)`, `MP`, and `MP+(+1,0)`.\n4.  Process Red L-Shapes (color 2):\n    - Based on `C_parity` (0=even, 1=odd) and `relative_MP`:\n        - If `C_parity`=(1, 1) and `relative_MP`=(-1,-1): Add Green (3) at `C+(0,+1)`.\n        - If `C_parity`=(0, 0) and `relative_MP`=(-1,+1): Add Green (3) at `C+(+1,0)`.\n        - If `C_parity`=(1, 0) and `relative_MP`=(+1,-1): Add Green (3) at `C+(-1,0)`, `C+(-1,+1)`, and `C+(0,+1)`.\n        - If `C_parity`=(0, 1) and `relative_MP`=(-1,+1): Add Green (3) at `C+(0,-1)`, `C+(+1,-1)`, and `C+(+1,0)`.\n5.  Add pixels only if the target cell is within grid bounds and contains the background color (7).\n\"\"\"\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies transformations based on identified Gray and Red L-shapes.\n    \"\"\"\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # Define colors\n    background_color = 7\n    gray = 5\n    red = 2\n    yellow = 4\n    green = 3\n\n    def is_valid(r, c):\n        \"\"\"Check if coordinates are within grid bounds.\"\"\"\n        return 0 <= r < height and 0 <= c < width\n\n    def add_pixel(grid, r, c, color):\n        \"\"\"Safely add a pixel if the location is valid and is background.\"\"\"\n        if is_valid(r, c) and grid[r][c] == background_color:\n            grid[r][c] = color\n\n    # Iterate through all possible top-left corners of 2x2 squares\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Coordinates of the 2x2 square\n            coords = [(r, c), (r + 1, c), (r, c + 1), (r + 1, c + 1)]\n            # Colors in the 2x2 square\n            colors = [input_grid[rr][cc] for rr, cc in coords]\n\n            # Count background and non-background pixels\n            non_bg_colors = [color for color in colors if color != background_color]\n            bg_coords = [coords[i] for i in range(4) if colors[i] == background_color]\n\n            # Check for exactly 3 identical non-background pixels (gray or red) and 1 background pixel\n            if len(non_bg_colors) == 3 and len(bg_coords) == 1 and len(set(non_bg_colors)) == 1:\n                shape_color = non_bg_colors[0]\n                if shape_color not in [gray, red]:\n                    continue # Skip if not gray or red\n\n                # Identify MP (Missing Pixel) coordinates\n                mr, mc = bg_coords[0]\n\n                # Identify C (Corner) coordinates (diagonally opposite MP)\n                cr, cc = -1, -1 # Initialize C coordinates\n                if (mr, mc) == (r, c): cr, cc = (r + 1, c + 1)\n                elif (mr, mc) == (r + 1, c): cr, cc = (r, c + 1)\n                elif (mr, mc) == (r, c + 1): cr, cc = (r + 1, c)\n                elif (mr, mc) == (r + 1, c + 1): cr, cc = (r, c)\n\n                # Calculate relative MP position and C parity\n                relative_mp = (mr - cr, mc - cc)\n                c_parity = (cr % 2, cc % 2) # (0=even, 1=odd)\n\n                # --- Process Gray L-Shapes ---\n                if shape_color == gray:\n                    if relative_mp[0] == -1: # MP is \"above\" C: relative_mp is (-1,-1) or (-1,+1)\n                        secondary_color = green if c_parity == (1, 1) else yellow # Green if C is odd,odd\n                        add_pixel(output_grid, mr - 1, mc, yellow)       # MP+(-1,0)\n                        add_pixel(output_grid, mr, mc, yellow)           # MP\n                        add_pixel(output_grid, mr, mc + 1, secondary_color) # MP+(0,+1)\n                        add_pixel(output_grid, mr + 1, mc + 1, secondary_color) # MP+(+1,+1)\n                    \n                    elif relative_mp[0] == 1: # MP is \"below\" C: relative_mp is (+1,-1) or (+1,+1)\n                        add_pixel(output_grid, mr - 1, mc - 1, yellow)  # MP+(-1,-1)\n                        add_pixel(output_grid, mr, mc - 1, yellow)      # MP+(0,-1)\n                        add_pixel(output_grid, mr, mc, yellow)          # MP\n                        add_pixel(output_grid, mr + 1, mc, yellow)      # MP+(+1,0)\n\n                # --- Process Red L-Shapes ---\n                elif shape_color == red:\n                    # Check specific combinations of C_parity and relative_MP based on analysis\n                    if c_parity == (1, 1) and relative_mp == (-1, -1): # odd,odd and MP top-left\n                        add_pixel(output_grid, cr, cc + 1, green)       # C+(0,+1)\n                    \n                    elif c_parity == (0, 0) and relative_mp == (-1, +1): # even,even and MP top-right\n                        add_pixel(output_grid, cr + 1, cc, green)       # C+(+1,0)\n                    \n                    elif c_parity == (1, 0) and relative_mp == (+1, -1): # odd,even and MP bottom-left\n                        # Add G L-shape opening Bottom-Left, corner C+(-1,+1)\n                        add_pixel(output_grid, cr - 1, cc, green)       # C+(-1,0)\n                        add_pixel(output_grid, cr - 1, cc + 1, green)   # C+(-1,+1)\n                        add_pixel(output_grid, cr, cc + 1, green)       # C+(0,+1)\n                        \n                    elif c_parity == (0, 1) and relative_mp == (-1, +1): # even,odd and MP top-right\n                        # Add G L-shape opening Top-Right, corner C+(+1,-1)\n                        add_pixel(output_grid, cr, cc - 1, green)       # C+(0,-1)\n                        add_pixel(output_grid, cr + 1, cc - 1, green)   # C+(+1,-1)\n                        add_pixel(output_grid, cr + 1, cc, green)       # C+(+1,0)\n                    \n                    # No action defined for other combinations based on examples\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15243,
    "candidates_token_count": 3033,
    "total_token_count": 18276,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.576177,
  "retries": 1
}