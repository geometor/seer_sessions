{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on identified L-shapes of gray (5) or red (2) pixels.\n\n    1.  Find all 3-pixel L-shapes (color 5 or 2) adjacent to a background pixel (7)\n        such that the L-shape and the background pixel form a 2x2 square.\n    2.  Identify the L-shape's color, its corner pixel 'C' (diagonally opposite the background pixel 'MP' in the 2x2),\n        and the coordinates of C=(r,c) and MP=(mr, mc).\n    3.  Process Gray L-shapes (color 5):\n        - If MP is above C (mr < r):\n            - Add pixels relative to MP: Y(4)@MP, Y(4)@MP+(-1,0).\n            - Add G(3)@MP+(0,+1) and G(3)@MP+(+1,+1) if C=(r,c) has r=odd and c=odd.\n            - Otherwise, add Y(4)@MP+(0,+1) and Y(4)@MP+(+1,+1).\n        - If MP is below C (mr > r):\n            - Add pixels relative to MP: Y(4)@MP, Y(4)@MP+(-1,-1), Y(4)@MP+(0,-1), Y(4)@MP+(+1,0).\n    4.  Process Red L-shapes (color 2):\n        - Based on the parity of the corner pixel C=(r,c):\n            - If r=even, c=even: Add G(3) at C+(+1,+1).\n            - If r=odd, c=odd: Add G(3) at C+(+1,+1). # Tentative based on (even,even) symmetry\n            - If r=even, c=odd: Add a G(3) L-shape with pixels C+(0,-1), C+(+1,-1), C+(+1,0).\n            - If r=odd, c=even: Add a G(3) L-shape with pixels C+(-1,0), C+(-1,+1), C+(0,+1).\n    5.  Added pixels only replace the background color (7).\n    \"\"\"\n\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 7\n    gray = 5\n    red = 2\n    yellow = 4\n    green = 3\n\n    def is_valid(r, c):\n        return 0 <= r < height and 0 <= c < width\n\n    def add_pixel(grid, r, c, color):\n        # Safely add a pixel if the location is valid and is background\n        if is_valid(r, c) and grid[r][c] == background_color:\n            grid[r][c] = color\n\n    # Find L-shapes\n    l_shapes = []\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Coordinates of the 2x2 square\n            coords = [(r, c), (r + 1, c), (r, c + 1), (r + 1, c + 1)]\n            # Colors in the 2x2 square\n            colors = [input_grid[rr][cc] for rr, cc in coords]\n\n            non_bg_colors = [color for color in colors if color != background_color]\n\n            # Check for 3 identical non-background pixels (gray or red) and 1 background pixel\n            if len(non_bg_colors) == 3 and len(set(non_bg_colors)) == 1:\n                shape_color = non_bg_colors[0]\n                if shape_color == gray or shape_color == red:\n                    mp_coord = None\n                    shape_pixels = []\n                    corner_coord = None\n\n                    # Find the background pixel (MP) and the shape pixels\n                    for i in range(4):\n                        if colors[i] == background_color:\n                            mp_coord = coords[i]\n                        else:\n                            shape_pixels.append(coords[i])\n\n                    # Find the corner pixel (C) - diagonally opposite MP\n                    if mp_coord == (r, c): corner_coord = (r + 1, c + 1)\n                    elif mp_coord == (r + 1, c): corner_coord = (r, c + 1)\n                    elif mp_coord == (r, c + 1): corner_coord = (r + 1, c)\n                    elif mp_coord == (r + 1, c + 1): corner_coord = (r, c)\n\n                    l_shapes.append({\n                        \"color\": shape_color,\n                        \"pixels\": shape_pixels,\n                        \"C\": corner_coord,\n                        \"MP\": mp_coord\n                    })\n\n    # Process L-shapes\n    for shape in l_shapes:\n        color = shape[\"color\"]\n        cr, cc = shape[\"C\"]\n        mr, mc = shape[\"MP\"]\n\n        if color == gray:\n            # Determine orientation based on MP relative to C\n            if mr < cr:  # MP is above C\n                use_green = (cr % 2 != 0 and cc % 2 != 0) # Check if C is odd, odd\n                secondary_color = green if use_green else yellow\n\n                # Add pixels based on Pattern A\n                add_pixel(output_grid, mr, mc, yellow)             # MP\n                add_pixel(output_grid, mr - 1, mc, yellow)         # MP+(-1,0)\n                add_pixel(output_grid, mr, mc + 1, secondary_color) # MP+(0,+1)\n                add_pixel(output_grid, mr + 1, mc + 1, secondary_color) # MP+(+1,+1)\n\n            elif mr > cr: # MP is below C\n                 # Add pixels based on Pattern B\n                add_pixel(output_grid, mr, mc, yellow)          # MP\n                add_pixel(output_grid, mr - 1, mc - 1, yellow)  # MP+(-1,-1)\n                add_pixel(output_grid, mr, mc - 1, yellow)      # MP+(0,-1)\n                add_pixel(output_grid, mr + 1, mc, yellow)      # MP+(+1,0)\n            # Cases mr == cr shouldn't happen if MP is above or below C\n\n        elif color == red:\n            # Determine action based on parity of corner C=(cr, cc)\n            is_r_even = (cr % 2 == 0)\n            is_c_even = (cc % 2 == 0)\n\n            if is_r_even and is_c_even:\n                # Rule: C=(even, even) -> Add G at C+(+1,+1)\n                add_pixel(output_grid, cr + 1, cc + 1, green)\n            elif not is_r_even and not is_c_even:\n                 # Rule: C=(odd, odd) -> Add G at C+(+1,+1) (Tentative)\n                add_pixel(output_grid, cr + 1, cc + 1, green)\n            elif is_r_even and not is_c_even:\n                 # Rule: C=(even, odd) -> Add G L-shape opening Top-Right\n                 # Pixels: C+(0,-1), C+(+1,-1), C+(+1,0)\n                 add_pixel(output_grid, cr, cc - 1, green)\n                 add_pixel(output_grid, cr + 1, cc - 1, green)\n                 add_pixel(output_grid, cr + 1, cc, green)\n            elif not is_r_even and is_c_even:\n                 # Rule: C=(odd, even) -> Add G L-shape opening Bottom-Left\n                 # Pixels: C+(-1,0), C+(-1,+1), C+(0,+1)\n                 add_pixel(output_grid, cr - 1, cc, green)\n                 add_pixel(output_grid, cr - 1, cc + 1, green)\n                 add_pixel(output_grid, cr, cc + 1, green)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3157,
    "candidates_token_count": 10968,
    "total_token_count": 14125,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 81.6108,
  "retries": 1
}