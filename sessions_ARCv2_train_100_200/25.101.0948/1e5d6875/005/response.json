{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms the input grid based on identified L-shapes of gray (5) or red (2) pixels.\n\n1.  Identify L-Shapes: Scan the input grid for all 2x2 squares containing exactly \n    three pixels of the same color (either gray 5 or red 2) and one background \n    pixel (orange 7).\n2.  For each such L-shape found, determine:\n    a.  The color of the L-shape (gray or red).\n    b.  The coordinates of the corner pixel `C = (cr, cc)` (the shape pixel \n        diagonally opposite the background pixel).\n    c.  The parity of `C` as `C_parity = (cr % 2, cc % 2)` (0=even, 1=odd).\n    d.  The coordinates of the missing background pixel `MP = (mr, mc)`.\n    e.  The relative position of MP to C: `relative_MP = (mr-cr, mc-cc)`.\n3.  Process Gray L-Shapes (color 5):\n    a.  If MP is \"above\" C (`relative_MP[0] == -1`):\n        i.  If `C_parity` is (odd, odd) (1, 1):\n            - Add Yellow (4) at `MP+(-1,0)` and `MP`.\n            - Add Green (3) at `MP+(0,+1)` and `MP+(+1,+1)`.\n        ii. Else (`C_parity` is not (odd, odd)):\n            - Add Yellow (4) at `MP+(-1,0)`, `MP`, and `MP+(0,+1)`.\n    b.  If MP is \"below\" C (`relative_MP[0] == 1`):\n        i.  Add Yellow (4) at `MP+(0,-1)`, `MP`, and `MP+(+1,0)`.\n4.  Process Red L-Shapes (color 2):\n    a.  Based on `C_parity` and `relative_MP`:\n        i.  If `C_parity`=(1, 1) and `relative_MP`=(-1,-1): Add Green (3) @ C+(0,+1).\n        ii. If `C_parity`=(0, 0) and `relative_MP`=(-1,+1): Add Green (3) @ C+(+1,0).\n        iii. If `C_parity`=(1, 0) and `relative_MP`=(+1,-1): Add Green (3) L-shape \n             opening Bottom-Left, corner C+(-1,+1). Pixels: C+(-1,0), C+(-1,+1), C+(0,+1).\n        iv. If `C_parity`=(0, 1) and `relative_MP`=(-1,+1): Add Green (3) L-shape \n             opening Top-Right, corner C+(+1,-1). Pixels: C+(0,-1), C+(+1,-1), C+(+1,0).\n        v.  Other combinations: No action.\n5.  Add pixels only if the target cell is within grid bounds and contains the \n    background color (7).\n\"\"\"\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies transformations based on identified Gray and Red L-shapes.\n    \"\"\"\n    # initialize output_grid\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # Define colors\n    background_color = 7\n    gray = 5\n    red = 2\n    yellow = 4\n    green = 3\n\n    # --- Helper Functions ---\n    def is_valid(r, c):\n        \"\"\"Check if coordinates are within grid bounds.\"\"\"\n        return 0 <= r < height and 0 <= c < width\n\n    def add_pixel(grid, r, c, color):\n        \"\"\"Safely add a pixel if the location is valid and is background.\"\"\"\n        if is_valid(r, c) and grid[r][c] == background_color:\n            grid[r][c] = color\n\n    # --- Main Transformation Logic ---\n\n    # Iterate through all possible top-left corners of 2x2 squares to find L-shapes\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Coordinates of the 2x2 square\n            coords = [(r, c), (r + 1, c), (r, c + 1), (r + 1, c + 1)]\n            # Colors in the 2x2 square\n            colors = [input_grid[rr][cc] for rr, cc in coords]\n\n            # Count background and non-background pixels\n            non_bg_colors = [color for color in colors if color != background_color]\n            bg_coords = [coords[i] for i in range(4) if colors[i] == background_color]\n\n            # Check for exactly 3 identical non-background pixels (gray or red) and 1 background pixel\n            if len(non_bg_colors) == 3 and len(bg_coords) == 1 and len(set(non_bg_colors)) == 1:\n                shape_color = non_bg_colors[0]\n                # Only consider Gray or Red L-shapes\n                if shape_color not in [gray, red]:\n                    continue \n\n                # Identify MP (Missing Pixel / background pixel) coordinates\n                mr, mc = bg_coords[0]\n\n                # Identify C (Corner pixel) coordinates (diagonally opposite MP)\n                cr, cc = -1, -1 # Initialize C coordinates\n                if (mr, mc) == (r, c): cr, cc = (r + 1, c + 1)\n                elif (mr, mc) == (r + 1, c): cr, cc = (r, c + 1)\n                elif (mr, mc) == (r, c + 1): cr, cc = (r + 1, c)\n                elif (mr, mc) == (r + 1, c + 1): cr, cc = (r, c)\n\n                # Calculate L-shape properties\n                relative_mp = (mr - cr, mc - cc) # Relative position of MP from C\n                c_parity = (cr % 2, cc % 2) # Parity of C coords (0=even, 1=odd)\n\n                # --- Process Gray L-Shapes ---\n                if shape_color == gray:\n                    # Case 1: MP is \"above\" C (relative_MP has -1 in the row component)\n                    if relative_mp[0] == -1: \n                        # Subcase 1.1: Corner C has (odd, odd) parity\n                        if c_parity == (1, 1): \n                            # Add 4 pixels: Y@MP+(-1,0), Y@MP, G@MP+(0,+1), G@MP+(+1,+1)\n                            add_pixel(output_grid, mr - 1, mc, yellow)       \n                            add_pixel(output_grid, mr, mc, yellow)           \n                            add_pixel(output_grid, mr, mc + 1, green) \n                            add_pixel(output_grid, mr + 1, mc + 1, green) \n                        # Subcase 1.2: Corner C does not have (odd, odd) parity\n                        else:\n                            # Add 3 pixels: Y@MP+(-1,0), Y@MP, Y@MP+(0,+1)\n                            add_pixel(output_grid, mr - 1, mc, yellow)\n                            add_pixel(output_grid, mr, mc, yellow)\n                            add_pixel(output_grid, mr, mc + 1, yellow)\n                            \n                    # Case 2: MP is \"below\" C (relative_MP has +1 in the row component)\n                    elif relative_mp[0] == 1: \n                        # Add 3 pixels: Y@MP+(0,-1), Y@MP, Y@MP+(+1,0)\n                        add_pixel(output_grid, mr, mc - 1, yellow)      \n                        add_pixel(output_grid, mr, mc, yellow)          \n                        add_pixel(output_grid, mr + 1, mc, yellow)      \n\n                # --- Process Red L-Shapes ---\n                elif shape_color == red:\n                    # Check specific combinations of C_parity and relative_MP based on analysis\n                    # Case 1: C=(odd, odd) and MP is top-left relative to C\n                    if c_parity == (1, 1) and relative_mp == (-1, -1): \n                        add_pixel(output_grid, cr, cc + 1, green)       # C+(0,+1)\n                    \n                    # Case 2: C=(even, even) and MP is top-right relative to C\n                    elif c_parity == (0, 0) and relative_mp == (-1, +1): \n                        add_pixel(output_grid, cr + 1, cc, green)       # C+(+1,0)\n                    \n                    # Case 3: C=(odd, even) and MP is bottom-left relative to C\n                    elif c_parity == (1, 0) and relative_mp == (+1, -1): \n                        # Add G L-shape opening Bottom-Left, corner C+(-1,+1)\n                        add_pixel(output_grid, cr - 1, cc, green)       # C+(-1,0)\n                        add_pixel(output_grid, cr - 1, cc + 1, green)   # C+(-1,+1)\n                        add_pixel(output_grid, cr, cc + 1, green)       # C+(0,+1)\n                        \n                    # Case 4: C=(even, odd) and MP is top-right relative to C\n                    elif c_parity == (0, 1) and relative_mp == (-1, +1): \n                        # Add G L-shape opening Top-Right, corner C+(+1,-1)\n                        add_pixel(output_grid, cr, cc - 1, green)       # C+(0,-1)\n                        add_pixel(output_grid, cr + 1, cc - 1, green)   # C+(+1,-1)\n                        add_pixel(output_grid, cr + 1, cc, green)       # C+(+1,0)\n                    \n                    # No action defined for other combinations based on examples\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23445,
    "candidates_token_count": 2719,
    "total_token_count": 26164,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.975627,
  "retries": 1
}