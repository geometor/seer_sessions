{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\n1. Identify the two foreground colors (non-orange/7) present in the input grid.\n2. For each foreground color:\n    a. Find all pixel locations.\n    b. Count how many unique grid edges (Top, Bottom, Left, Right) its pixels are adjacent to.\n3. Select the foreground color ('target_color') that touches the most unique grid edges. If there's a tie, select the color with the greater total number of pixels.\n4. Count the total number of pixels ('N') of the 'target_color'.\n5. Find the pair of integer factors (R, C) of N such that R * C = N and the absolute difference abs(R - C) is minimized. If there's a tie (e.g., (3,4) vs (4,3)), choose the pair with the smaller R. Let the chosen dimensions be 'Height = R' and 'Width = C'.\n6. For the 'target_color', count how many of its pixels touch each of the four grid edges (Top, Bottom, Left, Right).\n7. Identify the two edges with the highest contact counts. If there's a tie for the second highest count, use the priority order Top > Bottom > Left > Right to break the tie.\n8. Determine the 'target_corner' based on the two selected edges (e.g., Top and Right edges imply Top-Right corner).\n9. Create an output grid, initially a copy of the input grid.\n10. In the output grid, change all pixels that originally had the 'target_color' to the background color (orange/7).\n11. Draw a solid rectangle of 'target_color' with dimensions Height x Width in the 'target_corner' of the output grid.\n\"\"\"\n\ndef get_pixel_locations(grid, color):\n    \"\"\"Finds all locations (row, col) of a given color in the grid.\"\"\"\n    locations = []\n    for r, row in enumerate(grid):\n        for c, pixel in enumerate(row):\n            if pixel == color:\n                locations.append((r, c))\n    return locations\n\ndef get_unique_edge_contacts(grid_height, grid_width, locations):\n    \"\"\"Counts unique edges contacted by pixels at given locations.\"\"\"\n    edges = set()\n    for r, c in locations:\n        if r == 0:\n            edges.add('T')\n        if r == grid_height - 1:\n            edges.add('B')\n        if c == 0:\n            edges.add('L')\n        if c == grid_width - 1:\n            edges.add('R')\n    return len(edges)\n\ndef get_edge_contact_counts(grid_height, grid_width, locations):\n    \"\"\"Counts how many pixels contact each specific edge.\"\"\"\n    counts = {'T': 0, 'B': 0, 'L': 0, 'R': 0}\n    for r, c in locations:\n        if r == 0:\n            counts['T'] += 1\n        if r == grid_height - 1:\n            counts['B'] += 1\n        if c == 0:\n            counts['L'] += 1\n        if c == grid_width - 1:\n            counts['R'] += 1\n    return counts\n\ndef find_best_rectangle_shape(n):\n    \"\"\"Finds factors (R, C) of n minimizing abs(R-C), tie-breaking with smaller R.\"\"\"\n    best_shape = (0, 0)\n    min_diff = float('inf')\n\n    for r in range(1, int(math.sqrt(n)) + 1):\n        if n % r == 0:\n            c = n // r\n            diff = abs(r - c)\n            # Check factor pair (r, c)\n            if diff < min_diff:\n                min_diff = diff\n                best_shape = (r, c)\n            elif diff == min_diff:\n                # Tie-break: choose smaller R\n                if r < best_shape[0]:\n                    best_shape = (r, c)\n            \n            # Check factor pair (c, r) if r*r != n\n            if r * r != n:\n                diff_rc = abs(c - r) # same diff\n                if diff_rc < min_diff: # Should not happen if we proceed iteratively\n                     min_diff = diff_rc\n                     best_shape = (c, r)\n                elif diff_rc == min_diff:\n                    # Tie-break: choose smaller R (which is 'c' here)\n                     if c < best_shape[0]:\n                        best_shape = (c, r)\n\n    # Ensure best_shape is found (handles n=1 case)\n    if n==1: return (1,1)\n    if best_shape == (0,0) and n > 0 : # fallback for prime or other edge cases, though factors logic should cover it\n        factors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                 factors.append((i, n//i))\n        min_diff_fallback = float('inf')\n        for r_f, c_f in factors:\n            diff_f = abs(r_f - c_f)\n            if diff_f < min_diff_fallback:\n                 min_diff_fallback = diff_f\n                 best_shape = (r_f, c_f)\n            elif diff_f == min_diff_fallback:\n                 if r_f < best_shape[0]:\n                      best_shape = (r_f, c_f)\n                      \n    return best_shape\n\n\ndef determine_target_corner(edge_counts):\n    \"\"\"Determines the target corner based on the two highest edge contact counts.\"\"\"\n    # Sort edges by count descending, then by priority T > B > L > R for ties\n    edge_priority = {'T': 0, 'B': 1, 'L': 2, 'R': 3}\n    sorted_edges = sorted(edge_counts.keys(), key=lambda edge: (-edge_counts[edge], edge_priority[edge]))\n\n    edge1 = sorted_edges[0]\n    edge2 = sorted_edges[1]\n\n    # Determine corner based on the top two edges\n    if ('T' in [edge1, edge2] and 'L' in [edge1, edge2]): return 'TL'\n    if ('T' in [edge1, edge2] and 'R' in [edge1, edge2]): return 'TR'\n    if ('B' in [edge1, edge2] and 'L' in [edge1, edge2]): return 'BL'\n    if ('B' in [edge1, edge2] and 'R' in [edge1, edge2]): return 'BR'\n    \n    # Fallback/error case if logic somehow fails (shouldn't happen with 4 edges)\n    print(f\"Warning: Could not determine corner from edges: {edge1}, {edge2}\")\n    # Default based on highest edge? E.g. if only one edge has count > 0\n    if edge1 == 'T': return 'TL'\n    if edge1 == 'B': return 'BL'\n    if edge1 == 'L': return 'TL'\n    if edge1 == 'R': return 'TR'\n    return 'TL' # Default default\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by rearranging pixels of one foreground color \n    (chosen based on edge contact) into a rectangle in a corner (determined \n    by edge contact frequency).\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 7\n\n    # 1. Identify foreground colors\n    unique_colors = np.unique(input_np)\n    foreground_colors = [c for c in unique_colors if c != background_color]\n\n    # Ensure there are exactly two foreground colors as per problem description (or handle otherwise)\n    if len(foreground_colors) != 2:\n         # Handle error or unexpected input. For now, assume 2.\n         # If only one FG color, maybe it's automatically the target?\n         # If more than two, how to choose?\n         # Let's proceed assuming 2 for now based on examples.\n         if len(foreground_colors) == 0: return input_grid # No change if no FG\n         if len(foreground_colors) == 1: \n             target_color = foreground_colors[0]\n             other_color = -1 # Sentinel\n         else: # > 2, maybe pick first two? Arbitrary. Task likely implies 2.\n             foreground_colors = foreground_colors[:2]\n\n\n    # 2 & 3. Find target color based on unique edge contacts, tie-breaking with pixel count\n    color_data = {}\n    for color in foreground_colors:\n        locations = get_pixel_locations(input_np, color)\n        unique_edges = get_unique_edge_contacts(height, width, locations)\n        pixel_count = len(locations)\n        color_data[color] = {'locations': locations, 'unique_edges': unique_edges, 'count': pixel_count}\n\n    # Sort colors: primary key = unique_edges (desc), secondary key = count (desc)\n    sorted_colors = sorted(foreground_colors, key=lambda c: (color_data[c]['unique_edges'], color_data[c]['count']), reverse=True)\n    target_color = sorted_colors[0]\n    # Find the other color (the one not chosen)\n    other_color = next((c for c in foreground_colors if c != target_color), None)\n\n\n    # 4. Count pixels N of target_color\n    target_locations = color_data[target_color]['locations']\n    n = color_data[target_color]['count']\n    if n == 0: # If target color somehow has 0 pixels, return original grid\n        return input_grid\n\n    # 5. Determine rectangle shape (Height R, Width C)\n    rect_height, rect_width = find_best_rectangle_shape(n)\n\n    # 6. Calculate edge contact counts for target_color\n    edge_counts = get_edge_contact_counts(height, width, target_locations)\n\n    # 7 & 8. Determine target corner\n    target_corner = determine_target_corner(edge_counts)\n\n    # 9. Output grid is already initialized as a copy\n\n    # 10. Change original target_color pixels to background color\n    for r, c in target_locations:\n        output_np[r, c] = background_color\n\n    # 11. Draw the rectangle in the target corner\n    start_row, start_col = 0, 0\n    if target_corner == 'TL':\n        start_row, start_col = 0, 0\n    elif target_corner == 'TR':\n        start_row, start_col = 0, width - rect_width\n    elif target_corner == 'BL':\n        start_row, start_col = height - rect_height, 0\n    elif target_corner == 'BR':\n        start_row, start_col = height - rect_height, width - rect_width\n\n    for r in range(start_row, start_row + rect_height):\n        for c in range(start_col, start_col + rect_width):\n             # Check bounds just in case, although calculation should be correct\n            if 0 <= r < height and 0 <= c < width:\n                output_np[r, c] = target_color\n\n    # Convert back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3441,
    "candidates_token_count": 3582,
    "total_token_count": 7023,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.285438,
  "retries": 1
}