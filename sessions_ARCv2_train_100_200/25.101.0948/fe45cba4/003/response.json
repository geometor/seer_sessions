{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid according to the following rules:\n1. Identify foreground colors (non-background, typically non-7).\n2. For each foreground color, determine its pixel count, the number of unique grid edges it touches, and the count of pixels touching each specific edge.\n3. Select the 'target_color' as the one touching the most unique edges. Tie-break using the highest pixel count.\n4. Calculate the optimal rectangle shape (Height R, Width C) for the target_color's pixel count N, minimizing abs(R-C) and preferring smaller R in ties.\n5. Determine the 'target_corner' based on edge contact frequency: choose the vertical edge (T/B) with more contacts (T wins tie) and the horizontal edge (L/R) with more contacts (R wins tie). Combine them (e.g., T+R -> TR).\n6. Create an output grid, initially a copy of the input.\n7. Erase the original pixels of the target_color from the output grid by setting them to the background color.\n8. Draw a solid rectangle of the target_color with the calculated shape (R, C) in the determined target_corner.\n9. Pixels of other foreground colors remain unchanged.\n\"\"\"\n\ndef get_pixel_locations(grid: np.ndarray, color: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all locations (row, col) of a given color in the grid.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_unique_edge_contacts(grid_height: int, grid_width: int, locations: list[tuple[int, int]]) -> int:\n    \"\"\"Counts unique edges (T, B, L, R) contacted by pixels at given locations.\"\"\"\n    edges = set()\n    for r, c in locations:\n        if r == 0:\n            edges.add('T')\n        if r == grid_height - 1:\n            edges.add('B')\n        if c == 0:\n            edges.add('L')\n        if c == grid_width - 1:\n            edges.add('R')\n    return len(edges)\n\ndef get_edge_contact_counts(grid_height: int, grid_width: int, locations: list[tuple[int, int]]) -> dict[str, int]:\n    \"\"\"Counts how many pixels contact each specific edge.\"\"\"\n    counts = {'T': 0, 'B': 0, 'L': 0, 'R': 0}\n    for r, c in locations:\n        if r == 0:\n            counts['T'] += 1\n        if r == grid_height - 1:\n            counts['B'] += 1\n        if c == 0:\n            counts['L'] += 1\n        if c == grid_width - 1:\n            counts['R'] += 1\n    return counts\n\ndef find_best_rectangle_shape(n: int) -> tuple[int, int]:\n    \"\"\"Finds factors (R, C) of n minimizing abs(R-C), tie-breaking with smaller R.\"\"\"\n    if n == 0:\n        return (0, 0)\n    if n == 1:\n        return (1, 1)\n        \n    factors = []\n    for r in range(1, int(math.sqrt(n)) + 1):\n        if n % r == 0:\n            c = n // r\n            factors.append((r, c))\n            if r * r != n: # Avoid adding square root twice if n is a perfect square\n                factors.append((c, r))\n\n    best_shape = (0, 0)\n    min_diff = float('inf')\n\n    # Sort factors primarily by difference, secondarily by row (height)\n    factors.sort(key=lambda pair: (abs(pair[0] - pair[1]), pair[0]))\n    \n    if not factors: # Should not happen for n > 0, but as a fallback\n         return (1, n)\n\n    best_shape = factors[0]\n    return best_shape\n\n\ndef determine_target_corner(edge_counts: dict[str, int]) -> str:\n    \"\"\"Determines the target corner based on the highest vertical and horizontal edge contact counts.\"\"\"\n    # Vertical Edge: T vs B (T preferred on tie: >=)\n    vert_edge = 'T' if edge_counts['T'] >= edge_counts['B'] else 'B'\n        \n    # Horizontal Edge: R vs L (R preferred on tie: >=)\n    horiz_edge = 'R' if edge_counts['R'] >= edge_counts['L'] else 'L'\n\n    # Combine\n    return vert_edge + horiz_edge\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Convert to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    \n    # Define background color (assuming 7 based on examples)\n    background_color = 7\n\n    # 1. Identify foreground colors\n    unique_colors, counts = np.unique(input_np, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n    foreground_colors = [c for c in unique_colors if c != background_color]\n\n    # Handle cases with 0 or 1 foreground color\n    if not foreground_colors:\n        return input_grid # No foreground colors, return original\n    \n    target_color = -1\n    target_locations = []\n    \n    if len(foreground_colors) == 1:\n        target_color = foreground_colors[0]\n        target_locations = get_pixel_locations(input_np, target_color)\n    else:\n        # 2 & 3. Find target color based on unique edge contacts, tie-breaking with pixel count\n        color_data = {}\n        for color in foreground_colors:\n            locations = get_pixel_locations(input_np, color)\n            unique_edges = get_unique_edge_contacts(height, width, locations)\n            pixel_count = len(locations) # Use actual locations length\n            color_data[color] = {'locations': locations, 'unique_edges': unique_edges, 'count': pixel_count}\n\n        # Sort colors: primary key = unique_edges (desc), secondary key = count (desc)\n        sorted_colors = sorted(foreground_colors, key=lambda c: (color_data[c]['unique_edges'], color_data[c]['count']), reverse=True)\n        target_color = sorted_colors[0]\n        target_locations = color_data[target_color]['locations']\n\n    # 4. Count pixels N of target_color\n    n = len(target_locations)\n    if n == 0: # If target color somehow has 0 pixels, return original grid\n        return input_grid\n\n    # 5. Determine rectangle shape (Height R, Width C)\n    rect_height, rect_width = find_best_rectangle_shape(n)\n\n    # 6. Calculate edge contact counts for target_color\n    edge_counts = get_edge_contact_counts(height, width, target_locations)\n\n    # 7 & 8. Determine target corner using the revised logic\n    target_corner = determine_target_corner(edge_counts)\n\n    # 9. Output grid is already initialized as a copy\n\n    # 10. Change original target_color pixels to background color\n    # Use numpy indexing for efficiency\n    if target_locations: # Ensure there are locations to change\n        rows, cols = zip(*target_locations)\n        output_np[rows, cols] = background_color\n\n    # 11. Draw the rectangle in the target corner\n    start_row, start_col = 0, 0\n    if target_corner == 'TL':\n        start_row, start_col = 0, 0\n    elif target_corner == 'TR':\n        start_row, start_col = 0, width - rect_width\n    elif target_corner == 'BL':\n        start_row, start_col = height - rect_height, 0\n    elif target_corner == 'BR':\n        start_row, start_col = height - rect_height, width - rect_width\n\n    # Define the slice for the rectangle\n    end_row = start_row + rect_height\n    end_col = start_col + rect_width\n    \n    # Ensure slices are within bounds (although calculations should make this unnecessary)\n    start_row = max(0, start_row)\n    start_col = max(0, start_col)\n    end_row = min(height, end_row)\n    end_col = min(width, end_col)\n\n    # Fill the rectangle slice with the target color\n    output_np[start_row:end_row, start_col:end_col] = target_color\n\n    # Convert back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14031,
    "candidates_token_count": 2927,
    "total_token_count": 16958,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.314547,
  "retries": 1
}