{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation rule identifies a specific pattern in the lowest non-zero row ('r') of the input grid and adds new colored cells based on this pattern. The original cells are preserved.\n\n1. Find the bottom-most row 'r' containing any non-zero values. If r is 0 or no non-zero row exists, the grid remains unchanged.\n2. Identify all unique non-zero colors present in row 'r'. Iterate through these colors as potential flanker colors 'F'.\n3. For the *first* color 'F' encountered in this iteration that allows the formation of a valid pattern (detailed below), proceed to step 4. If no color 'F' leads to a valid pattern, return the original grid copy.\n    a. Find the minimum column index 'c_left' and the maximum column index 'c_right' such that input_grid[r, c_left] == F and input_grid[r, c_right] == F. If 'c_left >= c_right - 1', this 'F' cannot form a valid pattern with sufficient space between flankers.\n    b. Search for the *first* contiguous horizontal segment of a single non-zero color 'C' (where C != F) located strictly between 'c_left' and 'c_right' (i.e., in columns 'c_left + 1' to 'c_right - 1'). Let this segment span columns 'c_start' to 'c_end'. If no such segment 'C' is found, this 'F' cannot form a valid pattern.\n    c. Verify that all cells in row 'r' between 'c_left' and 'c_start' (i.e., columns 'c_left + 1' to 'c_start - 1', if any) have the color 'F'. If not, this 'F' is invalid.\n    d. Verify that all cells in row 'r' between 'c_end' and 'c_right' (i.e., columns 'c_end + 1' to 'c_right - 1', if any) have the color 'F'. If not, this 'F' is invalid.\n    e. Verify that all cells in row 'r-1' directly above the contained segment 'C' (i.e., columns 'c_start' to 'c_end') have the color 'F'. If not, this 'F' is invalid.\n    f. If all checks (a-e) pass, then this 'F' forms a valid pattern using the identified 'c_left', 'c_right', 'C', 'c_start', 'c_end'. Store these details.\n4. Determine if the found contained segment 'C' touches both flankers 'F' based on the widest pair coordinates: 'touches_flankers = (c_start == c_left + 1 AND c_end == c_right - 1)'.\n5. Apply the placement rule based on 'touches_flankers':\n    a. If 'touches_flankers' is true (Rule Type 1):\n        i. Set output_grid[r-2, c_left] = C (if r-2 >= 0 and c_left is within bounds).\n        ii. Set output_grid[r-2, c_right] = C (if r-2 >= 0 and c_right is within bounds).\n    b. If 'touches_flankers' is false (Rule Type 2):\n        i. Set output_grid[r-3, c_left] = C (if r-3 >= 0 and c_left is within bounds).\n        ii. Set output_grid[r-3, c_right] = C (if r-3 >= 0 and c_right is within bounds).\n        iii. Set output_grid[r-2, c_left + 1] = C (if r-2 >= 0 and c_left + 1 is within bounds).\n        iv. Set output_grid[r-2, c_right - 1] = C (if r-2 >= 0 and c_right - 1 is within bounds).\n6. Return the modified output_grid.\n\"\"\"\n\ndef find_lowest_non_zero_row(grid: np.ndarray) -> int:\n    \"\"\"Finds the index of the lowest row containing at least one non-zero value.\"\"\"\n    rows, _ = grid.shape\n    for r in range(rows - 1, -1, -1):\n        if np.any(grid[r, :] != 0):\n            return r\n    return -1 # No non-zero row found\n\ndef check_row_segment(grid: np.ndarray, r: int, c_start: int, c_end: int, expected_color: int) -> bool:\n    \"\"\"Checks if all cells in a horizontal segment have the expected color, handling boundaries.\"\"\"\n    # If the segment is empty (c_start > c_end), it's vacuously true.\n    if c_start > c_end:\n        return True\n\n    rows, cols = grid.shape\n    # Check row bounds first\n    if r < 0 or r >= rows:\n        return False\n    # Check column bounds - ensure the entire segment is within grid limits\n    if c_start < 0 or c_end >= cols:\n        return False\n\n    return np.all(grid[r, c_start:c_end+1] == expected_color)\n\ndef find_widest_flanker_pair(grid_row: np.ndarray, flanker_color: int) -> tuple[int, int]:\n    \"\"\"Finds the min and max column indices for a given flanker color.\"\"\"\n    indices = np.where(grid_row == flanker_color)[0]\n    if len(indices) >= 2:\n        return indices[0], indices[-1]\n    else:\n        return -1, -1 # Not enough flankers found\n\ndef find_first_contained_segment(grid_row: np.ndarray, c_left: int, c_right: int, flanker_color: int) -> tuple[int, int, int]:\n    \"\"\"Finds the first contiguous segment of a color different from flanker_color between c_left and c_right.\"\"\"\n    for c in range(c_left + 1, c_right):\n        cell_color = grid_row[c]\n        if cell_color != 0 and cell_color != flanker_color:\n            # Found the start of a potential C segment\n            contained_color = cell_color\n            c_start = c\n            c_end = c\n            # Extend the segment to find its end\n            for c_extend in range(c + 1, c_right):\n                if grid_row[c_extend] == contained_color:\n                    c_end = c_extend\n                else:\n                    break # End of contiguous C segment found\n            return contained_color, c_start, c_end # Return first found segment\n    return -1, -1, -1 # No contained segment found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Find the lowest non-zero row 'r'\n    r = find_lowest_non_zero_row(grid)\n\n    # Pattern requires checks in r-1, so r must be at least 1.\n    if r <= 0:\n        return output_grid.tolist() # Return the original grid copy\n\n    # 2. Identify potential flanker colors and iterate\n    row_r = grid[r]\n    potential_flanker_colors = np.unique(row_r[row_r != 0])\n    \n    found_pattern = None\n\n    for F in potential_flanker_colors:\n        # 3a. Find widest flanker pair for this color F\n        c_left, c_right = find_widest_flanker_pair(row_r, F)\n\n        # Need at least one cell between the widest flankers\n        if c_left == -1 or c_left >= c_right - 1:\n            continue # This color F cannot form a valid wide pair\n\n        # 3b. Find the first contained segment C between the widest flankers\n        C, c_start, c_end = find_first_contained_segment(row_r, c_left, c_right, F)\n\n        if C == -1:\n            continue # No contained segment C found for this F\n\n        # 3c. Verify intermediate F's before C\n        if not check_row_segment(grid, r, c_left + 1, c_start - 1, F):\n            continue # Failed check\n\n        # 3d. Verify intermediate F's after C\n        if not check_row_segment(grid, r, c_end + 1, c_right - 1, F):\n            continue # Failed check\n\n        # 3e. Verify F's in row r-1 above C\n        if not check_row_segment(grid, r - 1, c_start, c_end, F):\n            continue # Failed check\n\n        # --- Pattern Confirmed for this F ---\n        # Store details and break the loop (process only the first valid F found)\n        found_pattern = {\n            \"F\": F, \"C\": C, \"r\": r,\n            \"c_left\": c_left, \"c_right\": c_right,\n            \"c_start\": c_start, \"c_end\": c_end\n        }\n        break\n\n    # 4, 5. If a valid pattern was found, apply placement rules\n    if found_pattern:\n        # Extract pattern details\n        C = found_pattern[\"C\"]\n        r = found_pattern[\"r\"]\n        c_left = found_pattern[\"c_left\"]\n        c_right = found_pattern[\"c_right\"]\n        c_start = found_pattern[\"c_start\"]\n        c_end = found_pattern[\"c_end\"]\n\n        # Determine if C touches the *widest* flankers\n        touches_flankers = (c_start == c_left + 1 and c_end == c_right - 1)\n\n        # Apply Rule Type 1 or 2 based on whether C touches the flankers\n        if touches_flankers:\n            # Rule Type 1: Add C at (r-2, c_left) and (r-2, c_right)\n            if r - 2 >= 0:\n                if 0 <= c_left < cols:\n                     output_grid[r - 2, c_left] = C\n                if 0 <= c_right < cols:\n                     output_grid[r - 2, c_right] = C\n        else:\n            # Rule Type 2: Add C at (r-3, c_left), (r-3, c_right), (r-2, c_left+1), (r-2, c_right-1)\n            # Check bounds before assignment for row r-3\n            if r - 3 >= 0:\n                if 0 <= c_left < cols:\n                    output_grid[r - 3, c_left] = C\n                if 0 <= c_right < cols:\n                    output_grid[r - 3, c_right] = C\n            # Check bounds before assignment for row r-2\n            if r - 2 >= 0:\n                if 0 <= c_left + 1 < cols:\n                    output_grid[r - 2, c_left + 1] = C\n                if 0 <= c_right - 1 < cols: # Check both bounds for c_right-1\n                     output_grid[r - 2, c_right - 1] = C\n\n    # 6. Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17403,
    "candidates_token_count": 3349,
    "total_token_count": 20752,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.85253,
  "retries": 1
}