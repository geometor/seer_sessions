{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation rule operates on a 2D grid of digits. It identifies horizontal\nseparator rows (all 4s) and vertical separator columns (containing 4s in horizontal\nseparator rows). These separators define horizontal segments and vertical regions\nwithin the grid.\n\nThe core logic involves replacing placeholder digits '1' with 'key' digits\n(non-zero, non-1, non-4, i.e., 2, 3, 5, 6, 7, 8). The replacement rule depends\non the number of unique key digits found within each horizontal segment:\n\n1.  **One Unique Key:** If a segment contains exactly one unique key digit, all\n    '1's within that segment are replaced by that single key digit.\n2.  **Zero Unique Keys:** If a segment contains no key digits (only 0s, 1s, and 4s),\n    each '1' within that segment is replaced by the key digit associated with its\n    corresponding vertical region in the *most recently processed segment that\n    contained keys*.\n3.  **Multiple Unique Keys:** If a segment contains more than one unique key digit,\n    the '1's within that segment remain unchanged.\n\nKey digits within a segment are associated with the vertical region they reside in.\nThe first key digit encountered when scanning a region (top-to-bottom,\nleft-to-right within rows) is typically used to define the region's key for\nthat segment. This region-to-key mapping is stored (in key_memory) and potentially\nused by subsequent segments that lack their own keys. Horizontal separator rows\nremain unchanged in the output.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _find_horizontal_separators(grid: np.ndarray) -> list[int]:\n    \"\"\"Finds the indices of rows that consist entirely of the separator digit (4).\"\"\"\n    separator_rows = []\n    separator_value = 4\n    # Iterate through rows and check if all elements are the separator value\n    for r_idx, row in enumerate(grid):\n        if np.all(row == separator_value):\n            separator_rows.append(r_idx)\n    return separator_rows\n\ndef _find_vertical_separators(grid: np.ndarray, horizontal_separator_rows: list[int]) -> list[int]:\n    \"\"\"Finds the indices of columns that contain the separator digit (4) in at least one horizontal separator row.\"\"\"\n    separator_cols = set() # Use a set to automatically handle duplicates\n    separator_value = 4\n    # If there are no horizontal separators, there can be no vertical separators defined by them\n    if not horizontal_separator_rows: \n        return []\n\n    num_cols = grid.shape[1]\n    # Check each column\n    for c_idx in range(num_cols):\n        # Check if this column contains a separator value in any of the horizontal separator rows\n        for r_idx in horizontal_separator_rows:\n             # Ensure row index is valid before accessing grid element\n            if 0 <= r_idx < grid.shape[0] and grid[r_idx, c_idx] == separator_value:\n                separator_cols.add(c_idx)\n                break # Found a separator in this column, no need to check other rows\n    return sorted(list(separator_cols)) # Return a sorted list of unique column indices\n\ndef _get_vertical_region_index(col: int, vertical_separator_cols: list[int]) -> int:\n    \"\"\"Determines the 0-based vertical region index for a given column index.\"\"\"\n    region_index = 0\n    # Iterate through the separator column indices\n    for sep_col in vertical_separator_cols:\n        # If the column is to the left of the current separator, it belongs to the current region index\n        if col < sep_col:\n            return region_index\n        # Otherwise, it's in a region further to the right\n        region_index += 1\n    # If the column is not less than any separator column, it's in the last region\n    return region_index\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list-of-lists to numpy array for efficient operations\n    grid_np = np.array(input_grid, dtype=int)\n    # Initialize the output grid as a copy of the input\n    # Modifications will be made directly to this copy\n    output_grid_np = grid_np.copy()\n    num_rows, num_cols = grid_np.shape\n\n    # Identify horizontal and vertical separators using helper functions\n    horizontal_separator_rows = _find_horizontal_separators(grid_np)\n    vertical_separator_cols = _find_vertical_separators(grid_np, horizontal_separator_rows)\n\n    # Initialize memory to store region-to-key mapping from the last segment containing keys\n    key_memory = {}\n\n    # Define segment boundaries based on horizontal separators\n    # Start indices include 0 and the row after each separator\n    segment_starts = [0] + [r + 1 for r in horizontal_separator_rows]\n    # End indices include the separator rows themselves and the total number of rows\n    segment_ends = [r for r in horizontal_separator_rows] + [num_rows]\n\n    # Define the set of digits that act as keys\n    key_digits = {2, 3, 5, 6, 7, 8} \n\n    # Iterate through each horizontal segment\n    for i in range(len(segment_starts)):\n        r_start = segment_starts[i]\n        r_end = segment_ends[i]\n\n        # Skip processing for empty segments or rows that are themselves separators\n        if r_start >= r_end or r_start in horizontal_separator_rows:\n            continue \n\n        # Analyze the current segment using the *original* input grid\n        unique_keys_in_segment = set()\n        current_segment_region_keys = {}\n\n        # Scan cells within the segment to find keys and map them to regions\n        for r in range(r_start, r_end):\n            for c in range(num_cols):\n                val = grid_np[r, c]\n                # Check if the cell value is a key digit\n                if val in key_digits:\n                    # Record the unique key\n                    unique_keys_in_segment.add(val)\n                    # Determine the vertical region index for this key\n                    v_idx = _get_vertical_region_index(c, vertical_separator_cols)\n                    # Store the first key found for each region within this segment\n                    if v_idx not in current_segment_region_keys:\n                        current_segment_region_keys[v_idx] = val\n\n        # Determine the number of unique keys found in this segment\n        num_unique_keys = len(unique_keys_in_segment)\n\n        # Apply replacement rules based on the number of unique keys (modify output_grid_np)\n        if num_unique_keys == 1:\n            # Rule 1: Single unique key -> replace all '1's in this segment with this key\n            segment_key = list(unique_keys_in_segment)[0]\n            for r in range(r_start, r_end):\n                for c in range(num_cols):\n                    # Check the original grid for placeholder '1'\n                    if grid_np[r, c] == 1:\n                        # Modify the output grid\n                        output_grid_np[r, c] = segment_key\n        elif num_unique_keys == 0:\n            # Rule 2: No unique keys -> replace '1's using key_memory based on region\n            # Only attempt replacement if key_memory is not empty\n            if key_memory: \n                for r in range(r_start, r_end):\n                    for c in range(num_cols):\n                        # Check the original grid for placeholder '1'\n                        if grid_np[r, c] == 1:\n                            v_idx = _get_vertical_region_index(c, vertical_separator_cols)\n                            # If this region had a key in the last relevant segment, replace '1'\n                            if v_idx in key_memory:\n                                # Modify the output grid\n                                output_grid_np[r, c] = key_memory[v_idx]\n        # else num_unique_keys > 1:\n            # Rule 3: Multiple unique keys -> do nothing. \n            # '1's remain unchanged as they were copied initially.\n            pass\n\n        # Update the key memory *if* keys were found in the current segment\n        # This memory will be used by subsequent segments that have zero keys.\n        if current_segment_region_keys: # Check if the map is non-empty (i.e., keys were found)\n            key_memory = current_segment_region_keys.copy() # Use copy to store the state for the next iteration\n\n    # Convert the final numpy array back to a standard list of lists for the return value\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15829,
    "candidates_token_count": 2912,
    "total_token_count": 18741,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.517191,
  "retries": 1
}