{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation rule operates on a 2D grid of digits. It identifies horizontal\nseparator rows (all 4s) and vertical separator columns (containing 4s in horizontal\nseparator rows). These separators define horizontal segments and vertical regions\nwithin the grid.\n\nThe core logic involves replacing placeholder digits '1' with 'key' digits\n(non-zero, non-1, non-4, i.e., 2, 3, 5, 6, 7, 8). The replacement rule depends\non the number of unique key digits found within each horizontal segment:\n\n1.  **One Unique Key:** If a segment contains exactly one unique key digit, all\n    '1's within that segment are replaced by that single key digit.\n2.  **Zero Unique Keys:** If a segment contains no key digits (only 0s, 1s, and 4s),\n    each '1' within that segment is replaced by the key digit associated with its\n    corresponding vertical region in the *most recently processed segment that\n    contained keys*.\n3.  **Multiple Unique Keys:** If a segment contains more than one unique key digit,\n    the '1's within that segment remain unchanged.\n\nKey digits within a segment are associated with the vertical region they reside in.\nThe first key digit encountered when scanning a region (top-to-bottom,\nleft-to-right within rows) is typically used to define the region's key for\nthat segment. This region-to-key mapping is stored (in key_memory) and potentially\nused by subsequent segments that lack their own keys. Horizontal separator rows\nremain unchanged in the output.\n\"\"\"\n\n\ndef _find_horizontal_separators(grid: np.ndarray) -> list[int]:\n    \"\"\"Finds the indices of rows that consist entirely of the separator digit (4).\"\"\"\n    separator_rows = []\n    separator_value = 4\n    for r_idx, row in enumerate(grid):\n        if np.all(row == separator_value):\n            separator_rows.append(r_idx)\n    return separator_rows\n\ndef _find_vertical_separators(grid: np.ndarray, horizontal_separator_rows: list[int]) -> list[int]:\n    \"\"\"Finds the indices of columns that contain the separator digit (4) in at least one horizontal separator row.\"\"\"\n    separator_cols = set() # Use a set to automatically handle duplicates\n    separator_value = 4\n    if not horizontal_separator_rows: # No horizontal separators, thus no vertical separators defined by them\n        return []\n\n    num_cols = grid.shape[1]\n    for c_idx in range(num_cols):\n        is_separator = False\n        for r_idx in horizontal_separator_rows:\n             # Ensure r_idx is within grid bounds\n            if 0 <= r_idx < grid.shape[0] and grid[r_idx, c_idx] == separator_value:\n                is_separator = True\n                break\n        if is_separator:\n            separator_cols.add(c_idx)\n    return sorted(list(separator_cols)) # Return sorted list\n\ndef _get_vertical_region_index(col: int, vertical_separator_cols: list[int]) -> int:\n    \"\"\"Determines the vertical region index for a given column index.\"\"\"\n    region_index = 0\n    for sep_col in vertical_separator_cols:\n        if col < sep_col:\n            return region_index\n        region_index += 1\n    # Column is in the last region (or the only region if no separators)\n    return region_index\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid_np = grid_np.copy()\n    num_rows, num_cols = grid_np.shape\n\n    # Identify horizontal and vertical separators\n    horizontal_separator_rows = _find_horizontal_separators(grid_np)\n    vertical_separator_cols = _find_vertical_separators(grid_np, horizontal_separator_rows)\n\n    # Initialize the memory for the region-key mapping from the last valid segment\n    key_memory = {}\n\n    # Define segment boundaries\n    segment_starts = [0] + [r + 1 for r in horizontal_separator_rows]\n    segment_ends = [r for r in horizontal_separator_rows] + [num_rows]\n\n    # Define the set of possible key digits\n    key_digits = {2, 3, 5, 6, 7, 8} # Digits that act as keys\n\n    # Iterate through horizontal segments\n    for i in range(len(segment_starts)):\n        r_start = segment_starts[i]\n        r_end = segment_ends[i]\n\n        # Skip empty segments or separator rows themselves\n        if r_start >= r_end or r_start in horizontal_separator_rows:\n            continue # Separator rows are already copied, and empty segments need no processing\n\n        # Analyze the current segment (from the original input grid)\n        unique_keys_in_segment = set()\n        current_segment_region_keys = {}\n\n        # Find all keys and their region mapping within the current segment\n        for r in range(r_start, r_end):\n            for c in range(num_cols):\n                val = grid_np[r, c]\n                if val in key_digits:\n                    # Found a key digit\n                    unique_keys_in_segment.add(val)\n                    v_idx = _get_vertical_region_index(c, vertical_separator_cols)\n                    # Store the first key found for each region within this segment\n                    if v_idx not in current_segment_region_keys:\n                        current_segment_region_keys[v_idx] = val\n\n        # Apply replacement rules based on the number of unique keys found in this segment\n        num_unique_keys = len(unique_keys_in_segment)\n\n        if num_unique_keys == 1:\n            # Rule 1: Single unique key -> replace all 1s in the output grid with this key\n            segment_key = list(unique_keys_in_segment)[0]\n            for r in range(r_start, r_end):\n                for c in range(num_cols):\n                    if grid_np[r, c] == 1: # Check original grid for placeholder\n                        output_grid_np[r, c] = segment_key # Modify output grid\n        elif num_unique_keys == 0:\n            # Rule 2: No unique keys -> replace 1s using memory from previous segments\n            if key_memory: # Only replace if we have memory\n                for r in range(r_start, r_end):\n                    for c in range(num_cols):\n                        if grid_np[r, c] == 1: # Check original grid for placeholder\n                            v_idx = _get_vertical_region_index(c, vertical_separator_cols)\n                            if v_idx in key_memory:\n                                output_grid_np[r, c] = key_memory[v_idx] # Modify output grid\n        # else num_unique_keys > 1:\n            # Rule 3: Multiple unique keys -> do nothing to 1s in this segment\n            # The output grid already has the copied 1s, so no action needed.\n            pass\n\n        # Update the key memory *if* keys were found in the current segment\n        if current_segment_region_keys: # Check if the map is non-empty\n            key_memory = current_segment_region_keys.copy()\n            # Use copy() to ensure the memory is not just a reference that might change later\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15599,
    "candidates_token_count": 2254,
    "total_token_count": 17853,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.13379,
  "retries": 1
}