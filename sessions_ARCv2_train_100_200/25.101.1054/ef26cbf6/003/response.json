{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on region analysis and color replacement rules.\n\n1.  The grid is partitioned into contiguous regions of non-yellow (4) pixels, using yellow pixels as boundaries.\n2.  Regions are classified as either 'source' or 'target':\n    - A 'source region' contains exactly one pixel of a unique color (not white 0, yellow 4, or blue 1) and no blue pixels. Its unique color is the 'source color'.\n    - A 'target region' contains one or more blue (1) pixels and no other unique non-white/yellow colors.\n3.  A correspondence is established between each target region and exactly one source region based on adjacency across a yellow separator:\n    - Priority is implicitly given by the grid layout (either vertical or horizontal adjacency applies).\n    - Vertical Adjacency: The source region is immediately above the target region, separated by a continuous horizontal segment of yellow pixels along their shared boundary.\n    - Horizontal Adjacency: The source region is immediately to the left of the target region, separated by a continuous vertical segment of yellow pixels along their shared boundary.\n4.  All blue (1) pixels within each target region are replaced in the output grid by the source color of its corresponding source region.\n5.  All other pixels (white, yellow, source colors) remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef _get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\" Get 4-directional neighbors within grid bounds \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_regions(grid: np.ndarray) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds connected regions of non-yellow(4) cells using BFS.\n    Yellow cells act as boundaries and are not part of any region.\n    Returns a list of sets, where each set contains the (row, col) coordinates of a region.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS only if cell is not yellow and not visited\n            if grid[r, c] != 4 and not visited[r, c]:\n                region_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    region_coords.add((row, col))\n\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(row, col, height, width):\n                        # Add neighbor to queue if valid, not yellow, and not visited\n                        if grid[nr, nc] != 4 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if region_coords:\n                    regions.append(region_coords)\n    return regions\n\ndef _calculate_bounding_box(coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\" Calculates min_row, min_col, max_row, max_col for a set of coordinates \"\"\"\n    if not coords:\n        return -1, -1, -1, -1 # Indicate empty region\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef _analyze_regions(grid: np.ndarray, regions: list[set[tuple[int, int]]]) -> list[dict]:\n    \"\"\"\n    Analyzes each region to find its properties:\n    - coords: set of (row, col) tuples in the region.\n    - blue_coords: list of coordinates containing blue (1) pixels, or None.\n    - source_color: the unique non-white(0)/yellow(4)/blue(1) color, if one exists, or None.\n    - bbox: bounding box tuple (min_r, min_c, max_r, max_c).\n    \"\"\"\n    region_data = []\n    for i, coords in enumerate(regions):\n        blue_coords_list = []\n        # Using a set to find unique non-white/yellow/blue colors easily\n        other_colors = set()\n\n        for r, c in coords:\n            color = grid[r, c]\n            if color == 1: # Blue\n                blue_coords_list.append((r, c))\n            # Check for potential source color (not white, yellow, or blue)\n            elif color not in [0, 4]:\n                other_colors.add(color)\n\n        source_color = None\n        # A region is a source only if it has exactly one unique 'other' color AND no blue pixels.\n        if len(other_colors) == 1 and not blue_coords_list:\n             source_color = list(other_colors)[0] # Get the single element\n\n        bbox = _calculate_bounding_box(coords)\n\n        region_data.append({\n            'id': i, # Assign an ID for potential debugging\n            'coords': coords,\n            # Store list if blue found, else None\n            'blue_coords': blue_coords_list if blue_coords_list else None,\n            'source_color': source_color,\n            'bbox': bbox\n        })\n    return region_data\n\ndef _is_horizontal_separator(grid: np.ndarray, r: int, c1: int, c2: int) -> bool:\n    \"\"\" Checks if row r between columns c1 and c2 (inclusive) is entirely yellow(4) \"\"\"\n    height, width = grid.shape\n    if r < 0 or r >= height: return False # Row out of bounds\n    # Ensure column indices are valid and within grid bounds\n    c_start = max(0, c1)\n    c_end = min(width - 1, c2)\n    if c_start > c_end: return False # No valid column range to check (e.g., if c1 > c2)\n\n    # Check if all cells in the specified range within the row are yellow\n    return np.all(grid[r, c_start : c_end + 1] == 4)\n\ndef _is_vertical_separator(grid: np.ndarray, c: int, r1: int, r2: int) -> bool:\n    \"\"\" Checks if col c between rows r1 and r2 (inclusive) is entirely yellow(4) \"\"\"\n    height, width = grid.shape\n    if c < 0 or c >= width: return False # Column out of bounds\n    # Ensure row indices are valid and within grid bounds\n    r_start = max(0, r1)\n    r_end = min(height - 1, r2)\n    if r_start > r_end: return False # No valid row range to check (e.g., if r1 > r2)\n\n    # Check if all cells in the specified range within the column are yellow\n    return np.all(grid[r_start : r_end + 1, c] == 4)\n\ndef _find_correspondence(source_regions: list[dict], target_regions: list[dict], grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds the mapping from each target region to its corresponding source color.\n    Uses adjacency rules:\n    1. Vertical: Source directly above Target, separated by horizontal yellow line segment.\n    2. Horizontal: Source directly left of Target, separated by vertical yellow line segment.\n    Returns a dictionary mapping frozenset(target_coords) -> source_color.\n    \"\"\"\n    mapping = {}\n\n    for target in target_regions:\n        # Use frozenset of coordinates as a hashable key for the mapping\n        target_coords_frozen = frozenset(target['coords'])\n        # Should not happen with current analysis logic, but safeguard\n        if not target['blue_coords']: continue\n\n        matched_source_color = None\n        t_min_r, t_min_c, t_max_r, t_max_c = target['bbox']\n\n        # Iterate through potential source regions to find a match\n        for source in source_regions:\n            # Skip if this region doesn't have a source color defined\n            if source['source_color'] is None: continue\n\n            s_min_r, s_min_c, s_max_r, s_max_c = source['bbox']\n\n            # --- Check Vertical Adjacency ---\n            # Condition 1: Source's bottom edge is exactly one row above Target's top edge\n            if s_max_r == t_min_r - 1:\n                # Condition 2: Horizontal overlap exists between source and target bounding boxes\n                overlap_min_c = max(s_min_c, t_min_c)\n                overlap_max_c = min(s_max_c, t_max_c)\n                if overlap_min_c <= overlap_max_c:\n                    # Condition 3: The row between them (at row s_max_r = t_min_r - 1)\n                    # must be a yellow separator *within the overlapping columns*\n                    separator_row_idx = s_max_r\n                    if _is_horizontal_separator(grid, separator_row_idx, overlap_min_c, overlap_max_c):\n                         matched_source_color = source['source_color']\n                         break # Found vertical match, stop searching sources for this target\n\n            # --- Check Horizontal Adjacency (only if vertical didn't match) ---\n            # Condition 1: Source's right edge is exactly one column left of Target's left edge\n            if matched_source_color is None and s_max_c == t_min_c - 1:\n                 # Condition 2: Vertical overlap exists between source and target bounding boxes\n                overlap_min_r = max(s_min_r, t_min_r)\n                overlap_max_r = min(s_max_r, t_max_r)\n                if overlap_min_r <= overlap_max_r:\n                    # Condition 3: The column between them (at col s_max_c = t_min_c - 1)\n                    # must be a yellow separator *within the overlapping rows*\n                    separator_col_idx = s_max_c\n                    if _is_vertical_separator(grid, separator_col_idx, overlap_min_r, overlap_max_r):\n                        matched_source_color = source['source_color']\n                        break # Found horizontal match, stop searching sources for this target\n\n        # If a match was found (either vertical or horizontal), add it to the mapping\n        if matched_source_color is not None:\n             mapping[target_coords_frozen] = matched_source_color\n\n    return mapping\n\n# --- Main Transform Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = np.copy(grid)\n\n    # 1. Find all distinct regions separated by yellow(4) lines\n    regions_coords = _find_regions(grid)\n\n    # 2. Analyze properties of each region (source color, blue pixels, bounding box)\n    #    Classifies into potential sources and targets based on content.\n    region_data = _analyze_regions(grid, regions_coords)\n\n    # 3. Separate into actual source and target lists based on analysis\n    source_regions = [r for r in region_data if r['source_color'] is not None]\n    target_regions = [r for r in region_data if r['blue_coords'] is not None]\n\n    # 4. Determine the correspondence between target regions and source regions\n    #    Returns a map: { frozenset(target_coords) -> source_color }\n    mapping = _find_correspondence(source_regions, target_regions, grid)\n\n    # 5. Apply the transformations based on the mapping\n    #    Iterate through all identified target regions\n    for region in target_regions:\n        target_coords_frozen = frozenset(region['coords'])\n        # Check if a corresponding source was found for this target region in the mapping\n        if target_coords_frozen in mapping:\n            source_color = mapping[target_coords_frozen]\n            # Replace all blue pixels (stored in 'blue_coords') in this target region\n            # with the corresponding source color in the output grid.\n            for r, c in region['blue_coords']:\n                output_grid[r, c] = source_color\n\n    # Convert the final numpy array back to a list of lists format for the expected output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14460,
    "candidates_token_count": 3874,
    "total_token_count": 18334,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.279098,
  "retries": 1
}