{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\" Get 4-directional neighbors \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_regions(grid: np.ndarray) -> list[set[tuple[int, int]]]:\n    \"\"\" \n    Finds connected regions of non-yellow(4) cells using BFS.\n    Yellow cells act as boundaries and are not part of any region.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n    \n    for r in range(height):\n        for c in range(width):\n            # Start BFS only if cell is not yellow and not visited\n            if grid[r, c] != 4 and not visited[r, c]:\n                region_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    region_coords.add((row, col))\n                    \n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(row, col, height, width):\n                        # Add neighbor to queue if valid, not yellow, and not visited\n                        if grid[nr, nc] != 4 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if region_coords:\n                    regions.append(region_coords)\n    return regions\n\ndef _calculate_bounding_box(coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\" Calculates min_row, min_col, max_row, max_col for a set of coordinates \"\"\"\n    if not coords:\n        return -1, -1, -1, -1 # Indicate empty region\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef _analyze_regions(grid: np.ndarray, regions: list[set[tuple[int, int]]]) -> list[dict]:\n    \"\"\" \n    Analyzes each region to find its properties:\n    - blue_coords: list of coordinates containing blue (1) pixels.\n    - source_color: the unique non-white(0)/yellow(4)/blue(1) color, if one exists.\n    - bbox: bounding box tuple (min_r, min_c, max_r, max_c).\n    \"\"\"\n    region_data = []\n    for coords in regions:\n        blue_coords = []\n        # Using a set to find unique colors easily\n        other_colors = set() \n        \n        for r, c in coords:\n            color = grid[r, c]\n            if color == 1: # Blue\n                blue_coords.append((r, c))\n            elif color != 0 and color != 4: # Non-white, non-yellow source candidate\n                other_colors.add(color)\n\n        source_color = None\n        # Check if exactly one unique non-white/yellow/blue color exists\n        if len(other_colors) == 1:\n             source_color = list(other_colors)[0] # Get the single element\n             \n        bbox = _calculate_bounding_box(coords)\n\n        region_data.append({\n            'coords': coords,\n            # Store list if blue found, else None\n            'blue_coords': blue_coords if blue_coords else None, \n            'source_color': source_color,\n            'bbox': bbox \n        })\n    return region_data\n\ndef _is_horizontal_separator(grid: np.ndarray, r: int, c1: int, c2: int) -> bool:\n    \"\"\" Checks if row r between columns c1 and c2 (inclusive) is entirely yellow(4) \"\"\"\n    if r < 0 or r >= grid.shape[0]: return False # Row out of bounds\n    # Ensure column indices are within grid bounds\n    c_start = max(0, c1)\n    c_end = min(grid.shape[1] - 1, c2)\n    if c_start > c_end: return False # No valid column range to check\n    # Check if all cells in the specified range are yellow\n    return np.all(grid[r, c_start : c_end + 1] == 4)\n\ndef _is_vertical_separator(grid: np.ndarray, c: int, r1: int, r2: int) -> bool:\n    \"\"\" Checks if col c between rows r1 and r2 (inclusive) is entirely yellow(4) \"\"\"\n    if c < 0 or c >= grid.shape[1]: return False # Column out of bounds\n    # Ensure row indices are within grid bounds\n    r_start = max(0, r1)\n    r_end = min(grid.shape[0] - 1, r2)\n    if r_start > r_end: return False # No valid row range to check\n    # Check if all cells in the specified range are yellow\n    return np.all(grid[r_start : r_end + 1, c] == 4)\n    \ndef _find_correspondence(source_regions: list[dict], target_regions: list[dict], grid: np.ndarray) -> dict:\n    \"\"\" \n    Finds the mapping from each target region to its corresponding source color.\n    Uses prioritized adjacency rules:\n    1. Vertical: Source directly above Target, separated by horizontal yellow line.\n    2. Horizontal: Source to the left of Target, within the same horizontal band,\n       not separated by a vertical yellow line.\n    Returns a dictionary mapping frozenset(target_coords) -> source_color.\n    \"\"\"\n    mapping = {} \n    \n    for target in target_regions:\n        # Use frozenset of coordinates as a hashable key for the mapping\n        target_coords_frozen = frozenset(target['coords'])\n        # Skip if somehow a target region has no blue pixels (shouldn't happen with current logic)\n        if not target['blue_coords']: continue \n\n        matched_source_color = None\n        t_min_r, t_min_c, t_max_r, t_max_c = target['bbox']\n        \n        # --- Priority 1: Vertical Adjacency Check ---\n        for source in source_regions:\n            if source['source_color'] is None: continue # Skip regions without a valid source color\n            s_min_r, s_min_c, s_max_r, s_max_c = source['bbox']\n            \n            # Condition 1: Source's bottom edge is exactly one row above Target's top edge\n            if s_max_r == t_min_r - 1:\n                # Condition 2: Horizontal overlap exists between source and target bounding boxes\n                overlap_min_c = max(s_min_c, t_min_c)\n                overlap_max_c = min(s_max_c, t_max_c)\n                if overlap_min_c <= overlap_max_c:\n                    # Condition 3: The row between them (at target's top edge - 1) \n                    # must be a yellow separator within the overlapping columns\n                    separator_row_idx = t_min_r - 1 # = s_max_r\n                    if _is_horizontal_separator(grid, separator_row_idx, overlap_min_c, overlap_max_c):\n                         matched_source_color = source['source_color']\n                         break # Found vertical match, stop searching for this target\n        \n        if matched_source_color is not None:\n             mapping[target_coords_frozen] = matched_source_color\n             continue # Move to the next target region\n\n        # --- Priority 2: Horizontal Adjacency Check (within the same horizontal band) ---\n        \n        # Define band: Rows between the closest full horizontal separators above/below the target, or grid edges.\n        band_top = -1 # Default to top edge\n        for r in range(t_min_r - 1, -2, -1):\n            # Check if row is fully yellow or we are at the top edge\n            if r == -1 or np.all(grid[r, :] == 4): \n                 band_top = r\n                 break\n                 \n        band_bottom = grid.shape[0] # Default to bottom edge\n        for r in range(t_max_r + 1, grid.shape[0] + 1):\n             # Check if row is fully yellow or we are at the bottom edge\n             if r == grid.shape[0] or np.all(grid[r, :] == 4): \n                  band_bottom = r\n                  break\n\n        # Look for a source region within this band, to the left of the target\n        possible_horizontal_matches = []\n        for source in source_regions:\n             if source['source_color'] is None: continue\n             s_min_r, s_min_c, s_max_r, s_max_c = source['bbox']\n\n             # Condition 1: Source is vertically within the same band as target\n             if s_min_r > band_top and s_max_r < band_bottom:\n                  # Condition 2: Source is strictly to the left of target\n                  if s_max_c < t_min_c:\n                        # Condition 3: Vertical overlap exists between source and target\n                        overlap_min_r = max(s_min_r, t_min_r)\n                        overlap_max_r = min(s_max_r, t_max_r)\n                        if overlap_min_r <= overlap_max_r:\n                             # Condition 4: Check there's NO vertical yellow separator *between* them \n                             # within their overlapping rows.\n                             is_separated = False\n                             for c_check in range(s_max_c + 1, t_min_c):\n                                 if _is_vertical_separator(grid, c_check, overlap_min_r, overlap_max_r):\n                                     is_separated = True\n                                     break\n                             if not is_separated:\n                                 # Add potential match (store source and its distance for potentially choosing closest)\n                                 # For now, just take the first one found.\n                                 possible_horizontal_matches.append(source)\n                                 \n        # If any horizontal matches were found, use the first one \n        # (Could be refined to choose closest if multiple exist)\n        if possible_horizontal_matches:\n            matched_source_color = possible_horizontal_matches[0]['source_color']\n            mapping[target_coords_frozen] = matched_source_color\n            \n    return mapping\n\n# --- Main Transform Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. The grid is partitioned into regions by yellow (4) separators (horizontal/vertical lines).\n    2. Some regions act as 'source' regions, containing exactly one pixel of a unique color (not white 0, yellow 4, or blue 1).\n    3. Some regions act as 'target' regions, containing blue (1) pixels.\n    4. Each target region corresponds to exactly one source region based on adjacency:\n        - Priority 1: The source region is directly above the target region, separated by a continuous horizontal yellow line segment.\n        - Priority 2: The source region is to the left of the target region within the same horizontal 'band' (defined by horizontal yellow lines or grid edges above and below), and they are not separated by a vertical yellow line.\n    5. All blue (1) pixels within a target region are replaced by the color of its corresponding source region.\n    6. All other pixels (white, yellow, source colors) remain unchanged.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = np.copy(grid)\n    \n    # 1. Find all distinct regions separated by yellow(4) lines\n    regions = _find_regions(grid)\n    \n    # 2. Analyze properties of each region (source color, blue pixels, bounding box)\n    region_data = _analyze_regions(grid, regions)\n    \n    # 3. Classify regions into potential sources and targets\n    # Source: Has a unique non-0/1/4 color defined.\n    # Target: Has blue(1) pixels defined.\n    source_regions = [r for r in region_data if r['source_color'] is not None]\n    target_regions = [r for r in region_data if r['blue_coords'] is not None]\n    \n    # 4. Determine the correspondence between target regions and source regions\n    # Returns a map: { frozenset(target_coords) -> source_color }\n    mapping = _find_correspondence(source_regions, target_regions, grid)\n\n    # 5. Apply the transformations based on the mapping\n    # Iterate through all identified target regions\n    for region in target_regions:\n        target_coords_frozen = frozenset(region['coords'])\n        # Check if a corresponding source was found for this target region\n        if target_coords_frozen in mapping:\n            source_color = mapping[target_coords_frozen]\n            # Replace all blue pixels in this target region with the source color\n            for r, c in region['blue_coords']:\n                output_grid[r, c] = source_color\n                \n    # Convert the final numpy array back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2940,
    "candidates_token_count": 10404,
    "total_token_count": 13344,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 80.304597,
  "retries": 1
}