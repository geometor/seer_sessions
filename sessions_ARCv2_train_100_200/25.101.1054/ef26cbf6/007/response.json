{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on region analysis and color replacement rules across yellow separators.\n\n1.  The grid is partitioned into contiguous regions of non-yellow (4) pixels, using yellow pixels as boundaries.\n2.  Regions are classified as either 'source' or 'target':\n    - A 'source region' contains exactly one pixel of a unique color (not white 0, yellow 4, or blue 1) and no blue pixels. Its unique color is the 'source color'.\n    - A 'target region' contains one or more blue (1) pixels and no other unique non-white/yellow colors.\n3.  A correspondence is established between each target region and exactly one source region based on adjacency across a single row or column of yellow pixels:\n    - Vertical Adjacency: The source region is above the target region such that `source_max_row + 1 == target_min_row - 1`, AND the intervening row (`source_max_row + 1`) is entirely yellow within their horizontally overlapping columns.\n    - Horizontal Adjacency: The source region is to the left of the target region such that `source_max_col + 1 == target_min_col - 1`, AND the intervening column (`source_max_col + 1`) is entirely yellow within their vertically overlapping rows.\n4.  All blue (1) pixels within each target region are replaced in the output grid by the source color of its corresponding source region.\n5.  All other pixels (white, yellow, source colors) remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef _get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\" Get 4-directional neighbors within grid bounds \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_regions(grid: np.ndarray) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds connected regions of non-yellow(4) cells using BFS.\n    Yellow cells act as boundaries and are not part of any region.\n    Returns a list of sets, where each set contains the (row, col) coordinates of a region.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS only if cell is not yellow and not visited\n            if grid[r, c] != 4 and not visited[r, c]:\n                region_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    region_coords.add((row, col))\n\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(row, col, height, width):\n                        # Add neighbor to queue if valid, not yellow, and not visited\n                        if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] != 4 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if region_coords:\n                    regions.append(region_coords)\n    return regions\n\ndef _calculate_bounding_box(coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\" Calculates min_row, min_col, max_row, max_col for a set of coordinates \"\"\"\n    if not coords:\n        return -1, -1, -1, -1 # Indicate empty region\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef _analyze_regions(grid: np.ndarray, regions: list[set[tuple[int, int]]]) -> list[dict]:\n    \"\"\"\n    Analyzes each region to find its properties:\n    - coords: set of (row, col) tuples in the region.\n    - blue_coords: list of coordinates containing blue (1) pixels, or None.\n    - source_color: the unique non-white(0)/yellow(4)/blue(1) color, if one exists, or None.\n    - bbox: bounding box tuple (min_r, min_c, max_r, max_c).\n    \"\"\"\n    region_data = []\n    for i, coords in enumerate(regions):\n        blue_coords_list = []\n        # Using a set to find unique non-white/yellow/blue colors easily\n        other_colors = set()\n\n        for r, c in coords:\n            color = grid[r, c]\n            if color == 1: # Blue\n                blue_coords_list.append((r, c))\n            # Check for potential source color (not white, yellow, or blue)\n            elif color not in [0, 4]:\n                other_colors.add(color)\n\n        source_color = None\n        is_target = bool(blue_coords_list)\n        is_potential_source = len(other_colors) == 1\n\n        # Define as source only if exactly one 'other' color AND no blue pixels.\n        # Define as target only if blue pixels exist AND no 'other' colors.\n        # This prevents a region being both.\n        if is_potential_source and not is_target:\n             source_color = list(other_colors)[0]\n             region_type = 'source'\n        elif is_target and not is_potential_source:\n             region_type = 'target'\n        else:\n            region_type = 'other' # Neither source nor target based on strict definition\n\n\n        bbox = _calculate_bounding_box(coords)\n\n        region_data.append({\n            'id': i, # Assign an ID for potential debugging\n            'coords': coords,\n            'blue_coords': blue_coords_list if region_type == 'target' else None,\n            'source_color': source_color if region_type == 'source' else None,\n            'bbox': bbox,\n            'type': region_type\n        })\n    return region_data\n\ndef _is_horizontal_separator(grid: np.ndarray, r: int, c1: int, c2: int) -> bool:\n    \"\"\" Checks if row r between columns c1 and c2 (inclusive) is entirely yellow(4) \"\"\"\n    height, width = grid.shape\n    if r < 0 or r >= height: return False # Row out of bounds\n    # Ensure column indices are valid and within grid bounds\n    c_start = max(0, c1)\n    c_end = min(width - 1, c2)\n    if c_start > c_end: return False # No valid column range to check\n\n    # Check if all cells in the specified range within the row are yellow\n    return np.all(grid[r, c_start : c_end + 1] == 4)\n\ndef _is_vertical_separator(grid: np.ndarray, c: int, r1: int, r2: int) -> bool:\n    \"\"\" Checks if col c between rows r1 and r2 (inclusive) is entirely yellow(4) \"\"\"\n    height, width = grid.shape\n    if c < 0 or c >= width: return False # Column out of bounds\n    # Ensure row indices are valid and within grid bounds\n    r_start = max(0, r1)\n    r_end = min(height - 1, r2)\n    if r_start > r_end: return False # No valid row range to check\n\n    # Check if all cells in the specified range within the column are yellow\n    return np.all(grid[r_start : r_end + 1, c] == 4)\n\ndef _find_correspondence(source_regions: list[dict], target_regions: list[dict], grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds the mapping from each target region to its corresponding source color.\n    Uses adjacency rules across a single yellow separator row/column:\n    1. Vertical: Source above Target, separated by one horizontal yellow row.\n    2. Horizontal: Source left of Target, separated by one vertical yellow column.\n    Returns a dictionary mapping frozenset(target_coords) -> source_color.\n    \"\"\"\n    mapping = {}\n\n    for target in target_regions:\n        # Use frozenset of coordinates as a hashable key for the mapping\n        target_coords_frozen = frozenset(target['coords'])\n        if not target['blue_coords']: continue # Should already be filtered, but safety check\n\n        matched_source_color = None\n        t_min_r, t_min_c, t_max_r, t_max_c = target['bbox']\n\n        # Iterate through potential source regions to find a match\n        for source in source_regions:\n            if source['source_color'] is None: continue # Skip non-sources\n\n            s_min_r, s_min_c, s_max_r, s_max_c = source['bbox']\n\n            # --- Check Vertical Adjacency ---\n            # Condition 1: Exactly one row separates them (source is above target)\n            separator_row_idx = s_max_r + 1\n            if separator_row_idx == t_min_r - 1: # Check if target starts 2 rows below source end\n                # Condition 2: Horizontal overlap exists\n                overlap_min_c = max(s_min_c, t_min_c)\n                overlap_max_c = min(s_max_c, t_max_c)\n                if overlap_min_c <= overlap_max_c:\n                    # Condition 3: The separating row IS a horizontal yellow separator\n                    # within the overlapping columns.\n                    if _is_horizontal_separator(grid, separator_row_idx, overlap_min_c, overlap_max_c):\n                         matched_source_color = source['source_color']\n                         break # Found vertical match\n\n            # --- Check Horizontal Adjacency (only if vertical didn't match) ---\n             # Condition 1: Exactly one col separates them (source is left of target)\n            separator_col_idx = s_max_c + 1\n            if matched_source_color is None and separator_col_idx == t_min_c - 1: # Check if target starts 2 cols right of source end\n                # Condition 2: Vertical overlap exists\n                overlap_min_r = max(s_min_r, t_min_r)\n                overlap_max_r = min(s_max_r, t_max_r)\n                if overlap_min_r <= overlap_max_r:\n                    # Condition 3: The separating col IS a vertical yellow separator\n                    # within the overlapping rows.\n                    if _is_vertical_separator(grid, separator_col_idx, overlap_min_r, overlap_max_r):\n                        matched_source_color = source['source_color']\n                        break # Found horizontal match\n\n        # If a match was found, add it to the mapping\n        if matched_source_color is not None:\n             mapping[target_coords_frozen] = matched_source_color\n\n    return mapping\n\n# --- Main Transform Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic: identifies regions, finds source-target\n    correspondence across yellow separators, and replaces blue pixels in target\n    regions with the corresponding source color.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy of the grid to modify, preserving the original input\n    output_grid = np.copy(grid)\n\n    # 1. Identify all contiguous regions of non-yellow (4) pixels\n    regions_coords = _find_regions(grid)\n\n    # 2. Analyze each region to classify it and extract properties\n    region_data = _analyze_regions(grid, regions_coords)\n\n    # 3. Separate classified regions into source and target lists based on 'type'\n    source_regions = [r for r in region_data if r['type'] == 'source']\n    target_regions = [r for r in region_data if r['type'] == 'target']\n\n    # 4. Determine the correspondence: map each target region to its adjacent source color\n    #    The mapping uses frozenset(target_coords) as keys and source_color as values\n    mapping = _find_correspondence(source_regions, target_regions, grid)\n\n    # 5. Apply the color replacements based on the determined mapping\n    #    Iterate through the target regions identified earlier\n    for region in target_regions:\n        target_coords_frozen = frozenset(region['coords'])\n        # Check if a corresponding source color was found for this target region\n        if target_coords_frozen in mapping:\n            source_color = mapping[target_coords_frozen]\n            # Replace all blue pixels (stored in 'blue_coords') within this target region\n            # in the output grid with the corresponding source color.\n            for r, c in region['blue_coords']:\n                output_grid[r, c] = source_color\n\n    # Convert the final numpy array back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32615,
    "candidates_token_count": 3408,
    "total_token_count": 36023,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.395905,
  "retries": 1
}