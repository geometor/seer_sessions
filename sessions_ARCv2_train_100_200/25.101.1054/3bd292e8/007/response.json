{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid containing Red(2) and Orange(7) pixels based on a \npropagation rule originating from Red pixels.\n\nRule:\n1. Red(2) pixels in the input remain Red(2) in the output.\n2. Orange(7) pixels are transformed to either Green(3) or Gray(5).\n3. An Orange(7) pixel becomes Gray(5) if it meets either of these conditions:\n    a) It is 8-way adjacent (including diagonals) to at least one Red(2) pixel \n       in the input grid. These are considered 'seed' Gray pixels.\n    b) It is 4-way adjacent (cardinal directions: up, down, left, right) to \n       another pixel that is already determined to be Gray(5) (either a seed \n       or one turned Gray by this propagation rule).\n4. Any Orange(7) pixel that does not become Gray(5) through the above process \n   becomes Green(3).\n\nThe process effectively involves:\n- Identifying 'seed' Gray pixels (Orange next to Red 8-way).\n- Propagating the Gray color outwards from these seeds using 4-way adjacency \n  through the remaining Orange pixels.\n- Coloring any untouched Orange pixels Green.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _is_valid(r, c, height, width):\n    \"\"\"Checks if coordinates (r, c) are within the grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the 8-way seed, 4-way propagation transformation.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed grid as a list of lists.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid: -1 indicates unprocessed Orange pixels.\n    output_np = np.full_like(input_np, -1) \n    \n    # Queue for Breadth-First Search (BFS) propagation of Gray color\n    queue = deque()\n    \n    # Deltas for neighbor checks\n    deltas_8way = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    deltas_4way = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # --- Step 1 & 2: Initialize Output and Identify Seed Gray Pixels ---\n    # Iterate through each cell to initialize output and find seeds\n    for r in range(height):\n        for c in range(width):\n            if input_np[r, c] == 2: # Red pixel\n                output_np[r, c] = 2 # Copy Red directly\n            elif input_np[r, c] == 7: # Orange pixel\n                is_adjacent_to_red_8way = False\n                # Check 8 neighbors in the *input* grid for Red\n                for dr, dc in deltas_8way:\n                    nr, nc = r + dr, c + dc\n                    if _is_valid(nr, nc, height, width) and input_np[nr, nc] == 2:\n                        is_adjacent_to_red_8way = True\n                        break # Found a Red neighbor, no need to check further\n                \n                if is_adjacent_to_red_8way:\n                    # This Orange pixel is 8-way adjacent to Red -> Seed Gray pixel\n                    output_np[r, c] = 5 # Mark as Gray\n                    queue.append((r, c)) # Add to propagation queue\n                else:\n                    # Not adjacent to Red -> Tentatively mark as Green (will be processed later)\n                    # Use the initial -1 placeholder to distinguish from final Green\n                    pass # Keep as -1 for now\n            else:\n                # Copy any other colors directly (if they exist)\n                 output_np[r, c] = input_np[r, c]\n\n    # --- Step 3: Propagate Gray using BFS (4-way adjacency) ---\n    # Use a set to track items added to the queue to prevent redundant processing\n    processed_for_propagation = set(queue) \n\n    while queue:\n        r, c = queue.popleft() # Get coordinates of a current Gray pixel\n        \n        # Examine 4 cardinal neighbors for propagation\n        for dr, dc in deltas_4way:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n            \n            # Check if neighbor is valid, is an unprocessed Orange pixel (value -1),\n            # and hasn't already been added to the queue\n            if _is_valid(nr, nc, height, width) and output_np[nr, nc] == -1 and neighbor_pos not in processed_for_propagation:\n                # Propagate Gray: Change unprocessed Orange neighbor to Gray\n                output_np[nr, nc] = 5\n                # Add the newly Gray pixel to the queue and mark as processed\n                queue.append(neighbor_pos)\n                processed_for_propagation.add(neighbor_pos)\n\n    # --- Step 4: Finalize - Change remaining unprocessed Orange to Green ---\n    # Any cell that was originally Orange (input value 7) but is still -1 \n    # in the output grid was not reached by propagation.\n    for r in range(height):\n        for c in range(width):\n            if output_np[r, c] == -1: # Check if it's an unprocessed Orange pixel\n                 # Assert input_np[r,c] == 7 # Should be true if logic is correct\n                 output_np[r, c] = 3 # Set to Green\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32383,
    "candidates_token_count": 1738,
    "total_token_count": 34121,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.952626,
  "retries": 1
}