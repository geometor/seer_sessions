{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on column context.\nThe transformation targets the most frequent color in the grid ('T').\nFor each column, if it contains exactly one non-target color ('C_other'),\nall 'T' pixels in that column are changed to a new color determined by 'C_other'\nusing a predefined mapping. The mapping used depends on the set of colors\npresent in the overall grid (two patterns identified from training examples).\nIf a column contains no 'C_other' or multiple 'C_other' colors, 'T' pixels\nremain unchanged in that column. Other pixels (not 'T') are never changed.\n\"\"\"\n\n# Define the two known secondary color mappings observed in the examples\n# These maps define how the 'influencing_color' in a column transforms the 'target_color'\nMAP_1 = {2: 6, 6: 5, 5: 2} # Corresponds to train_1 pattern (Red->Blue, Magenta->Gray, Gray->Red affects Yellow)\nCOLORS_1 = {2, 4, 5, 6}    # Color set associated with MAP_1 (Yellow is target)\n\nMAP_2 = {4: 3, 3: 9, 9: 4} # Corresponds to train_2 pattern (Yellow->Green, Green->Maroon, Maroon->Yellow affects White)\nCOLORS_2 = {0, 3, 4, 9}    # Color set associated with MAP_2 (White is target)\n\ndef find_most_frequent_color(grid_np):\n    \"\"\"Helper function to find the most frequent color in a numpy grid.\"\"\"\n    # Check for empty grid case after potential conversion\n    if grid_np.size == 0:\n        # Cannot determine most frequent, return a default (e.g., 0) or raise error\n        # Returning 0 might be reasonable for ARC's background color preference\n        return 0 \n        \n    # Get unique colors and their counts\n    colors, counts = np.unique(grid_np, return_counts=True)\n    # Find the index of the maximum count\n    max_count_idx = np.argmax(counts)\n    # Return the color corresponding to the maximum count\n    return colors[max_count_idx]\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a column-based transformation to the input grid.\n    \n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    try:\n        input_np = np.array(input_grid, dtype=int)\n    except ValueError: # Handle potentially ragged lists\n         # Decide on error handling: return input, empty, or raise\n         # Returning input seems safest if format is unexpected\n         return input_grid\n\n    # Create a copy to modify, ensuring the original input is untouched\n    output_np = np.copy(input_np)\n    \n    # Get dimensions after conversion\n    if input_np.ndim != 2: # Ensure it's a 2D grid\n        return input_grid # Return original if not 2D\n    height, width = input_np.shape\n\n    # Handle empty grids\n    if height == 0 or width == 0:\n        return [] # Return empty list for empty grid\n\n    # --- Step 1: Identify the Target Color ---\n    # Assume the color to be transformed is the most frequent one in the grid\n    target_color = find_most_frequent_color(input_np)\n\n    # --- Step 2: Select the Transformation Map ---\n    # Determine which set of transformation rules (map) to use based on the\n    # overall set of colors present in the input grid.\n    unique_colors_grid = set(np.unique(input_np))\n    \n    selected_map = None\n    # Check if the grid's colors contain the set associated with the first pattern\n    # Using issubset allows for potential extra, unused colors in the grid\n    if COLORS_1.issubset(unique_colors_grid):\n         selected_map = MAP_1\n    # Check if the grid's colors contain the set associated with the second pattern\n    elif COLORS_2.issubset(unique_colors_grid):\n         selected_map = MAP_2\n    else:\n        # If the grid colors don't match any known pattern, assume no transformation\n        # is needed or possible based on the learned rules. Return the original grid copy.\n         return output_np.tolist()\n\n    # --- Step 3: Apply Transformation Column by Column ---\n    # Iterate through each column index\n    for j in range(width):\n        # Extract the current column from the input grid\n        column = input_np[:, j]\n        \n        # Find all unique colors present in this specific column\n        unique_colors_col = set(np.unique(column))\n        \n        # Identify the set of colors in the column that are NOT the target color\n        secondary_colors = unique_colors_col - {target_color}\n        \n        influencing_color = None\n        # Check if there is exactly one unique secondary color in this column\n        if len(secondary_colors) == 1:\n            # If yes, this color might influence the target color\n            influencing_color = list(secondary_colors)[0]\n            \n        # Determine the output color for the target pixels in this column\n        # Default is no change (output = target)\n        output_color_for_target = target_color\n        \n        # If there was a single influencing color AND it exists as a key in the selected map...\n        if influencing_color is not None and influencing_color in selected_map:\n            # ...then the target color should be changed to the mapped value\n            output_color_for_target = selected_map[influencing_color]\n\n        # --- Step 4: Update Output Grid ---\n        # If the calculated output color is different from the target color...\n        if output_color_for_target != target_color:\n            # ...then update all pixels in this column of the output grid\n            # that originally had the target color.\n            # Using boolean indexing for efficiency\n            mask = (input_np[:, j] == target_color)\n            output_np[mask, j] = output_color_for_target\n            # Equivalent loop version (less efficient for large arrays):\n            # for i in range(height):\n            #     if input_np[i, j] == target_color:\n            #         output_np[i, j] = output_color_for_target\n            \n    # Convert the final numpy array back to a list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2677,
    "candidates_token_count": 12443,
    "total_token_count": 15120,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 93.102001,
  "retries": 1
}