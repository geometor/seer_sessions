{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a grid of integers based on the neighborhood of the globally most frequent integer.\n\n1. Identify the globally most frequent integer value in the input grid. In case of a tie in frequency, choose the smallest integer value. Call this the `target_value`.\n2. Create a new grid, initially identical to the input grid.\n3. Iterate through each cell `(r, c)` of the *input* grid.\n4. If the value of the input cell `input_grid[r][c]` is equal to the `target_value`:\n    a. Find the values of the 8 neighbors of `(r, c)` in the *input* grid (handle boundary conditions).\n    b. Create a list of `valid_neighbors` containing only those neighbor values that are *not* equal to the `target_value`.\n    c. If `valid_neighbors` is not empty, determine the mode(s) (most frequent value(s)) within this list.\n    d. Check if there is exactly one unique `mode` value.\n    e. If there is a unique `mode`:\n        i. Select the appropriate value mapping based on the `target_value`:\n            - If `target_value` is 4, use the map: {2: 6, 5: 2, 6: 5}.\n            - If `target_value` is 0, use the map: {3: 9, 4: 3, 9: 4}.\n            - (Assume other `target_values` might have different, undefined maps).\n        ii. If the unique `mode` is found as a key in the selected map, update the cell `(r, c)` in the *new* grid with the corresponding mapped value.\n        iii. *Exception Handling Note:* There are observed cases where this condition (unique mode found in map) is met, but the cell does *not* change in the expected output. The precise condition preventing the change is not implemented.\n    f. If there is no unique mode (either `valid_neighbors` was empty, or there was a tie for the mode), the cell `(r, c)` in the *new* grid retains its original value.\n5. If the value of the input cell `input_grid[r][c]` is *not* equal to the `target_value`, the cell `(r, c)` in the *new* grid retains its original value.\n6. Return the new grid.\n\"\"\"\n\nimport collections\nimport copy\n\ndef get_neighbors(grid: list[list[int]], r: int, c: int) -> list[int]:\n    \"\"\"\n    Gets the values of the 8 neighbors for a given cell (r, c).\n    Handles boundary conditions.\n    Uses the Moore neighborhood (8 adjacent cells).\n    \"\"\"\n    neighbors = []\n    rows = len(grid)\n    cols = len(grid[0])\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue  # Skip the cell itself\n            nr, nc = r + dr, c + dc\n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append(grid[nr][nc])\n    return neighbors\n\ndef find_most_frequent(grid: list[list[int]]) -> int:\n    \"\"\"\n    Finds the most frequent value in the grid.\n    If there's a tie in frequency, returns the smallest value among those tied.\n    Returns -1 if the grid is empty or has no elements.\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1 # Indicate error or empty grid\n\n    counts = collections.Counter()\n    for row in grid:\n        counts.update(row)\n\n    if not counts:\n         return -1 # Grid contains only empty rows?\n\n    # Find the maximum frequency\n    max_freq = 0\n    max_freq = max(counts.values())\n\n    # Find all values with the maximum frequency\n    most_frequent_values = [val for val, freq in counts.items() if freq == max_freq]\n\n    # Tie-breaking: return the smallest value if there's a tie\n    return min(most_frequent_values)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n\n    # 1. Find the target_value (most frequent, smallest in case of tie)\n    target_value = find_most_frequent(input_grid)\n\n    # Define the replacement mappings based on target_value\n    replacement_map = {}\n    if target_value == 4:\n        # Mapping derived from train_1\n        replacement_map = {2: 6, 5: 2, 6: 5}\n    elif target_value == 0:\n         # Mapping derived from train_2 (re-evaluated)\n        replacement_map = {3: 9, 4: 3, 9: 4}\n    # Add more mappings here if needed for other potential target values discovered later\n\n    # 3. Iterate through each cell of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # 4. Check if the current cell's value is the target value\n            if input_grid[r][c] == target_value:\n                # 4a. Get neighbors from the original input grid\n                all_neighbors = get_neighbors(input_grid, r, c)\n\n                # 4b. Filter out neighbors that are the target value\n                valid_neighbors = [n for n in all_neighbors if n != target_value]\n\n                # 4c. Check if there are any valid neighbors\n                if valid_neighbors:\n                    # Find the mode(s) of the valid neighbors\n                    neighbor_counts = collections.Counter(valid_neighbors)\n                    max_neighbor_freq = max(neighbor_counts.values())\n                    modes = [val for val, freq in neighbor_counts.items() if freq == max_neighbor_freq]\n\n                    # 4d. Check if there is a unique mode\n                    if len(modes) == 1:\n                        local_mode = modes[0]\n                        # 4e. Check if this unique mode exists in the defined mapping\n                        if local_mode in replacement_map:\n                            # Perform the replacement in the output grid\n                            # Note: This step does not account for the unexplained exceptions\n                            # where this condition is met but the cell doesn't change.\n                            replacement_value = replacement_map[local_mode]\n                            output_grid[r][c] = replacement_value\n                        # else: If mode not in map, do nothing (cell retains target_value)\n                    # else: If there's a tie for mode, do nothing (cell retains target_value)\n                # else: If no valid neighbors, do nothing (cell retains target_value)\n\n            # 5. If the cell value is not the target_value, it remains unchanged (already copied)\n\n    # 6. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10195,
    "candidates_token_count": 2142,
    "total_token_count": 12337,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.302407,
  "retries": 1
}