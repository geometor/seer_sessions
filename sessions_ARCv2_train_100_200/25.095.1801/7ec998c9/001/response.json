{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Identifies the grid dimensions (Height H, Width W).\n2. Finds the 'background' value (most frequent integer) and the unique 'anchor' cell \n   (r_anchor, c_anchor) with a different value (v_anchor).\n3. Determines a pair of opposite corners:\n    - If the anchor cell is at the exact geometric center of the grid \n      (r_anchor == (H-1)/2 and c_anchor == (W-1)/2), uses Top-Right ((0, W-1)) \n      and Bottom-Left ((H-1, 0)).\n    - Otherwise, uses Top-Left ((0, 0)) and Bottom-Right ((H-1, W-1)).\n4. Constructs a path connecting the selected corners, using the anchor cell's column (c_anchor)\n   as the vertical segment:\n    - Horizontal segment from Corner1's row/col to (Corner1_row, c_anchor).\n    - Vertical segment from (Corner1_row, c_anchor) to (Corner2_row, c_anchor).\n    - Horizontal segment from (Corner2_row, c_anchor) to Corner2's row/col.\n5. Creates an output grid, initially a copy of the input.\n6. Iterates through all cells on the constructed path. If a path cell is *not* the anchor cell,\n   its value in the output grid is changed to 1.\n7. Returns the modified output grid.\n\"\"\"\n\n\ndef find_grid_dimensions(grid: list[list[int]]) -> tuple[int, int]:\n    \"\"\"Calculates the height and width of the grid.\"\"\"\n    H = len(grid)\n    W = len(grid[0]) if H > 0 else 0\n    return H, W\n\ndef find_background_and_anchor(grid: list[list[int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Finds the background value (most frequent) and the anchor cell \n    (value, row, column).\n    Assumes exactly one anchor cell exists.\n    \"\"\"\n    counts = Counter()\n    anchor_val = -1\n    anchor_row = -1\n    anchor_col = -1\n    \n    H, W = find_grid_dimensions(grid)\n\n    for r in range(H):\n        for c in range(W):\n            counts[grid[r][c]] += 1\n\n    # Find the background value (most common)\n    background_val = counts.most_common(1)[0][0]\n\n    # Find the anchor cell\n    for r in range(H):\n        for c in range(W):\n            if grid[r][c] != background_val:\n                anchor_val = grid[r][c]\n                anchor_row = r\n                anchor_col = c\n                break # Assume only one anchor\n        if anchor_row != -1:\n            break\n            \n    if anchor_row == -1:\n         raise ValueError(\"Could not find a unique anchor cell.\")\n\n    return background_val, anchor_val, anchor_row, anchor_col\n\ndef determine_corners(H: int, W: int, r_anchor: int, c_anchor: int) -> tuple[tuple[int, int], tuple[int, int]]:\n    \"\"\"\n    Determines the start and end corners based on anchor position relative to the center.\n    \"\"\"\n    center_r = (H - 1) / 2.0\n    center_c = (W - 1) / 2.0\n\n    # Use floating point comparison cautiously, but exact match should be fine here\n    if r_anchor == center_r and c_anchor == center_c:\n        # Center anchor: Top-Right to Bottom-Left\n        corner1 = (0, W - 1)\n        corner2 = (H - 1, 0)\n    else:\n        # Off-center anchor: Top-Left to Bottom-Right\n        corner1 = (0, 0)\n        corner2 = (H - 1, W - 1)\n        \n    return corner1, corner2\n\ndef generate_path_coordinates(corner1: tuple[int, int], corner2: tuple[int, int], c_anchor: int) -> set[tuple[int, int]]:\n    \"\"\"\n    Generates the set of (row, col) coordinates forming the path between corners \n    via the anchor column.\n    \"\"\"\n    path_coords = set()\n    r1, c1 = corner1\n    r2, c2 = corner2\n\n    # Segment 1: Horizontal from Corner1 to anchor column\n    c_start_h1 = min(c1, c_anchor)\n    c_end_h1 = max(c1, c_anchor)\n    for c in range(c_start_h1, c_end_h1 + 1):\n        path_coords.add((r1, c))\n\n    # Segment 2: Vertical along anchor column\n    r_start_v = min(r1, r2)\n    r_end_v = max(r1, r2)\n    for r in range(r_start_v, r_end_v + 1):\n        path_coords.add((r, c_anchor))\n\n    # Segment 3: Horizontal from anchor column to Corner2\n    c_start_h2 = min(c_anchor, c2)\n    c_end_h2 = max(c_anchor, c2)\n    for c in range(c_start_h2, c_end_h2 + 1):\n        path_coords.add((r2, c))\n        \n    return path_coords\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Make a deep copy to avoid modifying the original input\n    output_grid = copy.deepcopy(input_grid)\n    \n    # 1. Get grid dimensions\n    H, W = find_grid_dimensions(output_grid)\n    if H == 0 or W == 0:\n        return output_grid # Handle empty grid case\n\n    # 2. Find background and anchor cell details\n    try:\n        background_val, anchor_val, r_anchor, c_anchor = find_background_and_anchor(output_grid)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return output_grid # Return copy if anchor not found\n\n    # 3. Determine the corner pair for the path\n    corner1, corner2 = determine_corners(H, W, r_anchor, c_anchor)\n\n    # 4. Generate the coordinates of the path\n    path_coords = generate_path_coordinates(corner1, corner2, c_anchor)\n\n    # 5. Modify the output grid along the path\n    for r, c in path_coords:\n        # Ensure coordinates are within grid bounds (should be by construction, but safety check)\n        if 0 <= r < H and 0 <= c < W:\n            # Check if the current path cell is NOT the anchor cell\n            if not (r == r_anchor and c == c_anchor):\n                output_grid[r][c] = 1\n\n    # 6. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2482,
    "candidates_token_count": 2458,
    "total_token_count": 4940,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.592725,
  "retries": 1
}