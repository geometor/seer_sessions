{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport sys\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nIdentifies all continuous vertical segments of the value 5 in the input grid. \nSelects the segment with the maximum length and transforms it into a segment of 1s in the output. \nSelects the segment with the minimum length and transforms it into a segment of 2s in the output. \nAll other input cells (0s and non-selected 5s) become 0s in the output grid.\nThe dimensions of the output grid match the input grid.\n\"\"\"\n\ndef _find_vertical_segments(input_grid: List[List[int]]) -> List[Dict]:\n    \"\"\"\n    Finds all continuous vertical segments of the value 5 in the grid.\n\n    Args:\n        input_grid: The input 2D list of integers.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a segment\n        and contains 'col', 'start_row', 'end_row', and 'length'.\n    \"\"\"\n    segments = []\n    if not input_grid:\n        return segments\n        \n    rows = len(input_grid)\n    if rows == 0:\n        return segments\n    cols = len(input_grid[0])\n    if cols == 0:\n        return segments\n\n    for c in range(cols):\n        current_segment_start = -1\n        for r in range(rows):\n            is_five = input_grid[r][c] == 5\n            \n            # Start of a new segment\n            if is_five and current_segment_start == -1:\n                current_segment_start = r\n                \n            # End of the current segment (found a non-5 or reached end of column)\n            if not is_five and current_segment_start != -1:\n                start_row = current_segment_start\n                end_row = r - 1 # Segment ended at the previous row\n                length = end_row - start_row + 1\n                segments.append({\n                    'col': c,\n                    'start_row': start_row,\n                    'end_row': end_row,\n                    'length': length\n                })\n                current_segment_start = -1 # Reset for the next potential segment\n\n        # Check if a segment extends to the last row\n        if current_segment_start != -1:\n            start_row = current_segment_start\n            end_row = rows - 1 # Segment ends at the last row\n            length = end_row - start_row + 1\n            segments.append({\n                'col': c,\n                'start_row': start_row,\n                'end_row': end_row,\n                'length': length\n            })\n            \n    return segments\n\ndef _draw_segment(output_grid: List[List[int]], segment: Dict, value: int):\n    \"\"\"\n    Draws a segment onto the output grid with the specified value.\n\n    Args:\n        output_grid: The grid to draw on (modified in place).\n        segment: The segment dictionary containing col, start_row, end_row.\n        value: The integer value to draw (e.g., 1 or 2).\n    \"\"\"\n    col = segment['col']\n    for r in range(segment['start_row'], segment['end_row'] + 1):\n         # Basic boundary check (although rows should be valid based on segment finding)\n        if 0 <= r < len(output_grid) and 0 <= col < len(output_grid[0]):\n             output_grid[r][col] = value\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the lengths of vertical segments of 5s.\n    The longest segment becomes 1s, the shortest becomes 2s.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    \n    # Get dimensions and initialize output_grid with zeros\n    if not input_grid or not input_grid[0]:\n        return []\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    output_grid = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # Find all vertical segments of 5s\n    segments = _find_vertical_segments(input_grid)\n\n    # If no segments are found, return the zero grid\n    if not segments:\n        return output_grid\n\n    # Find the longest segment\n    # The key sorts primarily by length (descending using negative), then by column index, then start row\n    longest_segment = max(segments, key=lambda s: (s['length'], -s['col'], -s['start_row']))\n\n\n    # Find the shortest segment\n    # The key sorts primarily by length (ascending), then by column index, then start row\n    shortest_segment = min(segments, key=lambda s: (s['length'], s['col'], s['start_row']))\n\n    # Draw the longest segment as 1s\n    _draw_segment(output_grid, longest_segment, 1)\n\n    # Draw the shortest segment as 2s\n    # Make sure we don't overwrite the longest segment if it's also the shortest (only one segment exists)\n    if longest_segment != shortest_segment:\n        _draw_segment(output_grid, shortest_segment, 2)\n    # If there was only one segment, it was already drawn as 1. If the rules\n    # strictly mean longest=1 and shortest=2 even if they are the same segment,\n    # the shortest segment (value 2) would overwrite the longest (value 1).\n    # The examples suggest they must be distinct segments if both 1 and 2 appear.\n    # Let's refine: if longest and shortest are the *same* segment object,\n    # only draw it as 1 (longest). If they refer to different segments\n    # (even if they happen to have the same length), draw both.\n    # The current logic achieves this: if len(segments) == 1, longest==shortest,\n    # so the second draw call is skipped. If len(segments) > 1, longest might\n    # still equal shortest if all segments have the same length. In this case,\n    # min/max will pick based on tie-breaking rules (column/row index). They will\n    # likely be different segments unless there's only one segment.\n    # The check `longest_segment != shortest_segment` correctly handles the case\n    # where there's only one segment. If there are multiple segments of the same min/max length,\n    # the tie-breaking in min/max ensures different segments are chosen (unless they are truly identical\n    # duplicates, which shouldn't happen with this segment finding logic).\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2556,
    "candidates_token_count": 2289,
    "total_token_count": 4845,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.50681,
  "retries": 1
}