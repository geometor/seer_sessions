{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport numpy as np\n\ndef get_background_value(grid: list[list[int]]) -> int:\n    \"\"\"Finds the most frequent value in the grid.\"\"\"\n    counts = collections.Counter(item for row in grid for item in row)\n    # Find the element with the maximum count\n    if not counts:\n        # Handle empty grid case if necessary, though examples suggest non-empty\n        return -1 # Or raise an error\n    background_val = counts.most_common(1)[0][0]\n    return background_val\n\ndef get_foreground_counts(grid: list[list[int]], background_val: int) -> dict[int, int]:\n    \"\"\"Counts the frequency of non-background values.\"\"\"\n    counts = collections.Counter()\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            val = grid[r][c]\n            if val != background_val:\n                counts[val] += 1\n    return dict(counts)\n\ndef sort_foreground_values(foreground_counts: dict[int, int]) -> list[int]:\n    \"\"\"\n    Sorts foreground values.\n    Primary sort key: count (descending).\n    Secondary sort key: value (descending).\n    \"\"\"\n    # Create a list of tuples (value, count)\n    items = list(foreground_counts.items())\n    # Sort the list: first by count descending (-x[1]), then by value descending (-x[0])\n    items.sort(key=lambda x: (-x[1], -x[0]))\n    # Return just the sorted values\n    return [item[0] for item in items]\n\ndef fill_layer(grid: np.ndarray, layer_index: int, value: int):\n    \"\"\"Fills the specified concentric layer of the grid with the given value.\"\"\"\n    n = grid.shape[0]\n    # Top row\n    for c in range(layer_index, n - layer_index):\n        grid[layer_index, c] = value\n    # Bottom row\n    for c in range(layer_index, n - layer_index):\n        grid[n - 1 - layer_index, c] = value\n    # Left column (excluding corners already filled)\n    for r in range(layer_index + 1, n - 1 - layer_index):\n        grid[r, layer_index] = value\n    # Right column (excluding corners already filled)\n    for r in range(layer_index + 1, n - 1 - layer_index):\n        grid[r, n - 1 - layer_index] = value\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the frequency and value of non-background numbers.\n\n    1.  Find the most frequent number (background).\n    2.  Count frequencies of all other (foreground) numbers.\n    3.  Sort foreground numbers: descending by frequency, then descending by value.\n    4.  Create an output grid of size N = 2 * k - 1, where k is the number of unique foreground numbers.\n    5.  Fill the output grid with concentric square layers using the sorted foreground numbers,\n        starting with the first sorted number for the outermost layer and moving inwards.\n    \"\"\"\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # 1. Find the background value\n    background_val = get_background_value(input_grid)\n\n    # 2. Count foreground values\n    foreground_counts = get_foreground_counts(input_grid, background_val)\n\n    # Handle case where there are no foreground elements\n    if not foreground_counts:\n         # Decide on behavior: empty grid, grid of background, etc.\n         # Based on examples, seems there's always foreground. Let's assume k >= 1.\n         # If k=0 was possible, we'd need a specific rule. Returning 1x1 grid of background?\n         # For now, assume k>=1 as per examples.\n         # Or maybe return a single cell with the most common element if *only* one exists?\n         # Let's proceed assuming k >= 1 based on given examples.\n         # If we only had background, maybe return [[background_val]]? Let's handle that edge case.\n         all_values = [item for row in input_grid for item in row]\n         if len(set(all_values)) <= 1:\n             return [[background_val]] # Or based on specific requirement for this case\n\n\n    # 3. Sort foreground values\n    sorted_foreground_values = sort_foreground_values(foreground_counts)\n    num_foreground = len(sorted_foreground_values)\n\n    # Handle the edge case again if sorting resulted in empty list (shouldn't happen if foreground_counts wasn't empty)\n    if num_foreground == 0:\n         # This case implies only background exists.\n         return [[background_val]]\n\n\n    # 4. Determine output grid size\n    output_size = 2 * num_foreground - 1\n\n    # 5. Create and fill the output grid\n    # Initialize with a placeholder, e.g., -1, or the innermost value immediately\n    # The innermost value is the last one in the sorted list\n    innermost_value = sorted_foreground_values[-1]\n    output_grid_np = np.full((output_size, output_size), innermost_value, dtype=int)\n\n    # Fill layers from outermost (index 0) inwards\n    num_layers = num_foreground # Same as the number of unique foreground values\n    for layer_index in range(num_layers):\n        value_for_layer = sorted_foreground_values[layer_index]\n        fill_layer(output_grid_np, layer_index, value_for_layer)\n\n    # Convert numpy array back to list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1210,
    "candidates_token_count": 2741,
    "total_token_count": 3951,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.679789,
  "retries": 1
}