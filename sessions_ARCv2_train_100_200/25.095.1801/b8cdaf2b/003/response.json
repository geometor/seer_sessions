{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransformation rule:\n1. Initialize the output grid as a deep copy of the input grid.\n2. Scan the input grid rows from bottom to top.\n3. Identify the first row (`r_orig`) that contains a horizontal pattern `B C...C B`, where:\n    * `B` is a non-zero boundary color.\n    * `C` is a non-zero central color, different from `B`.\n    * `C...C` is a contiguous segment of color `C` with length `N >= 1`.\n    * The `B` pixels are immediately adjacent to the `C` segment at columns `c_left` and `c_right`.\n4. Once the first such pattern is found, stop scanning. Record `C`, `B`, `N`, `r_orig`, `c_left`, `c_right`.\n5. If no pattern is found, return the unchanged copy of the input grid.\n6. If a pattern was found, apply propagation rules:\n    a. **Special Case:** If `B == 8` OR (`B == 2` AND `N > 1`):\n        - Add color `C` at `(r_orig - 3, c_left - 1)` (if in bounds).\n        - Add color `C` at `(r_orig - 3, c_right + 1)` (if in bounds).\n        - Add color `C` at `(r_orig - 2, c_left)` (if in bounds).\n        - Add color `C` at `(r_orig - 2, c_right)` (if in bounds).\n    b. **Default Case:** Otherwise:\n        - Add color `C` at `(r_orig - 2, c_left)` (if in bounds).\n        - Add color `C` at `(r_orig - 2, c_right)` (if in bounds).\n7. Return the modified output grid.\n\"\"\"\n\ndef _find_pattern(grid: list[list[int]]) -> dict | None:\n    \"\"\"\n    Helper function to find the first occurrence (from bottom) of the B-C-B pattern.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A dictionary containing pattern details (C, B, N, r_orig, c_left, c_right)\n        or None if no pattern is found.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n\n    for r_orig in range(rows - 1, -1, -1): # Scan rows from bottom up\n        row = grid[r_orig]\n        c = 0\n        while c < cols:\n            # Find potential start of central segment (non-zero)\n            if row[c] != 0:\n                central_color_C = row[c]\n                start_c = c\n                # Find the end of the central segment\n                while c + 1 < cols and row[c + 1] == central_color_C:\n                    c += 1\n                end_c = c\n                central_segment_length_N = end_c - start_c + 1\n\n                # Check for left boundary pixel B (non-zero, different from C)\n                c_left = start_c - 1\n                if c_left >= 0:\n                    boundary_color_B = row[c_left]\n                    if boundary_color_B != 0 and boundary_color_B != central_color_C:\n                        # Check for right boundary pixel B (must be the *same* B)\n                        c_right = end_c + 1\n                        if c_right < cols and row[c_right] == boundary_color_B:\n                            # Pattern found!\n                            return {\n                                \"C\": central_color_C,\n                                \"B\": boundary_color_B,\n                                \"N\": central_segment_length_N,\n                                \"r_orig\": r_orig,\n                                \"c_left\": c_left,\n                                \"c_right\": c_right,\n                            }\n                # Move scanner past the current segment\n                c = end_c + 1\n            else:\n                c += 1 # Move past zero\n    return None # No pattern found\n\ndef _is_within_bounds(r, c, rows, cols):\n    \"\"\"Checks if coordinates (r, c) are within the grid boundaries.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(output_grid)\n    cols = len(output_grid[0]) if rows > 0 else 0\n\n    # Find the specific B-C-B pattern scanning from bottom up\n    pattern_info = _find_pattern(input_grid)\n\n    # If no pattern is found, return the original grid copy\n    if not pattern_info:\n        return output_grid\n\n    # Extract pattern details\n    C = pattern_info[\"C\"]\n    B = pattern_info[\"B\"]\n    N = pattern_info[\"N\"]\n    r_orig = pattern_info[\"r_orig\"]\n    c_left = pattern_info[\"c_left\"]\n    c_right = pattern_info[\"c_right\"]\n\n    # Apply propagation rules to add new pixels\n    # Special Case: B=8 or (B=2 and N > 1)\n    if B == 8 or (B == 2 and N > 1):\n        # Rule 1: Add C at (r_orig - 3, c_left - 1)\n        target_r, target_c = r_orig - 3, c_left - 1\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n\n        # Rule 2: Add C at (r_orig - 3, c_right + 1)\n        target_r, target_c = r_orig - 3, c_right + 1\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n\n        # Rule 3: Add C at (r_orig - 2, c_left)\n        target_r, target_c = r_orig - 2, c_left\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n\n        # Rule 4: Add C at (r_orig - 2, c_right)\n        target_r, target_c = r_orig - 2, c_right\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n    # Default Case: Other B values, or B=2 and N=1\n    else:\n        # Rule 5: Add C at (r_orig - 2, c_left)\n        target_r, target_c = r_orig - 2, c_left\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n\n        # Rule 6: Add C at (r_orig - 2, c_right)\n        target_r, target_c = r_orig - 2, c_right\n        if _is_within_bounds(target_r, target_c, rows, cols):\n            output_grid[target_r][target_c] = C\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9442,
    "candidates_token_count": 2093,
    "total_token_count": 11535,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.848636,
  "retries": 1
}