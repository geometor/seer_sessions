{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransformation rule:\n1. Identify a specific horizontal pattern in the lower part of the input grid. The pattern consists of a central segment of color 'C' (length N) flanked immediately on both sides by a different non-zero color 'B'.\n2. Determine vertical propagation shifts based on the properties (B, N) of the identified pattern.\n3. Add new pixels of color 'C' to the grid at positions determined by these shifts relative to the original pattern's location. The original pattern remains unchanged.\n\nSpecifically:\n- Scan rows from bottom to top to find the first occurrence of the pattern 'B... C... B...' where B and C are distinct non-zero colors.\n- Record the row index (r_orig), the central color (C), the boundary color (B), the length of the central segment (N), the column index of the leftmost boundary pixel (c_left), the column index of the rightmost boundary pixel (c_right), and the column index of the middle pixel of the central segment (c_mid).\n- Calculate the diagonal vertical shift (V_diag): V_diag is 3 if (B == 8) or (B == 2 and N > 1), otherwise V_diag is 2.\n- Determine if central propagation should occur: True if (N == 1 and B == 8) or (N > 1 and B == 2).\n- Place new pixels of color C at:\n    - (r_orig - V_diag, c_left)\n    - (r_orig - V_diag, c_right)\n    - (r_orig - 2, c_mid) (only if central propagation is determined to occur)\n- Ensure added pixels are within grid boundaries.\n\"\"\"\n\ndef find_pattern(grid: list[list[int]]) -> dict | None:\n    \"\"\"\n    Finds the first occurrence (from bottom) of the B-C-B pattern.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A dictionary containing pattern details (C, B, N, r_orig, c_left, c_right, c_mid)\n        or None if no pattern is found.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n\n    for r_orig in range(rows - 1, -1, -1): # Scan rows from bottom up\n        row = grid[r_orig]\n        c = 0\n        while c < cols:\n            if row[c] != 0:\n                central_color_C = row[c]\n                # Find the extent of the central segment\n                start_c = c\n                while c + 1 < cols and row[c + 1] == central_color_C:\n                    c += 1\n                end_c = c\n                central_segment_length_N = end_c - start_c + 1\n\n                # Check for left boundary pixel B\n                c_left = start_c - 1\n                if c_left >= 0:\n                    boundary_color_B = row[c_left]\n                    if boundary_color_B != 0 and boundary_color_B != central_color_C:\n                        # Check for right boundary pixel B (must be the *same* B)\n                        c_right = end_c + 1\n                        if c_right < cols and row[c_right] == boundary_color_B:\n                            # Pattern found!\n                            # Calculate middle column (integer division for even N)\n                            c_mid = start_c + (central_segment_length_N - 1) // 2\n                            return {\n                                \"C\": central_color_C,\n                                \"B\": boundary_color_B,\n                                \"N\": central_segment_length_N,\n                                \"r_orig\": r_orig,\n                                \"c_left\": c_left,\n                                \"c_right\": c_right,\n                                \"c_mid\": c_mid,\n                            }\n                # Move to the next potential segment start\n                c = end_c + 1\n            else:\n                c += 1 # Move past zero\n    return None # No pattern found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: The 2D list representing the input grid.\n\n    Returns:\n        The transformed 2D list representing the output grid.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input grid\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(output_grid)\n    cols = len(output_grid[0]) if rows > 0 else 0\n\n    # 1. Find the B-C-B pattern\n    pattern_info = find_pattern(input_grid)\n\n    if pattern_info:\n        # Extract pattern details\n        C = pattern_info[\"C\"]\n        B = pattern_info[\"B\"]\n        N = pattern_info[\"N\"]\n        r_orig = pattern_info[\"r_orig\"]\n        c_left = pattern_info[\"c_left\"]\n        c_right = pattern_info[\"c_right\"]\n        c_mid = pattern_info[\"c_mid\"]\n\n        # 2. Calculate shifts and propagation flags\n        V_diag = 3 if (B == 8) or (B == 2 and N > 1) else 2\n        perform_central_propagation = (N == 1 and B == 8) or (N > 1 and B == 2)\n\n        # 3. Apply propagation - add new pixels to the output grid\n        # Diagonal propagation\n        prop_r_diag = r_orig - V_diag\n        if 0 <= prop_r_diag < rows:\n            if 0 <= c_left < cols:\n                output_grid[prop_r_diag][c_left] = C\n            if 0 <= c_right < cols:\n                output_grid[prop_r_diag][c_right] = C\n\n        # Central propagation\n        if perform_central_propagation:\n            prop_r_central = r_orig - 2\n            if 0 <= prop_r_central < rows and 0 <= c_mid < cols:\n                 output_grid[prop_r_central][c_mid] = C\n\n    # Return the potentially modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2410,
    "candidates_token_count": 2304,
    "total_token_count": 4714,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.10109,
  "retries": 1
}