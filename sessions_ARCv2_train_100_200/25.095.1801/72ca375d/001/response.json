{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1.  Identify all distinct connected groups (objects) of non-zero digits in the input grid.\n2.  For each identified object:\n    a.  Determine its bounding box (the smallest rectangle enclosing the object).\n    b.  Calculate the area of the bounding box.\n    c.  Count the number of cells occupied by the object.\n    d.  Calculate the object's density by dividing its cell count by its bounding box area.\n3.  Find the maximum density value among all calculated densities.\n4.  Select all objects that have this maximum density.\n5.  If only one object has the maximum density, choose this object.\n6.  If multiple objects share the maximum density, choose the object among them that has the largest bounding box area.\n7.  Extract the rectangular region from the input grid defined by the bounding box of the chosen object. This extracted region is the output grid.\n\"\"\"\n\ndef _find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"Finds all connected components of non-zero digits.\"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-zero and not visited, start a search (BFS)\n            if grid[r, c] != 0 and (r, c) not in visited:\n                digit = grid[r, c]\n                object_cells = []\n                q = deque([(r, c)])\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Check bounds and if already visited or not the correct digit\n                    if not (0 <= curr_r < rows and 0 <= curr_c < cols) or \\\n                       (curr_r, curr_c) in visited or \\\n                       grid[curr_r, curr_c] != digit:\n                        continue\n                        \n                    visited.add((curr_r, curr_c))\n                    object_cells.append((curr_r, curr_c))\n                    \n                    # Add neighbors to the queue\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if (nr, nc) not in visited : # Optimization: only add if not visited\n                             q.append((nr, nc))\n\n                if object_cells:\n                     objects.append({'digit': digit, 'cells': object_cells})\n                     \n    return objects\n\ndef _calculate_properties(obj: dict) -> dict:\n    \"\"\"Calculates bounding box, area, cell count, and density for an object.\"\"\"\n    if not obj['cells']:\n        return {**obj, 'min_row': -1, 'max_row': -1, 'min_col': -1, 'max_col': -1, \n                'cell_count': 0, 'bbox_area': 0, 'density': 0.0}\n\n    rows = [r for r, c in obj['cells']]\n    cols = [c for r, c in obj['cells']]\n    \n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    \n    cell_count = len(obj['cells'])\n    bbox_height = max_row - min_row + 1\n    bbox_width = max_col - min_col + 1\n    bbox_area = bbox_height * bbox_width\n    \n    density = 0.0\n    if bbox_area > 0:\n        density = cell_count / bbox_area\n        \n    return {\n        **obj,\n        'min_row': min_row,\n        'max_row': max_row,\n        'min_col': min_col,\n        'max_col': max_col,\n        'cell_count': cell_count,\n        'bbox_area': bbox_area,\n        'density': density\n    }\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Identifies non-zero objects in the grid, calculates their density \n    (cell count / bounding box area), selects the object with the highest \n    density (using largest bounding box area as a tie-breaker), and returns \n    the subgrid corresponding to that object's bounding box.\n    \"\"\"\n    \n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify all distinct connected non-zero objects\n    objects_raw = _find_objects(grid_np)\n    \n    if not objects_raw:\n        # Handle case with no objects found (e.g., all zeros grid)\n        return [] \n\n    # 2. Calculate properties for each object\n    objects_with_props = [_calculate_properties(obj) for obj in objects_raw]\n\n    # 3. Find the maximum density\n    max_density = 0.0\n    if objects_with_props:\n         max_density = max(obj['density'] for obj in objects_with_props)\n\n    # 4. Filter objects by maximum density\n    max_density_objects = [obj for obj in objects_with_props if obj['density'] == max_density]\n    \n    # 5. & 6. Select the object (handle ties with max bbox area)\n    selected_object = None\n    if len(max_density_objects) == 1:\n        selected_object = max_density_objects[0]\n    elif len(max_density_objects) > 1:\n        max_bbox_area = max(obj['bbox_area'] for obj in max_density_objects)\n        # In case of a tie in both density and area, just pick the first one.\n        # The problem description doesn't specify further tie-breaking.\n        selected_object = next(obj for obj in max_density_objects if obj['bbox_area'] == max_bbox_area)\n        \n    if selected_object is None:\n         # Should not happen if there were initial objects, but safeguard\n         return [] \n\n    # 7. Extract the subgrid based on the selected object's bounding box\n    min_r, max_r = selected_object['min_row'], selected_object['max_row']\n    min_c, max_c = selected_object['min_col'], selected_object['max_col']\n    \n    output_np = grid_np[min_r : max_r + 1, min_c : max_c + 1]\n    \n    # Convert output numpy array back to list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2077,
    "candidates_token_count": 2752,
    "total_token_count": 4829,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.800909,
  "retries": 1
}