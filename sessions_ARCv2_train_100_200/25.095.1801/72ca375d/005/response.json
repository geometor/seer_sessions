{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math # Although median calculation doesn't strictly need math module here\n\n\"\"\"\nIdentify all distinct connected groups (objects) of the same non-zero digit within the input grid.\nCreate a list containing the unique digit value associated with each distinct object found.\nSort this list of unique digit values in ascending order.\nDetermine the median value from this sorted list. (For a list with an odd number of elements, this is the middle element).\nFind the specific object identified in step 1 whose digit value is equal to the calculated median value.\nDetermine the bounding box (minimum and maximum row and column indices) of this selected object.\nExtract the rectangular subgrid from the original input grid defined by this bounding box. This subgrid is the final output.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all connected components of non-zero digits using Breadth-First Search (BFS) \n    and determines their bounding boxes.\n    \n    Args:\n        grid: A NumPy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its 'digit' and 'bbox' [min_row, max_row, min_col, max_col].\n        Example: [{'digit': 4, 'bbox': [1, 2, 2, 3]}, ...]\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-zero and not visited, start a search (BFS)\n            if grid[r, c] != 0 and (r, c) not in visited:\n                digit = grid[r, c]\n                object_cells = []\n                q = deque([(r, c)])\n                visited.add((r,c)) # Mark starting cell visited immediately\n\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    object_cells.append((curr_r, curr_c))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    \n                    # Add neighbors to the queue (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, correct digit, and if not visited before adding\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == digit and (nr, nc) not in visited:\n                             visited.add((nr, nc)) # Mark visited when adding to queue\n                             q.append((nr, nc))\n\n                if object_cells: # Ensure we found at least one cell for the object\n                     objects.append({\n                         'digit': digit, \n                         'bbox': [min_r, max_r, min_c, max_c]\n                     })\n                     \n    return objects\n\ndef _calculate_median(digits: list[int]) -> float | int | None:\n    \"\"\"Calculates the median value of a list of numbers.\"\"\"\n    n = len(digits)\n    if n == 0: \n        return None\n    sorted_digits = sorted(digits)\n    mid_index = n // 2\n    if n % 2 == 1:\n        # Odd number of elements, median is the middle one\n        return sorted_digits[mid_index]\n    else:\n        # Even number of elements, median is the average of the two middle ones\n        # Note: Based on examples, expecting odd count, but handle even for robustness.\n        return (sorted_digits[mid_index - 1] + sorted_digits[mid_index]) / 2\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by selecting the object whose digit is the median\n    of all unique object digits present, and returning its bounding box.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct connected non-zero objects and their digits/bboxes\n    objects = _find_objects(grid_np)\n\n    # Handle edge case: no objects found\n    if not objects:\n        return [] \n\n    # 2. Create a sorted list of unique digit values from all identified objects\n    unique_digits = sorted(list(set(obj['digit'] for obj in objects)))\n\n    # 3. Determine the median value from this sorted list\n    median_digit = _calculate_median(unique_digits)\n    \n    # Handle edge case: median couldn't be calculated (e.g., no unique digits)\n    if median_digit is None:\n        return [] \n\n    # 4. Find the object whose digit value matches the median\n    selected_object = None\n    for obj in objects:\n        # Use math.isclose for potential floating point medians if needed,\n        # but digits are ints, so direct comparison is fine here.\n        if obj['digit'] == median_digit:\n            selected_object = obj\n            break # Assume only one object will match the median based on examples\n\n    # Handle edge case: no object matched the median (shouldn't happen based on examples)\n    if selected_object is None:\n        return []\n\n    # 5. Determine the bounding box of the selected object\n    min_r, max_r, min_c, max_c = selected_object['bbox']\n\n    # 6. Extract the rectangular subgrid defined by the bounding box\n    output_np = grid_np[min_r : max_r + 1, min_c : max_c + 1]\n\n    # Convert the output NumPy array back to a list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12953,
    "candidates_token_count": 1839,
    "total_token_count": 14792,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.497559,
  "retries": 1
}