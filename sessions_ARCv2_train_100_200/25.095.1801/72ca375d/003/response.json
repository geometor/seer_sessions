{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentify all distinct connected non-zero objects in the input grid.\nFor each object, determine its bounding box, cell count, bounding box area, density (cell count / area), and the count of unique digits (including 0) within its bounding box.\nFind the minimum count of unique digits found across all object bounding boxes.\nSelect all objects whose bounding box contains this minimum number of unique digits.\nIf only one object is selected, this is the target object.\nIf multiple objects are selected (tie in minimum unique digits):\n  Calculate the absolute difference between each tied object's density and 0.75.\n  Select the object(s) from this tied set whose density difference from 0.75 is the smallest.\nIf there is still a tie (multiple objects have the same minimum density difference):\n  Select the object among these tied objects that has the largest bounding box area. (If still tied, the first one encountered is chosen).\nExtract the rectangular region from the input grid defined by the bounding box of the finally selected object. This extracted region is the output grid.\n\"\"\"\n\ndef _find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all connected components of non-zero digits using Breadth-First Search (BFS).\n    \n    Args:\n        grid: A NumPy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its 'digit' and a list of its 'cells' (coordinates).\n        Example: [{'digit': 4, 'cells': [(1, 2), (1, 3), (2, 2), (2, 3)]}, ...]\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-zero and not visited, start a search (BFS)\n            if grid[r, c] != 0 and (r, c) not in visited:\n                digit = grid[r, c]\n                object_cells = []\n                q = deque([(r, c)])\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Check bounds and if already visited or not the correct digit\n                    if not (0 <= curr_r < rows and 0 <= curr_c < cols) or \\\n                       (curr_r, curr_c) in visited or \\\n                       grid[curr_r, curr_c] != digit:\n                        continue\n                        \n                    visited.add((curr_r, curr_c))\n                    object_cells.append((curr_r, curr_c))\n                    \n                    # Add neighbors to the queue (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds before adding to queue to avoid unnecessary checks later\n                        if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                             q.append((nr, nc))\n\n                if object_cells:\n                     objects.append({'digit': digit, 'cells': object_cells})\n                     \n    return objects\n\ndef _calculate_properties(obj: dict, grid: np.ndarray) -> dict:\n    \"\"\"\n    Calculates bounding box, area, cell count, density, and unique digit count \n    within the bounding box for a given object.\n\n    Args:\n        obj: A dictionary representing an object {'digit': ..., 'cells': ...}.\n        grid: The full input NumPy array.\n\n    Returns:\n        The input object dictionary updated with calculated properties:\n        'min_row', 'max_row', 'min_col', 'max_col', 'cell_count', \n        'bbox_area', 'density', 'unique_digits_in_bbox'.\n        Returns None for properties if the object has no cells.\n    \"\"\"\n    if not obj['cells']:\n        # Should not happen with _find_objects logic, but safeguard\n        return {**obj, 'min_row': -1, 'max_row': -1, 'min_col': -1, 'max_col': -1, \n                'cell_count': 0, 'bbox_area': 0, 'density': 0.0, 'unique_digits_in_bbox': 0}\n\n    rows = [r for r, c in obj['cells']]\n    cols = [c for r, c in obj['cells']]\n    \n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    \n    cell_count = len(obj['cells'])\n    bbox_height = max_row - min_row + 1\n    bbox_width = max_col - min_col + 1\n    bbox_area = bbox_height * bbox_width\n    \n    density = 0.0\n    if bbox_area > 0:\n        density = cell_count / bbox_area\n        \n    # Count unique digits within the bounding box\n    bbox_subgrid = grid[min_row : max_row + 1, min_col : max_col + 1]\n    unique_digits_in_bbox = len(np.unique(bbox_subgrid))\n        \n    return {\n        **obj,\n        'min_row': min_row,\n        'max_row': max_row,\n        'min_col': min_col,\n        'max_col': max_col,\n        'cell_count': cell_count,\n        'bbox_area': bbox_area,\n        'density': density,\n        'unique_digits_in_bbox': unique_digits_in_bbox\n    }\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Identifies non-zero objects, calculates properties including the number of unique\n    digits within each object's bounding box. Selects the object based on minimizing \n    this unique digit count. Ties are broken by selecting the object whose density \n    is closest to 0.75. Further ties are broken by selecting the object with the \n    largest bounding box area. Finally, returns the subgrid corresponding to the \n    selected object's bounding box.\n    \"\"\"\n    \n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify all distinct connected non-zero objects\n    objects_raw = _find_objects(grid_np)\n    \n    # Handle case with no objects found\n    if not objects_raw:\n        return [] \n\n    # 2. Calculate properties for each object\n    objects_with_props = [_calculate_properties(obj, grid_np) for obj in objects_raw]\n\n    # 3. Find the minimum count of unique digits in bounding boxes\n    min_unique_digits = min(obj['unique_digits_in_bbox'] for obj in objects_with_props)\n\n    # 4. Filter objects by minimum unique digit count (Primary Candidates)\n    primary_candidates = [obj for obj in objects_with_props if obj['unique_digits_in_bbox'] == min_unique_digits]\n    \n    # 5. Select the object based on tie-breaking rules\n    selected_object = None\n    if len(primary_candidates) == 1:\n        # 5a. No tie in unique digits\n        selected_object = primary_candidates[0]\n    elif len(primary_candidates) > 1:\n        # 5b. Tie in unique digits - use density proximity to 0.75\n        target_density = 0.75\n        min_density_diff = float('inf')\n        for obj in primary_candidates:\n            diff = abs(obj['density'] - target_density)\n            min_density_diff = min(min_density_diff, diff)\n        \n        # Filter based on minimum density difference (Secondary Candidates)\n        secondary_candidates = [obj for obj in primary_candidates if abs(obj['density'] - target_density) == min_density_diff]\n\n        if len(secondary_candidates) == 1:\n            # 5c. Tie broken by density proximity\n            selected_object = secondary_candidates[0]\n        elif len(secondary_candidates) > 1:\n             # 5d. Tie in density proximity - use max bounding box area\n             max_bbox_area = max(obj['bbox_area'] for obj in secondary_candidates)\n             # Use next() to get the first object matching the max area in case of final ties\n             selected_object = next(obj for obj in secondary_candidates if obj['bbox_area'] == max_bbox_area)\n        else: # Should not happen if primary_candidates was > 1\n             selected_object = primary_candidates[0] # Fallback: pick first primary candidate\n             \n    else: # Should not happen if objects_raw was not empty\n        return []\n        \n    # Ensure an object was selected (mainly for robustness)\n    if selected_object is None:\n         return [] \n\n    # 6. Extract the subgrid based on the selected object's bounding box\n    min_r, max_r = selected_object['min_row'], selected_object['max_row']\n    min_c, max_c = selected_object['min_col'], selected_object['max_col']\n    \n    output_np = grid_np[min_r : max_r + 1, min_c : max_c + 1]\n    \n    # Convert output numpy array back to list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6545,
    "candidates_token_count": 3222,
    "total_token_count": 9767,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.747398,
  "retries": 1
}