{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following logic:\n1. Identifies four corner values from the absolute corners of the input grid (Top-Left, Top-Right, Bottom-Left, Bottom-Right).\n2. Locates a rectangular frame composed entirely of '1's within the input grid.\n3. Extracts the subgrid (internal pattern) located strictly inside this '1' frame. This internal pattern consists of '0's and '8's.\n4. Creates an output grid with the same dimensions as the extracted internal pattern grid.\n5. Populates the output grid by iterating through the internal pattern:\n   - If a cell in the internal pattern is '0', the corresponding cell in the output grid is set to '0'.\n   - If a cell in the internal pattern is '8', the corresponding cell in the output grid is set to one of the input's corner values based on the cell's quadrant within the internal pattern (TL quadrant maps to input's TL corner value, TR to TR, BL to BL, BR to BR).\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\ndef get_corner_values(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"Extracts the four corner values from the absolute corners of the grid.\"\"\"\n    rows, cols = grid.shape\n    tl = grid[0, 0]\n    tr = grid[0, cols - 1]\n    bl = grid[rows - 1, 0]\n    br = grid[rows - 1, cols - 1]\n    return tl, tr, bl, br\n\ndef find_internal_pattern_bounds(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Finds the row and column indices for slicing the internal pattern.\n    It assumes the internal pattern is bounded by rows and columns consisting entirely of '1's.\n    Returns (top_row, bottom_row_exclusive, left_col, right_col_exclusive).\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Find indices of rows composed entirely of '1's\n    all_one_rows = [r for r in range(rows) if np.all(grid[r, :] == 1)]\n    if not all_one_rows or len(all_one_rows) < 2:\n        raise ValueError(\"Could not find bounding rows of '1's for the frame.\")\n        \n    # Find indices of columns composed entirely of '1's\n    all_one_cols = [c for c in range(cols) if np.all(grid[:, c] == 1)]\n    if not all_one_cols or len(all_one_cols) < 2:\n         raise ValueError(\"Could not find bounding columns of '1's for the frame.\")\n\n    # Internal pattern is between the first and last all-'1' row/column\n    internal_top = min(all_one_rows) + 1\n    internal_bottom = max(all_one_rows) # Exclusive index for slicing\n    internal_left = min(all_one_cols) + 1\n    internal_right = max(all_one_cols) # Exclusive index for slicing\n\n    # Basic validation: ensure bounds are sensible\n    if not (0 <= internal_top < internal_bottom <= rows and 0 <= internal_left < internal_right <= cols):\n         raise ValueError(f\"Calculated invalid bounds: {internal_top, internal_bottom, internal_left, internal_right}\")\n         \n    return internal_top, internal_bottom, internal_left, internal_right\n\ndef extract_internal_pattern(grid: np.ndarray, bounds: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the subgrid within the given boundaries.\"\"\"\n    top, bottom, left, right = bounds\n    return grid[top:bottom, left:right]\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n\n    # --- Identify Components ---\n    # 1. Get the four corner values from the input grid\n    tl_corner, tr_corner, bl_corner, br_corner = get_corner_values(grid_np)\n\n    # 2. Find the boundaries of the internal pattern (inside the '1' frame)\n    try:\n        bounds = find_internal_pattern_bounds(grid_np)\n    except ValueError as e:\n        print(f\"Error finding bounds: {e}\")\n        # Handle error case: perhaps return empty grid or re-raise\n        # For this problem structure, an error likely indicates an unexpected input format.\n        return [] \n\n    # 3. Extract the internal pattern subgrid\n    internal_pattern = extract_internal_pattern(grid_np, bounds)\n\n    # --- Initialize Output ---\n    # Get dimensions of the internal pattern\n    h, w = internal_pattern.shape\n    if h == 0 or w == 0:\n        # Handle empty internal pattern case if necessary\n        return []\n        \n    # Create output grid with the same dimensions as the internal pattern\n    output_grid_np = np.zeros((h, w), dtype=int)\n\n    # --- Populate Output Grid ---\n    # Iterate through each cell (r, c) of the internal pattern\n    for r in range(h):\n        for c in range(w):\n            # Get the value 'v' from the internal pattern\n            v = internal_pattern[r, c]\n\n            # If v is 0, copy 0 to the output\n            if v == 0:\n                output_grid_np[r, c] = 0\n            # If v is 8, determine the quadrant and assign the corresponding corner value\n            elif v == 8:\n                # Determine quadrant using floating point division for midpoint comparison\n                # Top-Left quadrant\n                if r < h / 2 and c < w / 2:\n                    output_grid_np[r, c] = tl_corner\n                # Top-Right quadrant\n                elif r < h / 2 and c >= w / 2:\n                    output_grid_np[r, c] = tr_corner\n                # Bottom-Left quadrant\n                elif r >= h / 2 and c < w / 2:\n                    output_grid_np[r, c] = bl_corner\n                # Bottom-Right quadrant\n                elif r >= h / 2 and c >= w / 2:\n                    output_grid_np[r, c] = br_corner\n            # else: # Optional: handle unexpected values in internal pattern\n            #    output_grid_np[r, c] = v # or raise error, or assign default\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    # --- Return Output ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10314,
    "candidates_token_count": 3214,
    "total_token_count": 13528,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.726975,
  "retries": 1
}