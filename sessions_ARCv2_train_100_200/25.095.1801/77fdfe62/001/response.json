{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following logic:\n1. Identifies four corner values from the absolute corners of the input grid (Top-Left, Top-Right, Bottom-Left, Bottom-Right).\n2. Locates a rectangular frame composed of '1's within the input grid.\n3. Extracts the subgrid (internal pattern) located strictly inside the '1' frame, which consists of '0's and '8's.\n4. Creates an output grid with the same dimensions as the internal pattern grid.\n5. Populates the output grid by iterating through the internal pattern:\n   - If a cell in the internal pattern is '0', the corresponding cell in the output grid is set to '0'.\n   - If a cell in the internal pattern is '8', the corresponding cell in the output grid is set to one of the corner values based on the cell's quadrant within the internal pattern (TL quadrant maps to TL corner value, TR to TR, BL to BL, BR to BR).\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\ndef find_frame_boundaries(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"Finds the row and column indices defining the inner boundary of the '1' frame.\"\"\"\n    rows, cols = grid.shape\n    min_row, max_row = -1, -1\n    min_col, max_col = -1, -1\n\n    # Find first and last rows containing non-1s (to identify frame roughly)\n    # This assumes the frame isn't at the absolute edge, which holds for examples\n    for r in range(rows):\n        if not np.all(grid[r] == 1):\n            if min_row == -1:\n                min_row = r\n            max_row = r\n\n    for c in range(cols):\n         if not np.all(grid[:, c] == 1):\n            if min_col == -1:\n                min_col = c\n            max_col = c\n\n    # The internal pattern is *inside* the frame, so boundaries are +1/-1\n    # Note: This logic assumes a frame of thickness 1 surrounding the internal pattern.\n    # Based on examples, the frame seems to be exactly at row/col `min_row`, `max_row`, `min_col`, `max_col`.\n    # So the internal pattern starts at row `min_row + 1` and col `min_col + 1`.\n    frame_top = min_row\n    frame_bottom = max_row\n    frame_left = min_col\n    frame_right = max_col\n\n    # The internal pattern is between these frame boundaries\n    internal_top = frame_top + 1\n    internal_bottom = frame_bottom -1 # Exclusive index for slicing\n    internal_left = frame_left + 1\n    internal_right = max_col - 1 # Exclusive index for slicing\n\n    # Return the start/end indices for slicing the internal pattern\n    return internal_top, internal_bottom + 1, internal_left, internal_right + 1\n\n\ndef extract_internal_pattern(grid: np.ndarray, top: int, bottom: int, left: int, right: int) -> np.ndarray:\n    \"\"\"Extracts the subgrid within the given boundaries.\"\"\"\n    return grid[top:bottom, left:right]\n\ndef get_corner_values(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"Extracts the four corner values from the absolute corners of the grid.\"\"\"\n    rows, cols = grid.shape\n    tl = grid[0, 0]\n    tr = grid[0, cols - 1]\n    bl = grid[rows - 1, 0]\n    br = grid[rows - 1, cols - 1]\n    return tl, tr, bl, br\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n\n    # --- Identify Components ---\n    # 1. Get the four corner values\n    tl_corner, tr_corner, bl_corner, br_corner = get_corner_values(grid_np)\n\n    # 2. Find the boundaries of the internal pattern (inside the '1' frame)\n    # We need to locate the frame first. Frame rows/cols usually contain only '1's\n    # except where they intersect the internal pattern area.\n    # A simpler approach for the given examples: find the first/last row/col\n    # that is *not* entirely composed of '1's. The internal pattern is inside this.\n    \n    rows_with_non_ones = [r for r in range(grid_np.shape[0]) if not np.all(grid_np[r] == 1)]\n    cols_with_non_ones = [c for c in range(grid_np.shape[1]) if not np.all(grid_np[:, c] == 1)]\n    \n    if not rows_with_non_ones or not cols_with_non_ones:\n         # Handle cases where no clear frame/internal pattern is found (e.g., all 1s)\n         # Based on examples, this shouldn't happen.\n         # Let's assume frame exists and find its boundaries more directly\n         # Find rows/cols that contain a '1' but are not *all* '1's - these define the frame boundary adjacent to the pattern\n         \n         frame_rows = []\n         for r in range(grid_np.shape[0]):\n             row = grid_np[r,:]\n             if 1 in row and not np.all(row == 1):\n                 frame_rows.append(r)\n         frame_cols = []\n         for c in range(grid_np.shape[1]):\n              col = grid_np[:,c]\n              if 1 in col and not np.all(col == 1):\n                  frame_cols.append(c)\n         \n         if not frame_rows or not frame_cols:\n            # Fallback or raise error if frame isn't found\n            # Based on structure, the core pattern should be bounded by 1s\n            # Let's try the boundary finding function\n             try:\n                 internal_top, internal_bottom, internal_left, internal_right = find_frame_boundaries(grid_np)\n             except: # If boundary finding fails, maybe it's a simpler case?\n                 raise ValueError(\"Could not determine frame boundaries.\") # Or return empty?\n         else:\n             internal_top = min(frame_rows) + 1\n             internal_bottom = max(frame_rows) # Exclusive index for slicing\n             internal_left = min(frame_cols) + 1\n             internal_right = max(frame_cols) # Exclusive index for slicing\n\n    else:\n        # The internal pattern rows/cols are between the min/max row/col containing non-1s\n        internal_top = min(rows_with_non_ones)\n        internal_bottom = max(rows_with_non_ones) + 1 # Exclusive index for slicing\n        internal_left = min(cols_with_non_ones)\n        internal_right = max(cols_with_non_ones) + 1 # Exclusive index for slicing\n\n\n    # 3. Extract the internal pattern subgrid\n    internal_pattern = grid_np[internal_top:internal_bottom, internal_left:internal_right]\n\n    # --- Initialize Output ---\n    # Get dimensions of the internal pattern\n    h, w = internal_pattern.shape\n    # Create output grid with the same dimensions, initialized perhaps with zeros\n    output_grid_np = np.zeros((h, w), dtype=int)\n\n    # --- Populate Output Grid ---\n    # Iterate through each cell (r, c) of the internal pattern\n    for r in range(h):\n        for c in range(w):\n            # Get the value 'v' from the internal pattern\n            v = internal_pattern[r, c]\n\n            # If v is 0, copy 0 to the output\n            if v == 0:\n                output_grid_np[r, c] = 0\n            # If v is 8, determine the quadrant and assign the corresponding corner value\n            elif v == 8:\n                # Determine quadrant (using floating point division for midpoint)\n                # Top-Left quadrant\n                if r < h / 2 and c < w / 2:\n                    output_grid_np[r, c] = tl_corner\n                # Top-Right quadrant\n                elif r < h / 2 and c >= w / 2:\n                    output_grid_np[r, c] = tr_corner\n                # Bottom-Left quadrant\n                elif r >= h / 2 and c < w / 2:\n                    output_grid_np[r, c] = bl_corner\n                # Bottom-Right quadrant\n                elif r >= h / 2 and c >= w / 2:\n                    output_grid_np[r, c] = br_corner\n            # Handle unexpected values if necessary (though examples only show 0 and 8)\n            # else:\n            #    output_grid_np[r, c] = v # or some error value?\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    # --- Return Output ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2023,
    "candidates_token_count": 2589,
    "total_token_count": 4612,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.908941,
  "retries": 1
}