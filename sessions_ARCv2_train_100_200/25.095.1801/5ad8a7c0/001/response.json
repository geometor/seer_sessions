{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np # Although not strictly necessary for this logic, it's often useful for grid manipulations\n\n\"\"\"\nThe transformation operates row by row, contingent on the overall pattern composition of the grid.\n\n1.  **Identify Row Patterns:** Each row is classified based on the position and number of '2's:\n    *   **Pattern 1 (P1):** Contains exactly two '2's, located at the very beginning and very end of the row (e.g., `[2, 0, ..., 0, 2]`).\n    *   **Pattern 2 (P2):** Contains exactly two '2's, located at the second and second-to-last positions (e.g., `[0, 2, 0, ..., 0, 2, 0]`).\n    *   **Other Pattern (OP):** Any row containing '2's that does not fit P1 or P2, or rows containing a number of '2's other than zero or two.\n    *   **Zero Row (ZR):** A row containing only '0's.\n\n2.  **Check for Inhibition:** If *any* row in the grid matches the Other Pattern (OP), the entire grid remains unchanged.\n\n3.  **Apply Transformation (if not inhibited):**\n    *   **P2 Priority:** If the grid contains *any* P2 rows (and potentially P1 and/or ZR rows, but no OP rows), then *only* the P2 rows are modified. The modification involves changing all '0's located strictly *between* the two '2's in the P2 row to '2'. P1 rows remain unchanged in this case.\n    *   **P1 Fallback:** If the grid contains *only* P1 rows (and potentially ZR rows, but no P2 or OP rows), then the P1 rows are modified. The modification involves changing all '0's located strictly *between* the two '2's in the P1 row to '2'.\n\n4.  Zero Rows (ZR) are never modified.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef is_pattern_1(row: list[int]) -> bool:\n    \"\"\"Checks if a row matches Pattern 1: [2, 0, ..., 0, 2].\"\"\"\n    n = len(row)\n    if n < 2:\n        return False\n    # Check ends and count of 2s\n    if row[0] == 2 and row[n-1] == 2 and row.count(2) == 2:\n        # Check intermediates are all 0\n        for i in range(1, n - 1):\n            if row[i] != 0:\n                return False\n        return True\n    return False\n\ndef is_pattern_2(row: list[int]) -> bool:\n    \"\"\"Checks if a row matches Pattern 2: [0, 2, 0, ..., 0, 2, 0].\"\"\"\n    n = len(row)\n    # Minimum length for pattern 2 is technically 4, e.g., [0, 2, 2, 0]\n    if n < 4: \n        return False\n    # Check second/second-to-last, ends, and count of 2s\n    if row[1] == 2 and row[n-2] == 2 and row[0] == 0 and row[n-1] == 0 and row.count(2) == 2:\n         # Check intermediates are all 0\n        for i in range(2, n - 2):\n            if row[i] != 0:\n                return False\n        return True\n    return False\n\ndef fill_pattern_1(row: list[int]) -> list[int]:\n    \"\"\"Fills the zeros between the 2s in a Pattern 1 row.\"\"\"\n    n = len(row)\n    new_row = list(row) # Copy the row to avoid modifying the original if passed directly\n    for i in range(1, n - 1):\n        new_row[i] = 2\n    return new_row\n\ndef fill_pattern_2(row: list[int]) -> list[int]:\n    \"\"\"Fills the zeros between the 2s in a Pattern 2 row.\"\"\"\n    n = len(row)\n    new_row = list(row) # Copy the row\n    for i in range(2, n - 2):\n        new_row[i] = 2\n    return new_row\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on row patterns P1 and P2,\n    inhibited by Other Patterns (OP), with P2 taking priority over P1.\n    \"\"\"\n    # Create a deep copy to avoid modifying the original input\n    output_grid = copy.deepcopy(input_grid)\n    \n    if not input_grid or not input_grid[0]:\n        return output_grid # Handle empty grid case\n\n    rows = len(input_grid)\n    \n    p1_indices = []\n    p2_indices = []\n    has_other_pattern = False\n\n    # 1. Identify Row Patterns and Check for Inhibition\n    for r, row in enumerate(input_grid):\n        num_twos = row.count(2)\n        \n        if num_twos == 0:\n            continue # Zero Row (ZR), no action needed, doesn't inhibit\n        elif num_twos == 2:\n            if is_pattern_1(row):\n                p1_indices.append(r)\n            elif is_pattern_2(row):\n                p2_indices.append(r)\n            else: # Two 2s, but not P1 or P2 -> Other Pattern (OP)\n                has_other_pattern = True\n                break # Stop checking if OP found, as it inhibits all changes\n        else: # Not 0 or 2 '2's -> Other Pattern (OP)\n             has_other_pattern = True\n             break # Stop checking if OP found\n\n    # 2. Apply Transformation Logic (if not inhibited)\n    if has_other_pattern:\n        # If any OP row exists, return the original grid unchanged\n        return input_grid # Or return output_grid which is a copy\n\n    if p2_indices: \n        # P2 Priority: If P2 rows exist, only fill them\n        for r_idx in p2_indices:\n             output_grid[r_idx] = fill_pattern_2(input_grid[r_idx])\n             # Note: We modify output_grid based on the *original* input_grid[r_idx] pattern\n             \n    elif p1_indices: \n        # P1 Fallback: If only P1 (and maybe ZR) rows exist, fill P1 rows\n        for r_idx in p1_indices:\n            output_grid[r_idx] = fill_pattern_1(input_grid[r_idx])\n            # Note: We modify output_grid based on the *original* input_grid[r_idx] pattern\n\n    # If neither p1_indices nor p2_indices are non-empty (and no OP), \n    # it means the grid only contained ZR rows, so output_grid remains unchanged.\n            \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1488,
    "candidates_token_count": 3812,
    "total_token_count": 5300,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.788774,
  "retries": 1
}