{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport numpy as np # Used for potential array operations, though list-based is primary\n\n\"\"\"\nTransforms an input grid by identifying connected objects of non-zero digits. \nCalculates the 'density' (number of cells / bounding box area) for each object. \nSelects the object with the highest density. If densities are tied, selects the one with the smallest bounding box area. Further ties are broken by selecting the top-most, then left-most object.\nThe output is a new grid representing the bounding box of the selected object. \nWithin this output grid, cells corresponding to the actual positions of the selected object's cells (within its bounding box in the input) are filled with the object's digit, while all other cells are set to 0.\n\"\"\"\n\ndef find_objects(grid: list[list[int]]) -> list[dict]:\n    \"\"\"\n    Identifies all distinct connected objects of the same non-zero digit in the grid using BFS.\n    Calculates properties for each object: digit, cells, bounding box, size, area, density.\n\n    Args:\n        grid: The input grid (list of lists of ints).\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its properties. Returns an empty list if no objects are found.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0: return []\n    cols = len(grid[0])\n    if cols == 0: return []\n    \n    visited = set()\n    objects = []\n\n    # Iterate through each cell to find starting points of objects\n    for r in range(rows):\n        for c in range(cols):\n            # Skip visited cells or background (0)\n            if (r, c) in visited or grid[r][c] == 0:\n                continue\n\n            # Found a potential start of a new object, begin BFS\n            digit = grid[r][c]\n            current_object_cells = set()\n            queue = collections.deque([(r, c)])\n            visited.add((r, c)) # Mark starting cell as visited\n\n            # Initialize bounding box coordinates\n            min_r, max_r = r, r\n            min_c, max_c = c, c\n\n            # Perform BFS to find all connected cells of the same digit\n            while queue:\n                curr_r, curr_c = queue.popleft()\n                current_object_cells.add((curr_r, curr_c))\n\n                # Update bounding box as we find more cells\n                min_r = min(min_r, curr_r)\n                max_r = max(max_r, curr_r)\n                min_c = min(min_c, curr_c)\n                max_c = max(max_c, curr_c)\n\n                # Explore neighbors (up, down, left, right)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = curr_r + dr, curr_c + dc\n\n                    # Check grid boundaries\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if neighbor is part of the same object (same digit) and not yet visited\n                        if (nr, nc) not in visited and grid[nr][nc] == digit:\n                            visited.add((nr, nc))\n                            queue.append((nr, nc))\n\n            # Calculate object properties after BFS completes\n            size = len(current_object_cells)\n            height = max_r - min_r + 1\n            width = max_c - min_c + 1\n            area = height * width\n            # Calculate density, handle potential division by zero for single-cell objects in invalid grids\n            density = size / area if area > 0 else 0 \n\n            # Store the found object and its properties\n            objects.append({\n                'digit': digit,\n                'cells': current_object_cells, # Set of (row, col) tuples\n                'min_r': min_r,\n                'max_r': max_r,\n                'min_c': min_c,\n                'max_c': max_c,\n                'size': size,\n                'area': area,\n                'density': density\n            })\n\n    return objects\n\ndef extract_object_representation(selected_object: dict) -> list[list[int]]:\n    \"\"\"\n    Creates a new grid representing the bounding box of the selected object,\n    placing the object's digit only at the locations corresponding to its cells.\n\n    Args:\n        selected_object: The dictionary containing the properties of the object to extract.\n\n    Returns:\n        A new grid (list of lists of ints) containing the extracted object representation.\n    \"\"\"\n    # Retrieve properties of the selected object\n    min_r = selected_object['min_r']\n    max_r = selected_object['max_r']\n    min_c = selected_object['min_c']\n    max_c = selected_object['max_c']\n    digit = selected_object['digit']\n    cells = selected_object['cells'] # The set of (r, c) coordinates making up the object\n\n    # Calculate dimensions of the output grid (based on bounding box)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Initialize the output grid with zeros\n    output_grid = [[0 for _ in range(width)] for _ in range(height)]\n\n    # Populate the output grid based on the object's actual cells\n    # Iterate through the object's cells coordinates\n    for r, c in cells:\n        # Calculate the corresponding position in the output grid (relative to the bounding box origin)\n        output_r = r - min_r\n        output_c = c - min_c\n        # Place the object's digit in the output grid\n        output_grid[output_r][output_c] = digit\n        \n    # Alternative (slightly less efficient but maybe clearer): Iterate through bounding box\n    # for r in range(min_r, max_r + 1):\n    #     for c in range(min_c, max_c + 1):\n    #         # Check if the coordinate (r, c) is actually part of the object's cells\n    #         if (r, c) in cells: \n    #              output_grid[r - min_r][c - min_c] = digit\n\n    return output_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Main transformation function. Finds all objects, selects the one with the\n    highest density (with tie-breaking), and extracts its representation.\n    \"\"\"\n    \n    # 1. Find all distinct objects and calculate their properties\n    objects = find_objects(input_grid)\n\n    # 2. Handle the case where no non-zero objects are found\n    if not objects:\n        # Return an empty grid or handle as per specific requirements (e.g., return original grid?)\n        # For ARC tasks, usually means empty output or a minimal grid. Let's return empty list.\n        return [] \n\n    # 3. Select the target object based on criteria:\n    #    - Primary: Maximum density\n    #    - Tie-breaker 1: Minimum bounding box area (negative area for max sort)\n    #    - Tie-breaker 2: Minimum row index of top-left corner (negative min_r for max sort)\n    #    - Tie-breaker 3: Minimum col index of top-left corner (negative min_c for max sort)\n    selected_object = max(objects, key=lambda obj: (obj['density'], -obj['area'], -obj['min_r'], -obj['min_c']))\n\n    # 4. Create the output grid representation based on the selected object\n    output_grid = extract_object_representation(selected_object)\n\n    # 5. Return the final output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8789,
    "candidates_token_count": 2416,
    "total_token_count": 11205,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.283902,
  "retries": 1
}