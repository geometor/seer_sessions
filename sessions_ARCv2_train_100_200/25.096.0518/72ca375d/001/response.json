{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\n\n\"\"\"\nThis function transforms an input grid based on identifying connected objects of non-zero digits. \nIt calculates the 'density' (number of cells / bounding box area) for each object. \nThe object with the highest density is selected. \nThe output is a grid representing the bounding box of the selected object, \ncontaining the object's digit where the object exists within the box, and 0 otherwise.\n\"\"\"\n\ndef find_objects(grid: list[list[int]]) -> list[dict]:\n    \"\"\"\n    Identifies all distinct connected objects of the same non-zero digit in the grid.\n    Calculates properties for each object: digit, cells, bounding box, size, area, density.\n\n    Args:\n        grid: The input grid (list of lists of ints).\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its properties. Returns an empty list if no objects are found.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return []\n    cols = len(grid[0])\n    if cols == 0:\n        return []\n\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Skip visited cells or background (0)\n            if (r, c) in visited or grid[r][c] == 0:\n                continue\n\n            # Start finding a new object using Breadth-First Search (BFS)\n            digit = grid[r][c]\n            current_object_cells = set()\n            queue = collections.deque([(r, c)])\n            visited.add((r, c))\n\n            min_r, max_r = r, r\n            min_c, max_c = c, c\n\n            while queue:\n                curr_r, curr_c = queue.popleft()\n                current_object_cells.add((curr_r, curr_c))\n\n                # Update bounding box\n                min_r = min(min_r, curr_r)\n                max_r = max(max_r, curr_r)\n                min_c = min(min_c, curr_c)\n                max_c = max(max_c, curr_c)\n\n                # Explore neighbors (up, down, left, right)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = curr_r + dr, curr_c + dc\n\n                    # Check boundaries\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if neighbor is part of the same object and not visited\n                        if (nr, nc) not in visited and grid[nr][nc] == digit:\n                            visited.add((nr, nc))\n                            queue.append((nr, nc))\n\n            # Calculate object properties\n            size = len(current_object_cells)\n            height = max_r - min_r + 1\n            width = max_c - min_c + 1\n            area = height * width\n            # Avoid division by zero if area is somehow 0 (shouldn't happen with non-empty objects)\n            density = size / area if area > 0 else 0 \n\n            objects.append({\n                'digit': digit,\n                'cells': current_object_cells,\n                'min_r': min_r,\n                'max_r': max_r,\n                'min_c': min_c,\n                'max_c': max_c,\n                'size': size,\n                'area': area,\n                'density': density\n            })\n\n    return objects\n\ndef extract_object(grid: list[list[int]], selected_object: dict) -> list[list[int]]:\n    \"\"\"\n    Extracts the selected object into a new grid representing its bounding box.\n\n    Args:\n        grid: The original input grid.\n        selected_object: The dictionary containing the properties of the object to extract.\n\n    Returns:\n        A new grid containing the extracted object representation.\n    \"\"\"\n    min_r = selected_object['min_r']\n    max_r = selected_object['max_r']\n    min_c = selected_object['min_c']\n    max_c = selected_object['max_c']\n    digit = selected_object['digit']\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    output_grid = [[0 for _ in range(width)] for _ in range(height)]\n\n    # Iterate through the bounding box in the original grid\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # If the cell in the original grid matches the object's digit,\n            # place the digit in the corresponding output grid cell.\n            if grid[r][c] == digit:\n                output_grid[r - min_r][c - min_c] = digit\n            # Otherwise, it remains 0 (as initialized).\n\n    return output_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by finding the object with the highest density\n    and extracting its representation within its bounding box.\n    \"\"\"\n    \n    # 1. Find all distinct objects and their properties\n    objects = find_objects(input_grid)\n\n    # Handle cases with no objects\n    if not objects:\n        return [] # Or potentially return an empty grid of specific size based on requirements\n\n    # 2. Find the object with the maximum density\n    # If there's a tie in density, the first one encountered in the list is chosen.\n    # A secondary sort key (e.g., area, top-left position) could be added if needed.\n    selected_object = max(objects, key=lambda obj: obj['density'])\n\n    # 3. Extract the selected object into its bounding box grid\n    output_grid = extract_object(input_grid, selected_object)\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2413,
    "candidates_token_count": 2742,
    "total_token_count": 5155,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.039212,
  "retries": 1
}