{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1.  Identifies horizontal rows and vertical columns consisting entirely of the number 4 (Separators).\n2.  Uses these Separators and grid boundaries to define distinct rectangular Cells, assigning logical coordinates (row_index, column_index) to each.\n3.  Iterates through each Cell (TargetCell). If a TargetCell contains the number 1:\n    a.  It attempts to find a PaintColor.\n    b.  First, it checks the Cell logically above it (same column_index, row_index - 1). If this cell exists and contains exactly one unique number other than 0, 1, or 4, that number is chosen as the PaintColor.\n    c.  If no PaintColor is found above, it checks the Cell logically to the left (same row_index, column_index - 1). If this cell exists and contains exactly one unique number other than 0, 1, or 4, that number is chosen as the PaintColor.\n    d.  If a PaintColor is determined, all instances of the number 1 within the TargetCell in the output grid are replaced by the PaintColor.\n    e.  If no PaintColor is found, the 1s in the TargetCell remain unchanged.\n4.  Numbers 0 and 4, and Cells not containing 1, remain unchanged in the output grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set, Dict\n\n# --- Helper Functions ---\n\ndef _find_separators(grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns that consist entirely of the separator value (4).\"\"\"\n    rows, cols = grid.shape\n    separator_rows = [r for r in range(rows) if np.all(grid[r, :] == 4)]\n    separator_cols = [c for c in range(cols) if np.all(grid[:, c] == 4)]\n    return separator_rows, separator_cols\n\ndef _get_cell_map(grid_shape: Tuple[int, int], sep_rows: List[int], sep_cols: List[int]) -> Dict[Tuple[int, int], Tuple[int, int, int, int]]:\n    \"\"\"\n    Determines the boundaries (start_row, end_row, start_col, end_col)\n    and logical coordinates (ri, ci) of each cell, returning a map:\n    {(ri, ci): (r_start, r_end, c_start, c_end)}\n    \"\"\"\n    rows, cols = grid_shape\n    cell_map = {} # Stores {(ri, ci): (r_start, r_end, c_start, c_end)}\n\n    # Define the start and end points for row sections based on separators\n    row_starts = [0] + [r + 1 for r in sep_rows]\n    row_ends = [r for r in sep_rows] + [rows]\n\n    # Define the start and end points for column sections based on separators\n    col_starts = [0] + [c + 1 for c in sep_cols]\n    col_ends = [c for c in sep_cols] + [cols]\n\n    # Assign logical coordinates and map them to boundaries\n    ri = 0\n    for r_start, r_end in zip(row_starts, row_ends):\n        if r_start >= r_end: continue # Skip empty sections\n        ci = 0\n        for c_start, c_end in zip(col_starts, col_ends):\n            if c_start >= c_end: continue # Skip empty sections\n            cell_map[(ri, ci)] = (r_start, r_end, c_start, c_end)\n            ci += 1\n        ri += 1\n\n    return cell_map\n\ndef _get_cell_subgrid(grid: np.ndarray, boundaries: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the subgrid corresponding to the given cell boundaries.\"\"\"\n    r_start, r_end, c_start, c_end = boundaries\n    return grid[r_start:r_end, c_start:c_end]\n\ndef _find_unique_source_color(cell_subgrid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds if a cell contains exactly one unique number other than 0, 1, or 4.\n    Returns that number if found, otherwise None.\n    \"\"\"\n    # Get unique values present in the cell\n    unique_values = np.unique(cell_subgrid)\n    # Filter out background (0), target (1), and separator (4) to find potential source colors\n    source_colors: Set[int] = {val for val in unique_values if val not in {0, 1, 4}}\n    # Return the color if exactly one unique source color exists\n    if len(source_colors) == 1:\n        return source_colors.pop()\n    return None # Return None if zero or more than one source color found\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Initialize the output grid as a copy of the input\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Identify separator rows and columns (filled with 4s)\n    sep_rows, sep_cols = _find_separators(grid)\n\n    # Determine the boundaries and logical coordinates of all cells\n    cell_map = _get_cell_map((rows, cols), sep_rows, sep_cols)\n\n    # Iterate through each cell using its logical coordinates (ri, ci)\n    for (ri, ci), target_boundaries in cell_map.items():\n        # Extract the subgrid for the current target cell from the *original* input grid\n        target_cell_subgrid = _get_cell_subgrid(grid, target_boundaries)\n\n        # Only process cells that contain the target number '1'\n        if 1 not in target_cell_subgrid:\n            continue\n\n        # Attempt to find the paint color, prioritizing vertical then horizontal adjacency\n        paint_color: Optional[int] = None\n\n        # 1. Check Cell Above (Vertical Priority)\n        coords_above = (ri - 1, ci)\n        if coords_above in cell_map: # Check if a cell exists at these logical coordinates\n            source_boundaries = cell_map[coords_above]\n            source_subgrid = _get_cell_subgrid(grid, source_boundaries)\n            paint_color = _find_unique_source_color(source_subgrid)\n\n        # 2. Check Cell Left (Horizontal Priority - only if color not found above)\n        if paint_color is None:\n            coords_left = (ri, ci - 1)\n            if coords_left in cell_map: # Check if a cell exists at these logical coordinates\n                source_boundaries = cell_map[coords_left]\n                source_subgrid = _get_cell_subgrid(grid, source_boundaries)\n                paint_color = _find_unique_source_color(source_subgrid)\n\n        # 3. Apply Paint Color if found\n        if paint_color is not None:\n            # Get the boundaries of the target cell\n            tr_start, tr_end, tc_start, tc_end = target_boundaries\n            # Create a boolean mask identifying '1's within the target cell in the *original* subgrid\n            target_mask = (target_cell_subgrid == 1)\n            # Update the corresponding locations in the *output* grid using the determined paint color\n            output_grid[tr_start:tr_end, tc_start:tc_end][target_mask] = paint_color\n            # Note: Cells without a determined paint color remain unchanged as per the initial copy.\n\n    # Convert the final numpy array back to a list of lists for the return value\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13694,
    "candidates_token_count": 2624,
    "total_token_count": 16318,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.122544,
  "retries": 1
}