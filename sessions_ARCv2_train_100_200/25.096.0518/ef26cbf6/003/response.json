{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1.  Identifies horizontal rows and vertical columns entirely composed of the number 4, treating them as separators.\n2.  These separators divide the grid into rectangular cells.\n3.  For each cell containing the number 1 (TargetCell):\n    a.  It first checks for cells directly above it (sharing the top separator line and overlapping horizontally). If the first such cell found contains exactly one unique number other than 0, 1, or 4, that number (the 'PaintColor') is chosen.\n    b.  If no PaintColor is found from the cells above, it checks for cells directly to its left (sharing the left separator line and overlapping vertically). If the first such cell found contains exactly one unique number other than 0, 1, or 4, that number is used as the PaintColor.\n    c.  If a PaintColor is determined from either the cells above or the cells to the left, all instances of the number 1 within the TargetCell are replaced by the PaintColor in the output grid.\n    d.  If no PaintColor is found, the 1s in the TargetCell remain unchanged.\n4.  Numbers 0 and 4, and cells not containing 1, remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set\n\ndef _find_separators(grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns that consist entirely of the separator value (4).\"\"\"\n    rows, cols = grid.shape\n    separator_rows = [r for r in range(rows) if np.all(grid[r, :] == 4)]\n    separator_cols = [c for c in range(cols) if np.all(grid[:, c] == 4)]\n    return separator_rows, separator_cols\n\ndef _get_cell_boundaries(grid_shape: Tuple[int, int], sep_rows: List[int], sep_cols: List[int]) -> List[Tuple[int, int, int, int]]:\n    \"\"\"Determines the boundaries (start_row, end_row, start_col, end_col) of each cell.\"\"\"\n    rows, cols = grid_shape\n    cell_boundaries = []\n\n    # Define the start and end points for row sections based on separators\n    row_starts = [0] + [r + 1 for r in sep_rows]\n    row_ends = [r for r in sep_rows] + [rows]\n\n    # Define the start and end points for column sections based on separators\n    col_starts = [0] + [c + 1 for c in sep_cols]\n    col_ends = [c for c in sep_cols] + [cols]\n\n    # Create boundary tuples for each cell\n    for r_start, r_end in zip(row_starts, row_ends):\n        if r_start >= r_end: continue # Skip empty sections\n        for c_start, c_end in zip(col_starts, col_ends):\n            if c_start >= c_end: continue # Skip empty sections\n            cell_boundaries.append((r_start, r_end, c_start, c_end))\n\n    return cell_boundaries\n\ndef _get_cell_subgrid(grid: np.ndarray, boundaries: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the subgrid corresponding to the given cell boundaries.\"\"\"\n    r_start, r_end, c_start, c_end = boundaries\n    return grid[r_start:r_end, c_start:c_end]\n\ndef _find_unique_source_color(cell_subgrid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds if a cell contains exactly one unique number other than 0, 1, or 4.\n    Returns that number if found, otherwise None.\n    \"\"\"\n    # Get unique values present in the cell\n    unique_values = np.unique(cell_subgrid)\n    # Filter out background (0), target (1), and separator (4) to find potential source colors\n    source_colors: Set[int] = {val for val in unique_values if val not in {0, 1, 4}}\n    # Return the color if exactly one unique source color exists\n    if len(source_colors) == 1:\n        return source_colors.pop()\n    return None # Return None if zero or more than one source color found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to store the output, preserving the original input\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Identify separator rows and columns (filled with 4s)\n    sep_rows, sep_cols = _find_separators(grid)\n\n    # Determine the boundaries of all cells based on separators and grid edges\n    cell_boundaries = _get_cell_boundaries((rows, cols), sep_rows, sep_cols)\n\n    # Iterate through each defined cell\n    for tr_start, tr_end, tc_start, tc_end in cell_boundaries:\n        target_cell_boundaries = (tr_start, tr_end, tc_start, tc_end)\n        target_cell_subgrid = _get_cell_subgrid(grid, target_cell_boundaries)\n\n        # Only process cells that contain the target number '1'\n        if 1 not in target_cell_subgrid:\n            continue\n\n        # Initialize the paint color to None\n        paint_color: Optional[int] = None\n\n        # --- Check for source color above (Vertical Priority) ---\n        if tr_start > 0: # Can only have a cell above if not in the top row section\n            # Iterate through all cells to find potential source cells above\n            for sr_start, sr_end, sc_start, sc_end in cell_boundaries:\n                # Check if a cell ends exactly at the target cell's top boundary\n                is_directly_above = (sr_end == tr_start)\n                # Check if the columns overlap horizontally\n                has_horizontal_overlap = (max(sc_start, tc_start) < min(sc_end, tc_end))\n\n                if is_directly_above and has_horizontal_overlap:\n                    # Found a potential source cell above\n                    source_cell_boundaries = (sr_start, sr_end, sc_start, sc_end)\n                    source_cell_subgrid = _get_cell_subgrid(grid, source_cell_boundaries)\n                    # Check if this source cell has a unique source color\n                    unique_color = _find_unique_source_color(source_cell_subgrid)\n                    if unique_color is not None:\n                        paint_color = unique_color\n                        break # Found the color, stop searching above cells\n\n        # --- Check for source color to the left (Horizontal Priority - only if not found above) ---\n        if paint_color is None and tc_start > 0: # Can only have a cell left if not in the leftmost column section\n            # Iterate through all cells to find potential source cells to the left\n            for sr_start, sr_end, sc_start, sc_end in cell_boundaries:\n                # Check if a cell ends exactly at the target cell's left boundary\n                is_directly_left = (sc_end == tc_start)\n                # Check if the rows overlap vertically\n                has_vertical_overlap = (max(sr_start, tr_start) < min(sr_end, tr_end))\n\n                if is_directly_left and has_vertical_overlap:\n                    # Found a potential source cell to the left\n                    source_cell_boundaries = (sr_start, sr_end, sc_start, sc_end)\n                    source_cell_subgrid = _get_cell_subgrid(grid, source_cell_boundaries)\n                     # Check if this source cell has a unique source color\n                    unique_color = _find_unique_source_color(source_cell_subgrid)\n                    if unique_color is not None:\n                        paint_color = unique_color\n                        break # Found the color, stop searching left cells\n\n        # --- Apply the paint color if found ---\n        if paint_color is not None:\n            # Create a boolean mask for the locations of '1's within the target cell in the *original* grid\n            target_mask = (target_cell_subgrid == 1)\n            # Use this mask to update only the corresponding positions in the *output* grid\n            output_grid[tr_start:tr_end, tc_start:tc_end][target_mask] = paint_color\n\n    # Convert the final numpy array back to a list of lists for the return value\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14150,
    "candidates_token_count": 2571,
    "total_token_count": 16721,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.983393,
  "retries": 1
}