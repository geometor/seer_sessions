{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Identifies horizontal rows and vertical columns entirely composed of the number 4, treating them as separators.\n2. These separators divide the grid into rectangular cells.\n3. For each cell containing the number 1:\n    a. It first checks the cell directly above it (if one exists). If that cell contains exactly one unique number other than 0, 1, or 4, that number (the 'PaintColor') is used.\n    b. If no PaintColor is found from the cell above, it checks the cell directly to its left (if one exists). If that cell contains exactly one unique number other than 0, 1, or 4, that number is used as the PaintColor.\n    c. If a PaintColor is determined from either the cell above or the cell to the left, all instances of the number 1 within the current cell are replaced by the PaintColor in the output grid.\n    d. If no PaintColor is found, the 1s in the current cell remain unchanged.\n4. Numbers 0 and 4, and cells not containing 1, remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set\n\ndef _find_separators(grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns that consist entirely of the separator value (4).\"\"\"\n    rows, cols = grid.shape\n    separator_rows = [r for r in range(rows) if np.all(grid[r, :] == 4)]\n    separator_cols = [c for c in range(cols) if np.all(grid[:, c] == 4)]\n    return separator_rows, separator_cols\n\ndef _get_cell_boundaries(grid_shape: Tuple[int, int], sep_rows: List[int], sep_cols: List[int]) -> List[Tuple[int, int, int, int]]:\n    \"\"\"Determines the boundaries (start_row, end_row, start_col, end_col) of each cell.\"\"\"\n    rows, cols = grid_shape\n    cell_boundaries = []\n\n    row_starts = [0] + [r + 1 for r in sep_rows]\n    row_ends = [r for r in sep_rows] + [rows]\n\n    col_starts = [0] + [c + 1 for c in sep_cols]\n    col_ends = [c for c in sep_cols] + [cols]\n\n    for r_start, r_end in zip(row_starts, row_ends):\n        if r_start >= r_end: continue\n        for c_start, c_end in zip(col_starts, col_ends):\n            if c_start >= c_end: continue\n            cell_boundaries.append((r_start, r_end, c_start, c_end))\n\n    return cell_boundaries\n\ndef _get_cell_subgrid(grid: np.ndarray, boundaries: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the subgrid corresponding to the given cell boundaries.\"\"\"\n    r_start, r_end, c_start, c_end = boundaries\n    return grid[r_start:r_end, c_start:c_end]\n\ndef _find_unique_source_color(cell_subgrid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds if a cell contains exactly one unique number other than 0, 1, or 4.\n    Returns that number if found, otherwise None.\n    \"\"\"\n    # Flatten the cell and get unique values\n    unique_values = np.unique(cell_subgrid)\n    # Filter out background (0), target (1), and separator (4)\n    source_colors: Set[int] = {val for val in unique_values if val not in {0, 1, 4}}\n    # Return the color if exactly one unique source color exists\n    if len(source_colors) == 1:\n        return source_colors.pop()\n    return None\n\ndef _get_cell_at(row: int, col: int, cell_map: dict) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"Finds the cell boundaries containing the given row and col.\"\"\"\n    for boundaries, _ in cell_map.items():\n        r_start, r_end, c_start, c_end = boundaries\n        if r_start <= row < r_end and c_start <= col < c_end:\n            return boundaries\n    return None\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find separator rows and columns\n    sep_rows, sep_cols = _find_separators(grid)\n\n    # Define all cell boundaries\n    cell_boundaries = _get_cell_boundaries((rows, cols), sep_rows, sep_cols)\n\n    # Create a mapping for quick lookup of boundaries given a coordinate (optional, but can optimize)\n    # For simplicity here, we'll iterate and find adjacent cells as needed.\n\n    # Iterate through each defined cell\n    for r_start, r_end, c_start, c_end in cell_boundaries:\n        current_cell_boundaries = (r_start, r_end, c_start, c_end)\n        current_cell_subgrid = _get_cell_subgrid(grid, current_cell_boundaries)\n\n        # Check if the current cell contains any '1's\n        if 1 not in current_cell_subgrid:\n            continue # Skip if no target '1's are present\n\n        paint_color: Optional[int] = None\n\n        # 1. Check cell directly above\n        if r_start > 0:\n            # Find the boundaries of the cell above (it must end just before a separator or the current cell start)\n            potential_above_row_end = r_start -1 # separator is at r_start - 1\n            # Find a cell whose end row matches potential_above_row_end and columns overlap\n            for br, er, bc, ec in cell_boundaries:\n                if er == r_start and bc < c_end and ec > c_start: # Check if cell ends exactly above and columns overlap\n                    # Refine check for exact vertical alignment\n                    if bc == c_start and ec == c_end:\n                        cell_above_boundaries = (br, er, bc, ec)\n                        cell_above_subgrid = _get_cell_subgrid(grid, cell_above_boundaries)\n                        paint_color = _find_unique_source_color(cell_above_subgrid)\n                        break # Found the directly above cell\n            if paint_color is not None:\n                 # Replace 1s in the current cell in the output grid\n                 output_grid[r_start:r_end, c_start:c_end][current_cell_subgrid == 1] = paint_color\n                 continue # Color found and applied, move to next cell\n\n\n        # 2. Check cell directly to the left (only if color not found above)\n        if paint_color is None and c_start > 0:\n             # Find the boundaries of the cell left (it must end just before a separator or the current cell start)\n            potential_left_col_end = c_start -1 # separator is at c_start - 1\n            # Find a cell whose end col matches potential_left_col_end and rows overlap\n            for br, er, bc, ec in cell_boundaries:\n                 if ec == c_start and br < r_end and er > r_start: # Check if cell ends exactly left and rows overlap\n                     # Refine check for exact horizontal alignment\n                     if br == r_start and er == r_end:\n                        cell_left_boundaries = (br, er, bc, ec)\n                        cell_left_subgrid = _get_cell_subgrid(grid, cell_left_boundaries)\n                        paint_color = _find_unique_source_color(cell_left_subgrid)\n                        break # Found the directly left cell\n            if paint_color is not None:\n                 # Replace 1s in the current cell in the output grid\n                 output_grid[r_start:r_end, c_start:c_end][current_cell_subgrid == 1] = paint_color\n                 continue # Color found and applied, move to next cell\n\n        # If no paint_color was found from above or left, the 1s remain unchanged (already handled by copying)\n\n    # Convert back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2290,
    "candidates_token_count": 2664,
    "total_token_count": 4954,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.614396,
  "retries": 1
}