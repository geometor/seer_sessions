{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nProjects a symmetrical pattern upwards from a source element identified in the \nbottom row, coloring only background cells (0). The source element is the central \ncell of the contiguous horizontal block of non-zero cells in the bottom row \nthat is closest to the grid's horizontal center. The projection pattern's shape \ndepends on the length (L) of this source block: if L=1, the horizontal distance \n(d) from the source column equals the vertical distance (k) from the source row \nminus 1 (d = k - 1); if L>1, d equals k (d = k). The projection starts two rows \nabove the source row (k=2) and continues upwards. Only background cells \n(color 0) are modified.\n\"\"\"\n\ndef find_source_block(bottom_row: list[int], grid_width: int) -> tuple[int | None, int | None, int | None]:\n    \"\"\"\n    Finds the centrally located contiguous block of non-zero cells in the bottom row.\n\n    Args:\n        bottom_row: A list of integers representing the bottom row of the grid.\n        grid_width: The width of the grid.\n\n    Returns:\n        A tuple (length, center_col_index, center_color) for the identified source block,\n        or (None, None, None) if no suitable block is found.\n    \"\"\"\n    width = len(bottom_row)\n    blocks = []\n    in_block = False\n    start_col = -1\n\n    # Iterate through the row to find all contiguous non-zero blocks\n    for c in range(width):\n        is_non_zero = bottom_row[c] != 0\n        is_last_col = c == width - 1\n\n        if is_non_zero and not in_block:\n            # Start of a new block\n            in_block = True\n            start_col = c\n        \n        # End condition: (current cell is zero OR it's the last column) AND we are inside a block\n        if (not is_non_zero or is_last_col) and in_block:\n            in_block = False\n            # Determine the correct end column index\n            end_col = c - 1 if not is_non_zero else c \n            length = end_col - start_col + 1\n            \n            # Calculate the index of the central cell within the block\n            center_col_idx = start_col + (length - 1) // 2\n            center_color = bottom_row[center_col_idx]\n            \n            # Calculate the geometric center coordinate of the block for comparison\n            block_geometric_center = (start_col + end_col) / 2.0\n            \n            blocks.append({\n                'start': start_col,\n                'end': end_col,\n                'length': length,\n                'center_col_index': center_col_idx,\n                'center_color': center_color,\n                'geometric_center': block_geometric_center\n            })\n            # Reset start_col shouldn't be needed here as loop continues\n\n    if not blocks:\n        # No non-zero blocks found\n        return None, None, None \n\n    # Calculate the horizontal center coordinate of the entire grid\n    grid_center_coord = (grid_width - 1) / 2.0\n\n    # Find the block whose geometric center is closest to the grid's center\n    # min() with a key function finds the minimum based on the key's return value\n    closest_block = min(blocks, key=lambda b: abs(b['geometric_center'] - grid_center_coord))\n\n    # Return properties of the closest block\n    return closest_block['length'], closest_block['center_col_index'], closest_block['center_color']\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to a numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Handle edge case: grid height must be at least 2 for a bottom row and a row above\n    if height < 2:\n        # Return copy of input if grid is too small\n        return output_np.tolist() \n\n    # Identify the bottom row and its index\n    bottom_row_index = height - 1\n    bottom_row_list = input_np[bottom_row_index, :].tolist()\n\n    # Find the source block properties (length L, center column C, color X)\n    source_length, source_col, source_color = find_source_block(bottom_row_list, width)\n\n    # If no source block is found, return the initial copy\n    if source_length is None:\n        return output_np.tolist()\n\n    # Determine the projection rule based on source block length L\n    # d = horizontal distance, k = vertical distance from source row\n    if source_length == 1:\n        # Rule: d = k - 1\n        get_d = lambda k: k - 1\n    else: # source_length > 1\n        # Rule: d = k\n        get_d = lambda k: k\n        \n    # Perform the projection upwards from the source row\n    # Iterate through vertical distances (k) starting from k=2 (two rows above source)\n    # up to k=height (which corresponds to the top row, index 0, when k=height-1)\n    # Note: k = bottom_row_index - target_row\n    for k in range(2, height): \n        # Calculate target row index\n        target_row = bottom_row_index - k\n        \n        # Calculate horizontal distance 'd' based on 'k' and the rule\n        d = get_d(k)\n        \n        # If d becomes negative (can happen for k=0/1 with d=k-1, but k starts at 2), skip this k\n        if d < 0:\n            continue\n\n        # Calculate target column indices\n        target_col_left = source_col - d\n        target_col_right = source_col + d\n\n        # Project point to the left, checking bounds and background color\n        if 0 <= target_col_left < width: # Check column bounds\n            # Check if the target cell is currently background color (0)\n            if output_np[target_row, target_col_left] == 0:\n                output_np[target_row, target_col_left] = source_color\n\n        # Project point to the right, checking bounds and background color\n        # Avoid double-painting if d=0 (source_col == target_col_left == target_col_right)\n        if d != 0 and 0 <= target_col_right < width: # Check column bounds\n             # Check if the target cell is currently background color (0)\n            if output_np[target_row, target_col_right] == 0:\n                output_np[target_row, target_col_right] = source_color\n\n    # Convert the final numpy array back to a list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10674,
    "candidates_token_count": 2101,
    "total_token_count": 12775,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.384324,
  "retries": 1
}