{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation takes an input grid containing horizontal bars of various colors above a solid azure floor line at the bottom. \nIt identifies these bars, sorts them by their original vertical position (lowest first), and then stacks them vertically upwards starting from the row just above the azure floor. \nCrucially, each bar is aligned to the right edge of the grid in the output. The azure floor remains in its original position. The rest of the grid is white.\n\"\"\"\n\ndef find_bars(input_grid: np.ndarray, floor_row_index: int) -> list[tuple[int, int, int]]:\n    \"\"\"\n    Finds all horizontal bars (contiguous segments of the same color, not white or azure) \n    above the floor line.\n\n    Args:\n        input_grid: The input grid as a numpy array.\n        floor_row_index: The row index of the azure floor.\n\n    Returns:\n        A list of tuples, where each tuple represents a bar: (color, length, row_index).\n    \"\"\"\n    bars = []\n    height, width = input_grid.shape\n    \n    # Scan rows above the floor\n    for r in range(floor_row_index):\n        c = 0\n        while c < width:\n            color = input_grid[r, c]\n            # Check if it's a bar color (not white 0 or azure 8)\n            if color != 0 and color != 8:\n                # Found the start of a potential bar\n                start_c = c\n                bar_color = color\n                # Find the end of the bar\n                while c < width and input_grid[r, c] == bar_color:\n                    c += 1\n                length = c - start_c\n                bars.append((bar_color, length, r))\n                # Continue scanning from the end of the found bar\n            else:\n                # Not a bar color, move to the next column\n                c += 1\n    return bars\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Rearranges horizontal bars from the input grid by stacking them vertically \n    from bottom to top (based on original position), right-aligned, \n    above a fixed azure floor line.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    \n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output grid with white (0)\n    output_array = np.zeros_like(input_array)\n\n    # Find the azure floor line (assuming it's solid and at the bottom)\n    floor_row_index = -1\n    for r in range(height - 1, -1, -1):\n        if np.all(input_array[r, :] == 8):\n            floor_row_index = r\n            break\n        # Handle cases where floor might not be solid, find first row containing 8\n        elif 8 in input_array[r, :]: \n             # Check if it's the actual floor by seeing if it spans the width or is the lowest row with 8\n             is_floor = True\n             for c_check in range(width):\n                 # Allow for white padding around the floor as seen in examples\n                 if input_array[r, c_check] != 8 and input_array[r, c_check] != 0:\n                     is_floor = False\n                     break\n             if is_floor and 8 in input_array[r,:]: # Ensure there's at least one 8\n                floor_row_index = r\n                break\n\n\n    if floor_row_index == -1:\n        # Fallback or error handling if no azure floor is found\n        # For this specific problem, assume the floor always exists.\n        # If it might not, we'd return the input or an empty grid, depending on requirements.\n        # Let's assume it's the last row if no solid '8' row is found but 8 exists somewhere\n        # For robustnes lets find the lowest row containing an 8\n        for r in range(height - 1, -1, -1):\n            if 8 in input_array[r,:]:\n                floor_row_index = r\n                break\n        # If still -1, it means no 8 exists at all, which contradicts the problem description\n        # For now, we proceed assuming floor_row_index is valid based on examples.\n\n\n    # Copy the floor line to the output grid\n    if floor_row_index != -1:\n         output_array[floor_row_index, :] = input_array[floor_row_index, :]\n    else:\n         # If no floor was found even with fallbacks, maybe return input?\n         # Based on problem, floor is guaranteed.\n         pass \n\n    # Identify all bars above the floor\n    bars = find_bars(input_array, floor_row_index if floor_row_index != -1 else height)\n\n    # Sort bars by original row index (descending order - lowest bar first)\n    # Bars with higher row index were lower on the screen\n    sorted_bars = sorted(bars, key=lambda x: x[2], reverse=True)\n\n    # Place the sorted bars onto the output grid, right-aligned, stacking upwards\n    if floor_row_index != -1:\n        current_placement_row = floor_row_index - 1\n    else:\n        # If no floor, stack from bottom\n        current_placement_row = height - 1\n        \n    for bar_color, bar_length, _ in sorted_bars:\n        if current_placement_row < 0:\n            # Stop if we run out of space at the top\n            break \n            \n        # Calculate start column for right alignment\n        start_col = width - bar_length\n        end_col = width\n        \n        # Place the bar\n        output_array[current_placement_row, start_col:end_col] = bar_color\n        \n        # Move placement row up for the next bar\n        current_placement_row -= 1\n\n    # Convert back to list of lists for the final output\n    output_grid = output_array.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2572,
    "candidates_token_count": 2355,
    "total_token_count": 4927,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.438356,
  "retries": 1
}