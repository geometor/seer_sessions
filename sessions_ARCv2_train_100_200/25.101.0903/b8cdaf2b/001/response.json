{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on identifying a single composite object at the bottom.\n\n1.  Identifies a single connected block of non-background pixels touching the bottom edge (the \"object\").\n2.  Determines the object's properties:\n    - Lowest row index (`r_base`).\n    - Horizontal extent on the lowest row (`c_min`, `c_max`).\n    - Base width (`W = c_max - c_min + 1`).\n    - Total height (`H`).\n    - Color of the bottom corners (`CornerC`).\n    - \"Content color\" (`C`), identified as the color of the pixel at the horizontal center of the base row.\n3.  Selects one of two symmetrical pixel placement patterns (A or B) based on `CornerC` and `W`:\n    - If `CornerC` is Magenta (6), use Pattern A.\n    - If `CornerC` is Azure (8), use Pattern B.\n    - If `CornerC` is Red (2):\n        - If `W <= 3`, use Pattern A.\n        - If `W > 3`, use Pattern B.\n4.  Adds new pixels of color `C` to the grid above the original object according to the selected pattern, preserving the original object.\n    - Pattern A: Adds pixels at `(r_base - H, c_min)` and `(r_base - H, c_max)`.\n    - Pattern B: Adds pixels at `(r_base - H - 1, c_min)`, `(r_base - H - 1, c_max)`, `(r_base - H, c_min + 1)`, and `(r_base - H, c_max - 1)`.\n\"\"\"\n\ndef find_object_coords(grid: np.ndarray) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of the single connected non-background object\n    touching the bottom edge using Breadth-First Search (BFS).\n    Assumes 4-connectivity and a single such object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    object_coords = []\n    q = deque()\n\n    # Find starting points on the bottom row (non-background)\n    start_points_found = False\n    for c in range(cols):\n        # Check the bottom row pixel\n        if grid[rows - 1, c] != 0:\n            # If this pixel hasn't been visited (part of the current object search)\n            if not visited[rows - 1, c]:\n                # Start a new BFS from this point\n                q_current = deque([(rows - 1, c)])\n                visited[rows - 1, c] = True\n                current_object_coords = []\n                start_points_found = True # Mark that we found at least one starting point\n\n                while q_current:\n                    r, c_curr = q_current.popleft()\n                    current_object_coords.append((r, c_curr))\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c_curr + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != 0:\n                            visited[nr, nc] = True\n                            q_current.append((nr, nc))\n                \n                # Assuming only one object touches the bottom, we take the first one found\n                object_coords = current_object_coords\n                break # Stop searching for other starting points on the bottom row\n\n    if not start_points_found:\n        return [] # No object touching the bottom found\n\n    # Sort coordinates for consistency\n    object_coords.sort()\n    return object_coords\n\ndef get_object_properties(grid: np.ndarray, object_coords: list[tuple[int, int]]) -> tuple[int, int, int, int, int, int, int]:\n    \"\"\"\n    Calculates properties of the object from its coordinates.\n    Returns: r_base, c_min, c_max, H, W, corner_c, content_color\n    Raises ValueError if object_coords is empty.\n    \"\"\"\n    if not object_coords:\n        raise ValueError(\"No object coordinates provided.\")\n\n    # Extract row and column indices\n    rows_arr = np.array([r for r, c in object_coords])\n    cols_arr = np.array([c for r, c in object_coords])\n\n    # Determine vertical extent and height\n    r_min = np.min(rows_arr) # Topmost row index\n    r_base = np.max(rows_arr) # Bottommost row index (base row)\n    H = r_base - r_min + 1 # Height of the object\n\n    # Filter coordinates to get only those on the base row\n    base_coords = [(r, c) for r, c in object_coords if r == r_base]\n    base_cols = np.array([c for r, c in base_coords])\n\n    # Determine horizontal extent on the base row and base width\n    c_min = np.min(base_cols) # Leftmost column index on base row\n    c_max = np.max(base_cols) # Rightmost column index on base row\n    W = c_max - c_min + 1 # Width of the object on the base row\n\n    # Get corner color (using the bottom-left corner pixel)\n    corner_c = grid[r_base, c_min]\n\n    # Get content color (defined as the color at the horizontal center of the base row)\n    # Use integer division for the center index\n    center_c_idx = (c_min + c_max) // 2\n    content_color = grid[r_base, center_c_idx]\n\n    return r_base, c_min, c_max, H, W, corner_c, content_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid by adding pixels above\n    an object found at the bottom edge, based on the object's properties.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input object\n    output_grid_np = np.copy(grid_np)\n    rows, cols = grid_np.shape\n\n    # --- Step 1 & 2: Find the object and its properties ---\n    object_coords = find_object_coords(grid_np)\n    if not object_coords:\n        # If no object is found touching the bottom, return the original grid\n        return input_grid\n\n    try:\n        # Calculate relevant properties of the identified object\n        r_base, c_min, c_max, H, W, corner_c, content_color = get_object_properties(grid_np, object_coords)\n    except ValueError:\n        # Handle cases where properties couldn't be determined (e.g., empty coords)\n        return input_grid # Return original grid if properties are invalid\n\n    # --- Step 3: Determine the placement pattern ---\n    # Define color constants relevant to the pattern selection rules\n    MAGENTA = 6\n    AZURE = 8\n    RED = 2\n\n    use_pattern_A = False\n    pattern_selected = False\n    if corner_c == MAGENTA:\n        use_pattern_A = True\n        pattern_selected = True\n    elif corner_c == AZURE:\n        use_pattern_A = False # Use Pattern B\n        pattern_selected = True\n    elif corner_c == RED:\n        if W <= 3:\n            use_pattern_A = True\n        else: # W > 3\n            use_pattern_A = False # Use Pattern B\n        pattern_selected = True\n\n    # If the corner color doesn't match any rule, do nothing\n    if not pattern_selected:\n        return input_grid\n\n    # --- Step 4: Apply the selected pattern ---\n    if use_pattern_A:\n        # Pattern A: Adds two pixels\n        target_r = r_base - H # Row above the object's top\n        target_c_left = c_min\n        target_c_right = c_max\n\n        # Add left pixel, checking grid boundaries\n        if 0 <= target_r < rows and 0 <= target_c_left < cols:\n            output_grid_np[target_r, target_c_left] = content_color\n        # Add right pixel, checking grid boundaries\n        if 0 <= target_r < rows and 0 <= target_c_right < cols:\n            output_grid_np[target_r, target_c_right] = content_color\n    else: # Use Pattern B\n        # Pattern B: Adds four pixels in two pairs\n        # Pair 1 (row r_base - H - 1)\n        target_r1 = r_base - H - 1\n        target_c1_left = c_min\n        target_c1_right = c_max\n\n        # Pair 2 (row r_base - H)\n        target_r2 = r_base - H\n        target_c2_left = c_min + 1\n        target_c2_right = c_max - 1\n\n        # Add first pair, checking grid boundaries\n        if 0 <= target_r1 < rows:\n            if 0 <= target_c1_left < cols:\n                output_grid_np[target_r1, target_c1_left] = content_color\n            if 0 <= target_c1_right < cols:\n                output_grid_np[target_r1, target_c1_right] = content_color\n\n        # Add second pair, checking grid boundaries\n        # Note: Pattern B is used when W>3 (for RED) or W=5 (for AZURE example),\n        # ensuring target_c2_left < target_c2_right.\n        if 0 <= target_r2 < rows:\n            if 0 <= target_c2_left < cols:\n                output_grid_np[target_r2, target_c2_left] = content_color\n            if 0 <= target_c2_right < cols:\n                 output_grid_np[target_r2, target_c2_right] = content_color\n\n    # --- Step 5: Return the result ---\n    # Convert the modified NumPy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3240,
    "candidates_token_count": 10366,
    "total_token_count": 13606,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 72.769059,
  "retries": 1
}