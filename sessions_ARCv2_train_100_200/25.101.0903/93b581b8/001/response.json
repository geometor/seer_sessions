{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List\n\n\"\"\"\nIdentifies a central 2x2 block of non-background colors in the input grid.\nCopies this central block to the same location in the output grid.\nGenerates four new rectangular blocks in the corners of the output grid.\nThe color of each corner block is determined by one of the colors in the central 2x2 block,\nmapped diagonally. The size and position of each corner block are determined by the\nposition of the central block.\n\nSpecifically, if the central block is [[A, B], [C, D]] starting at (r0, c0):\n- Top-Left corner block uses color D and fills region (0, 0) to (r0-1, c0-1).\n- Top-Right corner block uses color C and fills region (0, c0+2) to (r0-1, c0+3).\n- Bottom-Left corner block uses color B and fills region (r0+2, 0) to (r0+3, c0-1).\n- Bottom-Right corner block uses color A and fills region (r0+2, c0+2) to (r0+3, c0+3).\nThe rest of the output grid remains the background color (0).\n\"\"\"\n\ndef find_central_block(grid: np.ndarray) -> tuple[int, int, int, int, int, int] | None:\n    \"\"\"\n    Finds the unique 2x2 block of non-zero pixels.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (r0, c0, A, B, C, D) where (r0, c0) is the top-left\n        coordinate and A, B, C, D are the colors in the block [[A, B], [C, D]],\n        or None if no such block is found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Check if all four cells are non-zero\n            if (grid[r, c] != 0 and\n                grid[r, c+1] != 0 and\n                grid[r+1, c] != 0 and\n                grid[r+1, c+1] != 0):\n                # Assuming this is the unique block based on examples\n                A = grid[r, c]\n                B = grid[r, c+1]\n                C = grid[r+1, c]\n                D = grid[r+1, c+1]\n                return r, c, A, B, C, D\n    return None\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the identified central block and corner generation rules.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # Find the central 2x2 block and its properties\n    block_info = find_central_block(input_np)\n\n    if block_info:\n        r0, c0, A, B, C, D = block_info\n\n        # 1. Create the top-left corner block (Color D)\n        # Region: rows 0 to r0-1, columns 0 to c0-1\n        if r0 > 0 and c0 > 0:\n            output_np[0:r0, 0:c0] = D\n\n        # 2. Create the top-right corner block (Color C)\n        # Region: rows 0 to r0-1, columns c0+2 to c0+3\n        # Check bounds: column index c0+3 must be less than width\n        if r0 > 0 and c0 + 3 < width:\n             # Slice is [0:r0, c0+2 : c0+4] because end index is exclusive\n            output_np[0:r0, c0+2 : c0+4] = C\n        elif r0 > 0 and c0 + 2 < width: # Handle case where only c0+2 is valid\n             output_np[0:r0, c0+2 : c0+3] = C\n\n\n        # 3. Create the bottom-left corner block (Color B)\n        # Region: rows r0+2 to r0+3, columns 0 to c0-1\n        # Check bounds: row index r0+3 must be less than height\n        if r0 + 3 < height and c0 > 0:\n            # Slice is [r0+2 : r0+4, 0:c0]\n            output_np[r0+2 : r0+4, 0:c0] = B\n        elif r0 + 2 < height and c0 > 0: # Handle case where only r0+2 is valid\n            output_np[r0+2 : r0+3, 0:c0] = B\n\n\n        # 4. Create the bottom-right corner block (Color A)\n        # Region: rows r0+2 to r0+3, columns c0+2 to c0+3\n        # Check bounds: row r0+3 < height, col c0+3 < width\n        if r0 + 3 < height and c0 + 3 < width:\n            # Slice is [r0+2 : r0+4, c0+2 : c0+4]\n            output_np[r0+2 : r0+4, c0+2 : c0+4] = A\n        elif r0 + 2 < height and c0 + 2 < width: # Check minimum bounds\n            # Need to potentially handle single row/column cases if bounds are tight\n             if r0+3 < height and c0+2 < width: # 2 rows, 1 col\n                 output_np[r0+2 : r0+4, c0+2 : c0+3] = A\n             elif r0+2 < height and c0+3 < width: # 1 row, 2 cols\n                 output_np[r0+2 : r0+3, c0+2 : c0+4] = A\n             else: # 1 row, 1 col\n                 output_np[r0+2 : r0+3, c0+2 : c0+3] = A\n\n\n        # 5. Copy the original 2x2 block onto the output grid\n        # This ensures it overwrites any corner pixels if necessary\n        # Region: rows r0 to r0+1, columns c0 to c0+1\n        # Slice is [r0:r0+2, c0:c0+2]\n        original_block = input_np[r0:r0+2, c0:c0+2]\n        output_np[r0:r0+2, c0:c0+2] = original_block\n\n    # Convert back to list of lists for the expected output format\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3141,
    "candidates_token_count": 5340,
    "total_token_count": 8481,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 35.476552,
  "retries": 1
}