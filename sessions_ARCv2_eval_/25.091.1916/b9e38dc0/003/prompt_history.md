
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

*   **Perception:**
    The task involves identifying different regions within the input grid based on pixel colors and connectivity, and then performing a fill operation on specific regions. Key elements are the background color, boundary-forming objects, potential fill colors derived from other objects, and determining whether the fill occurs in regions connected to the grid edge ("outside") or regions enclosed by boundaries ("inside").

    1.  **Background Identification:** The most frequent color in the grid typically serves as the background.
    2.  **Boundary Identification:** Contiguous shapes of non-background colors act as boundaries that constrain the fill operation. Often, one main boundary shape can be identified (e.g., the largest non-background object).
    3.  **Fill Color Determination:** The color used for filling is derived from specific, often unique or small, non-background, non-boundary objects present in the input grid.
    4.  **Fill Region Determination:** The core logic distinguishes between two types of fill regions:
        *   **Outside Fill:** Targets background pixels that are connected to the grid's edge. This occurs when the main boundary shape does *not* completely enclose any background region. The fill color is typically taken from the smallest non-background, non-boundary object.
        *   **Inside Fill:** Targets background pixels that are completely enclosed by the main boundary shape (cannot reach the grid edge via background pixels). This occurs when such enclosed regions exist. The fill color is determined by the color(s) found within the enclosed region in the input grid (often the most frequent non-background color within that region).
    5.  **Transformation:** The final output grid is created by replacing the pixels in the determined fill region (either inside or outside) with the determined fill color, while leaving all other pixels (boundary objects, other objects) unchanged.

*   **YAML Facts:**
    
```yaml
    task_type: grid_transformation
    transformation_name: conditional_region_fill
    elements:
      - role: background
        property: most_frequent_color
        value: color_code
      - role: boundary
        property: forms_shapes
        value: color_code(s)
        relationship: constrains_fill
        identification: largest_contiguous_non_background_object
      - role: fill_source
        property: provides_fill_color
        value: color_code
        identification:
          if_outside_fill: color_of_smallest_non_background_non_boundary_object
          if_inside_fill: most_frequent_non_background_color_within_enclosed_region
      - role: fill_target
        property: pixels_to_be_replaced
        value: background_color_pixels
        location:
          conditional:
            if_enclosed_region_exists: background_pixels_within_enclosed_region
            else: background_pixels_connected_to_grid_edge
    actions:
      - name: identify_background_color
      - name: identify_objects
      - name: identify_main_boundary_object
      - name: identify_other_objects
      - name: check_for_enclosed_background_regions
        using: flood_fill_from_edge
      - name: determine_fill_type
        based_on: existence_of_enclosed_regions
      - name: determine_fill_color
        based_on: fill_type_and_fill_source_identification_rules
      - name: determine_fill_region
        based_on: fill_type_and_background_connectivity
      - name: apply_fill
        inputs:
          - original_grid
          - fill_region_coordinates
          - fill_color
        output: modified_grid
    relationships:
      - type: containment
        description: Boundary objects can enclose background regions.
      - type: connectivity
        description: Background pixels can be connected to the grid edge or isolated within enclosures.
      - type: derivation
        description: Fill color is derived from specific objects in the input.
      - type: constraint
        description: Boundary objects prevent the fill operation from crossing them.
    ```


*   **Natural Language Program:**
    1.  Identify the background color, which is the most frequent color in the input grid.
    2.  Identify all contiguous objects (shapes) formed by non-background colors.
    3.  Determine the main boundary object, typically the largest non-background object by pixel count. Note its color(s).
    4.  Identify all other non-background, non-boundary objects and their colors.
    5.  Check if the main boundary object fully encloses any regions of the background color. This can be done by performing a flood fill starting from all background pixels on the grid edges; any background pixels not reached by this fill are considered enclosed.
    6.  **If** enclosed background regions exist:
        a.  The fill operation targets these enclosed background pixels.
        b.  Examine the pixels within these enclosed regions in the original input grid. Identify the most frequent color present there, excluding the background color itself. This is the fill color.
    7.  **Else (if no enclosed background regions exist):**
        a.  The fill operation targets the background pixels that *are* reachable from the grid edge (identified in step 5).
        b.  Find the smallest object (by pixel count) among the 'other objects' identified in step 4. Its color is the fill color.
    8.  Create the output grid by copying the input grid, then changing the color of the pixels in the target fill region (determined in step 6a or 7a) to the determined fill color (determined in step 6b or 7b).
```python
import numpy as np
from collections import Counter, deque
from skimage.measure import label

"""
Identify the background color (most frequent color).
Identify all contiguous objects (shapes) of non-background colors.
Determine the largest non-background object as the main boundary.
Identify all other non-background objects.

Check if the main boundary encloses any background regions by performing a flood fill from the grid edges on background pixels. Background pixels not reached are considered enclosed.

If enclosed background regions exist:
  Determine the fill color by finding the most frequent non-background color within the original pixels of the enclosed region(s).
  The fill target is the set of enclosed background pixels.
Else (no enclosed regions):
  Determine the fill color from the smallest non-background, non-boundary object (by pixel count).
  The fill target is the set of background pixels reachable from the grid edge.

Create the output grid by copying the input grid and replacing the pixels in the fill target region with the determined fill color.
"""

def find_objects(grid, colors_to_ignore):
    """
    Finds connected components (objects) in the grid, ignoring specified colors.

    Args:
        grid (np.array): The input grid.
        colors_to_ignore (set): A set of color values to ignore (typically background).

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color', 'coords' (list of tuples), and 'size'.
              Returns empty list if no objects found.
    """
    objects = []
    unique_colors = np.unique(grid)
    rows, cols = grid.shape

    for color in unique_colors:
        if color in colors_to_ignore:
            continue

        # Create a mask for the current color
        mask = (grid == color)
        # Label connected components for this color
        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True) # 4-connectivity

        for i in range(1, num_labels + 1):
            coords = np.argwhere(labeled_mask == i)
            # Convert coords to list of tuples (row, col)
            coords_list = [tuple(coord) for coord in coords]
            obj = {
                'color': color,
                'coords': coords_list,
                'size': len(coords_list)
            }
            objects.append(obj)

    # Sort objects primarily by size (descending), then arbitrarily if sizes are equal
    objects.sort(key=lambda o: o['size'], reverse=True)
    return objects

def get_background_color(grid):
    """Determines the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    # Find the color with the maximum count
    background_color = counts.most_common(1)[0][0]
    return background_color

def flood_fill_from_edge(grid, background_color):
    """
    Performs a flood fill starting from background pixels at the grid edges.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color of the background pixels to fill.

    Returns:
        set: A set of (row, col) tuples representing background pixels
             connected to the edge.
    """
    rows, cols = grid.shape
    visited = set()
    queue = deque()

    # Add all edge background pixels to the queue
    for r in range(rows):
        if grid[r, 0] == background_color:
            queue.append((r, 0))
            visited.add((r, 0))
        if grid[r, cols - 1] == background_color:
            queue.append((r, cols - 1))
            visited.add((r, cols - 1))
    for c in range(cols):
        if grid[0, c] == background_color:
            queue.append((0, c))
            visited.add((0, c))
        if grid[rows - 1, c] == background_color:
            queue.append((rows - 1, c))
            visited.add((rows - 1, c))

    # BFS
    while queue:
        r, c = queue.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == background_color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))

    return visited


def transform(input_grid_list):
    """
    Applies the conditional region fill transformation to the input grid.

    Args:
        input_grid_list (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the output grid.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify background color
    background_color = get_background_color(input_grid)

    # 2. Identify all non-background objects
    all_objects = find_objects(input_grid, {background_color})

    if not all_objects: # If only background exists, return original grid
        return input_grid_list

    # 3. Determine the main boundary object (largest)
    main_boundary_object = all_objects[0]
    boundary_coords = set(main_boundary_object['coords'])

    # 4. Identify other non-background, non-boundary objects
    other_objects = [obj for obj in all_objects[1:]] # Exclude the largest object

    # 5. Check for enclosed background regions
    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))
    outside_background_coords = flood_fill_from_edge(input_grid, background_color)
    enclosed_background_coords = all_background_coords - outside_background_coords

    fill_target_coords = set()
    fill_color = -1 # Placeholder for invalid color

    # 6. & 7. Determine fill type, target, and color
    if enclosed_background_coords:
        # Inside Fill
        fill_target_coords = enclosed_background_coords

        # Find most frequent non-background color within the original enclosed region
        enclosed_pixels_colors = []
        for r, c in enclosed_background_coords:
             # Check neighbors for non-background colors IN THE ORIGINAL INPUT
             # This interpretation seems wrong based on example 3.
             # We need the colors of the objects *within* the enclosed area.
             pass # Re-think this part

        # Alternative interpretation for inside fill color (Example 3):
        # Look at *all* pixels (including non-background) within the bounding box
        # of the enclosed region, or just the original colors *at* the enclosed
        # background coordinates? The description implies looking at the content
        # *within* the enclosure. Let's find all objects fully contained within
        # the bounding box defined by the enclosed area. Simpler: Find the colors
        # of pixels *adjacent* to the enclosed background pixels, or get all pixels
        # inside the bounding box and find the most frequent non-background color.
        # Let's try: Get all non-background pixels from input_grid whose coordinates
        # fall within the space notionally defined by the enclosed region.

        # A simpler proxy for "within the enclosed region" might be pixels *adjacent*
        # to the enclosed background pixels, or pixels whose objects are fully contained.
        # Let's analyze Example 3 again. Enclosed area is near the green shapes.
        # The fill color is green (3). Green objects are within/adjacent.

        # Let's try finding the most frequent color of objects adjacent to the enclosed area.
        adjacent_non_bg_colors = []
        for r, c in enclosed_background_coords:
             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]: # 8-connectivity adjacency
                 nr, nc = r + dr, c + dc
                 if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] != background_color:
                     # Check if this adjacent pixel belongs to the main boundary
                     is_boundary_pixel = False
                     for br, bc in boundary_coords:
                         if nr == br and nc == bc:
                            is_boundary_pixel = True
                            break
                     # We only consider colors of objects *other* than the main boundary, if possible
                     # Or simply the most frequent non-bg color adjacent?
                     # Let's just collect all adjacent non-bg colors first.
                     adjacent_non_bg_colors.append(input_grid[nr, nc])

        if adjacent_non_bg_colors:
            color_counts = Counter(adjacent_non_bg_colors)
            # Remove boundary color counts if we want color *from inside*
            boundary_obj_colors = set(o['color'] for o in [main_boundary_object]) # Assuming single color boundary
            for b_color in boundary_obj_colors:
                if b_color in color_counts:
                   del color_counts[b_color] # Remove boundary color influence? Maybe not needed.

            # Try again: just find the most frequent non-background color in the enclosed area itself
            original_colors_in_enclosed = []
            # This needs a way to define the *region*, not just the background pixels within it.
            # Let's stick to the original description: "Examine the pixels within these enclosed
            # regions in the original input grid. Identify the most frequent color present there,
            # excluding the background color itself."
            # How to define "within"? Let's use a bounding box of the enclosed coords + neighbors.
            if enclosed_background_coords:
                 min_r = min(r for r, c in enclosed_background_coords)
                 max_r = max(r for r, c in enclosed_background_coords)
                 min_c = min(c for r, c in enclosed_background_coords)
                 max_c = max(c for r, c in enclosed_background_coords)

                 # Collect non-background colors within this bounding box from the input
                 colors_in_bbox = []
                 for r in range(min_r, max_r + 1):
                     for c in range(min_c, max_c + 1):
                         pixel_color = input_grid[r, c]
                         if pixel_color != background_color:
                             colors_in_bbox.append(pixel_color)

                 if colors_in_bbox:
                     fill_color = Counter(colors_in_bbox).most_common(1)[0][0]
                 else:
                     # Fallback if no non-background colors found inside bbox (unlikely for examples)
                     # Perhaps use the boundary color or a default? Let's assume one is found.
                     # If still no color, maybe default to boundary color?
                     fill_color = main_boundary_object['color'] # Guessing fallback


            # If still no fill color identified (e.g., only background in bbox), need a fallback.
            if fill_color == -1:
                 # Maybe use the color of the boundary?
                 fill_color = main_boundary_object['color'] # Fallback guess

        else:
             # Extremely unlikely case: enclosed region with no adjacent non-background pixels?
             # Fallback to boundary color
             fill_color = main_boundary_object['color']


    else:
        # Outside Fill
        fill_target_coords = outside_background_coords

        # Find the smallest object among 'other_objects'
        if other_objects:
            # Sort other_objects by size (ascending)
            other_objects.sort(key=lambda o: o['size'])
            fill_color = other_objects[0]['color']
        else:
             # If there are no 'other' objects, what determines the fill color?
             # Example 1: Boundary=3, Others=9(sz 1), 5(sz 2). Smallest=9. Fills 9.
             # Example 2: Boundary=5, Others=4(sz 1). Smallest=4. Fills 4.
             # If other_objects is empty, it means the boundary was the *only* non-background object.
             # This edge case isn't covered by examples. Maybe fill with boundary color? Or leave as background?
             # Let's assume it fills with the boundary color if no other objects exist.
             fill_color = main_boundary_object['color']


    # 8. Apply fill
    if fill_color != -1: # Ensure a valid fill color was determined
        for r, c in fill_target_coords:
            output_grid[r, c] = fill_color

    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter, deque
from skimage.measure import label

"""
Identify the background color (most frequent color).
Identify all contiguous objects (shapes) of non-background colors.
Determine the largest non-background object as the main boundary.
Identify all other non-background objects.

Check if the main boundary encloses any background regions by performing a flood fill from the grid edges on background pixels. Background pixels not reached are considered enclosed.

If enclosed background regions exist:
  Determine the fill color by finding the most frequent non-background color within the original pixels of the enclosed region(s).
  The fill target is the set of enclosed background pixels.
Else (no enclosed regions):
  Determine the fill color from the smallest non-background, non-boundary object (by pixel count).
  The fill target is the set of background pixels reachable from the grid edge.

Create the output grid by copying the input grid and replacing the pixels in the fill target region with the determined fill color.
"""

def find_objects(grid, colors_to_ignore):
    """
    Finds connected components (objects) in the grid, ignoring specified colors.

    Args:
        grid (np.array): The input grid.
        colors_to_ignore (set): A set of color values to ignore (typically background).

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color', 'coords' (list of tuples), and 'size'.
              Returns empty list if no objects found.
    """
    objects = []
    unique_colors = np.unique(grid)
    rows, cols = grid.shape

    for color in unique_colors:
        if color in colors_to_ignore:
            continue

        # Create a mask for the current color
        mask = (grid == color)
        # Label connected components for this color
        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True) # 4-connectivity

        for i in range(1, num_labels + 1):
            coords = np.argwhere(labeled_mask == i)
            # Convert coords to list of tuples (row, col)
            coords_list = [tuple(coord) for coord in coords]
            obj = {
                'color': color,
                'coords': coords_list,
                'size': len(coords_list)
            }
            objects.append(obj)

    # Sort objects primarily by size (descending), then arbitrarily if sizes are equal
    objects.sort(key=lambda o: o['size'], reverse=True)
    return objects

def get_background_color(grid):
    """Determines the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    # Find the color with the maximum count
    background_color = counts.most_common(1)[0][0]
    return background_color

def flood_fill_from_edge(grid, background_color):
    """
    Performs a flood fill starting from background pixels at the grid edges.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color of the background pixels to fill.

    Returns:
        set: A set of (row, col) tuples representing background pixels
             connected to the edge.
    """
    rows, cols = grid.shape
    visited = set()
    queue = deque()

    # Add all edge background pixels to the queue
    for r in range(rows):
        if grid[r, 0] == background_color:
            queue.append((r, 0))
            visited.add((r, 0))
        if grid[r, cols - 1] == background_color:
            queue.append((r, cols - 1))
            visited.add((r, cols - 1))
    for c in range(cols):
        if grid[0, c] == background_color:
            queue.append((0, c))
            visited.add((0, c))
        if grid[rows - 1, c] == background_color:
            queue.append((rows - 1, c))
            visited.add((rows - 1, c))

    # BFS
    while queue:
        r, c = queue.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == background_color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))

    return visited


def transform(input_grid_list):
    """
    Applies the conditional region fill transformation to the input grid.

    Args:
        input_grid_list (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the output grid.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify background color
    background_color = get_background_color(input_grid)

    # 2. Identify all non-background objects
    all_objects = find_objects(input_grid, {background_color})

    if not all_objects: # If only background exists, return original grid
        return input_grid_list

    # 3. Determine the main boundary object (largest)
    main_boundary_object = all_objects[0]
    boundary_coords = set(main_boundary_object['coords'])

    # 4. Identify other non-background, non-boundary objects
    other_objects = [obj for obj in all_objects[1:]] # Exclude the largest object

    # 5. Check for enclosed background regions
    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))
    outside_background_coords = flood_fill_from_edge(input_grid, background_color)
    enclosed_background_coords = all_background_coords - outside_background_coords

    fill_target_coords = set()
    fill_color = -1 # Placeholder for invalid color

    # 6. & 7. Determine fill type, target, and color
    if enclosed_background_coords:
        # Inside Fill
        fill_target_coords = enclosed_background_coords

        # Find most frequent non-background color within the original enclosed region
        enclosed_pixels_colors = []
        for r, c in enclosed_background_coords:
             # Check neighbors for non-background colors IN THE ORIGINAL INPUT
             # This interpretation seems wrong based on example 3.
             # We need the colors of the objects *within* the enclosed area.
             pass # Re-think this part

        # Alternative interpretation for inside fill color (Example 3):
        # Look at *all* pixels (including non-background) within the bounding box
        # of the enclosed region, or just the original colors *at* the enclosed
        # background coordinates? The description implies looking at the content
        # *within* the enclosure. Let's find all objects fully contained within
        # the bounding box defined by the enclosed area. Simpler: Find the colors
        # of pixels *adjacent* to the enclosed background pixels, or get all pixels
        # inside the bounding box and find the most frequent non-background color.
        # Let's try: Get all non-background pixels from input_grid whose coordinates
        # fall within the space notionally defined by the enclosed region.

        # A simpler proxy for "within the enclosed region" might be pixels *adjacent*
        # to the enclosed background pixels, or pixels whose objects are fully contained.
        # Let's analyze Example 3 again. Enclosed area is near the green shapes.
        # The fill color is green (3). Green objects are within/adjacent.

        # Let's try finding the most frequent color of objects adjacent to the enclosed area.
        adjacent_non_bg_colors = []
        for r, c in enclosed_background_coords:
             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]: # 8-connectivity adjacency
                 nr, nc = r + dr, c + dc
                 if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] != background_color:
                     # Check if this adjacent pixel belongs to the main boundary
                     is_boundary_pixel = False
                     for br, bc in boundary_coords:
                         if nr == br and nc == bc:
                            is_boundary_pixel = True
                            break
                     # We only consider colors of objects *other* than the main boundary, if possible
                     # Or simply the most frequent non-bg color adjacent?
                     # Let's just collect all adjacent non-bg colors first.
                     adjacent_non_bg_colors.append(input_grid[nr, nc])

        if adjacent_non_bg_colors:
            color_counts = Counter(adjacent_non_bg_colors)
            # Remove boundary color counts if we want color *from inside*
            boundary_obj_colors = set(o['color'] for o in [main_boundary_object]) # Assuming single color boundary
            for b_color in boundary_obj_colors:
                if b_color in color_counts:
                   del color_counts[b_color] # Remove boundary color influence? Maybe not needed.

            # Try again: just find the most frequent non-background color in the enclosed area itself
            original_colors_in_enclosed = []
            # This needs a way to define the *region*, not just the background pixels within it.
            # Let's stick to the original description: "Examine the pixels within these enclosed
            # regions in the original input grid. Identify the most frequent color present there,
            # excluding the background color itself."
            # How to define "within"? Let's use a bounding box of the enclosed coords + neighbors.
            if enclosed_background_coords:
                 min_r = min(r for r, c in enclosed_background_coords)
                 max_r = max(r for r, c in enclosed_background_coords)
                 min_c = min(c for r, c in enclosed_background_coords)
                 max_c = max(c for r, c in enclosed_background_coords)

                 # Collect non-background colors within this bounding box from the input
                 colors_in_bbox = []
                 for r in range(min_r, max_r + 1):
                     for c in range(min_c, max_c + 1):
                         pixel_color = input_grid[r, c]
                         if pixel_color != background_color:
                             colors_in_bbox.append(pixel_color)

                 if colors_in_bbox:
                     fill_color = Counter(colors_in_bbox).most_common(1)[0][0]
                 else:
                     # Fallback if no non-background colors found inside bbox (unlikely for examples)
                     # Perhaps use the boundary color or a default? Let's assume one is found.
                     # If still no color, maybe default to boundary color?
                     fill_color = main_boundary_object['color'] # Guessing fallback


            # If still no fill color identified (e.g., only background in bbox), need a fallback.
            if fill_color == -1:
                 # Maybe use the color of the boundary?
                 fill_color = main_boundary_object['color'] # Fallback guess

        else:
             # Extremely unlikely case: enclosed region with no adjacent non-background pixels?
             # Fallback to boundary color
             fill_color = main_boundary_object['color']


    else:
        # Outside Fill
        fill_target_coords = outside_background_coords

        # Find the smallest object among 'other_objects'
        if other_objects:
            # Sort other_objects by size (ascending)
            other_objects.sort(key=lambda o: o['size'])
            fill_color = other_objects[0]['color']
        else:
             # If there are no 'other' objects, what determines the fill color?
             # Example 1: Boundary=3, Others=9(sz 1), 5(sz 2). Smallest=9. Fills 9.
             # Example 2: Boundary=5, Others=4(sz 1). Smallest=4. Fills 4.
             # If other_objects is empty, it means the boundary was the *only* non-background object.
             # This edge case isn't covered by examples. Maybe fill with boundary color? Or leave as background?
             # Let's assume it fills with the boundary color if no other objects exist.
             fill_color = main_boundary_object['color']


    # 8. Apply fill
    if fill_color != -1: # Ensure a valid fill color was determined
        for r, c in fill_target_coords:
            output_grid[r, c] = fill_color

    return output_grid.tolist()
```
Results for code_00.py:
Train Set Error: error:
No module named 'skimage'
*   **Assessment:**
    The primary issue was a missing dependency (`skimage`) required for the `label` function used in `find_objects`. Assuming this dependency can be resolved in the execution environment, the core logic proposed seems promising. The strategy involves identifying a background, a main boundary object (largest non-background), and other smaller objects. A key distinction is made based on whether the main boundary encloses a region of the background.
    *   If an enclosure exists (like in train_3), the enclosed background area is filled with a color derived from the objects *within* or immediately adjacent to that enclosure (excluding the boundary itself).
    *   If no enclosure exists (like in train_1 and train_2), the background area connected to the grid edge ("outside") is filled with the color of the smallest non-boundary object.

    To verify and refine this, we need to execute code that correctly identifies objects and enclosure status for all examples.

*   **Metrics:**
    Let's gather metrics for each training example using code execution, assuming `skimage` is available. We need to calculate background color, identify objects (largest/boundary and others), determine if enclosed regions exist, and note the fill color used.



*code_execution:*
```python
import numpy as np
from collections import Counter, deque

# Assume skimage.measure.label is available for connected components
try:
    from skimage.measure import label
    SKIMAGE_AVAILABLE = True
except ImportError:
    SKIMAGE_AVAILABLE = False
    print("Warning: skimage not found. Object detection will be limited.")
    # Define a placeholder or basic implementation if needed, otherwise skip object finding

    def label(mask, connectivity, background, return_num):
         # Placeholder implementation or skip if skimage is required
         print("Error: skimage.measure.label is required for find_objects.")
         return np.zeros_like(mask), 0 # Return empty labels


def get_background_color(grid):
    """Determines the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    return counts.most_common(1)[0][0]

def find_objects(grid, colors_to_ignore):
    """Finds connected components (objects) using skimage.label."""
    if not SKIMAGE_AVAILABLE:
        return [] # Cannot find objects without skimage

    objects = []
    unique_colors = np.unique(grid)
    rows, cols = grid.shape

    for color in unique_colors:
        if color in colors_to_ignore:
            continue
        mask = (grid == color)
        # Using 4-connectivity (connectivity=1)
        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True)

        for i in range(1, num_labels + 1):
            coords = np.argwhere(labeled_mask == i)
            coords_list = [tuple(coord) for coord in coords]
            obj = {
                'color': color,
                'coords': coords_list,
                'size': len(coords_list)
            }
            objects.append(obj)

    objects.sort(key=lambda o: o['size'], reverse=True)
    return objects

def flood_fill_from_edge(grid, background_color):
    """Finds background pixels connected to the edge."""
    rows, cols = grid.shape
    visited = set()
    queue = deque()

    for r in range(rows):
        if grid[r, 0] == background_color:
            if (r,0) not in visited: queue.append((r, 0)); visited.add((r, 0))
        if grid[r, cols - 1] == background_color:
             if (r,cols-1) not in visited: queue.append((r, cols - 1)); visited.add((r, cols - 1))
    for c in range(cols):
        if grid[0, c] == background_color:
             if (0,c) not in visited: queue.append((0, c)); visited.add((0, c))
        if grid[rows - 1, c] == background_color:
             if (rows-1,c) not in visited: queue.append((rows - 1, c)); visited.add((rows - 1, c))

    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-connectivity
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == background_color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    return visited

def analyze_example(input_grid_list, output_grid_list):
    """Analyzes a single training example."""
    input_grid = np.array(input_grid_list)
    output_grid = np.array(output_grid_list)
    rows, cols = input_grid.shape

    bg_color = get_background_color(input_grid)
    all_bg_coords = set(tuple(coord) for coord in np.argwhere(input_grid == bg_color))
    outside_bg_coords = flood_fill_from_edge(input_grid, bg_color)
    enclosed_bg_coords = all_bg_coords - outside_bg_coords

    objects = find_objects(input_grid, {bg_color})
    if not objects:
        return {
            "background_color": bg_color,
            "objects": [],
            "boundary_object": None,
            "other_objects": [],
            "has_enclosed_region": bool(enclosed_bg_coords),
            "enclosed_coords_count": len(enclosed_bg_coords),
            "fill_type": "N/A (no objects)",
            "fill_color_in_output": None,
        }

    boundary_object = objects[0]
    other_objects = objects[1:]

    fill_color_in_output = None
    changed_coords = np.argwhere(input_grid != output_grid)

    if len(changed_coords) > 0:
        # Assume all changed pixels get the same color, check first one
        fill_color_in_output = output_grid[tuple(changed_coords[0])]
        # Verify assumption (optional but good practice)
        # assert np.all(output_grid[tuple(zip(*changed_coords))] == fill_color_in_output)

    analysis = {
        "background_color": bg_color,
        "objects_count": len(objects),
        "boundary_object": {"color": boundary_object['color'], "size": boundary_object['size']},
        "other_objects_summary": [{"color": o['color'], "size": o['size']} for o in other_objects],
        "has_enclosed_region": bool(enclosed_bg_coords),
        "enclosed_coords_count": len(enclosed_bg_coords),
        "outside_coords_count": len(outside_bg_coords),
        "fill_color_in_output": fill_color_in_output,
        "smallest_other_object": min(other_objects, key=lambda x: x['size']) if other_objects else None,
    }

    if analysis["has_enclosed_region"]:
        analysis["fill_type"] = "Inside"
        # Try to determine the source color for inside fill based on objects adjacent to enclosed area
        adjacent_colors = set()
        for r, c in enclosed_bg_coords:
             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]: # 8-connectivity
                 nr, nc = r + dr, c + dc
                 if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] != bg_color:
                      # Exclude boundary object color? Let's include all non-bg for now
                      # if input_grid[nr, nc] != boundary_object['color']:
                      adjacent_colors.add(input_grid[nr, nc])
        analysis["adjacent_non_bg_colors_to_enclosed"] = list(adjacent_colors)
        # Also check colors of 'other_objects' that might be 'inside'
        inside_object_colors = []
        boundary_coords_set = set(boundary_object['coords'])
        for obj in other_objects:
            is_inside = False
            for r, c in obj['coords']:
                 # Check if *any* pixel of the object is adjacent to an enclosed background pixel
                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]:
                     nr, nc = r + dr, c + dc
                     if (nr, nc) in enclosed_bg_coords:
                         is_inside = True
                         break
                 if is_inside: break
            if is_inside:
                inside_object_colors.append(obj['color'])
        analysis["inside_object_colors"] = list(set(inside_object_colors)) # Unique colors

    else:
        analysis["fill_type"] = "Outside"
        analysis["adjacent_non_bg_colors_to_enclosed"] = []
        analysis["inside_object_colors"] = []


    return analysis

# --- Train Data ---
train_1_input = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 1, 3, 1, 1, 9, 1, 1, 1, 3, 1, 1], [1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1], [1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]
train_1_output = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 9, 9, 9, 9, 3, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 9, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 9, 9, 3, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 9, 9, 3, 1, 1, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 9, 9, 9, 3, 1, 1, 1], [1, 1, 1, 1, 9, 9, 9, 5, 5, 9, 9, 9, 1, 1, 1], [1, 1, 1, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 1, 1], [1, 1, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 1], [1, 9, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9]]
train_2_input = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 4, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 5, 5, 0]]
train_2_output = [[4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 5, 0, 0, 0, 5, 5, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 5, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 5, 5, 5, 5, 0]]
train_3_input = [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 7, 7, 7, 7, 7, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 7, 7, 6, 7, 7, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 7, 7, 7, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 7, 7, 7, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 7, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 7, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 7, 7, 7, 7, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 7, 7, 3, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 7, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7], [7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]
train_3_output = [[7, 7, 7, 3, 3, 7, 3, 7, 3, 3, 3, 3, 7, 7, 7, 7], [7, 7, 7, 7, 3, 6, 3, 7, 3, 3, 3, 7, 7, 7, 7, 7], [7, 7, 7, 7, 3, 3, 3, 7, 3, 3, 3, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 7, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 6, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 3, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 3, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 9, 9, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 3, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 3, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7], [7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]

results = {}
if SKIMAGE_AVAILABLE:
    print("Analyzing Example 1...")
    results['train_1'] = analyze_example(train_1_input, train_1_output)
    print("Analyzing Example 2...")
    results['train_2'] = analyze_example(train_2_input, train_2_output)
    print("Analyzing Example 3...")
    results['train_3'] = analyze_example(train_3_input, train_3_output)
else:
    print("Skipping analysis due to missing skimage.")

print(f"\nAnalysis Results:\n{results}")
```

*code_execution_result:*
outcome: OUTCOME_OK
```
Warning: skimage not found. Object detection will be limited.
Skipping analysis due to missing skimage.

Analysis Results:
{}

```
*   **Assessment:**
    The execution failed because the `skimage` library is not available in the environment. This prevents the `find_objects` function from working, which is crucial for identifying the boundary and other objects needed for the transformation logic.

    Without object detection, we cannot confirm the sizes or colors of objects, nor definitively identify the boundary or enclosed regions algorithmically. However, visual inspection strongly suggests the "conditional fill" logic is correct:
    1.  **Example 1 & 2:** No enclosed background region. The outside background is filled with the color of the smallest non-boundary object (Maroon-9 in Ex1, Yellow-4 in Ex2).
    2.  **Example 3:** An enclosed background region exists. This region is filled with the color of the objects located within/defining that void (Green-3).

    To proceed, we must assume `skimage.measure.label` or an equivalent connected-components function is available. The YAML and Natural Language Program will be based on this assumption and the visual analysis.

*   **YAML Facts:**


```yaml
task_type: grid_transformation
transformation_name: conditional_region_fill
elements:
  - role: grid
    property: background_color
    value: most_frequent_color_in_input
  - role: object
    property: color
    value: any_color_except_background
  - role: object
    property: contiguity
    value: group_of_connected_pixels_of_same_color
    connectivity: 4-way (horizontal/vertical adjacency)
  - role: boundary_object
    property: largest_object_by_pixel_count
    value: identified_from_all_non_background_objects
  - role: other_object
    property: any_non_background_object_that_is_not_the_boundary_object
  - role: region
    type: outside_background
    property: background_pixels_connected_to_grid_edge
    identification: flood_fill_from_edge_pixels_with_background_color
  - role: region
    type: enclosed_background
    property: background_pixels_not_connected_to_grid_edge
    identification: set_difference_of_all_background_pixels_and_outside_background_pixels
    existence_condition: is_not_empty
  - role: fill_source
    condition: if_enclosed_background_exists
    identification: find_other_objects_adjacent_to_enclosed_background_pixels
    value: color_of_adjacent_other_objects (if unique, else potentially most frequent or largest) # Example 3 suggests unique Green(3)
  - role: fill_source
    condition: if_no_enclosed_background_exists
    identification: find_smallest_other_object_by_pixel_count
    value: color_of_smallest_other_object
actions:
  - name: determine_background_color
  - name: find_all_non_background_objects
    tool: connected_components_labeling (e.g., skimage.measure.label)
  - name: identify_boundary_object
    based_on: largest_size
  - name: identify_other_objects
  - name: identify_outside_background_region
    tool: flood_fill_from_edge
  - name: identify_enclosed_background_region
    based_on: set_difference
  - name: check_existence_of_enclosed_region
  - name: determine_fill_color
    logic: conditional_based_on_enclosed_region_existence
      - if_enclosed: get_color_from_adjacent_other_objects
      - if_not_enclosed: get_color_from_smallest_other_object
  - name: determine_fill_region
    logic: conditional_based_on_enclosed_region_existence
      - if_enclosed: use_enclosed_background_region
      - if_not_enclosed: use_outside_background_region
  - name: apply_fill
    inputs:
      - original_grid
      - fill_region_coordinates
      - fill_color
    output: modified_grid
    preserve: all_pixels_not_in_fill_region
```


*   **Natural Language Program:**

    1.  Determine the background color by finding the most frequent color in the input grid.
    2.  Identify all contiguous objects (connected groups of same-colored pixels using 4-way adjacency) that are not the background color. If no such objects exist, the output is the same as the input.
    3.  Find the object with the largest number of pixels; this is the 'main boundary object'.
    4.  Identify all other non-background objects ('other objects').
    5.  Perform a flood fill starting from all background-colored pixels on the grid's edges. Mark all reachable background pixels as the 'outside background region'.
    6.  Identify the 'enclosed background region' by finding all background-colored pixels that were *not* reached by the flood fill in step 5.
    7.  **If** the 'enclosed background region' is not empty:
        a.  Identify the set of 'other objects' (from step 4) where at least one pixel of the object is adjacent (using 8-way adjacency: horizontal, vertical, or diagonal) to any pixel in the 'enclosed background region'.
        b.  Determine the fill color. Based on Example 3, this appears to be the single unique color found among the objects identified in step 7a. (If multiple colors were found, a tie-breaking rule like 'most frequent' or 'color of largest object' might be needed, but isn't demonstrated).
        c.  The target fill region is the 'enclosed background region'.
    8.  **Else (if the 'enclosed background region' is empty):**
        a.  Find the 'other object' (from step 4) with the smallest number of pixels. If there are no 'other objects', use the color of the 'main boundary object' as the fill color (Fallback rule, not explicitly shown but necessary). If there are 'other objects', use the color of the smallest one as the fill color.
        b.  The target fill region is the 'outside background region'.
    9.  Create the output grid by copying the input grid. Then, change the color of all pixels within the target fill region (determined in step 7c or 8b) to the determined fill color (determined in step 7b or 8a). Leave all other pixels unchanged.
