
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

*   **Perception:**
    The task involves identifying different regions within the input grid based on pixel colors and connectivity, and then performing a fill operation on specific regions. Key elements are the background color, boundary-forming objects, potential fill colors derived from other objects, and determining whether the fill occurs in regions connected to the grid edge ("outside") or regions enclosed by boundaries ("inside").

    1.  **Background Identification:** The most frequent color in the grid typically serves as the background.
    2.  **Boundary Identification:** Contiguous shapes of non-background colors act as boundaries that constrain the fill operation. Often, one main boundary shape can be identified (e.g., the largest non-background object).
    3.  **Fill Color Determination:** The color used for filling is derived from specific, often unique or small, non-background, non-boundary objects present in the input grid.
    4.  **Fill Region Determination:** The core logic distinguishes between two types of fill regions:
        *   **Outside Fill:** Targets background pixels that are connected to the grid's edge. This occurs when the main boundary shape does *not* completely enclose any background region. The fill color is typically taken from the smallest non-background, non-boundary object.
        *   **Inside Fill:** Targets background pixels that are completely enclosed by the main boundary shape (cannot reach the grid edge via background pixels). This occurs when such enclosed regions exist. The fill color is determined by the color(s) found within the enclosed region in the input grid (often the most frequent non-background color within that region).
    5.  **Transformation:** The final output grid is created by replacing the pixels in the determined fill region (either inside or outside) with the determined fill color, while leaving all other pixels (boundary objects, other objects) unchanged.

*   **YAML Facts:**
    
```yaml
    task_type: grid_transformation
    transformation_name: conditional_region_fill
    elements:
      - role: background
        property: most_frequent_color
        value: color_code
      - role: boundary
        property: forms_shapes
        value: color_code(s)
        relationship: constrains_fill
        identification: largest_contiguous_non_background_object
      - role: fill_source
        property: provides_fill_color
        value: color_code
        identification:
          if_outside_fill: color_of_smallest_non_background_non_boundary_object
          if_inside_fill: most_frequent_non_background_color_within_enclosed_region
      - role: fill_target
        property: pixels_to_be_replaced
        value: background_color_pixels
        location:
          conditional:
            if_enclosed_region_exists: background_pixels_within_enclosed_region
            else: background_pixels_connected_to_grid_edge
    actions:
      - name: identify_background_color
      - name: identify_objects
      - name: identify_main_boundary_object
      - name: identify_other_objects
      - name: check_for_enclosed_background_regions
        using: flood_fill_from_edge
      - name: determine_fill_type
        based_on: existence_of_enclosed_regions
      - name: determine_fill_color
        based_on: fill_type_and_fill_source_identification_rules
      - name: determine_fill_region
        based_on: fill_type_and_background_connectivity
      - name: apply_fill
        inputs:
          - original_grid
          - fill_region_coordinates
          - fill_color
        output: modified_grid
    relationships:
      - type: containment
        description: Boundary objects can enclose background regions.
      - type: connectivity
        description: Background pixels can be connected to the grid edge or isolated within enclosures.
      - type: derivation
        description: Fill color is derived from specific objects in the input.
      - type: constraint
        description: Boundary objects prevent the fill operation from crossing them.
    ```


*   **Natural Language Program:**
    1.  Identify the background color, which is the most frequent color in the input grid.
    2.  Identify all contiguous objects (shapes) formed by non-background colors.
    3.  Determine the main boundary object, typically the largest non-background object by pixel count. Note its color(s).
    4.  Identify all other non-background, non-boundary objects and their colors.
    5.  Check if the main boundary object fully encloses any regions of the background color. This can be done by performing a flood fill starting from all background pixels on the grid edges; any background pixels not reached by this fill are considered enclosed.
    6.  **If** enclosed background regions exist:
        a.  The fill operation targets these enclosed background pixels.
        b.  Examine the pixels within these enclosed regions in the original input grid. Identify the most frequent color present there, excluding the background color itself. This is the fill color.
    7.  **Else (if no enclosed background regions exist):**
        a.  The fill operation targets the background pixels that *are* reachable from the grid edge (identified in step 5).
        b.  Find the smallest object (by pixel count) among the 'other objects' identified in step 4. Its color is the fill color.
    8.  Create the output grid by copying the input grid, then changing the color of the pixels in the target fill region (determined in step 6a or 7a) to the determined fill color (determined in step 6b or 7b).
```python
import numpy as np
from collections import Counter, deque
from skimage.measure import label

"""
Identify the background color (most frequent color).
Identify all contiguous objects (shapes) of non-background colors.
Determine the largest non-background object as the main boundary.
Identify all other non-background objects.

Check if the main boundary encloses any background regions by performing a flood fill from the grid edges on background pixels. Background pixels not reached are considered enclosed.

If enclosed background regions exist:
  Determine the fill color by finding the most frequent non-background color within the original pixels of the enclosed region(s).
  The fill target is the set of enclosed background pixels.
Else (no enclosed regions):
  Determine the fill color from the smallest non-background, non-boundary object (by pixel count).
  The fill target is the set of background pixels reachable from the grid edge.

Create the output grid by copying the input grid and replacing the pixels in the fill target region with the determined fill color.
"""

def find_objects(grid, colors_to_ignore):
    """
    Finds connected components (objects) in the grid, ignoring specified colors.

    Args:
        grid (np.array): The input grid.
        colors_to_ignore (set): A set of color values to ignore (typically background).

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color', 'coords' (list of tuples), and 'size'.
              Returns empty list if no objects found.
    """
    objects = []
    unique_colors = np.unique(grid)
    rows, cols = grid.shape

    for color in unique_colors:
        if color in colors_to_ignore:
            continue

        # Create a mask for the current color
        mask = (grid == color)
        # Label connected components for this color
        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True) # 4-connectivity

        for i in range(1, num_labels + 1):
            coords = np.argwhere(labeled_mask == i)
            # Convert coords to list of tuples (row, col)
            coords_list = [tuple(coord) for coord in coords]
            obj = {
                'color': color,
                'coords': coords_list,
                'size': len(coords_list)
            }
            objects.append(obj)

    # Sort objects primarily by size (descending), then arbitrarily if sizes are equal
    objects.sort(key=lambda o: o['size'], reverse=True)
    return objects

def get_background_color(grid):
    """Determines the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    # Find the color with the maximum count
    background_color = counts.most_common(1)[0][0]
    return background_color

def flood_fill_from_edge(grid, background_color):
    """
    Performs a flood fill starting from background pixels at the grid edges.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color of the background pixels to fill.

    Returns:
        set: A set of (row, col) tuples representing background pixels
             connected to the edge.
    """
    rows, cols = grid.shape
    visited = set()
    queue = deque()

    # Add all edge background pixels to the queue
    for r in range(rows):
        if grid[r, 0] == background_color:
            queue.append((r, 0))
            visited.add((r, 0))
        if grid[r, cols - 1] == background_color:
            queue.append((r, cols - 1))
            visited.add((r, cols - 1))
    for c in range(cols):
        if grid[0, c] == background_color:
            queue.append((0, c))
            visited.add((0, c))
        if grid[rows - 1, c] == background_color:
            queue.append((rows - 1, c))
            visited.add((rows - 1, c))

    # BFS
    while queue:
        r, c = queue.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == background_color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))

    return visited


def transform(input_grid_list):
    """
    Applies the conditional region fill transformation to the input grid.

    Args:
        input_grid_list (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the output grid.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify background color
    background_color = get_background_color(input_grid)

    # 2. Identify all non-background objects
    all_objects = find_objects(input_grid, {background_color})

    if not all_objects: # If only background exists, return original grid
        return input_grid_list

    # 3. Determine the main boundary object (largest)
    main_boundary_object = all_objects[0]
    boundary_coords = set(main_boundary_object['coords'])

    # 4. Identify other non-background, non-boundary objects
    other_objects = [obj for obj in all_objects[1:]] # Exclude the largest object

    # 5. Check for enclosed background regions
    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))
    outside_background_coords = flood_fill_from_edge(input_grid, background_color)
    enclosed_background_coords = all_background_coords - outside_background_coords

    fill_target_coords = set()
    fill_color = -1 # Placeholder for invalid color

    # 6. & 7. Determine fill type, target, and color
    if enclosed_background_coords:
        # Inside Fill
        fill_target_coords = enclosed_background_coords

        # Find most frequent non-background color within the original enclosed region
        enclosed_pixels_colors = []
        for r, c in enclosed_background_coords:
             # Check neighbors for non-background colors IN THE ORIGINAL INPUT
             # This interpretation seems wrong based on example 3.
             # We need the colors of the objects *within* the enclosed area.
             pass # Re-think this part

        # Alternative interpretation for inside fill color (Example 3):
        # Look at *all* pixels (including non-background) within the bounding box
        # of the enclosed region, or just the original colors *at* the enclosed
        # background coordinates? The description implies looking at the content
        # *within* the enclosure. Let's find all objects fully contained within
        # the bounding box defined by the enclosed area. Simpler: Find the colors
        # of pixels *adjacent* to the enclosed background pixels, or get all pixels
        # inside the bounding box and find the most frequent non-background color.
        # Let's try: Get all non-background pixels from input_grid whose coordinates
        # fall within the space notionally defined by the enclosed region.

        # A simpler proxy for "within the enclosed region" might be pixels *adjacent*
        # to the enclosed background pixels, or pixels whose objects are fully contained.
        # Let's analyze Example 3 again. Enclosed area is near the green shapes.
        # The fill color is green (3). Green objects are within/adjacent.

        # Let's try finding the most frequent color of objects adjacent to the enclosed area.
        adjacent_non_bg_colors = []
        for r, c in enclosed_background_coords:
             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]: # 8-connectivity adjacency
                 nr, nc = r + dr, c + dc
                 if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] != background_color:
                     # Check if this adjacent pixel belongs to the main boundary
                     is_boundary_pixel = False
                     for br, bc in boundary_coords:
                         if nr == br and nc == bc:
                            is_boundary_pixel = True
                            break
                     # We only consider colors of objects *other* than the main boundary, if possible
                     # Or simply the most frequent non-bg color adjacent?
                     # Let's just collect all adjacent non-bg colors first.
                     adjacent_non_bg_colors.append(input_grid[nr, nc])

        if adjacent_non_bg_colors:
            color_counts = Counter(adjacent_non_bg_colors)
            # Remove boundary color counts if we want color *from inside*
            boundary_obj_colors = set(o['color'] for o in [main_boundary_object]) # Assuming single color boundary
            for b_color in boundary_obj_colors:
                if b_color in color_counts:
                   del color_counts[b_color] # Remove boundary color influence? Maybe not needed.

            # Try again: just find the most frequent non-background color in the enclosed area itself
            original_colors_in_enclosed = []
            # This needs a way to define the *region*, not just the background pixels within it.
            # Let's stick to the original description: "Examine the pixels within these enclosed
            # regions in the original input grid. Identify the most frequent color present there,
            # excluding the background color itself."
            # How to define "within"? Let's use a bounding box of the enclosed coords + neighbors.
            if enclosed_background_coords:
                 min_r = min(r for r, c in enclosed_background_coords)
                 max_r = max(r for r, c in enclosed_background_coords)
                 min_c = min(c for r, c in enclosed_background_coords)
                 max_c = max(c for r, c in enclosed_background_coords)

                 # Collect non-background colors within this bounding box from the input
                 colors_in_bbox = []
                 for r in range(min_r, max_r + 1):
                     for c in range(min_c, max_c + 1):
                         pixel_color = input_grid[r, c]
                         if pixel_color != background_color:
                             colors_in_bbox.append(pixel_color)

                 if colors_in_bbox:
                     fill_color = Counter(colors_in_bbox).most_common(1)[0][0]
                 else:
                     # Fallback if no non-background colors found inside bbox (unlikely for examples)
                     # Perhaps use the boundary color or a default? Let's assume one is found.
                     # If still no color, maybe default to boundary color?
                     fill_color = main_boundary_object['color'] # Guessing fallback


            # If still no fill color identified (e.g., only background in bbox), need a fallback.
            if fill_color == -1:
                 # Maybe use the color of the boundary?
                 fill_color = main_boundary_object['color'] # Fallback guess

        else:
             # Extremely unlikely case: enclosed region with no adjacent non-background pixels?
             # Fallback to boundary color
             fill_color = main_boundary_object['color']


    else:
        # Outside Fill
        fill_target_coords = outside_background_coords

        # Find the smallest object among 'other_objects'
        if other_objects:
            # Sort other_objects by size (ascending)
            other_objects.sort(key=lambda o: o['size'])
            fill_color = other_objects[0]['color']
        else:
             # If there are no 'other' objects, what determines the fill color?
             # Example 1: Boundary=3, Others=9(sz 1), 5(sz 2). Smallest=9. Fills 9.
             # Example 2: Boundary=5, Others=4(sz 1). Smallest=4. Fills 4.
             # If other_objects is empty, it means the boundary was the *only* non-background object.
             # This edge case isn't covered by examples. Maybe fill with boundary color? Or leave as background?
             # Let's assume it fills with the boundary color if no other objects exist.
             fill_color = main_boundary_object['color']


    # 8. Apply fill
    if fill_color != -1: # Ensure a valid fill color was determined
        for r, c in fill_target_coords:
            output_grid[r, c] = fill_color

    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter, deque

# Attempt to import skimage for connected components labeling
try:
    from skimage.measure import label
    SKIMAGE_AVAILABLE = True
except ImportError:
    SKIMAGE_AVAILABLE = False
    # Define a simple placeholder or raise an error if skimage is critical
    def label(mask, connectivity=1, background=0, return_num=False):
        """Placeholder for skimage.measure.label if not installed."""
        print("Warning: skimage not found. Connected components analysis might be limited or inaccurate.")
        # Basic BFS/DFS based labeling could be implemented here as a fallback
        # For now, return an empty result to indicate failure.
        if return_num:
            return np.zeros_like(mask, dtype=int), 0
        else:
            return np.zeros_like(mask, dtype=int)

"""
Transformation Rule: Conditional Region Fill

1.  Identify the background color (most frequent).
2.  Find all contiguous non-background objects (using 4-way adjacency).
3.  Identify the largest object as the 'boundary' and others as 'other objects'.
4.  Determine if the boundary encloses any background pixels by performing a flood fill from the grid edges on background pixels. Unreached background pixels form the 'enclosed region'.
5.  If an enclosed region exists:
    a. Fill the enclosed region.
    b. The fill color is determined by the non-background, non-boundary pixels adjacent (8-way) to the enclosed region. Specifically, it's the most frequent color among these adjacent pixels. If no such pixels exist, or in case of a tie, a fallback might be needed (e.g., boundary color), though not explicitly required by examples.
6.  If no enclosed region exists:
    a. Fill the background pixels connected to the edge ('outside region').
    b. The fill color is the color of the smallest 'other object' by pixel count.
    c. If no 'other objects' exist, use the color of the boundary object as the fill color.
7.  Apply the determined fill color to the determined fill region, leaving all other pixels unchanged.
"""

def get_background_color(grid):
    """Determines the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    if not counts:
        return 0 # Default background for empty grid
    # Find the color with the maximum count
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_objects(grid, colors_to_ignore):
    """
    Finds connected components (objects) in the grid using 4-way connectivity,
    ignoring specified colors. Requires skimage.measure.label or a fallback.

    Args:
        grid (np.array): The input grid.
        colors_to_ignore (set): A set of color values to ignore.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color', 'coords' (list of tuples), and 'size'.
              Sorted by size descending. Returns empty list if no objects found
              or if labeling fails.
    """
    objects = []
    unique_colors = np.unique(grid)
    rows, cols = grid.shape

    for color in unique_colors:
        if color in colors_to_ignore:
            continue

        mask = (grid == color)
        # Use connectivity=1 for 4-way adjacency
        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True)

        # Handle case where skimage might not be available or fails
        if num_labels == 0 and np.any(mask):
             if not SKIMAGE_AVAILABLE:
                 print(f"Error: Cannot label objects of color {color} without skimage.")
                 # Potentially implement a fallback BFS/DFS labeler here if needed
             # else: # skimage is available but found 0 labels - should not happen if mask is not empty
                 # print(f"Warning: skimage.measure.label found 0 components for color {color} despite presence.")


        for i in range(1, num_labels + 1):
            coords = np.argwhere(labeled_mask == i)
            if coords.size == 0: continue # Skip if label somehow has no coords
            coords_list = [tuple(coord) for coord in coords]
            obj = {
                'color': color,
                'coords': coords_list,
                'size': len(coords_list)
            }
            objects.append(obj)

    # Sort objects primarily by size (descending)
    objects.sort(key=lambda o: o['size'], reverse=True)
    return objects

def flood_fill_from_edge(grid, background_color):
    """
    Performs a flood fill starting from background pixels at the grid edges
    using 4-way connectivity.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color of the background pixels to fill.

    Returns:
        set: A set of (row, col) tuples representing background pixels
             connected to the edge.
    """
    rows, cols = grid.shape
    visited = set()
    queue = deque()

    # Seed the queue with all background pixels on the border
    for r in range(rows):
        if grid[r, 0] == background_color:
            if (r,0) not in visited: queue.append((r, 0)); visited.add((r, 0))
        if grid[r, cols - 1] == background_color:
             if (r,cols-1) not in visited: queue.append((r, cols - 1)); visited.add((r, cols - 1))
    for c in range(1, cols - 1): # Avoid double-adding corners
        if grid[0, c] == background_color:
             if (0,c) not in visited: queue.append((0, c)); visited.add((0, c))
        if grid[rows - 1, c] == background_color:
             if (rows-1,c) not in visited: queue.append((rows - 1, c)); visited.add((rows - 1, c))

    # Perform BFS using 4-way connectivity
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 neighbors
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == background_color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))

    return visited

def transform(input_grid_list):
    """
    Applies the conditional region fill transformation based on whether the largest
    non-background object encloses a background region.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Determine background color
    background_color = get_background_color(input_grid)

    # 2. Find all non-background objects
    all_objects = find_objects(input_grid, {background_color})

    # If no non-background objects, return the original grid
    if not all_objects:
        return input_grid_list

    # 3. Identify boundary object (largest) and other objects
    boundary_object = all_objects[0]
    boundary_coords_set = set(boundary_object['coords'])
    boundary_color = boundary_object['color'] # Assuming single color for boundary object
    other_objects = all_objects[1:]

    # 4. Find outside and enclosed background regions
    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))
    outside_background_coords = flood_fill_from_edge(input_grid, background_color)
    enclosed_background_coords = all_background_coords - outside_background_coords

    fill_target_coords = set()
    fill_color = -1 # Initialize with invalid color

    # 5. & 6. Determine fill type, target region, and fill color
    if enclosed_background_coords:
        # --- Inside Fill ---
        fill_target_coords = enclosed_background_coords

        # Find colors of non-background, non-boundary pixels adjacent (8-way) to the enclosed region
        adjacent_colors = []
        for r, c in enclosed_background_coords:
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0: continue # Skip self
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        pixel_coord = (nr, nc)
                        pixel_color = input_grid[nr, nc]
                        # Check if pixel is non-background and not part of the main boundary object
                        if pixel_color != background_color and pixel_coord not in boundary_coords_set:
                            adjacent_colors.append(pixel_color)

        if adjacent_colors:
            # Determine fill color: most frequent among adjacent non-boundary colors
            color_counts = Counter(adjacent_colors)
            fill_color = color_counts.most_common(1)[0][0]
        else:
            # Fallback: If no *other* objects are adjacent, maybe use boundary color?
            # Or perhaps a different rule applies? Example 3 has adjacent 'other' objects.
            # Let's default to boundary color as a plausible fallback.
            fill_color = boundary_color
            # print("Warning: Enclosed region found, but no non-boundary objects adjacent. Falling back to boundary color.")


    else:
        # --- Outside Fill ---
        fill_target_coords = outside_background_coords

        if other_objects:
            # Find smallest 'other object'
            smallest_other_object = min(other_objects, key=lambda o: o['size'])
            fill_color = smallest_other_object['color']
        else:
            # Fallback: No 'other objects', use boundary color
            fill_color = boundary_color
            # print("Warning: Outside fill required, but no 'other objects' found. Using boundary color.")

    # 7. Apply the fill
    if fill_color != -1 and fill_target_coords: # Ensure valid color and target found
        for r, c in fill_target_coords:
             # Check if the target coord is indeed background in the original grid
             # This check prevents accidentally overwriting parts of objects if logic is flawed
             # Although fill_target_coords should only contain background pixels by definition
             if input_grid[r,c] == background_color:
                  output_grid[r, c] = fill_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
