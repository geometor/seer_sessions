{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on pixel color and grid dimensions.\nThe transformation rules depend on whether the grid is \"small\" (both height H and width W < 14) or \"large\" (H >= 14 or W >= 14).\n\nRule Overview:\n1. White(0) pixels always change to Blue(1). This is applied first.\n2. If the grid is small (H < 14 AND W < 14):\n   - After step 1, Red(2) pixels change to White(0).\n   - Other colors (including Blue(1)) remain unchanged.\n3. If the grid is large (H >= 14 OR W >= 14):\n   - After step 1, identify solid rectangular blocks composed entirely of Blue(1) pixels in the *original* input grid.\n   - For each such Blue(1) rectangle, check if all cells immediately neighboring its perimeter (including diagonals) in the *original* input grid are either Blue(1) or Green(3).\n   - If the neighbor condition is met for a Blue(1) rectangle, change all pixels within that rectangle in the *output grid* to White(0).\n   - Other colors (including Red(2)) remain unchanged in large grids, except for the transformations in step 1 and the Blue(1) rectangle rule.\n\"\"\"\n\ndef _is_solid_blue_rectangle(grid: np.ndarray, r1: int, c1: int, r2: int, c2: int) -> bool:\n    \"\"\"\n    Checks if the defined rectangular area in the grid contains only Blue(1) pixels.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        r1: Top row index (inclusive).\n        c1: Left column index (inclusive).\n        r2: Bottom row index (inclusive).\n        c2: Right column index (inclusive).\n\n    Returns:\n        True if the rectangle is solid Blue(1), False otherwise.\n    \"\"\"\n    if r1 > r2 or c1 > c2: # Basic check for valid rectangle definition\n        return False\n    try:\n        # Check if all elements in the slice are equal to 1\n        return np.all(grid[r1:r2+1, c1:c2+1] == 1)\n    except IndexError:\n        # This might happen if indices are out of bounds, though loops should prevent it.\n        return False\n\n\ndef _check_rectangle_neighbors(grid: np.ndarray, r1: int, c1: int, r2: int, c2: int) -> bool:\n    \"\"\"\n    Checks if all valid neighbors around the perimeter of the rectangle (r1,c1) to (r2,c2)\n    are either Blue(1) or Green(3) in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        r1: Top row index (inclusive).\n        c1: Left column index (inclusive).\n        r2: Bottom row index (inclusive).\n        c2: Right column index (inclusive).\n\n    Returns:\n        True if all valid neighbors meet the condition, False otherwise.\n    \"\"\"\n    H, W = grid.shape\n    for nr in range(r1 - 1, r2 + 2):\n        for nc in range(c1 - 1, c2 + 2):\n            # Skip cells inside the rectangle\n            if r1 <= nr <= r2 and c1 <= nc <= c2:\n                continue\n\n            # Check boundary conditions\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_color = grid[nr, nc]\n                # If a neighbor is *not* Blue(1) and *not* Green(3), condition fails\n                if neighbor_color != 1 and neighbor_color != 3:\n                    return False\n            # Neighbors outside the grid do not invalidate the condition\n\n    # If the loop completes without returning False, all valid neighbors are 1 or 3.\n    return True\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n\n    # Determine if the grid is small\n    is_small = H < 14 and W < 14\n\n    # --- Step 1: Universal White(0) -> Blue(1) Transformation ---\n    # Apply this first to the output grid\n    output_grid[input_grid == 0] = 1\n\n    # --- Step 2: Category-Specific Transformations ---\n\n    if is_small:\n        # Apply Small Grid Rule: Red(2) -> White(0)\n        # We check the *input* grid for Red(2) and modify the *output* grid\n        output_grid[(input_grid == 2)] = 0\n    else:\n        # Apply Large Grid Rule: Find qualifying Blue(1) rectangles and change them to White(0)\n        # Iterate through all possible top-left (r1, c1) and bottom-right (r2, c2) corners\n        for r1 in range(H):\n            for c1 in range(W):\n                for r2 in range(r1, H):\n                    for c2 in range(c1, W):\n                        # Check if this rectangle in the *original* grid is solid Blue(1)\n                        if _is_solid_blue_rectangle(input_grid, r1, c1, r2, c2):\n                            # Check if the neighbors in the *original* grid meet the condition\n                            if _check_rectangle_neighbors(input_grid, r1, c1, r2, c2):\n                                # If both conditions met, modify the *output* grid\n                                # Set all pixels within this rectangle to White(0)\n                                output_grid[r1:r2+1, c1:c2+1] = 0\n                                # Note: This overwrites any previous changes (like 0->1)\n                                # within this rectangle, which is the desired outcome based on examples.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14177,
    "candidates_token_count": 1446,
    "total_token_count": 15623,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.91281,
  "retries": 1
}