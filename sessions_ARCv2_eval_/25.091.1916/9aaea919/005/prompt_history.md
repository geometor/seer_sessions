
## train_1

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 4 4 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 9 9 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 4 4 7 7 7 7
7 7 7 7 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 9 9 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 9 9 9 9 9 7 0 0 0 0 0 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 9 9 9 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 2 2 7 7 7 7 7 7 7 3 3 3 3 3 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 5 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 5 5 5 5 5 7 7 7 7 7 7 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 5 5 5 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 5 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 5 5 5 5 5 7 0 0 0 0 0 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 5 5 5 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 6 6 6 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 6 6 6 6 6 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 6 6 6 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 5 5 5 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 5 5 5 5 5 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 5 5 5 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 3 3 3 3 3 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 3 3 3 3 3 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 0 0 0 6 6 6 6 6
6 6 6 7 7 7 7 7 6 2 2 2 2 2 6 3 3 3 3 3 6 0 0 0 0 0 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 0 0 0 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 3 3 3 3 3 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 0 0 0 6 6 6 6 6
6 6 6 7 7 7 7 7 6 2 2 2 2 2 6 5 5 5 5 5 6 0 0 0 0 0 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 0 0 0 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```

Okay, let's analyze the provided examples.

**Perception of Task Elements**

1.  **Grid Structure:** Both input and output are 2D grids of pixels with varying dimensions (all examples here are 30x30).
2.  **Background Color:** Each grid has a dominant background color filling most of the space (Orange=7 in train_1, Blue=1 in train_2, Magenta=6 in train_3). This color seems consistent between the input and output, except where objects are modified. The background color appears to be the color of the top-left pixel (0,0).
3.  **Objects:** The input grids contain distinct objects placed on the background. These objects appear in two main shapes:
    *   **Plus Shape:** A cross shape, typically 5 pixels tall and 5 pixels wide (e.g., a 3x5 horizontal bar intersecting a 5x3 vertical bar at the center seems incorrect based on the visual, it's more like a 1x5 horizontal bar intersecting a 3x1 vertical bar or vice versa, specifically a 3-pixel vertical line and a 5-pixel horizontal line crossing at their centers). These plus shapes appear in various colors (Maroon, White, Blue, Yellow, Azure, Magenta, Green, Red, Orange).
    *   **Horizontal Line:** A 1x5 rectangle (line segment) located specifically on the bottom row of the grid (row index H-1). These lines only appear in Red (2) or Green (3).
4.  **Transformation:** The primary transformation involves:
    *   Identifying the Red (2) and Green (3) horizontal lines on the bottom row.
    *   Locating the plus-shaped object(s) positioned directly above these lines (sharing the same column range).
    *   Conditionally changing the color of the plus-shaped object based on the color of the line below it.
    *   Removing the Red and Green lines from the bottom row.
5.  **Color Changes:**
    *   If a plus-shaped object is above a *Red (2)* line, its color changes to *Gray (5)*. (Observed for Maroon(9), Magenta(6), Green(3)).
    *   If a plus-shaped object is above a *Green (3)* line, its color *does not change*. (Observed for Blue(1), White(0), Red(2)).
6.  **Object Removal:** The Red (2) and Green (3) horizontal lines on the bottom row are always removed (replaced by the background color) in the output.
7.  **Object Preservation:** All other plus-shaped objects not located directly above a Red or Green line on the bottom row remain unchanged in position and color. The background color also remains the same.

**YAML Fact Sheet**


```yaml
task_description: "Modify colors of plus-shaped objects based on the color of specific horizontal lines directly below them on the bottom row, then remove the lines."

grid_properties:
  - background_color: Determined by the color of the pixel at (0,0). Remains constant in output except where lines are removed.
  - dimensions: Input and output grids have the same dimensions.

objects:
  - type: plus_shape
    description: "A 5x5 cross shape made of a single color."
    properties:
      - color: Various (Maroon, White, Blue, Yellow, Azure, Magenta, Green, Red, Orange)
      - position: Various locations within the grid.
    actions:
      - color_change: May change color to Gray (5) based on the trigger_line below.
      - remain_unchanged: If not above a trigger_line, or if above a Green trigger_line.
  - type: trigger_line
    description: "A 1x5 horizontal rectangle located on the bottom row (row H-1)."
    properties:
      - color: Exclusively Red (2) or Green (3).
      - position: Always on the bottom row, column varies.
    actions:
      - cause_effect: Triggers potential color change in the plus_shape object directly above it.
      - removed: Always removed from the output grid (pixels replaced by background_color).

relationships:
  - relationship: "directly_above"
    object1: plus_shape
    object2: trigger_line
    condition: "The column range of the plus_shape significantly overlaps with the column range of the trigger_line on the row below (H-1)."

transformation_rules:
  - rule: "Red Trigger"
    condition: "A plus_shape is directly_above a Red (2) trigger_line."
    action: "Change the color of the plus_shape to Gray (5)."
  - rule: "Green Trigger"
    condition: "A plus_shape is directly_above a Green (3) trigger_line."
    action: "The color of the plus_shape remains unchanged."
  - rule: "Line Removal"
    condition: "An object is a trigger_line (Red or Green on the bottom row)."
    action: "Remove the trigger_line by replacing its pixels with the background_color."
  - rule: "Default Preservation"
    condition: "Any pixel not part of a trigger_line or a plus_shape modified by a Red trigger_line."
    action: "Keep the pixel's original color."

```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Determine the background color by inspecting the color of the pixel at coordinates (0, 0) in the input grid.
3.  Identify all horizontal, 5-pixel-long line segments composed solely of Red (2) or Green (3) pixels located on the bottom row (row index H-1, where H is the grid height) of the input grid. Let's call these "trigger lines".
4.  For each identified trigger line:
    a.  Determine its color (Red or Green) and its column range.
    b.  Scan the input grid to find any plus-shaped objects positioned directly above the trigger line (i.e., the object's columns overlap with the trigger line's columns, and the object is vertically adjacent or close).
    c.  If the trigger line's color is Red (2):
        i.  For each plus-shaped object found directly above it, change all pixels belonging to that object in the *output* grid to Gray (5).
    d.  If the trigger line's color is Green (3):
        i.  The plus-shaped object(s) directly above it remain unchanged in the output grid (no action needed due to step 1).
    e.  Change the pixels corresponding to the trigger line itself (on the bottom row in the identified column range) in the *output* grid to the background color determined in step 2.
5.  Return the modified output grid.


```python
import numpy as np
from typing import Tuple, List, Dict

# Define color constants for clarity
COLORS = {
    "white": 0,
    "blue": 1,
    "red": 2,
    "green": 3,
    "yellow": 4,
    "gray": 5,
    "magenta": 6,
    "orange": 7,
    "azure": 8,
    "maroon": 9,
}

def _get_plus_shape_coords(center_r: int, center_c: int) -> List[Tuple[int, int]]:
    """Returns the coordinates of a 5x5 plus shape centered at (center_r, center_c)."""
    coords = []
    # Horizontal bar
    for dc in range(-2, 3):
        coords.append((center_r, center_c + dc))
    # Vertical bar (excluding center pixel already added)
    for dr in range(-2, 3):
        if dr != 0:
            coords.append((center_r + dr, center_c))
    return coords

def _is_plus_shape_at(grid: np.ndarray, r: int, c: int, background_color: int) -> Tuple[bool, int]:
    """
    Checks if a 5x5 plus shape is centered at (r, c).
    Returns (True, shape_color) if found, otherwise (False, -1).
    Assumes center (r,c) is not background.
    """
    height, width = grid.shape
    shape_color = grid[r, c]

    # Check bounds for the 5x5 area
    if not (2 <= r < height - 2 and 2 <= c < width - 2):
        return False, -1

    # Expected coordinates for the plus shape
    expected_coords = set(_get_plus_shape_coords(r, c))
    
    # Check the 5x5 bounding box
    for dr in range(-2, 3):
        for dc in range(-2, 3):
            current_r, current_c = r + dr, c + dc
            coord = (current_r, current_c)
            pixel_color = grid[current_r, current_c]

            if coord in expected_coords:
                # Pixel should be part of the shape
                if pixel_color != shape_color:
                    return False, -1
            else:
                # Pixel should be background
                if pixel_color != background_color:
                    return False, -1

    return True, shape_color


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid based on the following rules:
    1. Identify horizontal 1x5 lines of Red (2) or Green (3) on the bottom row ("trigger lines").
    2. For each trigger line, check if a 5x5 plus-shaped object exists directly above it (centered).
    3. If a Red trigger line is found with a plus shape above it, change the plus shape's color to Gray (5).
    4. If a Green trigger line is found with a plus shape above it, the plus shape's color remains unchanged.
    5. All trigger lines (Red or Green) on the bottom row are removed (replaced by the background color).
    6. Other elements in the grid remain unchanged.
    """
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # Determine the background color (assuming top-left pixel is representative)
    background_color = input_grid[0, 0]
    
    # Define trigger line colors
    trigger_colors = {COLORS["red"], COLORS["green"]}
    
    # Iterate through potential starting columns for a 5-pixel wide trigger line on the bottom row
    bottom_row_index = height - 1
    for c in range(width - 4):
        # Check for a 1x5 horizontal line of a trigger color
        line_segment = input_grid[bottom_row_index, c:c+5]
        first_pixel_color = line_segment[0]
        
        # Check if it's a solid line of a single trigger color
        if first_pixel_color in trigger_colors and np.all(line_segment == first_pixel_color):
            line_color = first_pixel_color
            line_start_col = c
            line_end_col = c + 4
            line_center_col = c + 2

            # Potential center row for a 5x5 plus shape above the line
            # The center row of the plus would be 3 rows above the line's row
            plus_center_r = bottom_row_index - 3 
            plus_center_c = line_center_col

            # Check if a valid plus shape exists centered at this potential location
            # Make sure the potential center is within grid bounds vertically
            if plus_center_r >= 2: 
                is_plus, plus_color = _is_plus_shape_at(input_grid, plus_center_r, plus_center_c, background_color)
                
                if is_plus:
                    # Apply color change rule if the line is Red
                    if line_color == COLORS["red"]:
                        new_plus_color = COLORS["gray"]
                        plus_coords = _get_plus_shape_coords(plus_center_r, plus_center_c)
                        for r_coord, c_coord in plus_coords:
                             # Double check bounds just in case, though _is_plus_shape_at should ensure this
                             if 0 <= r_coord < height and 0 <= c_coord < width:
                                 # Only change if the original color matches (handles overlapping shapes, though unlikely here)
                                 if output_grid[r_coord, c_coord] == plus_color:
                                      output_grid[r_coord, c_coord] = new_plus_color
                    # If line_color is Green, no change to the plus shape is needed

            # Remove the trigger line itself from the output grid, regardless of whether a plus was found above it
            output_grid[bottom_row_index, line_start_col:line_end_col+1] = background_color

    return output_grid
```
```python
import numpy as np
from typing import Tuple, List, Dict

"""
Modify the color of specific 3x5 cross shapes to gray (5) if they are 
positioned directly above a red (2) 1x5 line on the bottom row. 
Remove all red (2) and green (3) 1x5 lines from the bottom row, 
replacing them with the background color. 
Other grid elements remain unchanged.
"""

# Define color constants for clarity
COLORS = {
    "white": 0,
    "blue": 1,
    "red": 2,
    "green": 3,
    "yellow": 4,
    "gray": 5,
    "magenta": 6,
    "orange": 7,
    "azure": 8,
    "maroon": 9,
}

def _check_and_update_cross(input_grid: np.ndarray, 
                            output_grid: np.ndarray, 
                            cross_top_r: int, 
                            cross_left_c: int, 
                            trigger_line_color: int, 
                            background_color: int):
    """
    Checks if a 3x5 cross shape exists at the specified top-left corner (cross_top_r, cross_left_c)
    in the input_grid. If it exists and the trigger_line_color is red, it updates the 
    corresponding pixels in the output_grid to gray.

    Args:
        input_grid: The original input grid.
        output_grid: The grid being modified.
        cross_top_r: The expected top row index of the cross shape.
        cross_left_c: The expected left column index of the cross shape.
        trigger_line_color: The color of the trigger line found below (Red=2 or Green=3).
        background_color: The background color of the grid.
    """
    H, W = input_grid.shape
    
    # Define cross shape dimensions and center relative to top-left corner
    cross_height = 3
    cross_width = 5
    center_rel_r = 1 # Row offset of the horizontal bar
    center_rel_c = 2 # Column offset of the vertical bar center
    
    # --- 1. Boundary Checks ---
    # Check if the 3x5 bounding box fits within the grid
    if not (0 <= cross_top_r < H - (cross_height - 1) and 
            0 <= cross_left_c < W - (cross_width - 1)):
        return # Cross shape would be out of bounds

    # --- 2. Shape Identification ---
    # Define absolute coordinates
    mid_row = cross_top_r + center_rel_r
    center_col = cross_left_c + center_rel_c
    
    # Check the center pixel first - it must exist and not be background
    expected_cross_color = input_grid[mid_row, center_col]
    if expected_cross_color == background_color:
        return # Center pixel is background, not a shape

    # Check horizontal bar (1x5 at mid_row)
    horizontal_bar = input_grid[mid_row, cross_left_c : cross_left_c + cross_width]
    if not np.all(horizontal_bar == expected_cross_color):
        return # Horizontal bar is not solid or wrong color

    # Check vertical bar elements (excluding center pixel already checked)
    top_pixel = input_grid[cross_top_r, center_col]
    bottom_pixel = input_grid[cross_top_r + cross_height - 1, center_col]
    if not (top_pixel == expected_cross_color and bottom_pixel == expected_cross_color):
        return # Vertical bar parts are missing or wrong color
        
    # Optional: Check if the corner pixels of the 3x5 bounding box are background
    # This helps distinguish the cross from a solid rectangle, if necessary.
    # Not strictly required based on examples, but adds robustness.
    corners_are_background = True
    for r_offset in [0, cross_height - 1]:
        for c_offset in [0, 1, 3, cross_width - 1]: # Skip center column
             if input_grid[cross_top_r + r_offset, cross_left_c + c_offset] != background_color:
                 corners_are_background = False
                 break
        if not corners_are_background:
             break
    if not corners_are_background:
         return # Not a cross shape, likely part of a larger object

    # --- 3. Apply Transformation ---
    # If we reach here, a valid cross shape is found.
    # Change its color to Gray only if the trigger line was Red.
    if trigger_line_color == COLORS["red"]:
        new_color = COLORS["gray"]
        # Color the horizontal bar
        output_grid[mid_row, cross_left_c : cross_left_c + cross_width] = new_color
        # Color the vertical bar parts
        output_grid[cross_top_r, center_col] = new_color
        output_grid[cross_top_r + cross_height - 1, center_col] = new_color


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid based on the identified rules:
    1. Finds 1x5 Red(2) or Green(3) lines on the bottom row.
    2. Checks for a 3x5 cross shape directly above the line.
    3. If the line is Red and a cross exists, changes the cross to Gray(5).
    4. Removes all Red and Green lines from the bottom row.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    H, W = input_grid.shape
    
    # Determine the background color (assuming top-left pixel is representative)
    background_color = input_grid[0, 0]
    
    # Define trigger line colors
    trigger_colors = {COLORS["red"], COLORS["green"]}
    
    # Iterate through potential starting columns for a 5-pixel wide trigger line on the bottom row
    bottom_row_index = H - 1
    line_width = 5
    
    # Processed columns for lines to avoid double-processing overlaps (though lines seem distinct)
    processed_line_cols = set()

    for c in range(W - (line_width - 1)):
        # Skip if this column was part of an already processed line
        if c in processed_line_cols:
            continue

        # Check for a 1x5 horizontal line of a trigger color
        line_segment = input_grid[bottom_row_index, c : c + line_width]
        potential_line_color = line_segment[0]
        
        # Check if it's a solid line of a single trigger color
        if (potential_line_color in trigger_colors and 
            np.all(line_segment == potential_line_color)):
            
            # Found a trigger line
            trigger_line_color = potential_line_color
            line_start_col = c
            line_end_col = c + line_width - 1

            # Define the expected location of the cross shape above this line
            # The cross shape is 3 rows high. Its top row would be H-1(line)-1(gap)-1(bottom)-1(mid)-1(top) = H-5 ? No, H-4
            # If line is H-1, cross rows are H-4, H-3, H-2. Top row is H-4.
            cross_top_r = bottom_row_index - 3 # Top row of the 3x5 cross area
            cross_left_c = line_start_col     # Left column matches the line

            # Check for the cross shape and update output_grid if necessary
            _check_and_update_cross(input_grid, 
                                    output_grid, 
                                    cross_top_r, 
                                    cross_left_c, 
                                    trigger_line_color, 
                                    background_color)

            # Remove the trigger line itself from the output grid
            output_grid[bottom_row_index, line_start_col : line_end_col + 1] = background_color
            
            # Mark columns of this line as processed
            for col_idx in range(line_start_col, line_end_col + 1):
                 processed_line_cols.add(col_idx)

    return output_grid
```

Previous Code:
```python
import numpy as np
from typing import Tuple, List, Dict

"""
Modify the color of specific 3x5 cross shapes to gray (5) if they are 
positioned directly above a red (2) 1x5 line on the bottom row. 
Remove all red (2) and green (3) 1x5 lines from the bottom row, 
replacing them with the background color. 
Other grid elements remain unchanged.
"""

# Define color constants for clarity
COLORS = {
    "white": 0,
    "blue": 1,
    "red": 2,
    "green": 3,
    "yellow": 4,
    "gray": 5,
    "magenta": 6,
    "orange": 7,
    "azure": 8,
    "maroon": 9,
}

def _check_and_update_cross(input_grid: np.ndarray, 
                            output_grid: np.ndarray, 
                            cross_top_r: int, 
                            cross_left_c: int, 
                            trigger_line_color: int, 
                            background_color: int):
    """
    Checks if a 3x5 cross shape exists at the specified top-left corner (cross_top_r, cross_left_c)
    in the input_grid. If it exists and the trigger_line_color is red, it updates the 
    corresponding pixels in the output_grid to gray.

    Args:
        input_grid: The original input grid.
        output_grid: The grid being modified.
        cross_top_r: The expected top row index of the cross shape.
        cross_left_c: The expected left column index of the cross shape.
        trigger_line_color: The color of the trigger line found below (Red=2 or Green=3).
        background_color: The background color of the grid.
    """
    H, W = input_grid.shape
    
    # Define cross shape dimensions and center relative to top-left corner
    cross_height = 3
    cross_width = 5
    center_rel_r = 1 # Row offset of the horizontal bar
    center_rel_c = 2 # Column offset of the vertical bar center
    
    # --- 1. Boundary Checks ---
    # Check if the 3x5 bounding box fits within the grid
    if not (0 <= cross_top_r < H - (cross_height - 1) and 
            0 <= cross_left_c < W - (cross_width - 1)):
        return # Cross shape would be out of bounds

    # --- 2. Shape Identification ---
    # Define absolute coordinates
    mid_row = cross_top_r + center_rel_r
    center_col = cross_left_c + center_rel_c
    
    # Check the center pixel first - it must exist and not be background
    expected_cross_color = input_grid[mid_row, center_col]
    if expected_cross_color == background_color:
        return # Center pixel is background, not a shape

    # Check horizontal bar (1x5 at mid_row)
    horizontal_bar = input_grid[mid_row, cross_left_c : cross_left_c + cross_width]
    if not np.all(horizontal_bar == expected_cross_color):
        return # Horizontal bar is not solid or wrong color

    # Check vertical bar elements (excluding center pixel already checked)
    top_pixel = input_grid[cross_top_r, center_col]
    bottom_pixel = input_grid[cross_top_r + cross_height - 1, center_col]
    if not (top_pixel == expected_cross_color and bottom_pixel == expected_cross_color):
        return # Vertical bar parts are missing or wrong color
        
    # Optional: Check if the corner pixels of the 3x5 bounding box are background
    # This helps distinguish the cross from a solid rectangle, if necessary.
    # Not strictly required based on examples, but adds robustness.
    corners_are_background = True
    for r_offset in [0, cross_height - 1]:
        for c_offset in [0, 1, 3, cross_width - 1]: # Skip center column
             if input_grid[cross_top_r + r_offset, cross_left_c + c_offset] != background_color:
                 corners_are_background = False
                 break
        if not corners_are_background:
             break
    if not corners_are_background:
         return # Not a cross shape, likely part of a larger object

    # --- 3. Apply Transformation ---
    # If we reach here, a valid cross shape is found.
    # Change its color to Gray only if the trigger line was Red.
    if trigger_line_color == COLORS["red"]:
        new_color = COLORS["gray"]
        # Color the horizontal bar
        output_grid[mid_row, cross_left_c : cross_left_c + cross_width] = new_color
        # Color the vertical bar parts
        output_grid[cross_top_r, center_col] = new_color
        output_grid[cross_top_r + cross_height - 1, center_col] = new_color


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid based on the identified rules:
    1. Finds 1x5 Red(2) or Green(3) lines on the bottom row.
    2. Checks for a 3x5 cross shape directly above the line.
    3. If the line is Red and a cross exists, changes the cross to Gray(5).
    4. Removes all Red and Green lines from the bottom row.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    H, W = input_grid.shape
    
    # Determine the background color (assuming top-left pixel is representative)
    background_color = input_grid[0, 0]
    
    # Define trigger line colors
    trigger_colors = {COLORS["red"], COLORS["green"]}
    
    # Iterate through potential starting columns for a 5-pixel wide trigger line on the bottom row
    bottom_row_index = H - 1
    line_width = 5
    
    # Processed columns for lines to avoid double-processing overlaps (though lines seem distinct)
    processed_line_cols = set()

    for c in range(W - (line_width - 1)):
        # Skip if this column was part of an already processed line
        if c in processed_line_cols:
            continue

        # Check for a 1x5 horizontal line of a trigger color
        line_segment = input_grid[bottom_row_index, c : c + line_width]
        potential_line_color = line_segment[0]
        
        # Check if it's a solid line of a single trigger color
        if (potential_line_color in trigger_colors and 
            np.all(line_segment == potential_line_color)):
            
            # Found a trigger line
            trigger_line_color = potential_line_color
            line_start_col = c
            line_end_col = c + line_width - 1

            # Define the expected location of the cross shape above this line
            # The cross shape is 3 rows high. Its top row would be H-1(line)-1(gap)-1(bottom)-1(mid)-1(top) = H-5 ? No, H-4
            # If line is H-1, cross rows are H-4, H-3, H-2. Top row is H-4.
            cross_top_r = bottom_row_index - 3 # Top row of the 3x5 cross area
            cross_left_c = line_start_col     # Left column matches the line

            # Check for the cross shape and update output_grid if necessary
            _check_and_update_cross(input_grid, 
                                    output_grid, 
                                    cross_top_r, 
                                    cross_left_c, 
                                    trigger_line_color, 
                                    background_color)

            # Remove the trigger line itself from the output grid
            output_grid[bottom_row_index, line_start_col : line_end_col + 1] = background_color
            
            # Mark columns of this line as processed
            for col_idx in range(line_start_col, line_end_col + 1):
                 processed_line_cols.add(col_idx)

    return output_grid
```
Results for code_00.py:
Train Set Error: Timeout: Code execution exceeded 10 seconds
**General Assessment**

The initial code attempt failed due to a timeout, likely caused by an incorrect understanding of the spatial relationship between the "trigger lines" and the "cross shapes". The assumption was that the cross shapes were *directly* above the lines, leading to checks in the wrong locations. Re-analysis of all three training examples reveals that the critical factor is the *column overlap* between the trigger lines (1x5 Red or Green lines on the bottom row) and the cross shapes (3x5 shapes anywhere in the grid), irrespective of the vertical distance.

**Strategy for Resolution**

1.  **Identify Trigger Lines:** Scan only the bottom row (H-1) for contiguous 1x5 segments of Red (2) or Green (3) pixels. Store the color and column range `(start_col, end_col)` for each found line.
2.  **Identify Cross Shapes:** Scan the entire grid to locate all 3x5 cross shapes (a 1x5 horizontal bar intersecting a 3x1 vertical bar at their centers). Ensure these shapes are isolated (surrounding relevant pixels match the background color). Store the coordinates of the pixels belonging to each cross, its original color, and its column range `(start_col, end_col)`.
3.  **Apply Transformation Logic:**
    *   Create a copy of the input grid for the output.
    *   Iterate through each identified cross shape.
    *   Check if its column range overlaps with the column range of any identified Red trigger line. Overlap occurs if `max(cross_start_col, line_start_col) <= min(cross_end_col, line_end_col)`.
    *   If an overlap with a Red line exists, change the color of all pixels belonging to that cross shape in the *output* grid to Gray (5).
    *   If no overlap with a Red line exists, check for overlap with any Green trigger line using the same logic. If overlap exists, the cross shape remains unchanged (no action needed on the output grid copy).
    *   If a cross overlaps with neither, it also remains unchanged.
4.  **Remove Trigger Lines:** Iterate through the stored Red and Green trigger lines. For each line, change the corresponding pixels on the bottom row of the *output* grid to the background color.
5.  Return the modified output grid.

**Metrics Gathering**

