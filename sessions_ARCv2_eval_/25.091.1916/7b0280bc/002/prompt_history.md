
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 2 8 8 8 8 8 1 1 8
8 8 8 8 8 8 0 8 2 2 8 8 8 8 8 1 1 8
8 8 2 2 8 0 8 8 8 0 8 8 8 8 0 8 0 8
8 8 2 2 0 8 8 8 8 0 8 8 8 0 8 8 0 8
8 8 0 8 8 8 8 8 8 0 8 8 8 0 8 8 0 8
8 8 0 8 8 8 8 8 8 0 8 8 8 0 8 8 0 8
8 8 8 0 8 8 8 8 8 0 8 8 0 8 8 8 0 8
8 8 8 0 8 8 8 8 8 8 0 8 2 2 8 8 0 8
8 8 8 1 1 8 8 8 8 8 0 8 2 2 8 8 0 8
8 8 8 1 1 8 8 8 8 8 0 8 8 8 8 8 0 8
8 8 8 0 8 8 8 8 8 8 0 8 8 8 8 0 8 8
8 8 8 8 0 8 8 8 8 8 0 8 8 8 0 8 8 8
8 8 8 8 0 8 8 8 8 8 2 2 8 0 8 8 8 8
8 8 8 8 2 2 8 8 0 0 2 2 0 8 8 8 8 8
8 8 8 8 2 2 0 0 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 2 8 8 8 8 8 1 1 8
8 8 8 8 8 8 0 8 2 2 8 8 8 8 8 1 1 8
8 8 2 2 8 0 8 8 8 0 8 8 8 8 0 8 5 8
8 8 2 2 0 8 8 8 8 0 8 8 8 0 8 8 5 8
8 8 0 8 8 8 8 8 8 0 8 8 8 0 8 8 5 8
8 8 0 8 8 8 8 8 8 0 8 8 8 0 8 8 5 8
8 8 8 0 8 8 8 8 8 0 8 8 0 8 8 8 5 8
8 8 8 0 8 8 8 8 8 8 0 8 2 2 8 8 5 8
8 8 8 1 1 8 8 8 8 8 0 8 2 2 8 8 5 8
8 8 8 1 1 8 8 8 8 8 0 8 8 8 8 8 5 8
8 8 8 5 8 8 8 8 8 8 0 8 8 8 8 5 8 8
8 8 8 8 5 8 8 8 8 8 0 8 8 8 5 8 8 8
8 8 8 8 5 8 8 8 8 8 3 3 8 5 8 8 8 8
8 8 8 8 3 3 8 8 5 5 3 3 5 8 8 8 8 8
8 8 8 8 3 3 5 5 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
9 9 9 9 9 9 4 7 7 4 9 9 9 9 9
9 9 9 7 7 4 9 7 7 9 4 6 6 9 9
9 9 9 7 7 9 9 9 9 9 9 6 6 4 9
9 9 9 4 9 4 9 9 9 9 9 9 9 9 4
9 9 9 4 9 9 4 9 9 9 9 9 9 9 4
9 4 6 6 9 9 9 4 9 9 9 9 9 4 9
4 9 6 6 9 9 9 4 9 9 9 9 7 7 9
4 9 9 9 9 9 9 7 7 4 4 4 7 7 9
4 9 9 9 9 9 9 7 7 9 9 9 9 4 9
4 9 7 7 4 9 9 9 4 9 9 9 9 4 9
4 9 7 7 9 4 9 9 9 4 9 9 4 9 9
4 9 9 9 9 4 9 9 9 4 9 9 4 9 9
9 4 9 9 9 7 7 9 9 7 7 9 4 9 9
9 9 4 4 4 7 7 9 9 7 7 9 7 7 9
9 9 9 9 9 9 9 9 9 9 9 9 7 7 9
```


**output:**
```
9 9 9 9 9 9 5 3 3 5 9 9 9 9 9
9 9 9 3 3 5 9 3 3 9 5 6 6 9 9
9 9 9 3 3 9 9 9 9 9 9 6 6 4 9
9 9 9 5 9 4 9 9 9 9 9 9 9 9 4
9 9 9 5 9 9 4 9 9 9 9 9 9 9 4
9 4 6 6 9 9 9 4 9 9 9 9 9 4 9
4 9 6 6 9 9 9 4 9 9 9 9 7 7 9
4 9 9 9 9 9 9 7 7 4 4 4 7 7 9
4 9 9 9 9 9 9 7 7 9 9 9 9 4 9
4 9 7 7 4 9 9 9 4 9 9 9 9 4 9
4 9 7 7 9 4 9 9 9 4 9 9 4 9 9
4 9 9 9 9 4 9 9 9 4 9 9 4 9 9
9 4 9 9 9 7 7 9 9 7 7 9 4 9 9
9 9 4 4 4 7 7 9 9 7 7 9 7 7 9
9 9 9 9 9 9 9 9 9 9 9 9 7 7 9
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 1 1 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7
7 7 1 1 7 7 7 7 7 7 6 6 6 6 7 7 7 7 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 2 2 7 7 7 7 7
7 7 6 7 7 7 7 7 7 7 7 7 6 2 2 7 7 7 7 7
7 7 6 7 7 7 7 7 7 7 7 6 7 7 6 7 7 7 7 7
7 7 6 7 7 7 7 7 7 7 1 1 7 7 6 7 7 7 7 7
7 6 6 7 7 7 7 7 7 7 1 1 7 7 6 7 7 7 7 7
7 6 7 7 7 7 7 7 7 7 6 7 7 7 6 7 7 7 7 7
7 6 7 7 7 7 7 1 1 7 6 7 7 7 7 6 7 7 7 7
7 6 7 7 7 7 6 1 1 6 7 7 7 7 7 6 7 7 7 7
7 6 7 7 7 6 7 7 7 7 7 7 7 7 7 7 6 7 7 7
7 6 7 7 1 1 7 7 7 7 7 7 7 7 7 7 6 7 7 7
7 6 7 7 1 1 6 6 7 7 7 7 7 7 7 6 7 7 7 7
7 6 7 7 6 7 7 7 6 6 7 7 7 7 1 1 7 7 7 7
7 6 7 6 7 7 7 7 7 7 6 6 6 6 1 1 7 7 7 7
7 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 3 3 5 5 5 5 5 5 7 7 7 7 7 7 7 7 7 7
7 7 3 3 7 7 7 7 7 7 5 5 5 5 7 7 7 7 7 7
7 7 5 7 7 7 7 7 7 7 7 7 7 7 5 7 7 7 7 7
7 7 5 7 7 7 7 7 7 7 7 7 7 2 2 7 7 7 7 7
7 7 5 7 7 7 7 7 7 7 7 7 6 2 2 7 7 7 7 7
7 7 5 7 7 7 7 7 7 7 7 6 7 7 6 7 7 7 7 7
7 7 5 7 7 7 7 7 7 7 1 1 7 7 6 7 7 7 7 7
7 5 5 7 7 7 7 7 7 7 1 1 7 7 6 7 7 7 7 7
7 5 7 7 7 7 7 7 7 7 6 7 7 7 6 7 7 7 7 7
7 5 7 7 7 7 7 1 1 7 6 7 7 7 7 6 7 7 7 7
7 5 7 7 7 7 6 1 1 6 7 7 7 7 7 6 7 7 7 7
7 5 7 7 7 6 7 7 7 7 7 7 7 7 7 7 6 7 7 7
7 5 7 7 1 1 7 7 7 7 7 7 7 7 7 7 6 7 7 7
7 5 7 7 1 1 6 6 7 7 7 7 7 7 7 6 7 7 7 7
7 5 7 7 6 7 7 7 6 6 7 7 7 7 1 1 7 7 7 7
7 5 7 6 7 7 7 7 7 7 6 6 6 6 1 1 7 7 7 7
7 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's break down the transformation logic for this task.

**Perception of Elements:**

1.  **Grid Structure:** The input and output grids always have the same dimensions.
2.  **Background Color:** Each example has a dominant background color (azure '8', maroon '9', orange '7') which remains unchanged in the output.
3.  **Object Colors:** Besides the background, there are consistently three other colors present in the input grid.
4.  **Color Changes:** Specific pixels change color based on their own color and the colors of their immediate neighbors (including diagonals).
5.  **Transformation Products:** Two new colors appear in the output: gray (5) and green (3).
6.  **Role-Based Interaction:** The transformation seems to depend on assigning specific roles to the three non-background colors: a "trigger" color, a "changing actor" color, and a "non-changing actor" color.
    *   The trigger color changes to gray (5) when adjacent to *either* actor color.
    *   The changing actor color changes to green (3) when adjacent to the trigger color.
    *   The non-changing actor color is sometimes adjacent to the trigger color but never changes.
7.  **Identifying Roles:**
    *   **Trigger Color:** Across the examples (white '0', yellow '4', magenta '6'), the trigger color seems identifiable because it's the only one of the three non-background colors that appears as isolated pixels (pixels with no neighbors of the same color).
    *   **Actor Roles:** Once the trigger color is identified, the roles of the other two colors (which one changes, which one doesn't) seem to follow a fixed mapping based *only* on the trigger color's identity:
        *   If Trigger=0 (white), Changing=2 (red), Non-changing=1 (blue).
        *   If Trigger=4 (yellow), Changing=7 (orange), Non-changing=6 (magenta).
        *   If Trigger=6 (magenta), Changing=1 (blue), Non-changing=2 (red).
8.  **Simultaneity:** The rules are applied based on the state of the *input* grid. For instance, if a trigger pixel is next to a changing actor pixel, the trigger pixel becomes gray, and the changing actor pixel becomes green simultaneously based on their original adjacency in the input.

**YAML Facts:**


```yaml
task_description: Changes pixel colors based on adjacency rules involving three non-background colors assigned roles (trigger, changing actor, non-changing actor). The trigger changes to gray(5) if near an actor. The changing actor changes to green(3) if near the trigger. Roles are determined by identifying the trigger color (the one with isolated pixels) and applying a fixed mapping.
grid_properties:
  dimensionality: 2
  value_range: 0-9 # colors
  size_constancy: True # Input and output grids have the same dimensions.
objects:
  - type: Background
    properties: Most frequent color, remains unchanged.
  - type: Color Pixels (non-background)
    properties: Three distinct colors per example. Assigned roles based on properties and rules.
roles:
  - role: Trigger Color
    identification: The non-background color that appears as isolated pixels (no same-colored neighbors).
    transformation: Changes to gray (5) if adjacent (8-way) to Changing Actor or Non-changing Actor in the input grid.
  - role: Changing Actor Color
    identification: Determined by Trigger Color via fixed mapping: (Trigger=0 -> Actor=2), (Trigger=4 -> Actor=7), (Trigger=6 -> Actor=1).
    transformation: Changes to green (3) if adjacent (8-way) to Trigger Color in the input grid.
  - role: Non-changing Actor Color
    identification: The remaining non-background color after identifying Trigger and Changing Actor. Also determined by fixed mapping: (Trigger=0 -> Actor=1), (Trigger=4 -> Actor=6), (Trigger=6 -> Actor=2).
    transformation: Never changes color.
relationships:
  - type: Adjacency
    definition: 8-way connectivity (including diagonals). Crucial for triggering color changes.
  - type: Fixed Role Mapping
    definition: A predefined set of rules linking the identified Trigger color to the specific colors acting as Changing and Non-changing Actors.
actions:
  - step: 1. Identify Colors
    inputs: input_grid
    outputs: background_color, non_background_colors (set of 3)
  - step: 2. Identify Trigger Color
    inputs: input_grid, non_background_colors
    criteria: Find the color in non_background_colors that has at least one pixel with no neighbors (8-way) of the same color.
    outputs: trigger_color
  - step: 3. Determine Actor Roles
    inputs: trigger_color, non_background_colors
    logic: Apply fixed mapping ((0->(2,1)), (4->(7,6)), (6->(1,2))) to determine changing_actor_color and non_changing_actor_color from the remaining two colors.
    outputs: changing_actor_color, non_changing_actor_color
  - step: 4. Apply Transformations
    inputs: input_grid, trigger_color, changing_actor_color, non_changing_actor_color
    process: Iterate through each pixel (r, c) of the input grid. Check neighbors in the input grid. Determine output color based on the rules applied to the input state.
    outputs: output_grid
```


**Natural Language Program:**

1.  **Analyze Input Colors:** Determine the background color (most frequent) and the three other distinct colors present (let's call them Color A, Color B, Color C).
2.  **Find the Trigger:** Identify which of the three colors (A, B, or C) acts as the "trigger". The trigger color is the one that has at least one pixel instance in the grid that is completely isolated from other pixels of the same color (i.e., it has no neighbors, including diagonals, of its own color).
3.  **Assign Actor Roles:** Based on the identified trigger color, determine which of the other two colors is the "changing actor" and which is the "non-changing actor" using these fixed rules:
    *   If trigger is white (0): changing actor is red (2), non-changing actor is blue (1).
    *   If trigger is yellow (4): changing actor is orange (7), non-changing actor is magenta (6).
    *   If trigger is magenta (6): changing actor is blue (1), non-changing actor is red (2).
4.  **Generate Output:** Create a new grid of the same size as the input. Iterate through every pixel position of the *input* grid:
    *   Let the color of the current pixel in the input be `input_color`.
    *   Check the colors of the 8 neighbors of this pixel in the *input* grid.
    *   Determine the color for the corresponding pixel in the *output* grid as follows:
        *   If `input_color` is the trigger color AND
```python
import numpy as np
from collections import Counter

def transform(input_grid):
    """
    Changes pixel colors based on adjacency rules involving three non-background 
    colors assigned roles (trigger, changing actor, non-changing actor). 
    The trigger changes to gray(5) if near an actor. The changing actor 
    changes to green(3) if near the trigger. Roles are determined by 
    identifying the trigger color (the one with isolated pixels) and 
    applying a fixed mapping.

    1. Analyze Input Colors: Determine background and three non-background colors.
    2. Find the Trigger: Identify the non-background color with isolated pixels.
    3. Assign Actor Roles: Map trigger color to changing/non-changing actors.
    4. Generate Output: Create output grid applying rules based on input grid state.
       - Trigger -> Gray(5) if adjacent (8-way) to any Actor.
       - Changing Actor -> Green(3) if adjacent (8-way) to Trigger.
       - Other colors remain unchanged.
    """

    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array)
    height, width = input_array.shape

    # 1. Analyze Input Colors
    all_colors, counts = np.unique(input_array, return_counts=True)
    background_color = all_colors[np.argmax(counts)]
    non_background_colors = [c for c in all_colors if c != background_color]

    if len(non_background_colors) != 3:
        # Handle edge cases or unexpected inputs if necessary
        # For this specific task, we expect exactly 3 non-background colors
        print(f"Warning: Expected 3 non-background colors, found {len(non_background_colors)}")
        return output_array.tolist() # Return copy if colors don't match expectation

    color_a, color_b, color_c = non_background_colors

    # Helper to get 8 neighbors
    def get_neighbors(grid, r, c):
        neighbors = []
        h, w = grid.shape
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w:
                    neighbors.append(grid[nr, nc])
        return neighbors

    # 2. Find the Trigger Color
    trigger_color = -1 # Initialize with invalid value
    for potential_trigger in non_background_colors:
        is_this_the_trigger = False
        for r in range(height):
            for c in range(width):
                if input_array[r, c] == potential_trigger:
                    neighbors = get_neighbors(input_array, r, c)
                    # Check if NO neighbor has the same color
                    if potential_trigger not in neighbors:
                        is_this_the_trigger = True
                        break # Found an isolated pixel for this color
            if is_this_the_trigger:
                break # Found an isolated pixel, no need to check other pixels for this color
        if is_this_the_trigger:
            trigger_color = potential_trigger
            break # Found the trigger color

    if trigger_color == -1:
         # Fallback or error handling if no trigger identified (should not happen based on examples)
         print("Warning: Could not identify trigger color.")
         return output_array.tolist()


    # 3. Assign Actor Roles based on the fixed mapping
    changing_actor_color = -1
    non_changing_actor_color = -1
    remaining_colors = [c for c in non_background_colors if c != trigger_color]

    if trigger_color == 0: # white trigger
        # changing=red(2), non-changing=blue(1)
        changing_actor_color = 2
        non_changing_actor_color = 1
    elif trigger_color == 4: # yellow trigger
        # changing=orange(7), non-changing=magenta(6)
        changing_actor_color = 7
        non_changing_actor_color = 6
    elif trigger_color == 6: # magenta trigger
        # changing=blue(1), non-changing=red(2)
        changing_actor_color = 1
        non_changing_actor_color = 2
    else:
        # Error case: unexpected trigger color
        print(f"Warning: Unexpected trigger color identified: {trigger_color}")
        return output_array.tolist()
        
    # Verify that the determined actors match the remaining colors
    if not ({changing_actor_color, non_changing_actor_color} == set(remaining_colors)):
         print(f"Warning: Actor role assignment mismatch. Trigger: {trigger_color}, Remaining: {remaining_colors}, Assigned: ({changing_actor_color}, {non_changing_actor_color})")
         # This might indicate an issue with the fixed mapping assumption or color identification
         # Depending on strictness, could return original grid or attempt correction
         return output_array.tolist()

    actor_colors = {changing_actor_color, non_changing_actor_color}

    # 4. Generate Output Grid by applying transformation rules based on INPUT grid state
    for r in range(height):
        for c in range(width):
            input_color = input_array[r, c]
            neighbors = get_neighbors(input_array, r, c)

            # Rule 1: Trigger color transformation
            if input_color == trigger_color:
                # Check if any neighbor is an actor color
                if any(n in actor_colors for n in neighbors):
                    output_array[r, c] = 5 # Change to gray

            # Rule 2: Changing Actor color transformation
            elif input_color == changing_actor_color:
                # Check if any neighbor is the trigger color
                if trigger_color in neighbors:
                    output_array[r, c] = 3 # Change to green

            # Rule 3: Non-changing actor and background colors remain the same
            # (already handled by copying input to output initially)

    return output_array.tolist()
```
