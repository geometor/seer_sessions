
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 3 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 1 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 1 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 4 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 4 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 9 2 4
4 2 9 4 9 4 9 4 9 9 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down the task based on the provided examples.

**Perception of Elements:**

1.  **Input/Output Structure:** Both inputs and outputs are grids of colored pixels. The overall dimensions of the grid remain unchanged between input and output.
2.  **Borders:** The grids feature distinct border structures. In `train_1`, there's an outer green border (3) and an inner red border (2). In `train_2`, there's an outer yellow border (4) and an inner red border (2). These borders seem static and are preserved in the output. `train_2` appears to contain multiple independent sub-problems, each framed by these borders.
3.  **Patterned Areas:** Inside the inner borders, there are rows containing sequences of pixels that form patterns. These patterns consist primarily of two alternating colors.
4.  **Pattern Disruptions:** The core transformation seems to involve locating and correcting disruptions in these alternating patterns. Specifically, sequences where the same color repeats two (`X X`) or three (`X X X`) times in a row.
5.  **Correction Logic:** When a repetition (`X X` or `X X X`) is found, it's replaced by a sequence that restores the local alternation, using the *two* specific colors designated for that patterned area. If the two alternating colors are `C1` and `C2`, and a sequence of `X X` or `X X X` is found (where `X` is either `C1` or `C2`), let `Y` be the *other* color (`Y` is `C2` if `X` is `C1`, and `Y` is `C1` if `X` is `C2`). The sequence `X X` is replaced by `Y X`, and the sequence `X X X` is replaced by `Y X Y`.
6.  **Scope:** The correction seems to happen independently within each row segment bounded by the inner border color.

**Facts (YAML):**


```python
import numpy as np
from collections import Counter
import copy

"""
The transformation rule involves identifying horizontal sequences of pixels within inner borders and correcting disruptions in alternating two-color patterns.

1.  **Identify Borders:** Determine the outer and inner border colors. The inner border color defines the regions of interest.
2.  **Iterate Rows:** Process each row independently.
3.  **Find Pattern Segments:** Within a row, locate the contiguous sequence of pixels between the first and last occurrence of the inner border color.
4.  **Determine Alternating Colors:** Within this segment, identify the two most frequent colors (excluding the inner border color). These are the expected alternating colors (C1, C2).
5.  **Scan and Correct:** Iterate through the segment:
    *   If three consecutive pixels have the same color `X` (`X X X`), change the first and third `X` to the other alternating color `Y`.
    *   If two consecutive pixels have the same color `X` (`X X`), change the first `X` to the other alternating color `Y`.
6.  **Output:** The output grid is the input grid with the corrected segments.
"""

def find_border_colors(grid):
    """Identifies the outer and inner border colors."""
    outer_border_color = grid[0, 0]
    inner_border_color = -1
    # Scan inward from the top-left corner until a different color is found
    # This assumes borders are at least 1 pixel thick
    if grid.shape[0] > 1 and grid.shape[1] > 1:
       inner_border_color = grid[1, 1]
       if inner_border_color == outer_border_color: # Handle cases where inner border might not be at (1,1)
           # More robust search might be needed if borders aren't simple frames
           # For now, assume the second layer inwards reveals the inner border
            rows, cols = grid.shape
            for r in range(1, rows -1):
                for c in range(1, cols -1):
                    if grid[r,c] != outer_border_color:
                        inner_border_color = grid[r,c]
                        # Check if neighbors match inner_border_color to confirm it's part of a border
                        is_border = True
                        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                             nr, nc = r + dr, c + dc
                             if 0 <= nr < rows and 0 <= nc < cols:
                                 if grid[nr, nc] != inner_border_color and grid[nr, nc] != outer_border_color:
                                      is_border = False
                                      break
                        if is_border:
                             return outer_border_color, inner_border_color
            # Fallback if no clear inner border found in this simple way
            return outer_border_color, -1 # Or handle error
    return outer_border_color, inner_border_color


def get_alternating_colors(segment, inner_border_color):
    """Finds the two most frequent colors in a segment, excluding the border color."""
    counts = Counter(segment)
    if inner_border_color in counts:
        del counts[inner_border_color]
    
    most_common = counts.most_common(2)
    if len(most_common) == 2:
        return most_common[0][0], most_common[1][0]
    elif len(most_common) == 1:
        # Handle cases with only one non-border color? Or assume always two.
        # Based on examples, seems like there are always two intended colors.
        # If the disruption involves only one color type (e.g., X X X), we still need the 'other' color.
        # This case needs careful handling if it occurs. For now, assume two distinct colors exist besides border.
         return most_common[0][0], -1 # Indicate error or missing second color
    else:
         return -1, -1 # No non-border colors found


def transform(input_grid):
    """
    Applies the pattern correction logic to the input grid.
    """
    output_grid = np.copy(input_grid)
    rows, cols = output_grid.shape
    
    # Find border colors (assuming consistent borders across the grid)
    # We only really need the inner border color for processing segments.
    _, inner_border_color = find_border_colors(output_grid)

    if inner_border_color == -1:
         # Handle cases where no clear inner border is found
         # Maybe the pattern applies to the whole grid or different logic is needed
         print("Warning: Could not reliably determine inner border color.")
         # As a fallback maybe process rows without border constraints if no inner border found?
         # For now, we'll assume the examples imply an inner border exists.
         # return output_grid # Or apply a default logic

    # Iterate through each row
    for r in range(rows):
        row = output_grid[r, :]
        
        # Find indices of the inner border color in this row
        border_indices = np.where(row == inner_border_color)[0]
        
        # Skip rows that don't seem to contain a bordered segment
        if len(border_indices) < 2:
            continue
            
        # Define the segment start and end (exclusive of the borders themselves)
        start_col = border_indices[0] + 1
        end_col = border_indices[-1] 
        
        # Ensure the segment is valid
        if start_col >= end_col:
            continue

        segment = row[start_col:end_col]
        
        # Determine the two alternating colors for this segment
        color1, color2 = get_alternating_colors(segment, inner_border_color)

        if color1 == -1 or color2 == -1:
             # Skip row if we couldn't determine the two alternating colors
             # print(f"Warning: Could not determine alternating colors for row {r}, segment {segment}")
             continue
             
        # Create a mutable list copy of the segment for modifications
        mutable_segment = list(segment)
        
        # Scan the segment for pattern disruptions
        # We iterate up to len-2 for XXX checks and len-1 for XX checks
        i = 0
        while i < len(mutable_segment):
            # Check for XXX pattern
            if i + 2 < len(mutable_segment) and \
               mutable_segment[i] == mutable_segment[i+1] == mutable_segment[i+2] and \
               mutable_segment[i] != inner_border_color:
                
                current_color = mutable_segment[i]
                other_color = color2 if current_color == color1 else color1
                
                mutable_segment[i] = other_color
                # mutable_segment[i+1] remains current_color
                mutable_segment[i+2] = other_color
                i += 3 # Skip past the corrected triple
            
            # Check for XX pattern (only if XXX didn't match at this position)
            elif i + 1 < len(mutable_segment) and \
                 mutable_segment[i] == mutable_segment[i+1] and \
                 mutable_segment[i] != inner_border_color:
                 
                current_color = mutable_segment[i]
                other_color = color2 if current_color == color1 else color1
                
                mutable_segment[i] = other_color
                # mutable_segment[i+1] remains current_color
                i += 2 # Skip past the corrected double
            
            else:
                i += 1 # Move to the next pixel if no pattern found

        # Place the corrected segment back into the output grid row
        output_grid[r, start_col:end_col] = mutable_segment

    return output_grid
```
