{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on color-specific propagation rules over a checkerboard background.\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Identify background pixels (blue=1, white=0) from the original input grid.\n3.  Repeatedly iterate through the grid until no pixels can propagate further in a full pass:\n    a.  Create a temporary grid for the next state based on the current state.\n    b.  For each pixel in the current grid:\n        i.  If the pixel is Red (2):\n            - Try to propagate Red to the cell directly below (r+1, c).\n            - If the target cell is within bounds, was originally background, and is currently background in the next state grid, change it to Red in the next state grid.\n            - If propagation straight down fails, try propagating Red to the cell down-left (r+1, c-1) under the same conditions.\n        ii. If the pixel is Yellow (4):\n            - Try to propagate Yellow to the cell directly below (r+1, c).\n            - If the target cell is within bounds, was originally background, and is currently background in the next state grid, change it to Yellow in the next state grid.\n            - If propagation straight down fails, try propagating Yellow to the cell down-right (r+1, c+1) under the same conditions.\n        iii. If the pixel is Azure (8):\n            - Try to propagate Azure to the cell down-left (r+1, c-1). If the target cell is within bounds, was originally background, and is currently background in the next state grid, change it to Azure in the next state grid.\n            - Try to propagate Azure to the cell down-right (r+1, c+1). If the target cell is within bounds, was originally background, and is currently background in the next state grid, change it to Azure in the next state grid. (These are independent attempts).\n    c.  Update the main grid with the next state.\n    d.  If no changes were made in this pass, terminate the iteration.\n4.  Return the final grid state. Green (3) pixels are static and act as blockers but are never overwritten.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color propagation rules to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = input_np.copy()\n    height, width = input_np.shape\n    background_colors = {0, 1} # white, blue\n\n    while True:\n        changed = False\n        # Create a grid for the next state based on the current state.\n        # This prevents changes within one iteration from immediately causing further changes in the same iteration.\n        next_output_grid = output_grid.copy()\n\n        # Iterate row by row, from top to bottom\n        for r in range(height - 1): # No need to check the last row as propagation is downwards\n            for c in range(width):\n                current_color = output_grid[r, c]\n\n                # --- Helper function to check propagation validity ---\n                def is_valid_target(nr, nc):\n                    # Check bounds\n                    if not (0 <= nr < height and 0 <= nc < width):\n                        return False\n                    # Check if the target was originally background\n                    if input_np[nr, nc] not in background_colors:\n                        return False\n                     # Check if the target in the *next* state is currently background (not yet filled in this iteration)\n                    if next_output_grid[nr, nc] not in background_colors:\n                         return False\n                    return True\n\n                # --- Propagation Logic ---\n                if current_color == 2: # Red\n                    # Try down\n                    target_r, target_c = r + 1, c\n                    propagated_down = False\n                    if is_valid_target(target_r, target_c):\n                        if next_output_grid[target_r, target_c] != 2: # Avoid redundant changes\n                           next_output_grid[target_r, target_c] = 2\n                           changed = True\n                           propagated_down = True\n                    # If down failed, try down-left\n                    if not propagated_down:\n                        target_r, target_c = r + 1, c - 1\n                        if is_valid_target(target_r, target_c):\n                           if next_output_grid[target_r, target_c] != 2:\n                                next_output_grid[target_r, target_c] = 2\n                                changed = True\n\n                elif current_color == 4: # Yellow\n                    # Try down\n                    target_r, target_c = r + 1, c\n                    propagated_down = False\n                    if is_valid_target(target_r, target_c):\n                       if next_output_grid[target_r, target_c] != 4:\n                           next_output_grid[target_r, target_c] = 4\n                           changed = True\n                           propagated_down = True\n                    # If down failed, try down-right\n                    if not propagated_down:\n                        target_r, target_c = r + 1, c + 1\n                        if is_valid_target(target_r, target_c):\n                            if next_output_grid[target_r, target_c] != 4:\n                                next_output_grid[target_r, target_c] = 4\n                                changed = True\n\n                elif current_color == 8: # Azure\n                    # Try down-left (independent)\n                    target_r_left, target_c_left = r + 1, c - 1\n                    if is_valid_target(target_r_left, target_c_left):\n                        if next_output_grid[target_r_left, target_c_left] != 8:\n                            next_output_grid[target_r_left, target_c_left] = 8\n                            changed = True\n                    # Try down-right (independent)\n                    target_r_right, target_c_right = r + 1, c + 1\n                    if is_valid_target(target_r_right, target_c_right):\n                        if next_output_grid[target_r_right, target_c_right] != 8:\n                            next_output_grid[target_r_right, target_c_right] = 8\n                            changed = True\n\n        # Update the main grid for the next iteration\n        output_grid = next_output_grid\n\n        # If no changes occurred in this full pass, the simulation is stable\n        if not changed:\n            break\n\n    # Return the final state as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6580,
    "candidates_token_count": 1566,
    "total_token_count": 8146,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.538224,
  "retries": 1
}