{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid by iteratively propagating specific colors (Red=2, Yellow=4, Azure=8) downwards onto background cells (White=0, Blue=1), following specific movement rules and respecting obstacles (Green=3).\n\nThe propagation follows these rules:\n1.  The process iterates until no changes occur in a full pass over the grid (stable state).\n2.  Propagation only occurs into cells that meet ALL the following conditions:\n    a) Within grid boundaries.\n    b) Were originally background (White=0 or Blue=1) in the input grid.\n    c) Are currently background (White=0 or Blue=1) in the grid state being updated for the current iteration.\n3.  Green (3) pixels are static obstacles; they block propagation and are never overwritten.\n4.  Red (2) pixels at (r, c) attempt to propagate straight down to (r+1, c). If this target cell is invalid (doesn't meet conditions in rule 2), they attempt to propagate down-left to (r+1, c-1).\n5.  Yellow (4) pixels at (r, c) attempt to propagate straight down to (r+1, c). If this target cell is invalid, they attempt to propagate down-right to (r+1, c+1).\n6.  Azure (8) pixels at (r, c) attempt to propagate *both* down-left (r+1, c-1) and down-right (r+1, c+1) independently in each step. Each potential target is checked against the validity conditions (rule 2).\n7.  Changes calculated within one iteration step are based on the grid state at the *start* of that step. All valid propagations for the step are determined first, and then applied simultaneously to create the grid state for the next iteration.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the iterative color propagation rules to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the initial grid state.\n\n    Returns:\n        A list of lists representing the final grid state after propagation stops.\n    \"\"\"\n    # Convert to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    # output_grid holds the state at the beginning of each iteration\n    output_grid = input_np.copy()\n    height, width = input_np.shape\n\n    # Define background colors\n    background_colors = {0, 1} # white, blue\n\n    # Loop until no more changes occur in a full iteration (stable state)\n    while True:\n        # next_output_grid holds the changes calculated during the current iteration\n        next_output_grid = output_grid.copy()\n        # Flag to track if any change happened in this iteration\n        changed_in_iteration = False\n\n        # --- Helper function to check if a cell is a valid target for propagation in this iteration ---\n        def is_valid_propagation_target(nr, nc):\n            \"\"\"Checks bounds, original background status, and current background status.\"\"\"\n            # 1. Check bounds\n            if not (0 <= nr < height and 0 <= nc < width):\n                return False\n            # 2. Check if the target was originally background in the input grid\n            if input_np[nr, nc] not in background_colors:\n                return False\n            # 3. Check if the target in the *next* state grid is currently background\n            #    (meaning it hasn't been claimed by another propagation earlier in this *same* iteration scan)\n            if next_output_grid[nr, nc] not in background_colors:\n                return False\n            return True\n\n        # Iterate row by row, from top to bottom.\n        # Pixels in row 'r' can potentially propagate into row 'r+1'.\n        for r in range(height - 1): # The last row cannot propagate downwards\n            for c in range(width):\n                # Get the color from the grid state at the *start* of this iteration\n                current_color = output_grid[r, c]\n\n                # --- Apply Propagation Logic based on color ---\n                if current_color == 2: # Red: Try down, if invalid, try down-left\n                    target_r_down, target_c_down = r + 1, c\n                    can_propagate_down = is_valid_propagation_target(target_r_down, target_c_down)\n\n                    if can_propagate_down:\n                        # Propagate down if valid\n                        next_output_grid[target_r_down, target_c_down] = 2\n                        changed_in_iteration = True\n                    else:\n                        # Down target was invalid, try down-left\n                        target_r_dl, target_c_dl = r + 1, c - 1\n                        if is_valid_propagation_target(target_r_dl, target_c_dl):\n                            next_output_grid[target_r_dl, target_c_dl] = 2\n                            changed_in_iteration = True\n\n                elif current_color == 4: # Yellow: Try down, if invalid, try down-right\n                    target_r_down, target_c_down = r + 1, c\n                    can_propagate_down = is_valid_propagation_target(target_r_down, target_c_down)\n\n                    if can_propagate_down:\n                        # Propagate down if valid\n                        next_output_grid[target_r_down, target_c_down] = 4\n                        changed_in_iteration = True\n                    else:\n                        # Down target was invalid, try down-right\n                        target_r_dr, target_c_dr = r + 1, c + 1\n                        if is_valid_propagation_target(target_r_dr, target_c_dr):\n                           next_output_grid[target_r_dr, target_c_dr] = 4\n                           changed_in_iteration = True\n\n                elif current_color == 8: # Azure: Try down-left AND down-right independently\n                    # Try down-left\n                    target_r_dl, target_c_dl = r + 1, c - 1\n                    if is_valid_propagation_target(target_r_dl, target_c_dl):\n                        next_output_grid[target_r_dl, target_c_dl] = 8\n                        changed_in_iteration = True\n\n                    # Try down-right\n                    target_r_dr, target_c_dr = r + 1, c + 1\n                    if is_valid_propagation_target(target_r_dr, target_c_dr):\n                        next_output_grid[target_r_dr, target_c_dr] = 8\n                        changed_in_iteration = True\n\n        # --- End of Iteration ---\n        # Check if the grid state has stabilized (no changes in this iteration)\n        # Using np.array_equal is robust for comparing grid states.\n        if np.array_equal(output_grid, next_output_grid):\n            break # Exit the loop if no changes occurred\n\n        # Update the grid state for the next iteration\n        output_grid = next_output_grid\n\n        # Alternative check using the flag (less robust if a cell is changed back and forth)\n        # if not changed_in_iteration:\n        #    break\n\n    # Return the final stable grid state as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20581,
    "candidates_token_count": 1712,
    "total_token_count": 22293,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.931245,
  "retries": 1
}