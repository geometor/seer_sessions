{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms an input grid by performing a flood fill operation on a specific subgrid.\n\n1.  Extracts a subgrid (canvas) from the input grid, specifically rows 6 onwards \n    and columns 1 onwards. This canvas corresponds to the output grid dimensions.\n2.  Identifies the 'background color' within this canvas, defined as the most \n    frequent color excluding Azure (8).\n3.  Locates all initial 'seed' pixels within the canvas, which are pixels with \n    the Azure color (8).\n4.  Performs a 4-directional flood fill (Breadth-First Search) starting from the \n    seed pixels.\n5.  The fill operation changes pixels matching the identified background color to \n    Azure (8).\n6.  The fill stops at the canvas boundaries or when encountering pixels that do \n    not match the background color (acting as barriers).\n7.  If no background color is found (e.g., the canvas only contains Azure pixels \n    or is empty after exclusion) or if there are no seed pixels, the canvas is \n    returned unmodified.\n8.  The final state of the canvas after the flood fill is the output.\n\"\"\"\n\n# === Helper Functions ===\n\ndef _get_subgrid(grid, start_row, start_col):\n    \"\"\"\n    Extracts a subgrid from the specified starting row/col to the end.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_row (int): The starting row index (inclusive).\n        start_col (int): The starting column index (inclusive).\n\n    Returns:\n        np.ndarray: A copy of the extracted subgrid. Returns an empty grid if\n                    start indices are out of bounds.\n    \"\"\"\n    rows, cols = grid.shape\n    if start_row >= rows or start_col >= cols or start_row < 0 or start_col < 0:\n        # Return an empty array of appropriate type if start is out of bounds\n        # Using shape (0, cols-start_col) or similar might be more precise, \n        # but an empty 0x0 or 0xN is sufficient to indicate no valid subgrid.\n        return np.array([[]], dtype=grid.dtype).reshape(0,0) \n        \n    # Ensure slicing doesn't go negative if start indices are large\n    # (Python slicing handles large indices gracefully by returning empty)\n    return grid[start_row:, start_col:].copy()\n\ndef _find_most_frequent_excluding(grid, exclude_value):\n    \"\"\"\n    Finds the most frequent value in a grid, excluding a specific value.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        exclude_value (int): The value to exclude from frequency counting.\n\n    Returns:\n        int or None: The most frequent value, or None if no other value exists \n                     or the grid is effectively empty after exclusion.\n    \"\"\"\n    # Check for empty grid case\n    if grid.size == 0:\n        return None\n        \n    flat_grid = grid.flatten()\n    filtered_values = flat_grid[flat_grid != exclude_value]\n    \n    # If no values remain after filtering, return None\n    if filtered_values.size == 0:\n        return None\n\n    # Count occurrences of each remaining value\n    counts = Counter(filtered_values)\n    \n    # Check if the Counter is empty (shouldn't happen if filtered_values.size > 0, but defensive)\n    if not counts: \n        return None\n        \n    # Find the value with the highest count\n    # counts.most_common(1) returns a list like [ (value, count) ]\n    most_common_value = counts.most_common(1)[0][0] \n    return most_common_value\n\ndef _find_pixels_with_color(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels with a specific color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        np.ndarray: An array of coordinates [(r1, c1), (r2, c2), ...]. \n                    Returns an empty (0, 2) array if no pixels match or grid is empty.\n    \"\"\"\n    # Check for empty grid case\n    if grid.size == 0:\n        return np.array([], dtype=int).reshape(0, 2) # Return empty 2D array\n    return np.argwhere(grid == color)\n\ndef _flood_fill_4_direction(grid, seeds, fill_color, target_color):\n    \"\"\"\n    Performs a 4-directional flood fill in-place on the grid.\n\n    Args:\n        grid (np.ndarray): The grid to modify.\n        seeds (np.ndarray): Array of seed coordinates [(r1, c1), ...].\n        fill_color (int): The color to fill with.\n        target_color (int or None): The color of pixels to be filled. If None,\n                                    no filling occurs.\n\n    Returns:\n        np.ndarray: The modified grid (note: the input grid is modified in-place).\n    \"\"\"\n    # Check for conditions where no fill should occur\n    if target_color is None or seeds.size == 0 or grid.size == 0:\n        return grid \n        \n    rows, cols = grid.shape\n    \n    # Visited array is crucial to prevent infinite loops and re-processing\n    visited = np.zeros_like(grid, dtype=bool)\n    \n    # Use deque for efficient BFS queue operations\n    queue = deque() \n\n    # Initialize queue and visited array ONLY with valid seed pixels\n    for r, c in seeds:\n        # Check bounds for robustness, though seeds should be within canvas\n        if 0 <= r < rows and 0 <= c < cols:\n           # Check if the seed pixel itself hasn't been visited\n           # (useful if seeds overlap or BFS starts immediately)\n           if not visited[r, c]:\n               # Mark the seed as visited\n               visited[r, c] = True\n               # Add the seed to the queue to start the BFS\n               queue.append((r, c))\n               # Note: We assume seeds already have the 'fill_color' and don't need changing.\n               # If seeds could potentially have the 'target_color', they should be changed here.\n               # Based on the problem, seeds are defined as already being 'fill_color' (Azure).\n\n    # Perform Breadth-First Search (BFS)\n    while queue:\n        r, c = queue.popleft()\n\n        # Define the four cardinal neighbors (relative offsets)\n        # neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)] # Direct calculation below\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Deltas for neighbors\n            nr, nc = r + dr, c + dc\n\n            # Check 1: Is the neighbor within the grid boundaries?\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check 2: Does the neighbor have the target (background) color?\n                # Check 3: Has the neighbor NOT been visited yet?\n                if grid[nr, nc] == target_color and not visited[nr, nc]:\n                    # All checks pass:\n                    # - Mark as visited *before* changing color/adding to queue\n                    visited[nr, nc] = True \n                    # - Change the neighbor's color to the fill color\n                    grid[nr, nc] = fill_color\n                    # - Add the neighbor to the queue for further expansion\n                    queue.append((nr, nc))\n                    \n    return grid # Return the modified grid\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the flood fill transformation based on the described rules:\n    Extracts a subgrid, finds the most frequent non-azure color as background,\n    locates azure seeds, and flood-fills the background from the seeds.\n    \n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid (the modified subgrid).\n    \"\"\"\n    # Define constants based on problem description/observation\n    HEADER_ROWS = 6 # Number of rows to skip at the top\n    START_COL = 1   # Starting column index for the subgrid (0-based)\n    SEED_COLOR = 8  # Azure - the color that initiates the fill and is the fill color\n    # FILL_COLOR = 8 # Azure - implicit, same as SEED_COLOR\n\n    # 1. Extract the canvas (working area) from the input\n    #    Handles potential empty input grid via helper function.\n    canvas = _get_subgrid(input_grid, HEADER_ROWS, START_COL)\n\n    # If the extracted canvas is empty, return it immediately\n    if canvas.size == 0:\n        # Consider what an empty output should look like. \n        # Returning the empty canvas seems appropriate.\n        return canvas \n\n    # 2. Identify the background color to be filled (target color)\n    #    Exclude the seed color itself from being the background.\n    background_color = _find_most_frequent_excluding(canvas, SEED_COLOR)\n\n    # 3. Find initial seed pixels (pixels that already have the seed color)\n    #    These are the starting points for the flood fill.\n    seed_coords = _find_pixels_with_color(canvas, SEED_COLOR)\n\n    # 4. Perform flood fill\n    #    - The function modifies 'canvas' in-place.\n    #    - It fills pixels matching 'background_color' starting from 'seed_coords'.\n    #    - Handles cases where background_color is None or no seeds are found internally.\n    output_grid = _flood_fill_4_direction(canvas, seed_coords, SEED_COLOR, background_color)\n\n    # 5. Return the modified canvas as the final output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25442,
    "candidates_token_count": 2359,
    "total_token_count": 27801,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.030929,
  "retries": 1
}