{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms an input grid by performing a flood fill operation on a specific subgrid.\n\n1.  Extracts a subgrid (canvas) from the input grid, specifically rows 6 onwards \n    and columns 1 onwards. This canvas corresponds to the output grid dimensions.\n2.  Identifies the 'background color' within this canvas, defined as the most \n    frequent color excluding Azure (8).\n3.  Locates all initial 'seed' pixels within the canvas, which are pixels with \n    the Azure color (8).\n4.  Performs a 4-directional flood fill (Breadth-First Search) starting from the \n    seed pixels.\n5.  The fill operation changes pixels matching the identified background color to \n    Azure (8).\n6.  The fill stops at the canvas boundaries or when encountering pixels that do \n    not match the background color (acting as barriers).\n7.  If no background color is found (e.g., the canvas only contains Azure pixels \n    or is empty after exclusion) or if there are no seed pixels, the canvas is \n    returned unmodified.\n8.  The final state of the canvas after the flood fill is the output.\n\"\"\"\n\n# === Helper Functions ===\n\ndef _get_subgrid(grid, start_row, start_col):\n    \"\"\"\n    Extracts a subgrid from the specified starting row/col to the end.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_row (int): The starting row index (inclusive).\n        start_col (int): The starting column index (inclusive).\n\n    Returns:\n        np.ndarray: A copy of the extracted subgrid.\n    \"\"\"\n    # Ensure indices are within bounds, though slicing handles this gracefully\n    rows, cols = grid.shape\n    if start_row >= rows or start_col >= cols:\n        # Return an empty array of appropriate type if start is out of bounds\n        return np.array([[]], dtype=grid.dtype) \n    return grid[start_row:, start_col:].copy()\n\ndef _find_most_frequent_excluding(grid, exclude_value):\n    \"\"\"\n    Finds the most frequent value in a grid, excluding a specific value.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        exclude_value (int): The value to exclude from frequency counting.\n\n    Returns:\n        int or None: The most frequent value, or None if no other value exists \n                     or the grid is effectively empty after exclusion.\n    \"\"\"\n    # Check for empty grid case\n    if grid.size == 0:\n        return None\n        \n    flat_grid = grid.flatten()\n    filtered_values = flat_grid[flat_grid != exclude_value]\n    \n    # If no values remain after filtering, return None\n    if filtered_values.size == 0:\n        return None\n\n    # Count occurrences of each remaining value\n    counts = Counter(filtered_values)\n    \n    # Check if the Counter is empty (shouldn't happen if filtered_values.size > 0)\n    if not counts: \n        return None\n        \n    # Find the value with the highest count\n    # counts.most_common(1) returns a list like [ (value, count) ]\n    most_common_value = counts.most_common(1)[0][0] \n    return most_common_value\n\ndef _find_pixels_with_color(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels with a specific color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        np.ndarray: An array of coordinates [(r1, c1), (r2, c2), ...]. \n                    Returns an empty array if no pixels match.\n    \"\"\"\n    # Check for empty grid case\n    if grid.size == 0:\n        return np.array([], dtype=int).reshape(0, 2) # Return empty 2D array\n    return np.argwhere(grid == color)\n\ndef _flood_fill_4_direction(grid, seeds, fill_color, target_color):\n    \"\"\"\n    Performs a 4-directional flood fill in-place on the grid.\n\n    Args:\n        grid (np.ndarray): The grid to modify.\n        seeds (np.ndarray): Array of seed coordinates [(r1, c1), ...].\n        fill_color (int): The color to fill with.\n        target_color (int or None): The color of pixels to be filled. If None,\n                                    no filling occurs.\n\n    Returns:\n        np.ndarray: The modified grid (note: the input grid is modified in-place).\n    \"\"\"\n    # Check for conditions where no fill should occur\n    if target_color is None or seeds.size == 0 or grid.size == 0:\n        return grid \n        \n    rows, cols = grid.shape\n    queue = deque(seeds.tolist())\n    # Visited array is crucial to prevent infinite loops and re-processing\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Mark initial seeds as visited *only if they are within bounds*\n    # The seeds are found within the grid, so they should be in bounds,\n    # but this adds robustness.\n    initial_queue = deque()\n    for r, c in seeds:\n        if 0 <= r < rows and 0 <= c < cols:\n           # Only mark/add seeds that haven't somehow already been visited\n           # (shouldn't happen with a fresh visited array, but safe)\n           if not visited[r, c]:\n               visited[r, c] = True\n               initial_queue.append((r, c))\n               # We assume seeds already have the fill_color and don't need changing.\n    \n    queue = initial_queue # Use the validated initial queue\n\n    # Perform Breadth-First Search (BFS)\n    while queue:\n        r, c = queue.popleft()\n\n        # Define the four cardinal neighbors\n        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]\n\n        for nr, nc in neighbors:\n            # Check 1: Is the neighbor within the grid boundaries?\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check 2: Does the neighbor have the target color?\n                # Check 3: Has the neighbor NOT been visited yet?\n                if grid[nr, nc] == target_color and not visited[nr, nc]:\n                    # All checks pass:\n                    # - Change the neighbor's color to the fill color\n                    grid[nr, nc] = fill_color\n                    # - Mark as visited\n                    visited[nr, nc] = True\n                    # - Add the neighbor to the queue for further expansion\n                    queue.append((nr, nc))\n                    \n    return grid\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the flood fill transformation based on the described rules:\n    Extracts a subgrid, finds the most frequent non-azure color as background,\n    locates azure seeds, and flood-fills the background from the seeds.\n    \n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid (the modified subgrid).\n    \"\"\"\n    # Define constants based on problem description/observation\n    HEADER_ROWS = 6 # Number of rows to skip at the top\n    START_COL = 1   # Starting column index for the subgrid (0-based)\n    SEED_COLOR = 8  # Azure - the color that initiates the fill\n    FILL_COLOR = 8  # Azure - the color used to fill\n\n    # 1. Extract the canvas (working area) from the input\n    #    Handles potential empty input grid via helper function.\n    canvas = _get_subgrid(input_grid, HEADER_ROWS, START_COL)\n\n    # If the extracted canvas is empty, return it immediately\n    if canvas.size == 0:\n        return canvas\n\n    # 2. Identify the background color to be filled (target color)\n    #    Exclude the seed color itself from being the background.\n    background_color = _find_most_frequent_excluding(canvas, SEED_COLOR)\n\n    # 3. Find initial seed pixels (pixels that already have the fill color)\n    #    These are the starting points for the flood fill.\n    seed_coords = _find_pixels_with_color(canvas, SEED_COLOR)\n\n    # 4. Perform flood fill\n    #    - The function modifies 'canvas' in-place.\n    #    - It fills pixels matching 'background_color' starting from 'seed_coords'.\n    #    - Handles cases where background_color is None or no seeds are found.\n    output_grid = _flood_fill_4_direction(canvas, seed_coords, FILL_COLOR, background_color)\n\n    # 5. Return the modified canvas as the final output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22514,
    "candidates_token_count": 2115,
    "total_token_count": 24629,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.604211,
  "retries": 1
}