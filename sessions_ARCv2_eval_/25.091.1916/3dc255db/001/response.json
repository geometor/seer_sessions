{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies pixels of a specific color (C_enclosed) that are enclosed by pixels of any other non-white color. \nEnclosed means that any path from the pixel to the grid boundary must pass through a non-white pixel that is not C_enclosed.\n\nSteps:\n1. Iterate through each non-white color `C_enclosed` present in the input grid.\n2. For each `C_enclosed`, determine which pixels of this color are enclosed.\n   - Perform a Breadth-First Search (BFS) starting from all boundary cells of the grid.\n   - The BFS can only travel through white pixels (0) or pixels of color `C_enclosed`.\n   - Any pixel of color `C_enclosed` that is *not* reached by this BFS is considered enclosed.\n3. Collect all enclosed pixels for all colors. Store them grouped by their original color.\n4. Create an output grid, initially a copy of the input.\n5. Remove all identified enclosed pixels from the output grid by setting their color to white (0).\n6. For each color `C_enclosed` that had enclosed pixels removed:\n   a. Calculate the frequency of column indices among the removed pixel locations for this color.\n   b. Find the maximum frequency (most pixels removed in a single column).\n   c. Identify the column index (or indices) with this maximum frequency. Select the minimum (leftmost) column index among them (`target_col`).\n   d. Count the number of unique row indices among the removed pixel locations for this color (`N`).\n   e. In the `output_grid`, set the color of the pixels in the `target_col` from row 0 to row `N-1` to `C_enclosed`.\n7. Return the final modified output grid.\n\"\"\"\n\ndef find_enclosed_pixels(grid, color_to_check):\n    \"\"\"\n    Finds pixels of `color_to_check` that are enclosed.\n    Uses BFS starting from the boundary, propagating through white cells and cells of `color_to_check`.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Add boundary cells to the queue if they are white or the color_to_check\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not reachable[r, c] and (grid[r, c] == 0 or grid[r, c] == color_to_check):\n                q.append((r, c))\n                reachable[r, c] = True\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if not reachable[r, c] and (grid[r, c] == 0 or grid[r, c] == color_to_check):\n                q.append((r, c))\n                reachable[r, c] = True\n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is reachable (white or target color) and not visited\n                if not reachable[nr, nc] and (grid[nr, nc] == 0 or grid[nr, nc] == color_to_check):\n                    reachable[nr, nc] = True\n                    q.append((nr, nc))\n\n    # Identify enclosed pixels (target color pixels that were not reached)\n    enclosed_locations = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color_to_check and not reachable[r, c]:\n                enclosed_locations.append((r, c))\n\n    return enclosed_locations\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the enclosure transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    unique_colors = np.unique(input_grid[input_grid != 0]) # Get all non-white colors\n\n    all_removed_pixels_by_color = {}\n\n    # 1. Find all enclosed pixels for each color\n    for color in unique_colors:\n        enclosed_locations = find_enclosed_pixels(input_grid, color)\n        if enclosed_locations:\n            all_removed_pixels_by_color[color] = enclosed_locations\n\n    # 2. Remove enclosed pixels from the output grid\n    for color, locations in all_removed_pixels_by_color.items():\n        for r, c in locations:\n            output_grid[r, c] = 0 # Set to white\n\n    # 3. Add new pixels at the top of the target column for each color\n    for color, removed_locations in all_removed_pixels_by_color.items():\n        if not removed_locations:\n            continue\n\n        # a. Calculate column frequencies\n        columns = [c for r, c in removed_locations]\n        if not columns: continue # Should not happen if removed_locations is not empty, but safety check\n        \n        col_counts = Counter(columns)\n        max_freq = 0\n        for col, count in col_counts.items():\n             if count > max_freq:\n                 max_freq = count\n        \n        # b. Find leftmost column(s) with max frequency\n        candidate_cols = []\n        for col, count in col_counts.items():\n            if count == max_freq:\n                candidate_cols.append(col)\n        \n        target_col = min(candidate_cols)\n\n\n        # c. Count unique rows\n        unique_rows = set(r for r, c in removed_locations)\n        N = len(unique_rows)\n\n        # d. Add pixels to the top of the target column\n        for i in range(min(N, rows)): # Ensure we don't write past grid boundary\n            output_grid[i, target_col] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3880,
    "candidates_token_count": 1451,
    "total_token_count": 5331,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.597227,
  "retries": 1
}