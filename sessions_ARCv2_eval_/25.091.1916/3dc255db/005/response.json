{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify Unreachable Pixels: Find all non-white pixels in the input grid that cannot reach any boundary cell by moving only through adjacent white (0) pixels. This is done via a Breadth-First Search (BFS) starting from boundary white cells.\n2.  Group Unreachable Pixels: Partition the identified unreachable pixels into \"Enclosed Groups\". An Enclosed Group consists of pixels that:\n    a.  All have the same color.\n    b.  Form a single connected component using 4-way adjacency (considering only connections between the identified unreachable pixels of that same color).\n3.  Process Each Group: For every Enclosed Group found:\n    a.  Remove Group Pixels: Change the color of all pixels belonging to the group to white (0) in the output grid.\n    b.  Determine Target Column:\n        i.  Calculate the frequency of each column index among the group's pixel locations.\n        ii. Find the maximum frequency (`max_freq`).\n        iii. Identify all column indices (`candidate_cols`) that achieve `max_freq`.\n        iv. Apply Tie-breaker:\n            - If only one candidate column, select it.\n            - If multiple candidates: Calculate the average column index (centroid) of the group's locations. Select the candidate column closest (minimum absolute difference) to the centroid. If still tied (equidistant), select the leftmost (minimum index) tied column.\n    c.  Determine Indicator Count (`N`): Count the number of unique row indices among the group's pixel locations.\n    d.  Add Indicator Pixels: In the selected target column, change the color of the top `N` pixels (rows 0 to N-1) to the group's color.\n4.  Final Grid: The grid after processing all Enclosed Groups is the final output.\n(Note: This procedure describes the logic derived primarily from examples 2 and 3; example 1 appears to follow a different pattern not captured by this rule.)\n\"\"\"\n\ndef find_unreachable_non_white(grid):\n    \"\"\"\n    Finds all non-white pixels that cannot reach the grid boundary via white cells.\n    Uses BFS starting from the boundary, propagating only through white cells (0).\n    Returns a set of ((r, c), color) tuples for unreachable non-white pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable = np.zeros_like(grid, dtype=bool)\n    q = deque()\n    unreachable_pixels = set() # Using a set for efficient lookup later\n\n    # Initialize BFS queue with boundary white cells\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not reachable[r, c] and grid[r, c] == 0:\n                q.append((r, c))\n                reachable[r, c] = True\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if not reachable[r, c] and grid[r, c] == 0:\n                q.append((r, c))\n                reachable[r, c] = True\n\n    # Perform BFS through white cells\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not reachable[nr, nc] and grid[nr, nc] == 0:\n                reachable[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify non-white pixels that were not reached\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not reachable[r, c]:\n                unreachable_pixels.add(((r, c), grid[r,c]))\n\n    return unreachable_pixels\n\ndef group_pixels(unreachable_pixels, grid_shape):\n    \"\"\"\n    Groups unreachable pixels into connected components based on color and adjacency.\n    Returns a dictionary {color: [group1_locations, group2_locations, ...]}\n    where each group_locations is a list of (r, c) tuples.\n    \"\"\"\n    rows, cols = grid_shape\n    visited = set()\n    groups = {}\n    unreachable_locations = {loc for loc, color in unreachable_pixels} # For quick spatial check\n\n    for pixel_loc, color in unreachable_pixels:\n        if pixel_loc not in visited:\n            current_group = []\n            q = deque([pixel_loc])\n            visited.add(pixel_loc)\n\n            # BFS within unreachable pixels of the same color\n            while q:\n                r, c = q.popleft()\n                current_group.append((r,c))\n\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    neighbor_loc = (nr, nc)\n\n                    # Check bounds, if neighbor is unreachable, same color, and not visited\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       neighbor_loc in unreachable_locations and \\\n                       grid[nr, nc] == color and \\\n                       neighbor_loc not in visited:\n\n                        # Check if this neighbor is part of the original unreachable set\n                        # (This check might be redundant if unreachable_locations is derived correctly)\n                        is_unreachable = False\n                        for loc, clr in unreachable_pixels:\n                           if loc == neighbor_loc and clr == color:\n                               is_unreachable = True\n                               break\n                        \n                        if is_unreachable:\n                            visited.add(neighbor_loc)\n                            q.append(neighbor_loc)\n\n\n            # Store the found group\n            if color not in groups:\n                groups[color] = []\n            groups[color].append(current_group)\n\n    return groups\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the enclosure transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    global grid # Make input_grid accessible to group_pixels for color check\n    grid = input_grid\n\n    # 1. Find all non-white pixels unreachable via white cells\n    unreachable_pixels_with_color = find_unreachable_non_white(input_grid)\n\n    # 2. Group these pixels by color and connectivity\n    enclosed_groups_by_color = group_pixels(unreachable_pixels_with_color, (rows, cols))\n\n    # 3. Process each group\n    for color, groups in enclosed_groups_by_color.items():\n        for group_locations in groups:\n            if not group_locations:\n                continue\n\n            # a. Remove group pixels\n            for r, c in group_locations:\n                output_grid[r, c] = 0\n\n            # b. Determine Target Column\n            columns = [c for r, c in group_locations]\n            if not columns: continue\n            col_counts = Counter(columns)\n            max_freq = max(col_counts.values())\n            candidate_cols = sorted([col for col, count in col_counts.items() if count == max_freq]) # Sort for leftmost tie-break later\n\n            target_col = -1\n            if len(candidate_cols) == 1:\n                target_col = candidate_cols[0]\n            else:\n                # Calculate centroid column\n                avg_col = sum(columns) / len(columns)\n                min_dist = float('inf')\n                best_cols = []\n                for col in candidate_cols:\n                    dist = abs(col - avg_col)\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_cols = [col]\n                    elif dist == min_dist:\n                        best_cols.append(col)\n                target_col = min(best_cols) # Leftmost if equidistant\n\n            # c. Determine Indicator Count (N)\n            unique_rows = set(r for r, c in group_locations)\n            N = len(unique_rows)\n\n            # d. Add Indicator Pixels\n            for i in range(min(N, rows)): # Ensure we don't write past grid boundary\n                output_grid[i, target_col] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13328,
    "candidates_token_count": 1966,
    "total_token_count": 15294,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.283032,
  "retries": 1
}