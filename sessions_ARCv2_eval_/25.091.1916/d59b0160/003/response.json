{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all distinct objects in the input grid. An object is a connected \n   component of pixels (adjacent horizontally, vertically, or diagonally) that \n   are not the background color (orange, 7).\n2. For each identified object:\n   a. Check if it contains at least one white pixel (0).\n   b. Check if it is entirely surrounded *within the grid boundaries* by the \n      background color (orange, 7). This means no pixel of the object can be \n      adjacent (horizontally, vertically, or diagonally) to the grid boundary \n      or to a non-background pixel that is not part of the same object.\n3. If both conditions (contains white AND is surrounded by orange within the grid) \n   are true for an object, replace all pixels belonging to that object with the \n   background color (orange, 7) in the output grid.\n4. Otherwise, the object remains unchanged.\n5. Pixels that are initially the background color also remain unchanged.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int) -> List[Set[Tuple[int, int]]]:\n    \"\"\"\n    Finds all connected objects of non-background pixels in the grid.\n    Connectivity includes diagonals (8-way).\n    Args:\n        grid: The input numpy array representing the grid.\n        background_color: The integer value representing the background color.\n    Returns:\n        A list where each element is a set of (row, col) tuples representing\n        the coordinates of the pixels belonging to a single object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not background and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                current_object = set()\n                q = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    current_object.add((row, col))\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = row + dr, col + dc\n\n                            # Check if neighbor is within grid bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # Check if neighbor is part of the same object (not background)\n                                # and hasn't been visited yet\n                                if grid[nr, nc] != background_color and not visited[nr, nc]:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                \n                # Add the found object to the list\n                if current_object:\n                    objects.append(current_object)\n                    \n    return objects\n\ndef is_surrounded(grid: np.ndarray, obj: Set[Tuple[int, int]], background_color: int) -> bool:\n    \"\"\"\n    Checks if an object is completely surrounded by the background color \n    *within the grid boundaries*.\n    Args:\n        grid: The input numpy array representing the grid.\n        obj: A set of (row, col) tuples representing the object's pixels.\n        background_color: The integer value representing the background color.\n    Returns:\n        True if the object is surrounded, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Iterate through each pixel belonging to the object\n    for r, c in obj:\n        # Check all 8 neighbors of the current object pixel\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n\n                # Condition 1: Check if neighbor is outside the grid boundary\n                if not (0 <= nr < height and 0 <= nc < width):\n                    return False # Object touches the boundary, so it's not surrounded\n\n                # Condition 2: Check if the neighbor is within bounds, \n                # *not* part of the current object, and *not* the background color.\n                if (nr, nc) not in obj and grid[nr, nc] != background_color:\n                    return False # Object touches another non-background pixel (could be another object)\n                    \n    # If we checked all neighbors of all pixels in the object and didn't return False,\n    # it means all adjacent cells outside the object are background color.\n    return True \n\ndef contains_color(grid: np.ndarray, obj: Set[Tuple[int, int]], target_color: int) -> bool:\n    \"\"\"\n    Checks if any pixel within the object has the target color.\n    Args:\n        grid: The input numpy array representing the grid.\n        obj: A set of (row, col) tuples representing the object's pixels.\n        target_color: The integer color value to search for.\n    Returns:\n        True if the target color is found in the object, False otherwise.\n    \"\"\"\n    for r, c in obj:\n        if grid[r, c] == target_color:\n            return True\n    return False\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies objects containing white (0) and surrounded by orange (7) \n    within the grid boundaries, and replaces them entirely with orange (7).\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, leaving the original input unchanged\n    output_grid = grid_np.copy()\n    \n    # Define task-specific constants\n    background_color = 7\n    target_indicator_color = 0\n\n    # Step 1: Find all distinct objects (connected components of non-background pixels)\n    objects = find_objects(grid_np, background_color)\n\n    # Step 2: Iterate through each found object\n    for obj in objects:\n        # Step 2a: Check if the object contains the target indicator color (white, 0)\n        has_target_color = contains_color(grid_np, obj, target_indicator_color)\n        \n        # Step 2b: Check if the object is completely surrounded by the background color (orange, 7)\n        #          within the grid boundaries.\n        is_obj_surrounded = is_surrounded(grid_np, obj, background_color)\n        \n        # Step 3: If both conditions are met, replace the object's pixels \n        #         in the output grid with the background color.\n        if has_target_color and is_obj_surrounded:\n            for r, c in obj:\n                output_grid[r, c] = background_color\n\n    # Convert the final numpy array back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12747,
    "candidates_token_count": 1705,
    "total_token_count": 14452,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.816319,
  "retries": 1
}