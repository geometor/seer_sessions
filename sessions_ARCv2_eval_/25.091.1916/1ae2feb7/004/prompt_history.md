
## train_1

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 6 6 6 8 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
1 1 1 1 0 2 1 0 0 0 1 0 0 0 1 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 6 6 6 8 2 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 3 0 0 0 0 3 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 2 5 0 0 0 5 0 0 0 5 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 1 1 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 4 4 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 1 1 0 2 1 2 1 2 1 2 1 2 1 2
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 4 4 2 4 0 4 3 4 0 4 0 4 3
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 5 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
7 7 7 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 1 0 1 0 1 0 1 0 1 0 1
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 5 2 5 5 5 5 5 5 5 5 5 5 5
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
7 7 7 2 7 0 0 7 0 0 7 0 0 7 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Separator:** Each input grid contains a single vertical line of red pixels (color 2). This line acts as a separator, dividing the grid into a left region and a right region.
2.  **Input Patterns:** To the left of the red line, some rows contain horizontal sequences of non-white pixels. These sequences are the primary input patterns. They vary in color, length, and composition.
3.  **Transformation Trigger:** The presence of a non-white pattern in a row to the left of the red line triggers a transformation in the corresponding row to the right of the red line.
4.  **Output Area:** The region to the right of the red line is initially white (color 0) in the input. In the output, this area is filled with new patterns in the rows corresponding to the input patterns.
5.  **Invariant Regions:** The red vertical line itself, the area to its left, and any rows that were entirely white to the left of the red line remain unchanged in the output.
6.  **Pattern Generation:** The patterns generated in the output area seem derived from the properties (colors, sequence) of the input pattern in the same row. The specific generation rule depends on the colors present in the input pattern, particularly the first and last non-white colors. The generated pattern is tiled or repeated to fill the available space to the right of the red line.

**Facts:**


```yaml
elements:
  - object: separator
    type: vertical_line
    color: red (2)
    location: fixed column per example (e.g., col 5 in ex1/2, col 3 in ex3)
    function: divides grid, triggers transformation

  - object: input_pattern
    type: horizontal_sequence
    location: rows to the left of the separator
    properties:
      - composition: sequence of non-white pixels (can include white pixels within the segment)
      - colors: variable (blue, green, yellow, gray, magenta, azure, orange, red)
      - length: variable segment length up to the separator column
      - first_non_white_color: property derived from the sequence
      - last_non_white_color: property derived from the sequence
      - non_white_sequence: property derived (sequence of non-white colors only)
    existence: optional per row

  - object: output_pattern
    type: horizontal_sequence
    location: rows to the right of the separator
    properties:
      - width: determined by grid_width - separator_column - 1
      - composition: generated based on corresponding input_pattern
      - tiling: often involves repeating a smaller base pattern
    existence: present only if a corresponding input_pattern exists

actions:
  - name: identify_separator
    input: input_grid
    output: column_index_of_red_line

  - name: extract_input_pattern
    input: input_grid_row, separator_column_index
    output: segment_left_of_separator

  - name: analyze_input_pattern
    input: segment_left_of_separator
    output:
      - non_white_sequence (S)
      - first_color (S[0] if S not empty)
      - last_color (S[-1] if S not empty)
      - length_of_non_white_sequence (len(S))

  - name: determine_base_pattern
    input: first_color, last_color, length_of_non_white_sequence
    rules:
      - if last_color is azure (8): base_pattern = [azure (8)]
      - if first_color is red (2) and last_color is blue (1): base_pattern = [blue (1), red (2)]
      - if first_color is green (3) and last_color is yellow (4): base_pattern = [yellow (4), white (0), yellow (4), green (3)]
      - otherwise: base_pattern = [first_color] + [white (0)] * (length_of_non_white_sequence - 1)
    output: base_pattern (P)

  - name: generate_output_pattern
    input: base_pattern (P), output_width (W)
    logic: repeat P to fill width W ( P * (W // len(P)) + P[:(W % len(P))] )
    output: final_output_pattern_for_row

  - name: apply_transformation
    input: input_grid, separator_column_index, row_index, final_output_pattern
    output: modified_output_grid (updates row to the right of separator)

relationships:
  - type: correspondence
    entity1: input_pattern (row r, left)
    entity2: output_pattern (row r, right)
    description: An input pattern in a given row determines the output pattern in the same row.

  - type: dependency
    entity1: output_pattern
    entity2: input_pattern
    description: The structure and colors of the output pattern depend on the first color, last color, and number of non-white colors in the corresponding input pattern sequence.
```


**Natural Language Program:**

1.  **Initialization:** Create a copy of the input grid to serve as the output grid.
2.  **Locate Separator:** Find the column index (`C`) containing the vertical red line (color 2).
3.  **Calculate Output Width:** Determine the width (`W`) of the area to the right of the separator (`W = grid_width - C - 1`).
4.  **Iterate Through Rows:** For each row `r` from top to bottom:
    a.  **Extract Input Segment:** Get the segment of the row to the left of the separator: `Seg = input_grid[r, 0:C]`.
    b.  **Analyze Segment:** Create a sequence `S` containing only the non-white colors from `Seg`.
    c.  **Check for Pattern:** If the sequence `S` is empty (the segment `Seg` was all white), proceed to the next row without modification.
    d.  **Identify Key Colors:** If `S` is not empty, find the first color (`first_color = S[0]`) and the last color (`last_color = S[-1]`). Let `lenS = len(S)`.
    e.  **Determine Base Pattern (P):**
        i.  If `last_color` is azure (8), the base pattern `P` is `[azure (8)]`.
        ii. Else if `first_color` is red (2) and `last_color` is blue (1), the base pattern `P` is `[blue (1), red (2)]`.
        iii. Else if `first_color` is green (3) and `last_color` is yellow (4), the base pattern `P` is `[yellow (4), white (0), yellow (4), green (3)]`.
        iv. Otherwise (default case), the base pattern `P` consists of the `first_color` followed by `lenS - 1` white (0) pixels. If `lenS` is 1, `P` is just `[first_color]`.
    f.  **Generate Tiled Output Pattern:** Create the final pattern for the row (`OutPat`) by repeating the base pattern `P` until it fills the required width `W`. Calculate the number of full repetitions (`num_repeats = W // len(P)`) and the remaining length (`remainder = W % len(P)`). The `OutPat` is `P` concatenated `num_repeats` times, followed by the first `remainder` elements of `P`.
    g.  **Update Output Grid:** Replace the segment of the output grid in row `r` to the right of the separator with the generated `OutPat`: `output_grid[r, C+1 : C+1+W] = OutPat`.
5.  **Return Result:** After processing all rows, return the modified output grid.
```python
import numpy as np
import math

"""
Transformation Rule Natural Language Description:

1.  **Initialization:** Create a copy of the input grid to serve as the output grid.
2.  **Locate Separator:** Find the column index (`C`) containing the vertical red line (color 2). This line separates the grid into a left input region and a right output region.
3.  **Calculate Output Width:** Determine the width (`W`) of the area to the right of the separator (`W = grid_width - C - 1`). If `W` is less than or equal to 0, no transformation occurs in the right region.
4.  **Iterate Through Rows:** For each row `r` from top to bottom:
    a.  **Extract Input Segment:** Get the segment of the row to the left of the separator: `Seg = input_grid[r, 0:C]`.
    b.  **Analyze Segment:** Create a sequence `S` containing only the non-white colors (colors > 0) from `Seg`.
    c.  **Check for Pattern:** If the sequence `S` is empty (the segment `Seg` was all white or the separator was at column 0), proceed to the next row without modification.
    d.  **Identify Key Colors:** If `S` is not empty, find the first color (`first_color = S[0]`) and the last color (`last_color = S[-1]`). Let `lenS = len(S)`.
    e.  **Determine Base Pattern (P):** Apply the following rules in order:
        i.  If `last_color` is azure (8), the base pattern `P` is `[8]`.
        ii. Else if `first_color` is red (2) and `last_color` is blue (1), the base pattern `P` is `[1, 2]`.
        iii. Else if `first_color` is green (3) and `last_color` is yellow (4), the base pattern `P` is `[4, 0, 4, 3]`.
        iv. Otherwise (default case): 
            - If `lenS` is 1, the base pattern `P` is `[first_color]`.
            - If `lenS` > 1, the base pattern `P` consists of the `first_color` followed by `lenS - 1` white (0) pixels: `[first_color] + [0] * (lenS - 1)`.
    f.  **Generate Tiled Output Pattern:** If the `output_width` `W` is greater than 0 and the base pattern `P` is not empty: Create the final pattern for the row (`OutPat`) by repeating the base pattern `P` until it fills the required width `W`. Calculate the number of full repetitions (`num_repeats = W // len(P)`) and the remaining length (`remainder = W % len(P)`). The `OutPat` is `P` concatenated `num_repeats` times, followed by the first `remainder` elements of `P`.
    g.  **Update Output Grid:** If `OutPat` was generated, replace the segment of the output grid in row `r` to the right of the separator with `OutPat`: `output_grid[r, C+1 : C+1+W] = OutPat`.
5.  **Return Result:** After processing all rows, return the modified output grid.
"""

def find_separator_column(grid):
    """Finds the column index of the vertical separator line (color 2)."""
    height, width = grid.shape
    for c in range(width):
        if np.any(grid[:, c] == 2):
            return c
    # Should not happen based on problem description, but return -1 if no separator found
    return -1 

def tile_pattern(pattern, width):
    """Repeats a pattern list to fill a given width."""
    if not pattern or width <= 0:
        return []
    pattern_len = len(pattern)
    if pattern_len == 0:
        return []
    
    num_repeats = width // pattern_len
    remainder = width % pattern_len
    
    tiled = pattern * num_repeats + pattern[:remainder]
    return tiled

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Finds a vertical red separator line. For each row, if there's a non-white
    pattern left of the separator, it generates a new pattern based on the
    first/last colors and length of the non-white sequence, and tiles this
    new pattern into the area right of the separator in that row.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = input_grid_np.copy()
    height, width = output_grid.shape

    # 1. Locate Separator
    separator_col = find_separator_column(output_grid)
    
    # If no separator found, return the original grid
    if separator_col == -1:
        return output_grid.tolist() # return as list of lists

    # 2. Calculate Output Width
    output_width = width - separator_col - 1

    # Check if there's space to write the output
    if output_width <= 0:
        return output_grid.tolist()

    # 3. Iterate Through Rows
    for r in range(height):
        # 4a. Extract Input Segment
        # Ensure separator_col is not 0 before slicing
        if separator_col > 0:
            input_segment = output_grid[r, 0:separator_col]
        else:
            input_segment = np.array([]) # No segment if separator is at col 0

        # 4b. Analyze Segment (find non-white sequence)
        non_white_sequence = [pixel for pixel in input_segment if pixel != 0]

        # 4c. Check for Pattern
        if not non_white_sequence:
            continue # Skip rows with no pattern to the left

        # 4d. Identify Key Colors & Length
        first_color = non_white_sequence[0]
        last_color = non_white_sequence[-1]
        lenS = len(non_white_sequence)

        # 4e. Determine Base Pattern (P)
        base_pattern = []
        if last_color == 8: # azure
             base_pattern = [8]
        elif first_color == 2 and last_color == 1: # red -> blue
             base_pattern = [1, 2]
        elif first_color == 3 and last_color == 4: # green -> yellow
             base_pattern = [4, 0, 4, 3]
        else: # Default case
             if lenS == 1:
                 base_pattern = [first_color]
             else:
                 base_pattern = [first_color] + [0] * (lenS - 1)

        # 4f. Generate Tiled Output Pattern
        # Ensure base_pattern is not empty before tiling
        if base_pattern:
            tiled_output_pattern = tile_pattern(base_pattern, output_width)
            
            # 4g. Update Output Grid
            if tiled_output_pattern: # Ensure pattern has elements before assignment
                output_grid[r, separator_col + 1 : separator_col + 1 + output_width] = tiled_output_pattern

    # 5. Return Result as list of lists
    return output_grid.tolist()
```
```python
import numpy as np

"""
Transformation Rule Natural Language Description:

1.  **Initialize:** Create an exact copy of the input grid, which will be modified to become the output grid.
2.  **Find Separator:** Scan the grid columns to find the index (`C`) of the column containing the vertical red (2) line. If no red line is found, return the original grid copy.
3.  **Calculate Output Width:** Determine the available width (`W`) for the output pattern to the right of the separator: `W = grid_width - C - 1`. If `W` is 0 or less, return the original grid copy as no changes can be made.
4.  **Process Each Row:** Iterate through each row `r` of the grid.
    a.  **Extract Input Segment:** If `C > 0`, get the segment of the row to the left of the separator: `InputSeg = grid[r, 0:C]`. If `C` is 0, the segment is empty.
    b.  **Analyze Segment:** Create a sequence `S` containing only the non-white (value != 0) pixels from `InputSeg`, preserving their order.
    c.  **Check for Trigger:** If sequence `S` is empty, continue to the next row (this row remains unchanged on the right side).
    d.  **Determine Base Pattern:** If `S` is not empty:
        i.  Get the first color (`first_color = S[0]`), last color (`last_color = S[-1]`), and length (`lenS = len(S)`).
        ii. Apply rules to define the `base_pattern` list `P`:
            *   If `last_color` is 8 (azure), set `P = [8]`.
            *   Else if `first_color` is 2 (red) and `last_color` is 1 (blue), set `P = [1, 2]`.
            *   Else if `first_color` is 3 (green) and `last_color` is 4 (yellow), set `P = [4, 0, 4, 3]`.
            *   Else (default case):
                *   If `lenS` is 1, set `P = [first_color]`.
                *   If `lenS` > 1, set `P = [first_color] + ([0] * (lenS - 1))`.
    e.  **Generate Tiled Pattern:** If a non-empty `base_pattern` `P` was determined:
        i.  Calculate the number of full repetitions: `num_repeats = W // len(P)`.
        ii. Calculate the number of remaining elements needed: `remainder = W % len(P)`.
        iii. Construct the `TiledPattern` by concatenating `P` `num_repeats` times, and then appending the first `remainder` elements of `P`.
    f.  **Update Output Grid:** Replace the portion of the current row `r` in the output grid, starting from column `C + 1` and extending for `W` columns, with the generated `TiledPattern`.
5.  **Return Result:** After processing all rows, return the modified output grid.
"""

def find_separator_column(grid_np):
    """Finds the column index of the first vertical line containing color 2 (red)."""
    height, width = grid_np.shape
    for c in range(width):
        # Check if any cell in the column is red (2)
        if np.any(grid_np[:, c] == 2):
            return c
    # Return -1 if no red separator column is found
    return -1

def tile_pattern(pattern, width):
    """Repeats a pattern list to fill a given width."""
    # Handle edge cases: empty pattern or zero/negative width
    if not pattern or width <= 0:
        return []
    pattern_len = len(pattern)
    if pattern_len == 0: # Should not happen if called correctly, but safe check
        return []

    # Calculate how many full repetitions fit and the remaining length
    num_repeats = width // pattern_len
    remainder = width % pattern_len

    # Construct the tiled pattern
    tiled = pattern * num_repeats + pattern[:remainder]
    return tiled

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Finds a vertical red separator line. For each row, if there's a non-white
    pattern left of the separator, it generates a new pattern based on the
    first/last colors and length of the non-white sequence, and tiles this
    new pattern into the area right of the separator in that row.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input
    output_grid = input_grid_np.copy()
    height, width = output_grid.shape

    # Find the separator column (C)
    separator_col = find_separator_column(output_grid)

    # If no separator found, return the original grid
    if separator_col == -1:
        return output_grid.tolist()

    # Calculate the width (W) of the output area to the right
    output_width = width - separator_col - 1

    # If there's no space to write the output, return the original grid
    if output_width <= 0:
        return output_grid.tolist()

    # Process each row
    for r in range(height):
        # Extract the input segment to the left of the separator
        # Handle case where separator is at the first column (C=0)
        if separator_col > 0:
            input_segment = output_grid[r, 0:separator_col]
        else:
            input_segment = np.array([], dtype=int) # Empty segment

        # Analyze the segment: find the sequence (S) of non-white pixels
        non_white_sequence = [pixel for pixel in input_segment if pixel != 0]

        # Check if there's a non-white pattern (trigger for transformation)
        if not non_white_sequence:
            continue # Skip to the next row if S is empty

        # Determine the base pattern (P) based on rules
        first_color = non_white_sequence[0]
        last_color = non_white_sequence[-1]
        lenS = len(non_white_sequence)
        base_pattern = []

        # Apply pattern rules (order matters)
        if last_color == 8: # Rule 1: Last color is azure
             base_pattern = [8]
        elif first_color == 2 and last_color == 1: # Rule 2: Red -> Blue
             base_pattern = [1, 2]
        elif first_color == 3 and last_color == 4: # Rule 3: Green -> Yellow
             base_pattern = [4, 0, 4, 3]
        else: # Rule 4: Default case
             if lenS == 1:
                 base_pattern = [first_color]
             else:
                 # First color followed by (lenS - 1) white pixels
                 base_pattern = [first_color] + [0] * (lenS - 1)

        # Generate the tiled output pattern if a base pattern was determined
        if base_pattern:
            tiled_output_pattern = tile_pattern(base_pattern, output_width)

            # Update the output grid if a tiled pattern was generated
            if tiled_output_pattern:
                # Define the slice for the output area in the current row
                output_slice = slice(separator_col + 1, separator_col + 1 + output_width)
                # Assign the tiled pattern to the output grid slice
                output_grid[r, output_slice] = tiled_output_pattern

    # Convert the final numpy array back to a list of lists and return
    return output_grid.tolist()
```
