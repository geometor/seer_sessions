
## train_1

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 6 6 6 8 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
1 1 1 1 0 2 1 0 0 0 1 0 0 0 1 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 6 6 6 8 2 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 3 0 0 0 0 3 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 2 5 0 0 0 5 0 0 0 5 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 1 1 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 4 4 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 1 1 0 2 1 2 1 2 1 2 1 2 1 2
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 3 3 4 4 2 4 0 4 3 4 0 4 0 4 3
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 5 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
7 7 7 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 1 0 1 0 1 0 1 0 1 0 1
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 5 2 5 5 5 5 5 5 5 5 5 5 5
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
7 7 7 2 7 0 0 7 0 0 7 0 0 7 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Separator:** Each input grid contains a single vertical line of red pixels (color 2). This line acts as a separator, dividing the grid into a left region and a right region.
2.  **Input Patterns:** To the left of the red line, some rows contain horizontal sequences of non-white pixels. These sequences are the primary input patterns. They vary in color, length, and composition.
3.  **Transformation Trigger:** The presence of a non-white pattern in a row to the left of the red line triggers a transformation in the corresponding row to the right of the red line.
4.  **Output Area:** The region to the right of the red line is initially white (color 0) in the input. In the output, this area is filled with new patterns in the rows corresponding to the input patterns.
5.  **Invariant Regions:** The red vertical line itself, the area to its left, and any rows that were entirely white to the left of the red line remain unchanged in the output.
6.  **Pattern Generation:** The patterns generated in the output area seem derived from the properties (colors, sequence) of the input pattern in the same row. The specific generation rule depends on the colors present in the input pattern, particularly the first and last non-white colors. The generated pattern is tiled or repeated to fill the available space to the right of the red line.

**Facts:**


```yaml
elements:
  - object: separator
    type: vertical_line
    color: red (2)
    location: fixed column per example (e.g., col 5 in ex1/2, col 3 in ex3)
    function: divides grid, triggers transformation

  - object: input_pattern
    type: horizontal_sequence
    location: rows to the left of the separator
    properties:
      - composition: sequence of non-white pixels (can include white pixels within the segment)
      - colors: variable (blue, green, yellow, gray, magenta, azure, orange, red)
      - length: variable segment length up to the separator column
      - first_non_white_color: property derived from the sequence
      - last_non_white_color: property derived from the sequence
      - non_white_sequence: property derived (sequence of non-white colors only)
    existence: optional per row

  - object: output_pattern
    type: horizontal_sequence
    location: rows to the right of the separator
    properties:
      - width: determined by grid_width - separator_column - 1
      - composition: generated based on corresponding input_pattern
      - tiling: often involves repeating a smaller base pattern
    existence: present only if a corresponding input_pattern exists

actions:
  - name: identify_separator
    input: input_grid
    output: column_index_of_red_line

  - name: extract_input_pattern
    input: input_grid_row, separator_column_index
    output: segment_left_of_separator

  - name: analyze_input_pattern
    input: segment_left_of_separator
    output:
      - non_white_sequence (S)
      - first_color (S[0] if S not empty)
      - last_color (S[-1] if S not empty)
      - length_of_non_white_sequence (len(S))

  - name: determine_base_pattern
    input: first_color, last_color, length_of_non_white_sequence
    rules:
      - if last_color is azure (8): base_pattern = [azure (8)]
      - if first_color is red (2) and last_color is blue (1): base_pattern = [blue (1), red (2)]
      - if first_color is green (3) and last_color is yellow (4): base_pattern = [yellow (4), white (0), yellow (4), green (3)]
      - otherwise: base_pattern = [first_color] + [white (0)] * (length_of_non_white_sequence - 1)
    output: base_pattern (P)

  - name: generate_output_pattern
    input: base_pattern (P), output_width (W)
    logic: repeat P to fill width W ( P * (W // len(P)) + P[:(W % len(P))] )
    output: final_output_pattern_for_row

  - name: apply_transformation
    input: input_grid, separator_column_index, row_index, final_output_pattern
    output: modified_output_grid (updates row to the right of separator)

relationships:
  - type: correspondence
    entity1: input_pattern (row r, left)
    entity2: output_pattern (row r, right)
    description: An input pattern in a given row determines the output pattern in the same row.

  - type: dependency
    entity1: output_pattern
    entity2: input_pattern
    description: The structure and colors of the output pattern depend on the first color, last color, and number of non-white colors in the corresponding input pattern sequence.
```


**Natural Language Program:**

1.  **Initialization:** Create a copy of the input grid to serve as the output grid.
2.  **Locate Separator:** Find the column index (`C`) containing the vertical red line (color 2).
3.  **Calculate Output Width:** Determine the width (`W`) of the area to the right of the separator (`W = grid_width - C - 1`).
4.  **Iterate Through Rows:** For each row `r` from top to bottom:
    a.  **Extract Input Segment:** Get the segment of the row to the left of the separator: `Seg = input_grid[r, 0:C]`.
    b.  **Analyze Segment:** Create a sequence `S` containing only the non-white colors from `Seg`.
    c.  **Check for Pattern:** If the sequence `S` is empty (the segment `Seg` was all white), proceed to the next row without modification.
    d.  **Identify Key Colors:** If `S` is not empty, find the first color (`first_color = S[0]`) and the last color (`last_color = S[-1]`). Let `lenS = len(S)`.
    e.  **Determine Base Pattern (P):**
        i.  If `last_color` is azure (8), the base pattern `P` is `[azure (8)]`.
        ii. Else if `first_color` is red (2) and `last_color` is blue (1), the base pattern `P` is `[blue (1), red (2)]`.
        iii. Else if `first_color` is green (3) and `last_color` is yellow (4), the base pattern `P` is `[yellow (4), white (0), yellow (4), green (3)]`.
        iv. Otherwise (default case), the base pattern `P` consists of the `first_color` followed by `lenS - 1` white (0) pixels. If `lenS` is 1, `P` is just `[first_color]`.
    f.  **Generate Tiled Output Pattern:** Create the final pattern for the row (`OutPat`) by repeating the base pattern `P` until it fills the required width `W`. Calculate the number of full repetitions (`num_repeats = W // len(P)`) and the remaining length (`remainder = W % len(P)`). The `OutPat` is `P` concatenated `num_repeats` times, followed by the first `remainder` elements of `P`.
    g.  **Update Output Grid:** Replace the segment of the output grid in row `r` to the right of the separator with the generated `OutPat`: `output_grid[r, C+1 : C+1+W] = OutPat`.
5.  **Return Result:** After processing all rows, return the modified output grid.
