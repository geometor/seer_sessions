{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Identify the horizontal blue separator line (color 1) spanning the grid width. This divides the grid into an upper 'key' area and a lower 'work' area.\n2.  Identify all distinct non-separator colored objects within the key area. For each 'key' object, store its color, relative pixel pattern (coordinates relative to its bounding box top-left), pixel count, and bounding box dimensions (height, width).\n3.  Identify all gray objects (color 5) within the work area. For each 'gray' object, store its original pixel coordinates, relative pixel pattern, and bounding box dimensions.\n4.  For each gray object, determine which key object patterns *contain* the gray object's pattern. A key pattern contains the gray pattern if the gray object's shape (relative pixel set) can be translated such that all its pixels coincide with pixels within the key object's relative pattern.\n5.  If a gray object's pattern is contained within multiple key patterns, apply a tie-breaking rule:\n    a.  First, select the key(s) with the *smallest* bounding box area (height * width).\n    b.  If there's still a tie, select the key(s) with the *largest* pixel count among those tied in area.\n    c.  (Assumption: This process yields a unique key).\n6.  Create an output grid initialized as a copy of the input grid.\n7.  For each gray object that successfully matched a unique key, recolor all of its original pixel locations in the output grid with the color of the matched key object.\n8.  The separator line and the key objects remain unchanged.\n9.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, colors):\n    \"\"\"Finds all connected objects of specified colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        colors (list or set): A list/set of integer colors to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (a set of (r, c) tuples), and\n              'bbox' (a tuple of min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    target_colors = set(colors)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in target_colors and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (Moore neighborhood)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == obj_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                if obj_pixels:\n                    objects.append({\n                        'color': obj_color,\n                        'pixels': obj_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef get_relative_pattern(pixels, top_left):\n    \"\"\"Converts absolute pixel coordinates to relative coordinates based on top_left.\n\n    Args:\n        pixels (set): Set of (r, c) absolute coordinates.\n        top_left (tuple): (min_r, min_c) coordinates of the bounding box top-left.\n\n    Returns:\n        frozenset: A frozenset of (dr, dc) relative coordinates.\n    \"\"\"\n    min_r, min_c = top_left\n    return frozenset((r - min_r, c - min_c) for r, c in pixels)\n\ndef get_bbox_dims(bbox):\n    \"\"\"Calculates the height and width from bounding box coordinates.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef check_gray_in_key(gray_rel_pattern, key_rel_pattern):\n    \"\"\"Checks if the gray_rel_pattern fits inside (is a subset of) the key_rel_pattern.\"\"\"\n    if not gray_rel_pattern or not key_rel_pattern:\n        return False\n    if not gray_rel_pattern.issubset(key_rel_pattern): # Quick check if possible at all without offset\n         # Check if translation makes it a subset\n        max_gray_dr = max(dr for dr, dc in gray_rel_pattern) if gray_rel_pattern else -1\n        max_gray_dc = max(dc for dr, dc in gray_rel_pattern) if gray_rel_pattern else -1\n        max_key_dr = max(dr for dr, dc in key_rel_pattern) if key_rel_pattern else -1\n        max_key_dc = max(dc for dr, dc in key_rel_pattern) if key_rel_pattern else -1\n\n        gray_h = max_gray_dr + 1\n        gray_w = max_gray_dc + 1\n        key_h = max_key_dr + 1\n        key_w = max_key_dc + 1\n        \n        # If gray is larger than key in any dimension, it can't fit\n        if gray_h > key_h or gray_w > key_w:\n             return False\n\n        # Iterate through all possible top-left offsets for the gray within the key's relative bbox\n        for offset_r in range(key_h - gray_h + 1):\n            for offset_c in range(key_w - gray_w + 1):\n                fits_at_offset = True\n                # Check if every pixel of the shifted gray pattern exists in the key pattern\n                for gdr, gdc in gray_rel_pattern:\n                    target_rel = (gdr + offset_r, gdc + offset_c)\n                    if target_rel not in key_rel_pattern:\n                        fits_at_offset = False\n                        break # This offset doesn't work\n                \n                if fits_at_offset:\n                    return True # Found a working offset\n\n        return False # No offset worked, and direct subset failed\n    else:\n        return True # It's a direct subset\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule:\n    - Finds key patterns above a blue line.\n    - Finds gray objects below the blue line.\n    - Recolors gray objects based on the key pattern that contains the gray pattern,\n      using tie-breakers (smallest bbox area, then largest pixel count).\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n    separator_color = 1 # Blue\n    gray_color = 5\n\n    # --- 1. Find Separator and Define Areas ---\n    separator_row = -1\n    for r in range(rows):\n        # Check if the entire row is the separator color\n        is_separator_line = True\n        for c in range(cols):\n             if input_grid_np[r,c] != separator_color:\n                  is_separator_line = False\n                  break\n        if is_separator_line:\n             # Ensure it's not the only color in the grid if it's just 1xN or Nx1\n             if cols > 1 or rows > 1:\n                 # Check if there are other colors present anywhere\n                 if np.any(input_grid_np != separator_color):\n                     separator_row = r\n                     break\n    \n    # Handle case where separator isn't found (use heuristic if needed, but rely on examples for now)\n    if separator_row == -1:\n        # This case shouldn't happen based on the provided examples.\n        # If it did, we might assume no keys or default behavior.\n        print(\"Warning: Separator line not found.\")\n        return input_grid # Return original if structure is unclear\n\n    key_area_max_row = separator_row # Rows 0 to separator_row - 1\n    work_area_min_row = separator_row + 1 # Rows separator_row + 1 to end\n\n    # --- 2. Identify Key Objects ---\n    all_objects = find_objects(input_grid_np, list(range(10))) # Find all objects first\n    key_objects_info = []\n    \n    for obj in all_objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        # Object must be entirely above the separator and not be the separator color or gray\n        if max_r < key_area_max_row and obj['color'] != separator_color and obj['color'] != gray_color:\n            rel_pattern = get_relative_pattern(obj['pixels'], (min_r, min_c))\n            height, width = get_bbox_dims(obj['bbox'])\n            key_objects_info.append({\n                'color': obj['color'],\n                'pattern': rel_pattern,\n                'pixel_count': len(obj['pixels']),\n                'bbox_dims': (height, width),\n                'bbox_area': height * width\n            })\n\n    # --- 3. Identify Gray Objects ---\n    gray_objects = []\n    for obj in all_objects:\n        min_r, min_c, _, _ = obj['bbox']\n        # Object must start at or below the work area start row and be gray\n        if min_r >= work_area_min_row and obj['color'] == gray_color:\n            rel_pattern = get_relative_pattern(obj['pixels'], (min_r, min_c))\n            gray_objects.append({\n                 'pixels': obj['pixels'], # Keep original pixels for recoloring\n                 'pattern': rel_pattern\n            })\n\n    # --- 4. Process Gray Objects: Matching and Tie-breaking ---\n    for gray_obj in gray_objects:\n        gray_rel_pattern = gray_obj['pattern']\n        matching_keys = []\n\n        # Find all keys that contain the gray pattern\n        for key_info in key_objects_info:\n            if check_gray_in_key(gray_rel_pattern, key_info['pattern']):\n                matching_keys.append(key_info)\n\n        if not matching_keys:\n            continue # No key contains this gray object pattern\n\n        # Apply tie-breaker 1: Smallest BBox Area\n        min_area = min(k['bbox_area'] for k in matching_keys)\n        keys_min_area = [k for k in matching_keys if k['bbox_area'] == min_area]\n\n        best_key = None\n        if len(keys_min_area) == 1:\n            best_key = keys_min_area[0]\n        elif len(keys_min_area) > 1:\n            # Apply tie-breaker 2: Largest Pixel Count among those with min area\n            max_pixels = max(k['pixel_count'] for k in keys_min_area)\n            keys_max_pixels = [k for k in keys_min_area if k['pixel_count'] == max_pixels]\n            # Assuming this results in a unique key based on problem constraints\n            if len(keys_max_pixels) == 1:\n                 best_key = keys_max_pixels[0]\n            # else: handle unexpected multiple best keys? Print warning or pick first.\n            # For now, assume unique or pick first if still tied (unlikely based on ARC)\n            elif keys_max_pixels:\n                 best_key = keys_max_pixels[0] # Pick the first one if tie persists\n\n        # --- 5. Recolor ---\n        if best_key:\n            target_color = best_key['color']\n            for r, c in gray_obj['pixels']:\n                if 0 <= r < rows and 0 <= c < cols: # Bounds check\n                    output_grid[r, c] = target_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 8575,
            "end_index": 8910,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25631,
    "candidates_token_count": 3048,
    "total_token_count": 28679,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.305706,
  "retries": 1
}