
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 0 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 0 0 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 7 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 7 7 7 7 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 7 7 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 7 7 7 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 7 7 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 2 0 0 2 2 0 0 2 0 0 2 2 0 2 0 0 2 0
0 0 2 0 0 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 4 4 2 0 0 0 0 0 2 4 4 2 0
0 0 2 4 4 2 2 4 4 2 0 0 2 2 0 2 4 4 2 0
0 0 2 4 4 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


## train_4

**input:**
```
0 0 2 2 0 0 0 0
0 2 0 0 2 0 0 0
0 2 0 0 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```


**output:**
```
0 0 2 2 0 0 0 0
0 2 4 4 2 0 0 0
0 2 4 4 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```

## Perception

The task involves modifying an input grid based on color patterns. The core operation seems to be identifying specific 2x2 blocks of white pixels and filling them with a special color found elsewhere in the grid.

1.  **Identify the Fill Color:** In each example, there's exactly one pixel whose color is unique across the entire grid (appears only once). This unique color serves as the "fill color" for the transformation. In the examples, orange (7) and yellow (4) were the fill colors.
2.  **Identify Target Squares:** The transformation targets 2x2 squares composed entirely of white pixels (0).
3.  **Identify Frame Colors:** Certain colors seem to act as "frames" or "triggers" for the fill operation. These frame colors surround the target 2x2 white squares. Based on the examples, red (2), green (3), and gray (5) act as frame colors. White (0), blue (1), and the unique fill color itself do *not* act as frame colors.
4.  **Apply Fill Condition:** A 2x2 square of white pixels is filled with the unique fill color if it is "sufficiently bordered" by pixels of the frame colors. Specifically, if at least three of the eight neighboring cells surrounding the 2x2 white square are of a valid frame color.
5.  **Output:** The output grid is the input grid modified by filling the qualifying 2x2 white squares with the unique fill color. The original frame pixels and the unique fill color pixel remain unchanged. Other parts of the grid also remain unchanged.

## Facts


```yaml
- task: fill_enclosed_squares
- feature: color_frequency_analysis
  description: Identify a unique color present only once in the input grid.
  target_color_property: unique_occurrence
  role: fill_color
- feature: identify_patterns
  description: Locate all 2x2 squares consisting entirely of white pixels (0).
  target_pattern: 2x2_square
  target_pattern_color: white (0)
  role: potential_fill_area
- feature: define_trigger_colors
  description: Determine which colors can trigger the fill operation.
  triggering_colors: [red (2), green (3), gray (5)] # Based on examples
  non_triggering_colors: [white (0), blue (1), fill_color]
  role: frame_colors
- feature: neighborhood_analysis
  description: For each 2x2 white square, analyze its 8 immediate neighbors.
  condition: Count the number of neighbors whose color is one of the frame_colors.
  threshold: 3
  role: fill_condition_check
- action: conditional_fill
  description: If the fill condition (>= 3 frame color neighbors) is met for a 2x2 white square, change the color of all 4 pixels in that square to the fill_color.
  input: 2x2_white_square
  condition: neighbor_count >= 3
  output: 2x2_square_filled_with_fill_color
- output_grid: preservation
  description: Pixels not part of a filled 2x2 square retain their original color from the input grid.
```


## Natural Language Program

1.  Scan the input grid and count the occurrences of each color (excluding white, color 0).
2.  Identify the color that appears exactly once; this is the `fill_color`. If no color appears exactly once, the transformation might not apply or the rule is different (though all examples show a unique color).
3.  Define a set of `frame_colors` which includes all colors present in the input grid except for white (0), blue (1), and the identified `fill_color`.
4.  Create a copy of the input grid to serve as the output grid.
5.  Iterate through the grid, examining every possible 2x2 square. For a grid of height H and width W, check top-left corners (r, c) where `0 <= r < H-1` and `0 <= c < W-1`.
6.  For each potential top-left corner (r, c), check if the 2x2 square defined by `(r, c), (r+1, c), (r, c+1), (r+1, c+1)` consists entirely of white (0) pixels in the *input* grid.
7.  If it is a 2x2 white square, examine its 8 neighboring pixels in the *input* grid (cells `(r-1, c-1)` through `(r+2, c+2)`, excluding the square itself, and respecting grid boundaries).
8.  Count how many of these 8 neighbors have a color that is included in the `frame_colors` set.
9.  If this count is 3 or greater, modify the *output* grid by setting the color of the four pixels `(r, c), (r+1, c), (r, c+1), (r+1, c+1)` to the `fill_color`.
10. After checking all possible 2x2 squares, return the modified output grid.
```python
import numpy as np
from collections import Counter

"""
This transformation identifies a unique color (excluding white) in the input grid, 
which serves as a 'fill color'. It then locates all 2x2 squares composed entirely of 
white pixels (0). For each such white square, it examines the 8 neighboring pixels. 
If 3 or more of these neighbors belong to a defined set of 'frame colors' (all colors 
present except white, blue, and the fill color), the 2x2 white square in the output 
grid is filled with the unique 'fill color'. All other pixels retain their 
original color.
"""

def find_unique_color(grid):
    """Finds the color that appears exactly once in the grid (excluding 0)."""
    counts = Counter()
    for r in range(grid.shape[0]):
        for c in range(grid.shape[1]):
            if grid[r, c] != 0: # Exclude white
                counts[grid[r, c]] += 1
                
    unique_color = None
    for color, count in counts.items():
        if count == 1:
            unique_color = color
            break # Assume only one unique color based on examples
            
    return unique_color

def get_frame_colors(grid, fill_color):
    """Determines the set of frame colors."""
    present_colors = set(np.unique(grid))
    # Frame colors are all present colors except white(0), blue(1), and the fill_color
    frame_colors = present_colors - {0, 1, fill_color}
    return frame_colors

def transform(input_grid):
    """
    Fills 2x2 white squares with a unique color if they are bordered by at least 
    three 'frame color' pixels.
    """
    input_np = np.array(input_grid, dtype=int)
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # 1. Find the unique fill color
    fill_color = find_unique_color(input_np)
    if fill_color is None:
        # If no unique color is found (as defined by the rule), return the input unchanged.
        # This might need adjustment based on task constraints if this case is possible.
        return input_grid

    # 2. Define the frame colors
    frame_colors = get_frame_colors(input_np, fill_color)

    # 3. Iterate through the grid to find potential 2x2 white squares
    for r in range(height - 1):
        for c in range(width - 1):
            # 4. Check if the 2x2 square is all white
            square = input_np[r:r+2, c:c+2]
            if np.all(square == 0):
                
                # 5. Examine the 8 neighbors
                neighbor_count = 0
                for dr in range(-1, 3): # Relative row index from -1 to 2
                    for dc in range(-1, 3): # Relative col index from -1 to 2
                        # Skip the square itself
                        if 0 <= dr <= 1 and 0 <= dc <= 1:
                            continue

                        # Calculate absolute neighbor coordinates
                        nr, nc = r + dr, c + dc

                        # Check boundaries
                        if 0 <= nr < height and 0 <= nc < width:
                            # 6. Count neighbors with frame colors
                            if input_np[nr, nc] in frame_colors:
                                neighbor_count += 1
                
                # 7. If condition met, fill the square in the output grid
                if neighbor_count >= 3:
                    output_np[r:r+2, c:c+2] = fill_color

    # Convert back to list of lists for the expected output format
    return output_np.tolist()

```
