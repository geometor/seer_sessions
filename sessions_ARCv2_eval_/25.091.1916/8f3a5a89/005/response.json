{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the single connected component of gray (8) pixels that is cardinally \nadjacent to the single magenta (6) pixel or reachable from those adjacent gray \npixels via cardinal gray-to-gray steps, treating blue (1) pixels as impassable \nbarriers. Change all gray (8) pixels that do *not* belong to this \nmagenta-connected component to orange (7). Leave the magenta pixel, blue pixels, \nand the gray pixels belonging to the magenta-connected component unchanged.\n\"\"\"\n\ndef find_pixel(grid, color):\n    \"\"\"\n    Finds the coordinates (row, col) of the first pixel with the specified color.\n\n    Args:\n        grid: The numpy array representing the grid.\n        color: The integer color value to find.\n\n    Returns:\n        A tuple (row, col) if found, otherwise None.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                return (r, c)\n    return None\n\ndef find_magenta_adjacent_gray_component(grid, start_pos):\n    \"\"\"\n    Performs a Breadth-First Search (BFS) starting from the gray (8) neighbors\n    of the start_pos (magenta pixel) to find all connected gray pixels,\n    respecting blue (1) barriers.\n\n    Args:\n        grid: The numpy array representing the input grid.\n        start_pos: A tuple (row, col) representing the coordinates of the\n                   magenta (6) pixel.\n\n    Returns:\n        A set of tuples, where each tuple is the (row, col) coordinate of a\n        gray pixel belonging to the connected component adjacent to the magenta pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    component_pixels = set() # Stores (r, c) of gray pixels in the component\n    queue = deque()\n    \n    start_r, start_c = start_pos\n\n    # --- Step 1: Find initial gray neighbors of the magenta start point ---\n    # These are the entry points into the gray component we want to identify.\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Cardinal directions\n        nr, nc = start_r + dr, start_c + dc\n        \n        # Check if neighbor is within grid bounds\n        if 0 <= nr < rows and 0 <= nc < cols:\n            # Check if the neighbor is gray (8)\n            if grid[nr, nc] == 8:\n                # Check if not already added (important if magenta has multiple gray neighbors)\n                if (nr, nc) not in component_pixels:\n                    component_pixels.add((nr, nc))\n                    queue.append((nr, nc))\n\n    # --- Step 2: Perform BFS starting from these initial gray neighbors ---\n    while queue:\n        r, c = queue.popleft() # Get the next gray pixel to explore from\n\n        # Explore cardinal neighbors of the current gray pixel\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor is gray (8) AND not already visited/added\n                if grid[nr, nc] == 8 and (nr, nc) not in component_pixels:\n                    component_pixels.add((nr, nc))\n                    queue.append((nr, nc)) # Add valid gray neighbor to queue for further exploration\n                    \n    return component_pixels\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- Step 1: Locate the single magenta (6) pixel ---\n    magenta_pos = find_pixel(input_grid, 6)\n    if magenta_pos is None:\n        # Should not happen based on examples, but return original if it does\n        print(\"Warning: Magenta pixel (6) not found.\")\n        return output_grid \n\n    # --- Step 2: Identify the connected component of gray (8) pixels adjacent to magenta ---\n    # This uses BFS starting from the gray neighbors of magenta, treating blue (1) as barriers.\n    component_C = find_magenta_adjacent_gray_component(input_grid, magenta_pos)\n\n    # --- Step 3: Iterate through the grid and change non-component gray pixels to orange ---\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel in the *original* input grid is gray (8)\n            if input_grid[r, c] == 8:\n                # Check if this gray pixel's coordinate is NOT part of the component found in Step 2\n                if (r, c) not in component_C:\n                    # If it's gray and not connected to magenta, change it to orange (7)\n                    output_grid[r, c] = 7\n            \n            # All other pixels (magenta, blue, gray pixels in component_C) \n            # remain unchanged because output_grid started as a copy of input_grid.\n\n    # --- Step 4: Return the modified grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20323,
    "candidates_token_count": 1318,
    "total_token_count": 21641,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.748495,
  "retries": 1
}