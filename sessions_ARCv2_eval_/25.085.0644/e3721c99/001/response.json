{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nIdentifies key shapes in the upper part of the grid (above a blue horizontal line) \nand target gray shapes in the lower part. Replaces each gray shape with the \nkey shape that is geometrically closest to it. The replacement shape uses the \ncolor of the closest key shape and is positioned using the top-left corner of \nthe original gray shape's bounding box as an anchor.\n\n1.  Create a copy of the input grid for the output.\n2.  Find the horizontal blue separator line.\n3.  Identify all connected non-white objects (key objects) above the separator. \n    Store their pixels, color, top-left corner, and relative shape.\n4.  Identify all connected gray objects (target objects) below the separator. \n    Store their pixels and top-left corner.\n5.  For each target object:\n    a.  Calculate the minimum distance to every key object.\n    b.  Determine the closest key object (using top-left coordinate as a tie-breaker).\n    c.  Clear the original gray pixels of the target object in the output grid.\n    d.  Draw the shape of the closest key object using its color, anchored at the \n        target object's top-left corner, onto the output grid.\n6.  Return the modified output grid.\n\"\"\"\n\ndef find_separator_row(grid):\n    \"\"\"Finds the row index of the horizontal blue line.\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        if np.all(grid[r, :] == 1):\n            return r\n    return -1 # Should not happen based on examples\n\ndef get_objects(grid, condition_mask, get_color=False):\n    \"\"\"\n    Finds connected components based on a boolean condition mask.\n    Returns a list of objects, each with pixels, bbox, top_left, and optionally color and shape.\n    \"\"\"\n    labeled_array, num_features = label(condition_mask)\n    objects_data = []\n    \n    # find_objects returns slices, which can include None if the object touches the edge\n    # We need to convert these slices to actual bounding box coordinates.\n    slices = find_objects(labeled_array) \n    \n    for i in range(1, num_features + 1):\n        obj_mask = (labeled_array == i)\n        pixels = set(tuple(coord) for coord in np.argwhere(obj_mask))\n        \n        # Get bounding box from slices\n        r_slice, c_slice = slices[i-1]\n        min_row, max_row = r_slice.start, r_slice.stop\n        min_col, max_col = c_slice.start, c_slice.stop\n        \n        bbox = (min_row, min_col, max_row - 1, max_col - 1) # slices are exclusive at stop\n        top_left = (min_row, min_col)\n        \n        obj_info = {\n            \"pixels\": pixels,\n            \"bbox\": bbox,\n            \"top_left\": top_left\n        }\n\n        if get_color:\n            # Assuming object has a single non-background color\n            color_val = 0\n            for r, c in pixels:\n                 val = grid[r, c]\n                 if val != 0: # Find the first non-background color\n                     color_val = val\n                     break\n            obj_info[\"color\"] = color_val\n            \n            # Calculate relative shape\n            shape = set((r - min_row, c - min_col) for r, c in pixels)\n            obj_info[\"shape\"] = shape\n            \n        objects_data.append(obj_info)\n        \n    return objects_data\n\ndef calculate_min_distance(obj1_pixels, obj2_pixels):\n    \"\"\"Calculates the minimum Euclidean distance between any pair of pixels from two objects.\"\"\"\n    min_dist_sq = float('inf')\n    for r1, c1 in obj1_pixels:\n        for r2, c2 in obj2_pixels:\n            dist_sq = (r1 - r2)**2 + (c1 - c2)**2\n            if dist_sq < min_dist_sq:\n                min_dist_sq = dist_sq\n    return math.sqrt(min_dist_sq)\n\ndef draw_shape(grid, top_left, shape, color):\n    \"\"\"Draws a shape onto the grid at the specified anchor point.\"\"\"\n    rows, cols = grid.shape\n    anchor_r, anchor_c = top_left\n    for dr, dc in shape:\n        r, c = anchor_r + dr, anchor_c + dc\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # Find the separator row\n    separator_row = find_separator_row(output_grid)\n    if separator_row == -1:\n        # Handle error or return input if no separator found (though unlikely for this task)\n        return output_grid \n        \n    # --- Identify Key Objects (Above Separator) ---\n    key_mask = np.zeros_like(output_grid, dtype=bool)\n    # Consider rows 1 to separator_row-1 (excluding row 0 often empty, and the separator itself)\n    if separator_row > 1:\n         key_mask[1:separator_row, :] = (output_grid[1:separator_row, :] != 0)\n    key_objects = get_objects(output_grid, key_mask, get_color=True)\n\n    # --- Identify Target Objects (Below Separator) ---\n    target_mask = np.zeros_like(output_grid, dtype=bool)\n    if separator_row < rows - 1:\n        target_mask[separator_row + 1:, :] = (output_grid[separator_row + 1:, :] == 5) # Gray color\n    target_objects = get_objects(output_grid, target_mask, get_color=False)\n\n    # --- Process Each Target Object ---\n    if not key_objects: # If no keys, no transformation happens below separator\n        return output_grid\n        \n    for target_obj in target_objects:\n        min_distance = float('inf')\n        closest_key = None\n\n        # Find the closest key object\n        for key_obj in key_objects:\n            distance = calculate_min_distance(target_obj[\"pixels\"], key_obj[\"pixels\"])\n            \n            update_closest = False\n            if distance < min_distance:\n                update_closest = True\n            elif distance == min_distance:\n                 # Tie-breaking: prefer key object with smaller top_left row, then smaller top_left col\n                 if key_obj[\"top_left\"][0] < closest_key[\"top_left\"][0]:\n                     update_closest = True\n                 elif key_obj[\"top_left\"][0] == closest_key[\"top_left\"][0] and \\\n                      key_obj[\"top_left\"][1] < closest_key[\"top_left\"][1]:\n                     update_closest = True\n\n            if update_closest:\n                min_distance = distance\n                closest_key = key_obj\n\n        if closest_key:\n            # Clear the original target object pixels\n            for r, c in target_obj[\"pixels\"]:\n                if r < rows and c < cols: # Boundary check just in case\n                   output_grid[r, c] = 0 # Set to background color\n\n            # Draw the closest key's shape at the target's anchor point\n            draw_shape(output_grid, \n                       target_obj[\"top_left\"], \n                       closest_key[\"shape\"], \n                       closest_key[\"color\"])\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9690,
    "candidates_token_count": 1858,
    "total_token_count": 11548,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.801412
}