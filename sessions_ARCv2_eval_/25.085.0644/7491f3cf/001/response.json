{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation identifies four zones within a bordered grid. It copies the pattern\n(non-background, non-border pixels) from either Zone 2 or Zone 3 into Zone 4,\noverwriting Zone 4's original pattern but preserving its background.\n\nThe source zone selection logic is:\n1. If Zone 3 contains any non-background pattern pixel that is NOT green (3),\n   Zone 3 is the source.\n2. Otherwise, Zone 2 is the primary source.\n3. If Zone 2 is the source AND Zone 3's pattern consists solely of green (3) pixels\n   forming a single horizontal line spanning the zone's width, then Zone 3 acts as\n   a modifier, and its green pattern is overlaid onto Zone 4 after copying\n   Zone 2's pattern.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\n# Define constants\nZONE_WIDTH = 5\nZONE_SEPARATOR_WIDTH = 1\nNUM_ZONES = 4\nMODIFIER_COLOR = 3  # green\n\nZONE_COLUMNS = {\n    1: list(range(1, 1 + ZONE_WIDTH)),\n    2: list(range(1 + ZONE_WIDTH + ZONE_SEPARATOR_WIDTH, 1 + ZONE_WIDTH + ZONE_SEPARATOR_WIDTH + ZONE_WIDTH)),\n    3: list(range(1 + 2 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH), 1 + 2 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH) + ZONE_WIDTH)),\n    4: list(range(1 + 3 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH), 1 + 3 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH) + ZONE_WIDTH)),\n}\n\ndef _get_border_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assuming it's the border color.\"\"\"\n    counts = Counter(grid.flatten())\n    return counts.most_common(1)[0][0]\n\ndef _get_zone_subgrid(grid, zone_index):\n    \"\"\"Extracts the inner part (excluding borders) of a specified zone.\"\"\"\n    rows, _ = grid.shape\n    cols = ZONE_COLUMNS[zone_index]\n    return grid[1:rows-1, min(cols):max(cols)+1]\n\ndef _get_zone_background(grid, zone_index, border_color):\n    \"\"\"Finds the most frequent color within a zone, excluding the border color.\"\"\"\n    zone_subgrid = _get_zone_subgrid(grid, zone_index)\n    if zone_subgrid.size == 0:\n        # Handle empty inner zone case, maybe default? Or assume valid input.\n        # Let's assume valid input means non-empty inner zones for Z2/Z3/Z4\n        # If the zone only contains border color, there's no distinct background.\n        # This might need adjustment based on edge cases.\n        # For now, return a value unlikely to be a pattern, like border_color itself\n        # or -1 if we need to signal this. Let's return border_color for now.\n         unique_colors = np.unique(zone_subgrid)\n         if len(unique_colors) == 1 and unique_colors[0] == border_color:\n             # If the zone *only* has border color, this is tricky.\n             # Let's return the border color, assuming patterns won't match it.\n             return border_color\n         elif len(unique_colors) == 0:\n             # Empty subgrid? Shouldn't happen with ARC constraints (min 1x1)\n             # but being safe.\n             return border_color # or raise error\n\n\n    counts = Counter(zone_subgrid.flatten())\n    # Remove border color count if present\n    if border_color in counts:\n        del counts[border_color]\n    \n    if not counts:\n         # This means the zone only contained the border color\n         # Return the border color itself, assuming patterns won't match it.\n         return border_color\n\n    # Return the most frequent remaining color\n    return counts.most_common(1)[0][0]\n\n\ndef _get_pattern_pixels(grid, zone_index, bg_color, border_color):\n    \"\"\"Finds coordinates and colors of pattern pixels in a zone.\"\"\"\n    pattern_pixels = []\n    rows, _ = grid.shape\n    cols = ZONE_COLUMNS[zone_index]\n    min_col, max_col = min(cols), max(cols)\n\n    for r in range(1, rows - 1):\n        for c in range(min_col, max_col + 1):\n            color = grid[r, c]\n            if color != bg_color and color != border_color:\n                pattern_pixels.append(((r, c), color))\n    return pattern_pixels\n\ndef _is_horizontal_line(pattern_pixels, zone_index):\n    \"\"\"Checks if pattern pixels form a single horizontal line across the zone.\"\"\"\n    if not pattern_pixels:\n        return False\n\n    cols = ZONE_COLUMNS[zone_index]\n    min_col, max_col = min(cols), max(cols)\n    expected_width = max_col - min_col + 1 # Should be ZONE_WIDTH\n\n    first_row = pattern_pixels[0][0][0]\n    pixel_cols = set()\n\n    for (r, c), color in pattern_pixels:\n        if r != first_row: # Must all be on the same row\n            return False\n        if color != MODIFIER_COLOR: # Must all be the modifier color (green)\n            return False\n        if not (min_col <= c <= max_col): # Must be within zone columns\n             return False\n        pixel_cols.add(c)\n\n    # Check if all columns in the zone range are present exactly once\n    return len(pixel_cols) == expected_width and min(pixel_cols) == min_col and max(pixel_cols) == max_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on zone analysis and copying/modifying Zone 4.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify border color\n    border_color = _get_border_color(input_grid)\n\n    # 2. Get background colors for relevant zones\n    bg_z2 = _get_zone_background(input_grid, 2, border_color)\n    bg_z3 = _get_zone_background(input_grid, 3, border_color)\n    # bg_z4 is not explicitly needed for the logic, but good for clarity if copying\n    # bg_z4 = _get_zone_background(input_grid, 4, border_color) # We preserve Z4 bg\n\n    # 3. Analyze Zone 3 to determine source and modifier\n    source_zone_index = 2 # Default source\n    modifier_zone_index = None # Default no modifier\n\n    z3_pattern_pixels = _get_pattern_pixels(input_grid, 3, bg_z3, border_color)\n\n    has_non_green_pattern_z3 = any(color != MODIFIER_COLOR for _, color in z3_pattern_pixels)\n\n    if has_non_green_pattern_z3:\n        source_zone_index = 3\n        modifier_zone_index = None\n    else:\n        # All pattern pixels in Z3 (if any) are green\n        if _is_horizontal_line(z3_pattern_pixels, 3):\n            source_zone_index = 2\n            modifier_zone_index = 3\n        else:\n            source_zone_index = 2\n            modifier_zone_index = None\n\n    # 4. Perform the copy operation\n    source_cols = ZONE_COLUMNS[source_zone_index]\n    target_cols = ZONE_COLUMNS[4]\n    col_offset = min(target_cols) - min(source_cols)\n    source_bg = bg_z2 if source_zone_index == 2 else bg_z3\n\n    source_pattern_pixels = _get_pattern_pixels(input_grid, source_zone_index, source_bg, border_color)\n\n    for (r, c_src), color in source_pattern_pixels:\n        c_tgt = c_src + col_offset\n        # Ensure target is within bounds (should be by logic, but safety)\n        if 1 <= r < rows - 1 and min(target_cols) <= c_tgt <= max(target_cols):\n             # Check if target pixel is NOT part of the original Z4 background\n             # Actually, the rule seems to be overwrite regardless, preserving only Z4 bg *implicitly*\n             # by only copying non-bg pixels from source. Let's stick to that.\n             output_grid[r, c_tgt] = color\n\n\n    # 5. Perform the modification operation (if applicable)\n    if modifier_zone_index == 3:\n        modifier_cols = ZONE_COLUMNS[modifier_zone_index]\n        target_cols = ZONE_COLUMNS[4] # Target is still Zone 4\n        col_offset_mod = min(target_cols) - min(modifier_cols)\n        modifier_bg = bg_z3 # Modifier is Zone 3\n\n        # We already have z3_pattern_pixels\n        # modifier_pattern_pixels = _get_pattern_pixels(input_grid, modifier_zone_index, modifier_bg, border_color)\n\n        for (r, c_mod), color in z3_pattern_pixels: # Use the already computed Z3 pattern\n             c_tgt = c_mod + col_offset_mod\n             # Ensure target is within bounds\n             if 1 <= r < rows - 1 and min(target_cols) <= c_tgt <= max(target_cols):\n                  # Overwrite with the modifier color (which must be green)\n                  output_grid[r, c_tgt] = color # color here must be MODIFIER_COLOR\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6091,
    "candidates_token_count": 2336,
    "total_token_count": 8427,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.902203
}