{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Initialize:** Start with the input grid. Create a working copy.\n2.  **Yellow Connection:**\n    *   Identify all Yellow (4) pixels in the current working grid.\n    *   For each row, find pairs of Yellow pixels.\n    *   If the horizontal path strictly between a pair of Yellow pixels on the same row consists only of White (0) pixels, fill that path with Yellow (4) in the working grid.\n    *   Repeat this connection process on the updated working grid until no more connections can be made in a full pass. Store this grid state (`grid_with_yellow_connections`).\n3.  **Source Identification and Mapping:**\n    *   Refer back to the *original* input grid. Identify all non-White (0) and non-Yellow (4) pixels. These are the \"expansion sources\".\n    *   Determine if any of these identified expansion sources are Magenta (6) (`has_magenta_source`).\n    *   Determine if the *original* input grid contains *any* Orange (7) pixels (not necessarily sources) (`has_orange_anywhere`).\n    *   Create a mapping for how source colors will expand:\n        *   If a source is Azure (8) AND `has_magenta_source` is true, it expands as Blue (1).\n        *   If a source is Magenta (6) AND `has_orange_anywhere` is true, it expands as Orange (7).\n        *   All other sources expand using their own original color.\n4.  **Simultaneous Expansion (BFS):**\n    *   Start a simultaneous Breadth-First Search (BFS) from all identified expansion sources on the `grid_with_yellow_connections`.\n    *   The BFS expands one step (Manhattan distance) at a time into adjacent cells.\n    *   **Expansion Condition:** A source can only expand into a cell `(nr, nc)` if that cell is White (0) in the `grid_with_yellow_connections` AND has not yet been reached or contested in the current BFS (`owner[nr, nc]` is `None`).\n    *   **Obstacles:** Expansion is blocked by grid boundaries and any cell that is not White (0) in the `grid_with_yellow_connections` or cells that become contested.\n    *   **Conflict Resolution:** If multiple *different* sources attempt to expand into the same valid White cell in the *same step* of the BFS, that cell becomes \"CONTESTED\", remains White (0) in the final output, and acts as an obstacle for subsequent steps.\n    *   **Coloring:** When a source successfully expands into a cell, that cell's ownership is recorded. The final coloring happens after the BFS completes.\n5.  **Output Construction:**\n    *   Start with the `grid_with_yellow_connections`.\n    *   Iterate through the grid. For each cell `(r, c)`:\n        *   If the cell was successfully claimed by a source during the BFS (`owner[r, c]` is a source coordinate tuple), color the cell in the final output grid using the color determined by the source's original color and the color mapping (Step 3).\n        *   Otherwise (if the cell was originally non-white, yellow-connected, contested, or never reached), it retains its color from `grid_with_yellow_connections`.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # 1. Initialize: Create a working copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Yellow Connection Phase\n    made_connection = True\n    while made_connection:\n        made_connection = False\n        current_grid_state = np.copy(output_grid) # Check against state at start of pass\n        for r in range(rows):\n            # Find yellow pixel indices in the current row of the working grid\n            yellow_indices = [c for c in range(cols) if current_grid_state[r, c] == 4]\n            if len(yellow_indices) >= 2:\n                for i in range(len(yellow_indices) - 1):\n                    c1 = yellow_indices[i]\n                    c2 = yellow_indices[i+1]\n                    # Check if path between c1 and c2 (exclusive) is all white (0) in the current grid state\n                    can_connect = True\n                    if c2 > c1 + 1: # Only check if there are cells between them\n                        for k in range(c1 + 1, c2):\n                            # Check the state at the START of this pass\n                            if current_grid_state[r, k] != 0:\n                                can_connect = False\n                                break\n                        if can_connect:\n                            # Fill the path with yellow (4) in the output_grid\n                            for k in range(c1 + 1, c2):\n                                # Ensure we only fill if it's currently white in the evolving output grid\n                                # This prevents overwriting fills made earlier in the same pass in the same row\n                                if output_grid[r, k] == 0:\n                                     output_grid[r, k] = 4\n                                     made_connection = True # Signal that a change occurred\n\n    # Store the grid state after yellow connections\n    grid_with_yellow_connections = np.copy(output_grid)\n\n    # 3. Source Identification and Mapping\n    sources = []\n    has_magenta_source = False\n    has_orange_anywhere = False\n    source_coords_colors = {} # Store original color at source coord: {(r, c): color}\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c] # Check ORIGINAL grid\n            if color != 0:\n                if color == 7:\n                    has_orange_anywhere = True # Check if orange exists anywhere in original\n                if color != 4: # Non-white, non-yellow are potential sources\n                    # Check if the source position still has its original color after yellow connection\n                    # (it might have been paved over if it was white between two yellows, which shouldn't happen for non-white sources)\n                    # We define sources based on the ORIGINAL grid, regardless of yellow connection overwrites.\n                    sources.append(((r, c), color))\n                    source_coords_colors[(r, c)] = color\n                    if color == 6:\n                        has_magenta_source = True # Check if any source is magenta\n\n    # Create the expansion color map based on original source colors\n    expansion_color_map = {}\n    unique_source_colors = {color for _, color in sources}\n    for color in unique_source_colors:\n        if color == 8 and has_magenta_source:\n            expansion_color_map[color] = 1 # Azure -> Blue\n        elif color == 6 and has_orange_anywhere:\n            expansion_color_map[color] = 7 # Magenta -> Orange\n        else:\n            expansion_color_map[color] = color # Other sources expand as themselves\n\n    # 4. Simultaneous Expansion Phase (BFS)\n    # distance: Stores the step count when a cell is reached. -1 means unreached.\n    # owner: Stores the coordinate tuple (sr, sc) of the source that reached the cell.\n    #        None means unreached/unowned. \"CONTESTED\" means multiple sources reached simultaneously.\n    distance = np.full((rows, cols), -1, dtype=int)\n    owner = np.full((rows, cols), None, dtype=object)\n    queue = deque()\n\n    # Initialize BFS queue and state grids with sources\n    for (r, c), _ in sources:\n         # Check if source position is still valid in grid_with_yellow_connections\n         # A source is still a source even if its *cell* was paved over by yellow,\n         # but it cannot expand *from* a yellow cell. It only starts expanding\n         # if its original location wasn't changed by yellow connections.\n         # If the source location *itself* became yellow, it cannot start expansion.\n         # Check if the source cell in grid_with_yellow_connections still holds the original color\n         if grid_with_yellow_connections[r,c] == input_grid[r,c]:\n              # Check if the source location is not contested from the start (shouldn't be)\n              if owner[r,c] is None:\n                 distance[r, c] = 0\n                 owner[r, c] = (r, c) # Owner is the coord tuple\n                 queue.append(((r, c), 0)) # ((row, col), dist)\n              # Handle potential source overlap (unlikely but possible if sources are adjacent)\n              # If already owned, it means two sources are at the same spot (impossible by definition)\n              # Or if adjacent sources try to claim each other in step 0 (also impossible)\n\n    # Main BFS loop processing level by level\n    current_dist = 0\n    while queue:\n        # Dictionary to track cells reached in this specific step for conflict detection\n        # Format: {(nr, nc): [originating_owner_coord1, originating_owner_coord2, ...]}\n        newly_reached_this_step = {}\n\n        # Peek distance of the first element to confirm the current level\n        if not queue: break\n        peek_dist = queue[0][1]\n        current_dist = peek_dist\n\n        # Process all elements belonging to the current distance level\n        processed_count_in_level = 0\n        while queue and queue[0][1] == current_dist:\n             (r, c), dist = queue.popleft()\n             processed_count_in_level += 1\n\n             # Get the owner coord tuple of the current cell expanding\n             current_owner_coord = owner[r, c]\n\n             # If the current cell became contested earlier, it cannot expand further\n             if not isinstance(current_owner_coord, tuple):\n                 continue\n\n             # Explore neighbors (Manhattan distance)\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n\n                 # Check bounds\n                 if 0 <= nr < rows and 0 <= nc < cols:\n                     # *** Expansion Condition ***\n                     # 1. Must be white (0) in the grid *after* yellow connections.\n                     # 2. Must be currently unreached (owner is None).\n                     #    (Cells reached in *previous* steps or marked CONTESTED won't have owner == None)\n                     if grid_with_yellow_connections[nr, nc] == 0 and owner[nr, nc] is None:\n                        # Record this reach attempt for conflict resolution after the level is processed\n                        if (nr, nc) not in newly_reached_this_step:\n                            newly_reached_this_step[(nr, nc)] = []\n                        # Only add unique owners reaching this cell in this step\n                        if current_owner_coord not in newly_reached_this_step[(nr, nc)]:\n                             newly_reached_this_step[(nr, nc)].append(current_owner_coord)\n\n\n        # End of step processing: Update owner/distance grids and queue based on newly_reached_this_step\n        next_level_dist = current_dist + 1\n        for (nr, nc), owners_reaching in newly_reached_this_step.items():\n            if len(owners_reaching) == 1:\n                 # Successfully claimed by exactly one owner in this step\n                 assigned_owner = owners_reaching[0]\n                 distance[nr, nc] = next_level_dist\n                 owner[nr, nc] = assigned_owner # Store the tuple coord of the owner source\n                 queue.append(((nr, nc), next_level_dist)) # Add to queue for next level\n            else:\n                 # Contested: Reached by multiple different sources in this step\n                 owner[nr, nc] = \"CONTESTED\"\n                 # Do not update distance (or set to a special value if needed, but owner is enough)\n                 # Crucially, do *not* add contested cells to the queue for further expansion.\n\n\n    # 5. Final Output Construction\n    # Start with the grid after yellow connections\n    final_output_grid = grid_with_yellow_connections\n    # Now fill in the expanded areas based on the BFS results\n    for r in range(rows):\n        for c in range(cols):\n            cell_owner = owner[r, c]\n            # Fill if owned by a non-contested source (owner is a tuple)\n            # No need to check if originally white, as only originally white cells\n            # could have been reached and assigned a tuple owner.\n            if isinstance(cell_owner, tuple):\n                sr, sc = cell_owner\n                # Get the original color of the source that owns this cell\n                original_source_color = source_coords_colors[(sr, sc)]\n                # Determine the fill color using the expansion map\n                fill_color = expansion_color_map.get(original_source_color, original_source_color) # Use map, fallback to original\n                final_output_grid[r, c] = fill_color\n            # If cell_owner is \"CONTESTED\" or None, the cell keeps its value\n            # from grid_with_yellow_connections (which would be 0 if it was potentially expandable,\n            # or its original/yellow color otherwise).\n\n    return final_output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10240,
    "candidates_token_count": 3116,
    "total_token_count": 13356,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.015894
}