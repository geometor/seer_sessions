{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nApplies gravity to whole objects in the input grid.\n\nIdentifies connected objects of non-background colors (anything other than azure - 8) \nusing 8-way connectivity. Each object falls downwards as a single unit, maintaining \nits shape. An object stops falling when any part of its bottom edge reaches the \nbottom of the grid or lands on top of any part of another object that has already \nsettled in the output grid. Objects do not move horizontally. The relative vertical \norder of pixels within an object is preserved, and the relative horizontal positions \nof objects are preserved. The output grid is initially filled with the background \ncolor (azure - 8), and the objects are drawn in their final settled positions. \nObjects higher up in the input grid are processed and settled first.\n\"\"\"\n\ndef find_components_bfs(grid, background_color):\n    \"\"\"\n    Finds connected components (objects) of non-background colors using 8-way \n    connectivity via Breadth-First Search (BFS).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (a set of (r, c) tuples of absolute\n              coordinates), 'rel_coords' (a set of (r, c) tuples relative to the\n              bounding box top-left), and 'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    # Iterate through each cell to find starting points of objects\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not background and hasn't been visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                coords = set() # Stores absolute coordinates of the object's pixels\n                q = deque([(r, c)]) # Queue for BFS using deque for efficiency\n                visited[r, c] = True\n                min_r, max_r = r, r # Bounding box limits\n                min_c, max_c = c, c\n\n                # Perform BFS\n                while q:\n                    row, col = q.popleft() # Use popleft for BFS\n                    coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check if neighbor is within grid bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # Check if neighbor is part of the same object and not visited\n                                if not visited[nr, nc] and grid[nr, nc] == obj_color:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                \n                # Calculate coordinates relative to the object's bounding box top-left\n                rel_coords = set((cr - min_r, cc - min_c) for cr, cc in coords)\n                \n                # Store the found object's properties\n                objects.append({\n                    'color': obj_color,\n                    'coords': coords, # Absolute coordinates in the original grid\n                    'rel_coords': rel_coords, # Coordinates relative to bbox top-left\n                    'bbox': (min_r, min_c, max_r, max_c) # Bounding box: top, left, bottom, right\n                })\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity simulation to non-background objects in the grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed grid with objects settled by gravity.\n    \"\"\"\n    background_color = 8 # Azure\n    height, width = input_grid.shape\n\n    # 1. Initialize the output grid with the background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 2. Identify all distinct non-background objects in the input grid\n    objects = find_components_bfs(input_grid, background_color)\n\n    # 3. Sort objects primarily by their top edge (min_r), then left edge (min_c).\n    # This ensures that objects higher up are processed and settled first,\n    # providing a stable base for objects potentially falling onto them.\n    # The secondary sort by left edge ensures deterministic order for objects at the same height.\n    objects.sort(key=lambda obj: (obj['bbox'][0], obj['bbox'][1]))\n\n    # 4. Process each object to determine its final position after falling\n    for obj in objects:\n        color = obj['color']\n        rel_coords = obj['rel_coords']\n        min_r, min_c, _, _ = obj['bbox'] # Original top-left position\n\n        # Determine the maximum distance the object can fall vertically\n        fall_distance = 0\n        while True:\n            # Assume it can fall one step further in the next iteration\n            can_fall_further = True\n            # Calculate the potential vertical offset for the *next* step down\n            next_r_offset = fall_distance + 1\n\n            # Check collision for every pixel of the object at the potential new position\n            for rel_r, rel_c in rel_coords:\n                # Calculate the target row and column in the grid for this pixel\n                # based on the original top-left corner and the potential next fall step\n                target_r = min_r + rel_r + next_r_offset\n                target_c = min_c + rel_c # Column remains the same\n\n                # Check 1: Collision with grid bottom\n                if target_r >= height:\n                    can_fall_further = False\n                    break # Cannot fall further, hit the bottom\n\n                # Check 2: Collision with another object already settled in the output grid\n                # Need to ensure target_c is also within bounds (though horizontal movement isn't happening, good practice)\n                if target_c < 0 or target_c >= width:\n                     # This case shouldn't happen if object identification is correct, but safety check\n                     can_fall_further = False\n                     break\n                \n                if output_grid[target_r, target_c] != background_color:\n                    can_fall_further = False\n                    break # Cannot fall further, hit another settled object\n\n            # If no collision was detected for any pixel at the next step down\n            if can_fall_further:\n                fall_distance += 1 # Increment the fall distance, try falling further\n            else:\n                # Collision detected or bottom reached, stop checking further fall.\n                # The current 'fall_distance' is the maximum possible.\n                break\n\n        # 5. Calculate the final top-left position of the object after falling\n        final_r = min_r + fall_distance\n        final_c = min_c # Object only moves vertically\n\n        # 6. Place the object onto the output grid at its final settled position\n        for rel_r, rel_c in rel_coords:\n            # Calculate the absolute row and column in the output grid\n            output_r = final_r + rel_r\n            output_c = final_c + rel_c\n            \n            # Ensure coordinates are within bounds before drawing (redundant check if logic is perfect, but safe)\n            if 0 <= output_r < height and 0 <= output_c < width:\n                 output_grid[output_r, output_c] = color\n            # else: # Optional: Handle or log error if pixel falls outside grid unexpectedly\n            #     print(f\"Warning: Pixel ({output_r}, {output_c}) out of bounds for object {obj['color']} from ({min_r},{min_c})\")\n\n\n    # 7. Return the final grid with all objects settled\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11030,
    "candidates_token_count": 1978,
    "total_token_count": 13008,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 90.638646
}