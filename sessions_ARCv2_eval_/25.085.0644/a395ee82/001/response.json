{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\n1. Determine the background color by finding the most frequent color in the input grid.\n2. Identify all connected objects (groups of same-colored, adjacent pixels) that are not the background color.\n3. Identify the 'pattern object' as the largest connected object found in step 2. Record its shape (pixel coordinates relative to its bounding box top-left), color, and bounding box.\n4. Identify the 'marker color' as the color of the smallest connected non-background object(s) found in step 2.\n5. Find the coordinates of all pixels in the input grid that have the 'marker color'. These are the 'marker locations'.\n6. Create a new output grid with the same dimensions as the input grid, filled entirely with the background color.\n7. Place the original 'pattern object' onto the output grid using its original bounding box coordinates.\n8. For each 'marker location' identified in step 5:\n    a. Calculate the center coordinates of the 'pattern object's' bounding box relative to its top-left corner (e.g., `center_row = height // 2`, `center_col = width // 2`).\n    b. Determine the target top-left coordinate on the output grid for placing the pattern, such that the pattern's calculated relative center aligns with the current 'marker location'. The target top-left is `(marker_row - center_row, marker_col - center_col)`.\n    c. Copy the pixels forming the 'pattern object' (using the relative coordinates from step 3) onto the output grid, starting at the calculated target top-left coordinate. Overwrite any existing pixels in the output grid during this copy operation, ensuring coordinates stay within grid bounds.\n9. The resulting grid is the final output.\n\"\"\"\n\ndef find_connected_objects(grid):\n    \"\"\"\n    Finds all connected objects in the grid.\n    Returns a dictionary where keys are object IDs (1-based) and\n    values are dictionaries containing 'color', 'coords', 'size', 'bbox'.\n    \"\"\"\n    unique_colors = np.unique(grid)\n    objects = {}\n    current_label = 0\n\n    for color in unique_colors:\n        # Create a binary mask for the current color\n        mask = (grid == color)\n        # Label connected components for this color\n        labeled_array, num_features = label(mask)\n\n        if num_features > 0:\n            # Find the locations (slices) of each labeled object\n            locations = find_objects(labeled_array)\n            for i in range(num_features):\n                obj_label = i + 1\n                obj_slice = locations[i]\n                # Extract coordinates within the bounding box slice\n                coords_in_slice = np.argwhere(labeled_array[obj_slice] == obj_label)\n                # Convert to absolute grid coordinates\n                abs_coords = coords_in_slice + np.array([obj_slice[0].start, obj_slice[1].start])\n\n                current_label += 1\n                objects[current_label] = {\n                    'color': color,\n                    'coords': abs_coords,\n                    'size': len(abs_coords),\n                    'bbox': obj_slice  # Store the slice directly\n                }\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Determine the background color\n    background_color = Counter(input_grid.flatten()).most_common(1)[0][0]\n\n    # 2. Identify all connected non-background objects\n    all_objects = find_connected_objects(input_grid)\n    non_background_objects = {\n        obj_id: obj_data\n        for obj_id, obj_data in all_objects.items()\n        if obj_data['color'] != background_color\n    }\n\n    if not non_background_objects:\n        # Handle case with no non-background objects (e.g., return input or background)\n        return input_grid.copy()\n\n    # 3. Identify the 'pattern object' (largest)\n    pattern_obj_id = max(non_background_objects, key=lambda k: non_background_objects[k]['size'])\n    pattern_obj = non_background_objects[pattern_obj_id]\n    pattern_color = pattern_obj['color']\n    pattern_bbox = pattern_obj['bbox']\n    pattern_coords_absolute = pattern_obj['coords']\n\n    # Calculate pattern shape relative to its bounding box top-left\n    pattern_bbox_top_left = np.array([pattern_bbox[0].start, pattern_bbox[1].start])\n    pattern_coords_relative = pattern_coords_absolute - pattern_bbox_top_left\n\n    # 4. Identify the 'marker color' (color of smallest object(s))\n    min_size = min(obj['size'] for obj in non_background_objects.values())\n    # Taking the first color found with min_size. Assumes consistency if multiple exist.\n    marker_color = next(obj['color'] for obj in non_background_objects.values() if obj['size'] == min_size)\n\n    # 5. Find the coordinates of all 'marker locations'\n    marker_locations = np.argwhere(input_grid == marker_color)\n\n    # 6. Create a new output grid filled with the background color\n    output_grid = np.full_like(input_grid, background_color)\n\n    # 7. Place the original 'pattern object' onto the output grid\n    for r, c in pattern_coords_absolute:\n        if 0 <= r < height and 0 <= c < width:\n             output_grid[r, c] = pattern_color\n\n    # 8. For each 'marker location', copy the pattern centered on it\n    # a. Calculate the relative center of the pattern's bounding box\n    bbox_height = pattern_bbox[0].stop - pattern_bbox[0].start\n    bbox_width = pattern_bbox[1].stop - pattern_bbox[1].start\n    center_dr = bbox_height // 2\n    center_dc = bbox_width // 2\n\n    for marker_r, marker_c in marker_locations:\n        # b. Determine the target top-left for placing the pattern\n        target_top_left_r = marker_r - center_dr\n        target_top_left_c = marker_c - center_dc\n\n        # c. Copy the pattern pixels relative to the target top-left\n        for rel_r, rel_c in pattern_coords_relative:\n            output_r = target_top_left_r + rel_r\n            output_c = target_top_left_c + rel_c\n\n            # Ensure the pixel is within the grid bounds before painting\n            if 0 <= output_r < height and 0 <= output_c < width:\n                output_grid[output_r, output_c] = pattern_color\n\n    # 9. Return the resulting grid\n    return output_grid.tolist() # Convert back to list of lists if needed by ARC environment\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8275,
    "candidates_token_count": 1670,
    "total_token_count": 9945,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 82.437951
}