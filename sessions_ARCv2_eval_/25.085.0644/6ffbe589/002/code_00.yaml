facts:
  - task_type: "cropping"
  - input_grids:
      - variable size, contain multiple disconnected objects/pixels of various colors (green, azure, magenta, gray, yellow, blue, red).
      - background is white (0).
  - output_grids:
      - smaller subgrids of the corresponding input grids.
      - retain the pixel colors and relative positions from the input within the cropped area.
  - relevant_object_identification:
      - The region to be cropped is determined by one of the connected components of non-white pixels in the input.
      - Specifically, it is the component whose bounding box (minimum enclosing rectangle) has the largest area (height * width).
      - Components are defined by contiguous non-white pixels using 8-way adjacency (including diagonals).
      - Isolated pixels or components with smaller bounding box areas are ignored and excluded from the output.
  - transformation:
      - step 1: Identify all connected components of non-white pixels in the input grid using 8-way adjacency.
      - step 2: For each component, calculate its bounding box (min_row, max_row, min_col, max_col).
      - step 3: Calculate the area of each bounding box (area = (max_row - min_row + 1) * (max_col - min_col + 1)).
      - step 4: Select the component whose bounding box has the maximum area. If there's a tie, the specific tie-breaking rule isn't explicitly clear from these examples, but the first one found might suffice, or rules like top-most, left-most could apply. (Assuming no ties for now).
      - step 5: Determine the coordinates (min_r, max_r, min_c, max_c) of the selected bounding box.
      - step 6: Extract the subgrid from the input grid corresponding to these coordinates: `input[min_r : max_r + 1, min_c : max_c + 1]`. This subgrid is the output.