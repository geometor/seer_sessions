{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies the background color as the most frequent color in the input grid.\nFinds all contiguous objects composed of non-background colors.\nDetermines the largest object based on the number of pixels; this is designated as the 'frame'.\nCalculates the bounding box of this frame object.\nCreates an output grid with the dimensions of the frame's bounding box.\nPopulates the output grid by iterating through the corresponding area in the input grid (defined by the bounding box).\nFor each position within the bounding box:\n  - If the pixel in the input grid is the background color, the corresponding pixel in the output grid is set to the frame's color.\n  - If the pixel in the input grid is not the background color (i.e., it's part of the frame or another object within the bounds), its original color is copied to the corresponding pixel in the output grid.\nReturns the resulting output grid.\n\"\"\"\n\n# Helper function to find connected objects\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n    Uses Breadth-First Search (BFS) for connected components.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color to ignore.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object\n              and contains (color, set_of_coordinates).\n              Returns an empty list if the grid is empty or contains no non-background pixels.\n    \"\"\"\n    if grid.size == 0:\n        return []\n\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find an unvisited, non-background pixel\n            if not visited[r, c] and grid[r, c] != background_color:\n                object_color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor has the same color and hasn't been visited\n                            if not visited[nr, nc] and grid[nr, nc] == object_color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                current_object_pixels.add((nr, nc))\n\n                # Add the found object (color and its pixel coordinates) to the list\n                if current_object_pixels:\n                    objects.append((object_color, current_object_pixels))\n\n    return objects\n\n# Helper function to get the bounding box of an object\ndef get_bounding_box(object_pixels):\n    \"\"\"\n    Calculates the minimum bounding box containing all pixels of an object.\n\n    Args:\n        object_pixels (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) defining the bounding box.\n               Returns None if the input set is empty.\n    \"\"\"\n    if not object_pixels:\n        return None\n\n    # Extract all row and column coordinates\n    rows = [r for r, c in object_pixels]\n    cols = [c for r, c in object_pixels]\n\n    # Find the min and max row and column indices\n    min_r = min(rows)\n    max_r = max(rows)\n    min_c = min(cols)\n    max_c = max(cols)\n\n    return min_r, max_r, min_c, max_c\n\n# Main transformation function\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying a 'frame' object, extracting its\n    bounding box, and replacing the background within that box with the frame's color.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid, cropped to the frame's bounding box.\n                       Returns an empty list of lists if no non-background objects are found.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid\n    if input_grid_np.size == 0:\n        return [[]] \n        \n    rows, cols = input_grid_np.shape\n\n    # 1. Identify the background color (most frequent color)\n    colors, counts = np.unique(input_grid_np, return_counts=True)\n    if len(colors) == 0: # Should not happen if size > 0, but defensive check\n         return [[]]\n    background_color = colors[np.argmax(counts)]\n\n    # Handle case where the grid is entirely one color (background)\n    if len(colors) == 1:\n        # Undefined what to do here. Let's return an empty grid based on observations.\n        # If the single color isn't 0, it might still be considered a frame?\n        # The examples suggest we need a distinct frame *and* background.\n        # If it's all background, there's no frame.\n        return [[]] \n\n    # 2. Find all contiguous non-background objects\n    objects = find_objects(input_grid_np, background_color)\n\n    # Handle case where no non-background objects are found\n    if not objects:\n         return [[]] # Return empty grid if only background exists\n\n    # 3. Identify the largest object (the \"frame\") by pixel count\n    # If multiple objects have the same max size, the first one found is taken.\n    largest_object = max(objects, key=lambda obj: len(obj[1]))\n    frame_color, frame_pixels = largest_object\n\n    # 4. Calculate the bounding box of the frame object\n    bounding_box = get_bounding_box(frame_pixels)\n    # This check should be redundant if objects list wasn't empty, but for safety:\n    if bounding_box is None:\n        return [[]] \n\n    min_r, max_r, min_c, max_c = bounding_box\n\n    # 5. Determine the dimensions of the output grid (size of the bounding box)\n    output_height = max_r - min_r + 1\n    output_width = max_c - min_c + 1\n\n    # 6. Create the output grid, initialized with the frame's color\n    # We will overwrite pixels that are not background in the original input\n    output_grid = np.full((output_height, output_width), frame_color, dtype=int)\n\n    # 7. Iterate through the input grid within the bounding box area\n    for r_out in range(output_height):\n        for c_out in range(output_width):\n            # Calculate corresponding coordinates in the input grid\n            r_in = min_r + r_out\n            c_in = min_c + c_out\n\n            # Get the color of the pixel from the input grid\n            input_pixel_color = input_grid_np[r_in, c_in]\n\n            # 8. Apply the transformation rule:\n            # If the input pixel is NOT the background color, copy its color\n            # to the output grid. Otherwise, the output grid retains the\n            # frame_color it was initialized with.\n            if input_pixel_color != background_color:\n                output_grid[r_out, c_out] = input_pixel_color\n\n    # 9. Return the resulting grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7653,
    "candidates_token_count": 1899,
    "total_token_count": 9552,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.542003
}