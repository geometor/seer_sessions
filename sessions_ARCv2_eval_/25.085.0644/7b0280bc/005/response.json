{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Identify Background and Inside Regions:**\n    *   The background color (`bg_color`) is determined from the top-left pixel.\n    *   A flood fill is performed starting from all `bg_color` pixels on the grid borders. All reachable `bg_color` pixels are marked as 'outside'.\n    *   Pixels that are not `bg_color` and not marked 'outside' are considered 'inside'.\n\n2.  **Determine Trigger Color:**\n    *   Based on the `bg_color`, a specific `trigger_color` is identified:\n        *   If `bg_color` is Azure (8), `trigger_color` is White (0).\n        *   If `bg_color` is Maroon (9), `trigger_color` is Yellow (4).\n        *   If `bg_color` is Orange (7), `trigger_color` is Magenta (6).\n        *   Otherwise, no trigger color is defined.\n\n3.  **Identify Inside Objects:**\n    *   Contiguous groups of pixels within the 'inside' region that share the same color (using 4-directional adjacency) are identified as objects. Each object stores its color and the set of coordinates it occupies.\n\n4.  **Identify Trigger Pixels:**\n    *   All pixels in the input grid having the `trigger_color` are identified.\n\n5.  **Check and Transform Objects:**\n    *   For each 'inside' object:\n        a.  **Adjacency Check:** Determine if the object is adjacent (including diagonals, i.e., 8-directional adjacency) to *any* pixel identified as a `trigger_pixel`.\n        b.  **Shape Check:** If adjacent to a trigger pixel, determine the shape of the object by calculating its bounding box dimensions (height, width) and the number of pixels it contains. Check if it's a line/dot (height=1 or width=1) or a 2x2 square (height=2, width=2, and 4 pixels).\n        c.  **Transformation Rules:** Apply color changes to *all* pixels of the object if it meets the adjacency condition AND its color and shape match the rules defined by the `bg_color`:\n            *   **BG=8 (Azure), Trigger=0 (White):**\n                *   White(0) line/dot object -> Gray(5)\n                *   Red(2) 2x2 object -> Green(3)\n            *   **BG=9 (Maroon), Trigger=4 (Yellow):**\n                *   Yellow(4) line/dot object -> Gray(5)\n                *   Orange(7) 2x2 object -> Green(3)\n            *   **BG=7 (Orange), Trigger=6 (Magenta):**\n                *   Magenta(6) line/dot object -> Gray(5)\n                *   Blue(1) 2x2 object -> Green(3)\n        d.  **Update Output:** If a transformation rule applies, update the corresponding pixels in the output grid with the new color.\n\n6.  **Return Output Grid:** The final modified grid is returned.\n\"\"\"\n\nimport collections\nimport copy\n\ndef _find_outside_pixels(grid, bg_color):\n    \"\"\"Performs flood fill from borders to mark outside background pixels.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    is_outside = [[False for _ in range(cols)] for _ in range(rows)]\n    q = collections.deque()\n\n    # Seed queue with border background pixels\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not is_outside[r][c] and grid[r][c] == bg_color:\n                is_outside[r][c] = True\n                q.append((r, c))\n    for c in range(1, cols - 1):\n        for r in [0, rows - 1]:\n            if not is_outside[r][c] and grid[r][c] == bg_color:\n                is_outside[r][c] = True\n                q.append((r, c))\n\n    # Flood fill\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not is_outside[nr][nc] and grid[nr][nc] == bg_color:\n                is_outside[nr][nc] = True\n                q.append((nr, nc))\n    return is_outside\n\ndef _find_inside_objects(grid, bg_color, is_outside):\n    \"\"\"Finds all contiguous objects within the 'inside' region.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = copy.deepcopy(is_outside) # Start visited with outside pixels\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If not visited and not background -> potential start of an inside object\n            if not visited[r][c] and grid[r][c] != bg_color:\n                obj_color = grid[r][c]\n                obj_coords = set()\n                q = collections.deque([(r, c)])\n                visited[r][c] = True\n                \n                # BFS to find all connected pixels of the same color (4-connectivity)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_coords.add((curr_r, curr_c))\n                    \n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr][nc] and grid[nr][nc] == obj_color:\n                            visited[nr][nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                   objects.append({'color': obj_color, 'coords': obj_coords})\n                   \n    return objects\n\ndef _is_adjacent(obj_coords, trigger_pixels, rows, cols):\n    \"\"\"Checks if any pixel in obj_coords is 8-directionally adjacent to a trigger pixel.\"\"\"\n    for r, c in obj_coords:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in trigger_pixels:\n                    return True\n    return False\n\ndef _get_object_shape(obj_coords):\n    \"\"\"Determines if an object is a line/dot or a 2x2 square.\"\"\"\n    if not obj_coords:\n        return False, False\n\n    min_r = min(r for r, c in obj_coords)\n    max_r = max(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    max_c = max(c for r, c in obj_coords)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    num_pixels = len(obj_coords)\n\n    is_line_dot = (height == 1 or width == 1)\n    is_2x2 = (height == 2 and width == 2 and num_pixels == 4)\n\n    return is_line_dot, is_2x2\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying inside objects, checking their adjacency\n    to trigger pixels, analyzing their shape, and applying specific color changes.\n    \"\"\"\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    if rows == 0 or cols == 0:\n        return []\n\n    # 1. Determine background color\n    bg_color = input_grid[0][0]\n\n    # 2. Determine Trigger Color based on background\n    trigger_color = -1 # Default value if no rule matches\n    if bg_color == 8: trigger_color = 0 # white\n    elif bg_color == 9: trigger_color = 4 # yellow\n    elif bg_color == 7: trigger_color = 6 # magenta\n\n    # 3. Create the output grid\n    output_grid = copy.deepcopy(input_grid)\n\n    # 4. Find 'outside' background pixels\n    is_outside = _find_outside_pixels(input_grid, bg_color)\n\n    # 5. Find all 'inside' objects\n    inside_objects = _find_inside_objects(input_grid, bg_color, is_outside)\n\n    # 6. Identify all trigger pixels in the grid\n    trigger_pixels = set()\n    if trigger_color != -1:\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == trigger_color:\n                    trigger_pixels.add((r, c))\n\n    # 7. Iterate through objects, check conditions, and apply transformations\n    for obj in inside_objects:\n        obj_color = obj['color']\n        obj_coords = obj['coords']\n\n        # Check adjacency to any trigger pixel (8-connectivity)\n        is_adj = _is_adjacent(obj_coords, trigger_pixels, rows, cols)\n\n        if is_adj:\n            # Determine object shape\n            is_line_dot, is_2x2 = _get_object_shape(obj_coords)\n\n            # Apply transformation rules\n            new_color = obj_color # Default: no change\n            if bg_color == 8:  # Azure background, Trigger White(0)\n                if obj_color == 0 and is_line_dot: new_color = 5  # white -> gray\n                elif obj_color == 2 and is_2x2: new_color = 3  # red -> green\n            elif bg_color == 9:  # Maroon background, Trigger Yellow(4)\n                if obj_color == 4 and is_line_dot: new_color = 5  # yellow -> gray\n                elif obj_color == 7 and is_2x2: new_color = 3  # orange -> green\n            elif bg_color == 7:  # Orange background, Trigger Magenta(6)\n                if obj_color == 6 and is_line_dot: new_color = 5  # magenta -> gray\n                elif obj_color == 1 and is_2x2: new_color = 3  # blue -> green\n\n            # Update the output grid if the color changed\n            if new_color != obj_color:\n                for r, c in obj_coords:\n                    output_grid[r][c] = new_color\n\n    # 8. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8910,
    "candidates_token_count": 2595,
    "total_token_count": 11505,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 170.565891
}