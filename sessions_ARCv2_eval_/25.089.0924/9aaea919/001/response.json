{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nThis module transforms input grids according to specific rules based on object shape and color.\n\nTransformation Rules:\n1. Identify the background color (most frequent color).\n2. Find all distinct, contiguous objects of non-background colors.\n3. Analyze each object based on its size (pixel count) and color:\n    a. Objects with 13 pixels ('diamond' shape) are removed (replaced by the background color).\n    b. Objects with 9 pixels ('plus_sign' shape) are processed as follows:\n        i. If the color is maroon(9), magenta(6), or green(3), change the object's color to gray(5).\n        ii. If the color is orange(7), remove the object (replace with background color).\n        iii. If the color is white(0) AND the background color is magenta(6), remove the object.\n        iv. Otherwise (blue(1), yellow(4), azure(8), red(2), or white(0) with non-magenta background), the object remains unchanged.\n4. The background and any objects not matching the above criteria remain unchanged.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color of the grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object\n              and contains (color, list_of_pixel_coordinates).\n              Example: [(3, [(1,1), (1,2), (2,1)]) , ...]\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background and not visited, start a search (BFS)\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    # Only add pixels that actually belong to this object\n                    if grid[row, col] == color:\n                         obj_pixels.append((row, col))\n                         # Explore neighbors (up, down, left, right)\n                         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            # Check boundaries, if neighbor has the same color, and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                            grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    # else: # This pixel belongs to a different object or background, but was visited because it was adjacent to a previous queue item. Ignore it for this object.\n                    #    pass\n                \n                # Check if any pixels were actually added (handles edge cases where initial pixel doesn't match color?)\n                if obj_pixels:\n                     objects.append((color, obj_pixels))\n            \n            # Mark background pixels as visited to avoid starting searches from them\n            elif grid[r,c] == background_color:\n                 visited[r,c] = True\n\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformations to objects in the input grid based on their shape (pixel count) and color.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify the background color\n    # Flatten the grid, count occurrences, find the most common\n    colors, counts = np.unique(grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find all distinct objects\n    objects = find_objects(grid, background_color)\n\n    # 3. Iterate through objects and apply rules\n    for color, pixels in objects:\n        size = len(pixels)\n        \n        # Rule 3a: Remove 13-pixel objects (diamonds)\n        if size == 13:\n            for r, c in pixels:\n                output_grid[r, c] = background_color\n        \n        # Rule 3b: Process 9-pixel objects (plus signs)\n        elif size == 9:\n            # Rule 3b.i: Recolor maroon(9), magenta(6), green(3) to gray(5)\n            if color in [9, 6, 3]:\n                for r, c in pixels:\n                    output_grid[r, c] = 5 # Gray\n            # Rule 3b.ii: Remove orange(7)\n            elif color == 7:\n                for r, c in pixels:\n                    output_grid[r, c] = background_color\n            # Rule 3b.iii: Remove white(0) if background is magenta(6)\n            elif color == 0 and background_color == 6:\n                 for r, c in pixels:\n                    output_grid[r, c] = background_color\n            # Rule 3b.iv: Otherwise (blue(1), yellow(4), azure(8), red(2), or white(0) with non-magenta bg), leave unchanged.\n            # No action needed here as output_grid is a copy initially.\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13153,
    "candidates_token_count": 1382,
    "total_token_count": 14535,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.860818,
  "retries": 1
}