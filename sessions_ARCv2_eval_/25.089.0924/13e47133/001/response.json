{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the boundary color (Red=2) and the background color (the most frequent color in the input excluding Red=2).\n2.  Create the output grid as a copy of the input grid.\n3.  Find distinct connected regions of non-boundary pixels in the input grid using BFS, treating boundary pixels as walls.\n4.  For each region:\n    a.  Identify all \"source pixels\" within the region in the *input* grid. A source pixel is neither the background color nor the boundary color.\n    b.  If the region contains source pixels:\n        i.  For each pixel within the region's coordinates in the *output* grid:\n            - Calculate the Manhattan distance to all source pixels belonging to this region.\n            - Find the minimum distance.\n            - Identify all source pixels at this minimum distance.\n            - Apply tie-breaking: select the source pixel with the minimum row index, then the minimum column index among those tied for minimum distance.\n            - Set the output grid pixel's color to the color of the selected source pixel.\n    c.  If the region contains no source pixels, its pixels in the output grid remain unchanged from the initial copy.\n5.  Return the modified output grid.\n\"\"\"\n\ndef get_background_color(grid, boundary_color=2):\n    \"\"\"Finds the most frequent color in the grid, excluding the boundary color.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    max_count = 0\n    background = 0 # Default background\n    # Find the most frequent non-boundary color\n    found_non_boundary = False\n    sorted_indices = np.argsort(-counts) # Sort counts descending\n\n    for idx in sorted_indices:\n        color = colors[idx]\n        if color != boundary_color:\n             background = color\n             found_non_boundary = True\n             break\n             \n    # If only boundary color exists, pick 0 as default, although this case might not matter\n    # based on the logic as no regions would be processed. If other colors exist but only\n    # boundary and sources, pick the most frequent source as background? No, the prompt\n    # implied a dominant background. Let's stick to the most frequent non-boundary.\n    # If no non-boundary color exists, the concept of background might be irrelevant.\n    # Let's assume a background always exists if there are non-boundary pixels.\n    # If the grid contains only boundary cells, this function might return 0 or the boundary color itself.\n    # Check the first non-boundary color found.\n    if not found_non_boundary and len(colors) > 0:\n         # Handle cases where only boundary color exists or something unexpected\n         # Pick the smallest color value as a fallback if needed, or 0.\n         non_boundary_colors = colors[colors != boundary_color]\n         if len(non_boundary_colors) > 0:\n             background = np.min(non_boundary_colors) # Fallback strategy\n         else:\n             background = 0 # Default if truly only boundary color\n\n    return background\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described region-filling transformation based on closest source pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = input_np.shape\n    boundary_color = 2\n    background_color = get_background_color(input_np, boundary_color)\n    visited = np.zeros_like(input_np, dtype=bool)\n\n    # Iterate through each cell to find the start of a new region\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is not a boundary and hasn't been visited yet, start BFS\n            if input_np[r, c] != boundary_color and not visited[r, c]:\n                region_coords = []\n                region_sources = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                # Perform BFS to find all cells in the current connected region\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    region_coords.append((curr_r, curr_c))\n\n                    # Check if the current cell is a source pixel\n                    pixel_color = input_np[curr_r, curr_c]\n                    if pixel_color != background_color and pixel_color != boundary_color:\n                        region_sources.append((curr_r, curr_c, pixel_color))\n\n                    # Explore neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds and if neighbor is valid (not boundary, not visited)\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           input_np[nr, nc] != boundary_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # After finding all cells and sources for the region, fill it if sources exist\n                if region_sources:\n                    for reg_r, reg_c in region_coords:\n                        min_dist = float('inf')\n                        closest_sources = []\n\n                        # Calculate distance to all sources in this region\n                        for src_r, src_c, src_color in region_sources:\n                            dist = manhattan_distance((reg_r, reg_c), (src_r, src_c))\n                            if dist < min_dist:\n                                min_dist = dist\n                                closest_sources = [(src_r, src_c, src_color)]\n                            elif dist == min_dist:\n                                closest_sources.append((src_r, src_c, src_color))\n\n                        # Apply tie-breaking rule (min row, then min col)\n                        if closest_sources:\n                            closest_sources.sort(key=lambda x: (x[0], x[1])) # Sort by row, then col\n                            winning_source_color = closest_sources[0][2]\n                            output_grid[reg_r, reg_c] = winning_source_color\n                # If region_sources is empty, the output_grid pixels retain their original input value (copied initially)\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5593,
    "candidates_token_count": 1573,
    "total_token_count": 7166,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.653615,
  "retries": 1
}