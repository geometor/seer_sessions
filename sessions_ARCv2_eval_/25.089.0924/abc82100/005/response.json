{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on a hierarchical set of rules:\n\n1.  Vertical Red Line Rule: If a contiguous vertical line of Red (2) pixels exists spanning the grid's height at column 'c':\n    - Create a new white (0) output grid.\n    - Fill the area in the output grid to the left of the line (columns < c) with Red (2).\n    - Fill the column 'c' in the output grid with Blue (1).\n    - Leave the area to the right (columns > c) as white (0).\n    This rule takes precedence over all others.\n\n2.  Azure Presence Rule: If no vertical Red line is found, check if Azure (8) is present in the input grid.\n    - If Azure (8) is NOT present: Return a copy of the input grid.\n    - If Azure (8) IS present:\n        a. Count the frequency of all non-white (0) and non-azure (8) colors.\n        b. If no such colors exist (only white and/or azure present): Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n        c. If other colors exist, find the Most Frequent Color (MFC) among them. If counts are tied, the color with the lower numerical value is chosen.\n        d. Apply transformation based on MFC:\n            - If MFC is Blue (1):\n                i. Find all contiguous Blue (1) objects using 8-way adjacency (including diagonals).\n                ii. Identify the largest Blue object by pixel count.\n                iii. Create a new output grid filled entirely with white (0).\n                iv. Draw the shape of the largest Blue object onto the output grid using Red (2).\n            - If MFC is Magenta (6):\n                i. Create an intermediate grid, initially filled with white (0).\n                ii. Populate the intermediate grid based on the input grid: Input Red(2)->Output Yellow(4), Input Yellow(4)->Output Red(2). All other input colors (including Azure, Magenta, Orange) result in white(0).\n                iii. Initialize the final output grid as a copy of this intermediate grid.\n                iv. Iterate through the *original input* grid rows 0 to height-2. For each pixel (r, c):\n                   - If input(r, c) is Magenta(6) AND input(r+1, c) is white(0), set *final output*(r+1, c) to Orange(7).\n                   - If input(r, c) is Orange(7) AND input(r+1, c) is white(0), set *final output*(r+1, c) to Magenta(6).\n            - If MFC is Yellow (4):\n                i. Initialize the output grid filled entirely with white (0).\n                ii. Iterate through the input grid (r, c):\n                   - If input(r, c) is Yellow(4): Set the 2x2 block in the output grid starting at (r, c) to Red(2) (output[r:r+2, c:c+2] = 2), respecting boundary conditions.\n                   - If input(r, c) is Blue(1): Set output(r, c) = 7 and output(r+1, c+1) = 7, respecting boundary conditions.\n            - If MFC is any other color: (Fallback based on observed Azure removal) Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n\n3.  Default Rule: If no vertical Red line is found AND Azure (8) is not present, return the input grid unchanged (handled by step 2).\n\"\"\"\n\n\ndef find_objects(grid, color, adjacency=8):\n    \"\"\"Finds all contiguous objects of a given color using specified adjacency.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    # Define neighbor offsets based on adjacency\n    if adjacency == 8:\n        neighbor_deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else: # Default to 4-way\n        neighbor_deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Iterate through each pixel\n    for r in range(height):\n        for c in range(width):\n            # If pixel matches color and hasn't been visited, start BFS\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check neighbors\n                    for dr, dc in neighbor_deltas:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor matches color and is unvisited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                # Add found object coordinates to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef find_vertical_line_column(grid, color):\n    \"\"\"Checks for a vertical line of a specific color spanning the full height\n       and returns its column index, or None if not found.\"\"\"\n    height, width = grid.shape\n    if height == 0: return None # Handle empty grid\n\n    # Check each column\n    for c in range(width):\n        is_line = True\n        # Check each row in the current column\n        for r in range(height):\n            if grid[r, c] != color:\n                is_line = False\n                break\n        # If all pixels in the column match the color, return the column index\n        if is_line:\n            return c\n    return None # No full vertical line found\n\ndef get_color_counts(grid):\n    \"\"\"Counts the frequency of non-white (0) and non-azure (8) colors.\"\"\"\n    counts = Counter()\n    if grid.size == 0: return counts # Handle empty grid\n    # Iterate through all pixels\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            # Count only if not white and not azure\n            if color != 0 and color != 8:\n                counts[color] += 1\n    return counts\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the presence of a vertical red line\n    or the most frequent color alongside azure.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    if height == 0 or width == 0: # Handle empty input\n        return []\n\n    # 1. Check for Vertical Red Line (Rule 1)\n    red_line_col = find_vertical_line_column(input_grid_np, 2)\n    if red_line_col is not None:\n        # Initialize output grid as white\n        output_grid = np.zeros_like(input_grid_np)\n        # Fill left side with Red (2)\n        if red_line_col > 0:\n            output_grid[:, :red_line_col] = 2\n        # Change line itself to Blue (1)\n        output_grid[:, red_line_col] = 1\n        # Right side remains white (0) - already initialized\n        return output_grid.tolist()\n\n    # 2. Check for Azure (8) (Rule 2)\n    if 8 not in input_grid_np:\n        # If no Azure, return input unchanged (Rule 2 - no azure case)\n        return input_grid_np.tolist()\n    else:\n        # Azure is present, proceed with Azure rules\n        color_counts = get_color_counts(input_grid_np)\n\n        # 2.b Handle cases where only white and/or azure exist\n        if not color_counts:\n             # Change Azure to white and return\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n        # 2.c Find MFC (highest count, lowest color value tie-breaker)\n        mfc = -1\n        max_count = -1\n        # Iterate through sorted colors to handle tie-breaking correctly\n        for color in sorted(color_counts.keys()):\n            count = color_counts[color]\n            if count > max_count:\n                max_count = count\n                mfc = color\n            # Tie-breaking is implicitly handled by iterating in ascending color order\n\n        # Check if a valid MFC was found (should always be true if color_counts is not empty)\n        if mfc == -1:\n             # Fallback: should not happen based on logic, but safest to just clear azure\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n\n        # 2.d Apply transformation based on MFC\n\n        # MFC is Blue (1)\n        if mfc == 1:\n            # Find largest blue object using 8-way adjacency\n            blue_objects = find_objects(input_grid_np, 1, adjacency=8)\n            if not blue_objects:\n                # Fallback if no blue objects found despite MFC being blue\n                 output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n                 return output_grid.tolist()\n\n            # Find the object with the maximum number of pixels\n            largest_blue_object = max(blue_objects, key=len)\n            # Initialize output grid as white\n            output_grid = np.zeros_like(input_grid_np)\n            # Draw the largest blue object's shape in Red\n            for r, c in largest_blue_object:\n                output_grid[r, c] = 2\n            return output_grid.tolist()\n\n        # MFC is Magenta (6)\n        elif mfc == 6:\n            # Create intermediate grid with initial swaps (Red<->Yellow)\n            intermediate_grid = np.zeros_like(input_grid_np)\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 2: intermediate_grid[r, c] = 4 # Red -> Yellow\n                    elif color == 4: intermediate_grid[r, c] = 2 # Yellow -> Red\n                    # Other colors (0, 1, 3, 5, 6, 7, 8, 9) result in 0\n\n            # Copy intermediate to final output\n            output_grid = np.array(intermediate_grid)\n\n            # Apply row duplication logic based on *original* input\n            for r in range(height - 1): # Iterate up to second to last row\n                for c in range(width):\n                    input_color = input_grid_np[r, c]\n                    below_input_color = input_grid_np[r + 1, c]\n\n                    # Check condition for Magenta->Orange effect\n                    if input_color == 6 and below_input_color == 0:\n                        output_grid[r + 1, c] = 7 # Color below Orange in output\n                    # Check condition for Orange->Magenta effect\n                    elif input_color == 7 and below_input_color == 0:\n                        output_grid[r + 1, c] = 6 # Color below Magenta in output\n\n            return output_grid.tolist()\n\n        # MFC is Yellow (4)\n        elif mfc == 4:\n            # Initialize output grid as white\n            output_grid = np.zeros_like(input_grid_np)\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    # Yellow -> 2x2 Red block\n                    if color == 4:\n                        # Apply 2x2 block, checking bounds for each cell\n                        if r + 1 < height and c + 1 < width:\n                            output_grid[r:r+2, c:c+2] = 2\n                        else: # Handle edge cases where 2x2 doesn't fit\n                            if r < height and c < width: output_grid[r, c] = 2\n                            if r + 1 < height and c < width: output_grid[r+1, c] = 2\n                            if r < height and c + 1 < width: output_grid[r, c+1] = 2\n                            if r + 1 < height and c + 1 < width: output_grid[r+1, c+1] = 2\n\n                    # Blue -> Orange pair\n                    elif color == 1:\n                        # Set (r,c) to Orange, checking bounds\n                        if r < height and c < width:\n                             output_grid[r, c] = 7\n                        # Set (r+1, c+1) to Orange, checking bounds\n                        if r + 1 < height and c + 1 < width:\n                             output_grid[r + 1, c + 1] = 7\n                    # Other colors (including Azure, Red, Orange etc.) remain white (0)\n            return output_grid.tolist()\n\n        # MFC is any other color (Fallback)\n        else:\n             # Default action for other MFCs: just remove Azure\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n    # This part should theoretically not be reached due to exhaustive checks above\n    # but as a final safety, return the original grid if somehow missed.\n    return input_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21402,
    "candidates_token_count": 3288,
    "total_token_count": 24690,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.50342,
  "retries": 1
}