
## train_1

**input:**
```
1 1 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 4 8 8 1 8 1 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8
1 1 4 4 8 8 1 1 1 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 2 8 2 8 4 8 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 8 4 8 8 2 2 2 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 8 8 8 8 2 8 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 8 4 8 8 8 8 8 8 2 2 2 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 2 8 2 8 4 8 4 8 4 8 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 8 4 8 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
2 2 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 4 1 1 2 2 2 2 1 3 3 3 3 1 1 6 6 6 6 1 1
2 2 4 4 1 1 2 2 2 2 1 1 3 3 1 1 1 6 6 1 1 1 1
1 1 1 1 1 1 2 1 2 2 1 3 3 3 3 1 1 6 6 1 1 1 1
3 3 8 8 1 1 2 1 2 2 1 3 1 1 3 1 1 6 6 6 6 1 1
3 3 3 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 3 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
6 6 7 7 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
6 6 6 7 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
6 6 7 7 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 1 1 1 1 8 8 1 1 5
5 1 4 1 4 4 1 7 7 1 1 1 8 8 8 8 1 5
5 1 4 1 4 4 1 7 7 7 7 1 8 1 1 8 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 1 8 8 1 1 4 4 4 4 1 7 7 1 1 1 5
5 1 8 8 8 8 1 4 1 4 4 1 7 7 1 1 1 5
5 1 8 1 1 8 1 4 1 4 4 1 7 7 7 7 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```

Okay, let's analyze the provided training example (`train_1`) for the task.

**Perception**

1.  **Input Structure:** The input grid contains distinct regions. There's an upper section with scattered shapes (blue, yellow, green, red) on an azure background, and a lower section dominated by a large rectangular frame made of gray pixels. Inside this frame, the background is azure, and there are several 'T'-shaped objects composed of green or blue pixels, arranged in rows.
2.  **Output Structure:** The output grid is smaller than the input grid. It consists solely of a gray frame identical in shape and size to the *inner* dimensions of the input frame's content area plus the frame itself. Inside the output frame, the background is azure, and there are specific 3x3 patterns of red or yellow pixels placed at positions corresponding to where the 'T' shapes were in the input frame.
3.  **Transformation Focus:** The transformation appears to isolate the content within the gray frame of the input, discard everything outside it, and then map specific input objects within the frame to fixed output patterns while preserving the frame and the internal background color.
4.  **Object Mapping:** The 3x3 areas containing green 'T' shapes in the input map to a specific 3x3 red pattern in the output. The 3x3 areas containing blue 'T' shapes in the input map to a specific 3x3 yellow pattern in the output. The relative positions of these patterns are maintained within the frame. The exact shape of the input 'T' (upright, rotated) does not seem to affect the resulting output pattern, only the color (green or blue) matters.
5.  **Color Mapping:** Input Green (3) -> Output Red (2) pattern. Input Blue (1) -> Output Yellow (4) pattern. The patterns themselves also use the background color (azure=8).

**Facts**


```yaml
Input:
  Grid:
    - Size: Variable (e.g., 23x24 in train_1)
    - Background: Can vary (azure=8 in train_1 example area)
    - Objects:
      - Frame:
        - Color: Gray (5)
        - Shape: Rectangle
        - Role: Defines the area of interest.
      - Content_Objects (inside frame):
        - Type: Small (e.g., 3x3) blocks containing specific key colors (Green=3, Blue=1 in train_1) potentially mixed with the background color (Azure=8).
        - Arrangement: Placed at various locations within the frame on the background color.
      - External_Objects (outside frame):
        - Type: Various shapes and colors.
        - Role: Ignored in the transformation.
      - Content_Background:
        - Color: The dominant color inside the frame (Azure=8 in train_1).
Output:
  Grid:
    - Size: Determined by the dimensions of the input gray frame.
    - Objects:
      - Frame:
        - Color: Gray (5)
        - Shape: Rectangle (copied from input frame).
      - Content_Patterns (inside frame):
        - Type: Fixed patterns (e.g., 3x3) corresponding to input Content_Objects.
        - Color: Determined by the color of the corresponding input Content_Object (e.g., Red=2 or Yellow=4 in train_1).
        - Pattern Structure: Specific arrangement of pixels, may include the background color.
          - Red Pattern (train_1): [[2, 8, 2], [2, 2, 2], [2, 2, 2]]
          - Yellow Pattern (train_1): [[4, 8, 4], [4, 4, 4], [4, 4, 4]]
      - Content_Background:
        - Color: Copied from the input Content_Background (Azure=8 in train_1).
Transformation:
  Action: Pattern Substitution within a Frame.
  Steps:
    1. Identify the bounding box of the gray (5) frame in the input.
    2. Determine the output grid size from the frame's bounding box dimensions.
    3. Copy the gray (5) frame to the output grid.
    4. Identify the background color within the input frame.
    5. Fill the area inside the output frame with this background color.
    6. Define the size (e.g., 3x3) of the key input objects/output patterns.
    7. Define the mapping rules (input color -> output pattern).
    8. Scan the area inside the input frame for key objects (e.g., 3x3 blocks containing Green=3 or Blue=1).
    9. For each key object found at a specific location:
       - Apply the mapping rule to get the corresponding output pattern.
       - Place the output pattern at the same relative location inside the output frame, overwriting the background.
Relationships:
  - The output grid size is determined by the input gray frame size.
  - The output frame is a direct copy of the input frame.
  - The output background color is copied from the input background color *inside* the frame.
  - Each key object inside the input frame maps to a specific fixed pattern in the output frame based on the key object's color.
  - The relative positions of the mapped patterns in the output correspond to the relative positions of the key objects in the input.
  - Objects outside the input frame are irrelevant.
```


**Natural Language Program**

1.  **Isolate Frame:** Find the smallest rectangle (bounding box) that encloses all gray (5) pixels in the input grid. This defines the frame.
2.  **Create Output Canvas:** Create a new grid (the output grid) with the same height and width as the bounding box found in step 1.
3.  **Copy Frame:** Copy the gray (5) pixels from the input grid, relative to the frame's top-left corner, onto the output grid at the corresponding positions.
4.  **Identify Content Area & Background:** Determine the region inside the frame in the input grid. Identify the background color within this region (in the example, this is azure=8).
5.  **Initialize Output Content:** Fill the region inside the frame in the output grid with the background color identified in step 4.
6.  **Define Mappings:** Establish the rules for transforming input elements to output patterns based on the examples. For this task (based on `train_1`):
    *   The element size is 3x3.
    *   Input color Green (3) maps to the Red (2) pattern: `[[2, 8, 2], [2, 2, 2], [2, 2, 2]]`.
    *   Input color Blue (1) maps to the Yellow (4) pattern: `[[4, 8, 4], [4, 4, 4], [4, 4, 4]]`.
7.  **Scan and Replace:** Iterate through the content area (inside the frame) of the input grid, examining potential 3x3 blocks.
8.  For each 3x3 block in the input content area starting at `(row, col)`:
    *   Check if the block contains any green (3) pixels. If yes, overwrite the corresponding 3x3 area in the output grid (starting at the same relative `(row, col)` within the frame) with the Red (2) pattern defined in step 6.
    *   Else, check if the block contains any blue (1) pixels. If yes, overwrite the corresponding 3x3 area in the output grid with the Yellow (4) pattern defined in step 6.
9.  **Finalize:** The resulting grid after all replacements are done is the final output.
```python
import numpy as np
import collections

"""
Identify a rectangular frame made of gray (5) pixels in the input grid.
Determine the background color ('bg') from inside the frame (e.g., top-left inner pixel).
Create an output grid matching the frame's dimensions.
Copy the gray frame to the output grid.
Fill the inside of the output frame with the background color 'bg'.
Define two possible 3x3 output pattern structures based on 'bg':
  - Structure A (if bg=8): [[fill, bg, fill], [fill, fill, fill], [fill, fill, fill]]
  - Structure D (if bg=1): [[bg, fill, fill], [bg, fill, fill], [bg, fill, bg]]
  (Assume Structure A for any bg other than 1 for potential generalization).
Define two sets of color mappings from input 'key_color' to output 'fill' color, based on 'bg':
  - Mapping 8 (if bg=8): {Green(3): Red(2), Blue(1): Yellow(4)}
  - Mapping 1 (if bg=1): {Red(2): Yellow(4), Magenta(6): Orange(7), Green(3): Azure(8)}
  (Assume Mapping 8 for any bg other than 1 for potential generalization).
Iterate through the input grid's content area (inside the frame) in non-overlapping 3x3 blocks.
For each 3x3 input block:
  - Identify the 'key_color': Find the first color in the block that is not 'bg' and is a valid key in the active color mapping.
  - If a 'key_color' is found:
    - Determine the 'output_fill_color' using the active color mapping.
    - Select the active output pattern structure template.
    - Create the specific 3x3 output pattern by substituting 'fill' with 'output_fill_color' and using the correct 'bg'.
    - Place this output pattern onto the corresponding 3x3 location in the output grid (relative to the frame).
Return the final output grid.
"""

def find_frame_bounds(grid, frame_color=5):
    """Finds the min/max row/col for a given frame color."""
    rows, cols = np.where(grid == frame_color)
    if rows.size == 0:
        # Handle cases where the frame color is not found
        # Based on examples, a frame is expected. Raise error or return None.
        # For robustness, let's try finding any non-background object's bounds
        # But the task strongly implies a gray frame. Let's assume it exists.
        raise ValueError("Frame color not found in grid")
    min_r, max_r = np.min(rows), np.max(rows)
    min_c, max_c = np.min(cols), np.max(cols)
    return min_r, max_r, min_c, max_c

def get_key_color(block, bg, valid_keys):
    """Finds the first valid key color in the block."""
    # Flatten the block and check each color
    for color in block.flatten():
        if color != bg and color in valid_keys:
            return color
    return None # No valid key color found

def create_pattern(structure_type, bg, fill_color):
    """Creates the 3x3 output pattern based on type, bg, and fill color."""
    pattern = np.full((3, 3), fill_color, dtype=np.int8)
    if structure_type == 'A':
        # [[fill, bg, fill], [fill, fill, fill], [fill, fill, fill]]
        pattern[0, 1] = bg
    elif structure_type == 'D':
        # [[bg, fill, fill], [bg, fill, fill], [bg, fill, bg]]
        pattern[0, 0] = bg
        pattern[1, 0] = bg
        pattern[2, 0] = bg
        pattern[2, 2] = bg
    else:
         # Default or error case - let's default to structure A
         pattern[0, 1] = bg

    return pattern


def transform(input_grid):
    """
    Transforms the input grid based on pattern replacement within a frame,
    adapting patterns and colors based on the frame's internal background color.
    """
    input_grid_np = np.array(input_grid, dtype=np.int8)
    frame_color = 5

    try:
        min_r, max_r, min_c, max_c = find_frame_bounds(input_grid_np, frame_color)
    except ValueError:
         # If no frame found, maybe return input or default?
         # Based on examples, returning input seems unlikely to be correct.
         # Let's return an empty grid or a copy for safety, although error is likely better.
         return input_grid # Or np.array([[]])

    # Determine output grid size
    output_h = max_r - min_r + 1
    output_w = max_c - min_c + 1

    # Determine background color from inside the frame
    # Ensure indices are valid if frame is only 1 pixel thick (although examples aren't)
    bg_r, bg_c = min_r + 1, min_c + 1
    if bg_r > max_r -1 or bg_c > max_c -1:
         # Handle very thin frames - maybe just use frame color? Unlikely based on ARC tasks.
         # Or check multiple locations? For now, assume frame is thick enough.
         # Let's find the most common color inside the frame excluding the frame color itself.
         inner_area = input_grid_np[min_r+1:max_r, min_c+1:max_c]
         if inner_area.size > 0:
             colors, counts = np.unique(inner_area, return_counts=True)
             if colors.size > 0 :
                # Find most frequent color inside that isn't frame color
                bg = colors[counts.argmax()] # Simplistic, assumes single dominant bg
                # A more robust way might be needed if bg is noisy
             else:
                 bg = 0 # Default if inner area empty? Should not happen based on examples.
         else:
             # If frame is too thin, maybe default bg?
             bg = 0 # Default background
    else:
        bg = input_grid_np[bg_r, bg_c]


    # Initialize output grid and fill with background
    output_grid = np.full((output_h, output_w), bg, dtype=np.int8)

    # Copy the frame
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if input_grid_np[r, c] == frame_color:
                out_r, out_c = r - min_r, c - min_c
                output_grid[out_r, out_c] = frame_color

    # Define structures and mappings based on background color
    if bg == 1:
        structure_type = 'D'
        color_map = {2: 4, 6: 7, 3: 8} # Input: Output
    else: # Defaulting to bg=8 behavior for other backgrounds
        structure_type = 'A'
        color_map = {3: 2, 1: 4} # Input: Output


    valid_input_keys = set(color_map.keys())

    # Iterate through input content area in 3x3 steps
    # Start from the first potential top-left corner inside the frame
    # Ensure steps don't go past the inner boundary
    for r in range(min_r + 1, max_r - 1, 3): # Step by 3, stop before last 2 rows
         # Check if the block fits entirely within the inner frame bounds
         if r + 3 > max_r: continue
         for c in range(min_c + 1, max_c - 1, 3): # Step by 3, stop before last 2 cols
            if c + 3 > max_c: continue

            # Extract 3x3 block
            in_block = input_grid_np[r:r+3, c:c+3]

            # Find the key color
            key_color = get_key_color(in_block, bg, valid_input_keys)

            if key_color is not None:
                # Get the corresponding output fill color
                output_fill_color = color_map[key_color]

                # Create the output pattern
                output_pattern = create_pattern(structure_type, bg, output_fill_color)

                # Calculate output position (relative to output grid 0,0)
                out_r = r - min_r
                out_c = c - min_c

                # Place pattern in output grid
                # Ensure the pattern fits within the output grid bounds (should always if frame copied correctly)
                if out_r + 3 <= output_h and out_c + 3 <= output_w:
                   output_grid[out_r:out_r+3, out_c:out_c+3] = output_pattern
                else:
                    # This case should ideally not happen if logic is correct
                    print(f"Warning: Pattern placement out of bounds at ({out_r}, {out_c})")


    return output_grid.tolist() # Return as list of lists per ARC format
```
