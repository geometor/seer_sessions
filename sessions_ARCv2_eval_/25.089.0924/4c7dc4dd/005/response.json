{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Candidate Framed Objects:** Find all objects in the input grid that consist of a contiguous border of a single color (frame_color), surrounding an area filled entirely with white (0), which in turn contains a single, contiguous shape of a third distinct color (inner_color, different from frame_color). Record the `inner_color`, `frame_color`, and bounding box (`bbox`) for each candidate.\n2.  **Identify Largest Solid Rectangular Block (Potential Container):** Find the solid rectangular block with the largest area, consisting of a single color excluding white (0) and gray (5). If multiple blocks share the maximum area, choose the one whose top-left corner is highest, breaking further ties by choosing the leftmost one. Note its color (`container_color`) and bounding box (`container_bbox`). If no such block exists, consider the container absent.\n3.  **Select the Target Framed Object:**\n    *   Identify candidate framed objects whose bounding box (`bbox`) is entirely within the `container_bbox`.\n    *   If one or more candidates are contained within the container block's bounding box, select the one whose top-left corner is highest, breaking further ties by choosing the leftmost one. This is the \"target object\". Mark this case as `contained`.\n    *   If *no* candidates are contained within the container block's bounding box, select the candidate object (from the *original* list of all framed objects found in step 1) that has the numerically smallest `inner_color`. If there's a tie in `inner_color`, choose the one whose top-left corner is highest, breaking further ties by choosing the leftmost one. This is the \"target object\". Mark this case as `not_contained`.\n4.  **Determine Output Colors:**\n    *   Get the `inner_color` from the target object.\n    *   The `interior_color` is always white (0).\n    *   If the case is `contained`, the `primary_color` is the `container_color` identified in step 2.\n    *   If the case is `not_contained`, the `primary_color` is the same as the `inner_color` of the target object.\n5.  **Construct Output Grid:**\n    *   If the case is `contained`: Create a 5x5 grid following the specific pattern:\n        Row 1: [0, 0, 0, 0, 0]\n        Row 2: [inner, primary, primary, primary, primary]\n        Row 3: [primary, 0, 0, 0, 0]\n        Row 4: [primary, 0, 0, 0, 0]\n        Row 5: [primary, 0, 0, 0, 0]\n    *   If the case is `not_contained`: Create a 4x4 grid following the specific pattern:\n        Row 1: [primary, primary, 0, primary]\n        Row 2: [0, 0, 0, primary]\n        Row 3: [primary, primary, primary, primary]\n        Row 4: [primary, 0, 0, primary]\n\"\"\"\n\ndef find_objects(grid, colors_to_find=None, colors_to_ignore=None):\n    \"\"\"\n    Finds all contiguous objects of specified colors in the grid using 4-connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): Set of colors to look for. If None, find all colors not ignored.\n        colors_to_ignore (set): Set of colors to ignore.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary containing:\n              'color': The color of the object.\n              'pixels': A set of (row, col) tuples for the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col) representing the bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if colors_to_ignore is None:\n        colors_to_ignore = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Process pixel if not visited, not ignored, and either find all or in specific set\n            if not visited[r, c] and color not in colors_to_ignore and \\\n               (colors_to_find is None or color in colors_to_find):\n                \n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search (BFS) to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor is same color and not visited\n                            if not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store the found object\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef is_framed_object_strict(grid, frame_obj):\n    \"\"\"\n    Checks if a given object (frame_obj) acts as a valid frame for an inner object.\n    Checks:\n    1. A potential interior region exists within the frame's bounding box.\n    2. The region inside the bounding box but excluding frame pixels contains white (0).\n    3. This interior region contains exactly one contiguous non-white object (inner_obj).\n    4. The inner_obj's color is different from the frame_obj's color.\n    5. The inner_obj does not touch the outer edges of the frame's bounding box.\n    6. All non-frame pixels within the bounding box are either white or part of the single inner object.\n\n    Args:\n        grid (np.array): The input grid.\n        frame_obj (dict): A potential frame object from find_objects.\n\n    Returns:\n        tuple: (bool, int or None) - (True if valid framed object, inner_color)\n               or (False, None)\n    \"\"\"\n    frame_pixels = frame_obj['pixels']\n    frame_color = frame_obj['color']\n    min_r, min_c, max_r, max_c = frame_obj['bbox']\n    rows, cols = grid.shape\n\n    # Frame bounding box must be large enough to potentially contain something\n    if max_r - min_r < 2 or max_c - min_c < 2:\n        return False, None\n\n    inner_components = [] # Stores non-white components found inside\n    visited_inner = set(frame_pixels) # Mark frame pixels as visited for the inner search\n    has_white_inside = False\n    all_interior_pixels = set() # Track all pixels scanned inside the bbox (excluding frame)\n\n    # Iterate through the potential interior area (inside the bounding box)\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            # Skip if this pixel is part of the frame or already visited\n            if (r, c) not in visited_inner:\n                all_interior_pixels.add((r,c)) # Mark this as an interior pixel\n                color = grid[r, c]\n                \n                # Start BFS for this component within the interior\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited_inner.add((r, c))\n                is_valid_inner_component = True # Assume valid until it touches bbox boundary\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n\n                    # Check if component touches the bounding box boundary - disqualifies non-white inner objects\n                    if row <= min_r or row >= max_r or col <= min_c or col >= max_c:\n                       is_valid_inner_component = False # Mark as invalid if touching bbox edge\n                       # Continue BFS to mark all pixels of this invalid component as visited\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check neighbor is within grid, not visited, not frame, and same color\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited_inner and \\\n                           (nr, nc) not in frame_pixels and \\\n                           grid[nr, nc] == color:\n                            \n                            visited_inner.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # After BFS for the component, decide what it was\n                if color == 0:\n                    has_white_inside = True\n                    # We don't store the white component explicitly, just note its presence\n                elif is_valid_inner_component: # Only store non-white components fully inside\n                     inner_components.append({\n                         'color': color, \n                         'pixels': component_pixels,\n                     })\n\n    # Check final conditions for a valid framed object:\n    # 1. Must have found white pixels inside the frame's bbox.\n    # 2. Must have found exactly one valid (non-boundary touching) non-white inner component.\n    # 3. The inner component's color must differ from the frame color.\n    # 4. Check if all interior pixels are accounted for (frame, white, or the single inner object)\n    if has_white_inside and len(inner_components) == 1 and inner_components[0]['color'] != frame_color:\n        # Check if all visited inner pixels belong to the found inner component or were white\n        inner_pixels_found = inner_components[0]['pixels']\n        is_fully_explained = True\n        for p in all_interior_pixels:\n            if p not in inner_pixels_found and grid[p] != 0:\n                 is_fully_explained = False\n                 break \n        \n        if is_fully_explained:\n            return True, inner_components[0]['color']\n\n    return False, None\n\ndef find_largest_solid_block(grid, colors_to_ignore):\n    \"\"\"Finds the largest solid rectangular block of a single color, ignoring specified colors.\"\"\"\n    rows, cols = grid.shape\n    max_area = -1\n    largest_block = None # Store {'color': c, 'bbox': (min_r, min_c, max_r, max_c)}\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Skip ignored colors\n            if color in colors_to_ignore:\n                continue\n\n            # Determine the maximum possible width starting at (r, c) for this color\n            max_w = 0\n            for w in range(1, cols - c + 1):\n                if grid[r, c + w - 1] == color:\n                    max_w = w\n                else:\n                    break # Width extension stops\n            \n            # For each possible width, find the maximum height\n            for w in range(1, max_w + 1):\n                h = 0\n                # Check rows downwards\n                for current_h in range(1, rows - r + 1):\n                    is_solid_row_segment = True\n                    # Check if the entire row segment matches the color\n                    for k in range(w):\n                        if grid[r + current_h - 1, c + k] != color:\n                            is_solid_row_segment = False\n                            break\n                    \n                    if is_solid_row_segment:\n                        h = current_h # Extend height\n                    else:\n                        break # Height expansion stops here for width w\n                \n                # Calculate area and update largest block if needed\n                area = w * h\n                if area > max_area:\n                    max_area = area\n                    largest_block = {'color': color, 'bbox': (r, c, r + h - 1, c + w - 1)}\n                elif area == max_area and largest_block is not None:\n                     # Tie-breaking: top-leftmost (compare top row, then left column)\n                     current_bbox = (r, c, r + h - 1, c + w - 1)\n                     if current_bbox[0] < largest_block['bbox'][0] or \\\n                        (current_bbox[0] == largest_block['bbox'][0] and current_bbox[1] < largest_block['bbox'][1]):\n                         largest_block = {'color': color, 'bbox': current_bbox}\n\n    return largest_block\n\ndef is_contained(inner_bbox, outer_bbox):\n    \"\"\"Checks if inner_bbox is strictly inside or touching the boundaries of outer_bbox.\"\"\"\n    if outer_bbox is None or inner_bbox is None:\n        return False\n    min_r_in, min_c_in, max_r_in, max_c_in = inner_bbox\n    min_r_out, min_c_out, max_r_out, max_c_out = outer_bbox\n    # Check if all corners of inner are within or on the boundary of outer\n    return min_r_out <= min_r_in and min_c_out <= min_c_in and \\\n           max_r_in <= max_r_out and max_c_in <= max_c_out\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n\n    # 1. Identify Candidate Framed Objects\n    candidate_objects = []\n    # Find all non-white, non-gray objects as potential frames\n    potential_frames = find_objects(grid, colors_to_ignore={0, 5}) \n\n    # Validate each potential frame\n    for p_frame in potential_frames:\n        is_framed, inner_color = is_framed_object_strict(grid, p_frame)\n        if is_framed:\n            candidate_objects.append({\n                'inner_color': inner_color,\n                'bbox': p_frame['bbox'],\n                'frame_color': p_frame['color'] # Store frame color, might be useful\n            })\n\n    # Handle case where no valid framed objects are found\n    if not candidate_objects:\n         # Based on ARC tasks, this is unlikely for valid inputs, but return a minimal grid.\n         return [[0]] \n\n    # 2. Identify Largest Solid Rectangular Block (Potential Container)\n    container_block = find_largest_solid_block(grid, colors_to_ignore={0, 5}) # Ignore white and gray\n\n    # 3. Select the Target Framed Object\n    contained_candidates = []\n    if container_block:\n        container_bbox = container_block['bbox']\n        # Find candidates fully contained within the container's bounding box\n        for cand in candidate_objects:\n            if is_contained(cand['bbox'], container_bbox):\n                contained_candidates.append(cand)\n\n    target_object = None\n    is_contained_flag = False\n\n    if contained_candidates:\n        # If candidates are contained, select the top-leftmost one\n        # Sort by top row (bbox[0]), then left column (bbox[1])\n        contained_candidates.sort(key=lambda x: (x['bbox'][0], x['bbox'][1]))\n        target_object = contained_candidates[0]\n        is_contained_flag = True\n    else:\n        # If no candidates are contained, select from ALL candidates\n        # Sort by inner_color, then top row, then left column\n        candidate_objects.sort(key=lambda x: (x['inner_color'], x['bbox'][0], x['bbox'][1]))\n        target_object = candidate_objects[0]\n        is_contained_flag = False\n\n    # 4. Determine Output Colors\n    inner_color = target_object['inner_color']\n    interior_color = 0 # Always white\n\n    if is_contained_flag:\n        # If contained, primary color is the container's color\n        # Container must exist if is_contained_flag is True\n        primary_color = container_block['color']\n    else:\n        # If not contained, primary color is the inner color of the target\n        primary_color = inner_color \n\n    # 5. Construct Output Grid based on whether the target was contained\n    if is_contained_flag:\n        # Create the 5x5 pattern for contained objects\n        output_grid = np.full((5, 5), interior_color, dtype=int) # Fill with white (0)\n        output_grid[1, 0] = inner_color # Top-left of second row\n        output_grid[1, 1:] = primary_color # Rest of second row\n        output_grid[2:, 0] = primary_color # First column, rows 3-5\n    else:\n        # Create the 4x4 pattern for non-contained objects\n        output_grid = np.full((4, 4), primary_color, dtype=int) # Fill with primary color\n        # Set specific pixels to interior color (white 0)\n        output_grid[0, 2] = interior_color\n        output_grid[1, 0:3] = interior_color\n        # Row 3 remains primary color\n        output_grid[3, 1:3] = interior_color\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21838,
    "candidates_token_count": 4339,
    "total_token_count": 26177,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.584134,
  "retries": 1
}