{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on the adjacency of yellow pixels to blue pixels, \napplying a two-stage process:\n\n1.  **Stage 1 (Coloring Yellow Pixels):**\n    a.  Initialize an output grid as a copy of the input grid.\n    b.  Create a temporary grid (`stage1_colors`) to store the calculated colors \n        for pixels that were initially yellow (4).\n    c.  Iterate through each yellow pixel in the input grid.\n    d.  Count its orthogonal and diagonal blue (1) neighbors in the *input* grid.\n    e.  Determine the color for this yellow pixel based on the counts:\n        - Magenta (6) if orthogonally adjacent to 2 or more blue pixels.\n        - Red (2) if orthogonally adjacent to exactly 1 blue pixel.\n        - Azure (8) if diagonally adjacent to 1 or more blue pixels AND \n          NOT orthogonally adjacent to any blue pixels.\n        - Yellow (4) otherwise.\n    f.  Store this calculated color in the `stage1_colors` grid.\n    g.  Update the main output grid with the colors calculated in `stage1_colors`.\n\n2.  **Stage 2 (Coloring Blue Pixels):**\n    a.  Iterate through each pixel that was originally blue (1) in the input grid.\n    b.  Check its 8 neighbors (orthogonal and diagonal).\n    c.  If any neighbor `(nr, nc)` was originally yellow (4) in the input grid \n        AND its calculated color in `stage1_colors` is azure (8), then change \n        the current blue pixel in the output grid to azure (8).\n    d.  Otherwise, the blue pixel remains blue (1).\n\n3.  Return the final output grid.\n\"\"\"\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies a two-stage adjacency-based coloring rule to the input grid.\n\n    Args:\n        input_grid: A 2D numpy array representing the input grid.\n\n    Returns:\n        A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    # Temporary grid to store colors calculated for initially yellow pixels\n    # Initialize with -1 to distinguish from valid colors (0-9)\n    stage1_colors = np.full_like(input_grid, -1, dtype=int) \n\n    # Define neighbor offsets\n    orthogonal_neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    diagonal_neighbors = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n    all_neighbors = orthogonal_neighbors + diagonal_neighbors\n\n    # --- Stage 1: Calculate colors for initially yellow pixels ---\n    for r in range(rows):\n        for c in range(cols):\n            # Only process pixels that are yellow (4) in the input\n            if input_grid[r, c] == 4:\n                ortho_blue_count = 0\n                diag_blue_count = 0\n\n                # Check orthogonal neighbors in the original input grid\n                for dr, dc in orthogonal_neighbors:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] == 1:\n                        ortho_blue_count += 1\n\n                # Check diagonal neighbors in the original input grid\n                for dr, dc in diagonal_neighbors:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] == 1:\n                        diag_blue_count += 1\n\n                # Determine color based on rules and store in stage1_colors\n                if ortho_blue_count >= 2:\n                    stage1_colors[r, c] = 6  # Magenta\n                elif ortho_blue_count == 1:\n                    stage1_colors[r, c] = 2  # Red\n                elif diag_blue_count >= 1: # Only if ortho_blue_count is 0\n                    stage1_colors[r, c] = 8  # Azure\n                else:\n                    stage1_colors[r, c] = 4 # Remains Yellow\n\n    # Apply Stage 1 colors to the output grid\n    for r in range(rows):\n        for c in range(cols):\n            if stage1_colors[r, c] != -1: # If a color was calculated (i.e., was originally yellow)\n                output_grid[r, c] = stage1_colors[r, c]\n\n    # --- Stage 2: Check if original blue pixels should turn azure ---\n    # Create a list of blue pixels to update to avoid modifying the grid while iterating\n    blue_to_azure_updates = []\n    for r in range(rows):\n        for c in range(cols):\n            # Only process pixels that were blue (1) in the input\n            if input_grid[r, c] == 1:\n                should_turn_azure = False\n                # Check all 8 neighbors\n                for dr, dc in all_neighbors:\n                    nr, nc = r + dr, c + dc\n                    # Check if neighbor is within bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if the neighbor was originally yellow AND its calculated color is azure\n                        if input_grid[nr, nc] == 4 and stage1_colors[nr, nc] == 8:\n                            should_turn_azure = True\n                            break # Found one azure-inducing neighbor, no need to check further\n                \n                if should_turn_azure:\n                    blue_to_azure_updates.append((r, c))\n\n    # Apply the blue-to-azure updates\n    for r, c in blue_to_azure_updates:\n        output_grid[r, c] = 8 # Azure\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19802,
    "candidates_token_count": 1419,
    "total_token_count": 21221,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.421296,
  "retries": 1
}