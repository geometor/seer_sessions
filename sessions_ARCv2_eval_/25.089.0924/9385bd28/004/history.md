
## train_1

**input:**
```
0 0 0 2 2 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 1 1 0 0 0
0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 2 2 0 0
1 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 2 3 3 3 0 0
0 0 0 2 3 3 3 3 0 0
0 0 0 3 1 1 0 3 0 0
0 0 0 3 1 0 0 3 0 0
0 0 0 3 0 0 1 3 0 0
0 0 0 3 0 1 1 3 0 0
0 0 0 3 3 3 3 2 0 0
0 0 0 3 3 3 2 2 0 0
1 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 4 4
0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 1 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0
0 1 3 0 4 0 1 1 0 0
0 4 5 0 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 5 5 5 5 4 4
0 0 0 0 5 5 5 5 5 4
0 0 0 0 5 1 1 3 5 5
0 0 0 0 5 1 3 3 5 5
0 0 0 0 5 3 3 3 5 5
0 0 0 0 5 3 3 3 5 5
0 0 0 0 5 3 3 1 5 5
0 1 3 0 4 3 1 1 5 5
0 4 5 0 4 4 5 5 5 5
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
3 3 5 5 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 5 3 3 3 3 5 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 5 5 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 3 4 4 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 4 3 3 1 1 3 3 2 3 3 3
3 3 3 3 3 3 3 3 3 3 1 3 2 2 3 3 3
3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3
3 3 1 6 3 3 3 3 4 4 3 3 3 3 3 3 3
3 3 2 9 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 4 0 3 3 3 1 3 3 3 3 3 3 3 3 3
3 3 8 9 3 3 3 1 1 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 5 5 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 5 3 3 3 3 5 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 5 5 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 9 9 9 9 9 9 9 9 3 3 3
3 3 3 3 2 9 9 9 9 9 9 9 9 9 3 3 3
3 3 3 3 9 9 9 6 6 1 1 9 9 2 3 3 3
3 3 3 3 9 9 9 6 6 6 1 9 2 2 3 3 3
3 3 3 3 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 1 6 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 2 9 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 4 0 3 3 3 1 6 6 6 3 3 3 3 3 3
3 3 8 9 3 3 3 1 1 6 6 3 3 3 3 3 3
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 4
0 0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 4 4
0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 0 0 0 0 0 0 0 0 6 0 0 0 7 7 0 0
6 7 0 0 0 0 0 0 0 6 6 0 0 0 7 7 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4
0 0 0 0 0 0 6 6 7 7 7 0 4 4 4 4 4 4
0 0 0 0 0 0 6 7 7 7 7 0 0 0 0 0 0 0
0 0 0 0 0 0 7 7 7 7 7 0 0 0 0 0 0 0
3 3 0 0 0 0 7 7 7 7 6 0 0 0 6 6 0 0
6 7 0 0 0 0 7 7 7 6 6 0 0 0 6 6 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down the task based on the provided examples.

**Perception of Elements:**

1.  **Grid Structure:** The input and output are both grids of colored pixels.
2.  **Background Color:** The color white (0) predominantly acts as the background or empty space.
3.  **Objects:** Contiguous blocks of non-white colors form distinct objects or shapes within the grid.
4.  **Loops/Boundaries:** In each example, there are one or more closed loops formed by pixels of a single color (e.g., red in train\_1, yellow in train\_2, red and blue in train\_3, green, magenta, yellow, orange in train\_4). These loops act as boundaries.
5.  **Enclosed Areas:** These loops enclose areas within the grid. These areas primarily consist of the white background color but may also contain other non-white objects.
6.  **Transformation:** The core transformation involves filling the white (0) pixels *inside* these closed loops with a new color.
7.  **Fill Color Determination:** The color used to fill the enclosed white space appears to depend on two factors:
    *   The color of the loop itself (the border color).
    *   The color of the largest distinct object *inside* the loop (if any exists). If only white pixels are inside, the fill color depends solely on the border color.
8.  **Preservation:** The pixels forming the loop boundary and any objects originally inside the loop remain unchanged. Pixels outside any loop also remain unchanged.

**YAML Fact Document:**


```yaml
task_description: Fill enclosed background areas based on border color and largest interior object color.

elements:
  - type: grid
    properties:
      - background_color: white (0)
      - contains: objects

  - type: object
    properties:
      - shape: contiguous block of non-white pixels
      - role:
          - boundary (forms a closed loop)
          - interior_object (located inside a loop)
          - exterior_object (located outside any loop)

relationships:
  - type: enclosure
    subject: boundary_object (loop)
    object: interior_region (pixels inside the loop)
    properties:
      - interior_region contains:
          - white (0) pixels
          - optionally, interior_objects

actions:
  - action: identify_loops
    input: grid
    output: list of boundary_objects (loops) and their corresponding interior_regions

  - action: identify_largest_interior_object
    input: interior_region
    output: color of the largest non-white object within the region (or null if none)

  - action: determine_fill_color
    input:
      - boundary_object_color
      - largest_interior_object_color (or null)
    output: fill_color
    logic: Mapped based on observed pairs:
             (Border: Red 2, Inner: Blue 1) -> Fill: Green 3
             (Border: Yellow 4, Inner: Blue 1) -> Fill: Gray 5
             (Border: Red 2, Inner: Yellow 4) -> Fill: Maroon 9
             (Border: Blue 1, Inner: null) -> Fill: Magenta 6
             (Border: Green 3, Inner: null) -> Fill: Green 3
             (Border: Magenta 6, Inner: null) -> Fill: Orange 7
             (Border: Yellow 4, Inner: null) -> Fill: Yellow 4
             (Border: Orange 7, Inner: null) -> Fill: Magenta 6

  - action: fill_interior_background
    input:
      - grid
      - loop_boundary
      - interior_region
      - fill_color
    output: modified_grid
    effect: Changes the color of white (0) pixels within the interior_region to the fill_color.

final_state: The output grid reflects the input grid with all white pixels inside identified loops filled according to the determined fill color. Loop pixels and interior object pixels remain unchanged.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Iterate through each non-white color present in the input grid (potential loop colors).
3.  For each potential loop color, identify all distinct contiguous objects (regions) composed of that color.
4.  For each such object, determine if it forms a closed loop that encloses an area containing white (0) pixels. This can be verified by checking if a flood fill starting from the white pixels adjacent to the object's boundary eventually reaches the edge of the grid without crossing the object's color. If the flood fill is contained, the object forms a loop enclosing those white pixels.
5.  For each confirmed loop:
    a.  Identify all pixels located strictly inside the loop's boundary.
    b.  Among the interior pixels, find all contiguous non-white, non-border-color objects.
    c.  Determine the largest of these interior objects based on pixel count. Note its color (the "interior object color"). If no such objects exist (only white pixels and potentially pixels matching the border color are inside), consider the interior object color to be null.
    d.  Determine the "fill color" based on the combination of the loop's color (the "border color") and the identified "interior object color" (or null) using the specific mapping rules derived from the examples:
        *   If Border=Red(2) and Interior=Blue(1), Fill=Green(3).
        *   If Border=Yellow(4) and Interior=Blue(1), Fill=Gray(5).
        *   If Border=Red(2) and Interior=Yellow(4), Fill=Maroon(9).
        *   If Border=Blue(1) and Interior=null, Fill=Magenta(6).
        *   If Border=Green(3) and Interior=null, Fill=Green(3).
        *   If Border=Magenta(6) and Interior=null, Fill=Orange(7).
        *   If Border=Yellow(4) and Interior=null, Fill=Yellow(4).
        *   If Border=Orange(7) and Interior=null, Fill=Magenta(6).
    e.  Iterate through all the pixels identified as being strictly inside the loop (from step 5a). If a pixel's color is white (0), change its color in the output grid to the determined "fill color".
6.  After processing all loops for all potential colors, return the modified output grid.
```python
import numpy as np
from scipy.ndimage import label, find_objects, sum as ndi_sum

"""
Identifies closed loops formed by a single non-white color. 
For each loop, it determines the largest non-white object (if any) located strictly inside the loop, excluding any pixels matching the loop's border color.
Based on the loop's border color and the color of the largest interior object (or lack thereof), a specific fill color is determined using a predefined mapping.
All white (0) pixels strictly inside the loop are then changed to this fill color in the output grid.
Pixels forming the loop border, pixels of interior objects, and pixels outside any loop remain unchanged.

The fill color mapping is:
- Border Red(2), Largest Interior Blue(1) -> Fill Green(3)
- Border Yellow(4), Largest Interior Blue(1) -> Fill Gray(5)
- Border Red(2), Largest Interior Yellow(4) -> Fill Maroon(9)
- Border Blue(1), No distinct Interior Object -> Fill Magenta(6)
- Border Green(3), No distinct Interior Object -> Fill Green(3)
- Border Magenta(6), No distinct Interior Object -> Fill Orange(7)
- Border Yellow(4), No distinct Interior Object -> Fill Yellow(4)
- Border Orange(7), No distinct Interior Object -> Fill Magenta(6)
"""

def find_connected_components(grid, include_colors=None, exclude_colors=None):
    """Finds connected components for specified colors."""
    mask = np.zeros_like(grid, dtype=bool)
    if include_colors:
        for color in include_colors:
            mask[grid == color] = True
    elif exclude_colors:
        mask = np.ones_like(grid, dtype=bool)
        for color in exclude_colors:
            mask[grid == color] = False
    else: # include all non-background
         mask[grid != 0] = True

    labeled_array, num_features = label(mask)
    objects = find_objects(labeled_array)
    components = []
    for i in range(num_features):
        loc = objects[i]
        component_mask = (labeled_array[loc] == (i + 1))
        coords = np.argwhere(component_mask)
        coords[:, 0] += loc[0].start
        coords[:, 1] += loc[1].start
        color = grid[coords[0, 0], coords[0, 1]] # Get color from first pixel
        components.append({'label': i + 1, 'coords': coords, 'color': color, 'size': len(coords)})
    return labeled_array, components

def get_neighbors(r, c, height, width):
    """Get valid neighbor coordinates."""
    neighbors = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            neighbors.append((nr, nc))
    return neighbors

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Fills enclosed white areas based on border color and largest interior object color.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Define the fill color mapping based on (border_color, largest_interior_color)
    # Use None for largest_interior_color if no relevant interior object exists.
    fill_map = {
        (2, 1): 3,  # Border: Red, Inner: Blue -> Fill: Green
        (4, 1): 5,  # Border: Yellow, Inner: Blue -> Fill: Gray
        (2, 4): 9,  # Border: Red, Inner: Yellow -> Fill: Maroon
        (1, None): 6, # Border: Blue, Inner: None -> Fill: Magenta
        (3, None): 3, # Border: Green, Inner: None -> Fill: Green
        (6, None): 7, # Border: Magenta, Inner: None -> Fill: Orange
        (4, None): 4, # Border: Yellow, Inner: None -> Fill: Yellow
        (7, None): 6, # Border: Orange, Inner: None -> Fill: Magenta
    }

    # 1. Label all connected components in the grid (including background)
    # We use structure that connects only orthogonal neighbors
    structure = np.array([[0,1,0],[1,1,1],[0,1,0]], dtype=bool)
    labeled_grid, num_labels = label(input_grid, structure=structure)

    # 2. Identify white components (potential interiors)
    white_components = []
    for i in range(1, num_labels + 1):
        coords = np.argwhere(labeled_grid == i)
        if coords.size > 0 and input_grid[coords[0, 0], coords[0, 1]] == 0:
            white_components.append({'label': i, 'coords': coords})

    # 3. For each white component, check its neighbors
    for wc in white_components:
        neighbor_labels = set()
        border_color = -1 # Sentinel value
        is_enclosed = True
        
        # Find all unique neighboring labels
        for r, c in wc['coords']:
            for nr, nc in get_neighbors(r, c, height, width):
                neighbor_label = labeled_grid[nr, nc]
                # If neighbor is part of the same white component, skip
                if neighbor_label == wc['label']:
                    continue
                # If neighbor is background (0 label from scipy) or outside grid (handled by get_neighbors), 
                # it might mean it touches the edge implicitly if background reaches edge.
                # A more robust check: if any pixel of the white component is on the border, it's not enclosed.
                if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                   is_enclosed = False
                   break 
                
                # Check if neighbor pixel itself is background but has label 0 (unlabeled region touching edge)
                if input_grid[nr, nc] == 0 and neighbor_label == 0:
                    is_enclosed = False
                    break

                # If neighbor is non-white, add its label
                if input_grid[nr, nc] != 0:
                   neighbor_labels.add(neighbor_label)
            if not is_enclosed:
                break
        
        if not is_enclosed:
            continue

        # 4. Check if enclosed by a single non-white component
        if len(neighbor_labels) == 1:
            border_label = list(neighbor_labels)[0]
            border_coords = np.argwhere(labeled_grid == border_label)
            if border_coords.size > 0:
                 border_color = input_grid[border_coords[0, 0], border_coords[0, 1]]
            else: # Should not happen if label exists
                continue

            # 5. Find the largest interior object (non-white, non-border color)
            interior_coords_list = wc['coords']
            interior_mask = np.zeros_like(input_grid, dtype=bool)
            for r, c in interior_coords_list:
                interior_mask[r, c] = True

            # Create a temporary grid containing only the interior pixels' original colors
            temp_interior_grid = np.full_like(input_grid, -1) # Use -1 to mark outside area
            temp_interior_grid[interior_mask] = input_grid[interior_mask]

            # Find components within this interior, excluding white and border color
            interior_obj_mask = (temp_interior_grid != -1) & (temp_interior_grid != 0) & (temp_interior_grid != border_color)
            
            labeled_interior_objs, num_interior_objs = label(interior_obj_mask, structure=structure)
            
            largest_interior_object_color = None
            max_size = 0

            if num_interior_objs > 0:
                interior_obj_indices = np.unique(labeled_interior_objs)
                # Ignore label 0 (background/non-object area)
                interior_obj_indices = interior_obj_indices[interior_obj_indices != 0] 
                
                object_sizes = ndi_sum(interior_obj_mask, labeled_interior_objs, index=interior_obj_indices)

                if object_sizes.size > 0:
                    largest_obj_index_in_list = np.argmax(object_sizes)
                    largest_obj_label = interior_obj_indices[largest_obj_index_in_list]
                    
                    # Find coordinates and color of the largest object
                    largest_obj_coords = np.argwhere(labeled_interior_objs == largest_obj_label)
                    if largest_obj_coords.size > 0:
                       largest_interior_object_color = input_grid[largest_obj_coords[0, 0], largest_obj_coords[0, 1]]
                       max_size = len(largest_obj_coords) # Or use object_sizes[largest_obj_index_in_list]

            # 6. Determine fill color
            fill_key = (border_color, largest_interior_object_color)
            if fill_key in fill_map:
                fill_color = fill_map[fill_key]

                # 7. Fill the white pixels in the output grid
                for r, c in interior_coords_list:
                    # Crucially, only fill if the pixel was originally white
                    if input_grid[r, c] == 0:
                        output_grid[r, c] = fill_color

    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label, sum as ndi_sum

"""
Identifies closed loops formed by a single non-white color that do not touch the grid edge.
For each such loop, it identifies the area of white (0) pixels enclosed by it.
It then finds the largest distinct object (contiguous block of pixels of the same color)
strictly within this enclosed white area, excluding any objects that are white (0) or
match the color of the border loop.
Based on the loop's border color and the color of the largest valid interior object
(or None if no such object exists), a specific fill color is determined using a predefined mapping.
All the originally white pixels within the enclosed area are then changed to this fill color
in the output grid. Pixels forming the loop border, pixels of interior objects, and pixels
outside any identified loop remain unchanged.

The fill color mapping is derived from the examples:
- Border Red(2), Largest Interior Blue(1) -> Fill Green(3)
- Border Yellow(4), Largest Interior Blue(1) -> Fill Gray(5)
- Border Red(2), Largest Interior Yellow(4) -> Fill Maroon(9)
- Border Blue(1), No valid Interior Object -> Fill Magenta(6)
- Border Green(3), No valid Interior Object -> Fill Green(3)
- Border Magenta(6), No valid Interior Object -> Fill Orange(7)
- Border Yellow(4), No valid Interior Object -> Fill Yellow(4)
- Border Orange(7), No valid Interior Object -> Fill Magenta(6)
"""

def get_neighbors(r, c, height, width):
    """Get valid orthogonal neighbor coordinates."""
    neighbors = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            neighbors.append((nr, nc))
    return neighbors

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Fills enclosed white areas based on border color and largest interior object color.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Define the fill color mapping based on (border_color, largest_interior_color)
    # Use None for largest_interior_color if no relevant interior object exists.
    fill_map = {
        (2, 1): 3,  # Border: Red, Inner: Blue -> Fill: Green
        (4, 1): 5,  # Border: Yellow, Inner: Blue -> Fill: Gray
        (2, 4): 9,  # Border: Red, Inner: Yellow -> Fill: Maroon
        (1, None): 6, # Border: Blue, Inner: None -> Fill: Magenta
        (3, None): 3, # Border: Green, Inner: None -> Fill: Green
        (6, None): 7, # Border: Magenta, Inner: None -> Fill: Orange
        (4, None): 4, # Border: Yellow, Inner: None -> Fill: Yellow
        (7, None): 6, # Border: Orange, Inner: None -> Fill: Magenta
    }

    # Define structure for orthogonal connectivity
    structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=bool)

    # Label all non-white connected components (potential borders)
    labeled_objects, _ = label(input_grid != 0, structure=structure)

    # Label all white connected components (potential enclosed regions)
    labeled_white, num_white_labels = label(input_grid == 0, structure=structure)

    # Iterate through each identified white region
    for w_label in range(1, num_white_labels + 1):
        # Get coordinates of the current white region
        white_coords_list = np.argwhere(labeled_white == w_label)
        if white_coords_list.size == 0:
            continue

        # Create a boolean mask for faster indexing
        interior_mask = (labeled_white == w_label)

        # Check if the white region touches the grid boundary
        touches_boundary = np.any(white_coords_list[:, 0] == 0) or \
                           np.any(white_coords_list[:, 0] == height - 1) or \
                           np.any(white_coords_list[:, 1] == 0) or \
                           np.any(white_coords_list[:, 1] == width - 1)
        
        if touches_boundary:
            continue # Cannot be enclosed if it touches the boundary

        # Identify the labels of adjacent non-white objects
        adjacent_object_labels = set()
        for r, c in white_coords_list:
            for nr, nc in get_neighbors(r, c, height, width):
                obj_label = labeled_objects[nr, nc]
                if obj_label != 0: # It's a non-white labeled object
                    adjacent_object_labels.add(obj_label)

        # Check if enclosed by exactly one non-white object
        if len(adjacent_object_labels) == 1:
            border_label = list(adjacent_object_labels)[0]
            
            # Find the color of the border object
            # Find first coordinate belonging to the border object label
            border_coords = np.argwhere(labeled_objects == border_label)
            if border_coords.size == 0 : # Should not happen, but safe check
                continue 
            border_color = input_grid[border_coords[0, 0], border_coords[0, 1]]

            # Find the largest interior object (non-white, non-border color)
            # Create a mask for pixels inside the white region AND non-white AND not border color
            potential_interior_obj_mask = interior_mask & (input_grid != 0) & (input_grid != border_color)
            
            # Label connected components within this specific mask
            labeled_interior_objs, num_interior_objs = label(potential_interior_obj_mask, structure=structure)

            largest_interior_object_color = None
            if num_interior_objs > 0:
                # Calculate sizes of these interior objects
                interior_obj_indices = np.arange(1, num_interior_objs + 1)
                object_sizes = ndi_sum(potential_interior_obj_mask, labeled_interior_objs, index=interior_obj_indices)

                if object_sizes.size > 0:
                    # Find the label of the largest object
                    largest_obj_local_label_idx = np.argmax(object_sizes)
                    largest_obj_label = interior_obj_indices[largest_obj_local_label_idx]
                    
                    # Find coordinates and color of this largest object
                    largest_obj_coords = np.argwhere(labeled_interior_objs == largest_obj_label)
                    if largest_obj_coords.size > 0:
                        # Use the coordinates relative to the original grid
                        largest_interior_object_color = input_grid[largest_obj_coords[0, 0], largest_obj_coords[0, 1]]

            # Determine the fill color using the map
            fill_key = (border_color, largest_interior_object_color)
            fill_color = fill_map.get(fill_key)

            # Apply the fill color to the output grid if a rule exists
            if fill_color is not None:
                # Fill the area identified by interior_mask (which corresponds to the current white region)
                output_grid[interior_mask] = fill_color

    return output_grid
```
