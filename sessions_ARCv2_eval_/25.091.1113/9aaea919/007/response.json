{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n# Define color constants for rules based on observations from examples\nPLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray\nLINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed\nGRAY_COLOR = 5\n\ndef _find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid case if necessary\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _find_objects(grid, background_color):\n    \"\"\"Finds all connected objects of non-background colors using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background and not yet visited, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor has the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef _check_shape(coords):\n    \"\"\"Determines if the object shape is a 5-pixel plus or horizontal line.\"\"\"\n    # Rule applies only to 5-pixel objects based on examples\n    if len(coords) != 5:\n        return None \n\n    rows = sorted([r for r, c in coords])\n    cols = sorted([c for r, c in coords])\n    min_r, max_r = rows[0], rows[-1]\n    min_c, max_c = cols[0], cols[-1]\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check for 3x3 bounding box (characteristic of a plus)\n    if height == 3 and width == 3:\n        # Verify it's a plus shape. The median coordinate should be the center.\n        center_r = rows[2] # Median row of the 5 sorted rows\n        center_c = cols[2] # Median col of the 5 sorted cols\n        # Check if the median coordinate is the center and if all expected points exist\n        expected_plus_coords = {\n            (center_r, center_c), \n            (center_r - 1, center_c), \n            (center_r + 1, center_c), \n            (center_r, center_c - 1), \n            (center_r, center_c + 1)\n        }\n        if coords == expected_plus_coords:\n            return \"plus\"\n\n    # Check for 1x5 bounding box (characteristic of a horizontal line)\n    if height == 1 and width == 5:\n         # Verify all 5 pixels form a contiguous horizontal line\n        expected_line_coords = set((min_r, c) for c in range(min_c, max_c + 1))\n        if coords == expected_line_coords:\n             return \"horizontal_line\"\n\n    # Note: Vertical lines (5x1) are not present in examples, so not explicitly checked.\n    \n    return None # Not a recognized 5-pixel shape for the rules\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on specific rules applied to 5-pixel objects.\n    1. Identifies the background color (most frequent color).\n    2. Creates an output grid filled with the background color.\n    3. Finds all connected objects (contiguous blocks of same color) \n       that are not the background color.\n    4. For each object:\n        a. If the object has exactly 5 pixels:\n            i. Determine its shape ('plus' or 'horizontal_line').\n            ii. Apply rules:\n                - Remove 5-pixel horizontal lines if Red(2) or Green(3).\n                - Change 5-pixel plus shapes to Gray(5) if Maroon(9), Magenta(6), or Green(3).\n                - Keep other 5-pixel shapes/colors unchanged.\n        b. If the object does not have 5 pixels, keep it unchanged (copy to output).\n    5. Draws the final state of each object onto the output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # Step 1: Identify the background color\n    background_color = _find_background_color(input_grid_np)\n\n    # Step 2: Create an output grid initialized with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # Step 3: Find all distinct non-background objects\n    objects = _find_objects(input_grid_np, background_color)\n\n    # Step 4 & 5: Process each object and draw on output grid\n    for obj in objects:\n        color = obj['color']\n        coords = obj['coords']\n        \n        output_color = color # Default: keep original color\n        apply_change = True # Flag to indicate if drawing is needed\n\n        # Step 4a: Check if object has 5 pixels\n        if len(coords) == 5:\n            # Step 4a.i: Determine shape\n            shape = _check_shape(coords)\n\n            # Step 4a.ii: Apply rules based on shape and color\n            if shape == \"horizontal_line\":\n                if color in LINE_TO_REMOVE_COLORS:\n                    # Remove the line by not drawing it (output remains background)\n                    apply_change = False \n                # else: keep original color (output_color = color, apply_change = True)\n\n            elif shape == \"plus\":\n                if color in PLUS_TO_GRAY_COLORS:\n                    # Change color to Gray\n                    output_color = GRAY_COLOR\n                # else: keep original color (output_color = color, apply_change = True)\n                \n            # else shape is None (not plus or hline): keep original color\n\n        # else (Step 4b): Object does not have 5 pixels, keep original color\n\n        # Draw the object onto the output grid if it wasn't removed\n        if apply_change:\n             for r, c in coords:\n                 # Bounds check just in case, though coords from _find_objects should be valid\n                 if 0 <= r < rows and 0 <= c < cols: \n                     output_grid[r, c] = output_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19564,
    "candidates_token_count": 1813,
    "total_token_count": 21377,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.926999,
  "retries": 1
}