{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n# Color constants based on the problem description (mapping not strictly needed for logic but good for reference)\n# COLOR_MAP = {\n#     0: 'white', 1: 'blue', 2: 'red', 3: 'green', 4: 'yellow',\n#     5: 'gray', 6: 'magenta', 7: 'orange', 8: 'azure', 9: 'maroon',\n# }\n\n# Colors to be modified or removed\nPLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray\nLINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed\nGRAY_COLOR = 5\n\ndef _find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid case if necessary, though ARC constraints likely prevent this\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _find_objects(grid, background_color):\n    \"\"\"Finds all connected objects of non-background colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background and not yet visited, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor has the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef _check_shape(coords):\n    \"\"\"Determines if the object shape is a 5-pixel plus or horizontal line.\"\"\"\n    if len(coords) != 5:\n        return None # Only considering 5-pixel shapes based on examples\n\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check for 3x3 bounding box (characteristic of a plus)\n    if height == 3 and width == 3:\n        # Verify it's a plus shape (center must exist and have 4 neighbors)\n        center_r = min_r + 1\n        center_c = min_c + 1\n        if (center_r, center_c) in coords and \\\n           (center_r - 1, center_c) in coords and \\\n           (center_r + 1, center_c) in coords and \\\n           (center_r, center_c - 1) in coords and \\\n           (center_r, center_c + 1) in coords:\n            return \"plus\"\n\n    # Check for 1x5 bounding box (characteristic of a horizontal line)\n    if height == 1 and width == 5:\n         # Verify all 5 pixels are present consecutively\n        expected_coords = set((min_r, c) for c in range(min_c, max_c + 1))\n        if coords == expected_coords:\n             return \"horizontal_line\"\n\n    # Potentially add check for vertical line (5x1) if needed, but not in examples\n\n    return None # Unknown 5-pixel shape\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on specific object shapes and colors.\n    - Identifies the background color.\n    - Finds all non-background objects (connected components).\n    - Determines the shape of each 5-pixel object (plus or horizontal line).\n    - Applies rules:\n        - Removes 5-pixel horizontal lines if they are Red (2) or Green (3).\n        - Changes the color of 5-pixel plus shapes to Gray (5) if they are\n          Maroon (9), Magenta (6), or Green (3).\n        - Keeps all other identified objects unchanged.\n    - Returns the transformed grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify the background color\n    background_color = _find_background_color(input_grid_np)\n\n    # 2. Create an output grid initialized with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 3. Find all distinct objects\n    objects = _find_objects(input_grid_np, background_color)\n\n    # 4. Process each object\n    for obj in objects:\n        color = obj['color']\n        coords = obj['coords']\n\n        # 4a. Determine the shape\n        shape = _check_shape(coords)\n\n        # 4b. Apply transformation rules based on shape and color\n        if shape == \"horizontal_line\" and color in LINE_TO_REMOVE_COLORS:\n            # Do nothing - pixels remain background color in output_grid\n            pass\n        elif shape == \"plus\" and color in PLUS_TO_GRAY_COLORS:\n            # Change color to Gray\n            for r, c in coords:\n                output_grid[r, c] = GRAY_COLOR\n        else:\n            # Keep the object as is (copy its pixels to the output grid)\n            # This covers plus shapes of other colors, horizontal lines of other colors,\n            # and any shapes not explicitly handled (though examples only show these two)\n            for r, c in coords:\n                output_grid[r, c] = color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12740,
    "candidates_token_count": 1601,
    "total_token_count": 14341,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.297018,
  "retries": 1
}