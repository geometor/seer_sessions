{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on specific rules applied to 5-pixel objects.\n1. Identifies the background color (most frequent color).\n2. Creates an output grid filled with the background color.\n3. Finds all connected objects of non-background colors.\n4. Filters for objects consisting of exactly 5 pixels.\n5. Determines the shape of each 5-pixel object ('plus' or 'horizontal_line').\n6. Applies rules:\n   - Removes 5-pixel horizontal lines if they are Red (2) or Green (3) by leaving them as the background color.\n   - Changes the color of 5-pixel plus shapes to Gray (5) if they are Maroon (9), Magenta (6), or Green (3).\n   - Keeps all other identified 5-pixel plus or horizontal line shapes unchanged (copies their original color to the output).\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter, deque\n\n# Define color constants for rules\nPLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray\nLINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed\nGRAY_COLOR = 5\n\ndef _find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid case if necessary\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _find_objects(grid, background_color):\n    \"\"\"Finds all connected objects of non-background colors using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background and not yet visited, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor has the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef _check_shape(coords):\n    \"\"\"Determines if the object shape is a 5-pixel plus or horizontal line.\"\"\"\n    # Rule applies only to 5-pixel objects based on examples\n    if len(coords) != 5:\n        return None \n\n    rows = sorted([r for r, c in coords])\n    cols = sorted([c for r, c in coords])\n    min_r, max_r = rows[0], rows[-1]\n    min_c, max_c = cols[0], cols[-1]\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check for 3x3 bounding box (characteristic of a plus)\n    if height == 3 and width == 3:\n        # Verify it's a plus shape (center must exist and have 4 neighbors)\n        center_r = rows[2] # Median row\n        center_c = cols[2] # Median col\n        # Check if the median coordinate is the center and if all expected points exist\n        expected_plus_coords = {\n            (center_r, center_c), \n            (center_r - 1, center_c), \n            (center_r + 1, center_c), \n            (center_r, center_c - 1), \n            (center_r, center_c + 1)\n        }\n        if coords == expected_plus_coords:\n            return \"plus\"\n\n    # Check for 1x5 bounding box (characteristic of a horizontal line)\n    if height == 1 and width == 5:\n         # Verify all 5 pixels are present consecutively\n        expected_line_coords = set((min_r, c) for c in range(min_c, max_c + 1))\n        if coords == expected_line_coords:\n             return \"horizontal_line\"\n\n    # Note: Vertical lines (5x1) are not present in examples, so not explicitly checked.\n    \n    return None # Not a recognized 5-pixel shape\n\ndef transform(input_grid):\n    \"\"\"\n    Applies shape and color-based transformations to a grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Identify the background color\n    background_color = _find_background_color(input_grid_np)\n\n    # 2. Create an output grid initialized with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 3. Find all distinct non-background objects\n    objects = _find_objects(input_grid_np, background_color)\n\n    # 4. Process each object\n    for obj in objects:\n        color = obj['color']\n        coords = obj['coords']\n        \n        # Focus only on 5-pixel objects as per observations\n        if len(coords) != 5:\n            # If object size isn't 5, copy it as is (defensive programming)\n            # Although examples only show 5-pixel objects being transformed\n            for r, c in coords:\n                 if 0 <= r < rows and 0 <= c < cols: # Ensure coords are valid\n                     output_grid[r,c] = color\n            continue # Skip shape check and specific rules for non-5-pixel objects\n\n        # 4a. Determine the shape for 5-pixel objects\n        shape = _check_shape(coords)\n\n        # 4b. Apply transformation rules based on shape and color\n        output_color = color # Default: keep original color\n\n        if shape == \"horizontal_line\":\n            if color in LINE_TO_REMOVE_COLORS:\n                # Keep background color by setting output_color to it\n                output_color = background_color \n            # else: keep original color (output_color = color)\n\n        elif shape == \"plus\":\n            if color in PLUS_TO_GRAY_COLORS:\n                # Change color to Gray\n                output_color = GRAY_COLOR\n            # else: keep original color (output_color = color)\n\n        # else shape is None or not 'plus'/'horizontal_line': keep original color \n        # (output_color = color)\n        \n        # 5. Draw the object onto the output grid with the determined output color\n        # If output_color is background_color, the object is effectively removed.\n        if output_color != background_color:\n             for r, c in coords:\n                 # Bounds check just in case, though coords should be valid\n                 if 0 <= r < rows and 0 <= c < cols: \n                     output_grid[r, c] = output_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21464,
    "candidates_token_count": 1850,
    "total_token_count": 23314,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.580383,
  "retries": 1
}