{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all rectangular regions enclosed by solid, single-color frames within the input grid.\nSorts these identified regions based on their top-left corner coordinates (first by row, then by column).\nExtracts the subgrid corresponding to the bounding box (including the frame) of the *last* region in the sorted list.\n\"\"\"\n\ndef _find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid using BFS.\n    Helper function for _find_framed_rectangles.\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find components of.\n    Returns:\n        list: A list of dictionaries, each representing a component with\n              'pixels' (a set of (row, col) tuples),\n              'bbox' (min_r, min_c, max_r, max_c), and\n              'color' (the target_color).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is the target color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Store the component information\n                components.append({\n                    'pixels': component_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'color': target_color\n                })\n    return components\n\ndef _is_solid_frame(grid, component):\n    \"\"\"\n    Checks if a connected component forms a solid rectangular frame.\n    Helper function for _find_framed_rectangles.\n    Args:\n        grid (np.array): The input grid.\n        component (dict): A component dictionary from _find_connected_components.\n    Returns:\n        bool: True if the component forms a valid, solid frame, False otherwise.\n    \"\"\"\n    min_r, min_c, max_r, max_c = component['bbox']\n    pixels = component['pixels']\n    frame_color = component['color']\n    \n    # Frame must be at least 3x3 to have a distinct interior\n    if max_r - min_r < 2 or max_c - min_c < 2:\n        return False\n\n    # Condition 1: All pixels of the component must lie exactly on the perimeter of its bounding box.\n    # Condition 2: All cells on the perimeter of the bounding box must belong to the component.\n    # We can check both by iterating through the perimeter and verifying the pixel set.\n    expected_perimeter_pixels = set()\n    # Top and bottom rows\n    for c in range(min_c, max_c + 1):\n        expected_perimeter_pixels.add((min_r, c))\n        expected_perimeter_pixels.add((max_r, c))\n    # Left and right columns (excluding corners already added)\n    for r in range(min_r + 1, max_r):\n        expected_perimeter_pixels.add((r, min_c))\n        expected_perimeter_pixels.add((r, max_c))\n        \n    if pixels != expected_perimeter_pixels:\n        return False # The component either doesn't cover the whole perimeter or includes interior points\n\n    # Condition 3: The interior area must not contain any pixels of the frame's color.\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            if grid[r, c] == frame_color:\n                return False # Found frame color inside\n\n    # If all checks pass, it's a valid solid frame.\n    return True\n\n\ndef _find_framed_rectangles(grid):\n    \"\"\"\n    Identifies all rectangular regions enclosed by a solid, single-color frame.\n    Args:\n        grid (np.array): The input grid.\n    Returns:\n        list: A list of bounding boxes (r1, c1, r2, c2) for the identified\n              framed rectangles, sorted by top-left corner (row, then column).\n    \"\"\"\n    unique_colors = np.unique(grid)\n    valid_frames = []\n\n    # Find components for every color present in the grid, excluding typical backgrounds like black(0) if necessary\n    # Based on examples, frames seem to be non-zero colors, but let's check all for robustness.\n    for color in unique_colors:\n        # Find all connected regions of this color\n        components = _find_connected_components(grid, color)\n        # Check if each component forms a valid frame\n        for comp in components:\n            if _is_solid_frame(grid, comp):\n                valid_frames.append(comp['bbox']) # Store the bounding box\n\n    # Sort the identified frames primarily by top row, secondarily by leftmost column\n    valid_frames.sort(key=lambda bbox: (bbox[0], bbox[1]))\n\n    return valid_frames\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies solid single-color rectangular frames, sorts them by top-left position,\n    and returns the subgrid corresponding to the bounding box of the last frame.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n\n    # Find all valid framed rectangles, sorted by position (top-left corner)\n    framed_rect_bboxes = _find_framed_rectangles(input_array)\n\n    # Check if any framed rectangles were found\n    if not framed_rect_bboxes:\n        # Behavior for no frames found isn't strictly defined by examples.\n        # Returning an empty grid is a reasonable default.\n        return [] \n\n    # Select the bounding box of the *last* rectangle in the sorted list\n    r1, c1, r2, c2 = framed_rect_bboxes[-1]\n\n    # Extract the subgrid defined by the bounding box (inclusive slicing)\n    # Numpy slicing is exclusive of the end index, so add 1 to r2 and c2\n    output_array = input_array[r1 : r2 + 1, c1 : c2 + 1]\n\n    # Convert the resulting numpy array back to a list of lists format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10591,
    "candidates_token_count": 1781,
    "total_token_count": 12372,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.667175,
  "retries": 1
}