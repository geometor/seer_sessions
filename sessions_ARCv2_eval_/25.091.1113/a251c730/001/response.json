{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies rectangular regions enclosed by single-color frames within the input grid.\nSorts these regions based on their top-left corner (row, then column).\nExtracts the subgrid corresponding to the bounding box (including the frame) of the second identified region.\n\"\"\"\n\ndef _find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid using BFS.\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find components of.\n    Returns:\n        list: A list of dictionaries, each representing a component with\n              'pixels' (a set of (row, col) tuples) and\n              'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is the target color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Store the component information\n                components.append({\n                    'pixels': set(component_pixels),\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'color': target_color\n                })\n    return components\n\ndef _find_framed_rectangles(grid):\n    \"\"\"\n    Identifies all rectangular regions enclosed by a single-color frame.\n    Args:\n        grid (np.array): The input grid.\n    Returns:\n        list: A list of bounding boxes (r1, c1, r2, c2) for the identified\n              framed rectangles, sorted by top-left corner (row, then column).\n    \"\"\"\n    rows, cols = grid.shape\n    unique_colors = np.unique(grid)\n    all_components = []\n    # Find components for every color present in the grid\n    for color in unique_colors:\n        all_components.extend(_find_connected_components(grid, color))\n\n    framed_rectangles_data = [] # Store tuples: (bbox, frame_color)\n\n    # Analyze each component to see if it forms a valid frame\n    for comp in all_components:\n        min_r, min_c, max_r, max_c = comp['bbox']\n        pixels = comp['pixels']\n        frame_color = comp['color']\n\n        # A frame must have a minimum bounding box size of 2x2 to enclose an interior\n        if max_r - min_r < 1 or max_c - min_c < 1:\n            continue\n\n        is_valid_frame = True\n        # Condition 1: All pixels of the component must lie exactly on the perimeter of its bounding box.\n        for r_pix, c_pix in pixels:\n            is_on_border = (r_pix == min_r or r_pix == max_r or\n                            c_pix == min_c or c_pix == max_c)\n            if not is_on_border:\n                is_valid_frame = False\n                break\n        if not is_valid_frame: continue\n\n        # Condition 2: All cells on the perimeter of the bounding box must belong to the component.\n        # Check top/bottom rows of the bounding box\n        for c in range(min_c, max_c + 1):\n             if (min_r, c) not in pixels or (max_r, c) not in pixels:\n                  is_valid_frame = False; break\n        if not is_valid_frame: continue\n        # Check left/right columns of the bounding box (excluding corners already checked)\n        for r in range(min_r + 1, max_r):\n             if (r, min_c) not in pixels or (r, max_c) not in pixels:\n                  is_valid_frame = False; break\n        if not is_valid_frame: continue\n\n        # Condition 3: The interior area must exist and must not contain any pixels of the frame's color.\n        has_interior = False\n        interior_is_clear = True\n        # Iterate through the cells strictly inside the bounding box\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                has_interior = True # Mark that an interior exists\n                if grid[r, c] == frame_color:\n                    interior_is_clear = False # Found frame color inside\n                    break\n            if not interior_is_clear: break # Stop checking interior if violation found\n\n        # If all conditions are met, it's a valid framed rectangle\n        if is_valid_frame and has_interior and interior_is_clear:\n            framed_rectangles_data.append(((min_r, min_c, max_r, max_c), frame_color))\n\n    # Sort the identified frames primarily by top row, secondarily by leftmost column\n    framed_rectangles_data.sort(key=lambda item: (item[0][0], item[0][1]))\n\n    # Return only the bounding boxes in sorted order\n    return [box for box, color in framed_rectangles_data]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies rectangular regions enclosed by single-color frames within the input grid.\n    Sorts these regions based on their top-left corner (row, then column).\n    Extracts the subgrid corresponding to the bounding box (including the frame) of the second identified region.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n\n    # Find all framed rectangles, sorted by position (top-left corner)\n    framed_rect_bboxes = _find_framed_rectangles(input_array)\n\n    # Check if at least two framed rectangles were found\n    if len(framed_rect_bboxes) < 2:\n        # If fewer than two frames are found, the rule cannot be applied as described.\n        # Behavior in this edge case isn't specified; raising an error or returning\n        # a default (like empty list or original grid) are options.\n        # Here, we'll raise an IndexError implicitly if we try to access index 1.\n        # Consider adding explicit error handling if needed.\n        print(f\"Warning: Found {len(framed_rect_bboxes)} framed rectangles, expected at least 2.\")\n        # Or return input_grid or [] depending on desired behavior for non-applicable cases\n        if not framed_rect_bboxes: return [] # Return empty list if none found\n        # If only one found, the task description for the *second* cannot be met.\n        # Let's cause an error to signal the condition isn't met.\n        # Fallthrough will cause IndexError below if len < 2\n\n\n    # Select the bounding box of the second rectangle (index 1 in the sorted list)\n    r1, c1, r2, c2 = framed_rect_bboxes[1]\n\n    # Extract the subgrid defined by the bounding box (inclusive slicing)\n    # Numpy slicing is exclusive of the end index, so add 1 to r2 and c2\n    output_array = input_array[r1 : r2 + 1, c1 : c2 + 1]\n\n    # Convert the resulting numpy array back to a list of lists format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6018,
    "candidates_token_count": 2029,
    "total_token_count": 8047,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 154.836484,
  "retries": 2
}