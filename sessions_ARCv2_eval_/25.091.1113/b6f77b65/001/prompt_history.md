
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

Okay, let's break down this task.

**Perception of Task Elements:**

1.  **Input/Output Structure:** Both input and output are 12x12 grids containing colored pixels (integers 0-9).
2.  **Background:** The predominant color is white (0), serving as the background.
3.  **Key Pixel:** The pixel at the top-left corner `[0, 0]` seems significant. It has a non-white color in all examples.
4.  **Main Content:** There are various colored shapes or patterns distributed within the grid, separate from the top-left pixel.
5.  **Transformation:** In most examples (train\_2, 3, 4, 5), the main content of the grid appears to be shifted downwards and rightwards relative to its position in the input. The amount of shift varies between examples.
6.  **Stationary Pixel:** The top-left pixel `[0, 0]` does *not* move during the transformation; its position and color remain the same in the output.
7.  **Shift Control:** The color of the top-left pixel appears to determine the direction and magnitude of the shift applied to the rest of the grid content.
8.  **Example 1 Anomaly:** In train\_1, the input and output are identical. The top-left pixel is maroon (9). This suggests that the color maroon might correspond to a "no shift" or (0, 0) shift operation.
9.  **Shift Mapping:**
    *   Maroon (9) at `[0, 0]` -> No shift (0 rows down, 0 columns right).
    *   Yellow (4) at `[0, 0]` -> Shift 3 rows down, 2 columns right.
    *   Magenta (6) at `[0, 0]` -> Shift 3 rows down, 1 column right.
    *   Orange (7) at `[0, 0]` -> Shift 3 rows down, 1 column right.
10. **Clipping:** When the content is shifted, any pixels that would move outside the grid boundaries are clipped (discarded). The newly vacant areas resulting from the shift are filled with the background color (white, 0).

**YAML Facts:**


```yaml
Grid:
  Type: 2D Array
  Dimensions: 12x12 (variable, but consistent within a pair)
  Cell Values: Integers 0-9 (Colors)
  Background Color: 0 (white)

Objects:
  - Name: ControlPixel
    Location: Top-left corner (coordinates [0, 0])
    Property: Color (value C)
    Role: Determines the transformation (shift vector) for other objects. Remains stationary in the output.
  - Name: GridContent
    Description: All non-background pixels excluding the ControlPixel.
    Composition: Can be multiple disconnected shapes or patterns.
    Behavior: Undergoes a translational shift.

Transformation:
  Type: Conditional Shift
  Condition: Based on the Color (C) of the ControlPixel.
  Shift Vectors (delta_row, delta_col):
    - If C == 9 (Maroon): (0, 0)
    - If C == 4 (Yellow): (3, 2)
    - If C == 6 (Magenta): (3, 1)
    - If C == 7 (Orange): (3, 1)
  Process:
    - Apply the determined shift vector to the coordinates of every pixel belonging to the GridContent.
    - Pixels shifted outside the grid boundaries are removed.
    - The ControlPixel remains at [0, 0] in the output.
    - The output grid is initialized with the Background Color, then populated with the stationary ControlPixel and the shifted GridContent.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid, filled entirely with the background color (white, 0).
2.  Identify the color (`C`) of the input grid's pixel at coordinates `[0, 0]` (the ControlPixel).
3.  Determine the vertical shift (`delta_row`) and horizontal shift (`delta_col`) based on the ControlPixel color `C`:
    *   If `C` is 9 (Maroon), set `delta_row = 0` and `delta_col = 0`.
    *   If `C` is 4 (Yellow), set `delta_row = 3` and `delta_col = 2`.
    *   If `C` is 6 (Magenta), set `delta_row = 3` and `delta_col = 1`.
    *   If `C` is 7 (Orange), set `delta_row = 3` and `delta_col = 1`.
    *   (Assume other colors result in no shift, or handle as errors if they appear).
4.  Place the ControlPixel's color `C` back into the output grid at coordinates `[0, 0]`.
5.  Iterate through each pixel in the input grid, starting from row 0, column 1 (to skip the ControlPixel at `[0,0]` handled separately) and then all subsequent rows (row 1 onwards, all columns). Let the current input coordinates be `(r, c)` and the pixel color be `input_color`.
6.  If `input_color` is not the background color (white, 0):
    *   Calculate the target coordinates in the output grid: `new_r = r + delta_row`, `new_c = c + delta_col`.
    *   Check if `new_r` and `new_c` are within the valid bounds of the output grid (i.e., `0 <= new_r < grid_height` and `0 <= new_c < grid_width`).
    *   If the target coordinates are within bounds, set the pixel at `(new_r, new_c)` in the output grid to `input_color`.
7.  The final state of the output grid is the result.
