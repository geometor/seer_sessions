
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 2 8 2 1 1 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1
1 1 2 2 2 1 1 3 2 2 2 2 3 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 3 3 3 3 3 3 1 1 1 1 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 4 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 4
4 3 3 3 3 3 3 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 5 5 5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 5 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 2 5 5 5 2 2 2 5 5 5 5 2 2 2 2 2 2 2 2 2 2 2 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3
3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 3
3 8 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 4 4 2 8 8 8 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8
8 2 4 4 2 8 8 8 2 4 4 2 4 4 2 8 8 8 8 8 8 8 8 8
8 2 2 2 2 8 8 8 2 4 4 2 4 4 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 4 4 2 4 4 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 2 2 2 2 2 2 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 4
4 4 4 4 4 2 2 2 4 2 2 4 2 2 4 2 2 2 2 2 2 2 2 4
4 4 2 2 4 2 2 2 4 2 2 4 2 2 4 2 2 2 2 2 2 2 2 4
4 4 2 2 4 2 2 2 4 2 2 4 2 2 4 2 2 2 2 2 2 2 2 4
4 4 4 4 4 2 2 2 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6
6 4 4 4 4 4 4 4 4 6 6 4 6 6 4 4 4 4 4 4 4 4 4 6
6 4 6 6 4 4 4 4 4 6 6 4 6 6 4 4 4 4 4 4 4 4 4 6
6 4 6 6 4 4 4 4 4 6 6 4 6 6 4 4 4 4 4 4 4 4 4 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 4 4 4 4
4 4 4 3 3 4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 4 4 4 4
4 4 4 3 3 4 4 4 4 4 4 4 4 8 8 4 4 4 8 8 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 3 3 3 3 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 1 1 3 1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 1
1 3 3 1 1 3 3 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6 6 6 6 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6 6 6 6 8 8 8 6
6 8 8 8 8 8 8 8 8 8 8 8 8 6 6 8 8 8 6 6 8 8 8 6
```

Okay, let's break down this task.

## Perception

1.  **Input Grid Structure:** Each input grid appears segmented into distinct regions. There's typically an upper area with a background color (blue, azure, or yellow in the examples) containing several smaller, distinct objects composed of one or more colors. Below this, there are horizontal bands, each characterized by a fill color bordered on the left/right by a different border color. Sometimes there are separator lines (like full rows of blue or azure) between these regions or bands.
2.  **Output Grid Structure:** The output grid retains the overall structure, particularly the horizontal bands and separator lines. However, the objects originally present in the upper area of the input grid are removed (replaced by the upper background color). Crucially, modifications occur *within* the fill areas of the horizontal bands.
3.  **Transformation:** The core transformation involves transferring information from the upper objects ("patterns") to the lower horizontal bands ("targets"). Specifically, the *shape* of each pattern object from the top section is "stamped" or "drawn" onto the fill area of a corresponding target band below. The color used for stamping is the *border* color of the target band.
4.  **Pattern-Target Matching:** There's a one-to-one correspondence between the pattern objects in the top section and the target bands in the bottom section. The matching rule seems to be based on color: a pattern object is matched to a target band if one of the colors *within* the pattern object matches the *fill* color of the target band. In cases where multiple patterns could match a band based on the same color (Example 2, where two patterns contain red, and one band has a red fill), the pattern with the *most pixels* of the matching color is assigned to that band.
5.  **Stamping Process:** Once a pattern shape is matched to a target band, the shape (defined by the non-background pixels within the pattern object's bounding box) is drawn onto the target band's fill area using the target band's border color. The original fill color pixels within the shape's area are overwritten.
6.  **Cleanup:** The original pattern objects in the upper area are erased from the output grid, replaced by the background color of that upper area.

## Facts


```yaml
InputGrid:
  Properties:
    - segmentation: Contains distinct upper and lower regions.
    - upper_region:
        - contains: pattern_objects
        - background_color: dominant color in the upper area (e.g., blue, azure, yellow)
    - lower_region:
        - contains: horizontal_bands
        - contains: separator_lines (optional, single color rows)
  Elements:
    - pattern_object:
        - description: Connected component of non-background pixels in the upper_region.
        - properties:
            - shape: Relative coordinates of its non-background pixels.
            - colors: Set of colors present within the object.
            - color_counts: Count of pixels for each color within the object.
            - location: Bounding box or coordinates in the upper_region.
    - horizontal_band:
        - description: Rectangular area in the lower_region.
        - properties:
            - fill_color: Color of the main central part of the band.
            - border_color: Color of the pixels typically flanking the fill area on the left/right.
            - fill_area: Coordinates corresponding to the fill_color pixels.
            - location: Row indices defining the band.
    - background_pixel: Pixel belonging to the dominant background color of the upper_region.

OutputGrid:
  Properties:
    - derivation: Derived from InputGrid by applying transformations.
    - structure: Retains separator_lines and band structure from InputGrid.
    - upper_region: Contains only the background_color from the input's upper_region.
    - lower_region: Horizontal bands are potentially modified.

Transformation:
  Actions:
    - identify_elements:
        - Find background_color of the upper_region.
        - Find all pattern_objects in the upper_region. Extract shape, colors, and color_counts for each.
        - Find all horizontal_bands in the lower_region. Extract fill_color, border_color, and fill_area for each.
    - match_patterns_to_bands:
        - Establish a one-to-one mapping between pattern_objects and horizontal_bands.
        - rule: For a band B with fill_color C_fill:
            - Find all available patterns P containing C_fill.
            - If one pattern P is found, match P to B.
            - If multiple patterns P1, P2... are found, match the pattern P_max (which has the highest count of C_fill pixels) to B.
        - dependencies: Matches might need to be resolved iteratively if choices depend on prior matches.
    - stamp_shapes:
        - For each matched pair (pattern P, band B):
            - Get the shape S of pattern P.
            - Get the border_color C_border of band B.
            - Get the fill_area A of band B.
            - Modify the output grid: For each pixel location within shape S (relative to its origin), find the corresponding absolute coordinate within the fill_area A and set its color to C_border.
    - cleanup_upper_region:
        - Replace all pixels in the output grid corresponding to the original pattern_objects' locations with the upper_region's background_color.
```


## Natural Language Program

1.  **Initialization:** Create a copy of the input grid to serve as the initial output grid.
2.  **Identify Upper Background:** Determine the background color of the upper region of the input grid (e.g., the most frequent color in the top portion or the color at the corners).
3.  **Extract Patterns:** Locate all distinct connected objects in the upper region that are not the background color. For each object (pattern):
    *   Record its shape (the relative positions of all its constituent pixels).
    *   Record the set of colors it contains and the count of pixels for each color.
    *   Keep track of the original locations of these pattern objects.
4.  **Extract Bands:** Identify all horizontal bands in the lower region. For each band:
    *   Record its fill color.
    *   Record its border color (typically found in columns flanking the fill area within the band's rows).
    *   Record the coordinates defining its fill area.
5.  **Match Patterns and Bands:**
    *   Create lists of the extracted patterns and bands.
    *   Iteratively match patterns to bands:
        *   For each unmatched band `B` with fill color `C_fill`:
            *   Identify the set of unmatched patterns `P_candidates` where each pattern contains the color `C_fill`.
            *   If `P_candidates` is empty, continue to the next band.
            *   If `P_candidates` contains exactly one pattern `P`, match `P` to `B`. Mark both as matched.
            *   If `P_candidates` contains multiple patterns, find the pattern `P_best` within `P_candidates` that has the maximum count of pixels with the color `C_fill`. Match `P_best` to `B`. Mark both as matched.
    *   Repeat this process until all patterns and bands are matched.
6.  **Apply Stamping:**
    *   For each matched pair (Pattern `P`, Band `B`):
        *   Retrieve the shape `S` of pattern `P`.
        *   Retrieve the border color `C_border` of band `B`.
        *   Retrieve the fill area coordinates `A` of band `B`.
        *   For every pixel coordinate defined by shape `S` (relative to the pattern's origin), calculate its corresponding absolute coordinate within the band's fill area `A` in the output grid.
        *   Change the color of these pixels in the output grid to `C_border`.
7.  **Clean Up:** Go back to the original locations of the pattern objects identified in step 3. In the output grid, set all pixels at these locations to the upper background color identified in step 2.
8.  **Final Output:** The modified grid is the final output.
```python
import numpy as np
from collections import Counter, defaultdict

"""
Transformation Rule Description:

1.  **Identify Regions & Elements:**
    *   The input grid is conceptually divided into an upper region containing 'pattern' objects and a lower region containing horizontal 'bands'. There might be separator rows between these regions or between bands.
    *   Determine the background color of the upper region (often the color at 0,0).
    *   Find all connected components (objects) in the upper region that are not the background color. These are the 'patterns'. For each pattern, record its constituent pixels' coordinates, the set of colors it contains, and the count of each color.
    *   Identify horizontal bands in the lower region. A band is characterized by a central 'fill color' and a 'border color' typically flanking the fill area horizontally. Record the fill color, border color, and the coordinates of the fill area for each band.

2.  **Match Patterns to Bands:**
    *   Establish a one-to-one correspondence between patterns and bands.
    *   The matching rule is based on color: A pattern is a potential match for a band if one of the colors *within* the pattern is the same as the band's *fill color*.
    *   If multiple patterns could match a single band based on its fill color, the pattern with the *highest count* of that fill color among its pixels is chosen for the match.

3.  **Stamp Patterns onto Bands:**
    *   Create an output grid, initially a copy of the input grid.
    *   For each matched (pattern, band) pair:
        *   Determine the shape of the pattern (the relative coordinates of its pixels from its top-left corner).
        *   Get the top-left coordinate of the band's *fill area*.
        *   Get the band's *border color*.
        *   "Stamp" the pattern's shape onto the band's fill area in the output grid using the band's border color. This means for each relative coordinate `(dr, dc)` in the pattern's shape, the pixel at `(band_fill_top_left_row + dr, band_fill_top_left_col + dc)` in the output grid is set to the band's border color, overwriting the original fill color.

4.  **Clean Up Upper Region:**
    *   In the output grid, replace all pixels corresponding to the original locations of the pattern objects with the upper region's background color.

5.  **Return Output:** The modified grid is the result.
"""

def find_objects(grid, background_color, region_mask):
    """Finds connected objects of non-background colors within a specified region."""
    objects = []
    visited = np.zeros(grid.shape, dtype=bool)
    rows, cols = grid.shape

    for r in range(rows):
        for c in range(cols):
            # Check if the pixel is within the specified region, not background, and not visited
            if region_mask[r, c] and grid[r, c] != background_color and not visited[r, c]:
                obj_coords = set()
                obj_colors = Counter()
                q = [(r, c)]
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c

                while q:
                    row, col = q.pop(0)
                    obj_coords.add((row, col))
                    obj_colors[grid[row, col]] += 1
                    min_r = min(min_r, row)
                    min_c = min(min_c, col)
                    max_r = max(max_r, row)
                    max_c = max(max_c, col)

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           region_mask[nr, nc] and \
                           grid[nr, nc] != background_color and \
                           not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                # Calculate relative shape
                shape = set((orow - min_r, ocol - min_c) for orow, ocol in obj_coords)

                objects.append({
                    'coords': obj_coords,
                    'bbox': (min_r, min_c, max_r, max_c),
                    'colors': dict(obj_colors),
                    'shape': shape,
                    'top_left': (min_r, min_c)
                })
    return objects

def find_bands(grid, start_row):
    """Identifies horizontal bands below a given start row."""
    bands = []
    rows, cols = grid.shape
    if start_row >= rows:
        return bands

    current_band_rows = []
    for r in range(start_row, rows):
        row_data = grid[r, :]
        # Basic band heuristic: Check if first and last pixel differ from the second
        if cols >= 3 and row_data[0] != row_data[1] and row_data[0] == row_data[-1]:
            border_color = row_data[0]
            fill_color = row_data[1]
            # Check if the central part is mostly the fill color
            is_band_row = True
            fill_coords_row = set()
            for c in range(1, cols - 1):
                if row_data[c] == fill_color:
                    fill_coords_row.add((r, c))
                elif row_data[c] != border_color: # Allow border color inside sometimes? No, strictly fill or border
                     # Example 3 shows stamping can happen over border pixels if they are inside the fill region conceptually
                     # Let's stick to the simple definition first: border | fill+ | border
                     pass # Allow other colors? Let's assume only fill/border for now.
                     # Revisit: The examples show stamping *can* overwrite border color if it's inside the fill area bounds.
                     # Let's define fill area more loosely first: columns between the first and last.
                     # Better: Find first and last column index of the fill color.
                #else:
                #    is_band_row = False
                #    break
            
            # More robust check: scan inwards for border and fill
            left_border_end = 0
            while left_border_end < cols and row_data[left_border_end] == border_color:
                left_border_end += 1
            
            right_border_start = cols - 1
            while right_border_start >= 0 and row_data[right_border_start] == border_color:
                right_border_start -= 1

            # Potential fill area is between left_border_end and right_border_start
            potential_fill_color = -1
            is_simple_band = True
            if left_border_end <= right_border_start:
                potential_fill_color = row_data[left_border_end]
                for c in range(left_border_end, right_border_start + 1):
                     # Allow fill color or border color within the fill zone due to stamping
                    if row_data[c] != potential_fill_color and row_data[c] != border_color : 
                        is_simple_band = False
                        break
            else: # No fill area
                is_simple_band = False

            if is_simple_band and potential_fill_color != -1 and potential_fill_color != border_color :
                # This looks like a band row
                if not current_band_rows or \
                   (grid[current_band_rows[-1][0], 0] == border_color and \
                    grid[current_band_rows[-1][0], left_border_end] == potential_fill_color): # Check continuity
                    current_band_rows.append((r, border_color, potential_fill_color, left_border_end, right_border_start))
                else:
                    # End previous band
                    if current_band_rows:
                        bands.append(process_band_rows(grid, current_band_rows))
                    current_band_rows = [(r, border_color, potential_fill_color, left_border_end, right_border_start)]
            else:
                 # End previous band if any
                if current_band_rows:
                    bands.append(process_band_rows(grid, current_band_rows))
                current_band_rows = [] # Reset, not a band row or different band type
        else:
            # End previous band if any
            if current_band_rows:
                 bands.append(process_band_rows(grid, current_band_rows))
            current_band_rows = [] # Reset, not a band row

    # Add the last band if it exists
    if current_band_rows:
         bands.append(process_band_rows(grid, current_band_rows))

    return bands

def process_band_rows(grid, band_rows_info):
    """Helper to consolidate information for a band spanning multiple rows."""
    start_r = band_rows_info[0][0]
    end_r = band_rows_info[-1][0]
    border_color = band_rows_info[0][1]
    fill_color = band_rows_info[0][2] # Assuming fill color is consistent
    
    # Determine fill area bounds (min/max columns over all rows)
    min_fill_c = grid.shape[1]
    max_fill_c = -1
    fill_coords = set()
    fill_min_r, fill_min_c = start_r, grid.shape[1]


    for r, bc, fc, lbe, rbs in band_rows_info:
         # Define fill columns strictly as non-border between the borders
        current_min_c = lbe
        current_max_c = rbs
        min_fill_c = min(min_fill_c, current_min_c)
        max_fill_c = max(max_fill_c, current_max_c)
        
        # Collect actual fill coordinates (original fill color) - might be needed?
        # Stamping uses the border color, overwriting whatever is there.
        # We need the top-left corner of the conceptual fill *rectangle* for stamping alignment.
        fill_min_c = min(fill_min_c, current_min_c) # Update fill top-left
        
        for c in range(current_min_c, current_max_c + 1):
              fill_coords.add((r,c)) # Add all coords within the fill bounds


    return {
        'rows': (start_r, end_r),
        'fill_color': fill_color,
        'border_color': border_color,
        'fill_coords': fill_coords, # All coords within L/R bounds
        'fill_bbox': (start_r, min_fill_c, end_r, max_fill_c),
         'fill_top_left': (start_r, min_fill_c)
    }


def transform(input_grid):
    """
    Applies the pattern stamping transformation.
    """
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify Upper Background Color (Assume top-left)
    upper_background_color = input_grid[0, 0]

    # 2. Find potential band start row
    # Find the first row that looks like a band or a separator that isn't the background color
    band_start_row = 0
    found_lower_region = False
    for r in range(rows):
        is_background_row = np.all(input_grid[r,:] == upper_background_color)
        # Check for simple band structure (as in find_bands)
        is_band_like = False
        if cols >= 3 and input_grid[r, 0] != input_grid[r, 1] and input_grid[r, 0] == input_grid[r, -1] and input_grid[r,0] != upper_background_color:
             is_band_like = True
        # Check for separator line (single color, not background)
        is_separator = len(np.unique(input_grid[r,:])) == 1 and input_grid[r,0] != upper_background_color
        
        if not is_background_row and (is_band_like or is_separator):
             band_start_row = r
             found_lower_region = True
             break
    
    # If no bands/separators found, the whole grid might be the upper region? Or task is different.
    # For this specific task structure, assume bands exist. If not found, maybe default to row 0 or half?
    # Let's assume band_start_row correctly identifies the split.

    # Define upper region mask
    upper_region_mask = np.zeros(input_grid.shape, dtype=bool)
    if found_lower_region:
        upper_region_mask[:band_start_row, :] = True
    else: 
        # Fallback if no clear lower region start found - treat whole grid? Unlikely for this task.
        # Let's assume the first non-background row marks the start if no bands found.
         for r in range(rows):
            if not np.all(input_grid[r,:] == upper_background_color):
                band_start_row = r
                upper_region_mask[:band_start_row, :] = True
                break
         else: # Grid is all background?
             return output_grid # No patterns/bands likely


    # 3. Extract Patterns from the upper region
    patterns = find_objects(input_grid, upper_background_color, upper_region_mask)
    
    # Keep track of original pattern pixels for cleanup
    all_pattern_coords = set()
    for p in patterns:
        all_pattern_coords.update(p['coords'])

    # 4. Extract Bands from the lower region
    bands = find_bands(input_grid, band_start_row)

    # 5. Match Patterns and Bands
    matched_patterns = set()
    matched_bands = set()
    matches = [] # List of (pattern, band) tuples

    # Create lookup for faster matching
    patterns_by_color = defaultdict(list)
    for i, p in enumerate(patterns):
        for color, count in p['colors'].items():
            patterns_by_color[color].append({'id': i, 'count': count, 'pattern': p})

    
    # Iterate until no more matches can be made
    made_match_this_round = True
    while made_match_this_round :
        made_match_this_round = False
        best_match_for_band = {} # band_idx -> potential_match_info {'pattern_id', 'score', 'pattern_idx_in_patterns_list'}

        for band_idx, band in enumerate(bands):
            if band_idx in matched_bands:
                continue

            fill_color = band['fill_color']
            
            # Find candidate patterns containing the fill color
            candidate_patterns = []
            if fill_color in patterns_by_color:
                 for p_info in patterns_by_color[fill_color]:
                     if p_info['id'] not in matched_patterns:
                         candidate_patterns.append(p_info)

            if not candidate_patterns:
                continue # No available patterns match this band's fill color

            # Find the best candidate (highest count of fill_color)
            best_candidate = max(candidate_patterns, key=lambda x: x['count'])
            
            # Store this as the best potential match *for this band*
            # If another band also wants this pattern, the tie-breaking (highest count) decides
            # We need a way to resolve conflicts if multiple bands point to the same best pattern.
            # Let's try a simpler approach first: Iterate through bands and claim the best available pattern.
            
            # Find best match directly
            best_pattern_info = max(candidate_patterns, key=lambda p: p['count'])
            pattern_global_idx = best_pattern_info['id']

            # Tentatively assign
            # Check if this pattern is a better match for *this* band than any other band it could match
            # This seems overly complex. Let's stick to the description:
            # For a band, find all *available* patterns containing its fill color.
            # From those, pick the one with the highest count of that fill color.
            
            # Simple greedy matching based on iteration order and highest count
            current_best_pattern_idx = best_pattern_info['id']
            
            # Record this potential match
            # Score is the count of the fill color in the pattern
            match_info = {'pattern_id': current_best_pattern_idx, 'score': best_pattern_info['count'], 'band_idx': band_idx}

            # If this pattern is already potentially matched to another band, check scores
            # This still feels complex. Let's simplify: Process bands one by one.
            # When a band is processed, find its best available pattern and claim it immediately.

        # --- Simplified Greedy Matching ---
        for band_idx, band in enumerate(bands):
             if band_idx in matched_bands:
                 continue

             fill_color = band['fill_color']
             candidate_patterns_info = []
             if fill_color in patterns_by_color:
                  for p_info in patterns_by_color[fill_color]:
                      if p_info['id'] not in matched_patterns:
                          candidate_patterns_info.append(p_info)
            
             if not candidate_patterns_info:
                 continue

             # Find the best available pattern for this band
             best_pattern_info = max(candidate_patterns_info, key=lambda p: p['count'])
             pattern_global_idx = best_pattern_info['id']

             # Make the match
             matches.append((patterns[pattern_global_idx], band))
             matched_patterns.add(pattern_global_idx)
             matched_bands.add(band_idx)
             made_match_this_round = True # We made at least one match in this pass
             
        # If the number of matches equals patterns or bands, we can stop early potentially
        if len(matches) == len(patterns) or len(matches) == len(bands):
             break
        # The loop `while made_match_this_round` is actually sufficient for the greedy approach.

    # 6. Apply Stamping
    for pattern, band in matches:
        shape = pattern['shape']
        border_color = band['border_color']
        # Align stamping with the top-left of the *fill area*
        fill_top_left_r, fill_top_left_c = band['fill_top_left']
        
        min_r_fill, min_c_fill, max_r_fill, max_c_fill = band['fill_bbox']

        for dr, dc in shape:
            target_r = fill_top_left_r + dr
            target_c = fill_top_left_c + dc

            # Ensure stamping occurs within the band's fill bounding box conceptually
            # The examples show stamping happens regardless of original content (fill/border)
            # within the derived target coordinates. Check bounds of the grid.
            if 0 <= target_r < rows and 0 <= target_c < cols:
                 # Check if target is within the conceptual fill area for safety?
                 # The examples imply direct coordinate mapping is enough.
                 # Let's trust the derived coordinates map correctly based on fill_top_left.
                 output_grid[target_r, target_c] = border_color

    # 7. Clean Up Upper Region
    for r, c in all_pattern_coords:
        # Ensure cleanup only happens in the originally defined upper region
        if upper_region_mask[r, c]:
             output_grid[r, c] = upper_background_color

    return output_grid
```
