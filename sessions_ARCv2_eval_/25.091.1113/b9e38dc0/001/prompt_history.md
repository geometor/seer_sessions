
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's analyze the provided examples to understand the transformation rule.

**Perception of Task Elements:**

Each task example consists of an input grid and a corresponding output grid. The grids contain pixels of different colors. The core transformation seems to involve a "filling" process where one color expands into the background color, constrained by other colors.

1.  **Example 1:** The input has a blue background (1), green (3) and gray (5) pixels forming a partial boundary, and a single maroon (9) pixel inside this boundary. The output shows the maroon (9) color having filled the blue (1) area enclosed by the green (3) and gray (5) pixels. The original boundary and maroon pixels remain.
2.  **Example 2:** The input has a white background (0), gray (5) pixels forming scattered boundary elements, and a single yellow (4) pixel. The output shows the yellow (4) color having filled the white (0) area connected to the original yellow pixel, stopping when it encounters gray (5) pixels.
3.  **Example 3:** The input has an orange background (7), maroon (9) pixels forming an outer boundary, green (3) pixels inside this boundary, and some isolated magenta (6) and azure (8) pixels. The output shows the green (3) color having filled the orange (7) area within the maroon (9) boundary, starting from the original green (3) pixels. The maroon, magenta, and azure pixels remain unchanged and act as implicit boundaries for the fill.

The common pattern is a flood fill operation. A specific color ("fill color") expands into the background color. All other non-background colors act as boundaries, halting the expansion. The fill originates from the initial position(s) of the fill color.

**YAML Facts:**


```yaml
task_type: pattern_transformation
transformation_name: flood_fill_with_boundaries
common_elements:
  - grid_representation: 2D array of integers (colors)
  - background_color: Typically the most frequent color in the input.
  - objects: Contiguous areas of non-background colors.
actions:
  - identify_background_color
  - identify_non_background_colors
  - determine_fill_color: The color that expands.
  - determine_boundary_colors: All non-background colors *except* the fill color.
  - perform_flood_fill:
      origin: All pixels initially having the fill color.
      target_pixels: Pixels with the background color.
      fill_value: The fill color.
      stop_condition: Encountering a boundary color pixel or grid edge.
      connectivity: Cardinal neighbors (up, down, left, right).
relationships:
  - fill_color: Expands into the background.
  - boundary_colors: Constrain the expansion of the fill color.
  - background_color: Is replaced by the fill color during the operation.
  - other_colors: (Like Magenta/Azure in Ex3) Act as boundary colors if they are not the designated fill color.
examples_summary:
  - example_1:
      background: blue (1)
      fill_color: maroon (9)
      boundary_colors: [green (3), gray (5)]
  - example_2:
      background: white (0)
      fill_color: yellow (4)
      boundary_colors: [gray (5)]
  - example_3:
      background: orange (7)
      fill_color: green (3)
      boundary_colors: [maroon (9), magenta (6), azure (8)] # Note: Magenta and Azure are present but outside the main filled area. They still act as boundaries if the fill reaches them.
uncertainty:
  - The exact rule for selecting the 'fill_color' from multiple non-background colors needs clarification. In the examples, it seems to be the color whose flood fill (using other non-background colors as boundaries) successfully generates the output. A more direct selection criteria isn't immediately obvious from just these three examples (e.g., it's not always the unique color, nor always the color with fewest/most pixels).

```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the background color, which is the most frequent color in the input grid.
3.  Identify all non-background colors present in the input grid.
4.  Iterate through each non-background color identified in step 3, treating it as a potential 'fill color'.
    a.  For the current potential 'fill color', designate all *other* non-background colors as 'boundary colors'.
    b.  Create a temporary grid, initially a copy of the input grid.
    c.  Find all pixel coordinates in the temporary grid that contain the potential 'fill color'. Add these coordinates to a queue or stack for processing (these are the starting points for the flood fill).
    d.  Maintain a set of visited coordinates for the current fill operation, initially containing the starting coordinates.
    e.  While the queue/stack is not empty:
        i.  Dequeue/pop a coordinate (row, col).
        ii. For each cardinal neighbor (up, down, left, right) of the current coordinate:
            *   Check if the neighbor is within the grid boundaries.
            *   Check if the neighbor has *not* been visited yet in this fill operation.
            *   Check if the neighbor's color in the temporary grid is the background color.
            *   If all checks pass:
                *   Change the neighbor's color in the temporary grid to the potential 'fill color'.
                *   Mark the neighbor as visited.
                *   Enqueue/push the neighbor's coordinate.
    f.  After the flood fill process for the potential 'fill color' completes (the queue/stack is empty), compare the resulting temporary grid with the target output grid provided in the example.
    g.  If the temporary grid matches the target output grid, then the current potential 'fill color' is the correct one. Store this temporary grid as the final result and stop the iteration.
5.  Return the final result grid.
