
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's analyze the provided examples to understand the transformation rule.

**Perception of Task Elements:**

Each task example consists of an input grid and a corresponding output grid. The grids contain pixels of different colors. The core transformation seems to involve a "filling" process where one color expands into the background color, constrained by other colors.

1.  **Example 1:** The input has a blue background (1), green (3) and gray (5) pixels forming a partial boundary, and a single maroon (9) pixel inside this boundary. The output shows the maroon (9) color having filled the blue (1) area enclosed by the green (3) and gray (5) pixels. The original boundary and maroon pixels remain.
2.  **Example 2:** The input has a white background (0), gray (5) pixels forming scattered boundary elements, and a single yellow (4) pixel. The output shows the yellow (4) color having filled the white (0) area connected to the original yellow pixel, stopping when it encounters gray (5) pixels.
3.  **Example 3:** The input has an orange background (7), maroon (9) pixels forming an outer boundary, green (3) pixels inside this boundary, and some isolated magenta (6) and azure (8) pixels. The output shows the green (3) color having filled the orange (7) area within the maroon (9) boundary, starting from the original green (3) pixels. The maroon, magenta, and azure pixels remain unchanged and act as implicit boundaries for the fill.

The common pattern is a flood fill operation. A specific color ("fill color") expands into the background color. All other non-background colors act as boundaries, halting the expansion. The fill originates from the initial position(s) of the fill color.

**YAML Facts:**


```yaml
task_type: pattern_transformation
transformation_name: flood_fill_with_boundaries
common_elements:
  - grid_representation: 2D array of integers (colors)
  - background_color: Typically the most frequent color in the input.
  - objects: Contiguous areas of non-background colors.
actions:
  - identify_background_color
  - identify_non_background_colors
  - determine_fill_color: The color that expands.
  - determine_boundary_colors: All non-background colors *except* the fill color.
  - perform_flood_fill:
      origin: All pixels initially having the fill color.
      target_pixels: Pixels with the background color.
      fill_value: The fill color.
      stop_condition: Encountering a boundary color pixel or grid edge.
      connectivity: Cardinal neighbors (up, down, left, right).
relationships:
  - fill_color: Expands into the background.
  - boundary_colors: Constrain the expansion of the fill color.
  - background_color: Is replaced by the fill color during the operation.
  - other_colors: (Like Magenta/Azure in Ex3) Act as boundary colors if they are not the designated fill color.
examples_summary:
  - example_1:
      background: blue (1)
      fill_color: maroon (9)
      boundary_colors: [green (3), gray (5)]
  - example_2:
      background: white (0)
      fill_color: yellow (4)
      boundary_colors: [gray (5)]
  - example_3:
      background: orange (7)
      fill_color: green (3)
      boundary_colors: [maroon (9), magenta (6), azure (8)] # Note: Magenta and Azure are present but outside the main filled area. They still act as boundaries if the fill reaches them.
uncertainty:
  - The exact rule for selecting the 'fill_color' from multiple non-background colors needs clarification. In the examples, it seems to be the color whose flood fill (using other non-background colors as boundaries) successfully generates the output. A more direct selection criteria isn't immediately obvious from just these three examples (e.g., it's not always the unique color, nor always the color with fewest/most pixels).

```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the background color, which is the most frequent color in the input grid.
3.  Identify all non-background colors present in the input grid.
4.  Iterate through each non-background color identified in step 3, treating it as a potential 'fill color'.
    a.  For the current potential 'fill color', designate all *other* non-background colors as 'boundary colors'.
    b.  Create a temporary grid, initially a copy of the input grid.
    c.  Find all pixel coordinates in the temporary grid that contain the potential 'fill color'. Add these coordinates to a queue or stack for processing (these are the starting points for the flood fill).
    d.  Maintain a set of visited coordinates for the current fill operation, initially containing the starting coordinates.
    e.  While the queue/stack is not empty:
        i.  Dequeue/pop a coordinate (row, col).
        ii. For each cardinal neighbor (up, down, left, right) of the current coordinate:
            *   Check if the neighbor is within the grid boundaries.
            *   Check if the neighbor has *not* been visited yet in this fill operation.
            *   Check if the neighbor's color in the temporary grid is the background color.
            *   If all checks pass:
                *   Change the neighbor's color in the temporary grid to the potential 'fill color'.
                *   Mark the neighbor as visited.
                *   Enqueue/push the neighbor's coordinate.
    f.  After the flood fill process for the potential 'fill color' completes (the queue/stack is empty), compare the resulting temporary grid with the target output grid provided in the example.
    g.  If the temporary grid matches the target output grid, then the current potential 'fill color' is the correct one. Store this temporary grid as the final result and stop the iteration.
5.  Return the final result grid.
```python
import numpy as np
from collections import deque

"""
The transformation identifies a background color (most frequent color) and several non-background colors forming shapes or boundaries. 
It then determines a specific 'fill color' from the non-background colors. 
This fill color expands (flood fills) into adjacent background-colored areas. 
The expansion is constrained by the grid boundaries and any other non-background colors, which act as barriers.
The final output grid shows the result of this constrained flood fill, with the original boundary colors and the expanded fill color replacing the background color in the filled regions.

The fill color appears to be the unique non-background color that has adjacent background pixels it can expand into, considering other non-background colors as impassable boundaries.
"""

def find_background_color(grid):
    """Identifies the most frequent color as the background."""
    unique_colors, counts = np.unique(grid, return_counts=True)
    background_color = unique_colors[np.argmax(counts)]
    return background_color

def get_non_background_colors(grid, background_color):
    """Finds all unique colors that are not the background color."""
    unique_colors = np.unique(grid)
    non_background_colors = set(unique_colors) - {background_color}
    return non_background_colors

def find_potential_fill_candidates(grid, background_color, non_background_colors):
    """Identifies non-background colors adjacent to the background color."""
    rows, cols = grid.shape
    candidates = set()
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            if color in non_background_colors:
                # Check cardinal neighbors
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        if grid[nr, nc] == background_color:
                            candidates.add(color)
                            break # Found one background neighbor, no need to check others for this pixel
    return candidates


def flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):
    """Performs a flood fill on the grid."""
    rows, cols = grid.shape
    output_grid = np.copy(grid)
    q = deque(start_coords)
    visited = set(start_coords)

    while q:
        r, c = q.popleft()

        # Explore cardinal neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue

            # Check if visited
            if (nr, nc) in visited:
                continue

            neighbor_color = output_grid[nr, nc]

            # Check if it's background color (target for filling)
            if neighbor_color == background_color:
                output_grid[nr, nc] = fill_color
                visited.add((nr, nc))
                q.append((nr, nc))
            # Implicitly, if neighbor_color is in boundary_colors or is the fill_color itself,
            # we don't add it to the queue, effectively stopping the fill at boundaries.

    return output_grid


def transform(input_grid):
    """
    Applies a constrained flood fill transformation.

    1. Identifies background, non-background, and the specific fill color.
    2. Performs flood fill from the fill color pixels into the background color.
    3. Other non-background colors act as boundaries.
    """
    # Make a copy to avoid modifying the original input
    grid = np.array(input_grid)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # 1. Identify colors
    background_color = find_background_color(grid)
    non_background_colors = get_non_background_colors(grid, background_color)

    if not non_background_colors:
        # No non-background colors, nothing to fill
        return output_grid

    # 2. Determine the fill color
    # Assumption: The fill color is the unique non-background color adjacent to the background color.
    # This holds for the training examples.
    potential_fillers = find_potential_fill_candidates(grid, background_color, non_background_colors)

    # Heuristic: If exactly one color can expand, that's our fill color.
    # If multiple or none can expand, the logic might be different, but based on examples, assume one.
    if len(potential_fillers) != 1:
         # Fallback or error? Based on examples, assume this doesn't happen or means no change.
         # Let's refine this: Try each potential filler and see which one produces a change.
         # If only one produces a change from the input, use that one.
         # For now, stick to the simpler heuristic derived from observation.
         # If there are no potential fillers (e.g., everything is enclosed), return original.
         if len(potential_fillers) == 0:
             return output_grid
         # If ambiguity (>1), we can't be sure based on current logic. Return original.
         # print(f"Warning: Found {len(potential_fillers)} potential fill candidates: {potential_fillers}. Cannot determine unique fill color.")
         # Forcing the first one for now if ambiguous, might need better logic later.
         # A better approach might be to simulate fill for each and see which one modifies the grid.
         # Or, maybe the one *inside* the boundaries is the fill color.
         # Let's stick to the len==1 assumption derived from examples for now.
         # If this fails tests, we'll need to revisit the fill color selection.
         # Returning original grid if ambiguous.
         return output_grid # Or raise an error, or try a more complex heuristic


    fill_color = list(potential_fillers)[0]
    boundary_colors = non_background_colors - {fill_color}

    # 3. Find starting points for the flood fill
    start_coords = []
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == fill_color:
                start_coords.append((r, c))

    if not start_coords:
        # Fill color identified, but no pixels of that color exist? Should not happen based on candidate logic.
        return output_grid

    # 4. Perform the flood fill
    output_grid = flood_fill(grid, start_coords, fill_color, background_color, boundary_colors)

    return output_grid.tolist() # Return as list of lists per ARC standard

```
