{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify an \"activation column\" defined by the vertical alignment of a unique yellow (4) pixel located directly above one or more red (2) pixels in the same column within the input grid.\n2. Find all distinct contiguous objects made of blue (1) pixels using 8-way connectivity (orthogonal and diagonal).\n3. Determine if any blue object intersects the activation column.\n4. If intersection occurs:\n    a. Identify *all* blue objects that intersect the activation column (\"activated objects\").\n    b. Create a single set containing all coordinates belonging to *any* of the activated objects.\n    c. Find all green (3) pixels in the input grid.\n    d. Determine the \"hole coordinates\": these are the locations of green pixels that are either *within* any activated object or adjacent (8-way, including diagonally) to any pixel of any activated object.\n    e. Initialize the output grid filled with the background color (azure 8).\n    f. Fill the output grid with red (2) at the locations corresponding to the combined coordinates of all activated objects, *except* for the hole coordinates, which remain the background color (azure 8).\n5. If no blue object intersects the activation column:\n    a. Initialize the output grid filled with the background color (azure 8).\n    b. Fill the output grid with a vertical red (2) line in the activation column, spanning the full height of the grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color in the grid using 8-way connectivity.\n    Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    # 8-way directions (including diagonals)\n    delta = [\n        (-1, -1), (-1, 0), (-1, 1),\n        ( 0, -1),          ( 0, 1),\n        ( 1, -1), ( 1, 0), ( 1, 1),\n    ]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Check neighbors (8-way)\n                    for dr, dc in delta:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords: # Only add if an object was actually found\n                    objects.append(obj_coords)\n    return objects\n\ndef get_adjacent_coords(grid_shape, coords, include_diagonal=True):\n    \"\"\"\n    Gets all unique coordinates adjacent (optionally including diagonals)\n    to a set of coordinates, within grid boundaries. Includes the original coords.\n    \"\"\"\n    height, width = grid_shape\n    adjacent_and_self_set = set(coords) # Start with the original coords\n\n    delta = [\n        (-1, -1), (-1, 0), (-1, 1),\n        ( 0, -1),          ( 0, 1),\n        ( 1, -1), ( 1, 0), ( 1, 1),\n    ] if include_diagonal else [\n                 (-1, 0),\n        ( 0, -1),          ( 0, 1),\n                 ( 1, 0),\n    ]\n\n    for r, c in coords:\n        for dr, dc in delta:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                adjacent_and_self_set.add((nr, nc))\n\n    return adjacent_and_self_set\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on blue object intersection with an activation column.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Define colors\n    background_color = 8 # azure\n    shape_color = 1      # blue\n    hole_marker_color = 3 # green\n    activation_marker_color = 4 # yellow\n    fill_color = 2       # red (also the activation trigger color)\n\n    # Initialize output_grid with background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 1. Find the activation column\n    activation_col = -1\n    yellow_pixels = np.where(input_grid_np == activation_marker_color)\n    if len(yellow_pixels[0]) == 1: # Expect exactly one yellow pixel\n        y_row, y_col = yellow_pixels[0][0], yellow_pixels[1][0]\n        # Check if there are red pixels directly below it in the same column\n        if y_row + 1 < height and np.any(input_grid_np[y_row+1:, y_col] == fill_color):\n             activation_col = y_col\n\n    # If no valid activation column found (missing yellow/red pattern), return the empty grid\n    if activation_col == -1:\n        return output_grid.tolist()\n\n    # 2. Find all blue objects (using 8-way connectivity)\n    blue_objects = find_objects(input_grid_np, shape_color)\n\n    # 3. Determine activated objects and combine their coordinates\n    activated_objects = []\n    total_activated_coords = set()\n    intersection_found = False\n    for blue_obj_coords in blue_objects:\n        is_activated = False\n        for r, c in blue_obj_coords:\n            if c == activation_col:\n                is_activated = True\n                intersection_found = True\n                break\n        if is_activated:\n            activated_objects.append(blue_obj_coords)\n            total_activated_coords.update(blue_obj_coords) # Add coords to the total set\n\n    # 4. Handle Intersection Case\n    if intersection_found:\n        # 4b. Find all green pixel locations\n        green_pixels = set(zip(*np.where(input_grid_np == hole_marker_color)))\n\n        # 4c/d. Determine hole coordinates\n        # Potential hole locations are those within or adjacent (8-way) to *any* activated pixel\n        potential_hole_locations = get_adjacent_coords((height, width), total_activated_coords, include_diagonal=True)\n\n        # Actual holes are green pixels within the potential locations\n        actual_hole_coords = green_pixels.intersection(potential_hole_locations)\n\n        # 4e/f. Fill activated shapes in the output grid, respecting holes\n        for r, c in total_activated_coords:\n            if (r, c) not in actual_hole_coords:\n                output_grid[r, c] = fill_color\n\n    # 5. Handle No Intersection Case\n    else:\n        # 5a/b. Draw a vertical red line in the activation column\n        output_grid[:, activation_col] = fill_color\n\n    # Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 26005,
    "candidates_token_count": 1791,
    "total_token_count": 27796,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.092933,
  "retries": 1
}