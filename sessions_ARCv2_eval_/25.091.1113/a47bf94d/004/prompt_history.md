
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 8 8 8 8 8 8 0 0 8 8 0 0 0 0 0 0 0
0 0 3 3 3 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 9 9 9 9 8 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 8 0 9 9 9 9 0 0 4 0 4 0 0 0 0
0 0 4 0 4 8 5 8 5 9 9 9 9 8 8 0 4 0 0 0 0 0
0 0 0 4 0 0 0 8 0 9 9 9 9 0 0 4 0 4 0 0 0 0
0 0 0 0 0 0 0 8 0 9 9 9 9 0 0 0 0 0 0 0 0 0
0 0 2 2 2 0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 8 8 8 0 0 8 8 8 8 8 0 0 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 0
0 0 3 0 3 8 8 8 8 8 8 0 0 8 8 0 2 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 8 0 0 8 0 2 0 2 0 0 0 0
0 0 0 0 0 0 0 8 8 9 9 9 9 8 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 8 0 9 9 9 9 0 0 4 0 4 0 0 0 0
0 0 4 0 4 8 5 8 5 9 9 9 9 8 8 0 4 0 0 0 0 0
0 0 0 4 0 0 0 8 0 9 9 9 9 0 0 4 0 4 0 0 0 0
0 0 0 0 0 0 0 8 0 9 9 9 9 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 8 0 0 8 0 0 0 0 3 0 3 0 0 0 0
0 0 2 0 2 8 8 8 0 0 8 8 8 8 8 0 3 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0
0 0 6 0 6 8 8 8 8 8 8 8 8 8 8 0 6 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 0 2 2 2 0 3 3 3 0 4 4 4 0 0 0 0
0 0 0 1 1 1 0 2 2 2 0 3 3 3 0 4 4 4 0 0 0 0
0 0 0 1 1 1 0 2 2 2 0 3 3 3 0 4 4 4 0 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 8 8 5 8 5 8 0 0 0
0 0 0 0 8 0 0 0 5 0 0 0 0 0 0 0 8 0 8 0 0 0
0 0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0 8 0 8 0 0 0
0 0 0 0 8 8 8 5 8 5 8 5 8 5 8 8 8 0 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 8 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0
0 0 0 1 0 1 0 2 0 2 0 3 0 3 0 4 0 4 0 0 0 0
0 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 8 8 5 8 5 8 0 0 0
0 0 0 0 8 0 0 0 5 0 0 0 0 0 0 0 8 0 8 0 0 0
0 0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0 8 0 8 0 0 0
0 0 0 0 8 8 8 5 8 5 8 5 8 5 8 8 8 0 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 8 8 0 0 0
0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0
0 0 0 4 0 4 0 2 0 2 0 1 0 1 0 3 0 3 0 0 0 0
0 0 0 0 4 0 0 0 2 0 0 0 1 0 0 0 3 0 0 0 0 0
0 0 0 4 0 4 0 2 0 2 0 1 0 1 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 4 4 4 0 6 6 6 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 4 4 4 0 6 6 6 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 4 4 4 0 6 6 6 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 9 9 9 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 9 9 9 0 0 8 8 8 5 8 5 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0 8 0 8 9 9 9 9 0 0 0 0
0 0 0 8 8 8 8 8 0 0 9 9 0 8 9 9 9 9 0 0 0 0
0 0 0 0 0 0 0 8 0 0 9 9 0 8 9 9 9 9 0 0 0 0
0 0 0 8 8 8 5 8 5 8 8 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 0 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 8 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 1 0 0 0 4 0 0 0 6 0 0 0 0 0 0
0 0 2 0 2 0 1 0 1 0 4 0 4 0 6 0 6 0 0 0 0 0
0 0 0 2 0 0 0 1 0 0 0 4 0 0 0 6 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 9 9 9 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 9 9 9 0 0 8 8 8 5 8 5 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0 8 0 8 9 9 9 9 0 0 0 0
0 0 0 8 8 8 8 8 0 0 9 9 0 8 9 9 9 9 0 0 0 0
0 0 0 0 0 0 0 8 0 0 9 9 0 8 9 9 9 9 0 0 0 0
0 0 0 8 8 8 5 8 5 8 8 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 0 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 8 8 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0
0 0 4 0 4 0 2 0 2 0 1 0 1 0 6 0 6 0 0 0 0 0
0 0 0 4 0 0 0 2 0 0 0 1 0 0 0 6 0 0 0 0 0 0
0 0 4 0 4 0 2 0 2 0 1 0 1 0 6 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception of Task Elements**

1.  **Input Grid:** Contains a background of white pixels (0) and various colored shapes.
2.  **Key Objects:** The most prominent and consistently transformed objects are solid 3x3 squares of specific colors (Red, Green, Blue, Yellow, Magenta). Other complex shapes made of Azure, Gray, and Maroon also exist but seem unchanged by the transformation. Some inputs also contain hollow 3x3 frames (e.g., Train 3 input has a Blue frame).
3.  **Transformation:** The core transformation involves two steps applied to the solid 3x3 squares:
    *   **Hollowing:** Each solid 3x3 square found in the input is modified in place by changing its center pixel to white (0), effectively turning it into a hollow frame.
    *   **Copying/Swapping:** A *new* hollow frame is created elsewhere in the grid. The color of this new frame is determined by a color-swapping rule applied to the original square's color. The location of this new frame depends on the position(s) of the original solid 3x3 square(s).
4.  **Color Swapping:** There's a consistent pairing for color swaps: Red (2) swaps with Green (3), Blue (1) swaps with Yellow (4). Magenta (6) seems to swap with itself.
5.  **Location Rule for New Frames:** The placement of the *new* hollow frame depends on the arrangement of the original solid 3x3 squares:
    *   If all original solid 3x3 squares are found in the same row (specifically row index 1 in the examples), the new frame is placed at row index 14, keeping the original column index.
    *   If the original solid 3x3 squares are located at specific columns (column index 2 and column index 15 in the example), the new frame keeps the original row index, but the column index is swapped (2 becomes 15, 15 becomes 2).
6.  **Invariant Elements:** The background white pixels and the complex Azure/Gray/Maroon structures remain unchanged. Pre-existing hollow frames in the input also remain unchanged.

**YAML Facts Block**


```yaml
task_context:
  description: "Modifies solid 3x3 squares by hollowing them and creating a new, color-swapped hollow square at a calculated position."
  grid_properties:
    - background_color: 0 (white)
    - invariant_elements:
        - complex shapes (azure 8, gray 5, maroon 9)
        - pre-existing hollow 3x3 frames
        - background pixels

identified_objects:
  - object_type: "solid_3x3_square"
    properties:
      - size: 3x3
      - solid: true
      - colors_involved: [1 (blue), 2 (red), 3 (green), 4 (yellow), 6 (magenta)]
    actions:
      - find_all
      - identify_color
      - identify_top_left_location (r, c)

transformations:
  - step: 1
    action: "hollowing"
    input_object: "solid_3x3_square"
    details: "Change the center pixel (r+1, c+1) of the original square to white (0)."
    output: "hollow_3x3_frame" (at original location)
  - step: 2
    action: "color_swapping"
    input_color: C (color of original solid 3x3 square)
    rules:
      - { input: 2 (red), output: 3 (green) }
      - { input: 3 (green), output: 2 (red) }
      - { input: 1 (blue), output: 4 (yellow) }
      - { input: 4 (yellow), output: 1 (blue) }
      - { input: 6 (magenta), output: 6 (magenta) }
    output_color: C_partner
  - step: 3
    action: "determine_new_location"
    input_location: (r, c) (top-left of original solid 3x3 square)
    input_context: "Spatial arrangement of all original solid 3x3 squares"
    rules:
      - condition: "All original solid 3x3 squares are in row r=1"
        output_location: (r_new: 14, c_new: c)
      - condition: "Original solid 3x3 squares exist at column c=2"
        output_location: (r_new: r, c_new: 15) # Applies only if c=2
      - condition: "Original solid 3x3 squares exist at column c=15"
        output_location: (r_new: r, c_new: 2) # Applies only if c=15
    output_location: (r_new, c_new)
  - step: 4
    action: "create_new_frame"
    details: "Create a 3x3 hollow frame (center pixel is white 0) using C_partner color."
    location: (r_new, c_new)

final_output:
  composition: "Input grid with modifications from transformations applied."
```


**Natural Language Program**

1.  Initialize the output grid as a perfect copy of the input grid.
2.  Scan the input grid to identify all solid 3x3 squares (contiguous blocks of 3x3 pixels of the same color, excluding white). Record their top-left coordinates (r, c) and their color C.
3.  Check the spatial arrangement of the identified solid squares:
    *   Determine if all identified squares share the same row index (e.g., all are in row 1). Set a flag `same_row_pattern` accordingly.
    *   Determine if identified squares exist specifically in column index 2 and/or column index 1
```python
import numpy as np
import copy

"""
Transformation Rule:
1. Find all solid 3x3 squares of a single color (not white/0) in the input grid.
2. For each found solid 3x3 square:
    a. Hollow it out in place by changing its center pixel to white (0).
    b. Determine a 'partner' color based on a swap rule: Red (2) <-> Green (3), Blue (1) <-> Yellow (4), Magenta (6) <-> Magenta (6).
    c. Determine a new location for a corresponding hollow frame based on the original square's position:
        i. If all original solid 3x3 squares were found in row 1, the new location's top-left corner is (14, original_col).
        ii. Otherwise, if the original square was in column 2, the new location's top-left corner is (original_row, 15).
        iii. Otherwise, if the original square was in column 15, the new location's top-left corner is (original_row, 2).
        iv. (Assumption: The examples cover all location rules needed).
    d. Create a new 3x3 hollow frame (center pixel white/0, perimeter pixels are the partner color) at the calculated new location.
3. Keep all other elements (background, complex shapes, pre-existing hollow frames) unchanged.
"""

def find_solid_3x3_squares(grid):
    """Finds the top-left coordinates and color of all solid 3x3 squares."""
    squares = []
    height, width = grid.shape
    for r in range(height - 2):
        for c in range(width - 2):
            color = grid[r, c]
            if color == 0:  # Skip background
                continue
            # Check if the 3x3 block is solid and matches the top-left color
            is_solid = True
            for i in range(3):
                for j in range(3):
                    if grid[r + i, c + j] != color:
                        is_solid = False
                        break
                if not is_solid:
                    break
            if is_solid:
                squares.append({'r': r, 'c': c, 'color': color})
    return squares

def draw_hollow_frame(grid, r, c, color):
    """Draws a 3x3 hollow frame at (r, c) with the given color."""
    height, width = grid.shape
    if r < 0 or r + 2 >= height or c < 0 or c + 2 >= width:
        # Ensure the frame fits within the grid boundaries
        return 
        
    for i in range(3):
        for j in range(3):
            if i == 1 and j == 1:
                grid[r + i, c + j] = 0  # Center pixel is white
            else:
                grid[r + i, c + j] = color # Perimeter pixels

def transform(input_grid):
    """
    Applies the transformation rule: hollowing solid 3x3 squares and creating
    color-swapped, position-shifted hollow copies.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # 1. Find all solid 3x3 squares
    solid_squares = find_solid_3x3_squares(input_grid)

    if not solid_squares:
        return output_grid # No squares found, return original grid

    # Determine location rule based on original square positions
    all_in_row_1 = all(sq['r'] == 1 for sq in solid_squares)

    # Define the color swap map
    color_swap_map = {
        2: 3, 3: 2,  # Red <-> Green
        1: 4, 4: 1,  # Blue <-> Yellow
        6: 6        # Magenta <-> Magenta
    }

    # Process each found square
    for square in solid_squares:
        r, c, color = square['r'], square['c'], square['color']

        # 2a. Hollow the original square in the output grid
        output_grid[r + 1, c + 1] = 0

        # 2b. Determine the partner color
        swapped_color = color_swap_map.get(color, color) # Default to original if not in map

        # 2c. Determine the new location
        new_r, new_c = -1, -1 # Initialize invalid coordinates
        if all_in_row_1:
            # Rule i: All originals in row 1 -> new frame in row 14
            new_r, new_c = 14, c
        elif c == 2:
            # Rule ii: Original in col 2 -> new frame in col 15
             new_r, new_c = r, 15
        elif c == 15:
             # Rule iii: Original in col 15 -> new frame in col 2
             new_r, new_c = r, 2
        # Add potential default or error handling if needed, though examples seem covered.

        # 2d. Create the new hollow frame if location is valid
        if new_r != -1 and new_c != -1:
             draw_hollow_frame(output_grid, new_r, new_c, swapped_color)

    return output_grid
```
```python
import numpy as np
import copy

"""
Transformation Rule:
1. Find all solid 3x3 squares of a single color (not white/0) in the input grid.
2. For each found solid 3x3 square:
    a. Transform the original solid 3x3 square into a hollow 3x3 frame in place, using its original color for the perimeter and white (0) for the center.
    b. Determine a 'partner' color based on a swap rule: Red (2) <-> Green (3), Blue (1) <-> Yellow (4), Magenta (6) <-> Magenta (6).
    c. Determine a new location for a corresponding hollow frame based on the original square's position:
        i. If all original solid 3x3 squares were found in row 1, the new location's top-left corner is (14, original_col).
        ii. Otherwise, if the original square was in column 2, the new location's top-left corner is (original_row, 15).
        iii. Otherwise, if the original square was in column 15, the new location's top-left corner is (original_row, 2).
        iv. (Implicit assumption: these rules cover all cases presented).
    d. Create a new 3x3 hollow frame (center pixel white/0, perimeter pixels are the partner color) at the calculated new location.
3. Keep all other elements (background, complex shapes, pre-existing hollow frames) unchanged unless overwritten by a new frame.
"""

def find_solid_3x3_squares(grid):
    """Finds the top-left coordinates and color of all solid 3x3 squares."""
    squares = []
    height, width = grid.shape
    for r in range(height - 2):
        for c in range(width - 2):
            color = grid[r, c]
            if color == 0:  # Skip background
                continue
            # Check if the 3x3 block is solid and matches the top-left color
            is_solid = True
            for i in range(3):
                for j in range(3):
                    if grid[r + i, c + j] != color:
                        is_solid = False
                        break
                if not is_solid:
                    break
            if is_solid:
                squares.append({'r': r, 'c': c, 'color': color})
    return squares

def draw_hollow_frame(grid, r, c, color):
    """Draws a 3x3 hollow frame at (r, c) with the given color."""
    height, width = grid.shape
    if r < 0 or r + 2 >= height or c < 0 or c + 2 >= width:
        # Ensure the frame fits within the grid boundaries
        return 
        
    # Draw perimeter
    for i in range(3):
        grid[r, c + i] = color       # Top row
        grid[r + 2, c + i] = color   # Bottom row
        grid[r + i, c] = color       # Left column
        grid[r + i, c + 2] = color   # Right column
    # Set center to white
    grid[r + 1, c + 1] = 0  

def transform(input_grid):
    """
    Applies the transformation rule: hollowing solid 3x3 squares and creating
    color-swapped, position-shifted hollow copies.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # 1. Find all solid 3x3 squares in the *original* input grid
    solid_squares = find_solid_3x3_squares(input_grid)

    if not solid_squares:
        return output_grid # No squares found, return original grid

    # Determine location rule based on original square positions
    all_in_row_1 = all(sq['r'] == 1 for sq in solid_squares)

    # Define the color swap map
    color_swap_map = {
        2: 3, 3: 2,  # Red <-> Green
        1: 4, 4: 1,  # Blue <-> Yellow
        6: 6        # Magenta <-> Magenta
    }

    # Process each found square
    for square in solid_squares:
        r, c, color = square['r'], square['c'], square['color']

        # 2a. Transform the original square into a hollow frame in the output grid
        draw_hollow_frame(output_grid, r, c, color)

        # 2b. Determine the partner color
        swapped_color = color_swap_map.get(color, color) # Default to original if not in map

        # 2c. Determine the new location
        new_r, new_c = -1, -1 # Initialize invalid coordinates
        if all_in_row_1:
            # Rule i: All originals in row 1 -> new frame in row 14
            new_r, new_c = 14, c
        elif c == 2:
            # Rule ii: Original in col 2 -> new frame in col 15
             new_r, new_c = r, 15
        elif c == 15:
             # Rule iii: Original in col 15 -> new frame in col 2
             new_r, new_c = r, 2
        # No default rule specified if none of the above match, 
        # but examples seem covered.

        # 2d. Create the new hollow frame at the new location if valid
        if new_r != -1 and new_c != -1:
             draw_hollow_frame(output_grid, new_r, new_c, swapped_color)

    return output_grid
```
