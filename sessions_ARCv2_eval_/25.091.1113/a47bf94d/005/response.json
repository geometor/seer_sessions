{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n1. Create a copy of the input grid to serve as the output grid.\n2. Find all solid 3x3 squares of a single color (not white/0) in the *original input* grid. Record their top-left coordinates (r, c) and color.\n3. If no solid 3x3 squares are found, return the unchanged output grid copy.\n4. Determine the location rule based on the positions of all found solid squares:\n    a. Check if *all* identified solid squares share the same top row index r=1.\n5. For each solid 3x3 square found in the original input:\n    a. Determine a 'partner' color based on a swap rule: Red (2) <-> Green (3), Blue (1) <-> Yellow (4), Magenta (6) <-> Magenta (6).\n    b. Determine the top-left coordinates (new_r, new_c) for a *new* hollow frame based on the original square's top-left position (r, c) and the overall location rule:\n        i. If the 'all in row 1' rule (4a) is true: new_r = 14, new_c = c.\n        ii. Otherwise, if the original square's column c is 2: new_r = r, new_c = 15.\n        iii. Otherwise, if the original square's column c is 15: new_r = r, new_c = 2.\n        iv. (Assume these rules cover all required cases based on examples).\n    c. Draw a *new* 3x3 hollow frame (perimeter = partner color, center = white/0) onto the *output grid* at the calculated new location (new_r, new_c). This new frame may overwrite existing pixels in the output grid.\n6. The original solid 3x3 squares are *not* explicitly modified unless they happen to be overwritten by a newly drawn frame.\n7. Return the modified output grid.\n\"\"\"\n\ndef find_solid_3x3_squares(grid):\n    \"\"\"Finds the top-left coordinates and color of all solid 3x3 squares.\"\"\"\n    squares = []\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            color = grid[r, c]\n            # Check if the top-left is a potential start (not background)\n            if color == 0:\n                continue\n                \n            # Assume it's solid until proven otherwise\n            is_solid = True\n            for i in range(3):\n                for j in range(3):\n                    # Check bounds just in case, though outer loop handles most\n                    if r + i >= height or c + j >= width or grid[r + i, c + j] != color:\n                        is_solid = False\n                        break\n                if not is_solid:\n                    break\n                    \n            if is_solid:\n                squares.append({'r': r, 'c': c, 'color': color})\n    return squares\n\ndef draw_hollow_frame(grid, r, c, color):\n    \"\"\"Draws a 3x3 hollow frame onto the grid at (r, c) with the given color.\"\"\"\n    height, width = grid.shape\n    # Check if the frame is entirely within bounds\n    if r < 0 or r + 2 >= height or c < 0 or c + 2 >= width:\n        # Invalid location, do nothing\n        # print(f\"Warning: Attempted to draw frame outside bounds at ({r},{c})\") # Optional debug\n        return \n        \n    # Draw perimeter pixels\n    for i in range(3):\n        # Top and bottom rows\n        if r >= 0 and r < height and c + i >= 0 and c + i < width:\n             grid[r, c + i] = color\n        if r + 2 >= 0 and r + 2 < height and c + i >= 0 and c + i < width:\n             grid[r + 2, c + i] = color\n        # Left and right columns (avoiding corners already drawn)\n        if i > 0 and i < 2:\n            if r + i >= 0 and r + i < height and c >= 0 and c < width:\n                 grid[r + i, c] = color\n            if r + i >= 0 and r + i < height and c + 2 >= 0 and c + 2 < width:\n                 grid[r + i, c + 2] = color\n                 \n    # Set center pixel to white (0)\n    if r + 1 >= 0 and r + 1 < height and c + 1 >= 0 and c + 1 < width:\n        grid[r + 1, c + 1] = 0\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds solid 3x3 squares in the input,\n    and draws new, color-swapped, position-shifted hollow frames onto a copy.\n    \"\"\"\n    # 1. Create a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # 2. Find all solid 3x3 squares in the original input grid\n    solid_squares = find_solid_3x3_squares(input_grid)\n\n    # 3. If no squares found, return the copy\n    if not solid_squares:\n        return output_grid\n\n    # 4. Determine the location rule: check if all are in row 1\n    all_in_row_1 = all(sq['r'] == 1 for sq in solid_squares)\n\n    # Define the color swap map\n    color_swap_map = {\n        2: 3, 3: 2,  # Red <-> Green\n        1: 4, 4: 1,  # Blue <-> Yellow\n        6: 6        # Magenta <-> Magenta\n    }\n\n    # 5. Process each found solid square\n    for square in solid_squares:\n        r, c, color = square['r'], square['c'], square['color']\n\n        # 5a. Determine the partner color\n        # If the color isn't in the swap map, it shouldn't have been found by find_solid_3x3_squares\n        # based on the examples, but handle defensively just in case.\n        swapped_color = color_swap_map.get(color) \n        if swapped_color is None:\n            # print(f\"Warning: Found solid square with unexpected color {color} at ({r},{c})\") # Optional debug\n            continue # Skip if color is not one we expect to transform\n\n        # 5b. Determine the new location\n        new_r, new_c = -1, -1 # Initialize invalid coordinates\n\n        if all_in_row_1:\n            # Rule i: All originals in row 1 -> new frame in row 14\n            new_r, new_c = 14, c\n        elif c == 2:\n            # Rule ii: Original in col 2 -> new frame in col 15\n             new_r, new_c = r, 15\n        elif c == 15:\n             # Rule iii: Original in col 15 -> new frame in col 2\n             new_r, new_c = r, 2\n        # If none of the location rules match, new_r/new_c remain -1\n        # and the frame won't be drawn (handled by draw_hollow_frame check).\n\n        # 5c. Create the new hollow frame at the new location on the output grid\n        if new_r != -1 and new_c != -1: # Ensure a valid location rule was applied\n             draw_hollow_frame(output_grid, new_r, new_c, swapped_color)\n             \n    # 6 & 7. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21081,
    "candidates_token_count": 1850,
    "total_token_count": 22931,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.756905,
  "retries": 1
}