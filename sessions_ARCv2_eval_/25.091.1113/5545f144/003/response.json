{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule involves identifying vertical divider columns (columns where all pixels have the same color, and this color is consistent across all such columns). \nThese dividers split the input grid into vertical sections. \nThe background color is determined as the most frequent color in the grid, excluding the pixels within the divider columns. \nForeground pixels within each section are defined as those whose color is neither the background color nor the divider color. \nThe rule is to count these foreground pixels in each section. \nThe output grid is a copy of the section that contains the maximum number of foreground pixels. \nIf multiple sections tie for the maximum count, the leftmost section among them is chosen.\n\"\"\"\n\ndef find_divider_columns(grid: np.ndarray) -> tuple[list[int], int | None]:\n    \"\"\"\n    Finds columns composed of a single repeating color.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - divider_indices: A list of column indices that are divider columns.\n        - divider_color: The color value used in the divider columns (int or None if no dividers found).\n    \"\"\"\n    height, width = grid.shape\n    if height == 0 or width == 0:\n        return [], None\n        \n    divider_indices = []\n    potential_divider_color = None\n    first_divider_found = False\n\n    for c in range(width):\n        column = grid[:, c]\n        # Check if all elements in the column are the same\n        # Use unique check which is efficient for numpy arrays\n        unique_elements = np.unique(column)\n        if len(unique_elements) == 1:\n            current_color = unique_elements[0]\n            # If this is the first divider found, store its color\n            if not first_divider_found:\n                potential_divider_color = current_color\n                divider_indices.append(c)\n                first_divider_found = True\n            # If subsequent dividers are found, ensure they have the same color\n            elif current_color == potential_divider_color:\n                divider_indices.append(c)\n            # else: Ignore columns with different uniform colors based on task examples\n\n    return divider_indices, potential_divider_color\n\n\ndef find_background_color(grid: np.ndarray, divider_indices: list[int], divider_color: int | None) -> int:\n    \"\"\"\n    Finds the most frequent color in the grid, excluding divider columns and the divider color itself.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        divider_indices: A list of column indices that are divider columns.\n        divider_color: The color value used in the divider columns.\n\n    Returns:\n        The background color value (int). Returns 0 if determination is ambiguous.\n    \"\"\"\n    height, width = grid.shape\n    non_divider_pixels = []\n    divider_indices_set = set(divider_indices) # Use set for faster lookup\n\n    for c in range(width):\n        if c not in divider_indices_set:\n            non_divider_pixels.extend(grid[:, c].tolist())\n\n    if not non_divider_pixels:\n        # No pixels outside dividers - ambiguous background. Default to 0.\n        return 0\n\n    # Count frequencies of non-divider pixels\n    color_counts = Counter(non_divider_pixels)\n\n    # Remove the divider color from counts if it exists and is not None\n    if divider_color is not None and divider_color in color_counts:\n        del color_counts[divider_color]\n\n    # Find the most common color among the remaining\n    if not color_counts:\n        # This could happen if all non-divider pixels were the divider_color\n        # Or if non_divider_pixels was empty initially. Default background to 0.\n        return 0\n\n    # Find the color with the highest count\n    # most_common returns list of tuples [(element, count)], access first element's first item\n    background_color = color_counts.most_common(1)[0][0]\n    return background_color\n\n\ndef split_into_sections(grid: np.ndarray, divider_indices: list[int]) -> list[np.ndarray]:\n    \"\"\"\n    Splits the grid into vertical sections based on divider column indices.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        divider_indices: A list of column indices that are divider columns.\n\n    Returns:\n        A list of numpy arrays, where each array is a section (subgrid).\n    \"\"\"\n    sections = []\n    height, width = grid.shape\n    if width == 0:\n        return []\n        \n    start_col = 0\n    # Ensure indices are sorted for correct section splitting\n    sorted_indices = sorted(divider_indices)\n\n    for div_idx in sorted_indices:\n        # Add section before the current divider, if it's not empty\n        if div_idx > start_col:\n            sections.append(grid[:, start_col:div_idx])\n        # Update start for the next section (it starts *after* the divider)\n        start_col = div_idx + 1\n\n    # Add the last section (from the last divider to the end), if it's not empty\n    if start_col < width:\n        sections.append(grid[:, start_col:width])\n\n    # Handle case where there are no dividers found (treat whole grid as one section)\n    if not divider_indices and width > 0:\n         sections.append(grid)\n\n    return sections\n\n\ndef count_foreground_pixels(section: np.ndarray, background_color: int, divider_color: int | None) -> int:\n    \"\"\"\n    Counts pixels in a section that are neither the background nor the divider color.\n\n    Args:\n        section: A numpy array representing a grid section.\n        background_color: The determined background color.\n        divider_color: The color of the divider columns (can be None).\n\n    Returns:\n        The count of foreground pixels (int).\n    \"\"\"\n    count = 0\n    if section.size == 0: # Handle empty sections gracefully\n        return 0\n        \n    for pixel in section.flat:\n        is_background = (pixel == background_color)\n        # Only check against divider_color if it's defined (not None)\n        is_divider = (divider_color is not None and pixel == divider_color)\n        \n        if not is_background and not is_divider:\n            count += 1\n    return count\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the described rule:\n    1. Find vertical divider columns (uniform color).\n    2. Determine background color (most frequent non-divider color).\n    3. Split grid into sections based on dividers.\n    4. Count foreground pixels (not background, not divider) in each section.\n    5. Select the leftmost section with the maximum foreground pixel count.\n    6. Return the selected section.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    if input_np.size == 0:\n        return [] # Handle empty input grid\n\n    # 1. Analyze Columns: Find divider columns and their color\n    divider_indices, divider_color = find_divider_columns(input_np)\n    \n    # Although examples always have dividers, add a check.\n    # If no dividers, the whole grid is one section. The logic below handles this.\n\n    # 2. Identify Background: Find the most frequent non-divider/non-divider-color pixel\n    background_color = find_background_color(input_np, divider_indices, divider_color)\n    \n    # 3. Define Sections: Split the grid based on dividers\n    sections = split_into_sections(input_np, divider_indices)\n    \n    if not sections:\n        # This might happen if the grid width is 0, or only consists of dividers.\n        # Return an empty grid consistent with ARC format.\n        return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []\n\n\n    # 4. Count Foreground in Sections and 5. Select Section\n    max_foreground_count = -1  # Use -1 to ensure the first section's count is always >\n    selected_section_index = -1 # Keep track of index for tie-breaking\n\n    for i, section in enumerate(sections):\n        foreground_count = count_foreground_pixels(section, background_color, divider_color)\n\n        # Keep the *first* section encountered (smallest index i) that has the maximum count\n        if foreground_count > max_foreground_count:\n            max_foreground_count = foreground_count\n            selected_section_index = i\n            \n    # 6. Produce Output: Return the selected section\n    if selected_section_index == -1:\n        # This case means no sections had foreground > -1.\n        # This could happen if all sections are empty or all pixels are background/divider.\n        # Default behavior: return the first section if available, else empty.\n        if sections:\n            selected_section = sections[0]\n        else:\n             # Should have been caught earlier, but defensively return empty\n             return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []\n    else:\n        selected_section = sections[selected_section_index]\n\n    # Convert the selected numpy section back to list of lists for ARC format\n    output_grid = selected_section.tolist()\n    \n    # Ensure output is not empty list if input height > 0 but section width is 0\n    if not output_grid and input_np.shape[0] > 0:\n         return [[]] * input_np.shape[0]\n         \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11627,
    "candidates_token_count": 2282,
    "total_token_count": 13909,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.26723,
  "retries": 1
}