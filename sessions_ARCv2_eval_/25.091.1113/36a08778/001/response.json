{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies vertical magenta lines (color 6) that span the grid height.\nDetermines a vertical column range based on these lines:\n- If two lines are found at c1 and c2 (c1 < c2), the range is [c1, c2].\n- If one line is found at c, the range is [0, c] if red pixels (color 2) exist in columns 0 to c-1,\n  or [c, width-1] if red pixels exist in columns c+1 to width-1. If red pixels exist on both sides\n  (not observed in examples), or only within column c, the behavior is based on the side with red pixels closest to the line or potentially favoring one side if ambiguous (let's assume it picks the side containing any red pixel). The implementation will check left first, then right.\n- If no lines are found, no changes are made.\n\nWithin the determined vertical column range [min_col, max_col]:\n- Find all red pixels (color 2).\n- If red pixels are found, determine the minimum (min_row) and maximum (max_row) row index among them.\n- Fill the rectangular region defined by [min_row, max_row] and [min_col, max_col]\n  by changing all orange pixels (color 7) within this rectangle to magenta (color 6).\n  Existing red and magenta pixels within the region remain unchanged.\n\"\"\"\n\ndef find_magenta_lines(grid):\n    \"\"\"Finds columns composed entirely of magenta (6).\"\"\"\n    height, width = grid.shape\n    line_cols = []\n    for c in range(width):\n        if np.all(grid[:, c] == 6):\n            line_cols.append(c)\n    return line_cols\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # 1. Identify vertical magenta lines\n    magenta_line_cols = find_magenta_lines(input_grid)\n    num_lines = len(magenta_line_cols)\n\n    min_col = -1\n    max_col = -1\n\n    # 2. Determine the vertical range (columns) for filling\n    if num_lines == 2:\n        min_col = magenta_line_cols[0]\n        max_col = magenta_line_cols[1]\n    elif num_lines == 1:\n        line_col = magenta_line_cols[0]\n        # Check for red pixels to the left of the line\n        red_exists_left = np.any(input_grid[:, 0:line_col] == 2)\n        # Check for red pixels to the right of the line\n        red_exists_right = np.any(input_grid[:, line_col+1:width] == 2)\n        # Check for red pixels within the line column itself (might be relevant if no red outside)\n        # red_exists_in_line_col = np.any(input_grid[:, line_col] == 2) # Unused for now based on examples\n\n        if red_exists_left:\n             min_col = 0\n             max_col = line_col\n        elif red_exists_right:\n             min_col = line_col\n             max_col = width - 1\n        # If red exists only IN the line column, or neither side (edge case not in examples)\n        # Current logic based on examples implies fill happens towards the side WITH red pixels.\n        # If neither side has red pixels strictly outside the line, no fill based on examples.\n        # Let's refine: If red is *only* on the left, fill left. If *only* on the right, fill right.\n        # If red is on *both* sides (unlikely per examples), need tie-break - let's stick to the first found side (left)\n        # If red is *neither* left nor right (could be in the line col, or nowhere), no fill.\n        if not red_exists_left and not red_exists_right:\n             # Check if any red pixels exist within the column bounds defined by the line itself\n             # If red pixels *only* exist within the line column c, the examples don't clearly define behaviour.\n             # Example 4 has red inside the column bounds [3, 4] and the fill happens there.\n             # Example 3 has red inside the column bounds [0, 2] and the fill happens there.\n             # Let's assume if red exists *anywhere* relative to the line, we pick that side.\n             # Re-evaluating the single line case based on observation:\n             # It seems sufficient to check if ANY red pixel exists left of OR AT the line column when setting the left boundary,\n             # and ANY red pixel exists right of OR AT the line column when setting the right boundary.\n\n             red_indices_left_or_at = np.argwhere(input_grid[:, 0:line_col+1] == 2)\n             red_indices_right_or_at = np.argwhere(input_grid[:, line_col:width] == 2)\n\n             if red_indices_left_or_at.size > 0:\n                 min_col = 0\n                 max_col = line_col\n             elif red_indices_right_or_at.size > 0:\n                 min_col = line_col\n                 max_col = width - 1\n             # If still no red found relative to the line, do nothing.\n\n\n    elif num_lines == 0:\n        # No magenta lines, return the original grid\n        return output_grid\n    # else num_lines > 2 is not expected based on examples\n\n    # If no valid column range was determined (e.g., single line with no relevant red pixels)\n    if min_col == -1 or max_col == -1:\n        return output_grid\n\n    # 3. Find red pixels within the determined vertical range [min_col, max_col]\n    red_pixel_rows = []\n    # Iterate only through the selected columns\n    for c in range(min_col, max_col + 1):\n        for r in range(height):\n            if input_grid[r, c] == 2:\n                red_pixel_rows.append(r)\n\n    # 4. Determine horizontal bounds if red pixels were found\n    if not red_pixel_rows:\n        # No red pixels found in the relevant columns, no fill needed\n        return output_grid\n\n    min_row = min(red_pixel_rows)\n    max_row = max(red_pixel_rows)\n\n    # 5. Fill the identified region\n    for r in range(min_row, max_row + 1):\n        for c in range(min_col, max_col + 1):\n            # Check the original input grid's color\n            if input_grid[r, c] == 7: # If orange\n                output_grid[r, c] = 6 # Change to magenta\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6640,
    "candidates_token_count": 1643,
    "total_token_count": 8283,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.789307,
  "retries": 1
}