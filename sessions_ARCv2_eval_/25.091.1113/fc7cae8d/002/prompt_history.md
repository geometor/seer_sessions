
## train_1

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
6 0 4 0 0 0 4 4 0 0 0 0 0 0 0 4 0 0 4 0 0 5
6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
6 0 0 0 1 1 1 1 1 1 1 0 1 1 1 4 0 0 0 0 0 5
6 6 0 0 0 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 0
6 6 0 0 1 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 5
6 0 0 0 0 0 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 0
6 0 0 0 0 0 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 0
6 0 0 0 1 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 5
6 6 0 0 1 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 0
6 0 0 0 1 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 5
6 0 0 0 1 1 1 1 1 1 1 8 1 1 1 4 0 0 0 0 0 0
6 0 0 0 1 1 1 1 1 2 2 8 2 2 1 4 0 0 0 0 0 0
6 0 0 0 1 1 1 1 1 2 1 1 1 1 1 4 0 0 0 0 0 0
6 0 0 0 1 8 8 8 8 8 1 1 1 3 1 4 0 0 0 0 0 0
6 6 0 0 1 1 1 1 1 2 1 1 1 3 1 4 0 0 0 0 0 5
6 0 0 0 1 1 1 1 1 2 1 3 3 3 1 4 0 0 0 0 0 5
6 6 0 0 1 1 1 1 1 1 1 1 1 1 1 4 0 0 0 0 0 0
6 0 0 0 6 6 6 6 6 6 6 6 6 6 6 0 0 0 0 0 0 0
6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
6 0 5 5 0 0 0 5 0 5 0 5 5 0 0 0 5 5 0 0 5 5
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 2 1 1 1 1 1 1 1 1 1
1 3 1 1 1 2 1 1 1 1 1 1 1 1 1
1 3 1 1 1 8 8 8 8 8 8 8 8 8 0
1 1 1 1 1 2 1 1 1 1 1 1 1 1 1
1 2 2 8 2 2 1 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 1 1 1 0 0 1 1 1
1 1 1 1 1 1 1 1 1 1 0 0 1 0 1
```


## train_2

**input:**
```
5 5 0 5 0 0 5 0 0 0 5 5 0 5 0 0 0 5 0 5 5 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
5 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 1
5 0 0 3 2 4 2 2 2 2 2 8 8 2 0 0 0 0 0 0 0 1
0 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 1
5 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 1
0 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 1
0 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 1 1
5 0 0 3 2 4 2 4 4 4 2 4 4 2 0 0 0 0 0 0 1 1
0 0 0 3 2 4 2 4 2 4 2 4 2 2 0 0 0 0 0 0 0 1
0 0 0 3 2 4 4 4 2 4 4 4 2 2 0 0 0 0 0 0 0 1
0 0 0 3 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 1 1
0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 3 0 0 0 3 3 0 0 0 0 3 0 0 0 3 0 3 3 0 0 1
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
2 2 2 2 2 2 2 2 2 2
2 8 2 2 2 2 4 2 2 2
2 8 2 2 2 2 4 4 4 2
2 2 2 2 2 2 2 2 4 2
2 2 2 2 2 2 4 4 4 2
2 2 2 2 2 2 4 2 2 2
2 2 2 2 2 2 4 4 4 2
2 2 2 2 2 2 2 2 4 2
2 4 2 2 2 2 4 4 4 2
2 2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
2 0 0 5 0 5 0 0 5 5 0 0 5 0 0 0 5 0 5 0 0 5
2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 4 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 4 8 9 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 4 8 9 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 0 4 8 3 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 2 0 4 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 5
2 0 0 4 4 0 4 0 0 4 4 0 0 4 0 0 0 4 4 0 4 5
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
8 8 8 0 0
8 8 8 6 8
8 8 8 6 8
8 9 9 3 8
8 8 8 8 8
```

*   **Perception**:
    *   The input grids are relatively large and contain various colors, often including border-like structures or noisy backgrounds.
    *   The output grids are significantly smaller than the corresponding input grids.
    *   Each input grid contains a distinct rectangular frame made of a single color (blue in train\_1, red in train\_2, azure in train\_3).
    *   This colored frame encloses a pattern composed of various colors.
    *   The output grid appears to be the pattern *inside* the colored frame found in the input grid.
    *   The frame itself is not included in the output.
    *   The color used for the frame is consistently the color that forms the largest single-colored rectangle (excluding the background color, white 0) in the input grid.

*   **Facts**:
    
```yaml
    task_elements:
      - item: input_grid
        properties:
          - contains multiple colors
          - includes background noise/elements (often white 0, gray 5)
          - features a large, single-colored rectangular frame (the 'bounding_frame')
          - bounding_frame encloses an inner pattern
      - item: bounding_frame
        properties:
          - rectangular shape
          - composed of a single, non-background color (color C)
          - appears to be the largest such rectangle in the input grid
          - defines the area of interest
        relationships:
          - encloses the inner_pattern
      - item: inner_pattern
        properties:
          - located spatially inside the bounding_frame
          - composed of various colors
        relationships:
          - is extracted to form the output_grid
      - item: output_grid
        properties:
          - smaller dimensions than input_grid
          - identical pixel values and arrangement to the inner_pattern
        relationships:
          - is the extracted inner_pattern from the input_grid

    transformation:
      - action: identify_rectangles
        actor: system
        input: input_grid
        output: list of single-colored rectangles (excluding background color 0)
        details: Find all maximal contiguous rectangular areas composed of a single color C != 0.
      - action: find_largest_rectangle
        actor: system
        input: list of rectangles
        output: the bounding_frame (largest rectangle by area)
        details: Select the rectangle with the maximum area.
      - action: determine_inner_bounds
        actor: system
        input: bounding_frame coordinates (top, left, bottom, right)
        output: inner_pattern coordinates (top+1, left+1, bottom-1, right-1)
      - action: extract_subgrid
        actor: system
        input: input_grid, inner_pattern coordinates
        output: output_grid
        details: Copy the portion of the input_grid defined by the inner_pattern coordinates.
    ```


*   **Natural Language Program**:
    1.  Scan the input grid to identify all contiguous rectangular blocks composed of a single color, ignoring the background color white (0).
    2.  Determine the area (height * width) of each identified rectangle.
    3.  Select the rectangle with the largest area. This rectangle acts as the "bounding frame".
    4.  Define a new, smaller rectangular area by taking the region strictly *inside* the bounding frame (i.e., exclude the frame's border pixels by incrementing the top/left coordinates and decrementing the bottom/right coordinates).
    5.  Extract the subgrid corresponding to this inner rectangular area from the input grid. This extracted subgrid is the output grid.
```python
import numpy as np

"""
Identify the largest contiguous rectangular block composed of a single non-background (non-white, non-0) color in the input grid. This rectangle serves as a bounding frame. Extract the subgrid located strictly inside this bounding frame (excluding the frame's border pixels). The extracted subgrid is the output.
"""

def find_colored_rectangles(grid):
    """
    Finds all maximal contiguous rectangular blocks of a single color (excluding color 0).

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, where each dictionary represents a rectangle
              and contains 'color', 'top', 'left', 'bottom', 'right', and 'area'.
              Returns an empty list if no such rectangles are found.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                q = [(r, c)]
                visited[r, c] = True
                coords = [(r, c)]
                min_r, max_r = r, r
                min_c, max_c = c, c

                # BFS to find all connected cells of the same color
                head = 0
                while head < len(q):
                    curr_r, curr_c = q[head]
                    head += 1

                    min_r = min(min_r, curr_r)
                    max_r = max(max_r, curr_r)
                    min_c = min(min_c, curr_c)
                    max_c = max(max_c, curr_c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            coords.append((nr, nc))

                # Check if the found shape is a solid rectangle
                height = max_r - min_r + 1
                width = max_c - min_c + 1
                is_rectangle = True
                if len(coords) != height * width:
                    is_rectangle = False
                else:
                    # Double-check all cells within the bounds match the color
                    for check_r in range(min_r, max_r + 1):
                        for check_c in range(min_c, max_c + 1):
                            if grid[check_r, check_c] != color:
                                is_rectangle = False
                                break
                        if not is_rectangle:
                            break
                
                # Reset visited status for non-rectangular shapes within the bounding box
                # This is important if a non-rectangular shape was initially explored
                if not is_rectangle:
                     for cr, cc in coords:
                         # Check if the cell truly belongs only to this failed exploration
                         # A simple reset might be incorrect if cells were shared by overlapping checks
                         # A safer approach might involve more complex region tracking, but let's try resetting
                         # if it doesn't form the calculated bounding box.
                         # This BFS finds connected components. If it's not a rect, we just discard it.
                         # The cells will be revisited if they are part of *another* starting point's component.
                         # So, no need to reset visited status here. The `visited` prevents re-starting BFS
                         # from within an already explored component.
                         pass # No reset needed based on BFS logic


                if is_rectangle:
                    rectangles.append({
                        'color': color,
                        'top': min_r,
                        'left': min_c,
                        'bottom': max_r,
                        'right': max_c,
                        'area': height * width
                    })

    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by finding the largest non-background colored rectangle
    and extracting the content strictly inside it.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the output grid, which is the
                   subgrid inside the largest identified rectangle. Returns an empty
                   grid if no suitable rectangle is found or if the inner region
                   has zero height or width.
    """
    input_grid_np = np.array(input_grid)

    # 1. Find all non-background (non-0) colored rectangles
    rectangles = find_colored_rectangles(input_grid_np)

    # Handle case where no rectangles are found
    if not rectangles:
        # Return empty or default based on potential ARC conventions
        # For now, returning an empty 0x0 grid
        return np.array([[]], dtype=input_grid_np.dtype)

    # 2. Find the rectangle with the largest area
    largest_rect = max(rectangles, key=lambda r: r['area'])

    # 3. Define the inner bounds (excluding the frame)
    inner_top = largest_rect['top'] + 1
    inner_left = largest_rect['left'] + 1
    inner_bottom = largest_rect['bottom'] - 1
    inner_right = largest_rect['right'] - 1

    # 4. Check if the inner bounds are valid (positive height and width)
    if inner_top > inner_bottom or inner_left > inner_right:
        # The frame is too thin (1 pixel wide/high) or invalid
        return np.array([[]], dtype=input_grid_np.dtype) # Return empty grid

    # 5. Extract the subgrid corresponding to the inner area
    output_grid = input_grid_np[inner_top : inner_bottom + 1, inner_left : inner_right + 1]

    return output_grid
```
