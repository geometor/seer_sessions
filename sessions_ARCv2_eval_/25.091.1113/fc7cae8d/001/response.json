{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify the largest contiguous rectangular block composed of a single non-background (non-white, non-0) color in the input grid. This rectangle serves as a bounding frame. Extract the subgrid located strictly inside this bounding frame (excluding the frame's border pixels). The extracted subgrid is the output.\n\"\"\"\n\ndef find_colored_rectangles(grid):\n    \"\"\"\n    Finds all maximal contiguous rectangular blocks of a single color (excluding color 0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a rectangle\n              and contains 'color', 'top', 'left', 'bottom', 'right', and 'area'.\n              Returns an empty list if no such rectangles are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = [(r, c)]\n                visited[r, c] = True\n                coords = [(r, c)]\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # BFS to find all connected cells of the same color\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            coords.append((nr, nc))\n\n                # Check if the found shape is a solid rectangle\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                is_rectangle = True\n                if len(coords) != height * width:\n                    is_rectangle = False\n                else:\n                    # Double-check all cells within the bounds match the color\n                    for check_r in range(min_r, max_r + 1):\n                        for check_c in range(min_c, max_c + 1):\n                            if grid[check_r, check_c] != color:\n                                is_rectangle = False\n                                break\n                        if not is_rectangle:\n                            break\n                \n                # Reset visited status for non-rectangular shapes within the bounding box\n                # This is important if a non-rectangular shape was initially explored\n                if not is_rectangle:\n                     for cr, cc in coords:\n                         # Check if the cell truly belongs only to this failed exploration\n                         # A simple reset might be incorrect if cells were shared by overlapping checks\n                         # A safer approach might involve more complex region tracking, but let's try resetting\n                         # if it doesn't form the calculated bounding box.\n                         # This BFS finds connected components. If it's not a rect, we just discard it.\n                         # The cells will be revisited if they are part of *another* starting point's component.\n                         # So, no need to reset visited status here. The `visited` prevents re-starting BFS\n                         # from within an already explored component.\n                         pass # No reset needed based on BFS logic\n\n\n                if is_rectangle:\n                    rectangles.append({\n                        'color': color,\n                        'top': min_r,\n                        'left': min_c,\n                        'bottom': max_r,\n                        'right': max_c,\n                        'area': height * width\n                    })\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the largest non-background colored rectangle\n    and extracting the content strictly inside it.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the output grid, which is the\n                   subgrid inside the largest identified rectangle. Returns an empty\n                   grid if no suitable rectangle is found or if the inner region\n                   has zero height or width.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n\n    # 1. Find all non-background (non-0) colored rectangles\n    rectangles = find_colored_rectangles(input_grid_np)\n\n    # Handle case where no rectangles are found\n    if not rectangles:\n        # Return empty or default based on potential ARC conventions\n        # For now, returning an empty 0x0 grid\n        return np.array([[]], dtype=input_grid_np.dtype)\n\n    # 2. Find the rectangle with the largest area\n    largest_rect = max(rectangles, key=lambda r: r['area'])\n\n    # 3. Define the inner bounds (excluding the frame)\n    inner_top = largest_rect['top'] + 1\n    inner_left = largest_rect['left'] + 1\n    inner_bottom = largest_rect['bottom'] - 1\n    inner_right = largest_rect['right'] - 1\n\n    # 4. Check if the inner bounds are valid (positive height and width)\n    if inner_top > inner_bottom or inner_left > inner_right:\n        # The frame is too thin (1 pixel wide/high) or invalid\n        return np.array([[]], dtype=input_grid_np.dtype) # Return empty grid\n\n    # 5. Extract the subgrid corresponding to the inner area\n    output_grid = input_grid_np[inner_top : inner_bottom + 1, inner_left : inner_right + 1]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5398,
    "candidates_token_count": 1453,
    "total_token_count": 6851,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.610034,
  "retries": 1
}