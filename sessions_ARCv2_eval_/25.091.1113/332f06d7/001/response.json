{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1. Identify all contiguous blocks (objects) of Red (2), White (0), and Blue (1) pixels in the input grid. For each object, record its color, the coordinates of its pixels, and its dimensions (height and width).\n2. Initialize the output grid as a copy of the input grid.\n3. Process White Objects: For every White object found, change the color of all its constituent pixels in the output grid to Blue (1).\n4. Process Red Objects: For every Red object found:\n    a. Determine its dimensions (height, width).\n    b. Count how many Blue objects share these exact dimensions.\n    c. If exactly one Blue object matches the dimensions:\n        i. Locate that unique matching Blue object.\n        ii. Change the color of all its constituent pixels in the output grid to White (0).\n    d. Otherwise (if zero or more than one Blue object matches the dimensions):\n        i. Change the color of all the constituent pixels of the *current Red object* in the output grid to White (0).\n5. Return the modified output grid. Green (3) pixels and Blue pixels not involved in the Red object matching process remain unchanged (unless they originated from White objects).\n\"\"\"\n\ndef find_objects(grid, target_color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (list of (r, c) tuples),\n              'height', and 'width'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS to find the extent of the object\n                q = deque([(r, c)])\n                visited[r, c] = True\n                object_coords = [(r, c)]\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            object_coords.append((nr, nc))\n\n                obj_height = max_r - min_r + 1\n                obj_width = max_c - min_c + 1\n                objects.append({\n                    'color': target_color,\n                    'coords': object_coords,\n                    'height': obj_height,\n                    'width': obj_width\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    - White objects become Blue.\n    - If a Red object has the same dimensions as exactly one Blue object, that Blue object becomes White.\n    - Otherwise, the Red object itself becomes White.\n    \"\"\"\n    # Convert input_grid list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy\n    output_grid = np.copy(input_np)\n\n    # Find all objects of relevant colors\n    white_objects = find_objects(input_np, 0) # 0: White\n    red_objects = find_objects(input_np, 2)   # 2: Red\n    blue_objects = find_objects(input_np, 1)  # 1: Blue\n\n    # Process White objects: Change White to Blue\n    for obj in white_objects:\n        for r, c in obj['coords']:\n            output_grid[r, c] = 1 # Change to Blue\n\n    # Process Red objects: Conditional change based on Blue object dimensions\n    for red_obj in red_objects:\n        red_h, red_w = red_obj['height'], red_obj['width']\n        \n        # Find Blue objects with matching dimensions\n        matching_blue_objects = []\n        for blue_obj in blue_objects:\n            if blue_obj['height'] == red_h and blue_obj['width'] == red_w:\n                matching_blue_objects.append(blue_obj)\n        \n        # Check condition: Exactly one matching Blue object\n        if len(matching_blue_objects) == 1:\n            # Change the unique matching Blue object to White\n            target_blue_obj = matching_blue_objects[0]\n            for r, c in target_blue_obj['coords']:\n                # Important: Check if this blue pixel wasn't originally white\n                # If it was originally white, it should end up blue as per step 1\n                # This check prevents overwriting the white->blue change if the red trigger targets it.\n                # However, the rules imply the red trigger takes precedence if there's a match.\n                # So, if a white block became blue, and a red block matches its dimensions, it becomes white again.\n                 output_grid[r, c] = 0 # Change to White\n        else:\n            # Change the Red object itself to White\n            for r, c in red_obj['coords']:\n                output_grid[r, c] = 0 # Change to White\n\n    # Convert back to list of lists if necessary for the ARC framework\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4921,
    "candidates_token_count": 1459,
    "total_token_count": 6380,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.759153,
  "retries": 1
}