
## train_1

**input:**
```
0 0 0 2 2 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 1 1 0 0 0
0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 2 2 0 0
1 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 2 3 3 3 0 0
0 0 0 2 3 3 3 3 0 0
0 0 0 3 1 1 0 3 0 0
0 0 0 3 1 0 0 3 0 0
0 0 0 3 0 0 1 3 0 0
0 0 0 3 0 1 1 3 0 0
0 0 0 3 3 3 3 2 0 0
0 0 0 3 3 3 2 2 0 0
1 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 4 4
0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 1 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0
0 1 3 0 4 0 1 1 0 0
0 4 5 0 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 5 5 5 5 4 4
0 0 0 0 5 5 5 5 5 4
0 0 0 0 5 1 1 3 5 5
0 0 0 0 5 1 3 3 5 5
0 0 0 0 5 3 3 3 5 5
0 0 0 0 5 3 3 3 5 5
0 0 0 0 5 3 3 1 5 5
0 1 3 0 4 3 1 1 5 5
0 4 5 0 4 4 5 5 5 5
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
3 3 5 5 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 5 3 3 3 3 5 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 5 5 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 3 4 4 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 4 3 3 1 1 3 3 2 3 3 3
3 3 3 3 3 3 3 3 3 3 1 3 2 2 3 3 3
3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3
3 3 1 6 3 3 3 3 4 4 3 3 3 3 3 3 3
3 3 2 9 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 4 0 3 3 3 1 3 3 3 3 3 3 3 3 3
3 3 8 9 3 3 3 1 1 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 5 5 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 5 3 3 3 3 5 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 5 5 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 9 9 9 9 9 9 9 9 3 3 3
3 3 3 3 2 9 9 9 9 9 9 9 9 9 3 3 3
3 3 3 3 9 9 9 6 6 1 1 9 9 2 3 3 3
3 3 3 3 9 9 9 6 6 6 1 9 2 2 3 3 3
3 3 3 3 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 1 6 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 2 9 3 3 3 6 6 6 6 3 3 3 3 3 3
3 3 4 0 3 3 3 1 6 6 6 3 3 3 3 3 3
3 3 8 9 3 3 3 1 1 6 6 3 3 3 3 3 3
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 4
0 0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 4 4
0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 0 0 0 0 0 0 0 0 6 0 0 0 7 7 0 0
6 7 0 0 0 0 0 0 0 6 6 0 0 0 7 7 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4
0 0 0 0 0 0 6 6 7 7 7 0 4 4 4 4 4 4
0 0 0 0 0 0 6 7 7 7 7 0 0 0 0 0 0 0
0 0 0 0 0 0 7 7 7 7 7 0 0 0 0 0 0 0
3 3 0 0 0 0 7 7 7 7 6 0 0 0 6 6 0 0
6 7 0 0 0 0 7 7 7 6 6 0 0 0 6 6 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception**: The task involves identifying enclosed regions within a grid and filling them based on colors found on their boundaries and specific adjacency rules within the grid. The background color, which defines the regions to be filled, can vary between examples (white or green). The fill color depends on the colors bordering the enclosed region. If there's only one border color, that color is used to fill. If there are multiple border colors, the fill color is determined by looking for adjacent pairs of different, non-background colors elsewhere in the grid. Specifically, if a boundary color C1 is found adjacent to another color C2 in the grid, C2 becomes a potential fill color. If multiple such pairs exist involving different boundary colors, the potential fill color with the highest numerical index is chosen. In one case (train\_2), pixels matching a 'losing' potential fill color (green 3) that were also adjacent to the filled region were overwritten by the 'winning' fill color (gray 5).

*   **Facts**:
    
