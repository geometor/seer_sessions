{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Scan the input grid to find the unique 'fill color' pixel (either yellow/4 or orange/7). Store this fill color. If none is found, return the original grid.\n3. Find all connected components (regions) of white (0) pixels in the input grid.\n4. For each white component:\n    a. Check if any pixel in the component touches the grid edge. If it does, this component is invalid; ignore it.\n    b. Determine all pixels immediately adjacent (up, down, left, right) to any pixel in the component, but which are *not* part of the component itself. These are the boundary neighbors.\n    c. Check if all boundary neighbors exist and if they all have the *exact same* single non-white color. Store this boundary color. If neighbors don't exist, or are not uniform, or are white, this component is invalid; ignore it.\n    d. **Size Exclusion:** Check if the component is exactly a 2x2 square. If it is, and the boundary color found in step 4c is red (2), then this component is invalid; ignore it.\n    e. **Color Filter:** Apply a filter based on the fill color and the boundary color:\n        i. If the fill color is orange (7), the component is only valid if its boundary color is red (2) or gray (5).\n        ii. If the fill color is yellow (4), the component is only valid if its boundary color is red (2).\n    f. If the component is valid (passes edge check, uniform non-white boundary check, size exclusion check, and the color filter check), then mark it for filling.\n5. Change the color of all pixels belonging to any valid marked component in the *output* grid to the stored 'fill color'.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_fill_color(grid):\n    \"\"\"Scans the grid to find the unique yellow (4) or orange (7) pixel.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            pixel_color = grid[r, c]\n            # Check if the color is yellow (4) or orange (7)\n            if pixel_color == 4 or pixel_color == 7:\n                return pixel_color\n    # Fallback: Return -1 if no fill color found\n    return -1 \n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid adjacent neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_connected_components(grid, color_to_find):\n    \"\"\"Finds all connected components of a specific color using Breadth-First Search (BFS).\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color_to_find and not visited[r, c]:\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr, nc] == color_to_find and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                \n                components.append(component)\n    return components\n\ndef check_validity_and_filter(component, grid, fill_color):\n    \"\"\"\n    Checks if a component of white pixels satisfies all enclosure, size, and filter conditions.\n    Returns True if valid, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    boundary_colors = set()\n    first_boundary_color = -1 \n    touches_edge = False\n    has_boundary_neighbors = False\n\n    # Check for edge contact first\n    for r, c in component:\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            touches_edge = True\n            return False # Invalid if touches edge\n\n    # If not touching edge, find boundary neighbors and colors\n    for r, c in component:\n        for nr, nc in get_neighbors(r, c, height, width):\n            if (nr, nc) not in component:\n                has_boundary_neighbors = True\n                neighbor_color = grid[nr, nc]\n                boundary_colors.add(neighbor_color)\n                if first_boundary_color == -1:\n                    first_boundary_color = neighbor_color\n\n    # Check boundary validity\n    if not has_boundary_neighbors:\n        return False # Must have neighbors outside itself\n\n    is_uniform_non_white = len(boundary_colors) == 1 and 0 not in boundary_colors\n    if not is_uniform_non_white:\n        return False # Boundary must be single, non-white color\n        \n    boundary_color = first_boundary_color # The uniform boundary color\n\n    # Check Size Exclusion: Is it a 2x2 square bounded by red?\n    if len(component) == 4 and boundary_color == 2:\n        # Further check if it's actually a 2x2 square shape\n        min_r = min(r for r, c in component)\n        max_r = max(r for r, c in component)\n        min_c = min(c for r, c in component)\n        max_c = max(c for r, c in component)\n        if max_r - min_r == 1 and max_c - min_c == 1:\n             return False # Exclude 2x2 white squares bounded by red\n\n    # Apply Color Filter\n    if fill_color == 7: # Orange fill\n        if boundary_color == 2 or boundary_color == 5: # Red or Gray boundary\n            return True\n    elif fill_color == 4: # Yellow fill\n        if boundary_color == 2: # Red boundary only\n            return True\n\n    # If filter conditions are not met\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds the fill color (orange/7 or yellow/4),\n    identifies white regions that are fully enclosed by specific boundary colors \n    (red/2 or gray/5 for orange fill; red/2 only for yellow fill) without touching the edge,\n    excluding 2x2 red-bounded squares, and fills those valid regions with the fill color.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Step 1: Find the fill color (4 or 7)\n    fill_color = find_fill_color(grid)\n    if fill_color == -1: \n         # No fill color found, return the original grid\n         return output_grid.tolist() \n\n    # Step 2: Find all connected components of white (0) pixels\n    white_components = find_connected_components(grid, 0)\n\n    # Step 3 & 4: Check each white component for validity and filter\n    for component in white_components:\n        # Check all conditions: edge, boundary uniformity, size exclusion, color filter\n        if check_validity_and_filter(component, grid, fill_color):\n            # Step 5: If valid, fill the region in the output grid\n            for r, c in component:\n                output_grid[r, c] = fill_color\n\n    # Return the final modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21250,
    "candidates_token_count": 1928,
    "total_token_count": 23178,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.605719,
  "retries": 1
}