{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n# -*- coding: utf-8 -*-\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify the background color (most frequent color).\n2. Find the two distinct non-background patterns (objects) in the input grid using connected components analysis.\n3. Determine the bounding box subgrid for each pattern.\n4. Count the number of unique non-background colors within each pattern's bounding box subgrid.\n5. The pattern with a higher count of unique non-background colors becomes the 'Tile Pattern'.\n   The other pattern becomes the 'Shape Pattern'. If counts are equal, the selection criteria might need refinement,\n   but based on examples, the one with more colors is the tile. Assume unequal counts or a default tie-break (e.g., first found).\n6. Create a binary mask from the Shape Pattern's subgrid (1 for non-background pixels, 0 for background).\n7. Create an output grid whose dimensions are derived by multiplying the dimensions of the\n   Shape Pattern's mask (rows * tile_height, cols * tile_width).\n8. Tile the output grid: Place copies of the Tile Pattern subgrid into the output grid at positions\n   corresponding to the '1's in the Shape Pattern mask, scaled by the Tile Pattern dimensions.\n   Place blocks of the background color (matching the Tile Pattern's dimensions) where the mask is '0'.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n# Use morphological label function to find connected components\nfrom scipy.ndimage import label, find_objects as ndi_find_objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n\n    # Step 1: Identify background color (most frequent)\n    # Use np.unique to find all unique colors and their counts\n    colors, counts = np.unique(input_array, return_counts=True)\n    # The background color is the one with the highest count\n    background_color = colors[np.argmax(counts)]\n\n    # Step 2: Find non-background objects using connected components\n    # Create a boolean mask where True indicates non-background pixels\n    non_background_mask = (input_array != background_color)\n    # Use scipy.ndimage.label to find connected components in the mask.\n    # It assigns a unique integer label to each distinct object.\n    # structure=np.ones((3,3)) ensures 8-way connectivity (pixels touching sides or corners are connected).\n    labeled_array, num_features = label(non_background_mask, structure=np.ones((3,3), dtype=bool))\n\n    # Handle case where no non-background objects are found\n    if num_features == 0:\n        # Return the input grid unchanged as no patterns exist to process.\n        return input_grid\n\n    objects_data = []\n    # Use scipy.ndimage.find_objects to get the bounding box slices for each labeled object.\n    # It returns a list where each element is a tuple of slice objects (one per dimension).\n    object_slices = ndi_find_objects(labeled_array)\n\n    # Step 3 & 4: Extract subgrids and count unique non-background colors for each object\n    for i in range(num_features):\n        # Get the slice tuple for the current object (objects are labeled 1 to num_features)\n        obj_slice = object_slices[i]\n        # Extract the subgrid (bounding box content) from the input array using the slice\n        subgrid = input_array[obj_slice]\n\n        # Count the number of unique non-background colors within this subgrid\n        unique_colors_in_subgrid = np.unique(subgrid)\n        non_bg_unique_count = len([c for c in unique_colors_in_subgrid if c != background_color])\n\n        # Store relevant information about the object\n        objects_data.append({\n            'id': i + 1,            # Object label (1-based index)\n            'slice': obj_slice,     # Slice defining the bounding box\n            'subgrid': subgrid,     # The actual pixel data within the bounding box\n            'unique_non_bg_count': non_bg_unique_count, # Count of unique non-background colors\n            'height': subgrid.shape[0], # Height of the subgrid\n            'width': subgrid.shape[1]   # Width of the subgrid\n        })\n\n    # Based on training examples, we expect exactly two distinct patterns.\n    # If label finds more or fewer, apply heuristics or error handling.\n    if len(objects_data) != 2:\n        # Heuristic: If more than 2 objects, assume the two largest (by pixel count) are the intended patterns.\n        if len(objects_data) > 2:\n             objects_data.sort(key=lambda x: x['subgrid'].size, reverse=True)\n             objects_data = objects_data[:2]\n        # If fewer than 2 objects, the task cannot be performed as described.\n        elif len(objects_data) < 2:\n             # Return input grid as a fallback.\n             return input_grid\n\n    # Step 5: Determine Tile Pattern and Shape Pattern\n    # Sort the found objects based on the count of unique non-background colors (descending).\n    # The object with more unique colors is designated as the Tile Pattern.\n    objects_data.sort(key=lambda x: x['unique_non_bg_count'], reverse=True)\n\n    # Assign roles based on the sorted list\n    tile_pattern_data = objects_data[0]\n    shape_pattern_data = objects_data[1]\n\n    # Extract the grid data for the tile and shape patterns\n    tile_pattern_grid = tile_pattern_data['subgrid']\n    shape_pattern_grid = shape_pattern_data['subgrid']\n\n    # Get dimensions of the patterns' subgrids\n    tile_h, tile_w = tile_pattern_grid.shape\n    shape_h, shape_w = shape_pattern_grid.shape\n\n    # Step 6: Create a Binary Mask from the Shape Pattern's Subgrid\n    # The mask is 1 where the shape pattern has a non-background color, and 0 otherwise.\n    shape_binary_mask = (shape_pattern_grid != background_color).astype(int)\n\n    # Step 7: Calculate Output Grid Dimensions\n    # The output grid size is determined by the shape pattern's dimensions scaled by the tile pattern's dimensions.\n    output_h = shape_h * tile_h\n    output_w = shape_w * tile_w\n\n    # Step 8: Initialize and Tile the Output Grid\n    # Create the output grid, initializing all cells with the background color.\n    output_grid = np.full((output_h, output_w), background_color, dtype=int)\n\n    # Iterate through each cell (r, c) of the shape pattern's bounding box / binary mask\n    for r in range(shape_h):\n        for c in range(shape_w):\n            # Calculate the top-left coordinate (start row, start col) for placing the tile/block\n            # in the output grid, based on the current shape mask position (r, c) and tile dimensions.\n            out_r_start = r * tile_h\n            out_c_start = c * tile_w\n            # Calculate the bottom-right coordinate (exclusive end row, end col)\n            out_r_end = out_r_start + tile_h\n            out_c_end = out_c_start + tile_w\n\n            # Check the value in the shape binary mask at position (r, c)\n            if shape_binary_mask[r, c] == 1:\n                # If the mask value is 1, copy the entire tile pattern grid into the\n                # corresponding block in the output grid.\n                output_grid[out_r_start:out_r_end, out_c_start:out_c_end] = tile_pattern_grid\n            else:\n                # If the mask value is 0, fill the corresponding block in the output grid\n                # with the background color. (This is technically redundant due to initialization,\n                # but ensures correctness if initialization changes).\n                 output_grid[out_r_start:out_r_end, out_c_start:out_c_end] = background_color\n\n    # Convert the final NumPy array output grid back to the required list of lists format.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3176,
    "candidates_token_count": 2011,
    "total_token_count": 5187,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 65.227289,
  "retries": 1
}