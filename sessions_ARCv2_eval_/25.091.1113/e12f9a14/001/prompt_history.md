
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
8 3 3 8 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 8 8 8 8
8 8 3 3 3 8 8 8
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 4 8 8 8 8
8 8 8 4 8 8 8 8
8 3 3 4 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 4 4 4 4
8 4 3 3 3 8 8 8
4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 3 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 6 8 8 8 6 8 8 8 8 8
8 8 6 8 8 6 8 8 8 8 8 8
8 3 6 3 6 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 6 3 3 3 8 8 8 8 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```

*   **Perception**: The task involves identifying shapes defined by green pixels (3) on a gray (8) background. Inside these green boundaries, there are small regions of other colors (e.g., maroon(9), blue(1), yellow(4), magenta(6), red(2), orange(7)). The transformation fills the gray background areas connected to these inner colors, using the respective inner color for filling. The filling process extends outwards from the inner color regions, stops at the green boundaries, and does not affect the original green shapes or their inner colored regions. The fill seems to use 8-way connectivity (including diagonals).

*   **YAML Facts**:
    
```yaml
    task_description: "Fill gray background areas connected to colors enclosed by green boundaries."
    elements:
      - type: background
        color: gray (8)
        description: "The main grid area, subject to filling."
      - type: boundary
        color: green (3)
        description: "Closed or partially closed shapes acting as barriers to the fill."
        properties:
          - barrier: Prevents fill propagation.
          - static: Remains unchanged in the output.
      - type: seed_region
        description: "One or more connected pixels of a specific color (non-gray, non-green) located inside a green boundary."
        properties:
          - enclosed: Surrounded by green pixels or grid edges within the boundary area.
          - color: Varies (e.g., maroon, blue, yellow, magenta, red, orange). Determines the fill color.
          - static: Remains unchanged in the output.
      - type: fill_area
        description: "Regions of gray pixels in the input that are connected to a seed_region without crossing a green boundary."
        properties:
          - initial_color: gray (8)
          - final_color: The color of the connected seed_region.
          - connectivity: 8-way (adjacent and diagonal).
    actions:
      - type: identify_boundaries
        input: input_grid
        output: set of green pixel coordinates.
      - type: identify_seed_regions
        input: input_grid, boundaries
        output: list of seed_regions (each with color and coordinates).
      - type: flood_fill_from_seeds
        input: input_grid, boundaries, seed_regions
        parameters:
          - fill_target: gray (8)
          - barrier_color: green (3)
          - connectivity: 8
        output: modified_grid
        description: "For each seed_region, perform a flood fill starting from its pixels. The fill propagates into adjacent gray pixels, using the seed_region's color. The fill stops at green boundaries, grid edges, or non-gray pixels."
    output_generation:
      - step: Initialize output_grid as a copy of input_grid.
      - step: Identify boundaries and seed_regions.
      - step: Perform flood_fill_from_seeds, updating the output_grid.
      - step: Return the final output_grid.

    ```


*   **Natural Language Program**:
    1.  Create a copy of the input grid to serve as the output grid.
    2.  Identify all green (3) pixels in the input grid. These act as static barriers.
    3.  Find all pixels that are not green (3) and not gray (8). These are potential "seed" pixels.
    4.  For each distinct seed color found:
        a.  Identify all seed pixels of that color.
        b.  Perform a flood-fill operation starting simultaneously from all these seed pixels:
            i.  The fill color is the seed color.
            ii. The fill can spread to any adjacent (including diagonally) gray (8) pixel in the output grid.
            iii. The fill cannot spread into or across green (3) pixels.
            iv. The fill stops at green (3) pixels, grid boundaries, or any pixel that is not gray (8).
        c.  Update the output grid with the results of the flood fill for this seed color. Pixels changed by the fill retain their new color and cannot be overwritten by subsequent fills from different seed colors.
    5.  Return the final output grid.
