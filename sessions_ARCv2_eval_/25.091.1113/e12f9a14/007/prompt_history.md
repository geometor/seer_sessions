
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
8 3 3 8 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 8 8 8 8
8 8 3 3 3 8 8 8
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 4 8 8 8 8
8 8 8 4 8 8 8 8
8 3 3 4 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 4 4 4 4
8 4 3 3 3 8 8 8
4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 3 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 6 8 8 8 6 8 8 8 8 8
8 8 6 8 8 6 8 8 8 8 8 8
8 3 6 3 6 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 6 3 3 3 8 8 8 8 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```

*   **Perception**: The task involves identifying shapes defined by green pixels (3) on a gray (8) background. Inside these green boundaries, there are small regions of other colors (e.g., maroon(9), blue(1), yellow(4), magenta(6), red(2), orange(7)). The transformation fills the gray background areas connected to these inner colors, using the respective inner color for filling. The filling process extends outwards from the inner color regions, stops at the green boundaries, and does not affect the original green shapes or their inner colored regions. The fill seems to use 8-way connectivity (including diagonals).

*   **YAML Facts**:
    
```yaml
    task_description: "Fill gray background areas connected to colors enclosed by green boundaries."
    elements:
      - type: background
        color: gray (8)
        description: "The main grid area, subject to filling."
      - type: boundary
        color: green (3)
        description: "Closed or partially closed shapes acting as barriers to the fill."
        properties:
          - barrier: Prevents fill propagation.
          - static: Remains unchanged in the output.
      - type: seed_region
        description: "One or more connected pixels of a specific color (non-gray, non-green) located inside a green boundary."
        properties:
          - enclosed: Surrounded by green pixels or grid edges within the boundary area.
          - color: Varies (e.g., maroon, blue, yellow, magenta, red, orange). Determines the fill color.
          - static: Remains unchanged in the output.
      - type: fill_area
        description: "Regions of gray pixels in the input that are connected to a seed_region without crossing a green boundary."
        properties:
          - initial_color: gray (8)
          - final_color: The color of the connected seed_region.
          - connectivity: 8-way (adjacent and diagonal).
    actions:
      - type: identify_boundaries
        input: input_grid
        output: set of green pixel coordinates.
      - type: identify_seed_regions
        input: input_grid, boundaries
        output: list of seed_regions (each with color and coordinates).
      - type: flood_fill_from_seeds
        input: input_grid, boundaries, seed_regions
        parameters:
          - fill_target: gray (8)
          - barrier_color: green (3)
          - connectivity: 8
        output: modified_grid
        description: "For each seed_region, perform a flood fill starting from its pixels. The fill propagates into adjacent gray pixels, using the seed_region's color. The fill stops at green boundaries, grid edges, or non-gray pixels."
    output_generation:
      - step: Initialize output_grid as a copy of input_grid.
      - step: Identify boundaries and seed_regions.
      - step: Perform flood_fill_from_seeds, updating the output_grid.
      - step: Return the final output_grid.

    ```


*   **Natural Language Program**:
    1.  Create a copy of the input grid to serve as the output grid.
    2.  Identify all green (3) pixels in the input grid. These act as static barriers.
    3.  Find all pixels that are not green (3) and not gray (8). These are potential "seed" pixels.
    4.  For each distinct seed color found:
        a.  Identify all seed pixels of that color.
        b.  Perform a flood-fill operation starting simultaneously from all these seed pixels:
            i.  The fill color is the seed color.
            ii. The fill can spread to any adjacent (including diagonally) gray (8) pixel in the output grid.
            iii. The fill cannot spread into or across green (3) pixels.
            iv. The fill stops at green (3) pixels, grid boundaries, or any pixel that is not gray (8).
        c.  Update the output grid with the results of the flood fill for this seed color. Pixels changed by the fill retain their new color and cannot be overwritten by subsequent fills from different seed colors.
    5.  Return the final output grid.
```python
import numpy as np
from collections import deque

"""
Identifies non-gray, non-green "seed" pixels within the input grid.
Performs a flood fill operation starting from these seed pixels.
The fill color for a region is determined by the color of the seed pixel(s) initiating the fill for that region.
The fill propagates into adjacent (including diagonal) gray pixels.
Green pixels act as barriers, stopping the fill.
The original seed pixels and green barrier pixels remain unchanged.
Gray pixels not reachable by any fill also remain unchanged.
If multiple fills could reach the same gray pixel, the first one to reach it claims it (implicit in BFS).
"""

def transform(input_grid):
    """
    Fills gray areas adjacent to colored 'seed' pixels, bounded by green barriers.

    Args:
        input_grid (np.array): The input 2D grid.

    Returns:
        np.array: The transformed 2D grid.
    """
    # Define colors
    GRAY = 8
    GREEN = 3

    # Initialize output grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Keep track of visited cells during the fill process to avoid re-processing
    # and to handle cases where fills might compete. 
    # 0 = not visited, 1 = visited/part of a fill
    visited = np.zeros_like(input_grid, dtype=int) 

    # Use a queue for Breadth-First Search (BFS) based flood fill
    # Store tuples of (row, col, fill_color)
    queue = deque()

    # Identify initial seed pixels and add them to the queue
    # Mark seed pixels and green barriers as 'visited' initially so they aren't overwritten
    for r in range(height):
        for c in range(width):
            color = input_grid[r, c]
            if color != GRAY and color != GREEN:
                # This is a seed pixel
                queue.append((r, c, color))
                visited[r, c] = 1 # Mark seed as visited
            elif color == GREEN:
                visited[r, c] = 1 # Mark green barriers as visited

    # Define 8-directional neighbors (including diagonals)
    neighbors = [(-1, -1), (-1, 0), (-1, 1),
                 ( 0, -1),          ( 0, 1),
                 ( 1, -1), ( 1, 0), ( 1, 1)]

    # Perform the flood fill using BFS
    while queue:
        r, c, fill_color = queue.popleft()

        # Explore neighbors
        for dr, dc in neighbors:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor is a gray pixel and hasn't been visited yet
                if input_grid[nr, nc] == GRAY and visited[nr, nc] == 0:
                    # Fill the neighbor with the current fill_color
                    output_grid[nr, nc] = fill_color
                    # Mark as visited
                    visited[nr, nc] = 1
                    # Add the neighbor to the queue to continue the fill from there
                    queue.append((nr, nc, fill_color))
                # Note: We don't need an explicit check for GREEN barriers here,
                # because green cells were marked as visited==1 initially,
                # so the `visited[nr, nc] == 0` condition prevents filling them
                # or propagating fill through them. Other non-GRAY colors
                # (seeds) were also marked visited==1.

    return output_grid
```
```python
"""
Perform a multi-source flood fill on a grid. 
Identifies non-gray (8), non-green (3) "seed" pixels. 
Starting simultaneously from all seed pixels, fills adjacent (8-way connectivity) 
gray (8) pixels with the color of the originating seed. 
Green (3) pixels act as barriers, stopping the fill. 
Original seed and green pixels remain unchanged in the output.
Gray pixels not reachable by any fill also remain unchanged.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Fills gray areas adjacent to colored 'seed' pixels, bounded by green barriers,
    using a multi-source Breadth-First Search (BFS) flood fill.

    Args:
        input_grid (np.array): The input 2D grid represented as a NumPy array.

    Returns:
        np.array: The transformed 2D grid.
    """
    # Define color constants
    GRAY = 8
    GREEN = 3

    # Initialize output grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Keep track of visited cells during the fill process.
    # 0 = not visited/fillable gray, 1 = visited/barrier/seed
    visited = np.zeros_like(input_grid, dtype=int)

    # Use a queue for Breadth-First Search (BFS) based flood fill
    # Store tuples of (row, col, fill_color)
    queue = deque()

    # 1. Identify initial seed pixels and barrier pixels.
    #    Add seeds to the queue and mark seeds and barriers as visited.
    for r in range(height):
        for c in range(width):
            color = input_grid[r, c]
            if color == GREEN:
                # Mark green barriers as visited (impassable)
                visited[r, c] = 1
            elif color != GRAY: # Seed pixel (not gray and already checked not green)
                # Add seed pixel to the queue with its color as the fill color
                queue.append((r, c, color))
                # Mark seed as visited (should not be overwritten)
                visited[r, c] = 1
            # Gray pixels remain visited = 0 initially

    # Define 8-directional neighbors (including diagonals)
    neighbors = [(-1, -1), (-1, 0), (-1, 1),
                 ( 0, -1),          ( 0, 1),
                 ( 1, -1), ( 1, 0), ( 1, 1)]

    # 2. Perform the multi-source flood fill using BFS
    while queue:
        # Dequeue the next pixel to process
        r, c, fill_color = queue.popleft()

        # Explore neighbors
        for dr, dc in neighbors:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within grid bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor is:
                # a) Originally gray in the input grid
                # b) Has not been visited yet (i.e., not a barrier, not a seed, and not already filled)
                if input_grid[nr, nc] == GRAY and visited[nr, nc] == 0:
                    # Fill the neighbor in the output grid with the fill_color
                    output_grid[nr, nc] = fill_color
                    # Mark the neighbor as visited
                    visited[nr, nc] = 1
                    # Add the neighbor to the queue to continue the fill from there
                    # Crucially, propagate the same fill_color
                    queue.append((nr, nc, fill_color))

    # 3. Return the modified grid
    return output_grid
```
```python
import numpy as np
from collections import deque

"""
Transformation Rule: Boundary Projection

1. Identify "seed" pixels: non-gray (8) and non-green (3) pixels in the input.
2. Identify green (3) pixels, which act as boundary interfaces.
3. For each seed pixel, find adjacent green pixels (8-way connectivity).
4. For each pair of seed pixel (sr, sc) with color C and adjacent green pixel (gr, gc):
   a. Determine the projection direction (dr, dc) = (gr - sr, gc - sc).
   b. Define the ray starting position (start_r, start_c) = (gr + dr, gc + dc).
   c. Cast a ray from (start_r, start_c) in the direction (dr, dc).
5. Ray Casting Logic:
   a. Starting from (r, c) = (start_r, start_c), proceed in steps of (dr, dc).
   b. At each step (r, c):
      i. If (r, c) is outside the grid, stop the ray.
      ii. If the pixel input_grid[r, c] is green (3), stop the ray.
      iii. If the pixel input_grid[r, c] is gray (8), change output_grid[r, c] to the seed color C.
      iv. If the pixel input_grid[r, c] is non-gray and non-green, stop the ray.
      v. Continue to the next step: (r + dr, c + dc).
6. The final output grid contains the original non-gray pixels and the gray pixels colored by the rays. If multiple rays color the same gray pixel, the outcome depends on the order of processing, but the examples suggest a consistent result, implying either non-overlapping projections or a deterministic overwrite rule (e.g., based on proximity or seed color value - although the latter seems unlikely). This implementation assumes overwriting is acceptable, processed ray by ray.
"""

def transform(input_grid):
    """
    Projects colors from seed pixels outwards from adjacent green boundary pixels.

    Args:
        input_grid (np.array): The input 2D grid.

    Returns:
        np.array: The transformed 2D grid.
    """
    # Constants
    GRAY = 8
    GREEN = 3
    height, width = input_grid.shape

    # Initialize output grid as a copy of the input
    output_grid = np.copy(input_grid)

    # Define 8 directions for adjacency checks and ray casting
    directions = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Store unique rays to cast: set of (start_r, start_c, dr, dc, color)
    rays_to_cast = set()

    # Step 1 & 2: Identify seed pixels and find adjacent green boundaries
    for r in range(height):
        for c in range(width):
            seed_color = input_grid[r, c]
            # Check if it's a seed pixel
            if seed_color != GRAY and seed_color != GREEN:
                # Step 3: Check neighbors for green pixels
                for dr_adj, dc_adj in directions:
                    nr, nc = r + dr_adj, c + dc_adj
                    # Check bounds and if neighbor is green
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr, nc] == GREEN:
                        # Found an adjacent green boundary pixel (nr, nc)
                        # Step 4a: Determine projection direction
                        proj_dr, proj_dc = dr_adj, dc_adj # Direction is from seed to green
                        # Step 4b: Define ray starting position (first pixel beyond green)
                        start_r, start_c = nr + proj_dr, nc + proj_dc
                        # Add ray details to the set (ensures uniqueness)
                        rays_to_cast.add((start_r, start_c, proj_dr, proj_dc, seed_color))

    # Step 5 & 6: Cast all unique rays
    for start_r, start_c, dr, dc, color in rays_to_cast:
        curr_r, curr_c = start_r, start_c
        # Keep casting while within bounds
        while 0 <= curr_r < height and 0 <= curr_c < width:
            # Check the color of the pixel in the *original* grid
            pixel_in_input = input_grid[curr_r, curr_c]

            if pixel_in_input == GREEN:
                # Stop ray if it hits a green barrier
                break
            elif pixel_in_input == GRAY:
                # Color the gray pixel in the output grid
                output_grid[curr_r, curr_c] = color
            else: # Hit another non-gray, non-green color
                 # Stop the ray (as specified by examples like Ex1 where rays stop)
                 # Alternative: could continue if output[curr_r, curr_c] is gray
                 # but let's stick to stopping based on input content first.
                 break # Stop ray if it hits any non-GRAY, non-GREEN pixel in the input

            # Move to the next pixel along the ray
            curr_r += dr
            curr_c += dc

    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Transformation Rule: Boundary Projection

1. Identify "seed" pixels: non-gray (8) and non-green (3) pixels in the input.
2. Identify green (3) pixels, which act as boundary interfaces.
3. For each seed pixel, find adjacent green pixels (8-way connectivity).
4. For each pair of seed pixel (sr, sc) with color C and adjacent green pixel (gr, gc):
   a. Determine the projection direction (dr, dc) = (gr - sr, gc - sc).
   b. Define the ray starting position (start_r, start_c) = (gr + dr, gc + dc).
   c. Cast a ray from (start_r, start_c) in the direction (dr, dc).
5. Ray Casting Logic:
   a. Starting from (r, c) = (start_r, start_c), proceed in steps of (dr, dc).
   b. At each step (r, c):
      i. If (r, c) is outside the grid, stop the ray.
      ii. If the pixel input_grid[r, c] is green (3), stop the ray.
      iii. If the pixel input_grid[r, c] is gray (8), change output_grid[r, c] to the seed color C.
      iv. If the pixel input_grid[r, c] is non-gray and non-green, stop the ray.
      v. Continue to the next step: (r + dr, c + dc).
6. The final output grid contains the original non-gray pixels and the gray pixels colored by the rays. If multiple rays color the same gray pixel, the outcome depends on the order of processing, but the examples suggest a consistent result, implying either non-overlapping projections or a deterministic overwrite rule (e.g., based on proximity or seed color value - although the latter seems unlikely). This implementation assumes overwriting is acceptable, processed ray by ray.
"""

def transform(input_grid):
    """
    Projects colors from seed pixels outwards from adjacent green boundary pixels.

    Args:
        input_grid (np.array): The input 2D grid.

    Returns:
        np.array: The transformed 2D grid.
    """
    # Constants
    GRAY = 8
    GREEN = 3
    height, width = input_grid.shape

    # Initialize output grid as a copy of the input
    output_grid = np.copy(input_grid)

    # Define 8 directions for adjacency checks and ray casting
    directions = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Store unique rays to cast: set of (start_r, start_c, dr, dc, color)
    rays_to_cast = set()

    # Step 1 & 2: Identify seed pixels and find adjacent green boundaries
    for r in range(height):
        for c in range(width):
            seed_color = input_grid[r, c]
            # Check if it's a seed pixel
            if seed_color != GRAY and seed_color != GREEN:
                # Step 3: Check neighbors for green pixels
                for dr_adj, dc_adj in directions:
                    nr, nc = r + dr_adj, c + dc_adj
                    # Check bounds and if neighbor is green
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr, nc] == GREEN:
                        # Found an adjacent green boundary pixel (nr, nc)
                        # Step 4a: Determine projection direction
                        proj_dr, proj_dc = dr_adj, dc_adj # Direction is from seed to green
                        # Step 4b: Define ray starting position (first pixel beyond green)
                        start_r, start_c = nr + proj_dr, nc + proj_dc
                        # Add ray details to the set (ensures uniqueness)
                        rays_to_cast.add((start_r, start_c, proj_dr, proj_dc, seed_color))

    # Step 5 & 6: Cast all unique rays
    for start_r, start_c, dr, dc, color in rays_to_cast:
        curr_r, curr_c = start_r, start_c
        # Keep casting while within bounds
        while 0 <= curr_r < height and 0 <= curr_c < width:
            # Check the color of the pixel in the *original* grid
            pixel_in_input = input_grid[curr_r, curr_c]

            if pixel_in_input == GREEN:
                # Stop ray if it hits a green barrier
                break
            elif pixel_in_input == GRAY:
                # Color the gray pixel in the output grid
                output_grid[curr_r, curr_c] = color
            else: # Hit another non-gray, non-green color
                 # Stop the ray (as specified by examples like Ex1 where rays stop)
                 # Alternative: could continue if output[curr_r, curr_c] is gray
                 # but let's stick to stopping based on input content first.
                 break # Stop ray if it hits any non-GRAY, non-GREEN pixel in the input

            # Move to the next pixel along the ray
            curr_r += dr
            curr_c += dc

    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
```
Transformed Output:
```
8 1 6 1 9 9 8 4 4 8 8 8 1 1 9 8 9 8 8 4 8 8 1 8
8 8 6 8 9 9 8 8 4 4 8 8 1 1 8 9 8 8 8 4 8 1 8 1
8 8 6 1 9 9 8 8 8 4 4 8 9 1 9 8 8 8 8 4 1 8 1 8
8 8 6 8 9 9 1 8 8 8 4 9 1 9 8 8 8 8 8 1 8 1 8 8
8 8 6 8 9 9 8 1 8 8 9 4 9 1 8 8 8 8 1 4 1 8 8 8
9 8 6 8 9 9 1 8 1 9 8 9 4 1 8 8 8 1 8 4 8 8 8 4
8 9 6 8 9 9 8 1 9 1 9 8 1 4 4 8 1 8 1 4 8 8 4 4
9 8 6 8 9 9 8 9 1 9 1 8 1 1 4 1 8 1 8 4 8 4 4 4
8 9 6 9 9 9 9 8 9 1 8 1 1 1 1 4 4 8 8 4 4 4 4 8
8 8 6 8 3 3 8 9 8 8 1 8 3 3 8 1 4 3 8 3 3 4 8 8
9 9 6 3 9 9 3 1 1 1 1 3 1 1 3 1 1 3 4 4 3 4 4 4
9 9 6 3 9 9 3 1 1 1 1 3 1 1 3 4 4 3 4 4 3 4 4 4
8 8 6 6 3 3 8 9 8 8 1 6 3 3 8 1 4 3 8 3 3 4 8 8
8 9 6 6 9 9 9 8 9 1 6 1 1 1 1 4 4 8 8 4 4 4 4 8
9 8 6 6 9 9 8 9 1 6 1 8 1 1 4 4 8 1 8 4 8 4 4 4
8 9 6 6 9 9 8 1 6 1 9 8 1 4 4 8 1 8 1 4 8 8 4 4
9 8 6 6 9 9 1 6 1 9 8 9 4 4 8 8 8 1 8 4 8 8 8 4
6 8 6 6 9 9 6 1 8 8 9 4 4 1 8 8 8 8 1 4 1 8 8 8
6 6 6 6 9 6 1 8 8 8 4 4 1 9 8 8 8 8 8 1 8 1 8 8
6 3 3 3 3 1 8 8 8 4 4 8 1 1 9 8 8 8 8 4 1 8 1 8
6 3 6 6 1 9 8 8 4 4 8 8 1 9 8 9 8 8 8 4 8 1 8 1
6 3 6 6 3 9 6 4 4 6 6 6 1 1 9 6 9 6 6 4 6 6 1 6
6 3 3 3 3 6 4 4 8 8 8 8 1 1 8 9 8 9 8 4 8 8 8 1
6 6 6 6 6 4 4 8 8 8 8 8 1 1 8 8 9 8 9 4 8 8 8 8
```
Match: False
Pixels Off: 359
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 124.65277777777779

## Example 2:
Input:
```
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
8 3 3 8 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 8 8 8 8
8 8 3 3 3 8 8 8
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 4 8 8 8 8
8 8 8 4 8 8 8 8
8 3 3 4 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 4 4 4 4
8 4 3 3 3 8 8 8
4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
```
Transformed Output:
```
4 8 4 8 8 8 4 4
4 4 4 8 8 4 4 8
4 3 3 8 3 4 8 8
4 3 4 4 3 4 4 4
4 3 4 4 8 8 8 8
4 8 3 3 3 8 8 8
8 4 4 4 4 4 8 8
4 8 4 4 8 4 4 8
```
Match: False
Pixels Off: 36
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 112.5

## Example 3:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 4 8 2 2 8 7 8 8 2 2 4 8 8 8 8 8 8 8
2 8 8 4 2 2 8 7 8 2 2 8 4 8 8 8 8 8 8 8
2 2 8 8 4 2 8 7 2 2 8 8 4 8 8 8 8 8 8 8
2 2 2 8 2 2 8 2 2 8 8 8 4 8 8 8 8 8 8 8
8 2 2 2 2 2 2 2 8 8 8 8 4 8 8 8 8 8 8 8
8 8 2 3 3 3 3 4 8 8 8 8 4 8 8 8 8 8 8 4
2 2 2 3 2 2 8 7 4 8 8 8 4 8 8 8 8 8 4 4
8 8 8 8 2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 3 3 3 3 2 8 4 4 8 4 8 8 8 4 4 8 8
8 8 2 2 2 2 7 2 2 8 4 4 4 8 8 4 4 8 8 8
8 2 2 8 2 2 7 2 2 2 8 3 3 8 3 4 8 8 8 8
2 2 8 8 2 2 7 7 2 2 2 8 4 4 3 4 4 4 4 4
2 4 4 4 2 4 4 4 4 4 2 3 4 4 3 4 4 4 4 4
8 7 7 8 2 2 7 7 8 8 4 3 3 3 8 4 8 8 8 8
8 8 7 7 2 2 7 7 8 4 4 4 4 4 4 8 4 8 8 8
8 8 8 7 2 2 7 7 4 4 4 7 4 4 8 4 8 4 8 8
8 8 8 8 2 2 7 4 4 4 7 8 4 4 8 8 4 8 4 8
8 8 8 8 2 3 3 3 3 7 8 8 4 4 2 8 8 4 8 4
8 8 8 8 2 8 7 7 3 7 7 7 4 4 7 7 7 7 4 7
7 7 7 7 2 3 7 7 3 7 7 7 7 4 7 7 7 7 7 4
```
Match: False
Pixels Off: 232
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 116.0

## Example 4:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 3 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 6 8 8 8 6 8 8 8 8 8
8 8 6 8 8 6 8 8 8 8 8 8
8 3 6 3 6 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 6 3 3 3 8 8 8 8 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 6 8 6 8 6 8 8 8 8
6 8 8 6 6 8 6 8 8 8 8 8
6 3 8 3 8 6 8 8 8 8 8 8
6 3 6 6 3 6 6 6 6 6 6 6
6 3 6 6 3 6 6 6 6 6 6 6
6 8 3 3 3 6 8 8 8 8 8 8
8 6 6 6 6 6 6 8 8 8 8 8
6 8 6 6 8 6 6 6 8 8 8 8
8 8 6 6 8 8 6 6 6 8 8 8
8 8 6 6 8 8 8 6 6 6 8 8
8 8 6 6 8 8 8 8 6 6 6 8
8 8 6 6 8 8 8 8 8 6 6 6
```
Match: False
Pixels Off: 67
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 93.05555555555556
*   **General Assessment:** The initial 'Boundary Projection' hypothesis and corresponding code failed significantly on all training examples. The generated outputs bear little resemblance to the expected outputs, indicating a fundamental misunderstanding of the transformation rule. The large number of pixels off and the incorrect color counts confirm this. The flood-fill concept, initially described but then replaced by ray-casting, appears much more likely given the results. The fill seems to originate *from* the non-gray, non-green colors ('seeds') and spread *into* adjacent gray areas, respecting the green boundaries. The ray-casting approach incorrectly tied the fill direction to the boundary itself. The strategy is to revert to and refine the flood-fill hypothesis, ensuring correct handling of barriers, connectivity, and stopping conditions.

*   **Metrics Gathering:**
    

*code_execution:*
```python
    import numpy as np

    def analyze_example(input_grid_str, output_grid_str):
        input_grid = np.array([[int(x) for x in row.split()] for row in input_grid_str.strip().split('\n')])
        output_grid = np.array([[int(x) for x in row.split()] for row in output_grid_str.strip().split('\n')])

        input_shape = input_grid.shape
        output_shape = output_grid.shape

        input_colors = set(input_grid.flatten())
        output_colors = set(output_grid.flatten())

        seed_colors = sorted([c for c in input_colors if c not in [3, 8]]) # Green=3, Gray=8
        output_fill_colors = sorted([c for c in output_colors if c not in [3, 8]])

        green_coords_in = set(map(tuple, np.argwhere(input_grid == 3)))
        green_coords_out = set(map(tuple, np.argwhere(output_grid == 3)))
        green_preserved = green_coords_in == green_coords_out

        seed_pixels_preserved = True
        original_seeds = {}
        for r in range(input_shape[0]):
            for c in range(input_shape[1]):
                 val = input_grid[r,c]
                 if val not in [3, 8]:
                     original_seeds[(r,c)] = val
                     if output_grid[r,c] != val:
                         seed_pixels_preserved = False
                         # break # Can stop checking once one mismatch is found

        return {
            "input_shape": input_shape,
            "output_shape": output_shape,
            "input_colors": sorted(list(input_colors)),
            "output_colors": sorted(list(output_colors)),
            "seed_colors (non-gray, non-green input)": seed_colors,
            "fill_colors (non-gray, non-green output)": output_fill_colors,
            "shapes_match": input_shape == output_shape,
            "green_pixels_preserved": green_preserved,
            "seed_pixels_preserved": seed_pixels_preserved,
        }

    # Example 1 Data
    input_1 = """
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
    8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
    8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
    8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    """
    output_1 = """
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
    9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
    8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
    8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
    8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
    8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
    8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
    8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
    8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
    8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
    9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
    8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
    8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
    8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
    8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
    8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
    8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
    """

    # Example 2 Data
    input_2 = """
    8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8
    8 3 3 8 3 8 8 8
    8 3 4 4 3 8 8 8
    8 3 4 4 8 8 8 8
    8 8 3 3 3 8 8 8
    8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8
    """
    output_2 = """
    8 8 8 4 8 8 8 8
    8 8 8 4 8 8 8 8
    8 3 3 4 3 8 8 8
    8 3 4 4 3 8 8 8
    8 3 4 4 4 4 4 4
    8 4 3 3 3 8 8 8
    4 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8
    """

    # Example 3 Data
    input_3 = """
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
    """
    output_3 = """
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
    8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
    8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
    2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
    8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
    4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
    7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
    """

    # Example 4 Data
    input_4 = """
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 3 8 3 8 8 8 8 8 8 8 8
    8 3 6 6 3 8 8 8 8 8 8 8
    8 3 6 6 3 8 8 8 8 8 8 8
    8 8 3 3 3 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    """
    output_4 = """
    8 8 6 8 8 8 6 8 8 8 8 8
    8 8 6 8 8 6 8 8 8 8 8 8
    8 3 6 3 6 8 8 8 8 8 8 8
    8 3 6 6 3 8 8 8 8 8 8 8
    8 3 6 6 3 8 8 8 8 8 8 8
    8 6 3 3 3 8 8 8 8 8 8 8
    6 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    8 8 8 8 8 8 8 8 8 8 8 8
    """

    results = {
        "example_1": analyze_example(input_1, output_1),
        "example_2": analyze_example(input_2, output_2),
        "example_3": analyze_example(input_3, output_3),
        "example_4": analyze_example(input_4, output_4),
    }

    import json
    print(json.dumps(results, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_FAILED
```
Traceback (most recent call last):
  File "<string>", line 203, in <module>
  File "__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "encoder.py", line 202, in encode
    chunks = list(chunks)
             ^^^^^^^^^^^^
  File "encoder.py", line 432, in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 326, in _iterencode_list
    yield from chunks
  File "encoder.py", line 439, in _iterencode
    o = _default(o)
        ^^^^^^^^^^^
  File "encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type int64 is not JSON serializable

```
It seems the previous code execution failed because NumPy integer types (`int64`) are not directly serializable to JSON. Let's correct that and gather the metrics again.



*code_execution:*
```python
import numpy as np
import json

# Helper function to convert numpy types to standard python types for JSON serialization
def convert_numpy_types(obj):
    if isinstance(obj, (np.int_, np.intc, np.intp, np.int8,
                        np.int16, np.int32, np.int64, np.uint8,
                        np.uint16, np.uint32, np.uint64)):
        return int(obj)
    elif isinstance(obj, (np.float_, np.float16, np.float32, np.float64)):
        return float(obj)
    elif isinstance(obj, (np.ndarray,)): # if obj is an array
        return obj.tolist() # Convert arrays to lists
    elif isinstance(obj, dict):
        return {k: convert_numpy_types(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_numpy_types(i) for i in obj]
    elif isinstance(obj, tuple):
         return tuple(convert_numpy_types(list(obj)))
    elif isinstance(obj, set):
        return set(convert_numpy_types(list(obj)))
    return obj


def analyze_example(input_grid_str, output_grid_str):
    input_grid = np.array([[int(x) for x in row.split()] for row in input_grid_str.strip().split('\n')])
    output_grid = np.array([[int(x) for x in row.split()] for row in output_grid_str.strip().split('\n')])

    input_shape = input_grid.shape
    output_shape = output_grid.shape

    input_colors = set(input_grid.flatten())
    output_colors = set(output_grid.flatten())

    seed_colors = sorted([c for c in input_colors if c not in [3, 8]]) # Green=3, Gray=8
    output_fill_colors = sorted([c for c in output_colors if c not in [3, 8]])

    green_coords_in = set(map(tuple, np.argwhere(input_grid == 3)))
    green_coords_out = set(map(tuple, np.argwhere(output_grid == 3)))
    green_preserved = green_coords_in == green_coords_out

    seed_pixels_preserved = True
    original_seeds = {}
    for r in range(input_shape[0]):
        for c in range(input_shape[1]):
             val = input_grid[r,c]
             if val not in [3, 8]:
                 original_seeds[(r,c)] = val
                 if output_grid[r,c] != val:
                     seed_pixels_preserved = False
                     # break # Can stop checking once one mismatch is found

    analysis = {
        "input_shape": input_shape,
        "output_shape": output_shape,
        "input_colors": sorted(list(input_colors)),
        "output_colors": sorted(list(output_colors)),
        "seed_colors (non-gray, non-green input)": seed_colors,
        "fill_colors (non-gray, non-green output)": output_fill_colors,
        "shapes_match": input_shape == output_shape,
        "green_pixels_preserved": green_preserved,
        "seed_pixels_preserved": seed_pixels_preserved,
    }
    # Convert numpy types before returning
    return convert_numpy_types(analysis)

# Example 1 Data
input_1 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
"""
output_1 = """
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
"""

# Example 2 Data
input_2 = """
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
8 3 3 8 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 8 8 8 8
8 8 3 3 3 8 8 8
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
"""
output_2 = """
8 8 8 4 8 8 8 8
8 8 8 4 8 8 8 8
8 3 3 4 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 4 4 4 4
8 4 3 3 3 8 8 8
4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
"""

# Example 3 Data
input_3 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
"""
output_3 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
"""

# Example 4 Data
input_4 = """
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 3 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
"""
output_4 = """
8 8 6 8 8 8 6 8 8 8 8 8
8 8 6 8 8 6 8 8 8 8 8 8
8 3 6 3 6 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 6 3 3 3 8 8 8 8 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
"""

results = {
    "example_1": analyze_example(input_1, output_1),
    "example_2": analyze_example(input_2, output_2),
    "example_3": analyze_example(input_3, output_3),
    "example_4": analyze_example(input_4, output_4),
}

print(json.dumps(results, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_FAILED
```
Traceback (most recent call last):
  File "<string>", line 220, in <module>
  File "<string>", line 65, in analyze_example
  File "<string>", line 10, in convert_numpy_types
  File "__init__.py", line 400, in __getattr__
    raise AttributeError(
AttributeError: `np.float_` was removed in the NumPy 2.0 release. Use `np.float64` instead.

```
Okay, it seems there was another type compatibility issue with newer NumPy versions (`np.float_` vs `np.float64`). Let's fix the helper function and try gathering metrics one more time.



*code_execution:*
```python
import numpy as np
import json

# Helper function to convert numpy types to standard python types for JSON serialization
def convert_numpy_types(obj):
    if isinstance(obj, (np.int_, np.intc, np.intp, np.int8,
                        np.int16, np.int32, np.int64, np.uint8,
                        np.uint16, np.uint32, np.uint64)):
        return int(obj)
    elif isinstance(obj, (np.float16, np.float32, np.float64)): # Use np.float64
        return float(obj)
    elif isinstance(obj, (np.ndarray,)): # if obj is an array
        return obj.tolist() # Convert arrays to lists
    elif isinstance(obj, dict):
        return {k: convert_numpy_types(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_numpy_types(i) for i in obj]
    elif isinstance(obj, tuple):
         return tuple(convert_numpy_types(list(obj)))
    elif isinstance(obj, set):
        return set(convert_numpy_types(list(obj)))
    return obj


def analyze_example(input_grid_str, output_grid_str):
    input_grid = np.array([[int(x) for x in row.split()] for row in input_grid_str.strip().split('\n')])
    output_grid = np.array([[int(x) for x in row.split()] for row in output_grid_str.strip().split('\n')])

    input_shape = input_grid.shape
    output_shape = output_grid.shape

    input_colors = set(input_grid.flatten())
    output_colors = set(output_grid.flatten())

    seed_colors = sorted([c for c in input_colors if c not in [3, 8]]) # Green=3, Gray=8
    output_fill_colors = sorted([c for c in output_colors if c not in [3, 8]])

    green_coords_in = set(map(tuple, np.argwhere(input_grid == 3)))
    green_coords_out = set(map(tuple, np.argwhere(output_grid == 3)))
    green_preserved = green_coords_in == green_coords_out

    seed_pixels_preserved = True
    original_seeds = {}
    for r in range(input_shape[0]):
        for c in range(input_shape[1]):
             val = input_grid[r,c]
             if val not in [3, 8]:
                 original_seeds[(r,c)] = val
                 # Check if the output grid at this location still holds the original seed color
                 if output_grid[r,c] != val:
                     seed_pixels_preserved = False
                     # break # Can stop checking once one mismatch is found

    analysis = {
        "input_shape": input_shape,
        "output_shape": output_shape,
        "input_colors": sorted(list(input_colors)),
        "output_colors": sorted(list(output_colors)),
        "seed_colors (non-gray, non-green input)": seed_colors,
        "fill_colors (non-gray, non-green output)": output_fill_colors,
        "shapes_match": input_shape == output_shape,
        "green_pixels_preserved": green_preserved,
        "seed_pixels_preserved": seed_pixels_preserved,
    }
    # Convert numpy types before returning
    return convert_numpy_types(analysis)

# Example 1 Data
input_1 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 3 3 8 8 8 3 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
"""
output_1 = """
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 3 9 9 3 8 8 8 8 3 1 1 3 8 8 3 4 4 3 8 8 8
8 8 8 9 3 3 9 8 8 8 8 1 3 3 1 8 8 3 4 3 3 8 8 8
8 8 9 8 8 8 8 9 8 8 1 8 8 8 8 1 8 8 4 8 8 8 8 8
8 9 8 8 8 8 8 8 9 1 8 8 8 8 8 8 1 8 4 8 8 8 8 8
9 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 1 4 8 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 8 8 8 8 8 8 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8 8
8 3 3 3 3 8 8 8 9 1 8 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 6 6 6 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8 8
8 3 6 6 3 8 8 8 6 8 9 1 8 8 8 8 8 8 8 8 1 4 8 8
8 3 3 3 3 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8 8
8 8 8 8 8 8 8 8 8 8 6 8 9 1 8 8 8 8 8 8 8 1 4 8
"""

# Example 2 Data
input_2 = """
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
8 3 3 8 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 8 8 8 8
8 8 3 3 3 8 8 8
8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
"""
output_2 = """
8 8 8 4 8 8 8 8
8 8 8 4 8 8 8 8
8 3 3 4 3 8 8 8
8 3 4 4 3 8 8 8
8 3 4 4 4 4 4 4
8 4 3 3 3 8 8 8
4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8
"""

# Example 3 Data
input_3 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
"""
output_3 = """
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 4 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 2 8 4 8 8 8 8
8 8 8 3 2 2 2 2 2 2 2 2 2 8 4 8 8 8 8 8
2 2 2 2 2 2 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 3 3 3 3 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 4 3 8 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 4 4 3 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 7 7 3 8 8 8 8 8 8 8 8 8 8 8
"""

# Example 4 Data
input_4 = """
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 3 8 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
"""
output_4 = """
8 8 6 8 8 8 6 8 8 8 8 8
8 8 6 8 8 6 8 8 8 8 8 8
8 3 6 3 6 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 3 6 6 3 8 8 8 8 8 8 8
8 6 3 3 3 8 8 8 8 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
"""

results = {
    "example_1": analyze_example(input_1, output_1),
    "example_2": analyze_example(input_2, output_2),
    "example_3": analyze_example(input_3, output_3),
    "example_4": analyze_example(input_4, output_4),
}

print(json.dumps(results, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{
  "example_1": {
    "input_shape": [
      24,
      24
    ],
    "output_shape": [
      24,
      24
    ],
    "input_colors": [
      1,
      3,
      4,
      6,
      8,
      9
    ],
    "output_colors": [
      1,
      3,
      4,
      6,
      8,
      9
    ],
    "seed_colors (non-gray, non-green input)": [
      1,
      4,
      6,
      9
    ],
    "fill_colors (non-gray, non-green output)": [
      1,
      4,
      6,
      9
    ],
    "shapes_match": true,
    "green_pixels_preserved": true,
    "seed_pixels_preserved": true
  },
  "example_2": {
    "input_shape": [
      8,
      8
    ],
    "output_shape": [
      8,
      8
    ],
    "input_colors": [
      3,
      4,
      8
    ],
    "output_colors": [
      3,
      4,
      8
    ],
    "seed_colors (non-gray, non-green input)": [
      4
    ],
    "fill_colors (non-gray, non-green output)": [
      4
    ],
    "shapes_match": true,
    "green_pixels_preserved": true,
    "seed_pixels_preserved": true
  },
  "example_3": {
    "input_shape": [
      20,
      20
    ],
    "output_shape": [
      20,
      20
    ],
    "input_colors": [
      2,
      3,
      4,
      7,
      8
    ],
    "output_colors": [
      2,
      3,
      4,
      7,
      8
    ],
    "seed_colors (non-gray, non-green input)": [
      2,
      4,
      7
    ],
    "fill_colors (non-gray, non-green output)": [
      2,
      4,
      7
    ],
    "shapes_match": true,
    "green_pixels_preserved": true,
    "seed_pixels_preserved": true
  },
  "example_4": {
    "input_shape": [
      12,
      12
    ],
    "output_shape": [
      12,
      12
    ],
    "input_colors": [
      3,
      6,
      8
    ],
    "output_colors": [
      3,
      6,
      8
    ],
    "seed_colors (non-gray, non-green input)": [
      6
    ],
    "fill_colors (non-gray, non-green output)": [
      6
    ],
    "shapes_match": true,
    "green_pixels_preserved": true,
    "seed_pixels_preserved": true
  }
}

```
*   **YAML Facts:**


```yaml
task_description: "Perform a multi-source flood fill starting from 'seed' pixels."
constants:
  - GRAY: 8
  - GREEN: 3
elements:
  - type: background
    color: GRAY (8)
    description: "The default grid color, which is the target for filling."
  - type: barrier
    color: GREEN (3)
    description: "Impassable boundaries for the flood fill. Static."
    properties:
      - static: Position and color remain unchanged in the output.
      - blocks_fill: Fill cannot enter or cross these pixels.
  - type: seed
    description: "Pixels with colors other than GRAY (8) or GREEN (3)."
    properties:
      - static: Position and color remain unchanged in the output.
      - source_of_fill: Initiates a flood fill process.
      - fill_color_determiner: The color of the seed determines the color used for its corresponding fill.
  - type: fill_area
    description: "Regions of GRAY (8) pixels in the input that become colored in the output."
    properties:
      - initial_color: GRAY (8)
      - final_color: Determined by the color of the nearest seed pixel from which the fill originated.
      - connectivity: 8-way (adjacent and diagonal) to seed pixels or other filled pixels of the same color.
      - bounded: Fill expansion stops at GREEN barriers, grid edges, or any non-GRAY pixels.
actions:
  - type: identify_elements
    input: input_grid
    output: locations of background (GRAY), barrier (GREEN), and seed (all others) pixels.
  - type: multi_source_flood_fill
    input: input_grid, identified_elements
    parameters:
      - fill_target: GRAY (8)
      - barrier_color: GREEN (3)
      - connectivity: 8 (includes diagonals)
    output: modified_grid
    description: >
      Simultaneously start a flood fill from all seed pixels.
      Each fill uses the color of its starting seed pixel.
      The fill propagates into adjacent (8-way) GRAY pixels.
      The fill stops if it encounters a GREEN pixel, a non-GRAY pixel, or the grid boundary.
      If multiple fills could reach the same GRAY pixel, the first one (determined by BFS order) colors it.
output_generation:
  - step: Initialize output_grid as a copy of input_grid.
  - step: Identify all seed pixels (non-GRAY, non-GREEN).
  - step: Perform a multi-source Breadth-First Search (BFS) flood fill:
      a. Initialize a queue with all seed pixels, storing (row, col, seed_color).
      b. Initialize a 'visited' grid/set to track barriers, seeds, and already filled pixels. Mark all GREEN and seed pixels as visited initially.
      c. While the queue is not empty:
          i. Dequeue a pixel (r, c, fill_color).
          ii. For each 8-way neighbor (nr, nc):
             - If the neighbor is within bounds AND the input_grid[nr, nc] is GRAY AND the neighbor has not been visited:
                 - Set output_grid[nr, nc] = fill_color.
                 - Mark (nr, nc) as visited.
                 - Enqueue (nr, nc, fill_color).
  - step: Return the final output_grid.
```


*   **Natural Language Program:**

1.  Create an `output_grid` as a copy of the `input_grid`.
2.  Identify all "seed" pixels in the `input_grid`: these are any pixels that are *not* gray (8) and *not* green (3).
3.  Identify all "barrier" pixels: these are the green (3) pixels.
4.  Initialize a queue for a Breadth-First Search (BFS). Add all seed pixels to this queue, storing their location (row, column) and their color.
5.  Initialize a way to track visited locations (e.g., a 2D boolean array or a set of coordinates). Mark the locations of all barrier pixels and all initial seed pixels as already visited.
6.  While the queue is not empty:
    a.  Remove a location (row `r`, column `c`) and its associated `fill_color` from the front of the queue.
    b.  Examine all 8 neighbors (including diagonals) of the current location (`r`, `c`). Let a neighbor be (`nr`, `nc`).
    c.  For each neighbor (`nr`, `nc`):
        i.  Check if the neighbor is within the grid boundaries.
        ii. Check if the neighbor's color in the *original* `input_grid` is gray (8).
        iii. Check if the neighbor location (`nr`, `nc`) has *not* been visited yet.
        iv. If all three checks (bounds, input is gray, not visited) are true:
            1.  Change the color of the neighbor in the `output_grid` to the `fill_color`.
            2.  Mark the neighbor location (`nr`, `nc`) as visited.
            3.  Add the neighbor location (`nr`, `nc`) and the *same* `fill_color` to the back of the queue.
7.  Once the queue is empty, return the `output_grid`.
