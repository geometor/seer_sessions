{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the background color (most frequent color).\n2.  Identify the two unique non-background colors. One color forms a single contiguous 'pattern' object, and the other color appears as multiple single 'marker' pixels.\n3.  Find the coordinates of all marker pixels.\n4.  Find the coordinates of all pixels belonging to the pattern object.\n5.  Determine the 'center' of the pattern object (using the center of its bounding box).\n6.  Calculate the relative coordinates of each pattern pixel with respect to this center.\n7.  Create an output grid of the same dimensions as the input, filled with the background color.\n8.  For each marker pixel coordinate (anchor point):\n    a.  Iterate through the relative coordinates of the pattern pixels.\n    b.  Calculate the absolute target coordinate in the output grid by adding the anchor point coordinate to the relative pattern coordinate.\n    c.  If the target coordinate is within the grid bounds, place the corresponding pattern pixel color at that location in the output grid, overwriting the background color.\n9.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, color, connectivity=8):\n    \"\"\"Finds connected components (objects) of a specific color.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.append((row, col))\n\n                    # Define neighbors based on connectivity\n                    if connectivity == 8: # Queen's case (includes diagonals)\n                        potential_neighbors = [\n                            (row - 1, col - 1), (row - 1, col), (row - 1, col + 1),\n                            (row, col - 1),                 (row, col + 1),\n                            (row + 1, col - 1), (row + 1, col), (row + 1, col + 1)\n                        ]\n                    else: # Rook's case (only orthogonal)\n                         potential_neighbors = [\n                                     (row - 1, col),\n                            (row, col - 1),         (row, col + 1),\n                                     (row + 1, col)\n                         ]\n\n                    for nr, nc in potential_neighbors:\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef get_center(bbox):\n    \"\"\"Calculates the 'center' coordinate from a bounding box. Uses integer division.\"\"\"\n    if not bbox:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    # Using integer division, effectively floor((min+max)/2)\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    return center_r, center_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern stamping transformation.\n    Identifies a pattern object and marker pixels in the input grid.\n    Stamps the pattern onto an output grid centered at each marker location.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Determine background color\n    colors, counts = np.unique(input_np, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Identify non-background colors\n    non_background_colors = [c for c in colors if c != background_color]\n\n    if len(non_background_colors) != 2:\n        # This rule assumes exactly two non-background colors: one pattern, one marker\n        # Handle error or edge case if needed, maybe return input or raise error\n        print(f\"Warning: Expected 2 non-background colors, found {len(non_background_colors)}. Returning input.\")\n        return input_grid # Or handle differently\n\n    color1, color2 = non_background_colors\n\n    # 3 & 4. Identify pattern and marker colors/objects\n    objects1 = find_objects(input_np, color1)\n    objects2 = find_objects(input_np, color2)\n\n    pattern_color = -1\n    marker_color = -1\n    pattern_coords = []\n    marker_coords = []\n\n    # Assume pattern is the single larger object, markers are multiple single pixels\n    # Check color1\n    if len(objects1) == 1 and len(objects1[0]) > 1: # Single object, more than one pixel -> Pattern\n        pattern_color = color1\n        pattern_coords = objects1[0]\n        # Check if color2 consists of single-pixel objects -> Markers\n        if all(len(obj) == 1 for obj in objects2):\n            marker_color = color2\n            marker_coords = [obj[0] for obj in objects2]\n        else:\n             print(\"Warning: Ambiguous pattern/marker identification (Case 1).\")\n             return input_grid # Or handle differently\n\n    # Check color2 (if color1 wasn't the pattern)\n    elif len(objects2) == 1 and len(objects2[0]) > 1: # Single object, more than one pixel -> Pattern\n        pattern_color = color2\n        pattern_coords = objects2[0]\n         # Check if color1 consists of single-pixel objects -> Markers\n        if all(len(obj) == 1 for obj in objects1):\n            marker_color = color1\n            marker_coords = [obj[0] for obj in objects1]\n        else:\n            print(\"Warning: Ambiguous pattern/marker identification (Case 2).\")\n            return input_grid # Or handle differently\n    else:\n         # This handles cases like two single-pixel colors, or two multi-pixel objects etc.\n         # Based on examples, Markers seem to always be single pixels.\n         # Let's refine: Markers are *always* single pixels. Pattern is the other one.\n         is_obj1_markers = all(len(obj) == 1 for obj in objects1)\n         is_obj2_markers = all(len(obj) == 1 for obj in objects2)\n\n         if is_obj1_markers and not is_obj2_markers and len(objects2) == 1:\n             marker_color = color1\n             marker_coords = [obj[0] for obj in objects1]\n             pattern_color = color2\n             pattern_coords = objects2[0]\n         elif is_obj2_markers and not is_obj1_markers and len(objects1) == 1:\n             marker_color = color2\n             marker_coords = [obj[0] for obj in objects2]\n             pattern_color = color1\n             pattern_coords = objects1[0]\n         else:\n            print(\"Warning: Could not definitively identify pattern and marker colors based on object structure.\")\n            # Fallback: Let's check counts, maybe marker color is more frequent non-bg?\n            # Or maybe pattern color always has >1 pixel total?\n            count1 = np.sum(input_np == color1)\n            count2 = np.sum(input_np == color2)\n            if count1 > 1 and count2 > 0 and is_obj2_markers: # Assume color1 is pattern, color2 is marker\n                 pattern_color = color1\n                 pattern_coords = [(r,c) for r in range(rows) for c in range(cols) if input_np[r,c] == color1] # Recalculate coords if needed\n                 marker_color = color2\n                 marker_coords = [obj[0] for obj in objects2]\n            elif count2 > 1 and count1 > 0 and is_obj1_markers: # Assume color2 is pattern, color1 is marker\n                 pattern_color = color2\n                 pattern_coords = [(r,c) for r in range(rows) for c in range(cols) if input_np[r,c] == color2] # Recalculate coords if needed\n                 marker_color = color1\n                 marker_coords = [obj[0] for obj in objects1]\n            else:\n                print(\"Fallback failed.\")\n                return input_grid # Or handle differently\n\n\n    if not pattern_coords or not marker_coords:\n        print(\"Warning: Failed to find pattern or markers.\")\n        return input_grid # Or handle differently\n\n    # 5. Determine pattern center\n    pattern_bbox = get_bounding_box(pattern_coords)\n    pattern_center_r, pattern_center_c = get_center(pattern_bbox)\n\n    # 6. Calculate relative pattern coordinates\n    # Store as dictionary: {(dr, dc): color} - color is always pattern_color here\n    relative_pattern = {}\n    for r, c in pattern_coords:\n        dr = r - pattern_center_r\n        dc = c - pattern_center_c\n        relative_pattern[(dr, dc)] = pattern_color\n\n    # 7. Create output grid\n    output_np = np.full_like(input_np, background_color)\n\n    # 8. Stamp pattern for each marker\n    for anchor_r, anchor_c in marker_coords:\n        # 8a. Iterate through relative coordinates\n        for (dr, dc), p_color in relative_pattern.items():\n            # 8b. Calculate target coordinate\n            target_r = anchor_r + dr\n            target_c = anchor_c + dc\n\n            # 8c. Check bounds and place pixel\n            if 0 <= target_r < rows and 0 <= target_c < cols:\n                output_np[target_r, target_c] = p_color\n\n    # 9. Return the modified grid as list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7757,
    "candidates_token_count": 2534,
    "total_token_count": 10291,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.285445,
  "retries": 1
}