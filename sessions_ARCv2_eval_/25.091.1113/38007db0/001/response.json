{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Grid Structure:** The input grid is composed of smaller, equally-sized square subgrids arranged in a larger grid format. These subgrids are separated by single-pixel-thick lines of a uniform 'frame_color'.\n2.  **Extract Subgrids:** Determine the size of the subgrids and extract each subgrid from the input. Maintain their original row arrangement.\n3.  **Identify Unique Pattern per Row:** For each row of subgrids in the input:\n    a.  Compare all subgrids within that row.\n    b.  Count the occurrences of each distinct subgrid pattern.\n    c.  If one pattern appears exactly once in the row, select the subgrid containing that unique pattern.\n    d.  If all patterns in the row are identical (i.e., only one distinct pattern exists, repeated multiple times), select the first (leftmost) subgrid from that row.\n4.  **Construct Output:** Create an output grid with the same height as the input grid but with a width equal to the width of a single subgrid. Vertically stack the selected subgrids (one from each original row) into this output grid, preserving the vertical arrangement and spacing defined by the subgrid size.\n\"\"\"\n\ndef find_subgrid_size(grid):\n    \"\"\"\n    Determines the size of the subgrids by finding the second occurrence\n    of the frame color along the top row and first column.\n    Assumes the top-left pixel (0,0) is part of the frame.\n    \"\"\"\n    frame_color = grid[0, 0]\n    height, width = grid.shape\n\n    # Find horizontal size\n    h_size = -1\n    for c in range(1, width):\n        if grid[0, c] == frame_color:\n            h_size = c\n            break\n    \n    # Find vertical size (should be the same for square subgrids)\n    v_size = -1\n    for r in range(1, height):\n        if grid[r, 0] == frame_color:\n            v_size = r\n            break\n\n    # Basic check if sizes were found and match\n    if h_size == -1 or v_size == -1:\n        # Fallback or error: maybe only one subgrid row/column\n        if h_size != -1: return h_size\n        if v_size != -1: return v_size\n        # If neither works, assume full grid is the 'subgrid' (or handle error)\n        # Based on examples, we expect grid lines. If not found, maybe size is the full dimension?\n        # Let's assume grid lines are always present for multiple subgrids.\n        # If only one subgrid vertically, v_size will be height. If only one horizontally, h_size is width.\n        if h_size == -1 and v_size == -1: # Only one subgrid total\n             return max(height, width) # Or specific logic if needed\n        elif h_size == -1: # Only one column\n             h_size = width \n        elif v_size == -1: # Only one row\n             v_size = height\n\n    if h_size != v_size:\n         # This case shouldn't happen based on examples, but good to note\n         print(f\"Warning: Non-square subgrid structure detected? h_size={h_size}, v_size={v_size}\")\n         # Decide how to handle: maybe use the smaller, larger, or average? Or stick to h_size? Let's use h_size for now.\n\n    # We add 1 because the index `c` or `r` is the position *of* the second frame line.\n    # The size includes the pixels up to *before* that line. E.g., if line is at index 7, size is 7.\n    # Let's re-evaluate: if grid[0,0] is frame and grid[0,7] is the next frame pixel, \n    # the subgrid content spans columns 0 through 6, which is a size of 7. So h_size itself is correct.\n    # Similarly for v_size.\n    \n    # Correction: The logic seems to find the *start* of the next subgrid border.\n    # If grid[0,0] is border and grid[0,7] is the next border pixel, the first subgrid\n    # spans indices 0 to 6 horizontally. Size = 7. So the found index IS the size.\n    subgrid_dim = h_size # Assuming square based on examples\n    if subgrid_dim <= 0: # Handle cases where no second line was found\n        subgrid_dim = max(width, height) if width == height else -1 # Fallback for single block or error\n        if subgrid_dim == -1:\n             raise ValueError(\"Could not determine subgrid size reliably.\")\n             \n    return subgrid_dim\n\n\ndef extract_subgrids(grid, subgrid_size):\n    \"\"\"Extracts all subgrids into a list of lists.\"\"\"\n    height, width = grid.shape\n    num_rows = height // subgrid_size\n    num_cols = width // subgrid_size\n    \n    subgrids = []\n    for r in range(num_rows):\n        row_subgrids = []\n        for c in range(num_cols):\n            top = r * subgrid_size\n            left = c * subgrid_size\n            subgrid = grid[top : top + subgrid_size, left : left + subgrid_size]\n            row_subgrids.append(subgrid)\n        subgrids.append(row_subgrids)\n    return subgrids\n\ndef select_subgrid_for_row(subgrid_row):\n    \"\"\"Selects the unique or first subgrid from a list of subgrids.\"\"\"\n    # Convert numpy arrays to tuples for hashing\n    subgrid_tuples = [tuple(map(tuple, sg)) for sg in subgrid_row]\n    \n    # Count occurrences\n    counts = Counter(subgrid_tuples)\n    \n    # Find unique subgrid\n    unique_sg_tuple = None\n    for sg_tuple, count in counts.items():\n        if count == 1:\n            unique_sg_tuple = sg_tuple\n            break\n            \n    # If a unique one was found, find its original index to return the numpy array\n    if unique_sg_tuple is not None:\n        for i, sg_tuple in enumerate(subgrid_tuples):\n            if sg_tuple == unique_sg_tuple:\n                return subgrid_row[i]\n    else:\n        # If no unique one, return the first subgrid\n        return subgrid_row[0]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by selecting unique or first subgrids from each row\n    and stacking them vertically.\n    \"\"\"\n    input_np = np.array(input_grid)\n    height, width = input_np.shape\n\n    # 1. Identify Grid Structure - Determine subgrid size\n    try:\n        subgrid_size = find_subgrid_size(input_np)\n        if subgrid_size <= 0 or height % subgrid_size != 0 or width % subgrid_size != 0:\n             # Fallback or default if structure unclear - treat as single block\n             print(f\"Warning: Grid dimensions {height}x{width} not divisible by deduced subgrid size {subgrid_size}. Treating as single block.\")\n             # For this specific task, an invalid structure likely means it cannot be solved by this logic.\n             # However, let's try a simple fallback: If only one 'row' of subgrids exists, maybe return the unique/first?\n             # Or maybe the task implies valid structure always. Let's assume valid structure.\n             # Re-evaluate find_subgrid_size if issues persist.\n             if subgrid_size <= 0 :\n                  raise ValueError(\"Cannot determine subgrid size.\") # More appropriate than fallback for this task\n    except ValueError as e:\n         print(f\"Error in grid structure analysis: {e}\")\n         # Handle error case, maybe return input or empty grid? Let's return input.\n         # return input_np \n         # Let's reconsider: returning input is likely wrong. Maybe an empty grid of required size?\n         # The problem expects a transformation. Let's try to proceed assuming full grid if size fails.\n         # This seems risky. Let's stick to raising the error if size determination fails.\n         raise e\n\n\n    # 2. Extract Subgrids\n    # Check if dimensions are valid before extracting\n    if height % subgrid_size != 0 or width % subgrid_size != 0:\n        raise ValueError(f\"Input dimensions ({height}x{width}) not divisible by subgrid size ({subgrid_size})\")\n        \n    all_subgrids = extract_subgrids(input_np, subgrid_size)\n    num_subgrid_rows = len(all_subgrids)\n\n    if num_subgrid_rows == 0:\n         # Handle empty input case or error\n         return np.array([[]], dtype=int) # Return empty grid\n         \n    # 3. Process Rows & Select Subgrids\n    selected_subgrids = []\n    for subgrid_row in all_subgrids:\n        if not subgrid_row: # Skip empty rows if they somehow occur\n            continue\n        selected = select_subgrid_for_row(subgrid_row)\n        selected_subgrids.append(selected)\n\n    # 4. Construct Output Grid\n    output_height = height # Same height as input\n    output_width = subgrid_size # Width of one subgrid\n    output_grid = np.zeros((output_height, output_width), dtype=input_np.dtype)\n\n    # 5. Populate Output Grid\n    for i, sg in enumerate(selected_subgrids):\n        # Calculate top-left corner for placing the subgrid\n        row_start = i * subgrid_size\n        # Check bounds before placing\n        if row_start + subgrid_size <= output_height:\n             output_grid[row_start : row_start + subgrid_size, 0 : subgrid_size] = sg\n        else:\n             # This shouldn't happen if num_subgrid_rows * subgrid_size == height\n             print(f\"Warning: Subgrid placement exceeds output bounds. Row {i}, Start {row_start}\")\n\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4707,
    "candidates_token_count": 2417,
    "total_token_count": 7124,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.921349,
  "retries": 1
}