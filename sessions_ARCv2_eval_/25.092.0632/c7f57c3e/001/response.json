{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis program transforms an input grid based on its background color.\n\n1. Determine the dominant background color of the input grid.\n\n2. If the background color is Yellow (4):\n   a. Find all Green (3) and Azure (8) pixel locations. Store original Green locations separately.\n   b. Create a copy of the input grid.\n   c. Change pixels at original Green locations to Azure (8) in the output.\n   d. Change pixels at original Azure locations to Green (3) in the output.\n   e. Find all Red (2) pixel locations.\n   f. For each Red pixel, check if it's adjacent (including diagonals) to any *original* Green location.\n   g. If adjacent, change the Red pixel's color to Azure (8) in the output.\n\n3. If the background color is Green (3):\n   a. Find the location of the (assumed single) Magenta (6) pixel.\n   b. Find the locations of all Yellow (4) pixels.\n   c. Identify the Yellow pixel location with the minimum row index. Record its column index.\n   d. Create a copy of the input grid.\n   e. Change all Yellow pixels to Magenta (6) in the output.\n   f. Change the original Magenta pixel to Green (3) in the output.\n   g. Change the pixel at row 0 and the recorded column index (from step 3c) to Magenta (6) in the output.\n\n4. If the background color is neither Yellow nor Green, return the input grid unchanged.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Determines the most frequent color in the grid, assuming it's the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_pixels(grid, color):\n    \"\"\"Finds the coordinates (row, col) of all pixels with the given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets the 8 neighbor coordinates (including diagonals) for a pixel (r, c).\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef is_adjacent(r, c, target_locations, height, width):\n    \"\"\"Checks if pixel (r, c) is adjacent to any location in target_locations.\"\"\"\n    neighbors = get_neighbors(r, c, height, width)\n    target_set = set(target_locations)\n    for neighbor in neighbors:\n        if neighbor in target_set:\n            return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on the background color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 1. Determine background color\n    background_color = get_background_color(input_np)\n\n    if background_color == 4: # Yellow background case\n        # 2a. Find Green (3) and Azure (8) locations\n        original_green_locs = find_pixels(input_np, 3)\n        original_azure_locs = find_pixels(input_np, 8)\n        \n        # 2c. Change original Green to Azure\n        for r, c in original_green_locs:\n            output_np[r, c] = 8\n            \n        # 2d. Change original Azure to Green\n        for r, c in original_azure_locs:\n            output_np[r, c] = 3\n            \n        # 2e. Find Red (2) locations\n        red_locs = find_pixels(input_np, 2)\n        \n        # 2f & 2g. Check adjacency for Red pixels and change if needed\n        for r, c in red_locs:\n            if is_adjacent(r, c, original_green_locs, height, width):\n                output_np[r, c] = 8\n\n    elif background_color == 3: # Green background case\n        # 3a. Find Magenta (6) location (assume one)\n        magenta_locs = find_pixels(input_np, 6)\n        if not magenta_locs: \n             return output_np.tolist() # No trigger, return copy\n        original_magenta_loc = magenta_locs[0] # Assume first one if multiple (though examples show one)\n        \n        # 3b. Find Yellow (4) locations\n        yellow_locs = find_pixels(input_np, 4)\n        \n        min_row_yellow_col = -1\n        if yellow_locs:\n            # 3c. Find Yellow pixel with min row index and get its column\n            min_row = height # Initialize with value larger than any possible row index\n            for r, c in yellow_locs:\n                if r < min_row:\n                    min_row = r\n                    min_row_yellow_col = c\n                elif r == min_row: # If multiple in the same min row, take the smallest col? (not specified, taking first found)\n                     pass # Keep the first one found in this row\n\n            # 3e. Change Yellow to Magenta\n            for r, c in yellow_locs:\n                output_np[r, c] = 6\n        \n        # 3f. Change original Magenta to Green (background)\n        output_np[original_magenta_loc[0], original_magenta_loc[1]] = 3\n        \n        # 3g. Add Magenta at top row based on min_row_yellow_col\n        if min_row_yellow_col != -1: # Check if any yellow pixels were found\n             output_np[0, min_row_yellow_col] = 6\n\n    # 4. If background is neither Yellow nor Green, output_np remains a copy of input_np\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5013,
    "candidates_token_count": 1491,
    "total_token_count": 6504,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.477078,
  "retries": 1
}