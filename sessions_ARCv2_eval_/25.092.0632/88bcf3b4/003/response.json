{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on color adjacency rules involving three non-background colors.\n\n1. Identifies the background color (most frequent).\n2. Identifies the three unique non-background colors.\n3. Sorts the non-background colors numerically to determine roles:\n    - Source_Color: Lowest index.\n    - Mid_Color: Middle index.\n    - Target_Color: Highest index.\n4. Iterates through each pixel of the input grid.\n5. If a pixel has the Source_Color:\n    - Checks its 8 neighbors (including diagonals) in the input grid.\n    - If any neighbor has the Target_Color, the output pixel becomes Mid_Color.\n    - Otherwise, the output pixel becomes Background_Color.\n6. If a pixel has the Mid_Color:\n    - Checks its 8 neighbors (including diagonals) in the input grid.\n    - If any neighbor has the Target_Color, the output pixel becomes Target_Color.\n    - Otherwise, the output pixel becomes Background_Color.\n7. Pixels with Target_Color or Background_Color retain their original color in the output grid.\n\"\"\"\n\ndef _get_colors(grid):\n    \"\"\"\n    Identifies background color and the three non-background colors, assigning roles.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (background_color, source_color, mid_color, target_color)\n               Returns None for colors if fewer than 3 non-background colors are found.\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    \n    # Handle grids with only one color (all background)\n    if len(unique_colors) == 1:\n        return unique_colors[0], None, None, None\n        \n    background_color = unique_colors[np.argmax(counts)]\n    non_background_colors = sorted([color for color in unique_colors if color != background_color])\n\n    # Assign roles based on sorted order\n    source_color = non_background_colors[0] if len(non_background_colors) > 0 else None\n    mid_color = non_background_colors[1] if len(non_background_colors) > 1 else None\n    target_color = non_background_colors[2] if len(non_background_colors) > 2 else None\n\n    # Basic check if we have the required 3 non-background colors for the core logic\n    if len(non_background_colors) < 3:\n        print(f\"Warning: Expected 3 non-background colors, found {len(non_background_colors)}: {non_background_colors}. Roles assigned: S={source_color}, M={mid_color}, T={target_color}\")\n\n\n    return background_color, source_color, mid_color, target_color\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _has_target_neighbor(r, c, input_grid_np, target_color, rows, cols):\n    \"\"\"Checks if any of the 8 neighbors have the target color.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue  # Skip the cell itself\n            \n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor is valid and has the Target_Color\n            if _is_valid(nr, nc, rows, cols) and input_grid_np[nr, nc] == target_color:\n                return True # Found one\n    return False # Checked all neighbors, none found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the adjacency-based color transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n\n    # 1. Identify colors and roles\n    background_color, source_color, mid_color, target_color = _get_colors(input_grid_np)\n\n    # Check if essential colors (especially target) were identified for the logic to proceed\n    if target_color is None:\n         print(\"Error: Target color could not be determined. Cannot apply transformation rule.\")\n         return input_grid # Return original grid if roles cannot be established\n\n    # 2. Iterate through each pixel of the *input* grid\n    for r in range(rows):\n        for c in range(cols):\n            input_color = input_grid_np[r, c]\n\n            # 3. Apply transformation based on input color\n            \n            # Case 1: Pixel color is Source_Color\n            if input_color == source_color:\n                # Check adjacency to Target_Color in the *input* grid\n                if _has_target_neighbor(r, c, input_grid_np, target_color, rows, cols):\n                    output_grid[r, c] = mid_color # Change to Mid_Color\n                else:\n                    output_grid[r, c] = background_color # Change to Background_Color\n\n            # Case 2: Pixel color is Mid_Color\n            elif input_color == mid_color:\n                # Check adjacency to Target_Color in the *input* grid\n                if _has_target_neighbor(r, c, input_grid_np, target_color, rows, cols):\n                    output_grid[r, c] = target_color # Change to Target_Color\n                else:\n                    output_grid[r, c] = background_color # Change to Background_Color\n            \n            # Case 3 & 4: Pixel color is Target_Color or Background_Color\n            # No action needed, output_grid already holds the correct color from the initial copy.\n            # elif input_color == target_color: pass\n            # elif input_color == background_color: pass\n\n    # Convert back to list of lists for ARC standard output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15381,
    "candidates_token_count": 1446,
    "total_token_count": 16827,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.04596,
  "retries": 1
}