
## train_1

**input:**
```
0 0 0 0 0 0 0
0 0 0 0 0 2 0
0 0 0 0 0 0 0
0 0 0 4 4 8 0
0 0 0 4 0 8 0
0 0 4 4 0 8 0
0 4 0 0 0 8 0
```


**output:**
```
0 0 0 0 0 4 0
0 0 0 0 4 2 0
0 0 0 0 4 0 0
0 0 0 0 4 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
```


## train_2

**input:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 3 3 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


**output:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 7 3 7 7 7 7 7 7 7
7 7 7 7 7 3 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


## train_3

**input:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 7 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 7 7 1 1 1 1
1 1 1 1 1 1 2 1 7 7 7 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 8 8 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


**output:**
```
0 0 0 8 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 8 3 0 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 9 0 6 0 0 0
9 9 9 0 0 6 0 0 0
9 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 9 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Grid Structure:** The input and output are both 2D grids of colored pixels. The size of the grid remains the same between input and output for each example.
2.  **Background Color:** Each grid has a dominant background color (white/0 in ex 1, 4, 5; orange/7 in ex 2; blue/1 in ex 3). This background color remains largely unchanged in the output, except where specific transformations occur.
3.  **Objects:** Within the grid, there are distinct "objects" composed of contiguous pixels of non-background colors. In all examples, there appear to be exactly three distinct non-background colors present in the input grid.
4.  **Color Roles:** By comparing inputs and outputs, it seems the three non-background colors play specific roles based on their numerical value (color index):
    *   **Target Color:** The color with the highest numerical index among the three non-background colors. Pixels of this color remain unchanged and seem to influence the transformation.
    *   **Unaffected Color:** The color with the middle numerical index. Pixels of this color remain completely unchanged in the output.
    *   **Source Color:** The color with the lowest numerical index. Pixels of this color are the ones that undergo transformation.
5.  **Transformation Rule:** The core transformation operates on the pixels of the Source color.
    *   If a pixel with the Source color is adjacent (horizontally, vertically, or diagonally) to *any* pixel with the Target color in the input grid, its color changes to the Target color in the output grid.
    *   If a pixel with the Source color is *not* adjacent to any pixel with the Target color, its color changes to the Background color in the output grid.
6.  **Consistency:** This pattern holds across all five training examples. The identification of Source, Target, and Unaffected colors based on their numerical index (min, max, mid) and the subsequent adjacency-based transformation rule correctly predicts the output from the input.

**Facts**


```yaml
Task: Modify pixels of one color based on adjacency to pixels of another color.

Input_Grid:
  Properties:
    - Contains a single Background_Color (most frequent color).
    - Contains exactly three distinct Non_Background_Colors.
  Objects:
    - Pixels forming contiguous areas.

Color_Roles:
  - Identify the three Non_Background_Colors present in the input.
  - Target_Color: The Non_Background_Color with the highest numerical index.
  - Unaffected_Color: The Non_Background_Color with the middle numerical index.
  - Source_Color: The Non_Background_Color with the lowest numerical index.

Transformation:
  Action: Modify pixels based on color role and adjacency.
  Rule:
    - Iterate through each pixel (cell) in the input grid.
    - If the pixel color is Source_Color:
      - Check the 8 neighboring pixels (including diagonals).
      - Condition: If any neighbor has the Target_Color.
        - Result_True: Change the pixel's color to Target_Color in the output grid.
        - Result_False: Change the pixel's color to Background_Color in the output grid.
    - Else (pixel color is Target_Color, Unaffected_Color, or Background_Color):
      - Result: Keep the original pixel color in the output grid.

Output_Grid:
  Properties:
    - Same dimensions as Input_Grid.
    - Contains pixels modified according to the Transformation Rule.
    - Pixels originally of Target_Color or Unaffected_Color remain unchanged.
    - Background largely remains, potentially expanding into areas previously occupied by Source_Color pixels.
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the initial state of the output grid.
2.  Identify the background color by finding the most frequent color in the input grid.
3.  Identify all unique non-background colors present in the input grid. There should be exactly three.
4.  Sort these three non-background colors numerically by their color index.
5.  Assign roles based on the sorted order:
    *   `Source_Color`: The color with the lowest index.
    *   `Unaffected_Color`: The color with the middle index.
    *   `Target_Color`: The color with the highest index.
6.  Iterate through each cell (pixel) of the *input* grid, examining its coordinates (row, column) and color.
7.  If the color of the current cell in the *input* grid is equal to the `Source_Color`:
    *   Initialize a flag `is_adjacent_to_target` to `False`.
    *   Examine the 8 neighbors (up, down, left, right, and diagonals) of the current cell in the *input* grid.
    *   For each valid neighbor:
        *   If the neighbor's color in the *input* grid is equal to the `Target_Color`, set `is_adjacent_to_target` to `True` and stop checking neighbors for this cell.
    *   Based on the flag:
        *   If `is_adjacent_to_target` is `True`, update the color of the cell at the same (row, column) in the *output* grid to `Target_Color`.
        *   If `is_adjacent_to_target` is `False`, update the color of the cell at the same (row, column) in the *output* grid to the `Background_Color`.
8.  (Implicitly) If the color of the current cell in the *input* grid was *not* the `Source_Color`, its color in the *output* grid remains unchanged (as per the initial copy).
9.  Return the final modified output grid.
