{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom skimage.measure import label, regionprops\n\n\"\"\"\nThis program transforms an input grid based on rules derived from its structure.\nThe core transformation involves:\n1. Identifying a rectangular frame made of gray (5) pixels.\n2. Determining a color mapping based on vertically adjacent colored blocks found *outside* this frame. If a block of color C1 is directly above a block of color C2, then C1 maps to C2.\n3. Extracting the content *inside* the gray frame.\n4. Creating an output grid sized according to the frame's inner dimensions.\n5. Filling the output grid's border with gray (5).\n6. Copying the extracted content into the output grid's interior, applying the derived color mapping to each pixel. The background color within the frame is typically not mapped and remains the same.\n\"\"\"\n\ndef find_connected_components(grid, target_color):\n    \"\"\"Finds all connected components of a specific color.\"\"\"\n    labeled_grid = label(grid == target_color, connectivity=1, background=0)\n    regions = regionprops(labeled_grid)\n    components = []\n    for region in regions:\n        coords = tuple(map(tuple, region.coords.T)) # Store as (rows, cols)\n        components.append(coords)\n    return components\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\"\"\"\n    rows, cols = coords\n    if not rows or not cols:\n        return None\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by extracting content within a gray frame,\n    applying a color mapping derived from key blocks outside the frame,\n    and placing the result in a new grid with a gray border.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    gray_color = 5\n\n    # 1. Find the Frame\n    gray_components = find_connected_components(input_grid, gray_color)\n    if not gray_components:\n        # Handle cases where no gray frame exists (though unlikely based on examples)\n        return input_grid_list # Or raise error? Return original?\n\n    # Assume the largest gray component is the frame\n    frame_coords = max(gray_components, key=lambda coords: len(coords[0]))\n    frame_bbox = get_bounding_box(frame_coords)\n    if frame_bbox is None:\n         return input_grid_list # Should not happen if components found\n\n    min_r, min_c, max_r, max_c = frame_bbox\n\n    # 2. Determine Output Size (inner dimensions of the frame)\n    out_height = (max_r - min_r) + 1\n    out_width = (max_c - min_c) + 1\n\n    # 3. Identify Color Mapping Pairs\n    color_map = {}\n    # Use a simple approach: check vertical adjacency outside the frame\n    # Determine a likely background color (color just inside the frame top-left corner)\n    # Avoid mapping the background color itself\n    inner_bg_color = input_grid[min_r + 1, min_c + 1]\n\n    for r in range(height - 1):\n        for c in range(width):\n            # Check if the pixel pair (r, c) and (r+1, c) is outside the frame bounds\n            is_outside_r = r < min_r or r > max_r\n            is_outside_c = c < min_c or c > max_c\n            is_r_outside = is_outside_r or is_outside_c\n\n            is_outside_rp1 = (r + 1) < min_r or (r + 1) > max_r\n            is_outside_cp1 = c < min_c or c > max_c # c is same for rp1\n            is_rp1_outside = is_outside_rp1 or is_outside_cp1\n\n            # Only consider pairs fully outside the frame's bounding box\n            if is_r_outside and is_rp1_outside:\n                color_above = input_grid[r, c]\n                color_below = input_grid[r + 1, c]\n\n                # Ensure colors are not the determined inner background and are different\n                # This assumes key blocks are single solid colors different from background\n                if color_above != inner_bg_color and color_below != inner_bg_color and color_above != color_below:\n                     # Check if this pair belongs to larger blocks (optional refinement, maybe not needed)\n                     # Simple vertical adjacency is enough based on examples\n                     if color_above not in color_map: # Avoid overwriting if multiple instances found\n                         color_map[color_above] = color_below\n\n\n    # 4. Initialize Output Grid\n    # Fill with a temporary value or the inner background color initially\n    output_grid = np.full((out_height, out_width), inner_bg_color, dtype=int)\n\n    # 5. Draw Output Border\n    output_grid[0, :] = gray_color\n    output_grid[-1, :] = gray_color\n    output_grid[:, 0] = gray_color\n    output_grid[:, -1] = gray_color\n\n    # 6. Map and Copy Content\n    for r_in in range(min_r + 1, max_r):\n        for c_in in range(min_c + 1, max_c):\n            # Corresponding location in the output grid (relative to top-left corner of frame)\n            r_out = r_in - min_r\n            c_out = c_in - min_c\n\n            # Get the color from the input grid inside the frame\n            input_color = input_grid[r_in, c_in]\n\n            # Apply the mapping if the color is found in the map\n            output_color = color_map.get(input_color, input_color)\n\n            # Place the (potentially transformed) color into the output grid\n            output_grid[r_out, c_out] = output_color\n\n    # 7. Return Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5860,
    "candidates_token_count": 1501,
    "total_token_count": 7361,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.650026,
  "retries": 1
}