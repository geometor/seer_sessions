{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies rectangular objects in the input grid characterized by a 1-pixel thick frame of either azure (8) or red (2), enclosing a solid rectangular core of a different color.\nMoves these objects horizontally based on their frame color:\n- Objects with an azure (8) frame are moved to the left edge (column 0).\n- Objects with a red (2) frame are moved to the right edge (last column).\nThe vertical position and internal structure of the objects remain unchanged.\nThe background pixels are preserved, except where overwritten by moved objects.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all framed rectangular objects in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'bbox': (min_r, min_c, max_r, max_c)\n              'frame_color': The color of the frame (2 or 8)\n              'subgrid': A numpy array containing the object's pixels.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Look for potential frame pixels (red or azure) that haven't been visited\n            if grid[r, c] in [2, 8] and not visited[r, c]:\n                frame_color = grid[r, c]\n                \n                # Use BFS to find all connected pixels of the *same* frame color\n                q = deque([(r, c)])\n                frame_pixels = set([(r,c)])\n                component_visited = set([(r, c)])\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore 8 neighbors (including diagonals for connectivity check)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            \n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == frame_color and (nr, nc) not in component_visited:\n                                component_visited.add((nr, nc))\n                                frame_pixels.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Basic check: Potential object size must be at least 3x3\n                obj_h = max_r - min_r + 1\n                obj_w = max_c - min_c + 1\n                if obj_h < 3 or obj_w < 3:\n                    # Mark these pixels as visited to avoid reprocessing\n                    for fr, fc in frame_pixels:\n                        visited[fr, fc] = True\n                    continue # Too small to be a framed object\n\n                # Verify frame structure and solid core\n                is_valid_object = True\n                core_color = -1 # Sentinel value\n                core_pixels = set()\n\n                for ir in range(min_r, max_r + 1):\n                    for ic in range(min_c, max_c + 1):\n                        pixel_pos = (ir, ic)\n                        pixel_val = grid[ir, ic]\n\n                        # Check if it's on the border (frame)\n                        is_border = (ir == min_r or ir == max_r or ic == min_c or ic == max_c)\n\n                        if is_border:\n                            if pixel_pos not in frame_pixels: # Should be part of the found frame component\n                                is_valid_object = False\n                                break\n                            if pixel_val != frame_color: # Should have the correct frame color\n                                 is_valid_object = False\n                                 break\n                        else: # Inner pixel (core)\n                            if pixel_val == frame_color or pixel_val == background_color: # Core cannot be frame or background color\n                                is_valid_object = False\n                                break\n                            if core_color == -1: # First core pixel found\n                                core_color = pixel_val\n                            elif pixel_val != core_color: # Core must be solid color\n                                is_valid_object = False\n                                break\n                            core_pixels.add(pixel_pos)\n                    if not is_valid_object:\n                        break\n                \n                # Ensure the core isn't empty if the object is larger than 2x2 (which it must be)\n                if core_color == -1:\n                     is_valid_object = False\n\n                # Add the object if valid\n                if is_valid_object:\n                    # Extract the subgrid\n                    subgrid = grid[min_r:max_r+1, min_c:max_c+1]\n                    objects.append({\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'frame_color': frame_color,\n                        'subgrid': subgrid\n                    })\n                    # Mark all object pixels (frame and core) as visited\n                    all_object_pixels = frame_pixels.union(core_pixels)\n                    for orr, occ in all_object_pixels:\n                         if 0 <= orr < height and 0 <= occ < width:\n                            visited[orr, occ] = True\n                else:\n                    # Mark only the initially found frame component pixels as visited\n                    # This handles cases where we find frame-colored pixels that are not part of a valid object\n                    for fr, fc in frame_pixels:\n                       visited[fr, fc] = True\n\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves framed rectangular objects horizontally based on their frame color.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Determine background color (assuming it's the color at [0, 0])\n    background_color = input_np[0, 0]\n\n    # Initialize output grid with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # Find all framed objects\n    objects = find_objects(input_np, background_color)\n\n    # Process each object\n    for obj in objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        frame_color = obj['frame_color']\n        subgrid = obj['subgrid']\n        obj_h, obj_w = subgrid.shape\n\n        # Calculate new horizontal position\n        new_c = 0\n        if frame_color == 8: # Azure frame moves left\n            new_c = 0\n        elif frame_color == 2: # Red frame moves right\n            new_c = width - obj_w\n        \n        # Vertical position remains the same\n        new_r = min_r\n\n        # Place the object onto the output grid\n        # Ensure slicing bounds are within the grid dimensions\n        end_r = min(new_r + obj_h, height)\n        end_c = min(new_c + obj_w, width)\n        subgrid_h = end_r - new_r\n        subgrid_w = end_c - new_c\n        \n        if new_r < height and new_c < width and subgrid_h > 0 and subgrid_w > 0:\n             output_grid[new_r:end_r, new_c:end_c] = subgrid[0:subgrid_h, 0:subgrid_w]\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7965,
    "candidates_token_count": 1925,
    "total_token_count": 9890,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.196513,
  "retries": 1
}