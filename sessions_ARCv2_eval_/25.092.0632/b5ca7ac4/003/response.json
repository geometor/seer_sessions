{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies specific rectangular objects within the input grid and moves them horizontally.\nObjects are defined as having a 1-pixel thick frame of either azure (8) or red (2),\nenclosing a solid rectangular core of a different color (not the frame color and not the background color).\nThe size must be at least 3x3.\n\nTransformation Steps:\n1. Copy the input grid to create the output grid.\n2. Identify the background color.\n3. Find all qualifying framed rectangular objects.\n4. For each found object:\n    a. Erase the object from its original position in the output grid by filling its bounding box with the background color.\n    b. Calculate the new horizontal position based on the frame color:\n        - Azure (8) frames move to the left edge (column 0).\n        - Red (2) frames move to the right edge (last column).\n    c. Draw the object's original pixel data at its new position in the output grid.\n5. Return the modified output grid.\n\nStatic elements (pixels not part of the identified movable objects) remain unchanged.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all framed rectangular objects in the grid matching the criteria.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'bbox': (min_r, min_c, max_r, max_c) - Original bounding box\n              'frame_color': The color of the frame (2 or 8)\n              'subgrid': A numpy array containing the object's pixels.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Look for potential frame pixels (red or azure) that haven't been visited\n            # and are not the background color (handles cases where frame color might match background)\n            if grid[r, c] in [2, 8] and grid[r, c] != background_color and not visited[r, c]:\n                frame_color = grid[r, c]\n                \n                # Use BFS to find all connected pixels of the *same* frame color\n                # This helps identify the extent of a potential frame\n                q = deque([(r, c)])\n                frame_pixels = set([(r,c)]) # Store pixels belonging to this potential frame component\n                component_visited = set([(r, c)]) # Track visited during this specific BFS\n                min_r_bfs, min_c_bfs, max_r_bfs, max_c_bfs = r, c, r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    min_r_bfs = min(min_r_bfs, curr_r)\n                    min_c_bfs = min(min_c_bfs, curr_c)\n                    max_r_bfs = max(max_r_bfs, curr_r)\n                    max_c_bfs = max(max_c_bfs, curr_c)\n\n                    # Explore 8 neighbors for connectivity\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            \n                            # Check bounds and if neighbor has the same frame color and wasn't visited in this BFS\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == frame_color and (nr, nc) not in component_visited:\n                                component_visited.add((nr, nc))\n                                frame_pixels.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Define the bounding box based on the BFS extent\n                min_r, min_c, max_r, max_c = min_r_bfs, min_c_bfs, max_r_bfs, max_c_bfs\n                obj_h = max_r - min_r + 1\n                obj_w = max_c - min_c + 1\n\n                # Basic size check\n                if obj_h < 3 or obj_w < 3:\n                    # Mark only the BFS-found pixels as visited globally to avoid reprocessing this invalid component\n                    for fr, fc in frame_pixels:\n                        visited[fr, fc] = True\n                    continue \n\n                # Verify the strict rectangular frame structure and solid core\n                is_valid_object = True\n                core_color = -1 # Sentinel value\n                core_pixels = set() # Track core pixels for marking visited later\n\n                for ir in range(min_r, max_r + 1):\n                    for ic in range(min_c, max_c + 1):\n                        pixel_val = grid[ir, ic]\n                        # Check if it's on the border of the bounding box (potential frame)\n                        is_border = (ir == min_r or ir == max_r or ic == min_c or ic == max_c)\n\n                        if is_border:\n                            if pixel_val != frame_color: # All border pixels MUST be the frame color\n                                is_valid_object = False\n                                break\n                        else: # Inner pixel (potential core)\n                            # Core cannot be frame or background color\n                            if pixel_val == frame_color or pixel_val == background_color: \n                                is_valid_object = False\n                                break\n                            # Check for solid color core\n                            if core_color == -1: # First core pixel found\n                                core_color = pixel_val\n                            elif pixel_val != core_color: # Core must be solid (same color)\n                                is_valid_object = False\n                                break\n                            core_pixels.add((ir,ic)) # Add to core set if valid so far\n                    if not is_valid_object:\n                        break # Exit inner loop if invalid\n                \n                # Final check: ensure a core color was actually found (handles hollow shapes)\n                if core_color == -1:\n                     is_valid_object = False\n\n                # If all checks pass, it's a valid object\n                if is_valid_object:\n                    # Extract the object's pixel data\n                    subgrid = grid[min_r:max_r+1, min_c:max_c+1]\n                    objects.append({\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'frame_color': frame_color,\n                        'subgrid': subgrid\n                    })\n                    # Mark all pixels within the valid object's bounding box as visited globally\n                    for ir in range(min_r, max_r + 1):\n                        for ic in range(min_c, max_c + 1):\n                            visited[ir, ic] = True\n                else:\n                     # Mark only the BFS-found pixels as visited globally if it wasn't a valid object\n                    for fr, fc in frame_pixels:\n                       visited[fr, fc] = True\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # Determine background color (assume top-left is representative)\n    background_color = input_np[0, 0]\n\n    # Find all qualifying framed objects\n    objects_to_move = find_objects(input_np, background_color)\n\n    # Process each identified object\n    for obj in objects_to_move:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        frame_color = obj['frame_color']\n        subgrid = obj['subgrid']\n        obj_h, obj_w = subgrid.shape\n\n        # Erase the object from its original position in the output grid\n        output_grid[min_r:max_r+1, min_c:max_c+1] = background_color\n\n        # Calculate new horizontal position\n        new_c = 0 # Default for azure\n        if frame_color == 2: # Red frame moves right\n            new_c = width - obj_w\n        \n        # Vertical position remains the same\n        new_r = min_r\n\n        # Draw the object at its new position\n        # Ensure slicing bounds are within the grid dimensions (should be fine if width calculation is correct)\n        end_r = new_r + obj_h\n        end_c = new_c + obj_w\n        \n        # Check bounds before drawing (safety measure)\n        if 0 <= new_r < height and end_r <= height and 0 <= new_c < width and end_c <= width:\n             output_grid[new_r:end_r, new_c:end_c] = subgrid\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28518,
    "candidates_token_count": 2154,
    "total_token_count": 30672,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.898495,
  "retries": 1
}