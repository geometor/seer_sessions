{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies a horizontal separator line (all blue=1 pixels) dividing the grid into an upper 'key area' and a lower 'work area'.\nIt finds all distinct contiguous objects in the key area, excluding background (0) and separator (1) pixels. For each key object, it determines its bounding box and extracts the rectangular subgrid within that box as the 'key pattern'. The primary color of the contiguous object that defined the pattern is associated with this pattern subgrid.\nIt then finds all contiguous gray (5) objects in the work area. For each gray object, it determines its bounding box and extracts the corresponding rectangular subgrid as the 'target pattern'.\nIf a target pattern subgrid exactly matches a key pattern subgrid (both shape and pixel values), then all the *original gray pixels* corresponding to that target object in the output grid are replaced with the primary color associated with the matching key pattern.\nAll other elements (key area content, separator line, background pixels in work area, and gray objects whose patterns do not match any key pattern) remain unchanged in the output grid.\n\"\"\"\n\ndef find_objects_with_bbox(grid, target_colors, bounds=None):\n    \"\"\"\n    Finds all contiguous objects of specified colors within given bounds, \n    returning their color, coordinates, and bounding box. Uses BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_colors (set): The color(s) of the objects to find.\n        bounds (tuple, optional): (min_row, max_row, min_col, max_col) defining the search area (exclusive max).\n                                  Defaults to the whole grid if None.\n\n    Returns:\n        list: A list of objects. Each object is a tuple: \n              (color, set_of_coordinates, bounding_box).\n              Coordinates are (row, col) tuples relative to the original grid.\n              Bounding_box is (min_r, min_c, max_r, max_c) inclusive.\n              Returns an empty list if no objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    if bounds:\n        min_row, max_row, min_col, max_col = bounds\n        min_row = max(0, min_row)\n        max_row = min(rows, max_row)\n        min_col = max(0, min_col)\n        max_col = min(cols, max_col)\n    else:\n        min_row, max_row = 0, rows\n        min_col, max_col = 0, cols\n\n    visited = np.zeros((rows, cols), dtype=bool) \n    objects = []\n\n    for r in range(min_row, max_row):\n        for c in range(min_col, max_col):\n            if not visited[r, c] and grid[r, c] in target_colors:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True \n                min_obj_r, max_obj_r = r, r\n                min_obj_c, max_obj_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_obj_r = min(min_obj_r, row)\n                    max_obj_r = max(max_obj_r, row)\n                    min_obj_c = min(min_obj_c, col)\n                    max_obj_c = max(max_obj_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check grid bounds first\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                             # Check search bounds\n                            if min_row <= nr < max_row and min_col <= nc < max_col:\n                                # Check color and visited status\n                                if not visited[nr, nc] and grid[nr, nc] == color:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n\n                if obj_coords:\n                    bbox = (min_obj_r, min_obj_c, max_obj_r, max_obj_c)\n                    objects.append((color, obj_coords, bbox))\n\n    return objects\n\ndef get_pattern_subgrid(grid, bbox):\n    \"\"\"\n    Extracts the rectangular subgrid defined by the bounding box.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        bbox (tuple): (min_r, min_c, max_r, max_c) inclusive coordinates.\n\n    Returns:\n        np.ndarray: The extracted subgrid. Returns None if bbox is invalid.\n    \"\"\"\n    if not bbox or len(bbox) != 4:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    # Ensure indices are valid for slicing\n    if min_r < 0 or min_c < 0 or max_r >= grid.shape[0] or max_c >= grid.shape[1] or min_r > max_r or min_c > max_c:\n         # print(f\"Warning: Invalid bbox {bbox} for grid shape {grid.shape}\")\n         return None # Or handle error appropriately\n    \n    # Slicing is exclusive for the end index, so add 1\n    return grid[min_r : max_r + 1, min_c : max_c + 1]\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on pattern matching between key and work areas,\n    where patterns are defined by bounding boxes including internal background pixels.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input structure\n    output_grid_np = np.copy(input_grid_np)\n    rows, cols = input_grid_np.shape\n\n    # 1. Find the separator line (assuming blue=1 and full width)\n    separator_row = -1\n    separator_color = 1 # Blue\n    for r in range(rows):\n        if np.all(input_grid_np[r, :] == separator_color):\n            separator_row = r\n            break\n\n    # If no separator line is found, return the original grid copy\n    if separator_row == -1:\n        # print(\"Warning: Separator line (color=1) not found.\")\n        return output_grid_np.tolist() \n\n    # 2. Define key and work area boundaries\n    key_area_bounds = (0, separator_row, 0, cols)  # Rows 0 to separator_row-1\n    work_area_bounds = (separator_row + 1, rows, 0, cols) # Rows separator_row+1 to end\n\n    # 3. Find key patterns (subgrids and primary colors) in the key area\n    background_color = 0\n    key_colors = set(range(10)) - {background_color, separator_color}\n    key_objects = find_objects_with_bbox(input_grid_np, key_colors, key_area_bounds)\n\n    key_patterns = [] # Store as list of (subgrid_array, primary_color)\n    for primary_color, coords, bbox in key_objects:\n        key_subgrid = get_pattern_subgrid(input_grid_np, bbox)\n        if key_subgrid is not None:\n            key_patterns.append((key_subgrid, primary_color))\n            \n    # 4. Find gray (5) target objects in the work area\n    target_gray_color = 5\n    gray_objects = find_objects_with_bbox(input_grid_np, {target_gray_color}, work_area_bounds)\n\n    # 5. Process gray objects: match patterns and replace colors in the output grid\n    for gray_color, gray_coords, gray_bbox in gray_objects:\n        # Extract the pattern subgrid for the current gray object\n        target_pattern_subgrid = get_pattern_subgrid(input_grid_np, gray_bbox)\n\n        if target_pattern_subgrid is None:\n            continue # Skip if bounding box was invalid\n\n        # Compare the target pattern with each key pattern\n        match_found = False\n        for key_subgrid, key_primary_color in key_patterns:\n            # Check if shapes are identical AND content is identical\n            if target_pattern_subgrid.shape == key_subgrid.shape and \\\n               np.array_equal(target_pattern_subgrid, key_subgrid):\n                \n                # Match found! Replace the original gray pixels with the key's primary color\n                replacement_color = key_primary_color\n                for r, c in gray_coords:\n                     # Check bounds just in case, although coords should be valid\n                    if 0 <= r < rows and 0 <= c < cols:\n                        # Important: Only modify pixels that were originally gray (part of gray_coords)\n                        if input_grid_np[r,c] == target_gray_color:\n                             output_grid_np[r, c] = replacement_color\n                \n                match_found = True\n                break # Stop comparing once a match is found for this gray object\n        \n        # If no match was found after checking all keys, the gray object remains unchanged (already copied)\n\n    # Convert the modified numpy array back to a list of lists for the final output\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28132,
    "candidates_token_count": 2271,
    "total_token_count": 30403,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.856281,
  "retries": 1
}