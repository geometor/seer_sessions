{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies a horizontal separator line (all blue=1 pixels) dividing the grid into an upper 'key area' and a lower 'work area'.\nIt finds all distinct contiguous objects in the key area, excluding background (0) and separator (1) pixels. For each such key object, it records its normalized shape (tuple of relative coordinates) and its color.\nIt then finds all contiguous gray (5) objects in the work area.\nFor each gray object found in the work area, it calculates its normalized shape. If this shape exactly matches the shape of a key object from the key area, all pixels comprising that gray object in the output grid are replaced with the color of the matching key object.\nAll other elements (key area content, separator line, background pixels in work area, and gray objects in the work area whose shape does not match any key pattern shape) remain unchanged in the output grid.\n\"\"\"\n\ndef find_objects(grid, target_colors, bounds=None):\n    \"\"\"\n    Finds all contiguous objects of specified colors within given bounds using Breadth-First Search.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_colors (list or set): The color(s) of the objects to find.\n        bounds (tuple, optional): (min_row, max_row, min_col, max_col) defining the search area (exclusive max).\n                                  Defaults to the whole grid if None.\n\n    Returns:\n        list: A list of objects. Each object is a tuple: (color, set_of_coordinates).\n              Coordinates are (row, col) tuples relative to the original grid.\n    \"\"\"\n    rows, cols = grid.shape\n    if bounds:\n        min_row, max_row, min_col, max_col = bounds\n        # Ensure bounds are within grid dimensions\n        min_row = max(0, min_row)\n        max_row = min(rows, max_row)\n        min_col = max(0, min_col)\n        max_col = min(cols, max_col)\n    else:\n        min_row, max_row = 0, rows\n        min_col, max_col = 0, cols\n\n    # Use a full-grid visited array to handle objects potentially crossing implicit boundaries if bounds were handled differently\n    visited = np.zeros((rows, cols), dtype=bool) \n    objects = []\n\n    for r in range(min_row, max_row):\n        for c in range(min_col, max_col):\n            # Check if the current cell is a target color and hasn't been visited yet\n            if not visited[r, c] and grid[r, c] in target_colors:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark the starting cell as visited\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check if the neighbor is within the *original grid bounds* first\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                             # Now check if the neighbor is within the *defined search bounds*\n                            if min_row <= nr < max_row and min_col <= nc < max_col:\n                                # Check if the neighbor has the same color and hasn't been visited\n                                if not visited[nr, nc] and grid[nr, nc] == color:\n                                    visited[nr, nc] = True # Mark neighbor as visited\n                                    q.append((nr, nc)) # Add neighbor to the queue\n\n                # After BFS completes for an object, if coordinates were found, store it\n                if obj_coords:\n                    objects.append((color, obj_coords))\n\n    return objects\n\ndef get_object_shape(obj_coords):\n    \"\"\"\n    Calculates the normalized shape of an object based on its coordinates.\n    The shape is represented by coordinates relative to the top-left corner of the object's bounding box.\n\n    Args:\n        obj_coords (set): A set of (row, col) coordinates representing the object.\n\n    Returns:\n        tuple: A tuple of sorted relative coordinates ((r1, c1), (r2, c2), ...),\n               representing the shape normalized to (0,0).\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n\n    # Find the minimum row and column to establish the top-left reference point\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n\n    # Calculate relative coordinates by subtracting the min row and col\n    # Sort the coordinates to ensure a consistent representation regardless of traversal order\n    relative_coords = sorted([(r - min_r, c - min_c) for r, c in obj_coords])\n\n    # Return the sorted relative coordinates as a tuple (making it hashable)\n    return tuple(relative_coords)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on shape matching between key and work areas.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input structure\n    output_grid_np = np.copy(input_grid_np)\n    rows, cols = input_grid_np.shape\n\n    # 1. Find the separator line (assuming blue=1 and full width)\n    separator_row = -1\n    separator_color = 1 # Blue\n    for r in range(rows):\n        # Check if the entire row consists of the separator color\n        if np.all(input_grid_np[r, :] == separator_color):\n            separator_row = r\n            break\n\n    # If no separator line is found, return the original grid copy\n    if separator_row == -1:\n        # print(\"Warning: Separator line (color=1) not found.\")\n        return output_grid_np.tolist() # Return copy as list of lists\n\n    # 2. Define key and work area boundaries\n    key_area_bounds = (0, separator_row, 0, cols)  # Rows 0 to separator_row-1\n    work_area_bounds = (separator_row + 1, rows, 0, cols) # Rows separator_row+1 to end\n\n    # 3. Find key patterns (shapes and colors) in the key area\n    background_color = 0\n    # Define colors to look for in the key area (all except background and separator)\n    key_colors = set(range(10)) - {background_color, separator_color}\n    key_objects = find_objects(input_grid_np, key_colors, key_area_bounds)\n\n    # Store key patterns in a dictionary: shape -> color\n    key_patterns = {}\n    for color, coords in key_objects:\n        shape = get_object_shape(coords)\n        # Ensure shape is valid before adding to dictionary\n        if shape:\n            # If duplicate shapes exist, the last one encountered will overwrite previous ones.\n            key_patterns[shape] = color\n\n    # 4. Find gray (5) objects in the work area\n    target_gray_color = 5\n    gray_objects = find_objects(input_grid_np, {target_gray_color}, work_area_bounds)\n\n    # 5. Process gray objects: match shapes and replace colors in the output grid\n    for _, gray_coords in gray_objects:\n        # Calculate the normalized shape of the gray object\n        gray_shape = get_object_shape(gray_coords)\n\n        # Check if the shape is valid and if it exists as a key in the key patterns dictionary\n        if gray_shape and gray_shape in key_patterns:\n            # Get the color associated with the matching key pattern\n            replacement_color = key_patterns[gray_shape]\n            \n            # Update the output grid: replace gray pixels with the key pattern's color\n            for r, c in gray_coords:\n                # Double-check bounds for safety, although coordinates from find_objects should be valid\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_grid_np[r, c] = replacement_color\n        # Else: If no match found, the gray object remains unchanged in the output_grid_np (no action needed)\n\n\n    # Convert the modified numpy array back to a list of lists for the final output\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 33587,
    "candidates_token_count": 2044,
    "total_token_count": 35631,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.49153,
  "retries": 1
}