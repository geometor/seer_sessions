{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the background color (assumed to be the color of the top-left pixel).\nFinds all connected components (objects) of non-background colors, noting their \nshape, color, and original bounding box.\nCreates a new grid of the same dimensions, filled with the background color.\nFor each identified object, determines a target vertical edge (Top or Bottom) based \non the background color and the object's color according to specific rules:\n - If the background is White (0):\n    - Green (3) and Blue (1) objects move to the Top edge.\n    - Yellow (4) and Red (2) objects move to the Bottom edge.\n - If the background is Gray (5):\n    - Green (3), Orange (7), Maroon (9), and Red (2) objects move to the Top edge.\n    - Blue (1) and Yellow (4) objects move to the Bottom edge.\nThe object is then drawn onto the output grid, preserving its original horizontal \nposition (column) and shape, but aligning either its top row with row 0 (for Top edge) \nor its bottom row with the last row of the grid (for Bottom edge).\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all connected components (objects) of non-background colors using 8-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with its\n              properties: color, pixels_relative (relative to min_r, min_c), \n              height, width, min_r, min_c.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited.add((r, c))\n                component_pixels_absolute = []\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_pixels_absolute.append((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # Calculate object properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                # Store pixel coordinates relative to the object's top-left corner (min_r, min_c)\n                pixels_relative = [(pr - min_r, pc - min_c) for pr, pc in component_pixels_absolute]\n                \n                objects.append({\n                    'color': color,\n                    'pixels_relative': pixels_relative, # Coordinates relative to object's top-left\n                    'height': height,\n                    'width': width,\n                    'min_r': min_r, # Original top row\n                    'min_c': min_c, # Original left column\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving objects vertically to the top or bottom edge\n    based on background and object color, preserving horizontal position.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Determine background color (assuming top-left pixel)\n    background_color = input_np[0, 0] \n\n    # Find all non-background objects\n    objects = find_objects(input_np, background_color)\n\n    # Create the output grid filled with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Define color mappings to target edge based on background\n    top_edge_colors = {}\n    bottom_edge_colors = {}\n\n    if background_color == 0: # White background\n        top_edge_colors = {3, 1}    # Green, Blue\n        bottom_edge_colors = {4, 2} # Yellow, Red\n    elif background_color == 5: # Gray background\n        top_edge_colors = {3, 7, 9, 2} # Green, Orange, Maroon, Red\n        bottom_edge_colors = {1, 4}    # Blue, Yellow\n    else:\n        # Default behavior for unhandled background colors: perhaps no movement?\n        # For now, let's just copy input to output if background is unknown.\n        print(f\"Warning: Unhandled background color {background_color}. Returning original grid.\")\n        return input_grid # Or return output_grid which is just background\n\n    # Place each object in the output grid at its new position\n    for obj in objects:\n        obj_color = obj['color']\n        obj_height = obj['height']\n        obj_min_c = obj['min_c'] # Target column is the original column\n        \n        target_row = -1 # Initialize target row\n\n        # Determine target edge and calculate target_row\n        if obj_color in top_edge_colors:\n            target_row = 0 # Align top of object with row 0\n        elif obj_color in bottom_edge_colors:\n            target_row = rows - obj_height # Align bottom of object with last row\n        else:\n            # Handle unexpected colors within a known background case\n            # Option: place at original position, place at top, or skip? Let's skip for now.\n            print(f\"Warning: Color {obj_color} rule undefined for background {background_color}. Skipping object.\")\n            continue \n            \n        # Draw the object onto the output grid at the calculated position\n        for dr, dc in obj['pixels_relative']:\n            # Calculate absolute coordinates in the output grid\n            place_r = target_row + dr\n            place_c = obj_min_c + dc # Use original min_c for horizontal position\n            \n            # Check bounds before writing (should be safe if logic is correct)\n            if 0 <= place_r < rows and 0 <= place_c < cols:\n                output_grid[place_r, place_c] = obj_color\n            else:\n                # This indicates an error in calculation or unexpected input\n                print(f\"Error: Calculated pixel ({place_r}, {place_c}) out of bounds.\")\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20179,
    "candidates_token_count": 1724,
    "total_token_count": 21903,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.649325,
  "retries": 1
}