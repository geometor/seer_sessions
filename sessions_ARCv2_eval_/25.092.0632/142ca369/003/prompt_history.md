
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 2
0 0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 2 0
0 0 0 0 0 0 5 5 0 0 0 0 0 5 0 0 0 2 0 0
0 0 0 0 0 2 0 0 5 0 0 0 5 0 0 0 2 0 0 0
0 0 0 0 2 2 0 0 0 5 0 5 0 0 0 2 0 0 0 1
0 0 0 1 0 0 2 0 0 0 5 0 0 0 2 0 0 0 1 0
0 0 1 1 0 0 0 2 0 0 5 0 0 2 0 0 0 1 0 0
0 3 0 0 1 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0
3 3 0 0 0 1 0 0 0 2 0 2 0 0 0 1 0 0 0 3
0 0 3 0 0 0 1 0 0 0 2 0 0 0 1 0 0 0 3 0
0 0 0 3 0 0 0 1 0 0 2 0 0 1 0 0 0 3 0 0
0 0 0 0 3 0 0 0 1 0 0 0 1 0 0 0 3 0 0 0
0 0 0 0 0 3 0 0 0 1 0 1 0 0 0 3 0 0 0 0
0 0 0 0 0 0 3 0 0 0 1 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 1 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 6
6 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 6
6 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 6
6 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 6 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0 0 0 0 6 0 0 0 0
0 0 0 0 4 0 2 0 0 0 0 0 0 0 6 0 0 0
0 0 0 4 0 0 0 2 2 0 0 0 0 0 0 6 0 6
6 0 4 0 0 0 0 2 0 0 0 0 0 0 0 0 6 6
6 6 0 0 0 0 0 0 0 0 2 0 0 0 0 4 0 6
6 0 6 0 0 0 0 0 0 2 2 0 0 0 4 0 0 0
0 0 0 6 0 0 0 0 0 0 0 2 0 4 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 4 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 6 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 1 0 0 0 2 2 2 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 7 0 1 0 0 0 0 0 0 0 5 0 2 0 0 0 0 0 0
0 7 7 0 0 0 0 0 0 0 5 0 0 0 2 0 0 0 0 0
0 7 0 7 0 0 0 0 0 5 0 0 0 0 0 2 0 0 0 0
0 0 0 0 7 0 0 0 5 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 7 0 5 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 0 0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of Task Elements:**

1.  **Input/Output Structure:** Both input and output are 2D grids of colored pixels (represented by integers 0-9). The background is white (0).
2.  **Objects:** The non-white pixels form distinct objects or individual pixels scattered across the grid. These objects retain their original shapes and positions in the output grid.
3.  **Transformation:** The core transformation involves adding new pixels to the grid. These new pixels form diagonal lines extending downwards and to the right from *each* non-white pixel present in the input grid.
4.  **Line Behavior:**
    *   The diagonal line originating from a pixel at `(r, c)` starts at `(r+1, c+1)`.
    *   The line uses the same color as the originating pixel.
    *   The line continues diagonally (`r+k, c+k`) as long as it stays within the grid boundaries.
    *   Crucially, the line stops *before* overwriting any pixel that was *already* non-white in the *input* grid. If the path encounters a non-white pixel from the input, the line terminates just before that pixel.
    *   If the path reaches the bottom or right edge of the grid, it stops there.
5.  **Overlapping Lines:** The examples don't show conflicts where two different colored lines attempt to color the same initially white pixel. The rule seems deterministic based on checking the *input* grid state for blocking.

**YAML Facts:**


```yaml
Examples: 3
Grid_Size: Variable (e.g., 20x20, 18x18)
Colors: white(0), blue(1), red(2), green(3), yellow(4), gray(5), magenta(6), orange(7) - subset used in each example.

Input_Objects:
  - Type: Contiguous shapes or individual pixels.
  - Colors: Various non-white colors.
  - Persistence: All input objects remain unchanged in the output grid.

Output_Objects:
  - Includes all input objects.
  - Additional pixels forming diagonal lines.

Actions:
  - For each non-white pixel in the input grid:
    - Action: Emit a diagonal line.
    - Direction: Downwards and to the right (+1 row, +1 column).
    - Color: Same as the emitting pixel.
    - Termination_Condition_1: Line reaches a grid boundary (bottom or right edge).
    - Termination_Condition_2: Line reaches a cell that was non-white in the *input* grid (stops *before* this cell).

Relationships:
  - The added diagonal lines originate *from* the input non-white pixels.
  - The path of a diagonal line is constrained by the positions of *other* non-white pixels in the *input* grid.
  - The final output grid is a combination of the original input pixels and the newly added diagonal line pixels.
```


**Natural Language Program:**

1.  Create the output grid as an exact copy of the input grid.
2.  Iterate through every cell (`row`, `col`) of the input grid.
3.  If the cell at (`row`, `col`) in the input grid contains a non-white color `C`:
    a.  Initialize the starting position for the diagonal trace: `next_row = row + 1`, `next_col = col + 1`.
    b.  Begin a loop that continues as long as `next_row` is within the grid's height and `next_col` is within the grid's width.
    c.  Inside the loop, check the color of the cell at (`next_row`, `next_col`) in the *input* grid.
    d.  If the input cell at (`next_row`, `next_col`) is white (0):
        i.  Set the color of the cell at (`next_row`, `next_col`) in the *output* grid to color `C`.
        ii. Increment `next_row` by 1 and `next_col` by 1 to move to the next diagonal position.
    e.  If the input cell at (`next_row`, `next_col`) is *not* white (it's part of an original object):
        i.  Stop tracing this specific diagonal line immediately (break out of the inner loop starting at step 3b).
    f. Continue the loop (step 3b) until it terminates due to boundary checks or encountering a non-white input cell.
4.  After iterating through all cells of the input grid, return the modified output grid.
```python
import numpy as np

"""
Identify all non-white pixels in the input grid. For each non-white pixel, 
project a diagonal line downwards and to the right, using the same color as 
the starting pixel. This line continues until it hits the grid boundary or 
reaches a cell that was non-white in the *original* input grid. The line stops 
*before* overwriting any original non-white pixel. The final output grid 
contains both the original non-white pixels and the newly drawn diagonal lines.
"""

def transform(input_grid):
    """
    Projects diagonal lines from non-white pixels in the input grid.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input_grid
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Iterate through each cell of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current cell is non-white (not 0)
            if input_grid[r, c] != 0:
                # Get the color of the source pixel
                color = input_grid[r, c]
                
                # Initialize the starting position for the diagonal trace
                nr, nc = r + 1, c + 1

                # Start tracing the diagonal line downwards and to the right
                while nr < height and nc < width:
                    # Check if the next cell in the diagonal path *in the original input grid* is white
                    if input_grid[nr, nc] == 0:
                        # If it's white, draw the pixel with the source color in the output grid
                        output_grid[nr, nc] = color
                        # Move to the next diagonal position
                        nr += 1
                        nc += 1
                    else:
                        # If the next cell in the input grid is not white, stop tracing this line
                        break 
                # The loop also naturally stops if nr or nc go out of bounds

    # Return the modified output grid
    return output_grid

```

Previous Code:
```python
import numpy as np

"""
Identify all non-white pixels in the input grid. For each non-white pixel, 
project a diagonal line downwards and to the right, using the same color as 
the starting pixel. This line continues until it hits the grid boundary or 
reaches a cell that was non-white in the *original* input grid. The line stops 
*before* overwriting any original non-white pixel. The final output grid 
contains both the original non-white pixels and the newly drawn diagonal lines.
"""

def transform(input_grid):
    """
    Projects diagonal lines from non-white pixels in the input grid.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input_grid
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Iterate through each cell of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current cell is non-white (not 0)
            if input_grid[r, c] != 0:
                # Get the color of the source pixel
                color = input_grid[r, c]
                
                # Initialize the starting position for the diagonal trace
                nr, nc = r + 1, c + 1

                # Start tracing the diagonal line downwards and to the right
                while nr < height and nc < width:
                    # Check if the next cell in the diagonal path *in the original input grid* is white
                    if input_grid[nr, nc] == 0:
                        # If it's white, draw the pixel with the source color in the output grid
                        output_grid[nr, nc] = color
                        # Move to the next diagonal position
                        nr += 1
                        nc += 1
                    else:
                        # If the next cell in the input grid is not white, stop tracing this line
                        break 
                # The loop also naturally stops if nr or nc go out of bounds

    # Return the modified output grid
    return output_grid

```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 2
0 0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 2 0
0 0 0 0 0 0 5 5 0 0 0 0 0 5 0 0 0 2 0 0
0 0 0 0 0 2 0 0 5 0 0 0 5 0 0 0 2 0 0 0
0 0 0 0 2 2 0 0 0 5 0 5 0 0 0 2 0 0 0 1
0 0 0 1 0 0 2 0 0 0 5 0 0 0 2 0 0 0 1 0
0 0 1 1 0 0 0 2 0 0 5 0 0 2 0 0 0 1 0 0
0 3 0 0 1 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0
3 3 0 0 0 1 0 0 0 2 0 2 0 0 0 1 0 0 0 3
0 0 3 0 0 0 1 0 0 0 2 0 0 0 1 0 0 0 3 0
0 0 0 3 0 0 0 1 0 0 2 0 0 1 0 0 0 3 0 0
0 0 0 0 3 0 0 0 1 0 0 0 1 0 0 0 3 0 0 0
0 0 0 0 0 3 0 0 0 1 0 1 0 0 0 3 0 0 0 0
0 0 0 0 0 0 3 0 0 0 1 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 1 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 5 5 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 0 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 1 0 2 2 2 0 5 5 5 0 0 0 0 0 0 0 0
0 0 1 1 1 0 2 2 2 0 5 5 5 0 0 0 0 0 0 0
0 3 0 1 1 1 0 2 2 2 0 5 5 5 0 0 0 0 0 0
3 3 3 0 1 1 1 0 2 2 2 0 5 5 5 0 0 0 0 0
0 3 3 3 0 1 1 1 0 2 2 2 0 5 5 5 0 0 0 0
0 0 3 3 3 0 1 1 1 0 2 2 2 0 5 5 5 0 0 0
0 0 0 3 3 3 0 1 1 1 0 2 2 2 0 5 5 5 0 0
0 0 0 0 3 3 3 0 1 1 1 0 2 2 2 0 5 5 5 0
0 0 0 0 0 3 3 3 0 1 1 1 0 2 2 2 0 5 5 5
0 0 0 0 0 0 3 3 3 0 1 1 1 0 2 2 2 0 5 5
0 0 0 0 0 0 0 3 3 3 0 1 1 1 0 2 2 2 0 5
0 0 0 0 0 0 0 0 3 3 3 0 1 1 1 0 2 2 2 0
0 0 0 0 0 0 0 0 0 3 3 3 0 1 1 1 0 2 2 2
0 0 0 0 0 0 0 0 0 0 3 3 3 0 1 1 1 0 2 2
0 0 0 0 0 0 0 0 0 0 0 3 3 3 0 1 1 1 0 2
```
Match: False
Pixels Off: 152
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 76.0

## Example 2:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 6
6 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 6
6 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 6
6 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 6 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0 0 0 0 6 0 0 0 0
0 0 0 0 4 0 2 0 0 0 0 0 0 0 6 0 0 0
0 0 0 4 0 0 0 2 2 0 0 0 0 0 0 6 0 6
6 0 4 0 0 0 0 2 0 0 0 0 0 0 0 0 6 6
6 6 0 0 0 0 0 0 0 0 2 0 0 0 0 4 0 6
6 0 6 0 0 0 0 0 0 2 2 0 0 0 4 0 0 0
0 0 0 6 0 0 0 0 0 0 0 2 0 4 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 4 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 6 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 5 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 5 5 5 0 0 0 0 0
0 0 0 0 0 4 4 4 0 0 0 5 5 5 0 0 0 0
0 0 0 0 0 0 4 4 4 0 0 0 5 5 5 0 0 0
0 0 0 0 0 0 0 2 2 4 0 0 0 5 5 5 0 6
6 0 0 0 0 0 0 2 2 2 4 0 0 0 5 5 5 6
6 6 0 0 0 0 0 0 2 2 2 4 0 0 0 5 5 6
6 6 6 0 0 0 0 0 0 2 2 2 4 0 0 0 5 5
0 6 6 6 0 0 0 0 0 0 2 2 2 4 0 0 0 5
0 0 6 6 6 0 0 0 0 0 0 2 2 2 4 0 0 0
0 0 0 6 6 6 0 0 0 0 0 4 4 4 2 4 0 0
0 0 0 0 6 6 6 0 5 0 0 0 4 4 4 2 4 0
0 0 0 0 0 6 6 6 5 5 0 0 0 4 4 4 2 4
0 0 0 0 0 0 6 6 5 5 5 0 0 0 4 4 4 2
0 0 0 0 0 0 0 6 6 5 5 5 0 0 0 4 4 4
```
Match: False
Pixels Off: 90
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 55.55555555555557

## Example 3:
Input:
```
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 1 0 0 0 2 2 2 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 7 0 1 0 0 0 0 0 0 0 5 0 2 0 0 0 0 0 0
0 7 7 0 0 0 0 0 0 0 5 0 0 0 2 0 0 0 0 0
0 7 0 7 0 0 0 0 0 5 0 0 0 0 0 2 0 0 0 0
0 0 0 0 7 0 0 0 5 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 7 0 5 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 0 0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 1 1 1 0 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 4 1 1 1 0 2 2 2 0 0 0 0 0
0 7 0 0 0 0 0 0 4 1 1 1 0 2 2 2 0 0 0 0
0 7 7 0 0 0 0 0 0 4 1 1 1 0 2 2 2 0 0 0
0 7 7 7 0 0 0 0 0 0 4 1 1 1 0 2 2 2 0 0
0 0 7 7 7 0 0 0 0 0 0 4 1 1 1 0 2 2 2 0
0 0 0 7 7 7 0 0 0 0 0 0 4 1 1 1 0 2 2 2
0 0 0 0 7 7 7 0 0 0 0 0 0 4 1 1 1 0 2 2
0 0 0 0 0 5 5 5 0 0 0 0 0 0 4 1 1 1 0 2
0 0 0 0 0 0 5 5 5 0 0 0 0 0 0 4 1 1 1 0
0 0 0 0 0 0 0 5 5 5 0 0 0 0 0 0 4 1 1 1
0 0 0 0 0 0 0 0 5 5 5 0 0 0 0 0 0 4 1 1
0 0 0 0 0 0 0 0 0 5 5 5 0 0 0 0 0 0 4 1
```
Match: False
Pixels Off: 99
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 49.5
**Assessment and Strategy**

The initial code correctly identified the core action: projecting diagonal lines downwards and to the right from each non-white source pixel. However, it failed to accurately implement the stopping condition. The results show that the generated lines continued even when they encountered coordinates that corresponded to non-white pixels in the *original input grid*. The lines should have terminated *before* reaching such coordinates.

The strategy is to modify the line-drawing logic to check, at each step of the diagonal projection (`nr`, `nc`), whether the corresponding cell in the *original input grid* (`input_grid[nr, nc]`) is non-white (value > 0). If it is, the line projection from the current source pixel must stop immediately *before* drawing at `(nr, nc)`. If `input_grid[nr, nc]` is white (value == 0), the pixel at `(nr, nc)` in the *output grid* can be colored, and the projection continues to the next diagonal step (`nr+1`, `nc+1`).

**Metrics Analysis**



*code_execution:*
```python
import numpy as np

# Data from the prompt (simplified representation)

# Example 1
input_1 = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,1,1,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0],
    [0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])
output_1_expected = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,2],
    [0,0,0,0,0,0,0,5,0,0,0,0,0,0,5,0,0,0,2,0],
    [0,0,0,0,0,0,5,5,0,0,0,0,0,5,0,0,0,2,0,0],
    [0,0,0,0,0,2,0,0,5,0,0,0,5,0,0,0,2,0,0,0],
    [0,0,0,0,2,2,0,0,0,5,0,5,0,0,0,2,0,0,0,1],
    [0,0,0,1,0,0,2,0,0,0,5,0,0,0,2,0,0,0,1,0],
    [0,0,1,1,0,0,0,2,0,0,5,0,0,2,0,0,0,1,0,0],
    [0,3,0,0,1,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0],
    [3,3,0,0,0,1,0,0,0,2,0,2,0,0,0,1,0,0,0,3],
    [0,0,3,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,3,0],
    [0,0,0,3,0,0,0,1,0,0,2,0,0,1,0,0,0,3,0,0],
    [0,0,0,0,3,0,0,0,1,0,0,0,1,0,0,0,3,0,0,0],
    [0,0,0,0,0,3,0,0,0,1,0,1,0,0,0,3,0,0,0,0],
    [0,0,0,0,0,0,3,0,0,0,1,0,0,0,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,0,0,1,0,0,3,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,3,0,3,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])

# Example 2
input_2 = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0],
    [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,6],
    [6,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,6],
    [6,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,6],
    [6,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0],
    [0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])
output_2_expected = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,0,5,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,5,0,6,0,0,0,0,0,0],
    [0,0,0,0,4,4,4,0,0,0,0,0,6,0,0,0,0,0],
    [0,0,0,0,0,4,0,0,0,0,0,0,0,6,0,0,0,0],
    [0,0,0,0,4,0,2,0,0,0,0,0,0,0,6,0,0,0],
    [0,0,0,4,0,0,0,2,2,0,0,0,0,0,0,6,0,6],
    [6,0,4,0,0,0,0,2,0,0,0,0,0,0,0,0,6,6],
    [6,6,0,0,0,0,0,0,0,0,2,0,0,0,0,4,0,6],
    [6,0,6,0,0,0,0,0,0,2,2,0,0,0,4,0,0,0],
    [0,0,0,6,0,0,0,0,0,0,0,2,0,4,0,0,0,0],
    [0,0,0,0,6,0,0,0,0,0,0,0,4,0,0,0,0,0],
    [0,0,0,0,0,6,0,0,0,0,0,4,4,4,0,0,0,0],
    [0,0,0,0,0,0,6,0,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,5,0,5,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0]
])

# Example 3
input_3 = np.array([
    [0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,0,0,0,2,2,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])
output_3_expected = np.array([
    [0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,0,1,0,0,0,2,2,2,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,7,0,1,0,0,0,0,0,0,0,5,0,2,0,0,0,0,0,0],
    [0,7,7,0,0,0,0,0,0,0,5,0,0,0,2,0,0,0,0,0],
    [0,7,0,7,0,0,0,0,0,5,0,0,0,0,0,2,0,0,0,0],
    [0,0,0,0,7,0,0,0,5,0,0,0,0,0,0,0,2,0,0,0],
    [0,0,0,0,0,7,0,5,0,0,0,0,0,0,0,0,0,2,0,0],
    [0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,2,0],
    [0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,2],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])

results = {}

for i, (input_grid, output_expected) in enumerate(zip(
    [input_1, input_2, input_3],
    [output_1_expected, output_2_expected, output_3_expected]
), 1):
    input_shape = input_grid.shape
    output_shape = output_expected.shape
    input_pixels = np.count_nonzero(input_grid)
    output_pixels = np.count_nonzero(output_expected)
    added_pixels = output_pixels - input_pixels

    results[f'Example {i}'] = {
        'Input Shape': input_shape,
        'Output Shape': output_shape,
        'Input Non-White Pixels': input_pixels,
        'Output Non-White Pixels': output_pixels,
        'Added Pixels': added_pixels
    }

print(results)
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{'Example 1': {'Input Shape': (20, 20), 'Output Shape': (20, 20), 'Input Non-White Pixels': 16, 'Output Non-White Pixels': 72, 'Added Pixels': 56}, 'Example 2': {'Input Shape': (18, 18), 'Output Shape': (18, 18), 'Input Non-White Pixels': 24, 'Output Non-White Pixels': 52, 'Added Pixels': 28}, 'Example 3': {'Input Shape': (20, 20), 'Output Shape': (20, 20), 'Input Non-White Pixels': 15, 'Output Non-White Pixels': 41, 'Added Pixels': 26}}

```
**YAML Facts**


```yaml
Examples: 3
Grid_Size: Variable (e.g., 20x20, 18x18)
Colors: white(0), blue(1), red(2), green(3), yellow(4), gray(5), magenta(6), orange(7)

Input_Objects:
  - Type: Contiguous shapes or individual pixels.
  - Colors: Various non-white colors.
  - Property: Source for diagonal lines.
  - Persistence: All input objects remain unchanged in the output grid.

Output_Objects:
  - Includes all input objects.
  - Additional pixels forming diagonal lines originating from input pixels.

Actions:
  - Create an output grid identical to the input grid.
  - For each non-white pixel `P` at (`r`, `c`) with color `C` in the input grid:
    - Action: Emit a diagonal line trace.
    - Start_Trace_Position: (`r+1`, `c+1`).
    - Direction: Downwards and to the right (+1 row, +1 column per step).
    - Color: `C`.
    - Trace_Step: For current trace position (`tr`, `tc`):
      - Condition_Check: Examine the pixel at (`tr`, `tc`) in the *original input grid*.
      - If `input_grid[tr, tc]` is white (0):
          - Color the pixel at (`tr`, `tc`) in the *output grid* with color `C`.
          - Continue trace to (`tr+1`, `tc+1`).
      - If `input_grid[tr, tc]` is non-white (> 0):
          - Stop the trace for pixel `P` immediately. Do *not* color (`tr`, `tc`).
    - Termination_Condition_Boundary: Stop trace if `tr` or `tc` goes outside grid bounds.

Relationships:
  - Added diagonal lines originate *from* input non-white pixels.
  - The path of a diagonal line is constrained by grid boundaries and the positions of *other* non-white pixels in the *input grid*.
  - The final output grid combines the original input pixels and the correctly terminated diagonal line pixels.
```


**Natural Language Program**

1.  Create an output grid initialized as an exact copy of the input grid.
2.  Iterate through each cell (`r`, `c`) of the *input* grid.
3.  If the cell at (`r`, `c`) in the *input* grid contains a non-white color `C`:
    a.  Define the starting trace position: `trace_r = r + 1`, `trace_c = c + 1`.
    b.  Start a loop that continues as long as `trace_r` is less than the grid height AND `trace_c` is less than the grid width.
    c.  Inside the loop, check the cell at (`trace_r`, `trace_c`) in the *original input grid*.
    d.  If `input_grid[trace_r, trace_c]` is white (0):
        i.  Set the color of the cell at (`trace_r`, `trace_c`) in the *output* grid to `C`.
        ii. Update the trace position: `trace_r = trace_r + 1`, `trace_c = trace_c + 1`.
    e.  If `input_grid[trace_r, trace_c]` is *not* white (i.e., it belongs to an original object in the input):
        i.  Terminate the loop for the current source pixel (`r`, `c`) immediately (break out of the loop started in step 3b).
    f.  (Loop continues from step 3b if not terminated).
4.  After iterating through all source cells (`r`, `c`) in the input grid, return the final output grid.
