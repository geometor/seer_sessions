{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nThe transformation identifies a background/noise color and a set of N (where N is expected to be even) distinct, large 'primary' colored shapes. \nThese primary shapes are divided into Target shapes (those containing the noise color within their bounding box) and potentially Source shapes (the remaining primary shapes).\nIf the number of Targets equals the number of non-Target primary shapes, they are paired based on spatial order (e.g., top-left Target with top-left Source).\nIf not (e.g., all primary shapes are Targets), Source colors are derived from smaller, non-primary, non-noise shapes/patterns found elsewhere in the grid, again paired spatially/ordered relative to the Targets.\nThe output is created by taking the bounding box area of each Target shape from the input, replacing only the pixels matching the noise color within that area with the corresponding Source color, and assembling these modified areas into a new grid, preserving the Targets' original relative spatial arrangement.\n\"\"\"\n\n# --- Helper Function: Find Objects ---\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n    Uses Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'coords' (set of (r, c) tuples),\n              'bbox' (min_r, max_r, min_c, max_c), 'size', and 'avg_pos' (average row, col). \n              Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n        \n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n                sum_r, sum_c = 0, 0\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    sum_r += row\n                    sum_c += col\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                obj_size = len(coords)\n                if obj_size > 0:\n                    avg_r = sum_r / obj_size\n                    avg_c = sum_c / obj_size\n                    objects.append({\n                        'color': int(color), # Convert color to int\n                        'coords': coords, # Keep coords as set\n                        'bbox': tuple(map(int, (min_r, max_r, min_c, max_c))), # Convert bbox to tuple of ints\n                        'size': obj_size,\n                        'avg_pos': (avg_r, avg_c) # Store average position\n                    })\n    return objects\n\n# --- Helper Function: Determine Noise Color ---\ndef determine_noise_color(grid, primary_shapes):\n    \"\"\"\n    Determines the noise/background color based on frequency within primary shape bounding boxes.\n\n    Args:\n        grid (np.array): The input grid.\n        primary_shapes (list): List of primary shape objects.\n\n    Returns:\n        int: The determined noise color. Returns -1 if unable to determine.\n    \"\"\"\n    if grid.size == 0 or not primary_shapes:\n        return -1 \n\n    counts_inside_primary_bboxes = defaultdict(int)\n    primary_colors = set(obj['color'] for obj in primary_shapes)\n\n    for obj in primary_shapes:\n        min_r, max_r, min_c, max_c = obj['bbox']\n        # Check pixels *within* the bounding box\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                 pixel_color = int(grid[r,c])\n                 # Count only if the pixel is not part of ANY primary shape\n                 is_part_of_any_primary = False\n                 # A faster check: count only if pixel color is NOT one of the primary colors\n                 if pixel_color not in primary_colors:\n                      counts_inside_primary_bboxes[pixel_color] += 1\n                 # More precise (slower): check coords of all primary shapes\n                 # for p_shape in primary_shapes:\n                 #     if (r, c) in p_shape['coords']:\n                 #         is_part_of_any_primary = True\n                 #         break\n                 # if not is_part_of_any_primary:\n                 #      counts_inside_primary_bboxes[pixel_color] += 1\n\n    if counts_inside_primary_bboxes:\n        # The color most frequently found *inside* primary bboxes (excluding primary colors) is likely the noise\n        noise_color = max(counts_inside_primary_bboxes, key=counts_inside_primary_bboxes.get)\n        return noise_color\n    else:\n        # Fallback: If no non-primary colors found inside, maybe noise is one of the primary colors? Unlikely for this task.\n        # Or maybe the most frequent color overall?\n        colors, counts = np.unique(grid, return_counts=True)\n        if len(colors) > 0:\n            # Exclude primary colors from consideration if possible\n            valid_indices = [i for i, c in enumerate(colors) if c not in primary_colors]\n            if valid_indices:\n                filtered_counts = counts[valid_indices]\n                filtered_colors = colors[valid_indices]\n                if len(filtered_counts)>0:\n                    return int(filtered_colors[np.argmax(filtered_counts)])\n            # If only primary colors exist or fallback needed, return most frequent overall\n            return int(colors[np.argmax(counts)])\n        return -1 # Cannot determine\n\n# --- Main Transformation Function ---\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying target and source frames,\n    filling noise in target frames using source frame colors/derived colors, \n    and reassembling the modified target frames.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return []\n\n    # 1. Find all distinct objects\n    all_objects = find_objects(grid)\n    if not all_objects: \n        return grid.tolist() \n\n    # 2. Identify Primary Shapes (e.g., 4 largest non-background)\n    # First, guess background color (most frequent overall) to exclude it\n    colors, counts = np.unique(grid, return_counts=True)\n    potential_bg_color = -1\n    if len(colors) > 0:\n        potential_bg_color = int(colors[np.argmax(counts)])\n    \n    # Filter out potential background and sort by size\n    non_bg_objects = [obj for obj in all_objects if obj['color'] != potential_bg_color]\n    non_bg_objects.sort(key=lambda o: o['size'], reverse=True)\n    \n    # Assume N=4 primary shapes based on examples\n    num_primary = 4 \n    if len(non_bg_objects) < num_primary:\n         # Fallback: use all non-background objects if less than N found\n         # Or maybe N should be the largest even number <= len(non_bg_objects)?\n         num_primary = len(non_bg_objects) // 2 * 2 # Largest even number <= available\n         if num_primary == 0 and len(non_bg_objects) > 0: # Handle case of 1 non-bg object\n              primary_shapes = non_bg_objects[:1] # Take the single one? Problem spec implies pairs.\n              # Let's return original if we can't get at least 2 primary shapes\n              return grid.tolist()\n         elif num_primary == 0:\n              return grid.tolist() # No non-bg objects\n\n    primary_shapes = non_bg_objects[:num_primary]\n    primary_shapes.sort(key=lambda o: (o['bbox'][0], o['bbox'][2])) # Sort by position\n\n    # 3. Identify Noise Color using primary shapes\n    noise_color = determine_noise_color(grid, primary_shapes)\n    if noise_color == -1: \n         return grid.tolist() # Failed to determine noise\n\n    # Re-filter all objects, excluding the *confirmed* noise color\n    all_non_noise_objects = [obj for obj in all_objects if obj['color'] != noise_color]\n    \n    # Re-identify primary shapes among all non-noise objects by matching color and bbox/position\n    # This ensures we didn't accidentally filter them if noise was misidentified initially\n    primary_shape_identifiers = set((o['color'], o['bbox']) for o in primary_shapes)\n    current_primary_shapes = []\n    other_non_noise_objects = []\n    for obj in all_non_noise_objects:\n        if (obj['color'], obj['bbox']) in primary_shape_identifiers:\n            current_primary_shapes.append(obj)\n        else:\n            other_non_noise_objects.append(obj) # These will be source components in Case 2\n            \n    if len(current_primary_shapes) != num_primary:\n        # This shouldn't happen if noise detection is okay, but indicates an issue.\n        return grid.tolist()\n        \n    current_primary_shapes.sort(key=lambda o: (o['bbox'][0], o['bbox'][2])) # Ensure sorted\n\n    # 4. Identify Target Shapes among primary shapes\n    target_shapes = []\n    non_target_primary_shapes = []\n    for obj in current_primary_shapes:\n        min_r, max_r, min_c, max_c = obj['bbox']\n        has_noise_inside = False\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                # Check if pixel is noise AND not part of the object itself\n                if grid[r, c] == noise_color and (r, c) not in obj['coords']:\n                    # More careful check: ensure the noise isn't part of *another* primary shape\n                    is_part_of_other_primary = False\n                    for other_p in current_primary_shapes:\n                         if other_p != obj and (r,c) in other_p['coords']:\n                             is_part_of_other_primary = True\n                             break\n                    if not is_part_of_other_primary:\n                         has_noise_inside = True\n                         break\n            if has_noise_inside:\n                break\n        if has_noise_inside:\n            target_shapes.append(obj)\n        else:\n            non_target_primary_shapes.append(obj)\n\n    target_shapes.sort(key=lambda o: (o['bbox'][0], o['bbox'][2]))\n    non_target_primary_shapes.sort(key=lambda o: (o['bbox'][0], o['bbox'][2]))\n\n    # 5. Determine Source Colors & Pairing\n    paired_targets = [] # List of tuples: (target_obj, source_color)\n\n    if len(target_shapes) == len(non_target_primary_shapes) and len(target_shapes) > 0:\n        # Case 1: Pair targets with non-target primary shapes (like Ex 1)\n        for i in range(len(target_shapes)):\n            target = target_shapes[i]\n            source = non_target_primary_shapes[i]\n            paired_targets.append((target, source['color']))\n    elif len(target_shapes) == num_primary and num_primary > 0:\n        # Case 2: All primary shapes are targets (like Ex 2)\n        # Source colors derived from 'other_non_noise_objects'\n        \n        source_components = other_non_noise_objects\n        source_colors_data = defaultdict(list) # Store coords for each potential source color\n        for comp in source_components:\n            source_colors_data[comp['color']].extend(list(comp['coords']))\n            \n        unique_source_colors = sorted(list(source_colors_data.keys()))\n\n        if len(unique_source_colors) == len(target_shapes):\n            # Calculate average position for each source color\n            avg_pos_by_color = {}\n            for color, coords_list in source_colors_data.items():\n                if coords_list:\n                    avg_r = sum(r for r, c in coords_list) / len(coords_list)\n                    avg_c = sum(c for r, c in coords_list) / len(coords_list)\n                    avg_pos_by_color[color] = (avg_r, avg_c)\n                else:\n                     avg_pos_by_color[color] = (float('inf'), float('inf')) # Should not happen\n\n            # Sort source colors based on their average position\n            sorted_source_colors = sorted(unique_source_colors, key=lambda c: avg_pos_by_color[c])\n\n            # Pair sorted targets with sorted source colors\n            for i in range(len(target_shapes)):\n                paired_targets.append((target_shapes[i], sorted_source_colors[i]))\n        else:\n            # Failed to find matching number of source colors\n            return grid.tolist()\n            \n    else:\n        # Ambiguous case or error in logic (e.g., odd number of targets/sources)\n        return grid.tolist()\n\n    # 6. Modify Target Shapes\n    modified_targets_data = []\n    for target, source_color in paired_targets:\n        min_r, max_r, min_c, max_c = target['bbox']\n        \n        # Extract subgrid based on target's bounding box from the *original* grid\n        subgrid_original = grid[min_r:max_r+1, min_c:max_c+1]\n        modified_subgrid = subgrid_original.copy()\n\n        # Replace ONLY noise pixels within this subgrid copy\n        noise_mask = (modified_subgrid == noise_color)\n        modified_subgrid[noise_mask] = source_color\n\n        modified_targets_data.append({\n            'bbox': target['bbox'], # Store original bbox for layout calculation\n            'subgrid': modified_subgrid\n        })\n\n    # 7. Assemble Output Grid\n    if not modified_targets_data:\n        return grid.tolist() \n\n    # Calculate relative positions and final grid size based on target bboxes\n    min_target_r = min(t['bbox'][0] for t in modified_targets_data)\n    min_target_c = min(t['bbox'][2] for t in modified_targets_data)\n\n    max_output_r = 0\n    max_output_c = 0\n    output_layout = []\n\n    for data in modified_targets_data:\n        bbox = data['bbox']\n        subgrid = data['subgrid']\n        h, w = subgrid.shape\n        # Position relative to the top-leftmost target's origin\n        rel_r = bbox[0] - min_target_r\n        rel_c = bbox[2] - min_target_c\n\n        output_layout.append({\n            'rel_r': rel_r, 'rel_c': rel_c, 'subgrid': subgrid, 'h': h, 'w': w\n        })\n        # Update max dimensions needed\n        max_output_r = max(max_output_r, rel_r + h)\n        max_output_c = max(max_output_c, rel_c + w)\n\n    # Create and populate the output grid. Initialize with 0 (white).\n    output_grid = np.zeros((max_output_r, max_output_c), dtype=int) \n\n    for layout_info in output_layout:\n        r, c = layout_info['rel_r'], layout_info['rel_c']\n        h, w = layout_info['h'], layout_info['w']\n        subgrid = layout_info['subgrid']\n        # Place the modified subgrid onto the output grid\n        output_grid[r:r+h, c:c+w] = subgrid\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 38396,
    "candidates_token_count": 4049,
    "total_token_count": 42445,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 52.095418,
  "retries": 1
}