
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 1 8 0 0 8
0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8
0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 7 6 7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 6 0 6 7 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 6 0 0 0 6 7 0 0 0 0 0 0 0 0 0
0 0 0 7 6 0 0 0 0 0 6 7 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0 0 6 7 0 0 1 8 8 8 8
0 0 0 0 0 3 3 0 0 0 0 0 6 7 0 1 8 0 1 8
0 0 0 0 3 0 0 3 0 0 0 0 0 6 0 1 8 0 1 8
0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 1 8 0 1 8
0 0 3 0 0 0 0 0 0 3 0 0 0 0 0 1 8 0 1 8
0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 1 8 0 1 8
0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 1 8 0 1 8
0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 1 8 1 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 6 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 8 0 0 4 4 4 0 0 0 0 0
0 0 0 0 1 0 8 0 0 0 4 6 6 6 0 0 0 0
0 0 0 0 0 8 0 0 0 0 4 6 0 0 6 0 0 0
0 0 0 0 0 0 8 0 0 0 4 6 0 0 0 6 0 0
0 0 0 0 0 0 0 8 0 0 4 6 0 0 0 0 6 0
0 0 0 0 0 0 0 0 0 0 4 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 6 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 7 0 0 0
0 0 0 0 0 0 4 2 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 7 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0
0 8 1 1 1 1 1 1 1 1 1 1 1 1 0
0 8 1 0 0 0 0 0 0 0 0 0 8 1 0
0 8 1 0 7 7 7 7 7 7 7 0 8 1 0
0 8 1 0 7 0 0 0 0 0 0 7 8 1 0
0 8 1 0 7 0 4 2 2 2 7 0 8 1 0
0 8 1 0 7 0 0 0 0 7 0 0 8 1 0
0 8 1 0 7 0 0 0 7 0 0 0 8 1 0
0 8 1 0 7 0 0 7 0 0 0 0 8 1 0
0 8 1 0 7 7 7 0 0 0 0 0 8 1 0
0 8 1 8 8 8 8 8 8 8 8 8 8 1 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception**: The task involves transforming an input grid containing scattered, single-colored pixels (or small groups of pixels) on a white background into an output grid where these initial pixels have "expanded" outwards, filling the surrounding white space. The expansion seems to follow specific rules:
    *   Each non-white pixel in the input acts as a "seed".
    *   These seeds expand into adjacent (cardinal directions: up, down, left, right) white pixels.
    *   The expansion continues iteratively until no more white pixels can be filled.
    *   The expansion from one seed stops when it meets the boundary of the grid, an existing non-white pixel from the input, or the expansion area of another seed.
    *   Crucially, the color used for expansion (the "fill color") is usually the same as the seed color, *except* for magenta (6) seeds, which expand using orange (7). All other colors (blue, red, green, yellow, gray, orange, azure, maroon) expand using their own color.
    *   The process appears to be simultaneous for all seeds, meaning expansions happen in parallel, respecting each other's boundaries as they form.

*   **Facts**:
    
```yaml
    objects:
      - type: grid
        properties:
          height: variable (e.g., 20, 18, 15)
          width: variable (e.g., 20, 18, 15)
          pixels: represented by integers 0-9
      - type: pixel
        properties:
          color: integer 0-9 (white, blue, red, green, yellow, gray, magenta, orange, azure, maroon)
          location: (row, column) coordinates
      - type: seed_pixel
        description: A non-white (color 1-9) pixel in the input grid.
        properties:
          color: integer 1-9
          location: (row, column)
      - type: expansion_area
        description: The region filled by the expansion process originating from one or more seed pixels of the same effective fill color.
        properties:
          fill_color: integer 1-9 (determined by seed color)

    relationships:
      - type: adjacency
        description: Pixels can be adjacent cardinally (sharing an edge) or diagonally (sharing a corner). Cardinal adjacency is relevant for expansion.
      - type: boundary
        description: Expansion stops at grid edges or pixels belonging to a different expansion area or original non-white pixels.

    actions:
      - name: identify_seeds
        description: Find all pixels in the input grid with colors 1 through 9.
      - name: determine_fill_color
        description: Assign a fill color to each seed. Magenta (6) seeds get orange (7). All other seeds get their own color.
      - name: expand_simultaneously
        description: Iteratively fill adjacent white (0) pixels with the determined fill color.
        details:
          - Start with the seed pixels considered filled.
          - In each step, identify all white pixels cardinally adjacent to any currently filled pixel.
          - For each identified white pixel, check the fill colors of its adjacent filled neighbors.
          - If all adjacent filled neighbors belong to the *same* fill color group, color the white pixel with that fill color.
          - If adjacent filled neighbors belong to *different* fill color groups, the white pixel remains white (boundary).
          - Repeat until no more white pixels can be colored in a step.

    state_changes:
      - description: White (0) pixels in the input grid are changed to non-zero colors based on the expansion rules.
      - description: Original non-white pixels remain unchanged in color and location.
    ```


*   **Natural Language Program**:
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify all non-white pixels (colors 1-9) in the input grid. These are the initial "seed" pixels.
    3.  Create a mapping of seed locations to their "fill color". If a seed pixel has color magenta (6), its fill color is orange (7). Otherwise, its fill color is its own color.
    4.  Create a set of "active" pixels, initially containing the locations of all seed pixels.
    5.  Start an iterative expansion process:
        a.  Initialize an empty set for `next_active_pixels` and a dictionary `potential_fills` mapping coordinates `(r, c)` to a set of fill colors proposing to fill that coordinate.
        b.  For each pixel location `(r, c)` in the `active` set:
            i.  Get the fill color `fill_c` associated with this active pixel (determined in step 3).
            ii. Check its four cardinal neighbors (up, down, left, right).
            iii. For each neighbor `(nr, nc)` that is within the grid boundaries and is currently white (0) in the output grid:
                *   Add `fill_c` to the set associated with `(nr, nc)` in the `potential_fills` dictionary. If the key `(nr, nc)` doesn't exist, create it with a new set containing `fill_c`.
        c.  Iterate through the `potential_fills` dictionary:
            i.  For each coordinate `(r, c)` and its associated set of proposed fill colors `colors_set`:
                *   If `colors_set` contains exactly one color `fill_c`:
                    *   Change the color of the pixel at `(r, c)` in the output grid to `fill_c`.
                    *   Add `(r, c)` to the `next_active_pixels` set.
        d.  If `next_active_pixels` is empty, the expansion is complete; break the loop.
        e.  Otherwise, update `active` to be `next_active_pixels` and continue to the next iteration (step 5a).
    6.  Return the final state of the output grid.
```python
import numpy as np

"""
Identifies non-white pixels (seeds) in the input grid.
Determines a "fill color" for each seed: magenta (6) seeds use orange (7), others use their own color.
Simultaneously expands each seed's fill color into adjacent white (0) pixels iteratively.
Expansion stops at grid boundaries, existing non-white pixels, or where expansions from different fill colors would meet.
The process continues until no more white pixels can be filled.
"""

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by expanding seed pixels into adjacent white space.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # 1. Identify seeds and determine their fill colors
    # We also need a way to track the fill color associated with *any* filled cell,
    # not just the original seeds, to correctly propagate colors.
    # fill_color_grid stores the 'effective' color (magenta->orange) for propagation.
    fill_color_grid = np.zeros_like(input_grid, dtype=int)
    initial_seeds = []
    for r in range(height):
        for c in range(width):
            color = input_grid[r, c]
            if color != 0:
                fill_color = 7 if color == 6 else color
                initial_seeds.append((r, c))
                fill_color_grid[r, c] = fill_color # Store the fill color

    # 2. Initialize the set of active coordinates (pixels filled in the previous step)
    active_coords = set(initial_seeds)

    # 3. Iterative expansion process
    while active_coords:
        # Dictionary to store potential fills for white cells in the next step.
        # Key: (r, c) of a white cell
        # Value: set of fill colors proposed by neighbors
        potential_fills = {}
        
        # Set to store coordinates that get filled in *this* iteration
        next_active_coords = set()

        # a. Check neighbors of currently active pixels
        for r, c in active_coords:
            # Get the fill color associated with the *current* active pixel
            # This ensures correct propagation from newly filled areas
            current_fill_color = fill_color_grid[r, c]
            if current_fill_color == 0: # Should not happen if logic is correct, but safety check
                continue

            # Check cardinal neighbors (up, down, left, right)
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc

                # Check if neighbor is within bounds and is white
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr, nc] == 0:
                    # Add the current fill color to the set of potential fills for this neighbor
                    potential_fills.setdefault((nr, nc), set()).add(current_fill_color)

        # b. Process potential fills
        made_change_this_iteration = False
        for (r, c), colors_set in potential_fills.items():
            # If exactly one fill color is proposed for this white cell
            if len(colors_set) == 1:
                fill_c = list(colors_set)[0]
                # Check if the cell is still white (it should be based on the logic above)
                if output_grid[r, c] == 0:
                    output_grid[r, c] = fill_c
                    fill_color_grid[r, c] = fill_c # Update the fill color grid too
                    next_active_coords.add((r, c))
                    made_change_this_iteration = True # Mark that a change occurred

        # c. Prepare for next iteration or break
        if not made_change_this_iteration:
            break # No changes means expansion is complete

        active_coords = next_active_coords # Update active set for the next round

    # 4. Return the final grid
    return output_grid
```
```python
import numpy as np

"""
Identifies non-white pixels (seeds) in the input grid.
Determines a "fill color" for each seed: magenta (6) seeds use orange (7) as their fill color, all other seeds use their own color.
Simultaneously expands each seed's fill color into adjacent white (0) pixels iteratively.
Expansion fills a white pixel if and only if all its adjacent non-white neighbors share the exact same fill color.
Expansion stops at grid boundaries, original non-white pixels, or where expansions from different fill colors would meet (leaving the conflicting pixel white).
The process continues until no more white pixels can be filled in a full iteration. Original seed pixels retain their original visual color in the final output.
"""

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by expanding seed pixels into adjacent white space
    based on simultaneous expansion rules.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    height, width = input_grid.shape
    
    # 1. Initialize output grid (copy of input) and fill color grid
    output_grid = np.copy(input_grid)
    fill_color_grid = np.zeros_like(input_grid, dtype=int)

    # 2. Populate fill_color_grid based on initial seeds
    for r in range(height):
        for c in range(width):
            original_color = input_grid[r, c]
            if original_color != 0:
                # Determine the fill color for propagation
                fill_color = 7 if original_color == 6 else original_color
                fill_color_grid[r, c] = fill_color
                # Ensure original color is preserved in the output grid initially
                output_grid[r, c] = original_color 

    # 3. Iterative simultaneous expansion
    while True:
        # Dictionary to store updates for this iteration: {(r, c): fill_color}
        pending_updates = {}
        made_change_this_iteration = False

        # Iterate through every cell to check if it's a white cell ready to be filled
        for r in range(height):
            for c in range(width):
                # Consider only white cells in the current output_grid state
                if output_grid[r, c] == 0:
                    neighbor_fills = set()
                    has_non_white_neighbor = False

                    # Check cardinal neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc

                        # Check bounds
                        if 0 <= nr < height and 0 <= nc < width:
                            neighbor_output_color = output_grid[nr, nc]
                            # If neighbor is not white
                            if neighbor_output_color != 0:
                                has_non_white_neighbor = True
                                # Get the fill color associated with this neighbor
                                neighbor_fill_color = fill_color_grid[nr, nc]
                                if neighbor_fill_color != 0: # Should always be non-zero if output is non-zero
                                     neighbor_fills.add(neighbor_fill_color)

                    # If the white cell has non-white neighbors and ALL of them
                    # propose the SAME single fill color
                    if has_non_white_neighbor and len(neighbor_fills) == 1:
                        single_fill_color = list(neighbor_fills)[0]
                        # Store the planned update (don't apply yet)
                        pending_updates[(r, c)] = single_fill_color
        
        # If no updates were determined in this pass, expansion is complete
        if not pending_updates:
            break

        # Apply all collected updates simultaneously for this step
        for (r, c), fill_c in pending_updates.items():
             # Check if the cell is still white before updating 
             # (Might be redundant with the check at the start of the loop, but safe)
            if output_grid[r, c] == 0: 
                output_grid[r, c] = fill_c
                fill_color_grid[r, c] = fill_c # Also update the fill color grid for next iteration
                made_change_this_iteration = True

        # Double check if any change was actually made (if all pending updates were for already filled cells somehow)
        if not made_change_this_iteration and pending_updates :
             # This case might indicate an issue, but logically, if pending_updates is not empty, 
             # made_change_this_iteration should become True. Let's break to prevent infinite loops.
             # print("Warning: Pending updates found but no change made. Breaking.") # Optional debug
             break


    # 4. Final Check: Ensure original seed pixels retain original color visually
    #    This step is needed because the expansion might overwrite an original seed
    #    pixel if the expansion color (e.g., orange for magenta) is different.
    #    We prioritize the original input color for visualization.
    for r in range(height):
        for c in range(width):
            if input_grid[r, c] != 0:
                output_grid[r, c] = input_grid[r, c]


    return output_grid
```
