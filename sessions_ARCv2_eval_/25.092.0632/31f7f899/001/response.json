{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms the input grid based on vertical color propagation towards a horizontal separator line.\n\n1. Identifies the background color (azure, 8) and the separator color (magenta, 6).\n2. Locates the row index of the horizontal magenta (6) separator line.\n3. Iterates through each column of the grid.\n4. For each column:\n    a. Finds the non-background, non-separator color closest to the separator line from above. If found, propagates this color downwards, replacing background pixels, until the row just above the separator line.\n    b. Finds the non-background, non-separator color closest to the separator line from below. If found, propagates this color upwards, replacing background pixels, until the row just below the separator line.\n5. The separator line itself remains unchanged.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the vertical color propagation transformation.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Define known colors\n    background_color = 8\n    separator_color = 6\n\n    # Initialize output_grid as a copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    height, width = output_grid.shape\n\n    # Find the separator row\n    separator_row = -1\n    for r in range(height):\n        if np.all(input_grid[r, :] == separator_color) or separator_color in input_grid[r, :]: # Check if the whole row or part of the row contains the separator color\n             # More robust check: find the first row containing the separator color\n             rows_with_separator = np.where(np.any(input_grid == separator_color, axis=1))[0]\n             if len(rows_with_separator) > 0:\n                 separator_row = rows_with_separator[0] # Assume the first occurrence is the separator line\n                 break\n    \n    if separator_row == -1:\n        # Handle cases where no separator is found (e.g., return input?)\n        # For this specific task based on examples, a separator is always expected.\n        # If not found, it might indicate an issue or an edge case not covered.\n        # Let's assume it's always present based on training data.\n        print(\"Warning: Separator row not found. Returning original grid.\")\n        return input_grid\n\n\n    # Iterate through each column\n    for c in range(width):\n        # --- Process Above Separator ---\n        color_above = None\n        source_row_above = -1\n        # Scan downwards from just above the separator to the top\n        for r in range(separator_row - 1, -1, -1):\n            pixel_color = input_grid[r, c]\n            if pixel_color != background_color and pixel_color != separator_color:\n                color_above = pixel_color\n                source_row_above = r\n                break # Found the closest color source above\n\n        # If a color source was found above, propagate it downwards\n        if color_above is not None:\n            # Iterate from the source row up to (but not including) the separator row\n            # In the original description, it says propagate *downwards*. Let's adjust.\n            # Propagate from the found source row towards the separator\n            # It should fill the background pixels between the source and the separator\n            for r_fill in range(source_row_above + 1, separator_row):\n                 if output_grid[r_fill, c] == background_color:\n                     output_grid[r_fill, c] = color_above\n            # Correction: The natural language said \"Iterate from r = source_row_above up to separator_row - 1\".\n            # Let's re-read: \"Propagate this color downwards, replacing background pixels, until the row just above the separator line.\"\n            # This means fill from source_row_above + 1 to separator_row - 1.\n            # Let's rethink the loop based on the *output* examples.\n            # Example 1, col 1: gray(5) at (2,1) propagates down to row 5.\n            # Example 1, col 6: red(2) at (3,6) propagates down to row 5.\n            # Example 1, col 8: blue(1) at (5,8) propagates down to row 5.\n            # It seems the color *below* the source gets filled.\n            # Let's try filling from source_row_above + 1 to separator_row - 1\n            for r_fill in range(source_row_above + 1, separator_row):\n                 if output_grid[r_fill, c] == background_color:\n                     output_grid[r_fill, c] = color_above\n\n\n        # --- Process Below Separator ---\n        color_below = None\n        source_row_below = -1\n        # Scan upwards from just below the separator to the bottom\n        for r in range(separator_row + 1, height):\n            pixel_color = input_grid[r, c]\n            if pixel_color != background_color and pixel_color != separator_color:\n                color_below = pixel_color\n                source_row_below = r\n                break # Found the closest color source below\n\n        # If a color source was found below, propagate it upwards\n        if color_below is not None:\n            # Propagate upwards from the source row towards the separator\n            # Fill background pixels between the source and the separator\n            # Iterate from source_row_below - 1 down to separator_row + 1\n            for r_fill in range(source_row_below - 1, separator_row, -1):\n                 if output_grid[r_fill, c] == background_color:\n                     output_grid[r_fill, c] = color_below\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4079,
    "candidates_token_count": 1393,
    "total_token_count": 5472,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.334341,
  "retries": 1
}