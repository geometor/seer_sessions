{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the transformation rule based on the set of unique non-white colors present in the input grid.\n\n1.  **Pattern Replacement Rule (Example 3):**\n    - Trigger: If the unique non-white colors are exactly {Blue(1), Red(2), Yellow(4), Orange(7), Azure(8)}.\n    - Action: Initialize an output grid with white(0). For each Blue pixel in the input, draw an Orange '+' pattern `[[0, 7, 0], [7, 0, 7], [0, 7, 0]]` centered at its location in the output. For each Yellow or Azure pixel, draw a Red '+' pattern `[[0, 2, 0], [2, 0, 2], [0, 2, 0]]` centered at its location. Input Red and Orange pixels are ignored. Patterns overwrite previous values if they overlap.\n\n2.  **Largest Object Recolor Rule (Example 1):**\n    - Trigger: If the unique non-white colors are exactly {Blue(1), Red(2), Azure(8)} AND there exists at least one single-pixel non-white object in the input grid.\n    - Action: Find all single-pixel non-white objects. Determine the minimum color value among these single pixels (`min_single_color`). Find the largest connected non-white object in the input grid. Initialize an output grid with white(0). Color the pixels corresponding to the largest object's shape with `min_single_color`.\n\n3.  **Pixel Swap Rule (Examples 2 & 4):**\n    - Trigger: If the unique non-white colors match specific sets not covered by rules 1 or 2.\n    - Sub-Rule (Example 4): If colors are {Blue(1), Red(2), Azure(8)} and no single-pixel objects exist.\n        - Action: Create an output grid by replacing Azure(8) with White(0), swapping Blue(1) with Red(2), and keeping other colors unchanged.\n    - Sub-Rule (Example 2): If colors are {Red(2), Yellow(4), Magenta(6), Orange(7), Azure(8)}.\n        - Action: Create an output grid by replacing Azure(8) with White(0), swapping Red(2) with Yellow(4), swapping Magenta(6) with Orange(7), and keeping other colors unchanged.\n\n4.  **Default Rule:** If none of the above conditions are met, return the input grid unchanged.\n\nHelper functions are used to find objects, identify single pixels, find the largest object, and apply patterns.\n\"\"\"\n\ndef find_objects(grid, colors=None, connectivity=1):\n    \"\"\"\n    Finds connected objects of specified colors in the grid.\n    Uses Breadth-First Search (BFS).\n    Connectivity: 1 for 4-way (N, S, E, W), 2 for 8-way (includes diagonals).\n    \"\"\"\n    if colors is None:\n        # Find objects of any non-background (0) color\n        colors = set(np.unique(grid)) - {0}\n    if not colors:\n        return []\n\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in colors and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_color = color\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Define neighbors based on connectivity\n                    if connectivity == 1:\n                        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                    else: # connectivity == 2 (8-way)\n                         neighbors = [\n                            (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1),\n                            (row - 1, col - 1), (row - 1, col + 1), (row + 1, col - 1), (row + 1, col + 1)\n                         ]\n                         \n                    for nr, nc in neighbors:\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef get_single_pixel_objects(grid):\n    \"\"\"Identifies non-zero pixels with no non-zero neighbors (4-way).\"\"\"\n    objects = find_objects(grid, connectivity=1)\n    single_pixel_objects = [obj for obj in objects if len(obj['coords']) == 1]\n    return single_pixel_objects\n    # Alternative direct check:\n    # rows, cols = grid.shape\n    # single_pixels = []\n    # for r in range(rows):\n    #     for c in range(cols):\n    #         color = grid[r, c]\n    #         if color != 0:\n    #             is_single = True\n    #             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n    #                 nr, nc = r + dr, c + dc\n    #                 if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] != 0:\n    #                     is_single = False\n    #                     break\n    #             if is_single:\n    #                 single_pixels.append({'color': color, 'coords': {(r, c)}})\n    # return single_pixels\n\n\ndef find_largest_object(grid, ignore_color=0):\n    \"\"\"Finds the largest connected object (most pixels) ignoring a specific color.\"\"\"\n    valid_colors = set(np.unique(grid)) - {ignore_color}\n    if not valid_colors:\n      return None # No non-ignored objects\n\n    objects = find_objects(grid, colors=valid_colors, connectivity=1)\n    if not objects:\n        return None\n\n    largest_obj = max(objects, key=lambda obj: len(obj['coords']))\n    return largest_obj\n\ndef apply_pattern(output_grid, center_r, center_c, pattern):\n    \"\"\"Applies a 3x3 pattern centered at (center_r, center_c) on the output grid.\"\"\"\n    rows, cols = output_grid.shape\n    pattern_rows, pattern_cols = pattern.shape\n    \n    # Calculate pattern offsets from center (assuming 3x3)\n    offset_r = pattern_rows // 2\n    offset_c = pattern_cols // 2\n\n    for pr in range(pattern_rows):\n        for pc in range(pattern_cols):\n            pattern_val = pattern[pr, pc]\n            if pattern_val == 0: # Skip background color in pattern\n                continue\n\n            # Calculate target coordinates in the output grid\n            target_r = center_r + (pr - offset_r)\n            target_c = center_c + (pc - offset_c)\n\n            # Check boundaries\n            if 0 <= target_r < rows and 0 <= target_c < cols:\n                output_grid[target_r, target_c] = pattern_val\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules derived from examples.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Determine unique non-white colors\n    original_colors = set(np.unique(input_np)) - {0}\n\n    # Rule 1 Check: Pattern Replacement (Example 3)\n    if original_colors == {1, 2, 4, 7, 8}:\n        output_grid = np.zeros_like(input_np)\n        # Define patterns (Orange '+' for Blue, Red '+' for Yellow/Azure)\n        p_orange = np.array([[0, 7, 0], [7, 0, 7], [0, 7, 0]])\n        p_red = np.array([[0, 2, 0], [2, 0, 2], [0, 2, 0]])\n        \n        # Apply patterns - process yellow/azure first, then blue to ensure blue overwrites correctly if needed?\n        # The order shouldn't matter if patterns don't overlap center points. Let's stick to input order.\n        for r in range(rows):\n            for c in range(cols):\n                color = input_np[r, c]\n                if color == 1: # Blue\n                    apply_pattern(output_grid, r, c, p_orange)\n                elif color == 4 or color == 8: # Yellow or Azure\n                     apply_pattern(output_grid, r, c, p_red)\n        return output_grid.tolist()\n\n    # Rule 2 Check: Largest Object Recolor (Example 1)\n    if original_colors == {1, 2, 8}:\n        single_pixels = get_single_pixel_objects(input_np)\n        if single_pixels:\n            # Find minimum color among single pixels\n            min_single_color = min(obj['color'] for obj in single_pixels)\n            \n            # Find largest object\n            largest_obj = find_largest_object(input_np, ignore_color=0)\n            \n            output_grid = np.zeros_like(input_np)\n            if largest_obj:\n                 for r, c in largest_obj['coords']:\n                     output_grid[r, c] = min_single_color\n            return output_grid.tolist()\n        else:\n            # Condition for Rule 3 Sub-Rule (Example 4) - colors {1, 2, 8} but NO single pixels\n            output_grid = np.copy(input_np)\n            # Apply mapping: 8->0, 1->2, 2->1\n            swap_map = {0:0, 1:2, 2:1, 3:3, 4:4, 5:5, 6:6, 7:7, 8:0, 9:9}\n            vectorized_map = np.vectorize(swap_map.get)\n            output_grid = vectorized_map(input_np)\n            return output_grid.tolist()\n\n\n    # Rule 3 Check: Pixel Swap (Example 2)\n    if original_colors == {2, 4, 6, 7, 8}:\n        output_grid = np.copy(input_np)\n         # Apply mapping: 8->0, 2->4, 4->2, 6->7, 7->6\n        swap_map = {0:0, 1:1, 2:4, 3:3, 4:2, 5:5, 6:7, 7:6, 8:0, 9:9}\n        vectorized_map = np.vectorize(swap_map.get)\n        output_grid = vectorized_map(input_np)\n        return output_grid.tolist()\n\n    # Default Rule: No matching rule found, return input unchanged\n    return input_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4374,
    "candidates_token_count": 2692,
    "total_token_count": 7066,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 69.194294,
  "retries": 1
}