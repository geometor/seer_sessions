
## train_1

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 7 7 7 7 7 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 2 2 2 2 2 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 6 6 6 6 6 7 7 7 6 6 6 6
7 7 6 2 2 2 6 7 7 7 6 2 2 2
6 6 6 6 6 6 6 7 7 7 6 7 7 7
2 2 2 2 2 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 6 6 6 6 6 6 6
7 7 7 7 7 6 6 2 2 2 2 2 2 2
7 6 6 6 6 6 6 6 7 7 7 7 7 7
7 6 2 2 2 2 2 6 7 7 7 7 7 7
7 6 7 7 6 6 6 6 6 6 6 6 7 7
7 6 7 7 6 2 2 2 2 2 2 6 7 7
7 6 7 7 6 7 7 7 7 7 7 6 7 7
```


## train_2

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 2 2 2 2 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 6 6 6 6 7
7 7 7 7 6 7 7 7 6 2 2 2 2
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
6 6 6 6 6 6 7 7 6 7 7 7 7
6 2 2 2 2 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 6 6 6 6 6 6 7 7 7 7
6 7 7 6 2 2 2 2 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
```


## train_3

**input:**
```
7 7 6 7 7 7 7 2 2
7 7 6 7 7 7 7 2 7
7 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 7 7 7
```


**output:**
```
7 7 6 7 7 7 7 2 2
6 6 6 6 6 7 7 2 7
6 2 2 2 6 7 7 7 7
6 7 7 7 6 7 7 7 7
6 7 6 6 6 6 6 6 7
6 7 6 2 2 2 2 6 7
6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 6 6 7
```


## train_4

**input:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 7 7
7 7 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
2 2 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
```


**output:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 6 7
7 7 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
7 6 7 7 7
7 6 7 7 7
6 6 6 6 7
2 2 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
```


## train_5

**input:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 7 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6 6
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 6 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 6 6 6 6 6 6 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7 6 7
```


## train_6

**input:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2 2 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 7 7 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
7 7 7 6 6 6 6 6 6 6 6 6 6 6 7 7
7 7 7 6 2 2 2 2 2 2 2 2 2 6 7 7
7 7 7 6 7 7 7 7 7 7 7 7 7 6 7 7
6 6 6 6 6 6 6 6 6 6 6 7 7 6 7 7
2 2 2 2 2 2 2 2 2 2 6 7 7 6 7 7
7 7 7 7 7 7 7 7 7 7 6 7 7 6 7 7
7 7 7 7 7 7 6 6 6 6 6 6 6 6 6 6
7 7 7 7 7 7 6 2 2 2 2 2 2 2 2 6
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 6
7 7 7 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 7 6 2 2 2 2 2 2 2 2 2 2 6 6
7 7 7 6 7 7 7 7 7 7 7 7 7 7 6 6
```

*   **Perception:** The input grids contain predominantly orange (7) pixels, with some red (2) objects (contiguous blocks of red pixels) and one or more vertical lines of magenta (6) pixels. The output grids retain the red objects and the original magenta lines in their exact positions. The transformation involves changing some of the orange (7) pixels to magenta (6). The change seems to depend on whether an orange pixel is "enclosed" or "trapped" by the red objects and the initial magenta lines. Orange pixels that have a path to the edge of the grid consisting only of other orange pixels remain orange. Orange pixels that do not have such a path (i.e., are blocked by red or magenta pixels) are changed to magenta.

*   **YAML Facts:**
    
```yaml
    elements:
      - color: 7 (orange)
        role: background/fill, potentially transformable
      - color: 2 (red)
        role: static objects, act as barriers
      - color: 6 (magenta)
        role: static vertical lines (fences), act as barriers, also the target color for transformation
    objects:
      - type: red_object
        description: Contiguous blocks of red (2) pixels. Shape and position vary across examples.
        properties: remain unchanged in the output, act as barriers.
      - type: magenta_line
        description: Vertical lines of magenta (6) pixels. Number and position vary across examples.
        properties: remain unchanged in the output, act as barriers.
    spatial_relationships:
      - relation: enclosure/containment
        description: Orange pixels can be enclosed by combinations of red objects, magenta lines, and grid boundaries.
    transformation:
      - type: conditional_color_change
        input_color: 7 (orange)
        output_color: 6 (magenta)
        condition: The orange pixel is 'enclosed', meaning it cannot reach any edge of the grid by moving only through adjacent orange pixels without crossing a red (2) or magenta (6) pixel.
      - type: preservation
        colors: [2 (red), 6 (magenta)]
        condition: Pixels with these colors in the input retain their color and position in the output.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify all orange (7) pixels in the input grid that are connected to any edge of the grid via a path consisting only of adjacent (up, down, left, right) orange pixels. Consider red (2) and magenta (6) pixels as impassable barriers.
    3.  Mark all such edge-connected orange pixels as "safe".
    4.  Iterate through all pixels in the input grid.
    5.  If a pixel is orange (7) and was *not* marked as "safe" in step 3, change its color to magenta (6) in the output grid.
    6.  Leave all red (2) pixels, original magenta (6) pixels, and "safe" orange (7) pixels unchanged in the output grid.
    7.  The final state of the output grid is the result.
```python
import numpy as np
from collections import deque

"""
Identify all orange (7) pixels in the input grid that are connected to any edge of the grid via a path consisting only of adjacent (up, down, left, right) orange pixels. Red (2) and magenta (6) pixels act as impassable barriers. Change any orange (7) pixel that is *not* connected to an edge in this way to magenta (6). Leave all other pixels (red, original magenta, edge-connected orange) unchanged.
"""

def transform(input_grid):
    """
    Transforms the input grid based on the described rule.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape
    output_grid = np.copy(input_np) # Initialize output grid as a copy

    # Create a grid to track visited/safe orange pixels
    visited = np.zeros_like(input_np, dtype=bool)
    q = deque()

    # Find initial orange pixels connected to the edge
    for r in range(rows):
        # Check left edge
        if input_np[r, 0] == 7 and not visited[r, 0]:
            q.append((r, 0))
            visited[r, 0] = True
        # Check right edge
        if input_np[r, cols - 1] == 7 and not visited[r, cols - 1]:
            q.append((r, cols - 1))
            visited[r, cols - 1] = True

    for c in range(cols):
        # Check top edge
        if input_np[0, c] == 7 and not visited[0, c]:
            q.append((0, c))
            visited[0, c] = True
        # Check bottom edge
        if input_np[rows - 1, c] == 7 and not visited[rows - 1, c]:
            q.append((rows - 1, c))
            visited[rows - 1, c] = True

    # Perform BFS (flood fill) from edge-connected orange pixels
    while q:
        r, c = q.popleft()

        # Check 4 adjacent neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if neighbor is orange and not visited
                if input_np[nr, nc] == 7 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid and change unconnected orange pixels to magenta
    for r in range(rows):
        for c in range(cols):
            # If it's an orange pixel but wasn't visited (not connected to edge)
            if input_np[r, c] == 7 and not visited[r, c]:
                output_grid[r, c] = 6 # Change to magenta

    return output_grid.tolist()
```
```python
import numpy as np
from collections import deque

"""
Identify all orange (7) pixels in the input grid that are connected to any edge of the grid via a path consisting only of adjacent (up, down, left, right) orange pixels. Red (2) and magenta (6) pixels act as impassable barriers. Change any orange (7) pixel that is *not* connected to an edge in this way to magenta (6). Leave all other pixels (red, original magenta, edge-connected orange) unchanged.
"""

def transform(input_grid):
    """
    Transforms the input grid based on the flood fill rule from edges.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape

    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_np)

    # Create a grid to track orange pixels connected to the edge
    is_connected_to_edge = np.zeros_like(input_np, dtype=bool)

    # Initialize a queue for Breadth-First Search (BFS)
    q = deque()

    # Seed the BFS with orange pixels on the edges
    for r in range(rows):
        # Check left edge
        if input_np[r, 0] == 7 and not is_connected_to_edge[r, 0]:
            is_connected_to_edge[r, 0] = True
            q.append((r, 0))
        # Check right edge
        if input_np[r, cols - 1] == 7 and not is_connected_to_edge[r, cols - 1]:
            is_connected_to_edge[r, cols - 1] = True
            q.append((r, cols - 1))

    for c in range(cols): # Avoid double-counting corners already checked
        # Check top edge
        if input_np[0, c] == 7 and not is_connected_to_edge[0, c]:
            is_connected_to_edge[0, c] = True
            q.append((0, c))
        # Check bottom edge
        if input_np[rows - 1, c] == 7 and not is_connected_to_edge[rows - 1, c]:
            is_connected_to_edge[rows - 1, c] = True
            q.append((rows - 1, c))

    # Perform BFS (flood fill) from edge-connected orange pixels
    while q:
        r, c = q.popleft()

        # Check 4 adjacent neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if neighbor is orange (7) and hasn't been visited yet
                if input_np[nr, nc] == 7 and not is_connected_to_edge[nr, nc]:
                    # Mark as connected and add to queue for further exploration
                    is_connected_to_edge[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid and change unconnected orange pixels to magenta
    for r in range(rows):
        for c in range(cols):
            # If it's an orange pixel in the input AND it wasn't reached by the BFS (not connected)
            if input_np[r, c] == 7 and not is_connected_to_edge[r, c]:
                # Change its color to magenta (6) in the output grid
                output_grid[r, c] = 6

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```
