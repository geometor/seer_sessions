
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1
1 1 1 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 8 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 1 1 1 1 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 1 1 1 8 8 8 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 8 8 8 8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 8 4 4 4 4 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 8 8 8 1 1 1 1 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 3 3 3 1 1 1 1 3 3 3 3 1 1 1 1 1 1 1
1 1 1 1 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 8 8 8 8 8 8 8 4 4 4 4 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 8 8 8 8 1 1 1 4 4 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3 3 1 1 1 1
1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 8 8 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1 1 1 1 4 4 4 4 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 1 1 1 1 8 8 1 1 1 1 1
1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 1 4 4 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 1 1 1 1 1 1 4 4 4 4 1 1 1 1 1 1 1
1 8 8 8 8 8 1 1 1 1 1 1 1 1 1 8 8 8 8 1 1 1
1 1 3 3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3 1 1 1
1 1 1 1 8 8 1 1 8 8 8 1 1 1 1 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 8 8 4 4 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 2 8 2 2 2 8 8 8 8 8 2 2 2 2 8 8
8 8 8 8 2 2 2 2 2 2 2 8 8 8 8 2 2 2 2 2 8 8
8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 2 2 2 2 8 8
8 8 8 8 8 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 8 8 8 2 2 8 8 8 8 8 8 8 8
8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
2 8 2 2 2 2 2 2 8 8 8 8 8 8 8 2 2 2 2 2 2 2
8 8 8 2 2 2 2 2 2 8 8 8 8 2 2 2 2 2 2 2 8 8
8 8 8 8 2 2 2 2 2 2 2 8 8 8 8 2 2 2 2 8 2 2
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 2 2 2 2 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 8
8 8 8 8 8 8 2 2 2 2 2 8 8 8 8 8 8 2 2 2 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 4 4 2 2 8 2 2 2 8 8 8 8 8 2 2 2 2 8 8
8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 2 2 2 2 2 8 8
8 8 4 4 4 8 2 2 2 2 8 8 8 8 8 8 2 2 2 2 8 8
8 8 8 8 8 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8
8 8 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 4 4 4 8 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 8 8 8 2 2 8 8 8 8 8 8 8 8
8 2 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 8 8
8 8 4 4 4 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
2 8 8 8 8 2 2 2 8 8 8 8 8 8 8 2 2 2 2 2 2 2
8 8 4 4 4 2 2 2 2 8 8 8 8 2 2 2 2 2 2 2 8 8
8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 2 2 2 2 8 2 2
8 8 4 4 4 8 8 8 8 2 2 8 8 8 8 8 2 2 2 2 2 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 2 2 2 8
8 8 3 3 3 8 3 3 3 3 3 8 8 8 8 8 8 3 3 3 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 4 4 4 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 2 2 2 8 8 8 8 8 8 8 8
8 8 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

*   **Perception:** The task involves pattern replacement and insertion based on a template object found at the bottom of the input grid. The input grid has a background color, multiple objects of a "main" color, and a single "template" object of a specific shape and color located at the bottom. The output grid modifies the main objects and the template object, and inserts new objects based on adjacency rules.

*   **Analysis:**
    1.  **Background Identification:** The background color (blue=1 in example 1, azure=8 in example 2) is the most prevalent color, often filling the grid borders.
    2.  **Template Object Identification:** A unique, non-background object exists along the bottom row. This is the template object. Its shape (4x1 horizontal in example 1, 3x1 horizontal in example 2) and color (yellow=4 in both examples) are crucial.
    3.  **Main Object Identification:** Other non-background objects exist in the grid, composed of a "main" color (azure=8 in example 1, red=2 in example 2).
    4.  **Transformation Rules:**
        *   A specific color mapping exists: the template color (yellow=4) maps to a replacement color (green=3).
        *   Instances of the template shape composed entirely of the main object color in the input are replaced by the replacement color (green=3) in the output.
        *   The original template object itself is also replaced by the replacement color (green=3) in the output.
        *   Instances of the template shape composed entirely of the background color, which are adjacent (sharing an edge) to any pixel of the main object color in the input, are filled with the original template color (yellow=4) in the output.
        *   All other pixels (background, parts of the main object not matching the template shape) retain their original color.

*   **YAML Facts:**
    
```yaml
    elements:
      - element: grid
        properties:
          - background_color: dominant color, often at borders (blue=1 or azure=8)
      - element: object
        properties:
          - type: main_object
          - color: color different from background and template (azure=8 or red=2)
          - shape: variable, often complex clusters
      - element: object
        properties:
          - type: template_object
          - color: specific color (yellow=4)
          - shape: simple rectangle (e.g., 4x1 or 3x1 horizontal)
          - location: unique instance located on the bottom row of the input grid
      - element: color_mapping
        properties:
          - input_color: yellow=4 (from template_object)
          - output_color: green=3 (replacement_color)
    actions:
      - action: identify
        actor: agent
        inputs:
          - grid
        outputs:
          - background_color
          - main_object_color
          - template_object (shape, color, location)
          - replacement_color (based on template_object color via mapping)
      - action: find_and_replace
        actor: agent
        inputs:
          - grid
          - template_object_shape
          - main_object_color
          - replacement_color
        description: Find all occurrences of the template_object_shape composed solely of main_object_color pixels in the input grid. Replace these areas with the replacement_color in the output grid.
      - action: replace_template
        actor: agent
        inputs:
          - grid
          - template_object_location
          - template_object_shape
          - replacement_color
        description: Replace the original template_object area with the replacement_color in the output grid.
      - action: find_and_fill_adjacent
        actor: agent
        inputs:
          - grid
          - template_object_shape
          - background_color
          - main_object_color
          - template_object_color
        description: Find all occurrences of the template_object_shape composed solely of background_color pixels in the input grid that are edge-adjacent to at least one main_object_color pixel. Fill these areas with the template_object_color in the output grid.
      - action: copy_remaining
        actor: agent
        inputs:
          - input_grid
          - output_grid
        description: Copy all pixels from the input_grid to the output_grid that were not modified by the previous actions.
    relationships:
      - relationship: adjacency
        between: [template_object_shape (background color instance), main_object_color pixel]
        property: edge_adjacent
        condition: Required for the find_and_fill_adjacent action.
      - relationship: color_transformation
        between: [template_object_color, replacement_color]
        property: specific_mapping (yellow=4 -> green=3)
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid with the same dimensions as the input grid.
    2.  Identify the background color (B) by finding the most frequent color in the input grid.
    3.  Identify the "template object" by finding the unique, contiguous non-background object located entirely within the bottom row of the input grid. Record its shape (S) and color (C_template).
    4.  Identify the primary "main object color" (C_main) which constitutes the other non-background, non-template objects in the grid.
    5.  Determine the "replacement color" (C_replace) based on the template color. If C_template is yellow (4), set C_replace to green (3). (Assume default behavior or identity transformation if template color is not yellow).
    6.  Fill the output grid initially with the background color (B).
    7.  Iterate through all pixels (r, c) in the input grid:
        a.  Check if the pixel at (r, c) is the top-left corner of an instance of the template shape S.
        b.  **Rule 1 (Main Object Match):** If the area covered by S starting at (r, c) in the *input* grid consists *only* of pixels with color C_main, then fill the corresponding area in the *output* grid with C_replace.
        c.  **Rule 2 (Template Object Match):** If the area covered by S starting at (r, c) in the *input* grid consists *only* of pixels with color C_template (matching the original template object), then fill the corresponding area in the *output* grid with C_replace.
        d.  **Rule 3 (Adjacent Background Match):** If the area covered by S starting at (r, c) in the *input* grid consists *only* of pixels with color B, AND this area in the *input* grid shares at least one edge with a pixel of color C_main, then fill the corresponding area in the *output* grid with C_template.
    8.  After checking all possible locations for Rules 1, 2, and 3: Iterate through all pixels (r, c) in the input grid *again*. If the pixel at (r, c) in the *output* grid is still the background color (B), and the corresponding pixel in the *input* grid was *not* the background color (B), copy the color from the input grid pixel at (r, c) to the output grid pixel at (r, c). (This copies over parts of the main object and any other objects that were not affected by the replacement rules).
```python
import numpy as np
from collections import Counter

"""
Identify the background color (most frequent).
Identify a 'template' object located on the bottom row: determine its color (template_color) and shape (template_shape).
Identify the 'main' object color (most frequent non-background, non-template color).
Define a 'replacement' color based on the template color (yellow=4 maps to green=3).
Initialize the output grid as a copy of the input.
Iterate through all possible locations in the grid that could contain the template_shape:
1. If an area matches the template_shape and consists entirely of the main_color, replace that area in the output with the replacement_color.
2. If an area matches the template_shape and consists entirely of the template_color (i.e., it's the original template instance), replace that area in the output with the replacement_color.
3. If an area matches the template_shape, consists entirely of the background_color, AND is edge-adjacent to any pixel of the main_color in the input grid, fill that area in the output with the template_color.
Pixels not modified by these rules retain their original color from the input grid.
"""

def find_objects(grid, target_color):
    """Finds connected components of a specific color."""
    if grid.size == 0:
        return []
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(height):
        for c in range(width):
            if grid[r, c] == target_color and not visited[r, c]:
                obj_pixels = []
                q = [(r, c)]
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c
                
                while q:
                    row, col = q.pop(0)
                    obj_pixels.append((row, col))
                    min_r = min(min_r, row)
                    min_c = min(min_c, col)
                    max_r = max(max_r, row)
                    max_c = max(max_c, col)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == target_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                bounding_box = (min_r, min_c, max_r, max_c)
                objects.append({'pixels': obj_pixels, 'bbox': bounding_box, 'color': target_color})
    return objects

def get_shape_from_bbox(bbox):
    """Calculates height and width from bounding box."""
    min_r, min_c, max_r, max_c = bbox
    return (max_r - min_r + 1, max_c - min_c + 1)

def check_area_color(grid, r, c, shape_h, shape_w, color):
    """Checks if the specified area in the grid is uniformly of the given color."""
    height, width = grid.shape
    if r + shape_h > height or c + shape_w > width:
        return False # Shape out of bounds
    return np.all(grid[r:r+shape_h, c:c+shape_w] == color)

def check_adjacency(grid, r, c, shape_h, shape_w, adjacent_color):
    """Checks if any pixel within the r,c area is edge-adjacent to adjacent_color outside the area."""
    height, width = grid.shape
    for i in range(shape_h):
        for j in range(shape_w):
            row, col = r + i, c + j
            # Check neighbors (N, S, E, W)
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = row + dr, col + dc
                # Check if neighbor is within grid bounds
                if 0 <= nr < height and 0 <= nc < width:
                    # Check if neighbor is OUTSIDE the shape area
                    is_outside = not (0 <= nr - r < shape_h and 0 <= nc - c < shape_w)
                    if is_outside and grid[nr, nc] == adjacent_color:
                        return True
    return False

def fill_area(grid, r, c, shape_h, shape_w, color):
    """Fills the specified area in the grid with the given color."""
    grid[r:r+shape_h, c:c+shape_w] = color

def transform(input_grid):
    """
    Applies the transformation rules based on identifying a template object
    on the bottom row and replacing/filling based on its shape and color relationships.
    """
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape
    output_array = np.copy(input_array)

    # 1. Identify Background Color
    colors, counts = np.unique(input_array, return_counts=True)
    if not colors.size: return [] # Handle empty grid case
    background_color = colors[np.argmax(counts)]

    # 2. Identify Template Object
    template_object = None
    template_color = -1
    template_shape = None
    template_bbox = None
    
    # Find non-background objects touching the bottom row
    potential_template_colors = [c for c in colors if c != background_color]
    found_template = False
    for color in potential_template_colors:
        objects = find_objects(input_array, color)
        for obj in objects:
            min_r, min_c, max_r, max_c = obj['bbox']
            # Check if the object is entirely on the bottom row
            # Or more robustly, check if *any* part is on the bottom row and it's unique there
            # Let's assume the unique non-background object fully contained in the bottom row
            is_on_bottom_row = True
            for r_pix, c_pix in obj['pixels']:
                if r_pix != height - 1:
                    is_on_bottom_row = False
                    break
            
            if is_on_bottom_row:
                 # Simple check: find first object completely on bottom row
                 # More complex logic might be needed if multiple objects fit this
                 template_object = obj
                 template_color = color
                 template_bbox = obj['bbox']
                 template_shape = get_shape_from_bbox(template_bbox)
                 found_template = True
                 break # Assume first one found is the template
        if found_template:
            break

    if not found_template:
        # Fallback or error handling if no template found
        # Maybe look for the smallest non-background object? Or unique color?
        # For now, assume template is always found as per examples
        # A reasonable fallback might be to return input if structure isn't matched
        return input_grid 

    # 3. Identify Main Object Color
    main_color_candidates = {}
    for r in range(height):
        for c in range(width):
            color = input_array[r, c]
            if color != background_color and color != template_color:
                main_color_candidates[color] = main_color_candidates.get(color, 0) + 1
    
    if not main_color_candidates:
         # No main color found (maybe only background and template exist)
         # Or maybe the template IS the main color in some cases?
         # Let's assume a main color distinct from template exists based on examples.
         # Return input if no clear main color.
         return input_grid 

    main_color = max(main_color_candidates, key=main_color_candidates.get)


    # 4. Determine Replacement Color (Specific mapping: yellow -> green)
    replacement_color = -1
    if template_color == 4: # Yellow
        replacement_color = 3 # Green
    else:
        # Define behavior for other template colors if needed
        # Default to template color itself? Or an error?
        # Given examples, let's stick to the 4->3 mapping.
        # If template isn't yellow, maybe no replacement happens.
        # Let's assume the rule only applies if template is yellow.
        if template_color != 4:
             return input_grid # Or apply different logic

    # 5. Iterate and Apply Rules
    template_h, template_w = template_shape
    
    # Keep track of areas modified by rules 1, 2, 3 to avoid overwriting them later
    # when copying non-modified main object parts. However, the current logic
    # initializes output as a copy, so we only overwrite based on rules.

    for r in range(height - template_h + 1):
        for c in range(width - template_w + 1):
            # Rule 1: Main Object Match -> Replace with replacement_color
            if check_area_color(input_array, r, c, template_h, template_w, main_color):
                fill_area(output_array, r, c, template_h, template_w, replacement_color)

            # Rule 2: Template Object Match -> Replace with replacement_color
            # This specifically targets the original template instance(s)
            elif check_area_color(input_array, r, c, template_h, template_w, template_color):
                 fill_area(output_array, r, c, template_h, template_w, replacement_color)

            # Rule 3: Adjacent Background Match -> Fill with template_color
            elif check_area_color(input_array, r, c, template_h, template_w, background_color):
                if check_adjacency(input_array, r, c, template_h, template_w, main_color):
                    fill_area(output_array, r, c, template_h, template_w, template_color) # Fill with original template color

    # No explicit step 8 needed as we started with a copy and selectively overwrote.

    return output_array.tolist()
```
