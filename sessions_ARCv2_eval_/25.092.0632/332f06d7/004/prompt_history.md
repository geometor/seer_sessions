
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

**Perception**

1.  **Colors:** The grids primarily use green (3) as a background/border color. Key active colors are red (2), white (0), and blue (1).
2.  **Objects:** In each input grid, there appear to be distinct, contiguous objects composed of red pixels and white pixels. There are also objects or regions composed of blue pixels. Often, there seems to be exactly one red object and one white object.
3.  **Transformation:** The core transformation involves changing the color of the white object(s) and one other object (either the red object or a blue object).
    *   **White to Blue:** All white pixels in the input consistently become blue pixels in the output.
    *   **Something to White:** Exactly one other object changes its color to white.
4.  **Conditional Change:** The object that changes *to* white depends on a condition related to the shapes of the white and red objects, and the presence of blue objects with specific shapes.
    *   If the white object and the red object have the exact same shape, *and* no blue object shares this shape, then the red object becomes white.
    *   Otherwise (if white and red shapes differ, OR if a blue object shares the white object's shape), the red object remains unchanged, and a specific blue object becomes white.
5.  **Blue Object Selection (if applicable):** When a blue object is chosen to become white, the selection criteria seem to be:
    *   If a blue object exists with the same shape as the original white object, that blue object is chosen.
    *   If not, but a blue object exists with the same shape as the red object, that blue object is chosen.

**Facts**


```yaml
objects:
  - color: white (0)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x1)
    action: always changes color to blue (1)
  - color: red (2)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x3)
    action:
      - changes color to white (0) IF its shape matches the white object's shape AND no blue object shares that shape.
      - remains unchanged otherwise.
  - color: blue (1)
    property: forms one or more contiguous objects/regions
    shape: variable
    action:
      - one specific blue object changes color to white (0) IF the red object does not change to white.
      - remains unchanged otherwise (except where white pixels become blue).
  - color: green (3)
    property: appears as background or border
    action: remains unchanged

relationships:
  - type: shape_comparison
    between: [white object, red object]
    purpose: determines if red object changes to white (Rule A trigger)
  - type: shape_comparison
    between: [white object, blue objects]
    purpose: determines if Rule A is overridden; identifies candidate blue object for Rule B
  - type: shape_comparison
    between: [red object, blue objects]
    purpose: identifies candidate blue object for Rule B (if no blue object matches white shape)

transformation_rules:
  - rule: A (Primary Swap)
    condition: shape(white_object) == shape(red_object) AND NOT EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - change red_object pixels to white (0)
  - rule: B (White->Blue, Blue->White)
    condition: shape(white_object) != shape(red_object) OR EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - leave red_object unchanged
      - find target_blue_object:
          - IF EXISTS blue_object WHERE shape(blue_object) == shape(white_object):
              target_blue_object = that blue_object
          - ELSE IF EXISTS blue_object WHERE shape(blue_object) == shape(red_object):
              target_blue_object = that blue_object
          - ELSE:
              # (Case not observed in examples, default might be no change or error)
              target_blue_object = None
      - IF target_blue_object exists:
          change target_blue_object pixels to white (0)

```


**Natural Language Program**

1.  Identify the single contiguous object composed of white (0) pixels. Determine its shape and location. Let this be `W`.
2.  Identify the single contiguous object composed of red (2) pixels. Determine its shape and location. Let this be `R`.
3.  Identify all contiguous objects composed of blue (1) pixels. Determine their shapes and locations. Let this set be `{B}`.
4.  Compare the shape of `W` with the shape of `R`.
5.  Check if any blue object `Bi` in `{B}` has the same shape as `W`.
6.  **Decision Point:**
    *   **IF** the shape of `W` is identical to the shape of `R`, **AND** no blue object `Bi` has the same shape as `W`:
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Change all pixels corresponding to `R` in the output grid to white (0).
    *   **ELSE** (the shapes of `W` and `R` differ, OR a blue object `Bi` has the same shape as `W`):
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Leave the pixels corresponding to `R` unchanged (still red).
        *   Find a target blue object `Bk` to change to white:
            *   Search for a blue object `Bi` in `{B}` whose shape is identical to the shape of `W`. If found, this is `Bk`.
            *   If no such blue object is found, search for a blue object `Bj` in `{B}` whose shape is identical to the shape of `R`. If found, this is `Bk`.
        *   If a target blue object `Bk` was found, change all pixels corresponding to `Bk` in the output grid to white (0).
7.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies single contiguous objects of white (0) and red (2) pixels, and all contiguous objects of blue (1) pixels.
Compares the shapes of the white and red objects.
Also checks if any blue object has the same shape as the white object.

Transformation Rules:
1.  All white pixels always change to blue pixels.
2.  Conditional Swap/Change:
    a. If the white object and red object have the exact same shape AND no blue object shares the white object's shape, then the red object's pixels change to white.
    b. Otherwise (white/red shapes differ OR a blue object matches the white shape):
        i. The red object remains unchanged.
        ii. Find a blue object to change to white:
            - First, look for a blue object with the same shape as the original white object. If found, change its pixels to white.
            - If not found, look for a blue object with the same shape as the red object. If found, change its pixels to white.
        iii. If no suitable blue object is found based on shape matching (white's shape then red's shape), no blue object changes to white.
3. All other pixels (e.g., green background) remain unchanged.
"""

def find_objects(grid, color):
    """
    Finds all contiguous objects of a specific color in the grid.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color of the objects to find.

    Returns:
        list: A list of sets, where each set contains the (row, col) tuples
              of pixels belonging to a single contiguous object.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_coords.add((r, c))

                while q:
                    row, col = q.popleft()
                    # Check 4-directional neighbors (could extend to 8 if needed)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            obj_coords.add((nr, nc))
                
                if obj_coords:
                    objects.append(obj_coords)
    return objects

def get_object_shape(obj_coords):
    """
    Calculates a canonical shape representation for an object.

    Args:
        obj_coords (set): A set of (row, col) tuples for the object's pixels.

    Returns:
        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,
                   normalized to the top-left corner (0, 0). Returns an empty
                   frozenset if obj_coords is empty.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def transform(input_grid):
    """
    Applies the transformation rules to the input grid.
    """
    output_grid = np.copy(input_grid)

    # 1. Identify objects
    white_objects = find_objects(input_grid, 0)
    red_objects = find_objects(input_grid, 2)
    blue_objects = find_objects(input_grid, 1)

    # Assume exactly one white and one red object based on examples
    if not white_objects or not red_objects:
        # Handle cases where expected objects are missing (e.g., return input)
        # For this specific problem structure, we might assume they always exist.
        # If they might not, add error handling or specific logic here.
        # Based on examples, it seems safe to assume one of each.
        if not white_objects: return output_grid # Or raise error
        if not red_objects: return output_grid # Or raise error
        
    w_coords = white_objects[0]
    r_coords = red_objects[0]

    # 2. Determine shapes
    w_shape = get_object_shape(w_coords)
    r_shape = get_object_shape(r_coords)

    blue_objects_with_shapes = []
    for b_coords in blue_objects:
        b_shape = get_object_shape(b_coords)
        blue_objects_with_shapes.append({'coords': b_coords, 'shape': b_shape})

    # 3. Check conditions
    exists_blue_matches_w_shape = any(b['shape'] == w_shape for b in blue_objects_with_shapes)

    # --- Apply Transformation Rules ---

    # Rule 1: White always becomes Blue
    for r, c in w_coords:
        output_grid[r, c] = 1

    # Rule 2: Conditional Swap/Change
    if w_shape == r_shape and not exists_blue_matches_w_shape:
        # Rule 2a: Red becomes White
        for r_coord_r, r_coord_c in r_coords:
            output_grid[r_coord_r, r_coord_c] = 0
    else:
        # Rule 2b: Red stays Red, find a Blue to become White
        target_blue_coords = None
        
        # First check for blue matching white's shape
        for b_obj in blue_objects_with_shapes:
            if b_obj['shape'] == w_shape:
                target_blue_coords = b_obj['coords']
                break
        
        # If not found, check for blue matching red's shape
        if target_blue_coords is None:
            for b_obj in blue_objects_with_shapes:
                if b_obj['shape'] == r_shape:
                    target_blue_coords = b_obj['coords']
                    break

        # If a target blue object was found, change it to white
        if target_blue_coords:
            for b_coord_r, b_coord_c in target_blue_coords:
                # Check if this pixel wasn't originally white (now blue)
                # This check prevents overwriting pixels that just turned blue from white
                # if input_grid[b_coord_r, b_coord_c] == 1: 
                # We change based on coords, so this check isn't strictly needed
                # if the logic correctly identifies distinct objects.
                output_grid[b_coord_r, b_coord_c] = 0
                
    return output_grid
```
```python
import numpy as np
from collections import deque
from typing import Set, Tuple, Optional, List, FrozenSet

"""
Transformation rule based on object shapes and colors:

1.  Identify the single contiguous white (0) object (W) and the single 
    contiguous red (2) object (R) using 8-directional connectivity. 
    Determine their shapes relative to their top-left corners (shapeW, shapeR) 
    and their absolute coordinates (W_coords, R_coords).
2.  Identify all blue (1) pixels in the input grid (B_pixels).
3.  Initialize the output grid as a copy of the input grid.
4.  **Mandatory Change:** Change all pixels at W_coords to blue (1) in the output grid.
5.  **Conditional Changes:**
    a. Search within the original blue pixels (B_pixels) for a contiguous 
       sub-region that exactly matches shapeW. Let the coordinates of the first 
       such sub-region found be `TargetB_W_coords`.
    b. **Case 1: shapeW == shapeR**
        i. If `TargetB_W_coords` exists (a blue sub-region matching W was found):
           - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.
           - Leave the red object R unchanged.
        ii. If `TargetB_W_coords` does not exist:
           - Change the pixels at `R_coords` (the red object) to white (0) in the output grid.
    c. **Case 2: shapeW != shapeR**
        i. Leave the red object R unchanged.
        ii. If `TargetB_W_coords` exists:
            - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.
        iii. If `TargetB_W_coords` does not exist:
            - Search within the original blue pixels (B_pixels) for a contiguous 
              sub-region that exactly matches shapeR. Let the first found be 
              `TargetB_R_coords`.
            - If `TargetB_R_coords` exists:
                - Change the pixels at `TargetB_R_coords` to white (0) in the output grid.
            - (Else: If neither matching sub-region is found, no further blue pixels change).
6. Return the modified output grid.
"""

def find_objects(grid: np.ndarray, color: int, connectivity: int = 8) -> List[Set[Tuple[int, int]]]:
    """
    Finds all contiguous objects of a specific color in the grid using BFS.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color of the objects to find.
        connectivity (int): 4 or 8 for neighbor checking.

    Returns:
        list: A list of sets, where each set contains the (row, col) tuples
              of pixels belonging to a single contiguous object.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    if connectivity == 8:
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    else: # Default to 4-connectivity
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_coords.add((r, c))

                while q:
                    row, col = q.popleft()
                    for dr, dc in deltas:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            obj_coords.add((nr, nc))
                
                if obj_coords:
                    objects.append(obj_coords)
    return objects

def get_object_shape(obj_coords: Set[Tuple[int, int]]) -> FrozenSet[Tuple[int, int]]:
    """
    Calculates a canonical shape representation for an object.

    Args:
        obj_coords (set): A set of (row, col) tuples for the object's pixels.

    Returns:
        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,
                   normalized to the top-left corner (0, 0). Returns an empty
                   frozenset if obj_coords is empty.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def find_subregion_with_shape(grid: np.ndarray, 
                               target_shape: FrozenSet[Tuple[int, int]], 
                               color_to_search: int) -> Optional[Set[Tuple[int, int]]]:
    """
    Searches the grid for the first contiguous sub-region of a specific color 
    that matches the target shape.

    Args:
        grid (np.ndarray): The grid to search within (should be the original input).
        target_shape (frozenset): The relative coordinates defining the shape.
        color_to_search (int): The color of pixels that can form the sub-region.

    Returns:
        Optional[Set[Tuple[int, int]]]: The absolute coordinates of the first 
                                         matching sub-region found, or None.
    """
    if not target_shape:
        return None
        
    rows, cols = grid.shape
    
    # Iterate through all possible top-left anchor points in the grid
    for r_anchor in range(rows):
        for c_anchor in range(cols):
            # Check if the anchor pixel itself has the right color
            if grid[r_anchor, c_anchor] == color_to_search:
                match = True
                current_subregion_coords = set()
                
                # Check if all pixels defined by the shape relative to the anchor exist and have the correct color
                for dr, dc in target_shape:
                    nr, nc = r_anchor + dr, c_anchor + dc
                    
                    # Check bounds and color
                    if not (0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color_to_search):
                        match = False
                        break # This anchor point doesn't work for this shape
                    current_subregion_coords.add((nr, nc))
                
                # If all pixels of the shape matched
                if match:
                    # Verify the size matches (ensures no extra pixels accidentally included if shape has holes)
                    if len(current_subregion_coords) == len(target_shape):
                         return current_subregion_coords # Found the first match

    return None # No matching sub-region found

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rules based on object shapes and colors.
    """
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify white (W) and red (R) objects
    white_objects = find_objects(input_grid, 0, connectivity=8)
    red_objects = find_objects(input_grid, 2, connectivity=8)

    # Assume exactly one white and one red object based on examples
    if not white_objects or not red_objects:
        # If assumptions fail, return the unchanged grid or handle error
        return output_grid 
        
    w_coords = white_objects[0]
    r_coords = red_objects[0]

    # 2. Determine shapes
    shapeW = get_object_shape(w_coords)
    shapeR = get_object_shape(r_coords)

    # (Step 3 is implicit: B_pixels are checked within find_subregion_with_shape)

    # 4. Mandatory Change: White becomes Blue
    for r, c in w_coords:
        if 0 <= r < rows and 0 <= c < cols: # Bounds check just in case
             output_grid[r, c] = 1

    # 5. Conditional Changes
    
    # 5a. Search for blue sub-region matching white shape in the *original* grid
    targetB_W_coords = find_subregion_with_shape(input_grid, shapeW, 1)

    # 5b. Case 1: shapeW == shapeR
    if shapeW == shapeR:
        if targetB_W_coords is not None:
            # Change the found blue sub-region to white
            for r, c in targetB_W_coords:
                 if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
            # Leave red object unchanged
        else:
            # Change the red object to white
            for r, c in r_coords:
                if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
    
    # 5c. Case 2: shapeW != shapeR
    else:
        # Leave red object unchanged
        if targetB_W_coords is not None:
            # Change the found blue sub-region (matching white) to white
            for r, c in targetB_W_coords:
                if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
        else:
            # Search for blue sub-region matching red shape in the *original* grid
            targetB_R_coords = find_subregion_with_shape(input_grid, shapeR, 1)
            if targetB_R_coords is not None:
                # Change the found blue sub-region (matching red) to white
                for r, c in targetB_R_coords:
                    if 0 <= r < rows and 0 <= c < cols:
                        output_grid[r, c] = 0
            # Else: No matching blue sub-regions found for either shape, no further changes.

    # 6. Return the result
    return output_grid
```
