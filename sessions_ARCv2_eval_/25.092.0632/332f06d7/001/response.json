{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies single contiguous objects of white (0) and red (2) pixels, and all contiguous objects of blue (1) pixels.\nCompares the shapes of the white and red objects.\nAlso checks if any blue object has the same shape as the white object.\n\nTransformation Rules:\n1.  All white pixels always change to blue pixels.\n2.  Conditional Swap/Change:\n    a. If the white object and red object have the exact same shape AND no blue object shares the white object's shape, then the red object's pixels change to white.\n    b. Otherwise (white/red shapes differ OR a blue object matches the white shape):\n        i. The red object remains unchanged.\n        ii. Find a blue object to change to white:\n            - First, look for a blue object with the same shape as the original white object. If found, change its pixels to white.\n            - If not found, look for a blue object with the same shape as the red object. If found, change its pixels to white.\n        iii. If no suitable blue object is found based on shape matching (white's shape then red's shape), no blue object changes to white.\n3. All other pixels (e.g., green background) remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a single contiguous object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4-directional neighbors (could extend to 8 if needed)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                \n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_object_shape(obj_coords):\n    \"\"\"\n    Calculates a canonical shape representation for an object.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples for the object's pixels.\n\n    Returns:\n        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,\n                   normalized to the top-left corner (0, 0). Returns an empty\n                   frozenset if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return frozenset()\n    \n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    \n    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return shape\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify objects\n    white_objects = find_objects(input_grid, 0)\n    red_objects = find_objects(input_grid, 2)\n    blue_objects = find_objects(input_grid, 1)\n\n    # Assume exactly one white and one red object based on examples\n    if not white_objects or not red_objects:\n        # Handle cases where expected objects are missing (e.g., return input)\n        # For this specific problem structure, we might assume they always exist.\n        # If they might not, add error handling or specific logic here.\n        # Based on examples, it seems safe to assume one of each.\n        if not white_objects: return output_grid # Or raise error\n        if not red_objects: return output_grid # Or raise error\n        \n    w_coords = white_objects[0]\n    r_coords = red_objects[0]\n\n    # 2. Determine shapes\n    w_shape = get_object_shape(w_coords)\n    r_shape = get_object_shape(r_coords)\n\n    blue_objects_with_shapes = []\n    for b_coords in blue_objects:\n        b_shape = get_object_shape(b_coords)\n        blue_objects_with_shapes.append({'coords': b_coords, 'shape': b_shape})\n\n    # 3. Check conditions\n    exists_blue_matches_w_shape = any(b['shape'] == w_shape for b in blue_objects_with_shapes)\n\n    # --- Apply Transformation Rules ---\n\n    # Rule 1: White always becomes Blue\n    for r, c in w_coords:\n        output_grid[r, c] = 1\n\n    # Rule 2: Conditional Swap/Change\n    if w_shape == r_shape and not exists_blue_matches_w_shape:\n        # Rule 2a: Red becomes White\n        for r_coord_r, r_coord_c in r_coords:\n            output_grid[r_coord_r, r_coord_c] = 0\n    else:\n        # Rule 2b: Red stays Red, find a Blue to become White\n        target_blue_coords = None\n        \n        # First check for blue matching white's shape\n        for b_obj in blue_objects_with_shapes:\n            if b_obj['shape'] == w_shape:\n                target_blue_coords = b_obj['coords']\n                break\n        \n        # If not found, check for blue matching red's shape\n        if target_blue_coords is None:\n            for b_obj in blue_objects_with_shapes:\n                if b_obj['shape'] == r_shape:\n                    target_blue_coords = b_obj['coords']\n                    break\n\n        # If a target blue object was found, change it to white\n        if target_blue_coords:\n            for b_coord_r, b_coord_c in target_blue_coords:\n                # Check if this pixel wasn't originally white (now blue)\n                # This check prevents overwriting pixels that just turned blue from white\n                # if input_grid[b_coord_r, b_coord_c] == 1: \n                # We change based on coords, so this check isn't strictly needed\n                # if the logic correctly identifies distinct objects.\n                output_grid[b_coord_r, b_coord_c] = 0\n                \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5417,
    "candidates_token_count": 1712,
    "total_token_count": 7129,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.150718,
  "retries": 1
}