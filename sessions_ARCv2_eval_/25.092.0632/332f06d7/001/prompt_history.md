
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

**Perception**

1.  **Colors:** The grids primarily use green (3) as a background/border color. Key active colors are red (2), white (0), and blue (1).
2.  **Objects:** In each input grid, there appear to be distinct, contiguous objects composed of red pixels and white pixels. There are also objects or regions composed of blue pixels. Often, there seems to be exactly one red object and one white object.
3.  **Transformation:** The core transformation involves changing the color of the white object(s) and one other object (either the red object or a blue object).
    *   **White to Blue:** All white pixels in the input consistently become blue pixels in the output.
    *   **Something to White:** Exactly one other object changes its color to white.
4.  **Conditional Change:** The object that changes *to* white depends on a condition related to the shapes of the white and red objects, and the presence of blue objects with specific shapes.
    *   If the white object and the red object have the exact same shape, *and* no blue object shares this shape, then the red object becomes white.
    *   Otherwise (if white and red shapes differ, OR if a blue object shares the white object's shape), the red object remains unchanged, and a specific blue object becomes white.
5.  **Blue Object Selection (if applicable):** When a blue object is chosen to become white, the selection criteria seem to be:
    *   If a blue object exists with the same shape as the original white object, that blue object is chosen.
    *   If not, but a blue object exists with the same shape as the red object, that blue object is chosen.

**Facts**


```yaml
objects:
  - color: white (0)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x1)
    action: always changes color to blue (1)
  - color: red (2)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x3)
    action:
      - changes color to white (0) IF its shape matches the white object's shape AND no blue object shares that shape.
      - remains unchanged otherwise.
  - color: blue (1)
    property: forms one or more contiguous objects/regions
    shape: variable
    action:
      - one specific blue object changes color to white (0) IF the red object does not change to white.
      - remains unchanged otherwise (except where white pixels become blue).
  - color: green (3)
    property: appears as background or border
    action: remains unchanged

relationships:
  - type: shape_comparison
    between: [white object, red object]
    purpose: determines if red object changes to white (Rule A trigger)
  - type: shape_comparison
    between: [white object, blue objects]
    purpose: determines if Rule A is overridden; identifies candidate blue object for Rule B
  - type: shape_comparison
    between: [red object, blue objects]
    purpose: identifies candidate blue object for Rule B (if no blue object matches white shape)

transformation_rules:
  - rule: A (Primary Swap)
    condition: shape(white_object) == shape(red_object) AND NOT EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - change red_object pixels to white (0)
  - rule: B (White->Blue, Blue->White)
    condition: shape(white_object) != shape(red_object) OR EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - leave red_object unchanged
      - find target_blue_object:
          - IF EXISTS blue_object WHERE shape(blue_object) == shape(white_object):
              target_blue_object = that blue_object
          - ELSE IF EXISTS blue_object WHERE shape(blue_object) == shape(red_object):
              target_blue_object = that blue_object
          - ELSE:
              # (Case not observed in examples, default might be no change or error)
              target_blue_object = None
      - IF target_blue_object exists:
          change target_blue_object pixels to white (0)

```


**Natural Language Program**

1.  Identify the single contiguous object composed of white (0) pixels. Determine its shape and location. Let this be `W`.
2.  Identify the single contiguous object composed of red (2) pixels. Determine its shape and location. Let this be `R`.
3.  Identify all contiguous objects composed of blue (1) pixels. Determine their shapes and locations. Let this set be `{B}`.
4.  Compare the shape of `W` with the shape of `R`.
5.  Check if any blue object `Bi` in `{B}` has the same shape as `W`.
6.  **Decision Point:**
    *   **IF** the shape of `W` is identical to the shape of `R`, **AND** no blue object `Bi` has the same shape as `W`:
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Change all pixels corresponding to `R` in the output grid to white (0).
    *   **ELSE** (the shapes of `W` and `R` differ, OR a blue object `Bi` has the same shape as `W`):
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Leave the pixels corresponding to `R` unchanged (still red).
        *   Find a target blue object `Bk` to change to white:
            *   Search for a blue object `Bi` in `{B}` whose shape is identical to the shape of `W`. If found, this is `Bk`.
            *   If no such blue object is found, search for a blue object `Bj` in `{B}` whose shape is identical to the shape of `R`. If found, this is `Bk`.
        *   If a target blue object `Bk` was found, change all pixels corresponding to `Bk` in the output grid to white (0).
7.  Return the modified output grid.
