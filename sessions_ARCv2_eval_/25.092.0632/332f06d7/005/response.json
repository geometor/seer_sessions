{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom typing import Set, Tuple, Optional, List, FrozenSet, Dict\n\n\"\"\"\nTransforms grid by swapping colors based on object shapes. A white object \nalways becomes blue. Either the red object or a blue object becomes white \nbased on shape comparison and existence of matching blue objects.\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Identify the single contiguous white object (W). Store its coordinates \n    (`W_coords`) and calculate its canonical shape (`shapeW`).\n3.  Identify the single contiguous red object (R). Store its coordinates \n    (`R_coords`) and calculate its canonical shape (`shapeR`).\n4.  Identify all contiguous blue objects ({B}). For each blue object `Bi`, store \n    its coordinates (`Bi_coords`), calculate its canonical shape (`shapeBi`), and\n    determine its top-left anchor point (`Bi_anchor`).\n5.  **Mandatory Change:** Change all pixels at `W_coords` in the output grid to \n    blue (1).\n6.  Find all blue objects `Bk` from {B} such that `shapeBk == shapeW`. Let this \n    collection be `MatchingW_BlueObjects`.\n7.  Find all blue objects `Bj` from {B} such that `shapeBj == shapeR`. Let this \n    collection be `MatchingR_BlueObjects`.\n8.  **Conditional Change (Object to become White):**\n    a.  **IF `shapeW == shapeR`:**\n        i.  IF `MatchingW_BlueObjects` is **empty**:\n            Change all pixels at `R_coords` in the output grid to white (0).\n        ii. ELSE (`MatchingW_BlueObjects` is **not empty**):\n            Select one target object `Bt` from `MatchingW_BlueObjects` (e.g., the \n            one with the largest top-left anchor: max row, then max col).\n            Change all pixels at `Bt_coords` in the output grid to white (0).\n            *(Note: This step correctly handles Ex2, Ex3, but incorrectly handles \n            Ex1, Ex4 based on expected outputs).*\n    b.  **ELSE (`shapeW != shapeR`):**\n        i.  IF `MatchingW_BlueObjects` is **not empty**:\n            Select one target object `Bt` from `MatchingW_BlueObjects` (using the \n            same selection rule).\n            Change all pixels at `Bt_coords` in the output grid to white (0).\n        ii. ELSE (`MatchingW_BlueObjects` is **empty**):\n            IF `MatchingR_BlueObjects` is **not empty**:\n                Select one target object `Bt` from `MatchingR_BlueObjects` (using \n                the same selection rule).\n                Change all pixels at `Bt_coords` in the output grid to white (0).\n            ELSE:\n                No object changes to white (only W changed to blue).\n9.  Return the modified output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid: np.ndarray, color: int, connectivity: int = 8) -> List[Dict]:\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using BFS.\n    Returns a list of dictionaries, each containing 'coords' and 'anchor'.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    if connectivity == 8:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    else: # Default to 4-connectivity\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c  # Initialize anchor\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    for dr, dc in deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_coords:\n                    # Recalculate anchor accurately after finding all coords\n                    current_min_r = min(coord[0] for coord in obj_coords)\n                    current_min_c = min(coord[1] for coord in obj_coords)\n                    objects.append({\n                        'coords': obj_coords,\n                        'anchor': (current_min_r, current_min_c)\n                    })\n    return objects\n\ndef get_object_shape(obj_coords: Set[Tuple[int, int]]) -> FrozenSet[Tuple[int, int]]:\n    \"\"\"\n    Calculates a canonical shape representation for an object.\n    \"\"\"\n    if not obj_coords:\n        return frozenset()\n    \n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    \n    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return shape\n\ndef select_target_blue_object(candidate_objects: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Selects one blue object from the candidates based on the largest anchor.\n    Largest anchor means: max row, then max column.\n    \"\"\"\n    if not candidate_objects:\n        return None\n    \n    # Sort by anchor: primarily by row (descending), secondarily by col (descending)\n    # Since max() finds the first maximum in case of ties in the primary key, \n    # we sort first by col (ascending), then by row (ascending) and take the last element.\n    # Alternatively, use a custom key with max().\n    \n    # Using max with a custom key (row, col)\n    selected_object = max(candidate_objects, key=lambda obj: obj['anchor'])\n    \n    return selected_object\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rules based on object shapes and colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify white (W) object\n    white_objects_data = find_objects(input_grid, 0, connectivity=8)\n    if not white_objects_data: return output_grid # Should not happen per task desc\n    w_data = white_objects_data[0]\n    w_coords = w_data['coords']\n    shapeW = get_object_shape(w_coords)\n\n    # 2. Identify red (R) object\n    red_objects_data = find_objects(input_grid, 2, connectivity=8)\n    if not red_objects_data: return output_grid # Should not happen per task desc\n    r_data = red_objects_data[0]\n    r_coords = r_data['coords']\n    shapeR = get_object_shape(r_coords)\n\n    # 3. Identify all blue (B) objects and calculate shapes/anchors\n    blue_objects_data = find_objects(input_grid, 1, connectivity=8)\n    for b_obj in blue_objects_data:\n        b_obj['shape'] = get_object_shape(b_obj['coords'])\n\n    # 4. Mandatory Change: White becomes Blue\n    for r, c in w_coords:\n        if 0 <= r < rows and 0 <= c < cols:\n             output_grid[r, c] = 1\n\n    # 5. Filter blue objects matching W's shape\n    matchingW_blue_objects = [b for b in blue_objects_data if b['shape'] == shapeW]\n\n    # 6. Filter blue objects matching R's shape\n    matchingR_blue_objects = [b for b in blue_objects_data if b['shape'] == shapeR]\n    \n    # 7. Conditional Change (Object to become White)\n    target_coords_to_make_white = None\n\n    # 7a. Case: shapeW == shapeR\n    if shapeW == shapeR:\n        if not matchingW_blue_objects:\n            # 7a.i: No blue object matches W/R shape -> R becomes White\n            target_coords_to_make_white = r_coords\n        else:\n            # 7a.ii: Blue object(s) match W/R shape -> Select one B and make it White\n            # (Note: This branch correctly handles Ex2, Ex3, but fails Ex1, Ex4)\n            selected_blue_obj = select_target_blue_object(matchingW_blue_objects)\n            if selected_blue_obj:\n                target_coords_to_make_white = selected_blue_obj['coords']\n            # If selection fails (shouldn't if list is not empty), R remains unchanged implicitly\n            \n    # 7b. Case: shapeW != shapeR\n    else:\n        if matchingW_blue_objects:\n            # 7b.i: Blue object(s) match W shape -> Select one B and make it White\n            selected_blue_obj = select_target_blue_object(matchingW_blue_objects)\n            if selected_blue_obj:\n                target_coords_to_make_white = selected_blue_obj['coords']\n        else:\n            # 7b.ii: No blue object matches W shape. Check for match with R shape.\n            if matchingR_blue_objects:\n                selected_blue_obj = select_target_blue_object(matchingR_blue_objects)\n                if selected_blue_obj:\n                    target_coords_to_make_white = selected_blue_obj['coords']\n            # Else: No blue object matches W or R shape -> No further changes\n\n    # Apply the change to white if a target was determined\n    if target_coords_to_make_white:\n        for r, c in target_coords_to_make_white:\n             if 0 <= r < rows and 0 <= c < cols:\n                 # Ensure we don't overwrite a pixel that just turned blue from white, \n                 # although this shouldn't happen if objects are distinct.\n                 # Check original color? No, just apply based on determined target coords.\n                 output_grid[r, c] = 0\n\n    # 8. Return the result\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28267,
    "candidates_token_count": 2593,
    "total_token_count": 30860,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.783963,
  "retries": 1
}