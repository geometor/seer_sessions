{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom typing import Set, Tuple, Optional, List, FrozenSet\n\n\"\"\"\nTransformation rule based on object shapes and colors:\n\n1.  Identify the single contiguous white (0) object (W) and the single \n    contiguous red (2) object (R) using 8-directional connectivity. \n    Determine their shapes relative to their top-left corners (shapeW, shapeR) \n    and their absolute coordinates (W_coords, R_coords).\n2.  Identify all blue (1) pixels in the input grid (B_pixels).\n3.  Initialize the output grid as a copy of the input grid.\n4.  **Mandatory Change:** Change all pixels at W_coords to blue (1) in the output grid.\n5.  **Conditional Changes:**\n    a. Search within the original blue pixels (B_pixels) for a contiguous \n       sub-region that exactly matches shapeW. Let the coordinates of the first \n       such sub-region found be `TargetB_W_coords`.\n    b. **Case 1: shapeW == shapeR**\n        i. If `TargetB_W_coords` exists (a blue sub-region matching W was found):\n           - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.\n           - Leave the red object R unchanged.\n        ii. If `TargetB_W_coords` does not exist:\n           - Change the pixels at `R_coords` (the red object) to white (0) in the output grid.\n    c. **Case 2: shapeW != shapeR**\n        i. Leave the red object R unchanged.\n        ii. If `TargetB_W_coords` exists:\n            - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.\n        iii. If `TargetB_W_coords` does not exist:\n            - Search within the original blue pixels (B_pixels) for a contiguous \n              sub-region that exactly matches shapeR. Let the first found be \n              `TargetB_R_coords`.\n            - If `TargetB_R_coords` exists:\n                - Change the pixels at `TargetB_R_coords` to white (0) in the output grid.\n            - (Else: If neither matching sub-region is found, no further blue pixels change).\n6. Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, color: int, connectivity: int = 8) -> List[Set[Tuple[int, int]]]:\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n        connectivity (int): 4 or 8 for neighbor checking.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a single contiguous object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    if connectivity == 8:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    else: # Default to 4-connectivity\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                \n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_object_shape(obj_coords: Set[Tuple[int, int]]) -> FrozenSet[Tuple[int, int]]:\n    \"\"\"\n    Calculates a canonical shape representation for an object.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples for the object's pixels.\n\n    Returns:\n        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,\n                   normalized to the top-left corner (0, 0). Returns an empty\n                   frozenset if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return frozenset()\n    \n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    \n    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return shape\n\ndef find_subregion_with_shape(grid: np.ndarray, \n                               target_shape: FrozenSet[Tuple[int, int]], \n                               color_to_search: int) -> Optional[Set[Tuple[int, int]]]:\n    \"\"\"\n    Searches the grid for the first contiguous sub-region of a specific color \n    that matches the target shape.\n\n    Args:\n        grid (np.ndarray): The grid to search within (should be the original input).\n        target_shape (frozenset): The relative coordinates defining the shape.\n        color_to_search (int): The color of pixels that can form the sub-region.\n\n    Returns:\n        Optional[Set[Tuple[int, int]]]: The absolute coordinates of the first \n                                         matching sub-region found, or None.\n    \"\"\"\n    if not target_shape:\n        return None\n        \n    rows, cols = grid.shape\n    \n    # Iterate through all possible top-left anchor points in the grid\n    for r_anchor in range(rows):\n        for c_anchor in range(cols):\n            # Check if the anchor pixel itself has the right color\n            if grid[r_anchor, c_anchor] == color_to_search:\n                match = True\n                current_subregion_coords = set()\n                \n                # Check if all pixels defined by the shape relative to the anchor exist and have the correct color\n                for dr, dc in target_shape:\n                    nr, nc = r_anchor + dr, c_anchor + dc\n                    \n                    # Check bounds and color\n                    if not (0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color_to_search):\n                        match = False\n                        break # This anchor point doesn't work for this shape\n                    current_subregion_coords.add((nr, nc))\n                \n                # If all pixels of the shape matched\n                if match:\n                    # Verify the size matches (ensures no extra pixels accidentally included if shape has holes)\n                    if len(current_subregion_coords) == len(target_shape):\n                         return current_subregion_coords # Found the first match\n\n    return None # No matching sub-region found\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rules based on object shapes and colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify white (W) and red (R) objects\n    white_objects = find_objects(input_grid, 0, connectivity=8)\n    red_objects = find_objects(input_grid, 2, connectivity=8)\n\n    # Assume exactly one white and one red object based on examples\n    if not white_objects or not red_objects:\n        # If assumptions fail, return the unchanged grid or handle error\n        return output_grid \n        \n    w_coords = white_objects[0]\n    r_coords = red_objects[0]\n\n    # 2. Determine shapes\n    shapeW = get_object_shape(w_coords)\n    shapeR = get_object_shape(r_coords)\n\n    # (Step 3 is implicit: B_pixels are checked within find_subregion_with_shape)\n\n    # 4. Mandatory Change: White becomes Blue\n    for r, c in w_coords:\n        if 0 <= r < rows and 0 <= c < cols: # Bounds check just in case\n             output_grid[r, c] = 1\n\n    # 5. Conditional Changes\n    \n    # 5a. Search for blue sub-region matching white shape in the *original* grid\n    targetB_W_coords = find_subregion_with_shape(input_grid, shapeW, 1)\n\n    # 5b. Case 1: shapeW == shapeR\n    if shapeW == shapeR:\n        if targetB_W_coords is not None:\n            # Change the found blue sub-region to white\n            for r, c in targetB_W_coords:\n                 if 0 <= r < rows and 0 <= c < cols:\n                    output_grid[r, c] = 0\n            # Leave red object unchanged\n        else:\n            # Change the red object to white\n            for r, c in r_coords:\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_grid[r, c] = 0\n    \n    # 5c. Case 2: shapeW != shapeR\n    else:\n        # Leave red object unchanged\n        if targetB_W_coords is not None:\n            # Change the found blue sub-region (matching white) to white\n            for r, c in targetB_W_coords:\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_grid[r, c] = 0\n        else:\n            # Search for blue sub-region matching red shape in the *original* grid\n            targetB_R_coords = find_subregion_with_shape(input_grid, shapeR, 1)\n            if targetB_R_coords is not None:\n                # Change the found blue sub-region (matching red) to white\n                for r, c in targetB_R_coords:\n                    if 0 <= r < rows and 0 <= c < cols:\n                        output_grid[r, c] = 0\n            # Else: No matching blue sub-regions found for either shape, no further changes.\n\n    # 6. Return the result\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15369,
    "candidates_token_count": 2550,
    "total_token_count": 17919,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.497177,
  "retries": 1
}