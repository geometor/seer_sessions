
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

**Perception**

1.  **Colors:** The grids primarily use green (3) as a background/border color. Key active colors are red (2), white (0), and blue (1).
2.  **Objects:** In each input grid, there appear to be distinct, contiguous objects composed of red pixels and white pixels. There are also objects or regions composed of blue pixels. Often, there seems to be exactly one red object and one white object.
3.  **Transformation:** The core transformation involves changing the color of the white object(s) and one other object (either the red object or a blue object).
    *   **White to Blue:** All white pixels in the input consistently become blue pixels in the output.
    *   **Something to White:** Exactly one other object changes its color to white.
4.  **Conditional Change:** The object that changes *to* white depends on a condition related to the shapes of the white and red objects, and the presence of blue objects with specific shapes.
    *   If the white object and the red object have the exact same shape, *and* no blue object shares this shape, then the red object becomes white.
    *   Otherwise (if white and red shapes differ, OR if a blue object shares the white object's shape), the red object remains unchanged, and a specific blue object becomes white.
5.  **Blue Object Selection (if applicable):** When a blue object is chosen to become white, the selection criteria seem to be:
    *   If a blue object exists with the same shape as the original white object, that blue object is chosen.
    *   If not, but a blue object exists with the same shape as the red object, that blue object is chosen.

**Facts**


```yaml
objects:
  - color: white (0)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x1)
    action: always changes color to blue (1)
  - color: red (2)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x3)
    action:
      - changes color to white (0) IF its shape matches the white object's shape AND no blue object shares that shape.
      - remains unchanged otherwise.
  - color: blue (1)
    property: forms one or more contiguous objects/regions
    shape: variable
    action:
      - one specific blue object changes color to white (0) IF the red object does not change to white.
      - remains unchanged otherwise (except where white pixels become blue).
  - color: green (3)
    property: appears as background or border
    action: remains unchanged

relationships:
  - type: shape_comparison
    between: [white object, red object]
    purpose: determines if red object changes to white (Rule A trigger)
  - type: shape_comparison
    between: [white object, blue objects]
    purpose: determines if Rule A is overridden; identifies candidate blue object for Rule B
  - type: shape_comparison
    between: [red object, blue objects]
    purpose: identifies candidate blue object for Rule B (if no blue object matches white shape)

transformation_rules:
  - rule: A (Primary Swap)
    condition: shape(white_object) == shape(red_object) AND NOT EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - change red_object pixels to white (0)
  - rule: B (White->Blue, Blue->White)
    condition: shape(white_object) != shape(red_object) OR EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - leave red_object unchanged
      - find target_blue_object:
          - IF EXISTS blue_object WHERE shape(blue_object) == shape(white_object):
              target_blue_object = that blue_object
          - ELSE IF EXISTS blue_object WHERE shape(blue_object) == shape(red_object):
              target_blue_object = that blue_object
          - ELSE:
              # (Case not observed in examples, default might be no change or error)
              target_blue_object = None
      - IF target_blue_object exists:
          change target_blue_object pixels to white (0)

```


**Natural Language Program**

1.  Identify the single contiguous object composed of white (0) pixels. Determine its shape and location. Let this be `W`.
2.  Identify the single contiguous object composed of red (2) pixels. Determine its shape and location. Let this be `R`.
3.  Identify all contiguous objects composed of blue (1) pixels. Determine their shapes and locations. Let this set be `{B}`.
4.  Compare the shape of `W` with the shape of `R`.
5.  Check if any blue object `Bi` in `{B}` has the same shape as `W`.
6.  **Decision Point:**
    *   **IF** the shape of `W` is identical to the shape of `R`, **AND** no blue object `Bi` has the same shape as `W`:
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Change all pixels corresponding to `R` in the output grid to white (0).
    *   **ELSE** (the shapes of `W` and `R` differ, OR a blue object `Bi` has the same shape as `W`):
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Leave the pixels corresponding to `R` unchanged (still red).
        *   Find a target blue object `Bk` to change to white:
            *   Search for a blue object `Bi` in `{B}` whose shape is identical to the shape of `W`. If found, this is `Bk`.
            *   If no such blue object is found, search for a blue object `Bj` in `{B}` whose shape is identical to the shape of `R`. If found, this is `Bk`.
        *   If a target blue object `Bk` was found, change all pixels corresponding to `Bk` in the output grid to white (0).
7.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies single contiguous objects of white (0) and red (2) pixels, and all contiguous objects of blue (1) pixels.
Compares the shapes of the white and red objects.
Also checks if any blue object has the same shape as the white object.

Transformation Rules:
1.  All white pixels always change to blue pixels.
2.  Conditional Swap/Change:
    a. If the white object and red object have the exact same shape AND no blue object shares the white object's shape, then the red object's pixels change to white.
    b. Otherwise (white/red shapes differ OR a blue object matches the white shape):
        i. The red object remains unchanged.
        ii. Find a blue object to change to white:
            - First, look for a blue object with the same shape as the original white object. If found, change its pixels to white.
            - If not found, look for a blue object with the same shape as the red object. If found, change its pixels to white.
        iii. If no suitable blue object is found based on shape matching (white's shape then red's shape), no blue object changes to white.
3. All other pixels (e.g., green background) remain unchanged.
"""

def find_objects(grid, color):
    """
    Finds all contiguous objects of a specific color in the grid.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color of the objects to find.

    Returns:
        list: A list of sets, where each set contains the (row, col) tuples
              of pixels belonging to a single contiguous object.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_coords.add((r, c))

                while q:
                    row, col = q.popleft()
                    # Check 4-directional neighbors (could extend to 8 if needed)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            obj_coords.add((nr, nc))
                
                if obj_coords:
                    objects.append(obj_coords)
    return objects

def get_object_shape(obj_coords):
    """
    Calculates a canonical shape representation for an object.

    Args:
        obj_coords (set): A set of (row, col) tuples for the object's pixels.

    Returns:
        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,
                   normalized to the top-left corner (0, 0). Returns an empty
                   frozenset if obj_coords is empty.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def transform(input_grid):
    """
    Applies the transformation rules to the input grid.
    """
    output_grid = np.copy(input_grid)

    # 1. Identify objects
    white_objects = find_objects(input_grid, 0)
    red_objects = find_objects(input_grid, 2)
    blue_objects = find_objects(input_grid, 1)

    # Assume exactly one white and one red object based on examples
    if not white_objects or not red_objects:
        # Handle cases where expected objects are missing (e.g., return input)
        # For this specific problem structure, we might assume they always exist.
        # If they might not, add error handling or specific logic here.
        # Based on examples, it seems safe to assume one of each.
        if not white_objects: return output_grid # Or raise error
        if not red_objects: return output_grid # Or raise error
        
    w_coords = white_objects[0]
    r_coords = red_objects[0]

    # 2. Determine shapes
    w_shape = get_object_shape(w_coords)
    r_shape = get_object_shape(r_coords)

    blue_objects_with_shapes = []
    for b_coords in blue_objects:
        b_shape = get_object_shape(b_coords)
        blue_objects_with_shapes.append({'coords': b_coords, 'shape': b_shape})

    # 3. Check conditions
    exists_blue_matches_w_shape = any(b['shape'] == w_shape for b in blue_objects_with_shapes)

    # --- Apply Transformation Rules ---

    # Rule 1: White always becomes Blue
    for r, c in w_coords:
        output_grid[r, c] = 1

    # Rule 2: Conditional Swap/Change
    if w_shape == r_shape and not exists_blue_matches_w_shape:
        # Rule 2a: Red becomes White
        for r_coord_r, r_coord_c in r_coords:
            output_grid[r_coord_r, r_coord_c] = 0
    else:
        # Rule 2b: Red stays Red, find a Blue to become White
        target_blue_coords = None
        
        # First check for blue matching white's shape
        for b_obj in blue_objects_with_shapes:
            if b_obj['shape'] == w_shape:
                target_blue_coords = b_obj['coords']
                break
        
        # If not found, check for blue matching red's shape
        if target_blue_coords is None:
            for b_obj in blue_objects_with_shapes:
                if b_obj['shape'] == r_shape:
                    target_blue_coords = b_obj['coords']
                    break

        # If a target blue object was found, change it to white
        if target_blue_coords:
            for b_coord_r, b_coord_c in target_blue_coords:
                # Check if this pixel wasn't originally white (now blue)
                # This check prevents overwriting pixels that just turned blue from white
                # if input_grid[b_coord_r, b_coord_c] == 1: 
                # We change based on coords, so this check isn't strictly needed
                # if the logic correctly identifies distinct objects.
                output_grid[b_coord_r, b_coord_c] = 0
                
    return output_grid
```
