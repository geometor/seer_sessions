
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

**Perception**

1.  **Colors:** The grids primarily use green (3) as a background/border color. Key active colors are red (2), white (0), and blue (1).
2.  **Objects:** In each input grid, there appear to be distinct, contiguous objects composed of red pixels and white pixels. There are also objects or regions composed of blue pixels. Often, there seems to be exactly one red object and one white object.
3.  **Transformation:** The core transformation involves changing the color of the white object(s) and one other object (either the red object or a blue object).
    *   **White to Blue:** All white pixels in the input consistently become blue pixels in the output.
    *   **Something to White:** Exactly one other object changes its color to white.
4.  **Conditional Change:** The object that changes *to* white depends on a condition related to the shapes of the white and red objects, and the presence of blue objects with specific shapes.
    *   If the white object and the red object have the exact same shape, *and* no blue object shares this shape, then the red object becomes white.
    *   Otherwise (if white and red shapes differ, OR if a blue object shares the white object's shape), the red object remains unchanged, and a specific blue object becomes white.
5.  **Blue Object Selection (if applicable):** When a blue object is chosen to become white, the selection criteria seem to be:
    *   If a blue object exists with the same shape as the original white object, that blue object is chosen.
    *   If not, but a blue object exists with the same shape as the red object, that blue object is chosen.

**Facts**


```yaml
objects:
  - color: white (0)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x1)
    action: always changes color to blue (1)
  - color: red (2)
    property: forms a single contiguous object (assumption based on examples)
    shape: variable (e.g., 1x1, 2x2, 3x3)
    action:
      - changes color to white (0) IF its shape matches the white object's shape AND no blue object shares that shape.
      - remains unchanged otherwise.
  - color: blue (1)
    property: forms one or more contiguous objects/regions
    shape: variable
    action:
      - one specific blue object changes color to white (0) IF the red object does not change to white.
      - remains unchanged otherwise (except where white pixels become blue).
  - color: green (3)
    property: appears as background or border
    action: remains unchanged

relationships:
  - type: shape_comparison
    between: [white object, red object]
    purpose: determines if red object changes to white (Rule A trigger)
  - type: shape_comparison
    between: [white object, blue objects]
    purpose: determines if Rule A is overridden; identifies candidate blue object for Rule B
  - type: shape_comparison
    between: [red object, blue objects]
    purpose: identifies candidate blue object for Rule B (if no blue object matches white shape)

transformation_rules:
  - rule: A (Primary Swap)
    condition: shape(white_object) == shape(red_object) AND NOT EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - change red_object pixels to white (0)
  - rule: B (White->Blue, Blue->White)
    condition: shape(white_object) != shape(red_object) OR EXISTS blue_object WHERE shape(blue_object) == shape(white_object)
    steps:
      - change white_object pixels to blue (1)
      - leave red_object unchanged
      - find target_blue_object:
          - IF EXISTS blue_object WHERE shape(blue_object) == shape(white_object):
              target_blue_object = that blue_object
          - ELSE IF EXISTS blue_object WHERE shape(blue_object) == shape(red_object):
              target_blue_object = that blue_object
          - ELSE:
              # (Case not observed in examples, default might be no change or error)
              target_blue_object = None
      - IF target_blue_object exists:
          change target_blue_object pixels to white (0)

```


**Natural Language Program**

1.  Identify the single contiguous object composed of white (0) pixels. Determine its shape and location. Let this be `W`.
2.  Identify the single contiguous object composed of red (2) pixels. Determine its shape and location. Let this be `R`.
3.  Identify all contiguous objects composed of blue (1) pixels. Determine their shapes and locations. Let this set be `{B}`.
4.  Compare the shape of `W` with the shape of `R`.
5.  Check if any blue object `Bi` in `{B}` has the same shape as `W`.
6.  **Decision Point:**
    *   **IF** the shape of `W` is identical to the shape of `R`, **AND** no blue object `Bi` has the same shape as `W`:
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Change all pixels corresponding to `R` in the output grid to white (0).
    *   **ELSE** (the shapes of `W` and `R` differ, OR a blue object `Bi` has the same shape as `W`):
        *   Create the output grid by copying the input grid.
        *   Change all pixels corresponding to `W` in the output grid to blue (1).
        *   Leave the pixels corresponding to `R` unchanged (still red).
        *   Find a target blue object `Bk` to change to white:
            *   Search for a blue object `Bi` in `{B}` whose shape is identical to the shape of `W`. If found, this is `Bk`.
            *   If no such blue object is found, search for a blue object `Bj` in `{B}` whose shape is identical to the shape of `R`. If found, this is `Bk`.
        *   If a target blue object `Bk` was found, change all pixels corresponding to `Bk` in the output grid to white (0).
7.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies single contiguous objects of white (0) and red (2) pixels, and all contiguous objects of blue (1) pixels.
Compares the shapes of the white and red objects.
Also checks if any blue object has the same shape as the white object.

Transformation Rules:
1.  All white pixels always change to blue pixels.
2.  Conditional Swap/Change:
    a. If the white object and red object have the exact same shape AND no blue object shares the white object's shape, then the red object's pixels change to white.
    b. Otherwise (white/red shapes differ OR a blue object matches the white shape):
        i. The red object remains unchanged.
        ii. Find a blue object to change to white:
            - First, look for a blue object with the same shape as the original white object. If found, change its pixels to white.
            - If not found, look for a blue object with the same shape as the red object. If found, change its pixels to white.
        iii. If no suitable blue object is found based on shape matching (white's shape then red's shape), no blue object changes to white.
3. All other pixels (e.g., green background) remain unchanged.
"""

def find_objects(grid, color):
    """
    Finds all contiguous objects of a specific color in the grid.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color of the objects to find.

    Returns:
        list: A list of sets, where each set contains the (row, col) tuples
              of pixels belonging to a single contiguous object.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_coords.add((r, c))

                while q:
                    row, col = q.popleft()
                    # Check 4-directional neighbors (could extend to 8 if needed)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            obj_coords.add((nr, nc))
                
                if obj_coords:
                    objects.append(obj_coords)
    return objects

def get_object_shape(obj_coords):
    """
    Calculates a canonical shape representation for an object.

    Args:
        obj_coords (set): A set of (row, col) tuples for the object's pixels.

    Returns:
        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,
                   normalized to the top-left corner (0, 0). Returns an empty
                   frozenset if obj_coords is empty.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def transform(input_grid):
    """
    Applies the transformation rules to the input grid.
    """
    output_grid = np.copy(input_grid)

    # 1. Identify objects
    white_objects = find_objects(input_grid, 0)
    red_objects = find_objects(input_grid, 2)
    blue_objects = find_objects(input_grid, 1)

    # Assume exactly one white and one red object based on examples
    if not white_objects or not red_objects:
        # Handle cases where expected objects are missing (e.g., return input)
        # For this specific problem structure, we might assume they always exist.
        # If they might not, add error handling or specific logic here.
        # Based on examples, it seems safe to assume one of each.
        if not white_objects: return output_grid # Or raise error
        if not red_objects: return output_grid # Or raise error
        
    w_coords = white_objects[0]
    r_coords = red_objects[0]

    # 2. Determine shapes
    w_shape = get_object_shape(w_coords)
    r_shape = get_object_shape(r_coords)

    blue_objects_with_shapes = []
    for b_coords in blue_objects:
        b_shape = get_object_shape(b_coords)
        blue_objects_with_shapes.append({'coords': b_coords, 'shape': b_shape})

    # 3. Check conditions
    exists_blue_matches_w_shape = any(b['shape'] == w_shape for b in blue_objects_with_shapes)

    # --- Apply Transformation Rules ---

    # Rule 1: White always becomes Blue
    for r, c in w_coords:
        output_grid[r, c] = 1

    # Rule 2: Conditional Swap/Change
    if w_shape == r_shape and not exists_blue_matches_w_shape:
        # Rule 2a: Red becomes White
        for r_coord_r, r_coord_c in r_coords:
            output_grid[r_coord_r, r_coord_c] = 0
    else:
        # Rule 2b: Red stays Red, find a Blue to become White
        target_blue_coords = None
        
        # First check for blue matching white's shape
        for b_obj in blue_objects_with_shapes:
            if b_obj['shape'] == w_shape:
                target_blue_coords = b_obj['coords']
                break
        
        # If not found, check for blue matching red's shape
        if target_blue_coords is None:
            for b_obj in blue_objects_with_shapes:
                if b_obj['shape'] == r_shape:
                    target_blue_coords = b_obj['coords']
                    break

        # If a target blue object was found, change it to white
        if target_blue_coords:
            for b_coord_r, b_coord_c in target_blue_coords:
                # Check if this pixel wasn't originally white (now blue)
                # This check prevents overwriting pixels that just turned blue from white
                # if input_grid[b_coord_r, b_coord_c] == 1: 
                # We change based on coords, so this check isn't strictly needed
                # if the logic correctly identifies distinct objects.
                output_grid[b_coord_r, b_coord_c] = 0
                
    return output_grid
```
```python
import numpy as np
from collections import deque
from typing import Set, Tuple, Optional, List, FrozenSet

"""
Transformation rule based on object shapes and colors:

1.  Identify the single contiguous white (0) object (W) and the single 
    contiguous red (2) object (R) using 8-directional connectivity. 
    Determine their shapes relative to their top-left corners (shapeW, shapeR) 
    and their absolute coordinates (W_coords, R_coords).
2.  Identify all blue (1) pixels in the input grid (B_pixels).
3.  Initialize the output grid as a copy of the input grid.
4.  **Mandatory Change:** Change all pixels at W_coords to blue (1) in the output grid.
5.  **Conditional Changes:**
    a. Search within the original blue pixels (B_pixels) for a contiguous 
       sub-region that exactly matches shapeW. Let the coordinates of the first 
       such sub-region found be `TargetB_W_coords`.
    b. **Case 1: shapeW == shapeR**
        i. If `TargetB_W_coords` exists (a blue sub-region matching W was found):
           - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.
           - Leave the red object R unchanged.
        ii. If `TargetB_W_coords` does not exist:
           - Change the pixels at `R_coords` (the red object) to white (0) in the output grid.
    c. **Case 2: shapeW != shapeR**
        i. Leave the red object R unchanged.
        ii. If `TargetB_W_coords` exists:
            - Change the pixels at `TargetB_W_coords` to white (0) in the output grid.
        iii. If `TargetB_W_coords` does not exist:
            - Search within the original blue pixels (B_pixels) for a contiguous 
              sub-region that exactly matches shapeR. Let the first found be 
              `TargetB_R_coords`.
            - If `TargetB_R_coords` exists:
                - Change the pixels at `TargetB_R_coords` to white (0) in the output grid.
            - (Else: If neither matching sub-region is found, no further blue pixels change).
6. Return the modified output grid.
"""

def find_objects(grid: np.ndarray, color: int, connectivity: int = 8) -> List[Set[Tuple[int, int]]]:
    """
    Finds all contiguous objects of a specific color in the grid using BFS.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color of the objects to find.
        connectivity (int): 4 or 8 for neighbor checking.

    Returns:
        list: A list of sets, where each set contains the (row, col) tuples
              of pixels belonging to a single contiguous object.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    if connectivity == 8:
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    else: # Default to 4-connectivity
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_coords.add((r, c))

                while q:
                    row, col = q.popleft()
                    for dr, dc in deltas:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            obj_coords.add((nr, nc))
                
                if obj_coords:
                    objects.append(obj_coords)
    return objects

def get_object_shape(obj_coords: Set[Tuple[int, int]]) -> FrozenSet[Tuple[int, int]]:
    """
    Calculates a canonical shape representation for an object.

    Args:
        obj_coords (set): A set of (row, col) tuples for the object's pixels.

    Returns:
        frozenset: A frozenset of relative (dr, dc) coordinates representing the shape,
                   normalized to the top-left corner (0, 0). Returns an empty
                   frozenset if obj_coords is empty.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def find_subregion_with_shape(grid: np.ndarray, 
                               target_shape: FrozenSet[Tuple[int, int]], 
                               color_to_search: int) -> Optional[Set[Tuple[int, int]]]:
    """
    Searches the grid for the first contiguous sub-region of a specific color 
    that matches the target shape.

    Args:
        grid (np.ndarray): The grid to search within (should be the original input).
        target_shape (frozenset): The relative coordinates defining the shape.
        color_to_search (int): The color of pixels that can form the sub-region.

    Returns:
        Optional[Set[Tuple[int, int]]]: The absolute coordinates of the first 
                                         matching sub-region found, or None.
    """
    if not target_shape:
        return None
        
    rows, cols = grid.shape
    
    # Iterate through all possible top-left anchor points in the grid
    for r_anchor in range(rows):
        for c_anchor in range(cols):
            # Check if the anchor pixel itself has the right color
            if grid[r_anchor, c_anchor] == color_to_search:
                match = True
                current_subregion_coords = set()
                
                # Check if all pixels defined by the shape relative to the anchor exist and have the correct color
                for dr, dc in target_shape:
                    nr, nc = r_anchor + dr, c_anchor + dc
                    
                    # Check bounds and color
                    if not (0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color_to_search):
                        match = False
                        break # This anchor point doesn't work for this shape
                    current_subregion_coords.add((nr, nc))
                
                # If all pixels of the shape matched
                if match:
                    # Verify the size matches (ensures no extra pixels accidentally included if shape has holes)
                    if len(current_subregion_coords) == len(target_shape):
                         return current_subregion_coords # Found the first match

    return None # No matching sub-region found

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rules based on object shapes and colors.
    """
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify white (W) and red (R) objects
    white_objects = find_objects(input_grid, 0, connectivity=8)
    red_objects = find_objects(input_grid, 2, connectivity=8)

    # Assume exactly one white and one red object based on examples
    if not white_objects or not red_objects:
        # If assumptions fail, return the unchanged grid or handle error
        return output_grid 
        
    w_coords = white_objects[0]
    r_coords = red_objects[0]

    # 2. Determine shapes
    shapeW = get_object_shape(w_coords)
    shapeR = get_object_shape(r_coords)

    # (Step 3 is implicit: B_pixels are checked within find_subregion_with_shape)

    # 4. Mandatory Change: White becomes Blue
    for r, c in w_coords:
        if 0 <= r < rows and 0 <= c < cols: # Bounds check just in case
             output_grid[r, c] = 1

    # 5. Conditional Changes
    
    # 5a. Search for blue sub-region matching white shape in the *original* grid
    targetB_W_coords = find_subregion_with_shape(input_grid, shapeW, 1)

    # 5b. Case 1: shapeW == shapeR
    if shapeW == shapeR:
        if targetB_W_coords is not None:
            # Change the found blue sub-region to white
            for r, c in targetB_W_coords:
                 if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
            # Leave red object unchanged
        else:
            # Change the red object to white
            for r, c in r_coords:
                if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
    
    # 5c. Case 2: shapeW != shapeR
    else:
        # Leave red object unchanged
        if targetB_W_coords is not None:
            # Change the found blue sub-region (matching white) to white
            for r, c in targetB_W_coords:
                if 0 <= r < rows and 0 <= c < cols:
                    output_grid[r, c] = 0
        else:
            # Search for blue sub-region matching red shape in the *original* grid
            targetB_R_coords = find_subregion_with_shape(input_grid, shapeR, 1)
            if targetB_R_coords is not None:
                # Change the found blue sub-region (matching red) to white
                for r, c in targetB_R_coords:
                    if 0 <= r < rows and 0 <= c < cols:
                        output_grid[r, c] = 0
            # Else: No matching blue sub-regions found for either shape, no further changes.

    # 6. Return the result
    return output_grid
```
```python
import numpy as np
from collections import deque
from typing import Set, Tuple, Optional, List, FrozenSet, Dict

"""
Transforms grid by swapping colors based on object shapes. A white object 
always becomes blue. Either the red object or a blue object becomes white 
based on shape comparison and existence of matching blue objects.

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the single contiguous white object (W). Store its coordinates 
    (`W_coords`) and calculate its canonical shape (`shapeW`).
3.  Identify the single contiguous red object (R). Store its coordinates 
    (`R_coords`) and calculate its canonical shape (`shapeR`).
4.  Identify all contiguous blue objects ({B}). For each blue object `Bi`, store 
    its coordinates (`Bi_coords`), calculate its canonical shape (`shapeBi`), and
    determine its top-left anchor point (`Bi_anchor`).
5.  **Mandatory Change:** Change all pixels at `W_coords` in the output grid to 
    blue (1).
6.  Find all blue objects `Bk` from {B} such that `shapeBk == shapeW`. Let this 
    collection be `MatchingW_BlueObjects`.
7.  Find all blue objects `Bj` from {B} such that `shapeBj == shapeR`. Let this 
    collection be `MatchingR_BlueObjects`.
8.  **Conditional Change (Object to become White):**
    a.  **IF `shapeW == shapeR`:**
        i.  IF `MatchingW_BlueObjects` is **empty**:
            Change all pixels at `R_coords` in the output grid to white (0).
        ii. ELSE (`MatchingW_BlueObjects` is **not empty**):
            Select one target object `Bt` from `MatchingW_BlueObjects` (e.g., the 
            one with the largest top-left anchor: max row, then max col).
            Change all pixels at `Bt_coords` in the output grid to white (0).
            *(Note: This step correctly handles Ex2, Ex3, but incorrectly handles 
            Ex1, Ex4 based on expected outputs).*
    b.  **ELSE (`shapeW != shapeR`):**
        i.  IF `MatchingW_BlueObjects` is **not empty**:
            Select one target object `Bt` from `MatchingW_BlueObjects` (using the 
            same selection rule).
            Change all pixels at `Bt_coords` in the output grid to white (0).
        ii. ELSE (`MatchingW_BlueObjects` is **empty**):
            IF `MatchingR_BlueObjects` is **not empty**:
                Select one target object `Bt` from `MatchingR_BlueObjects` (using 
                the same selection rule).
                Change all pixels at `Bt_coords` in the output grid to white (0).
            ELSE:
                No object changes to white (only W changed to blue).
9.  Return the modified output grid.
"""

# --- Helper Functions ---

def find_objects(grid: np.ndarray, color: int, connectivity: int = 8) -> List[Dict]:
    """
    Finds all contiguous objects of a specific color in the grid using BFS.
    Returns a list of dictionaries, each containing 'coords' and 'anchor'.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    if connectivity == 8:
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    else: # Default to 4-connectivity
        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, min_c = r, c  # Initialize anchor

                while q:
                    row, col = q.popleft()
                    obj_coords.add((row, col))
                    min_r = min(min_r, row)
                    min_c = min(min_c, col)

                    for dr, dc in deltas:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if obj_coords:
                    # Recalculate anchor accurately after finding all coords
                    current_min_r = min(coord[0] for coord in obj_coords)
                    current_min_c = min(coord[1] for coord in obj_coords)
                    objects.append({
                        'coords': obj_coords,
                        'anchor': (current_min_r, current_min_c)
                    })
    return objects

def get_object_shape(obj_coords: Set[Tuple[int, int]]) -> FrozenSet[Tuple[int, int]]:
    """
    Calculates a canonical shape representation for an object.
    """
    if not obj_coords:
        return frozenset()
    
    min_r = min(r for r, c in obj_coords)
    min_c = min(c for r, c in obj_coords)
    
    shape = frozenset((r - min_r, c - min_c) for r, c in obj_coords)
    return shape

def select_target_blue_object(candidate_objects: List[Dict]) -> Optional[Dict]:
    """
    Selects one blue object from the candidates based on the largest anchor.
    Largest anchor means: max row, then max column.
    """
    if not candidate_objects:
        return None
    
    # Sort by anchor: primarily by row (descending), secondarily by col (descending)
    # Since max() finds the first maximum in case of ties in the primary key, 
    # we sort first by col (ascending), then by row (ascending) and take the last element.
    # Alternatively, use a custom key with max().
    
    # Using max with a custom key (row, col)
    selected_object = max(candidate_objects, key=lambda obj: obj['anchor'])
    
    return selected_object

# --- Main Transformation Function ---

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rules based on object shapes and colors.
    """
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify white (W) object
    white_objects_data = find_objects(input_grid, 0, connectivity=8)
    if not white_objects_data: return output_grid # Should not happen per task desc
    w_data = white_objects_data[0]
    w_coords = w_data['coords']
    shapeW = get_object_shape(w_coords)

    # 2. Identify red (R) object
    red_objects_data = find_objects(input_grid, 2, connectivity=8)
    if not red_objects_data: return output_grid # Should not happen per task desc
    r_data = red_objects_data[0]
    r_coords = r_data['coords']
    shapeR = get_object_shape(r_coords)

    # 3. Identify all blue (B) objects and calculate shapes/anchors
    blue_objects_data = find_objects(input_grid, 1, connectivity=8)
    for b_obj in blue_objects_data:
        b_obj['shape'] = get_object_shape(b_obj['coords'])

    # 4. Mandatory Change: White becomes Blue
    for r, c in w_coords:
        if 0 <= r < rows and 0 <= c < cols:
             output_grid[r, c] = 1

    # 5. Filter blue objects matching W's shape
    matchingW_blue_objects = [b for b in blue_objects_data if b['shape'] == shapeW]

    # 6. Filter blue objects matching R's shape
    matchingR_blue_objects = [b for b in blue_objects_data if b['shape'] == shapeR]
    
    # 7. Conditional Change (Object to become White)
    target_coords_to_make_white = None

    # 7a. Case: shapeW == shapeR
    if shapeW == shapeR:
        if not matchingW_blue_objects:
            # 7a.i: No blue object matches W/R shape -> R becomes White
            target_coords_to_make_white = r_coords
        else:
            # 7a.ii: Blue object(s) match W/R shape -> Select one B and make it White
            # (Note: This branch correctly handles Ex2, Ex3, but fails Ex1, Ex4)
            selected_blue_obj = select_target_blue_object(matchingW_blue_objects)
            if selected_blue_obj:
                target_coords_to_make_white = selected_blue_obj['coords']
            # If selection fails (shouldn't if list is not empty), R remains unchanged implicitly
            
    # 7b. Case: shapeW != shapeR
    else:
        if matchingW_blue_objects:
            # 7b.i: Blue object(s) match W shape -> Select one B and make it White
            selected_blue_obj = select_target_blue_object(matchingW_blue_objects)
            if selected_blue_obj:
                target_coords_to_make_white = selected_blue_obj['coords']
        else:
            # 7b.ii: No blue object matches W shape. Check for match with R shape.
            if matchingR_blue_objects:
                selected_blue_obj = select_target_blue_object(matchingR_blue_objects)
                if selected_blue_obj:
                    target_coords_to_make_white = selected_blue_obj['coords']
            # Else: No blue object matches W or R shape -> No further changes

    # Apply the change to white if a target was determined
    if target_coords_to_make_white:
        for r, c in target_coords_to_make_white:
             if 0 <= r < rows and 0 <= c < cols:
                 # Ensure we don't overwrite a pixel that just turned blue from white, 
                 # although this shouldn't happen if objects are distinct.
                 # Check original color? No, just apply based on determined target coords.
                 output_grid[r, c] = 0

    # 8. Return the result
    return output_grid
```
