{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on the number and location of connected components \nformed by blue (1) and green (3) pixels (\"pattern objects\").\n\n1. Initialize the output grid as a copy of the input grid, then set all \n   non-background (non-azure, 8) pixels to the background color (azure, 8).\n2. Find all connected components consisting of blue (1) or green (3) pixels. \n   Connectivity is defined by adjacent (non-diagonal) cells. Blue and green \n   pixels are considered connected to each other. Count these components.\n3. If exactly one component is found:\n   a. Locate the column index of the single yellow (4) marker pixel.\n   b. Fill this entire column in the output grid with red (2).\n4. If more than one component is found:\n   a. For each component, determine its minimum bounding box.\n   b. Calculate the union of all these bounding boxes.\n   c. Fill all cells within the union of the bounding boxes in the output \n      grid with red (2).\n5. Return the modified output grid.\n\"\"\"\n\ndef find_connected_components(grid, target_colors):\n    \"\"\"\n    Finds all connected components of specified colors in the grid.\n    Uses Breadth-First Search (BFS).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in target_colors and not visited[r, c]:\n                # Start BFS for a new component\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] in target_colors and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                components.append(component)\n                \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"Calculates the bounding box of a component.\"\"\"\n    if not component:\n        return None # Or raise an error\n    \n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on pattern object count.\n    \"\"\"\n    # Define colors\n    background_color = 8\n    pattern_colors = {1, 3} # Blue and Green\n    marker_color_yellow = 4\n    output_color = 2 # Red\n\n    # Initialize output_grid as a copy of input, then clear non-background\n    output_grid = np.copy(input_grid)\n    output_grid[output_grid != background_color] = background_color\n    \n    rows, cols = input_grid.shape\n\n    # Find pattern objects (connected components of blue or green)\n    pattern_objects = find_connected_components(input_grid, pattern_colors)\n    num_pattern_objects = len(pattern_objects)\n\n    # Case 1: Exactly one pattern object\n    if num_pattern_objects == 1:\n        # Find the column of the yellow marker\n        marker_col = -1\n        yellow_locations = np.where(input_grid == marker_color_yellow)\n        if len(yellow_locations[1]) > 0: # Check if yellow marker exists\n             marker_col = yellow_locations[1][0] # Assume only one yellow marker\n        \n        # Check if marker was found (robustness)\n        if marker_col != -1:\n            # Fill the marker column with the output color\n            output_grid[:, marker_col] = output_color\n        else:\n            # Fallback or error handling if no yellow marker found, \n            # although the problem description implies it will be there.\n            # For now, leave the grid as background if marker is missing.\n            pass \n\n    # Case 2: More than one pattern object\n    elif num_pattern_objects > 1:\n        # Calculate the union of bounding boxes\n        min_union_r, min_union_c = rows, cols\n        max_union_r, max_union_c = -1, -1\n        found_box = False\n\n        for component in pattern_objects:\n            bbox = get_bounding_box(component)\n            if bbox:\n                found_box = True\n                min_r, min_c, max_r, max_c = bbox\n                min_union_r = min(min_union_r, min_r)\n                min_union_c = min(min_union_c, min_c)\n                max_union_r = max(max_union_r, max_r)\n                max_union_c = max(max_union_c, max_c)\n\n        # Fill the union of bounding boxes if any boxes were found\n        if found_box:\n            for r in range(min_union_r, max_union_r + 1):\n                for c in range(min_union_c, max_union_c + 1):\n                     # Check bounds just in case something weird happened with initialization\n                    if 0 <= r < rows and 0 <= c < cols:\n                        output_grid[r, c] = output_color\n                        \n    # Case 3: Zero pattern objects (implicitly handled, output grid remains background)\n    # No specific action needed as output grid is already initialized to background.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9116,
    "candidates_token_count": 1446,
    "total_token_count": 10562,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.703739,
  "retries": 1
}