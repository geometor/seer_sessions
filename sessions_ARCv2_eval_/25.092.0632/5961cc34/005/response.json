{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on the number and location of connected components \nformed by blue (1) and green (3) pixels (\"pattern objects\").\n\n1. Initialize the output grid with the background color (azure, 8).\n2. Find all connected components consisting of blue (1) or green (3) pixels. \n   Connectivity is defined by adjacent (non-diagonal) cells. Blue and green \n   pixels are considered connected to each other. Count these components.\n3. If exactly one component is found:\n   a. Locate the column index of the single yellow (4) marker pixel.\n   b. Fill this entire column in the output grid with red (2).\n4. If more than one component is found:\n   a. Determine the overall minimum bounding box that encompasses *all* the \n      pattern objects found.\n   b. Fill the area within this single encompassing bounding box in the output \n      grid with red (2).\n5. If zero pattern objects are found, the output grid remains the background color.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_connected_components(grid, target_colors):\n    \"\"\"\n    Finds all connected components of specified colors in the grid.\n    Uses Breadth-First Search (BFS). Adjacent means sharing an edge (not diagonal).\n    \n    Args:\n        grid (np.array): The input grid.\n        target_colors (set): A set of integer color values to consider part of components.\n        \n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples of a component.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell has a target color and hasn't been visited yet, start a new search\n            if grid[r, c] in target_colors and not visited[r, c]:\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Perform BFS\n                while q:\n                    row, col = q.popleft()\n                    component.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if the neighbor is within bounds, has a target color, and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] in target_colors and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the found component to the list if it's not empty\n                if component:\n                    components.append(component)\n                \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the minimum bounding box (min_row, min_col, max_row, max_col) \n    for a given component.\n    \n    Args:\n        component (set): A set of (row, col) tuples representing a component.\n        \n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if the component is empty.\n    \"\"\"\n    if not component:\n        return None \n    \n    # Find the min/max row and column indices from the component's coordinates\n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on pattern object count.\n    \"\"\"\n    # Define colors used in the task\n    background_color = 8  # azure\n    pattern_colors = {1, 3} # Blue and Green\n    marker_color_yellow = 4 # Yellow\n    output_color = 2      # Red\n\n    rows, cols = input_grid.shape\n    # Initialize output_grid with the background color\n    output_grid = np.full_like(input_grid, background_color)\n    \n    # Find pattern objects (connected components of blue or green)\n    pattern_objects = find_connected_components(input_grid, pattern_colors)\n    num_pattern_objects = len(pattern_objects)\n\n    # Case 1: Exactly one pattern object\n    if num_pattern_objects == 1:\n        # Find the column of the yellow marker\n        marker_col = -1\n        yellow_locations = np.where(input_grid == marker_color_yellow)\n        # Ensure a yellow marker was actually found\n        if len(yellow_locations[1]) > 0: \n             marker_col = yellow_locations[1][0] # Assume only one yellow marker column is relevant\n        \n        # If a valid marker column was found, fill it\n        if marker_col != -1:\n            output_grid[:, marker_col] = output_color\n        # else: If no yellow marker found, the output grid remains background (as initialized)\n            \n    # Case 2: More than one pattern object\n    elif num_pattern_objects > 1:\n        # Calculate the overall bounding box encompassing all components\n        min_union_r, min_union_c = rows, cols  # Initialize with max possible values\n        max_union_r, max_union_c = -1, -1      # Initialize with min possible values\n        found_any_box = False\n\n        # Iterate through each found pattern object to find the overall min/max coords\n        for component in pattern_objects:\n            bbox = get_bounding_box(component)\n            if bbox:\n                found_any_box = True\n                min_r, min_c, max_r, max_c = bbox\n                min_union_r = min(min_union_r, min_r)\n                min_union_c = min(min_union_c, min_c)\n                max_union_r = max(max_union_r, max_r)\n                max_union_c = max(max_union_c, max_c)\n\n        # Fill the union bounding box if at least one component was found\n        if found_any_box:\n            # Use slicing for efficient filling of the encompassing rectangle\n            output_grid[min_union_r : max_union_r + 1, min_union_c : max_union_c + 1] = output_color\n                        \n    # Case 3: Zero pattern objects \n    # No specific action needed as output_grid is already initialized to background.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24737,
    "candidates_token_count": 1628,
    "total_token_count": 26365,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.228605,
  "retries": 1
}