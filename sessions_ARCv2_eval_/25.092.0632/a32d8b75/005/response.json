{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransform the input grid based on a rule defined by a 5x5 key region in the top-left corner and applied to a source region to the right.\n\n1.  Isolate the 5x5 key region (rows 0-4, columns 0-4) and the source region (all rows, columns 6 onwards).\n2.  Identify the two distinct non-white colors (C1, C2) in the central 3x3 area of the key region (`key_region[1:4, 1:4]`). Sort them numerically for consistency.\n3.  Determine the target color (T) to be replaced in the source region based on the sorted pair {C1, C2}:\n    - {4(yellow), 7(orange)} -> target 3(green)\n    - {1(blue), 2(red)} -> target 8(azure)\n    - {3(green), 8(azure)} -> target 5(gray)\n4.  Generate a 3x3 replacement pattern by swapping C1 and C2 within the central 3x3 key pattern source. Other colors (like white background) remain unchanged.\n5.  Initialize the output grid:\n    - If the key colors are {1(blue), 2(red)}, create an output grid of the same dimensions as the source region, filled entirely with 8(azure).\n    - Otherwise, create the output grid as a direct copy of the source region.\n6.  Iterate through the source region. For every pixel that matches the target color (T), update the corresponding pixel in the output grid using the replacement pattern, tiled using modulo 3 indexing (row % 3, col % 3). Non-target pixels remain as initialized in step 5.\n7.  Return the transformed output grid.\n\"\"\"\n\ndef find_key_colors(key_pattern_source):\n    \"\"\"Finds the two distinct non-white colors in the 3x3 key pattern source.\"\"\"\n    # Find unique colors in the 3x3 pattern\n    unique_colors = np.unique(key_pattern_source)\n    # Filter out white (0)\n    non_white_colors = unique_colors[unique_colors != 0] \n    # Expect exactly two non-white colors based on examples\n    if len(non_white_colors) != 2:\n        # Add basic error handling, though examples suggest this won't happen.\n        # Consider more robust error handling or assumptions if needed.\n        print(f\"Warning: Expected 2 non-white key colors, found {len(non_white_colors)}: {non_white_colors}. Using first two if available.\")\n        if len(non_white_colors) < 2:\n             raise ValueError(\"Not enough non-white key colors found.\")\n        non_white_colors = non_white_colors[:2]\n\n    # Sort for consistent order when mapping\n    return tuple(sorted(non_white_colors))\n\ndef determine_target_color(key_colors_tuple):\n    \"\"\"Determines the target color based on the pair of key colors.\"\"\"\n    # Predefined mapping from key color pairs to target colors\n    mapping = {\n        (4, 7): 3,  # yellow, orange -> green\n        (1, 2): 8,  # blue, red -> azure\n        (3, 8): 5   # green, azure -> gray\n    }\n    if key_colors_tuple not in mapping:\n        raise ValueError(f\"Unknown key color combination: {key_colors_tuple}\")\n    return mapping[key_colors_tuple]\n\ndef generate_replacement_pattern(key_pattern_source, color1, color2):\n    \"\"\"Generates the 3x3 replacement pattern by swapping color1 and color2.\"\"\"\n    # Create a copy of the 3x3 key pattern\n    pattern = np.copy(key_pattern_source)\n    # Identify locations of the two key colors\n    mask_c1 = (key_pattern_source == color1)\n    mask_c2 = (key_pattern_source == color2)\n    # Swap the two key colors within the pattern\n    pattern[mask_c1] = color2\n    pattern[mask_c2] = color1\n    return pattern\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # 1. Isolate Regions\n    key_region = input_array[0:5, 0:5]\n    source_region = input_array[:, 6:] # Assume separator is always at column 5\n    \n    # Handle potential empty source region \n    if source_region.shape[1] == 0:\n        return [] # Return empty list if source region has no columns\n    \n    rows, cols = source_region.shape\n\n    # 2. Analyze Key (Central 3x3)\n    key_pattern_source = key_region[1:4, 1:4]\n    try:\n        key_colors = find_key_colors(key_pattern_source)\n        color1, color2 = key_colors # Already sorted\n    except ValueError as e:\n        # Handle cases where key colors aren't as expected\n        print(f\"Error processing key colors: {e}\")\n        # Depending on requirements, might return empty, original, or raise\n        return source_region.tolist() # Return original source as fallback\n\n    # 3. Determine Target Color\n    try:\n        target_color = determine_target_color(key_colors)\n    except ValueError as e:\n        print(f\"Error determining target color: {e}\")\n        # Fallback or error handling\n        return source_region.tolist() \n\n    # 4. Generate Replacement Pattern\n    replacement_pattern = generate_replacement_pattern(key_pattern_source, color1, color2)\n\n    # 5. Initialize Output Grid\n    if key_colors == (1, 2): # Special case for blue/red key\n        # Fill with azure(8)\n        output_grid = np.full_like(source_region, fill_value=8)\n    else:\n        # Otherwise, start with a copy of the source region\n        output_grid = np.copy(source_region)\n\n    # 6. Apply Transformation: Overwrite target pixels\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the original pixel in the source was the target color\n            if source_region[r, c] == target_color:\n                # If it was, replace the corresponding pixel in the output grid\n                # using the tiled replacement pattern\n                output_grid[r, c] = replacement_pattern[r % 3, c % 3]\n            # No 'else' needed: non-target pixels were already handled in step 5\n\n    # 7. Final Output\n    # Convert the final NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23691,
    "candidates_token_count": 1602,
    "total_token_count": 25293,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.969596,
  "retries": 1
}