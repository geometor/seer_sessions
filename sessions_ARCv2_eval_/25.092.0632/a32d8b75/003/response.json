{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransform the input grid based on a rule defined by a 5x5 key region in the top-left corner.\n\n1.  Isolate the 5x5 key region (rows 0-4, columns 0-4) and the source region (all rows, columns 6 onwards).\n2.  Identify the two distinct non-white colors (C1, C2) in the central 3x3 area of the key region (`key_region[1:4, 1:4]`).\n3.  Determine the target color (T) to be replaced in the source region based on the pair {C1, C2}:\n    - {yellow(4), orange(7)} -> target green(3)\n    - {blue(1), red(2)} -> target azure(8)\n    - {green(3), azure(8)} -> target gray(5)\n4.  Generate a 3x3 replacement pattern by swapping C1 and C2 within the central 3x3 key pattern source. Other colors remain unchanged.\n5.  Determine the background fill color for the output grid based on the key colors and the unique non-target colors in the source region:\n    - If key colors are {blue(1), red(2)}, the background fill color is azure (8).\n    - Otherwise, find unique colors in the source region excluding the target color (T).\n        - If exactly one unique non-target color exists, use that color as the background fill.\n        - If zero or multiple unique non-target colors exist, use gray (5) as the background fill.\n6.  Initialize the output grid with the same dimensions as the source region, filled with the determined background fill color.\n7.  Iterate through the source region. For every pixel that matches the target color (T), update the corresponding pixel in the output grid using the replacement pattern, tiled using modulo 3 indexing (row % 3, col % 3).\n\"\"\"\n\ndef find_key_colors(key_pattern_source):\n    \"\"\"Finds the two distinct non-white colors in the 3x3 key pattern source.\"\"\"\n    # Find unique colors in the 3x3 pattern\n    unique_colors = np.unique(key_pattern_source)\n    # Filter out white (0)\n    non_white_colors = unique_colors[unique_colors != 0] \n    # Expect exactly two non-white colors based on examples\n    if len(non_white_colors) != 2:\n        raise ValueError(f\"Expected 2 non-white key colors, found {len(non_white_colors)}: {non_white_colors}\")\n    # Sort for consistent order when mapping\n    return tuple(sorted(non_white_colors))\n\ndef determine_target_color(key_colors_tuple):\n    \"\"\"Determines the target color based on the pair of key colors.\"\"\"\n    # Predefined mapping from key color pairs to target colors\n    mapping = {\n        (4, 7): 3,  # yellow, orange -> green\n        (1, 2): 8,  # blue, red -> azure\n        (3, 8): 5   # green, azure -> gray\n    }\n    if key_colors_tuple not in mapping:\n        raise ValueError(f\"Unknown key color combination: {key_colors_tuple}\")\n    return mapping[key_colors_tuple]\n\ndef generate_replacement_pattern(key_pattern_source, color1, color2):\n    \"\"\"Generates the 3x3 replacement pattern by swapping color1 and color2.\"\"\"\n    # Create a copy of the 3x3 key pattern\n    pattern = np.copy(key_pattern_source)\n    # Swap the two key colors within the pattern\n    pattern[key_pattern_source == color1] = color2\n    pattern[key_pattern_source == color2] = color1\n    return pattern\n\ndef determine_background_color(source_region, target_color, key_colors_tuple):\n    \"\"\"Determines the background fill color for the output grid.\"\"\"\n    # Special case for key colors blue(1) and red(2)\n    if key_colors_tuple == (1, 2):\n        return 8 # Background is always azure(8)\n\n    # General case: analyze unique colors in the source region\n    unique_source_colors = np.unique(source_region)\n    # Find unique colors excluding the target color\n    non_target_unique_colors = unique_source_colors[unique_source_colors != target_color]\n\n    # If exactly one unique non-target color exists, use it\n    if len(non_target_unique_colors) == 1:\n        return non_target_unique_colors[0]\n    # Otherwise (zero or multiple unique non-target colors), use gray(5)\n    else:\n        return 5\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # 1. Isolate Regions\n    key_region = input_array[0:5, 0:5]\n    source_region = input_array[:, 6:]\n    \n    # Handle empty source region (though unlikely based on examples)\n    if source_region.shape[1] == 0:\n        return [] \n    \n    rows, cols = source_region.shape\n\n    # 2. Analyze Key (Central 3x3)\n    key_pattern_source = key_region[1:4, 1:4]\n    key_colors = find_key_colors(key_pattern_source)\n    color1, color2 = key_colors # Already sorted\n\n    # 3. Determine Target Color\n    target_color = determine_target_color(key_colors)\n\n    # 4. Generate Replacement Pattern\n    replacement_pattern = generate_replacement_pattern(key_pattern_source, color1, color2)\n\n    # 5. Determine Background Fill Color\n    background_fill = determine_background_color(source_region, target_color, key_colors)\n\n    # 6. Initialize Output Grid\n    # Create output grid with same dimensions as source, filled with background color\n    output_grid = np.full_like(source_region, fill_value=background_fill)\n\n    # 7. Transform Source: Overwrite pixels matching the target color\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the original pixel in the source was the target color\n            if source_region[r, c] == target_color:\n                # If it was, replace the corresponding pixel in the output grid\n                # using the tiled replacement pattern\n                output_grid[r, c] = replacement_pattern[r % 3, c % 3]\n\n    # Convert the final NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21555,
    "candidates_token_count": 1574,
    "total_token_count": 23129,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.109897,
  "retries": 1
}