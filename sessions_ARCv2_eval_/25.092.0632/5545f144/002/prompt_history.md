
## train_1

**input:**
```
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 1 1 3 1 4 1 1 1 1 1 1
1 1 1 4 1 4 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 4 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 4 1 4 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 4 1 1 4 1 3 1 1 1 4 1 1 4 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 4 1 4
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1
1 4 1 1 1 1 1 1
4 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 3 0 0 3 0 2 0 3 0 0 3 0 2 0 0 0 3 3 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 3 3 3 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 3 3
0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 3 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
3 3 3 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 3 3 3
0 0 0 0 3 0
0 0 0 0 0 0
```


## train_3

**input:**
```
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 6 5 5 6 5 5 5 6 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 6 5 6 5 5 6 5 5 6 5 4 5 5 6 5 6 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 5 5 6 5 5 5 5 5 5 4 5 5 6 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 6 5 6 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
```

**Perception of Task Elements**

1.  **Input/Output Grids:** Each task consists of an input grid and a corresponding output grid.
2.  **Dimensions:** The height of the output grid is always the same as the height of the input grid. The width of the output grid is less than or equal to the width of the input grid.
3.  **Colors:** The grids use a palette of colors (0-9). Each example features a dominant background color (blue in #1, white in #2, gray in #5) and other foreground colors.
4.  **Vertical Lines:** A key feature in the input grids is the presence of one or more solid vertical lines. These lines span the full height of the grid and consist of a single color distinct from the background color. In example #1, the lines are green (3); in #2, they are red (2); in #3, there's one yellow (4) line.
5.  **Transformation:** The transformation appears to be a cropping operation based on the location of the *first* (leftmost) vertical line marker. The output grid consists of all columns from the input grid *before* this marker line. The marker line itself is excluded.
6.  **Marker Line Definition:** A column acts as a marker if all its cells have the same color, and this color is different from the color of the cell at the top-left corner `(0, 0)` of the input grid (which seems to represent the background in these examples).

**YAML Facts**


```yaml
task_description: Crop the input grid horizontally based on the position of the first vertical line marker.

definitions:
  - name: vertical_line_marker
    description: A column in the grid where all cells have the same color, and this color is different from the color of the cell at position (0, 0) in the input grid.

input_grid:
  properties:
    - height: H
    - width: W
    - contains_pixels: Yes
    - contains_vertical_line_markers: Yes, at least one in examples.

output_grid:
  properties:
    - height: H (same as input)
    - width: W_out (where W_out is the column index of the first vertical_line_marker)
    - content: A subgrid of the input grid.

transformation:
  action: Identify the first vertical_line_marker
  details:
    - Iterate through columns from left (index 0) to right.
    - The first column that meets the criteria for vertical_line_marker determines the crop point.
    - Let the index of this first marker column be `C_marker`.
  action: Crop the input grid
  details:
    - Select all rows (0 to H-1).
    - Select columns from index 0 up to (but not including) `C_marker`.
    - The resulting subgrid is the output.

relationship:
  - The output grid is the portion of the input grid to the left of the first identified vertical_line_marker.
  - The height remains unchanged.
```


**Natural Language Program**

1.  Accept the input grid.
2.  Determine the height (H) and width (W) of the input grid.
3.  Identify the color of the top-left pixel (at row 0, column 0), call it `background_color_ref`.
4.  Initialize a variable `marker_column_index` to -1 (or some indicator that no marker has been found yet).
5.  Iterate through each column index `c` from 0 to W-1:
    a.  Check if the column `c` is a vertical line marker:
        i.  Get the color of the first pixel in the column, `column_color = grid[0][c]`.
        ii. If `column_color` is the same as `background_color_ref`, this column cannot be a marker; continue to the next column `c+1`.
        iii. Assume the column is a marker (`is_marker = True`).
        iv. Iterate through each row index `r` from 1 to H-1:
            1.  If the color `grid[r][c]` is different from `column_color`, set `is_marker = False` and break this inner loop (checking rows).
        v.  If `is_marker` is still `True` after checking all rows, then column `c` is the first vertical line marker found. Set `marker_column_index = c` and break the outer loop (checking columns).
6.  If no marker column was found (`marker_column_index` is still -1), handle this case (e.g., return the original grid or an empty grid, though examples suggest a marker always exists). Based on the examples, assume `marker_column_index` will be found and hold a value between 0 and W-1.
7.  Create the output grid by taking a slice of the input grid: select all rows (from 0 to H-1) and columns from 0 up to (but not including) `marker_column_index`.
8.  Return the created output grid.
```python
"""
This module defines a function to transform an input grid based on identifying the first vertical line marker.
The transformation crops the input grid horizontally, keeping all columns to the left of the first vertical line marker.
A vertical line marker is defined as a column where all cells have the same color, and this color is different 
from the color of the top-left cell (0, 0) of the input grid.
"""

import numpy as np

def is_vertical_line_marker(column_data, background_color_ref):
    """
    Checks if a given column data represents a vertical line marker.

    Args:
        column_data (np.array): 1D array representing the column pixels.
        background_color_ref (int): The color of the top-left pixel of the original grid.

    Returns:
        bool: True if the column is a vertical line marker, False otherwise.
    """
    # A column must have at least one pixel.
    if column_data.size == 0:
        return False
        
    # Get the color of the first pixel in the column.
    marker_color = column_data[0]
    
    # The marker color must be different from the reference background color.
    if marker_color == background_color_ref:
        return False
        
    # Check if all pixels in the column have the same marker_color.
    # np.all efficiently checks if all elements are True (column_data == marker_color).
    return np.all(column_data == marker_color)

def transform(input_grid):
    """
    Transforms the input grid by cropping it horizontally based on the first vertical line marker.

    Args:
        input_grid (list of lists or np.array): The input grid.

    Returns:
        np.array: The transformed (cropped) grid. Returns the original grid if no marker is found.
    """
    # Convert input to numpy array for easier slicing and manipulation
    input_np = np.array(input_grid, dtype=int)
    
    # Get grid dimensions
    height, width = input_np.shape
    
    # Handle edge case of empty or 1-pixel wide grid
    if width == 0:
        return np.array([[]] * height) # Return empty grid with correct height
    if width == 1:
         # If the single column is a marker, return empty grid. Otherwise, return the column.
         background_color_ref = input_np[0, 0]
         if is_vertical_line_marker(input_np[:, 0], background_color_ref):
             return np.array([[]] * height)
         else:
             return input_np # Or maybe empty? Examples suggest marker is always found before end.
                             # Let's stick to the primary logic for now. The loop below handles width=1 correctly.

    # Identify the background color reference from the top-left pixel
    background_color_ref = input_np[0, 0]
    
    # Initialize marker column index
    marker_column_index = -1
    
    # Iterate through columns to find the first vertical line marker
    for c in range(width):
        # Extract the current column
        column_data = input_np[:, c]
        
        # Check if this column is a vertical line marker
        if is_vertical_line_marker(column_data, background_color_ref):
            # Found the first marker column
            marker_column_index = c
            # Stop searching
            break
            
    # If a marker column was found
    if marker_column_index != -1:
        # Create the output grid by slicing the input grid
        # Select all rows (:) and columns from 0 up to (but not including) marker_column_index
        output_grid = input_np[:, 0:marker_column_index]
    else:
        # If no marker column was found (this shouldn't happen based on examples,
        # but as a fallback, return the original grid or handle as needed)
        # Returning the original grid seems safest if the pattern assumption fails.
        output_grid = input_np 
        # Alternatively, could return an empty grid: output_grid = np.array([[]]*height)
        
    return output_grid.tolist() # Return as list of lists as per ARC standard output format
```
