{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies the background color, which is the most frequent color in the grid.\nFinds all non-background objects.\nIdentifies specific objects: a Red (2) bar (5 pixels) and a Green (3) bar (5 pixels).\nIdentifies all plus-sign shaped objects (13 pixels, 5x5 bounding box minus corners).\nDetermines the relative horizontal position of the Red and Green bars.\nBased on this relative position, determines a target plus-sign color:\n- If the Red bar is to the left of the Green bar, the target color is Maroon (9).\n- If the Red bar is to the right of the Green bar:\n    - If any Magenta (6) plus-signs exist, Magenta is the target color.\n    - Otherwise, Green (3) is the target color.\nModifies the grid:\n- Removes the Red and Green bars by changing their pixels to the background color.\n- If the target color is Maroon (9) or Magenta (6), changes all pixels of all plus-signs of that color to Gray (5).\n- If the target color is Green (3), finds the *topmost* Green plus-sign and changes its pixels to Gray (5).\nReturns the modified grid.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all connected components (objects) of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int) and 'pixels' (set of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n    return objects\n\ndef get_object_bounds(obj_pixels):\n    \"\"\"Calculates the bounding box and size of an object.\"\"\"\n    if not obj_pixels:\n        return None, None, None, None, 0\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    size = len(obj_pixels)\n    return min_r, min_c, height, width, size\n\ndef is_plus_sign(obj_pixels):\n    \"\"\"Checks if an object represented by pixels forms a plus sign shape.\"\"\"\n    min_r, min_c, height, width, size = get_object_bounds(obj_pixels)\n    if size != 13 or height != 5 or width != 5:\n        return False\n    \n    # Expected shape: a 5x5 bounding box minus the 4 corners (4*3=12 pixels removed)\n    # Center is at (min_r + 2, min_c + 2)\n    center_r, center_c = min_r + 2, min_c + 2\n    \n    # Check if center pixel exists\n    if (center_r, center_c) not in obj_pixels:\n        return False\n        \n    # Check if the cross shape exists and corners are empty\n    expected_pixels = set()\n    # Horizontal bar\n    for dc in range(-2, 3):\n        expected_pixels.add((center_r, center_c + dc))\n    # Vertical bar\n    for dr in range(-2, 3):\n        expected_pixels.add((center_r + dr, center_c))\n        \n    # The union of horizontal and vertical bars should match the object pixels exactly\n    # The size check already confirmed 13 pixels.\n    return obj_pixels == expected_pixels\n\n\ndef is_bar(obj_pixels):\n    \"\"\"Checks if an object represented by pixels forms a 1x5 or 5x1 bar.\"\"\"\n    min_r, min_c, height, width, size = get_object_bounds(obj_pixels)\n    if size != 5:\n        return False\n    if (height == 5 and width == 1) or (height == 1 and width == 5):\n        return True\n    return False\n\ndef get_topmost_object(objects):\n    \"\"\"Finds the object with the minimum top row index.\"\"\"\n    if not objects:\n        return None\n        \n    topmost_obj = None\n    min_top_row = float('inf')\n\n    for obj in objects:\n        min_r, _, _, _, _ = get_object_bounds(obj['pixels'])\n        if min_r < min_top_row:\n            min_top_row = min_r\n            topmost_obj = obj\n        # Tie-breaking: if rows are equal, prefer leftmost? Not specified, using first found.\n            \n    return topmost_obj\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules derived from examples.\n    - Finds red/green bars, determines relative position.\n    - Identifies target plus-sign color based on bar position.\n    - Removes bars and modifies target plus-signs (all if Maroon/Magenta, topmost if Green) to Gray.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Find background color\n    all_pixels = grid.flatten()\n    background_color = Counter(all_pixels).most_common(1)[0][0]\n\n    # 2. Find all objects\n    objects = find_objects(grid, background_color)\n\n    # 3. Identify bars and plus-signs\n    red_bar = None\n    green_bar = None\n    plus_signs = []\n    magenta_plus_exists = False\n    green_plus_signs = []\n\n    for obj in objects:\n        pixels = obj['pixels']\n        color = obj['color']\n        \n        if is_bar(pixels):\n            if color == 2: # Red\n                red_bar = obj\n            elif color == 3: # Green\n                green_bar = obj\n        elif is_plus_sign(pixels):\n            plus_signs.append(obj)\n            if color == 6: # Magenta\n                magenta_plus_exists = True\n            if color == 3: # Green\n                green_plus_signs.append(obj)\n\n    # Ensure bars were found\n    if red_bar is None or green_bar is None:\n        # Fallback or error - assume no change if control bars missing\n        print(\"Warning: Red or Green bar not found.\")\n        return output_grid.tolist() \n\n    # 4. Determine relative bar position (using min column index)\n    _, red_min_c, _, _, _ = get_object_bounds(red_bar['pixels'])\n    _, green_min_c, _, _, _ = get_object_bounds(green_bar['pixels'])\n\n    target_color = None\n    target_specific_object = None # Used only if target is Green(3)\n\n    if red_min_c < green_min_c:\n        # Red is left of Green\n        target_color = 9 # Maroon\n    else:\n        # Red is right of Green (or same column, though examples suggest distinct columns)\n        if magenta_plus_exists:\n            target_color = 6 # Magenta\n        elif green_plus_signs:\n             target_color = 3 # Green\n             target_specific_object = get_topmost_object(green_plus_signs) # Find the topmost green plus\n\n    # 5. Apply Transformations\n    \n    # 5a. Remove Red and Green bars\n    for r, c in red_bar['pixels']:\n        output_grid[r, c] = background_color\n    for r, c in green_bar['pixels']:\n        output_grid[r, c] = background_color\n\n    # 5b. Modify target plus-signs\n    if target_color is not None:\n        if target_color == 3: # Green - only modify the topmost one\n             if target_specific_object:\n                 for r, c in target_specific_object['pixels']:\n                     output_grid[r, c] = 5 # Gray\n        else: # Maroon or Magenta - modify all plus signs of that color\n            for ps in plus_signs:\n                if ps['color'] == target_color:\n                    for r, c in ps['pixels']:\n                        output_grid[r, c] = 5 # Gray\n\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12239,
    "candidates_token_count": 2279,
    "total_token_count": 14518,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.033411,
  "retries": 1
}