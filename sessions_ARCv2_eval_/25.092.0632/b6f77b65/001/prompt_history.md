
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

*   **Perception:**
    *   The input and output grids are typically 12x12.
    *   The background color is white (0).
    *   Each input grid features a single non-white pixel in the top-left corner (0, 0). This pixel's color varies across examples (maroon, yellow, magenta, orange).
    *   Besides the top-left pixel, the input grids contain various colored shapes or patterns composed of non-white pixels.
    *   In the output grid, the top-left pixel remains unchanged from the input.
    *   All other non-white pixels and the patterns they form appear to be shifted vertically downwards relative to their position in the input grid.
    *   The amount of the downward shift seems correlated with the color of the top-left pixel.
    *   By comparing input and output pairs:
        *   `train_1`: Top-left is maroon (9). No shift occurs (shift = 0).
        *   `train_2`: Top-left is yellow (4). Shapes shift down by 3 rows.
        *   `train_3`: Top-left is magenta (6). Shapes shift down by 2 rows.
        *   `train_4`: Top-left is yellow (4). Shapes shift down by 3 rows.
        *   `train_5`: Top-left is orange (7). Shapes shift down by 5 rows.
    *   Pixels shifted off the bottom edge of the grid are removed. The original positions of the shifted pixels become white (background).

*   **Facts:**
    
```yaml
    task_type: transformation
    grid_properties:
      size: 12x12 (typically)
      background_color: 0 (white)
    objects:
      - type: anchor_pixel
        location: (0, 0)
        properties:
          color: varies (maroon, yellow, magenta, orange observed)
          role: determines the vertical shift amount
      - type: colored_patterns
        location: various, excluding (0, 0)
        properties:
          color: non-white (values > 0)
          composition: contiguous or non-contiguous groups of pixels
    actions:
      - action: determine_shift
        input: color of the anchor_pixel at (0, 0)
        output: vertical_shift_amount (integer)
        rule: Based on observed mapping {maroon(9): 0, yellow(4): 3, magenta(6): 2, orange(7): 5}
      - action: shift_pixels
        target: all non-white pixels excluding the anchor_pixel at (0, 0)
        direction: downwards
        amount: vertical_shift_amount derived from the anchor_pixel
        constraints: Pixels shifted beyond the grid boundary are discarded.
    output_grid:
      - composition:
          - anchor_pixel copied directly from input (0, 0) to output (0, 0).
          - shifted non-white pixels placed at new locations (original_row + shift, original_col).
          - all other locations are set to the background color (white, 0).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, but with all pixels set to the background color (white, 0), preserving the original dimensions.
    2.  Identify the color of the pixel at the top-left corner (row 0, column 0) of the input grid. Call this the `anchor_color`.
    3.  Determine the vertical shift amount (`shift`) based on the `anchor_color` using the following mapping:
        *   If `anchor_color` is maroon (9), `shift` is 0.
        *   If `anchor_color` is yellow (4), `shift` is 3.
        *   If `anchor_color` is magenta (6), `shift` is 2.
        *   If `anchor_color` is orange (7), `shift` is 5.
        *   (Assume `shift` is 0 for any other anchor color not observed in the examples).
    4.  Copy the `anchor_color` pixel from the input grid's position (0, 0) to the output grid's position (0, 0).
    5.  Iterate through each pixel in the input grid, starting from row 0, column 1 (skipping the anchor pixel if it's at (0,0)) or more generally, iterate through all pixels *not* at (0,0).
    6.  For each input pixel at `(row, col)` that is not the anchor pixel (i.e., `(row, col) != (0, 0)`) and is not the background color (white, 0):
        a.  Calculate the target row index in the output grid: `new_row = row + shift`.
        b.  The target column index remains the same: `new_col = col`.
        c.  Check if the target position `(new_row, new_col)` is within the bounds of the output grid.
        d.  If it is within bounds, set the pixel at `(new_row, new_col)` in the output grid to the color of the input pixel at `(row, col)`.
