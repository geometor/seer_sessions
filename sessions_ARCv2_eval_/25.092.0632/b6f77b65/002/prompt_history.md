
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

*   **Perception:**
    *   The input and output grids are typically 12x12.
    *   The background color is white (0).
    *   Each input grid features a single non-white pixel in the top-left corner (0, 0). This pixel's color varies across examples (maroon, yellow, magenta, orange).
    *   Besides the top-left pixel, the input grids contain various colored shapes or patterns composed of non-white pixels.
    *   In the output grid, the top-left pixel remains unchanged from the input.
    *   All other non-white pixels and the patterns they form appear to be shifted vertically downwards relative to their position in the input grid.
    *   The amount of the downward shift seems correlated with the color of the top-left pixel.
    *   By comparing input and output pairs:
        *   `train_1`: Top-left is maroon (9). No shift occurs (shift = 0).
        *   `train_2`: Top-left is yellow (4). Shapes shift down by 3 rows.
        *   `train_3`: Top-left is magenta (6). Shapes shift down by 2 rows.
        *   `train_4`: Top-left is yellow (4). Shapes shift down by 3 rows.
        *   `train_5`: Top-left is orange (7). Shapes shift down by 5 rows.
    *   Pixels shifted off the bottom edge of the grid are removed. The original positions of the shifted pixels become white (background).

*   **Facts:**
    
```yaml
    task_type: transformation
    grid_properties:
      size: 12x12 (typically)
      background_color: 0 (white)
    objects:
      - type: anchor_pixel
        location: (0, 0)
        properties:
          color: varies (maroon, yellow, magenta, orange observed)
          role: determines the vertical shift amount
      - type: colored_patterns
        location: various, excluding (0, 0)
        properties:
          color: non-white (values > 0)
          composition: contiguous or non-contiguous groups of pixels
    actions:
      - action: determine_shift
        input: color of the anchor_pixel at (0, 0)
        output: vertical_shift_amount (integer)
        rule: Based on observed mapping {maroon(9): 0, yellow(4): 3, magenta(6): 2, orange(7): 5}
      - action: shift_pixels
        target: all non-white pixels excluding the anchor_pixel at (0, 0)
        direction: downwards
        amount: vertical_shift_amount derived from the anchor_pixel
        constraints: Pixels shifted beyond the grid boundary are discarded.
    output_grid:
      - composition:
          - anchor_pixel copied directly from input (0, 0) to output (0, 0).
          - shifted non-white pixels placed at new locations (original_row + shift, original_col).
          - all other locations are set to the background color (white, 0).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, but with all pixels set to the background color (white, 0), preserving the original dimensions.
    2.  Identify the color of the pixel at the top-left corner (row 0, column 0) of the input grid. Call this the `anchor_color`.
    3.  Determine the vertical shift amount (`shift`) based on the `anchor_color` using the following mapping:
        *   If `anchor_color` is maroon (9), `shift` is 0.
        *   If `anchor_color` is yellow (4), `shift` is 3.
        *   If `anchor_color` is magenta (6), `shift` is 2.
        *   If `anchor_color` is orange (7), `shift` is 5.
        *   (Assume `shift` is 0 for any other anchor color not observed in the examples).
    4.  Copy the `anchor_color` pixel from the input grid's position (0, 0) to the output grid's position (0, 0).
    5.  Iterate through each pixel in the input grid, starting from row 0, column 1 (skipping the anchor pixel if it's at (0,0)) or more generally, iterate through all pixels *not* at (0,0).
    6.  For each input pixel at `(row, col)` that is not the anchor pixel (i.e., `(row, col) != (0, 0)`) and is not the background color (white, 0):
        a.  Calculate the target row index in the output grid: `new_row = row + shift`.
        b.  The target column index remains the same: `new_col = col`.
        c.  Check if the target position `(new_row, new_col)` is within the bounds of the output grid.
        d.  If it is within bounds, set the pixel at `(new_row, new_col)` in the output grid to the color of the input pixel at `(row, col)`.
```python
import numpy as np

"""
Transformation Rule:
1. Identify the color of the pixel at the top-left corner (0, 0) - the anchor color.
2. Determine a vertical shift amount based on the anchor color using a predefined mapping:
   - Maroon (9) -> shift 0
   - Yellow (4) -> shift 3
   - Magenta (6) -> shift 2
   - Orange (7) -> shift 5
   - Default: shift 0 for any other color.
3. Initialize an output grid of the same dimensions as the input, filled with the background color (white, 0).
4. Copy the anchor pixel from input (0, 0) to output (0, 0).
5. Iterate through all pixels in the input grid, excluding the anchor pixel at (0, 0).
6. For each non-background pixel found at (row, col):
   a. Calculate its new row position: new_row = row + shift.
   b. If the new_row is within the grid's height boundaries:
      i. Copy the pixel's color to the output grid at (new_row, col).
7. Return the resulting output grid.
"""

def transform(input_grid):
    """
    Applies a vertical shift to non-anchor, non-background pixels based on the
    color of the anchor pixel at (0, 0).

    Args:
        input_grid (list of lists): The input grid represented as a 2D list.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape

    # Initialize the output grid with the background color (0)
    output_array = np.zeros_like(input_array)

    # 1. Identify the anchor color
    anchor_color = input_array[0, 0]

    # 2. Determine the vertical shift amount based on the anchor color
    shift_map = {
        9: 0,  # Maroon
        4: 3,  # Yellow
        6: 2,  # Magenta
        7: 5   # Orange
    }
    shift = shift_map.get(anchor_color, 0) # Default shift is 0

    # 3. Copy the anchor pixel to the output grid
    output_array[0, 0] = anchor_color

    # 4. Iterate through all pixels in the input grid, excluding the anchor
    for r in range(height):
        for c in range(width):
            # Skip the anchor pixel itself
            if r == 0 and c == 0:
                continue

            # Get the color of the current pixel
            pixel_color = input_array[r, c]

            # 5. Process non-background pixels
            if pixel_color != 0:
                # a. Calculate the new row position
                new_r = r + shift

                # b. Check if the new row is within grid bounds
                if 0 <= new_r < height:
                    # c. Copy the pixel to the new location in the output grid
                    # Check if the target pixel is currently background (0).
                    # This handles potential overlaps where later pixels might overwrite earlier ones
                    # if they shift to the same spot. Based on examples, direct overwrite seems intended.
                    output_array[new_r, c] = pixel_color

    # Convert the NumPy array back to a list of lists for the standard ARC format
    return output_array.tolist()
```
