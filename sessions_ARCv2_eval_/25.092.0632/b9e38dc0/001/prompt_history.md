
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

**Perception of Elements:**

1.  **Grid Structure:** The task operates on 2D grids of colored pixels.
2.  **Colors:** Multiple colors are used in each example, with one color typically acting as a background.
3.  **Objects/Shapes:** In the input grids, distinct shapes or clusters of pixels exist, formed by non-background colors. Some inputs feature single pixels of a specific color.
4.  **Transformation:** The core transformation appears to be a "flood fill" or "coloring" operation originating from specific pixels.
5.  **Fill Propagation:** The fill color spreads outwards from its initial locations into the background color pixels.
6.  **Boundaries:** The fill operation is constrained by pixels of colors other than the background and fill colors, as well as the grid boundaries. These non-background, non-fill pixels act as barriers.
7.  **Color Roles:**
    *   **Background Color:** The dominant color in the input grid that gets partially replaced.
    *   **Fill Color:** The color that expands or spreads into the background area. This color is present in the input, sometimes as small features or single pixels.
    *   **Barrier Colors:** All other colors present in the input grid remain unchanged and block the spread of the fill color.

**YAML Facts:**


```yaml
task_description: Identify a background color, a fill color, and barrier colors in the input grid. Perform a flood fill starting from the initial fill color pixels, replacing adjacent background color pixels with the fill color, stopping at barrier colors and grid edges.

definitions:
  - name: background_color
    description: The most frequent color in the input grid. This color is subject to being replaced by the fill color.
  - name: fill_color
    description: The color that initiates the fill operation and expands into the background. Identified by observing which color increases its area significantly in the output compared to the input, replacing the background color.
  - name: barrier_colors
    description: Any color present in the input grid that is neither the background color nor the fill color. These colors remain unchanged and block the fill propagation.
  - name: fill_seeds
    description: All pixels in the input grid that have the fill_color.
  - name: fill_operation
    description: A process starting from fill_seeds that iteratively changes adjacent (non-diagonal) background_color pixels to the fill_color.
  - name: stopping_conditions
    description: The fill_operation stops propagating into a pixel if that pixel is a barrier_color, already the fill_color, or outside the grid boundaries.

examples:
  - train_1:
      background_color: blue (1)
      fill_color: maroon (9)
      barrier_colors: [green (3), gray (5)]
      action: Flood fill starts from the single maroon pixel, replacing adjacent blue pixels with maroon until green, gray, or grid boundaries are met.
  - train_2:
      background_color: white (0)
      fill_color: yellow (4)
      barrier_colors: [gray (5)]
      action: Flood fill starts from the single yellow pixel, replacing adjacent white pixels with yellow until gray or grid boundaries are met.
  - train_3:
      background_color: orange (7)
      fill_color: green (3)
      barrier_colors: [magenta (6), maroon (9), azure (8)]
      action: Flood fill starts from all initial green pixels, replacing adjacent orange pixels with green until magenta, maroon, azure, or grid boundaries are met.

```


**Natural Language Program:**

1.  Analyze the input grid to determine the frequency of each color.
2.  Identify the `background_color` as the color with the highest frequency.
3.  Identify the `fill_color` by comparing the input and output grids; it's the color that expands into the `background_color` areas. (Alternatively, assume the fill color is the one that is present in the input but not the background and not the most numerous of the remaining colors, often appearing as small features).
4.  Identify `barrier_colors` as all colors present in the input grid that are neither the `background_color` nor the `fill_color`.
5.  Create a copy of the input grid to serve as the output grid.
6.  Initialize a queue or list for processing, adding the coordinates of all pixels in the input grid that have the `fill_color` (these are the `fill_seeds`). Maintain a set of visited coordinates to avoid redundant processing. Add the initial `fill_seeds` coordinates to the visited set.
7.  While the processing queue is not empty:
    a.  Dequeue a coordinate (row, col).
    b.  For each of its four adjacent neighbors (up, down, left, right):
        i.  Check if the neighbor is within the grid boundaries.
        ii. Check if the neighbor has not been visited yet.
        iii. Check if the neighbor's color in the *original input grid* is the `background_color`.
        iv. If all conditions (i, ii, iii) are met:
            1.  Change the color of the neighbor pixel in the *output grid* to the `fill_color`.
            2.  Add the neighbor's coordinates to the visited set.
            3.  Enqueue the neighbor's coordinates for further processing.
8.  Return the modified output grid.
