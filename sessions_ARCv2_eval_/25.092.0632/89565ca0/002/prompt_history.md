
## train_1

**input:**
```
0 0 0 0 0 0 0 5 0 5 0 0 0 0 5 0 0 0 0 0 0 0 0 0 5 0 0 0
0 0 0 0 0 0 5 0 0 0 0 5 5 0 0 5 0 0 0 5 0 0 0 0 0 0 0 0
5 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 3 3 5 5 0
0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 5 0 0 0
0 0 3 0 1 1 1 1 1 1 0 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 3 5 1 0 0 5 0 1 0 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 5 0 1 0 0 0 5 1 0 0 0 3 0 0 0 0 5 0 0 0 0 0 3 0 0 0
0 0 5 0 1 0 0 0 0 1 0 0 0 3 0 0 0 0 0 0 0 0 0 5 3 0 0 0
0 0 3 0 5 0 0 0 0 1 0 0 0 3 0 0 5 0 0 0 0 0 0 0 3 0 0 0
0 0 3 0 1 1 1 1 1 1 0 0 0 3 0 5 0 5 0 0 0 0 0 0 3 0 0 0
0 5 3 5 0 0 0 0 0 0 5 0 5 3 0 0 0 0 5 0 0 0 0 0 3 0 0 0
0 0 3 5 0 0 0 0 5 0 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2 2 0
0 0 3 0 0 0 0 0 5 0 2 0 0 3 0 2 0 0 0 0 2 0 0 0 5 0 2 0
5 0 3 0 0 0 0 0 0 0 2 0 0 5 0 2 5 0 0 0 2 0 0 0 3 0 2 0
0 0 3 3 3 3 3 3 3 5 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 0 2 0
0 0 0 0 0 0 5 0 0 0 5 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 2 0
0 5 5 0 0 0 0 0 0 0 2 2 2 2 2 5 0 0 0 0 2 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 2 5
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 5 0 0 0 0 2 5 0 0 0 0 2 5
0 0 0 0 0 0 0 0 0 0 5 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 5 5 5
3 3 5 5
2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 0 0 0 0 4 4 4 4 5 4 5 4 4 4 4 4 4 4 4 0
0 1 0 0 0 0 0 1 0 0 0 0 4 0 0 0 0 4 0 0 0 0 4 0 5 0 4 0
0 1 0 5 2 2 2 2 2 2 2 2 4 2 2 2 0 4 0 5 0 0 4 0 5 5 4 0
0 1 0 0 2 0 0 1 0 0 2 0 4 0 0 2 0 4 0 0 0 0 4 0 0 5 5 0
0 1 1 1 2 1 1 1 0 0 2 5 4 0 0 2 0 4 0 5 5 0 4 0 0 0 4 0
0 1 0 0 2 0 0 1 0 0 2 0 4 0 0 2 0 4 0 0 0 5 4 0 0 0 4 5
0 1 0 0 5 0 0 1 0 0 2 0 4 0 0 2 0 4 0 0 0 0 4 0 0 0 4 0
0 5 0 0 2 0 0 1 0 0 2 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0
0 1 0 0 2 0 0 1 0 0 2 0 0 0 0 2 0 0 5 0 0 0 0 0 0 0 0 0
0 1 1 1 2 1 1 1 0 0 2 2 2 2 2 5 0 8 5 8 8 8 8 8 8 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 2 0 8 0 0 0 5 0 0 8 0 0 5
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 2 0 8 0 0 5 0 0 0 8 0 0 0
0 5 0 0 2 0 0 0 0 0 2 0 0 0 0 5 0 8 0 5 5 5 0 0 8 0 0 0
0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 5 8 0 0 5 0 0 0 5 0 5 5
0 0 0 0 0 0 0 0 5 0 0 0 5 0 0 0 0 8 0 0 5 0 0 0 8 0 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 8 0 0 0 0 0 0 8 0 0 0
0 3 0 3 0 0 0 3 0 0 0 3 0 0 3 0 0 8 8 8 8 8 8 8 8 0 0 0
0 3 0 3 0 0 0 3 5 0 5 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 0 0 3 0 0 0 3 0 0 3 0 0 0 5 0 0 0 5 0 0 0 0 0
0 3 3 3 3 3 3 3 5 3 3 5 3 3 3 0 0 0 5 5 0 0 0 0 5 5 0 0
0 0 0 0 5 5 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 5 5 5
1 1 5 5
2 2 2 5
4 4 4 4
3 3 3 3
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 7 0 7 0 0 0 0 7 0 0 0 0
0 1 1 1 1 1 1 1 1 1 0 0 0 0 8 8 8 8 0 0
0 1 0 0 1 0 0 0 0 7 7 0 0 0 8 0 0 8 0 0
0 1 0 0 7 7 0 0 0 1 0 0 0 0 8 0 0 8 0 0
0 1 0 0 1 0 0 0 0 1 0 0 0 0 8 8 8 8 0 0
0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 1 0 0 1 7 2 2 2 2 2 2 2 2 2 2 0 0 0 0
0 1 0 0 7 2 0 0 0 1 0 2 0 0 0 7 0 0 0 0
0 1 1 1 1 2 1 1 1 1 0 2 0 0 0 2 0 0 0 7
0 0 0 0 0 2 0 0 0 0 0 2 0 7 0 2 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 2 0 7 0 0
0 7 0 0 0 2 0 0 0 0 0 7 0 0 0 2 0 0 0 0
0 0 0 0 0 2 0 0 0 7 0 2 0 0 0 2 0 0 0 0
0 7 0 0 0 7 2 2 2 2 2 7 2 2 2 2 0 0 0 0
0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 4 0 2 0 0 0 4 0 0 4 0 0 2 4 0 0 4
0 0 0 4 0 2 0 0 0 4 0 0 4 0 0 2 4 0 0 4
0 0 0 4 0 2 2 2 7 4 2 7 4 2 7 2 4 0 0 4
7 0 0 4 0 0 0 0 0 4 0 0 4 0 0 0 4 0 0 4
0 0 0 7 0 0 0 0 0 4 0 0 4 0 0 0 4 7 0 4
0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
8 7 7 7
1 1 7 7
2 2 2 7
4 4 4 4
```

**Perception:**

1.  **Input Structure:** The input grids contain multiple distinct regions or "objects," often resembling characters or symbols, embedded within a background (white=0) and interspersed with "noise" pixels (gray=5 or orange=7).
2.  **Character Objects:** The primary objects appear to be contiguous shapes made of a single primary color (blue=1, red=2, green=3, yellow=4, azure=8). These shapes might contain some noise pixels within their boundaries.
3.  **Noise:** A specific color acts as "noise" in each example (gray=5 in train_1 and train_2, orange=7 in train_3). These noise pixels are scattered throughout the grid, sometimes within or near the character objects.
4.  **Output Structure:** The output is a small grid (Nx4). Each row represents one identified character object from the input.
5.  **Transformation:** The transformation involves:
    *   Identifying the character objects and their primary colors.
    *   Identifying the dominant noise color for the entire input grid.
    *   Determining the vertical order of the character objects in the input.
    *   Creating an output row for each character, consisting of its primary color followed by three cells filled with the identified noise color.
    *   Stacking these rows vertically in the output grid, maintaining the original top-to-bottom order of the characters.

**Facts:**


```yaml
task_description: Identify character-like objects, determine the dominant noise color, and represent each character by its color and the noise color in a fixed-width output grid, ordered vertically.

definitions:
  - name: background_color
    value: 0 (white)
  - name: potential_character_colors
    value: [1, 2, 3, 4, 8] # blue, red, green, yellow, azure
  - name: potential_noise_colors
    value: Any color except 0 and potential_character_colors (e.g., 5, 6, 7, 9)

steps:
  - step: 1. Identify Character Objects
    description: Find connected components of pixels whose color is in the potential_character_colors list. Filter out very small components if necessary (though examples suggest they are substantial).
    inputs:
      - input_grid
      - potential_character_colors
    outputs:
      - list_of_character_objects: [{color: int, pixels: list_of_coords}, ...]

  - step: 2. Identify Noise Color
    description: Count the frequency of all non-background colors in the input grid. Exclude the colors identified as primary colors of character objects found in Step 1. The most frequent remaining color is the noise color for this grid.
    inputs:
      - input_grid
      - list_of_character_objects (to get their primary colors)
    outputs:
      - noise_color: int

  - step: 3. Determine Character Order
    description: For each character object found in Step 1, find the minimum row index among its pixels. Sort the character objects based on this minimum row index (ascending).
    inputs:
      - list_of_character_objects
    outputs:
      - sorted_character_objects: [{color: int, pixels: list_of_coords, min_row: int}, ...]

  - step: 4. Construct Output Grid
    description: Create an output grid with height equal to the number of sorted character objects and width equal to 4. For each character object, create a row: the first cell is the character's primary color, and the next three cells are filled with the noise_color identified in Step 2. Place these rows in the output grid according to the sorted order from Step 3.
    inputs:
      - sorted_character_objects
      - noise_color
    outputs:
      - output_grid

example_1_trace:
  input_grid: train_1_input
  step_1_output: Characters found (color, approx location): (1, top-left), (3, mid-left), (2, mid-right/bottom).
  step_2_output: Non-bg colors: {1:19, 2:59, 3:67, 5:53}. Character colors: {1, 2, 3}. Remaining: {5:53}. noise_color = 5 (gray).
  step_3_output: Order by min row: (1, row 5), (3, row 3), (2, row 12). Sorted: 3, 1, 2. (Wait, output is 1, 3, 2. Let's recheck min rows).
    - Blue(1) min row: 5
    - Green(3) min row: 3
    - Red(2) min row: 12
    - Output order: Green(3), Blue(1), Red(2).
    - The *output* shows 1, 3, 2 first column. This contradicts sorting by min row. Let me re-examine the output order vs input positions.
    - Train_1 output: [1 5 5 5], [3 3 5 5], [2 2 2 2].
    - The GREEN shape (3) clearly starts at row 3. The BLUE shape (1) starts at row 5. The RED shape (2) starts at row 12.
    - The output order is 1, 3, 2, but the vertical positions are 3, 1, 2. This is inconsistent.
    - Let's re-read the output for Train 1:
      ```

      1 5 5 5
      3 3 5 5
      2 2 2 2
      
```
      Okay, the first column is [1, 3, 2]. This *does* match the top-down order of Blue(1) min_row=5, Green(3) min_row=3, Red(2) min_row=12? No, that's still wrong. Min row order is 3, 1, 2. Output order is 1, 3, 2.
      What else could define the order? Maybe the color value itself? Order 1, 2, 3? No, output is 1, 3, 2.
      Maybe something about the shape? Area?
      Let's check Train 2:
      Input min rows: Blue(1) r=1, Red(2) r=3, Green(3) r=16, Yellow(4) r=1, Azure(8) r=10.
      Sorted by min row: Blue(1), Yellow(4) tie at r=1. Then Red(2) r=3. Then Azure(8) r=10. Then Green(3) r=16.
      Tie break? Leftmost? Blue(1) col=1. Yellow(4) col=12. So Blue(1) then Yellow(4).
      Min row sorted order: Blue(1), Yellow(4), Red(2), Azure(8), Green(3). Colors: 1, 4, 2, 8, 3.
      Train 2 output: [8 5 5 5], [1 1 5 5], [2 2 2 5], [4 4 4 4], [3 3 3 3].
      First column order: 8, 1, 2, 4, 3. This does *not* match the min-row sort order (1, 4, 2, 8, 3).
      What is the order in the output? 8, 1, 2, 4, 3.
      Let's reconsider Train 1 output order: 1, 3, 2.
      Train 3 output order: 8, 1, 2, 4.

      Is there a fixed canonical order for the colors involved?
      Train 1 Colors: 1, 2, 3 -> Output order: 1, 3, 2
      Train 2 Colors: 1, 2, 3, 4, 8 -> Output order: 8, 1, 2, 4, 3
      Train 3 Colors: 1, 2, 4, 8 -> Output order: 8, 1, 2, 4

      There doesn't seem to be a simple sort based on color value or position.
      Let's rethink the core concept. Maybe it's not character *recognition*.

      Look at the noise color usage again.
      Train 1: Noise=5. Output cols 2-4 use 5. Except row 2 (Green) uses 3 (itself). Row 3 (Red) uses 2 (itself). Row 1 (Blue) uses 5 (noise).
      Output 1:
      ```

      1 5 5 5  # Blue object, noise fill
      3 3 5 5  # Green object, green fill?, noise fill
      2 2 2 2  # Red object, red fill
      
```
      This isn't consistent fill. What did I miss in the output?
      Ah, I misread the output grid for train 1!
      Correct output 1:
      ```

      1 5 5 5
      3 3 5 5
      2 2 2 2
      
```python
import numpy as np
from collections import Counter
import operator # Consider using if more complex sorting/filtering needed

def find_noise_color(grid: np.ndarray, character_colors: set) -> int:
    """
    Finds the most frequent color in the grid, excluding background (0)
    and the provided character colors.

    Args:
        grid: The input numpy array grid.
        character_colors: A set of integers representing the colors identified as characters.

    Returns:
        The integer color value identified as the noise color.
        Defaults to 5 (gray) if no suitable noise color is found.
        Ties in frequency are broken by choosing the lower color value.
    """
    counts = Counter(grid.flatten())

    noise_candidate_counts = {}
    for color, count in counts.items():
        # Include only colors that are not background and not character colors
        if color != 0 and color not in character_colors:
            noise_candidate_counts[color] = count

    if not noise_candidate_counts:
        # No non-background, non-character colors found. Default to gray.
        return 5

    # Find the maximum frequency among candidates
    max_count = 0
    if noise_candidate_counts:
       max_count = max(noise_candidate_counts.values())

    # Get all candidates that have the maximum frequency
    candidates_with_max_count = [
        color for color, count in noise_candidate_counts.items() if count == max_count
    ]

    # Tie-break by choosing the minimum color value among the top candidates
    if candidates_with_max_count:
        noise_color = min(candidates_with_max_count)
    else:
        # This case should theoretically not be reached if noise_candidate_counts was not empty,
        # but provides a fallback.
        noise_color = 5

    return noise_color


def transform(input_grid: list) -> list:
    """
    Identifies specific character colors present in the input grid, determines a 'noise' color,
    and constructs an output grid based on a fixed canonical order of character colors.

    The output grid has one row for each character color present in the input, ordered according
    to the canonical sequence [8, 1, 2, 4, 3]. Each output row is 4 cells wide.
    The first cell contains the character color.
    The remaining three cells are filled with a mix of the character color and the noise color.
    The number of cells filled with the character color (N) depends on the character's position (0-based index 'idx')
    in the output sequence for this specific grid:
    - If it's the last character in the sequence AND its index 'idx' is 2 or greater, N = 3.
    - Otherwise, N = min(idx, 3).
    The remaining (3 - N) cells are filled with the noise color.

    The noise color is the most frequent color in the input grid, excluding background (0)
    and the identified character colors. Ties are broken by choosing the lowest color value.

    Args:
        input_grid: A list of lists representing the input grid.

    Returns:
        A list of lists representing the transformed output grid.
    """

    input_grid_np = np.array(input_grid, dtype=int) # Work with numpy array

    # Define potential character colors and their canonical order
    # These are the colors that form the main shapes/objects to be represented.
    potential_character_colors = {1, 2, 3, 4, 8} # blue, red, green, yellow, azure
    # This specific order determines the row order in the output.
    canonical_order = [8, 1, 2, 4, 3] # azure, blue, red, yellow, green

    # 1. Identify which potential character colors are actually present in the input grid.
    present_colors = set(np.unique(input_grid_np))
    present_character_colors = potential_character_colors.intersection(present_colors)

    # If no character colors are found, return an empty grid (0 rows, 4 columns).
    # This follows the pattern of creating an Nx4 output.
    if not present_character_colors:
        return np.empty((0, 4), dtype=int).tolist() # Return as list of lists

    # 2. Determine the order of characters for the output grid by filtering the
    #    canonical order based on presence in the input.
    output_order = [color for color in canonical_order if color in present_character_colors]

    # If the filtering resulted in an empty list (should be caught by the check above, but defensive check)
    if not output_order:
         return np.empty((0, 4), dtype=int).tolist()

    # 3. Identify the noise color using the helper function.
    noise_color = find_noise_color(input_grid_np, present_character_colors)

    # 4. Construct the output rows according to the rules.
    output_rows = []
    num_output_rows = len(output_order)

    for idx, char_color in enumerate(output_order):
        # Calculate N - the number of times the character color repeats after the first cell.
        # Special rule for the last element if its index is high enough.
        is_last_element = (idx == num_output_rows - 1)

        if is_last_element and idx >= 2:
            n_repeats = 3 # Fill all remaining 3 cells with character color
        else:
            # Otherwise, the number of repeats is the index, capped at 3.
            n_repeats = min(idx, 3)

        # Build the row: [CharColor, CharColor * N, NoiseColor * (3-N)]
        row = [char_color] # Start with the character color
        row.extend([char_color] * n_repeats) # Add N repeats of the character color
        row.extend([noise_color] * (3 - n_repeats)) # Fill the rest with noise color

        output_rows.append(row)

    # 5. Convert the list of rows into the final output format (list of lists).
    #    Numpy array was used internally for convenience.
    output_grid = np.array(output_rows, dtype=int)

    return output_grid.tolist()
```
