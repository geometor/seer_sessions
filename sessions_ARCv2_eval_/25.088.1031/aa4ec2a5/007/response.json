{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# Define colors\nBLUE = 1\nRED = 2\nGREEN = 3\nYELLOW = 4\nGRAY = 5\nMAGENTA = 6\nORANGE = 7\nAZURE = 8\nMAROON = 9\nWHITE = 0\n\n\ndef _get_neighbors(r, c, height, width, include_diagonal=True):\n    \"\"\" Gets valid neighbor coordinates for a given cell. \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            # Check for diagonal exclusion if specified\n            if not include_diagonal and abs(dr) + abs(dc) > 1:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_connected_yellow(start_nodes, yellow_coords, height, width):\n    \"\"\" Find all yellow coordinates connected to the start_nodes using BFS. \"\"\"\n    q = deque(list(start_nodes))\n    visited = set(start_nodes)\n    connected_region = set(start_nodes) # Include the starting frame pixels\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors\n        for nr, nc in _get_neighbors(r, c, height, width, include_diagonal=True):\n            coord = (nr, nc)\n            # Check if neighbor is yellow and not visited yet\n            if coord in yellow_coords and coord not in visited:\n                visited.add(coord)\n                connected_region.add(coord)\n                q.append(coord)\n\n    return connected_region\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on layered adjacency rules starting from Blue pixels\n    and propagating through connected Yellow pixels.\n\n    1. Initialize the output grid as a copy of the input grid.\n    2. Identify coordinates of all Blue (1) and initial Yellow (4) pixels.\n    3. Identify 'Frame' Yellow pixels: Those Yellow pixels adjacent (orthogonally or diagonally) to any Blue pixel.\n    4. Change the color of 'Frame' pixels to Red (2) in the output grid.\n    5. Identify the 'Region of Interest' (ROI): All Yellow pixels belonging to the same connected component(s) as the 'Frame' pixels. This uses BFS starting from the Frame pixels and exploring only through other Yellow pixels.\n    6. Identify 'Outer Fill' pixels (Azure, 8): These are Yellow pixels within the ROI (but not Frame pixels) that are adjacent to at least one Red 'Frame' pixel.\n    7. Identify 'Inner Fill' pixels (Magenta, 6): These are the remaining Yellow pixels within the ROI that were not turned Red or Azure.\n    8. Update the output grid with Azure and Magenta colors.\n    9. Original Blue pixels remain Blue. Yellow pixels outside the ROI remain Yellow. Other original colors (if any) remain unchanged.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify coordinates of all blue and yellow pixels\n    blue_coords = set(map(tuple, np.argwhere(input_grid == BLUE)))\n    initial_yellow_coords = set(map(tuple, np.argwhere(input_grid == YELLOW)))\n\n    # Handle edge cases with no blue or no yellow pixels\n    if not blue_coords or not initial_yellow_coords:\n        return output_grid # No transformation possible\n\n    # 3. Find all yellow pixels adjacent to blue pixels ('frame_coords')\n    frame_coords = set()\n    for r_yellow, c_yellow in initial_yellow_coords:\n        is_adjacent_to_blue = False\n        # Check all 8 neighbors (including diagonals)\n        neighbors = _get_neighbors(r_yellow, c_yellow, height, width, include_diagonal=True)\n        for nr, nc in neighbors:\n            if (nr, nc) in blue_coords:\n                is_adjacent_to_blue = True\n                break\n        if is_adjacent_to_blue:\n            frame_coords.add((r_yellow, c_yellow))\n\n    # 4. Change 'frame' pixels to red in the output grid\n    for r, c in frame_coords:\n        output_grid[r, c] = RED\n\n    # If no frame was created (e.g., blue and yellow not adjacent), return\n    if not frame_coords:\n         return output_grid\n\n    # 5. Identify the 'Region of Interest' (ROI) using BFS\n    # Start BFS from the frame_coords, exploring only within initial_yellow_coords\n    yellow_roi = _find_connected_yellow(frame_coords, initial_yellow_coords, height, width)\n\n    # 6. Classify remaining yellow pixels *within the ROI*\n    outer_fill_coords = set()\n    # Consider only yellows in the ROI that are not already frames\n    potential_outer_fill = yellow_roi - frame_coords\n\n    for r_rem, c_rem in potential_outer_fill:\n        is_adjacent_to_red = False\n        neighbors = _get_neighbors(r_rem, c_rem, height, width, include_diagonal=True)\n        # Check adjacency against the *final* set of frame coordinates (now RED)\n        for nr, nc in neighbors:\n            if (nr, nc) in frame_coords: # Check if neighbor became red\n                is_adjacent_to_red = True\n                break\n        if is_adjacent_to_red:\n            outer_fill_coords.add((r_rem, c_rem))\n\n    # 7. Determine inner fill coordinates accurately - must be within ROI\n    # Inner fill are those in the ROI not part of frame or outer fill\n    inner_fill_coords = yellow_roi - frame_coords - outer_fill_coords\n\n    # 8. Update the output grid with azure and magenta colors\n    for r, c in outer_fill_coords:\n        output_grid[r, c] = AZURE\n    for r, c in inner_fill_coords:\n        output_grid[r, c] = MAGENTA\n\n    # 9. Original blue, other colors, and yellows outside the ROI remain unchanged\n    #    because we started with a copy and only modified specific yellow pixels within the ROI.\n    #    (Blue pixel modification logic is omitted for now due to uncertainty).\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25655,
    "candidates_token_count": 1539,
    "total_token_count": 27194,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.014498,
  "retries": null
}