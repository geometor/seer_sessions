{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the unique red (2) pixel in the grid. If none exists, return the input grid unchanged.\n2.  Identify the 'core object', which consists of the red pixel and all green (3) pixels connected to it (including diagonally, potentially through other green pixels).\n3.  Identify the 'border pixels': all pixels adjacent (including diagonally) to any green pixel of the core object, but which are not part of the core object themselves (i.e., not the red pixel or the connected green pixels).\n4.  Analyze the border pixels:\n    a.  If *all* border pixels are magenta (6):\n        i.  Check if any maroon (9) pixel in the entire grid is adjacent (including diagonally) to any of the magenta (6) border pixels.\n        ii. If such an adjacent maroon pixel exists, change *all* green (3) pixels within the core object to maroon (9).\n        iii. Otherwise (no adjacent maroon pixel), change only those green (3) pixels in the core object that are located above the red pixel, or in the same row but to the left of the red pixel, to maroon (9).\n    b.  If the border pixels are *not* all magenta (6) (e.g., contain orange (7) or other colors):\n        i.  Change only those green (3) pixels in the core object that are located above the red pixel, or in the same row but to the left of the red pixel, to maroon (9).\n5.  All other pixels (the red pixel, background pixels, original maroon pixels, magenta pixels not part of the border, etc.) remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width, include_diagonals=True):\n    \"\"\" Gets valid neighbor coordinates for a pixel (r, c). \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonals and (dr != 0 and dc != 0):\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_pixel(grid, target_color):\n    \"\"\" Finds the first occurrence of a pixel with the target_color. \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color:\n                return r, c\n    return None\n\ndef find_core_object(grid, start_r, start_c):\n    \"\"\" Finds the red pixel and all connected green pixels. \"\"\"\n    height, width = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    core_object_coords = set([(start_r, start_c)]) # Include the red pixel itself\n    green_coords = set()\n\n    # Search starts from the red pixel to find adjacent green ones\n    search_q = deque(get_neighbors(start_r, start_c, height, width, include_diagonals=True))\n    initial_green_visited = set([(start_r, start_c)]) # Prevent revisiting red\n\n    while search_q:\n        r, c = search_q.popleft()\n        if (r,c) in initial_green_visited:\n             continue\n        initial_green_visited.add((r,c))\n\n        if grid[r, c] == 3: # Found a green pixel connected to red\n            # Now perform BFS/DFS from this green pixel to find all connected greens\n            component_q = deque([(r,c)])\n            component_visited = set([(r,c)])\n            while component_q:\n                 gr, gc = component_q.popleft()\n                 if grid[gr, gc] == 3: # If it's green\n                     green_coords.add((gr, gc))\n                     core_object_coords.add((gr, gc))\n                     for nr, nc in get_neighbors(gr, gc, height, width, include_diagonals=True):\n                         if (nr, nc) not in component_visited and (nr, nc) not in core_object_coords and grid[nr, nc] == 3:\n                             component_visited.add((nr, nc))\n                             component_q.append((nr, nc))\n\n\n    return core_object_coords, green_coords\n\n\ndef get_border_pixels(grid, core_object_coords, green_coords):\n    \"\"\" Finds pixels adjacent to the green parts of the core object, but not in it. \"\"\"\n    height, width = grid.shape\n    border_pixels = {} # Store coords -> color\n\n    for r_g, c_g in green_coords:\n        for nr, nc in get_neighbors(r_g, c_g, height, width, include_diagonals=True):\n            if (nr, nc) not in core_object_coords:\n                 border_pixels[(nr, nc)] = grid[nr, nc]\n\n    return border_pixels\n\ndef check_maroon_adjacency(grid, border_pixels):\n    \"\"\" Checks if any maroon pixel is adjacent to any magenta border pixel. \"\"\"\n    height, width = grid.shape\n    magenta_border_coords = {coord for coord, color in border_pixels.items() if color == 6}\n\n    if not magenta_border_coords:\n        return False # No magenta border pixels to be adjacent to\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 9: # Found a maroon pixel\n                for nr, nc in get_neighbors(r, c, height, width, include_diagonals=True):\n                    if (nr, nc) in magenta_border_coords:\n                        return True # Maroon pixel is adjacent to a magenta border pixel\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules derived from examples:\n    Finds a red pixel and its connected green pixels (core object).\n    Analyzes the border around the green pixels.\n    Conditionally changes some or all green pixels to maroon based on border color\n    and proximity of external maroon pixels to a magenta border.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 1. Find the unique red (2) pixel\n    red_coord = find_pixel(input_np, 2)\n    if red_coord is None:\n        return input_grid # No red pixel, return original\n\n    r_red, c_red = red_coord\n\n    # 2. Identify the core object (red + connected green pixels)\n    core_object_coords, green_coords = find_core_object(input_np, r_red, c_red)\n\n    if not green_coords: # No green pixels connected to red\n        return input_grid\n\n    # 3. Identify the border pixels around the green part\n    border_pixels = get_border_pixels(input_np, core_object_coords, green_coords)\n\n    # 4. Analyze the border and apply rules\n    all_border_magenta = True\n    if not border_pixels: # Handle case with no border (e.g., object touches grid edge fully)\n        all_border_magenta = False # Cannot be all magenta if empty or contains other colors\n    else:\n        for color in border_pixels.values():\n            if color != 6:\n                all_border_magenta = False\n                break\n\n    apply_rule_a = False\n    apply_rule_b = False\n\n    if all_border_magenta:\n        # 4.a. Check for adjacent maroon pixels to the magenta border\n        maroon_adjacent_to_magenta_border = check_maroon_adjacency(input_np, border_pixels)\n        if maroon_adjacent_to_magenta_border:\n            # Rule B: Change all green to maroon\n            apply_rule_b = True\n        else:\n            # Rule A: Change specific green to maroon\n            apply_rule_a = True\n    else:\n        # 4.b. Border is not all magenta\n        # Rule A: Change specific green to maroon\n        apply_rule_a = True\n\n    # 5. Perform the transformation on the output grid\n    if apply_rule_b:\n        for r_g, c_g in green_coords:\n            output_np[r_g, c_g] = 9 # Change all green in core object to maroon\n    elif apply_rule_a:\n        for r_g, c_g in green_coords:\n            if r_g < r_red or (r_g == r_red and c_g < c_red):\n                output_np[r_g, c_g] = 9 # Change specific green to maroon\n\n    # Convert back to list of lists for the required output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4075,
    "candidates_token_count": 2124,
    "total_token_count": 6199,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.918749,
  "retries": 1
}