{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two static yellow (4) 'anchor' objects and one other uniquely colored 'mover' object against an orange (7) background.\nDetermines which anchor the mover is initially closest to (Source Anchor) and the other anchor (Target Anchor).\nCalculates the relative quadrant (NW, NE, SW, SE) of the mover with respect to the Source Anchor's center.\nCalculates the target position for the mover, which is adjacent to the Target Anchor in the diagonally opposite quadrant relative to the Target Anchor's bounding box.\nCreates the output grid by erasing the mover from its original position (filling with the background color) and drawing it in the new calculated position.\n\"\"\"\n\ndef find_objects(grid, ignore_color=None):\n    \"\"\"\n    Finds connected components of the same color in the grid.\n    Returns a list of objects, where each object is a dictionary containing\n    'color', 'coords' (list of (r, c) tuples), 'bbox' (min_r, min_c, max_r, max_c),\n    and 'center' (r, c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c]:\n                color = grid[r, c]\n                if ignore_color is not None and color == ignore_color:\n                    visited[r, c] = True\n                    continue\n\n                coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                sum_r, sum_c = 0, 0\n\n                while q:\n                    row, col = q.popleft()\n                    coords.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n                    sum_r += row\n                    sum_c += col\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if coords: # Only add if we found coordinates (i.e., not just background we skipped)\n                    center_r = sum_r / len(coords)\n                    center_c = sum_c / len(coords)\n                    objects.append({\n                        'color': color,\n                        'coords': coords,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'center': (center_r, center_c)\n                    })\n    return objects\n\ndef calculate_distance(center1, center2):\n    \"\"\"Calculates Euclidean distance between two center points.\"\"\"\n    r1, c1 = center1\n    r2, c2 = center2\n    return np.sqrt((r1 - r2)**2 + (c1 - c2)**2)\n\ndef get_relative_quadrant(center_obj, center_ref):\n    \"\"\"Determines the quadrant (NW, NE, SW, SE) of center_obj relative to center_ref.\"\"\"\n    obj_r, obj_c = center_obj\n    ref_r, ref_c = center_ref\n    \n    north = obj_r < ref_r\n    south = obj_r > ref_r\n    west = obj_c < ref_c\n    east = obj_c > ref_c\n\n    # Handle cases exactly on axis by slightly preferring N/S over E/W, then N over S, W over E\n    if not north and not south: # Exactly horizontal\n        north = True # Arbitrarily pick North\n    if not west and not east: # Exactly vertical\n        west = True # Arbitrarily pick West\n        \n    if north and west: return \"NW\"\n    if north and east: return \"NE\"\n    if south and west: return \"SW\"\n    if south and east: return \"SE\"\n    # Default/fallback if alignment is perfect (should be covered above)\n    return \"SE\" \n\ndef get_opposite_quadrant(quadrant):\n    \"\"\"Returns the diagonally opposite quadrant.\"\"\"\n    if quadrant == \"NW\": return \"SE\"\n    if quadrant == \"NE\": return \"SW\"\n    if quadrant == \"SW\": return \"NE\"\n    if quadrant == \"SE\": return \"NW\"\n    return None # Should not happen\n\ndef get_mover_relative_coords(coords):\n    \"\"\" Converts absolute coords to coords relative to the top-left corner. \"\"\"\n    if not coords:\n        return [], (0,0)\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    relative_coords = [(r - min_r, c - min_c) for r, c in coords]\n    return relative_coords, (min_r, min_c)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Make a copy to modify\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    \n    # Define known colors\n    background_color = 7\n    anchor_color = 4\n\n    # Find all non-background objects\n    objects = find_objects(output_grid, ignore_color=background_color)\n\n    # Identify anchors and mover\n    anchors = [obj for obj in objects if obj['color'] == anchor_color]\n    movers = [obj for obj in objects if obj['color'] != anchor_color]\n\n    # Basic validation\n    if len(anchors) != 2 or len(movers) != 1:\n        # Return original grid if assumptions aren't met\n        # Or raise an error, depending on desired behavior for unexpected input\n        print(f\"Warning: Expected 2 anchors and 1 mover, found {len(anchors)} anchors and {len(movers)} movers.\")\n        return output_grid \n        \n    mover = movers[0]\n    anchor1, anchor2 = anchors[0], anchors[1]\n\n    # Determine source and target anchors\n    dist1 = calculate_distance(mover['center'], anchor1['center'])\n    dist2 = calculate_distance(mover['center'], anchor2['center'])\n\n    if dist1 <= dist2:\n        source_anchor = anchor1\n        target_anchor = anchor2\n    else:\n        source_anchor = anchor2\n        target_anchor = anchor1\n\n    # Determine initial relative quadrant\n    initial_quadrant = get_relative_quadrant(mover['center'], source_anchor['center'])\n\n    # Determine target quadrant\n    target_quadrant = get_opposite_quadrant(initial_quadrant)\n\n    # Get mover shape relative to its top-left corner\n    mover_rel_coords, mover_orig_top_left = get_mover_relative_coords(mover['coords'])\n    mover_height = max(r for r, c in mover_rel_coords) + 1 if mover_rel_coords else 0\n    mover_width = max(c for r, c in mover_rel_coords) + 1 if mover_rel_coords else 0\n\n    # Get target anchor bounding box\n    tr_min, tc_min, tr_max, tc_max = target_anchor['bbox']\n\n    # Calculate new top-left position based on target quadrant and anchor bbox\n    new_r, new_c = 0, 0\n    if target_quadrant == \"NW\":\n        new_r = tr_min - mover_height\n        new_c = tc_min - mover_width\n    elif target_quadrant == \"NE\":\n        new_r = tr_min - mover_height\n        new_c = tc_max + 1\n    elif target_quadrant == \"SW\":\n        new_r = tr_max + 1\n        new_c = tc_min - mover_width\n    elif target_quadrant == \"SE\":\n        new_r = tr_max + 1\n        new_c = tc_max + 1\n        \n    # --- Grid Modification ---\n\n    # Erase mover from original position\n    for r, c in mover['coords']:\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = background_color\n\n    # Draw mover at new position\n    mover_color = mover['color']\n    for r_off, c_off in mover_rel_coords:\n        draw_r, draw_c = new_r + r_off, new_c + c_off\n        # Check bounds before drawing\n        if 0 <= draw_r < rows and 0 <= draw_c < cols:\n            output_grid[draw_r, draw_c] = mover_color\n        else:\n             # This case should ideally not happen based on ARC constraints/examples\n             # but good to be aware of potential out-of-bounds placement\n             print(f\"Warning: Calculated draw position ({draw_r}, {draw_c}) is out of bounds.\")\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3536,
    "candidates_token_count": 2233,
    "total_token_count": 5769,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.041491,
  "retries": 1
}