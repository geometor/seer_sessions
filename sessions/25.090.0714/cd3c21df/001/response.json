{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify all distinct objects (connected components of non-background pixels) in the input grid.\nFor each object, determine its pattern (colors and relative positions within its minimal bounding box).\nCount the occurrences of each unique pattern signature across all objects.\nFilter the objects to find those whose pattern signature appears exactly once (unique patterns).\nAmong these unique-pattern objects, evaluate their symmetry (horizontal, vertical, or both).\nSelect the unique-pattern object with the highest degree of symmetry (both > horizontal or vertical > none).\nIf there's a tie in symmetry among unique-pattern objects, select the one whose pattern contains the non-background color with the lowest numerical value.\nExtract the minimal bounding box containing the selected object and return it as the output grid.\n\"\"\"\n\ndef find_objects(grid, target_colors):\n    \"\"\"Finds connected components of specified colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in target_colors and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                obj_color = grid[r,c] # Check if all pixels in an object must have same color? No, examples show multi-color objects.\n                                      # The definition uses \"contiguous block\", implying connectivity, not necessarily same color.\n                                      # Okay, so connectivity applies to any non-background color.\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] in target_colors and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(list(obj_coords)) # Store as list for easier indexing later if needed\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the minimal bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None, None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return (min_r, min_c), (max_r, max_c)\n\ndef extract_pattern(grid, coords):\n    \"\"\"Extracts the subgrid corresponding to the object's bounding box.\"\"\"\n    if not coords:\n        return np.array([[]])\n    (min_r, min_c), (max_r, max_c) = get_bounding_box(coords)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    pattern = np.zeros((height, width), dtype=int)\n    \n    coord_set = set(coords) # Faster lookup\n    \n    # Create the pattern based on actual object pixels within the bounding box\n    # Background (0) remains if a pixel in BB is not part of the object\n    for r in range(height):\n        for c in range(width):\n            grid_r, grid_c = min_r + r, min_c + c\n            if (grid_r, grid_c) in coord_set:\n                 pattern[r, c] = grid[grid_r, grid_c]\n            # else: pattern[r,c] remains 0 - this might be wrong based on how patterns are compared.\n            # Let's rethink: The pattern should only contain the object pixels relative to its top-left corner,\n            # possibly on a background of 0. Yes, the bounding box defines the shape, and pixels within it are filled.\n\n    # Alternative: Use relative coordinates\n    pattern = np.zeros((height, width), dtype=int)\n    for r, c in coords:\n        pattern[r - min_r, c - min_c] = grid[r, c]\n        \n    return pattern\n\n\ndef get_pattern_signature(pattern):\n    \"\"\"Returns a hashable representation of the pattern.\"\"\"\n    return tuple(map(tuple, pattern.tolist()))\n\ndef check_symmetry(pattern):\n    \"\"\"Checks for horizontal and vertical symmetry. Returns score: 2 (both), 1 (H or V), 0 (none).\"\"\"\n    h_sym = np.array_equal(pattern, pattern[:, ::-1])\n    v_sym = np.array_equal(pattern, pattern[::-1, :])\n    if h_sym and v_sym:\n        return 2\n    elif h_sym or v_sym:\n        return 1\n    else:\n        return 0\n\ndef get_min_color(pattern):\n    \"\"\"Finds the minimum non-zero color value in the pattern.\"\"\"\n    non_zero_colors = pattern[pattern > 0]\n    if non_zero_colors.size == 0:\n        return float('inf') # Should not happen for valid objects\n    return np.min(non_zero_colors)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying a unique, maximally symmetric object\n    and returning its bounding box. Ties are broken by minimum color.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    # Define background color and target colors for object detection\n    background_color = 0\n    target_colors = set(range(1, 10)) \n\n    # 1. Find all distinct objects\n    objects_coords = find_objects(input_grid_np, target_colors)\n    if not objects_coords:\n        return np.array([[]]) # Or handle as error\n\n    object_details = []\n    pattern_signatures = []\n\n    # 2. Analyze each object: pattern, signature, symmetry\n    for coords in objects_coords:\n        pattern = extract_pattern(input_grid_np, coords)\n        signature = get_pattern_signature(pattern)\n        symmetry_score = check_symmetry(pattern)\n        min_color = get_min_color(pattern)\n        \n        object_details.append({\n            'coords': coords,\n            'pattern': pattern,\n            'signature': signature,\n            'symmetry': symmetry_score,\n            'min_color': min_color\n        })\n        pattern_signatures.append(signature)\n\n    # 3. Count pattern occurrences\n    pattern_counts = Counter(pattern_signatures)\n\n    # 4. Filter for unique patterns\n    unique_objects = [\n        obj for obj in object_details \n        if pattern_counts[obj['signature']] == 1\n    ]\n\n    if not unique_objects:\n         # This case didn't appear in examples. If it happens, the logic is undefined.\n         # Maybe return the object with the highest symmetry regardless of uniqueness?\n         # Or the smallest/largest unique one? Let's stick to the derived logic.\n         # If no *unique* patterns, maybe the task implies something else?\n         # For now, return empty or maybe the input? Let's return empty.\n        return np.array([[]]) \n\n    # 5. Find max symmetry among unique objects\n    max_symmetry = -1\n    for obj in unique_objects:\n        if obj['symmetry'] > max_symmetry:\n            max_symmetry = obj['symmetry']\n\n    # 6. Filter for max symmetry\n    max_symmetry_objects = [\n        obj for obj in unique_objects \n        if obj['symmetry'] == max_symmetry\n    ]\n\n    # 7. Select the final object (handle ties)\n    if len(max_symmetry_objects) == 1:\n        selected_object = max_symmetry_objects[0]\n    else:\n        # Tie-breaker: minimum color\n        min_min_color = float('inf')\n        for obj in max_symmetry_objects:\n            if obj['min_color'] < min_min_color:\n                min_min_color = obj['min_color']\n        \n        tied_min_color_objects = [\n            obj for obj in max_symmetry_objects\n            if obj['min_color'] == min_min_color\n        ]\n        \n        # If still tied (same max symmetry, same min color), pick the first one found.\n        # (Could add other tie-breakers like size or position if needed later)\n        selected_object = tied_min_color_objects[0] \n\n    # 8. Extract and return the pattern of the selected object\n    output_grid = selected_object['pattern']\n    \n    return output_grid.tolist() # Convert back to list of lists for ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2735,
    "candidates_token_count": 2130,
    "total_token_count": 4865,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.310472,
  "retries": 1
}