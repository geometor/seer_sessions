{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nThe transformation identifies all distinct contiguous objects (groups of connected pixels of the same non-white color) in the input grid.\nIt then determines if these objects are vertically separated or if their vertical extents overlap or touch.\nBased on this separation status, a target starting row ('target_start_row') is calculated:\n- If objects are vertically separated (no object's vertical range [min_row, max_row] overlaps or touches another's): 'target_start_row' is the maximum of the minimum row indices across all objects.\n- If objects overlap or touch vertically: 'target_start_row' is the maximum row index of the specific object that has the overall minimum starting row index among all objects.\nAn output grid of the same dimensions as the input is created, initialized with the background color (white, 0).\nEach non-white pixel from the input grid is then mapped to the output grid. For a pixel at (r, c) belonging to an object whose topmost row is 'obj_min_r', its new row ('new_r') is calculated as 'target_start_row + (r - obj_min_r)'. The column ('new_c') remains the same as the original column 'c'. The pixel at (new_r, new_c) in the output grid is set to the color of the original pixel, provided it's within the grid bounds. This process vertically aligns all objects based on the calculated target row, preserving their internal structure and relative horizontal positions.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-white color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object\n              and contains (color, set_of_coordinates). Returns an empty list\n              if no non-white objects are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # If not background (0) and not visited yet, start BFS\n            if color != 0 and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds and if neighbor has the same color and not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords: # Ensure we found coordinates for the object\n                    objects.append((color, obj_coords))\n                \n    return objects\n\ndef get_object_extents(object_coords):\n    \"\"\"\n    Calculates the minimum and maximum row index for a set of coordinates.\n\n    Args:\n        object_coords (set): A set of (row, col) tuples for an object.\n\n    Returns:\n        tuple: (min_row, max_row). Returns (inf, -inf) if the set is empty.\n    \"\"\"\n    if not object_coords:\n        return float('inf'), float('-inf')\n    min_r = min(r for r, c in object_coords)\n    max_r = max(r for r, c in object_coords)\n    return min_r, max_r\n\ndef check_vertical_separation(objects_with_extents):\n    \"\"\"\n    Checks if any objects overlap or touch vertically based on their row extents.\n\n    Args:\n        objects_with_extents (list): List of tuples (color, coords, min_r, max_r).\n\n    Returns:\n        bool: True if all objects are vertically separated, False otherwise.\n    \"\"\"\n    if len(objects_with_extents) <= 1:\n        return True # 0 or 1 object is considered separated\n\n    # Sort objects by min_r primarily, then max_r for consistency\n    sorted_objects = sorted(objects_with_extents, key=lambda x: (x[2], x[3]))\n\n    for i in range(len(sorted_objects) - 1):\n        obj1_min_r, obj1_max_r = sorted_objects[i][2], sorted_objects[i][3]\n        # Check against all subsequent objects\n        for j in range(i + 1, len(sorted_objects)):\n             obj2_min_r, obj2_max_r = sorted_objects[j][2], sorted_objects[j][3]\n             # Check for overlap or touching: max1 >= min2 means they touch or overlap\n             if obj1_max_r >= obj2_min_r:\n                 return False # Found overlap/touching\n\n    return True # No overlaps found\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the vertical alignment rule determined\n    by object separation.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    height, width = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color 0\n\n    # 1. Find all non-white objects\n    objects = find_objects(input_grid)\n\n    # Handle edge case: no objects found\n    if not objects:\n        return output_grid\n\n    # 2. Calculate vertical extents for each object\n    objects_with_extents = []\n    all_non_white_pixels = [] # Also collect all pixels for easier iteration later\n    pixel_to_obj_min_row = {} # Map pixel coord to its object's min_r\n\n    min_overall_start_row = float('inf')\n    object_with_min_start_row = None\n\n    for color, coords in objects:\n        if not coords: continue # Skip if an object somehow has no coordinates\n        min_r, max_r = get_object_extents(coords)\n        objects_with_extents.append((color, coords, min_r, max_r))\n        \n        # Track the object with the overall minimum starting row\n        if min_r < min_overall_start_row:\n            min_overall_start_row = min_r\n            object_with_min_start_row = (color, coords, min_r, max_r)\n        \n        # Populate pixel map and list\n        for r, c in coords:\n            all_non_white_pixels.append(((r, c), color))\n            pixel_to_obj_min_row[(r, c)] = min_r\n            \n    # Handle edge case: no valid objects with extents found (shouldn't happen if find_objects works)\n    if not objects_with_extents:\n         return output_grid\n\n    # 3. Determine vertical separation\n    are_separated = check_vertical_separation(objects_with_extents)\n\n    # 4. Calculate target_start_row based on separation\n    if are_separated:\n        # Target row is the max of all minimum starting rows\n        target_start_row = max(obj[2] for obj in objects_with_extents)\n    else:\n        # Target row is the max row of the object with the overall minimum start row\n        if object_with_min_start_row:\n             target_start_row = object_with_min_start_row[3] # max_r of that object\n        else:\n             # Fallback (should not be needed if objects exist)\n             target_start_row = min_overall_start_row\n\n\n    # 5. Create output grid by mapping pixels\n    for (r, c), color in all_non_white_pixels:\n        # Get the minimum row for the object this pixel belongs to\n        # Use get() with a default just in case, although map should be complete\n        obj_min_r = pixel_to_obj_min_row.get((r, c)) \n        \n        if obj_min_r is not None: # Check if pixel was found in map\n            # Calculate vertical offset within the object\n            offset = r - obj_min_r\n            \n            # Calculate new position\n            new_r = target_start_row + offset\n            new_c = c\n            \n            # Place pixel in output grid if within bounds\n            if 0 <= new_r < height and 0 <= new_c < width:\n                output_grid[new_r, new_c] = color\n        # else: # Should not happen if find_objects and mapping work correctly\n        #    print(f\"Warning: Pixel {(r,c)} not found in object map.\")\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6470,
    "candidates_token_count": 2177,
    "total_token_count": 8647,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.663184,
  "retries": 1
}