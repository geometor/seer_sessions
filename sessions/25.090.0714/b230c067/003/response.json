{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all separate, contiguous objects composed of azure (8) pixels in the input grid. \nCalculates the size (pixel count) of each object. Finds the object(s) with the minimum size.\nIf there's a tie for minimum size, selects the one whose top-most, left-most pixel appears earliest in scan order (row-major).\nColors the selected smallest object red (2) and all other azure objects blue (1). Leaves the background white (0).\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a list of (row, col) coordinates.\n              Returns an empty list if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find an unvisited pixel of the target color\n            if grid[r, c] == color and not visited[r, c]:\n                current_object_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.append((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check grid boundaries and if neighbor is same color and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                                \n                # Store the coordinates of the found object\n                if current_object_coords:\n                    objects.append(current_object_coords)\n                \n    return objects\n\ndef get_object_properties(obj_coords):\n    \"\"\"\n    Calculates properties of an object: size and top-left coordinate.\n\n    Args:\n        obj_coords (list): A list of (row, col) coordinates for an object.\n\n    Returns:\n        dict: A dictionary containing 'coords', 'size', and 'top_left'.\n              Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n        \n    # Size is the number of coordinates\n    size = len(obj_coords)\n    \n    # Sort coordinates primarily by row, secondarily by column to find top-left\n    top_left = sorted(obj_coords)[0]\n    \n    return {'coords': obj_coords, 'size': size, 'top_left': top_left}\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding azure objects, identifying the smallest\n    (first by scan order in case of tie), coloring it red, and others blue.\n\n    Args:\n        input_grid (np.array): The input grid with azure (8) objects on a white (0) background.\n\n    Returns:\n        np.array: The transformed grid with objects colored blue (1) or red (2).\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Define colors\n    azure_color = 8\n    blue_color = 1\n    red_color = 2\n    \n    # 1. Identify all azure objects\n    azure_object_coords_list = find_objects(output_grid, azure_color)\n\n    # If there are no azure objects, return the grid as is\n    if not azure_object_coords_list:\n        return output_grid\n\n    # 2. Calculate properties (size, top-left) for each object\n    object_properties = [get_object_properties(coords) for coords in azure_object_coords_list]\n    \n    # 3. Find the minimum size among all objects\n    min_size = min(prop['size'] for prop in object_properties)\n    \n    # 4. Create a list of objects that have this minimum size\n    min_size_objects = [prop for prop in object_properties if prop['size'] == min_size]\n    \n    # 5. Sort the minimum-sized objects by their top-left coordinate (scan order)\n    min_size_objects.sort(key=lambda x: x['top_left'])\n    \n    # 6. Select the first object from this sorted list as the target to color red\n    target_object_to_color_red_coords = set(min_size_objects[0]['coords']) # Use set for faster lookup\n\n    # 7. Iterate through all originally identified objects and apply recoloring\n    for obj_prop in object_properties:\n        current_coords = obj_prop['coords']\n        # Check if the *first coordinate* of the current object matches the first coordinate\n        # of the target object. Since coordinates within an object are unique, comparing\n        # the first coordinate (or any coordinate) is sufficient to identify the object.\n        # A more robust check compares the entire set of coordinates, but using the top-left\n        # is simpler if we trust find_objects returns distinct objects.\n        # Let's use the full coordinate set comparison for robustness.\n        \n        is_target_object = set(current_coords) == target_object_to_color_red_coords\n        \n        # Determine the color based on whether it's the target object\n        target_color = red_color if is_target_object else blue_color\n            \n        # Change the color of all pixels belonging to the current object\n        for r, c in current_coords:\n            output_grid[r, c] = target_color\n            \n    # 8. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10076,
    "candidates_token_count": 1448,
    "total_token_count": 11524,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.197073,
  "retries": 1
}