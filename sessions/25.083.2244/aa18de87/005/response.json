{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Lines:** Scan the input grid to find all horizontal and vertical lines. A line is a contiguous sequence of pixels of the *same non-zero color*. Only consider lines with length greater than 1.\n2.  **Group Lines:** Group the identified lines based on two criteria: their color and their orientation (horizontal or vertical). This results in groups of parallel lines of the same color.\n3.  **Sort Lines within Groups**: Within each group (same color and orientation), sort the lines.\n    *   For horizontal lines, sort by the starting column of each line.\n    *   For vertical lines, sort by the starting row of each line.\n4.  **Fill Between Lines:** For each group of lines (same color, same orientation):\n    *   Iterate through the *sorted* lines. For each consecutive pair of lines, fill the space *between* them with red (color code 2). \"Between\" is defined as:\n        *   **Horizontal Lines:** All pixels in the rows between the two lines' row, and columns from the smaller of the two line's ending columns plus one, and up to the larger of the two line start columns minus one.\n        *   **Vertical Lines:** All pixels in the columns between the two lines' column, and rows from the smaller of the two line's end rows plus one and up to the larger of the two line's starting rows minus one.\n5. **Output**: The output grid is the original grid with the spaces between the lines filled.\n\"\"\"\n\nimport numpy as np\n\ndef _find_lines(grid):\n    lines = []\n    rows, cols = grid.shape\n\n    # Horizontal lines\n    for r in range(rows):\n        start = None\n        for c in range(cols):\n            if grid[r, c] != 0:\n                if start is None:\n                    start = (r, c)\n            elif start is not None:\n                if c - start[1] > 1:\n                    lines.append({\n                        \"color\": grid[r, start[1]],\n                        \"start_point\": start,\n                        \"end_point\": (r, c - 1),\n                        \"length\": c - start[1],\n                        \"orientation\": \"horizontal\"\n                    })\n                start = None\n        if start is not None and cols - start[1] > 1:\n            lines.append({\n                \"color\": grid[r, start[1]],\n                \"start_point\": start,\n                \"end_point\": (r, cols - 1),\n                \"length\": cols - start[1],\n                \"orientation\": \"horizontal\"\n            })\n\n    # Vertical lines\n    for c in range(cols):\n        start = None\n        for r in range(rows):\n            if grid[r, c] != 0:\n                if start is None:\n                    start = (r, c)\n            elif start is not None:\n                if r - start[0] > 1:\n                    lines.append({\n                        \"color\": grid[start[0], c],\n                        \"start_point\": start,\n                        \"end_point\": (r - 1, c),\n                        \"length\": r - start[0],\n                        \"orientation\": \"vertical\"\n                    })\n                start = None\n        if start is not None and rows - start[0] > 1:\n            lines.append({\n                \"color\": grid[start[0], c],\n                \"start_point\": start,\n                \"end_point\": (rows - 1, c),\n                \"length\": rows - start[0],\n                \"orientation\": \"vertical\"\n            })\n\n    return lines\n\ndef _group_lines(lines):\n    groups = {}\n    for line in lines:\n        color = line[\"color\"]\n        orientation = line[\"orientation\"]\n        key = (color, orientation)\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(line)\n    return groups\n\ndef _sort_lines(grouped_lines):\n    sorted_groups = {}\n    for key, lines in grouped_lines.items():\n        color, orientation = key\n        if orientation == \"horizontal\":\n            sorted_lines = sorted(lines, key=lambda x: x[\"start_point\"][1])\n        else:  # vertical\n            sorted_lines = sorted(lines, key=lambda x: x[\"start_point\"][0])\n        sorted_groups[key] = sorted_lines\n    return sorted_groups\n\ndef _fill_between_lines(grid, lines):\n    output_grid = np.copy(grid)\n    for i in range(len(lines) - 1):\n        line1 = lines[i]\n        line2 = lines[i+1]\n\n        if line1[\"orientation\"] == \"horizontal\":\n            row = line1[\"start_point\"][0]\n            start_col = min(line1[\"end_point\"][1], line2[\"end_point\"][1]) + 1\n            end_col = max(line1[\"start_point\"][1], line2[\"start_point\"][1]) - 1\n            for c in range(start_col, end_col + 1):\n                if 0 <= c < output_grid.shape[1]:\n                  output_grid[row, c] = 2\n        elif line1[\"orientation\"] == \"vertical\":\n            col = line1[\"start_point\"][1]\n            start_row = min(line1[\"end_point\"][0], line2[\"end_point\"][0]) + 1\n            end_row = max(line1[\"start_point\"][0], line2[\"start_point\"][0]) - 1\n            for r in range(start_row, end_row + 1):\n              if 0 <= r < output_grid.shape[0]:\n                output_grid[r, col] = 2\n\n    return output_grid\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n\n    # find all lines and filter lines of length 1\n    lines = _find_lines(output_grid)\n\n    # group by color and orientation\n    grouped_lines = _group_lines(lines)\n\n    # sort lines within each group\n    sorted_grouped_lines = _sort_lines(grouped_lines)\n\n    # fill between lines in each group\n    for key, lines in sorted_grouped_lines.items():\n        output_grid = _fill_between_lines(output_grid, lines)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5514,
    "candidates_token_count": 1499,
    "total_token_count": 7013,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 17.719124
}