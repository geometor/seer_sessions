{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify the outermost border color.\n2. Identify the output border color based on input border and core colors.\n3. Identify Inner Border (if present).\n4. Identify the \"Core\".\n5. Determine Output Grid Size: Same as the combined \"core\" and inner border (if any).\n6. Transform Colors in the core based on example-specific rules, and inner border, if applicable.\n7. Construct Output Grid: Fill border with output border color, fill core area with transformed colors.\n8. Inner Border Preservation: Inner borders are not transformed.\n\"\"\"\n\nimport numpy as np\n\ndef get_border_color(grid):\n    \"\"\"Finds the most likely border color of a grid.\"\"\"\n    top_edge = grid[0, :]\n    bottom_edge = grid[-1, :]\n    left_edge = grid[:, 0]\n    right_edge = grid[:, -1]\n    all_edges = np.concatenate((top_edge, bottom_edge, left_edge, right_edge))\n    unique, counts = np.unique(all_edges, return_counts=True)\n    border_color = unique[np.argmax(counts)]\n    return border_color\n\ndef find_inner_border(grid, outer_border_color):\n    \"\"\"Identifies an inner border, if present.\"\"\"\n    rows, cols = grid.shape\n    # Create a mask for the outer border\n    outer_border_mask = np.full((rows, cols), False)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] == outer_border_color:\n                outer_border_mask[r,c] = True\n\n    # Use a flood fill algorithm to find contiguous regions\n    visited = np.zeros_like(grid, dtype=bool)\n    inner_border_colors = []\n\n    def is_valid(row, col):\n        return 0 <= row < rows and 0 <= col < cols\n\n    def flood_fill(row, col, color):\n        if (not is_valid(row, col) or visited[row, col] or\n            grid[row,col] != color or outer_border_mask[row,col]):\n            return\n        visited[row, col] = True\n        flood_fill(row + 1, col, color)\n        flood_fill(row - 1, col, color)\n        flood_fill(row, col + 1, color)\n        flood_fill(row, col - 1, color)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r,c] and not outer_border_mask[r,c]:\n                color = grid[r,c]\n                #Check adjacent to see if is border.\n                is_adjacent_to_outer_border = False\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r+dr, c+dc\n                    if is_valid(nr, nc) and outer_border_mask[nr, nc]:\n                        is_adjacent_to_outer_border = True\n                        break\n                if is_adjacent_to_outer_border:\n                  flood_fill(r, c, color) #fills visited\n                  inner_border_colors.append(color)\n\n    #Determine what part of the visited grid is not the core.\n    core_mask = np.copy(visited)\n    for r in range(rows):\n      for c in range(cols):\n        if not visited[r,c] and not outer_border_mask[r,c]: #then must be core\n            core_mask[r,c] = True\n\n    if len(inner_border_colors) > 0:\n      inner_border_color = inner_border_colors[0] # Assume only one\n      inner_border_grid = np.where(visited & ~core_mask, inner_border_color, -1)\n      return inner_border_grid\n    else:\n      return None\n\ndef extract_core(input_grid, outer_border_color, inner_border_grid):\n    \"\"\"Extracts the core of the grid.\"\"\"\n    rows, cols = input_grid.shape\n    core_grid = np.copy(input_grid)\n\n    if inner_border_grid is not None:\n      for r in range(rows):\n        for c in range(cols):\n          if inner_border_grid[r,c] != -1 or input_grid[r,c] == outer_border_color:\n            core_grid[r,c] = -1 # Use -1 to mark cells not in the core\n    else:\n      for r in range(rows):\n        for c in range(cols):\n          if input_grid[r,c] == outer_border_color:\n            core_grid[r,c] = -1\n\n    core_grid = core_grid[~np.all(core_grid == -1, axis=1)] #remove rows\n    core_grid = core_grid[:, ~np.all(core_grid == -1, axis=0)] #remove cols\n\n    return core_grid\n\ndef get_output_border_color(input_border_color, core_colors):\n    \"\"\"Determines the output border color based on the rules.\"\"\"\n    if input_border_color == 7:\n        if all(color in [4, 6, 7] for color in core_colors):\n            return 4\n        elif all(color in [1, 8, 5, 7] for color in core_colors):\n            return 1\n        elif all(color in [8, 3, 9, 7, 0] for color in core_colors):\n            return 8\n    return input_border_color  # Default case\n\ndef transform_core_colors(core_grid, input_border_color, inner_border_color):\n    \"\"\"Transforms the colors of the core grid.\"\"\"\n    transformed_grid = np.copy(core_grid)\n    rows, cols = transformed_grid.shape\n    color_map = {}\n\n    if input_border_color == 7:\n        core_colors = np.unique(core_grid)\n        if all(color in [4, 6, 7] for color in core_colors):  # Example 1\n            color_map = {4: 6}\n        elif all(color in [1, 8, 5, 7] for color in core_colors):  # Example 2\n            color_map = {1: 8, 8:8, 5:5}\n        elif all(color in [7, 8, 3, 9, 0] for color in core_colors): # Example 3\n           if inner_border_color == 0:\n                color_map = {8: 0, 9: 3, 3:3}\n\n    for r in range(rows):\n      for c in range(cols):\n        transformed_grid[r,c] = color_map.get(transformed_grid[r,c], transformed_grid[r,c])\n    return transformed_grid\n\ndef transform(input_grid):\n    # 1. Identify the outermost border color.\n    outer_border_color = get_border_color(input_grid)\n\n    # 2. Identify Inner Border\n    inner_border_grid = find_inner_border(input_grid, outer_border_color)\n    inner_border_color = None\n    if inner_border_grid is not None:\n        inner_border_color = np.unique(inner_border_grid[inner_border_grid != -1])[0]\n\n    # 3. Extract Core\n    core_grid = extract_core(input_grid, outer_border_color, inner_border_grid)\n\n    # Get core colors, handle -1 if present\n    core_colors = np.unique(core_grid)\n    core_colors = core_colors[core_colors != -1]\n    if inner_border_color is not None:\n        core_colors = np.append(core_colors, inner_border_color)\n\n\n    # 4. Determine the output border color.\n    output_border_color = get_output_border_color(outer_border_color, core_colors)\n\n    # 5. Determine Output Size\n    rows, cols = input_grid.shape # Start with input grid\n    output_grid = np.full((rows,cols),-1) #Fill with -1\n\n    # 6. Transform Core Colors\n    transformed_core = transform_core_colors(core_grid, outer_border_color, inner_border_color)\n\n    # Construct output grid\n    # Fill outer border.\n    for r in range(rows):\n      for c in range(cols):\n        if input_grid[r,c] == outer_border_color:\n          output_grid[r,c] = output_border_color\n    \n    # Fill in inner border if it exists\n    if inner_border_grid is not None:\n        for r in range(rows):\n            for c in range(cols):\n                if inner_border_grid[r, c] != -1:\n                    output_grid[r, c] = inner_border_color\n\n    # Find where to place the core in output\n    start_row, start_col = 0,0\n    if inner_border_grid is not None:\n      for r in range(rows):\n        for c in range(cols):\n          if inner_border_grid[r,c] != -1:\n            start_row = r\n            start_col = c\n            break\n    else: #no inner border\n      for r in range(rows):\n        for c in range(cols):\n          if input_grid[r,c] != outer_border_color:\n            start_row = r\n            start_col = c\n            break\n\n    # Fill Transformed Core\n    for r in range(transformed_core.shape[0]):\n      for c in range(transformed_core.shape[1]):\n        if transformed_core[r,c] != -1:\n          output_grid[start_row + r, start_col + c] = transformed_core[r, c]\n\n    # Trim output grid\n    output_grid = output_grid[~np.all(output_grid == -1, axis=1)] #remove rows\n    output_grid = output_grid[:, ~np.all(output_grid == -1, axis=0)] #remove cols\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8636,
    "candidates_token_count": 2448,
    "total_token_count": 11084,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 33.975235
}