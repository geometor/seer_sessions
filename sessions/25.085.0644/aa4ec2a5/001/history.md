
## train_1

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 4 4
4 4 4 1 1 1 1 4 4 4 4 4 4 4 4 4 1 4 4 4 1 1 1 4 4
4 4 4 1 1 1 1 1 1 1 4 4 4 4 4 4 1 4 4 4 1 1 1 4 4
4 4 4 1 1 1 1 4 4 1 4 4 4 4 4 4 1 4 4 4 1 1 1 4 4
4 4 4 1 1 1 1 4 4 1 4 4 4 4 4 4 1 1 1 1 1 1 1 4 4
4 4 4 4 4 4 1 1 1 1 4 4 4 4 4 4 1 1 1 1 1 1 1 4 4
4 4 4 4 4 4 1 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 4
4 4 2 2 2 2 2 2 4 4 4 4 4 4 4 2 8 8 8 8 8 8 8 2 4
4 4 2 8 8 8 8 2 2 2 2 4 4 4 4 2 8 6 6 6 8 8 8 2 4
4 4 2 8 8 8 8 8 8 8 2 4 4 4 4 2 8 6 6 6 8 8 8 2 4
4 4 2 8 8 8 8 6 6 8 2 4 4 4 4 2 8 6 6 6 8 8 8 2 4
4 4 2 8 8 8 8 6 6 8 2 4 4 4 4 2 8 8 8 8 8 8 8 2 4
4 4 2 2 2 2 8 8 8 8 2 4 4 4 4 2 8 8 8 8 8 8 8 2 4
4 4 4 4 4 2 8 8 8 8 2 4 4 4 4 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 2 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 2 2 2 2 2 2 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 1 1 1 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 1 1 1 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 1 1 1 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 1 1 1 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 1 1 1 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 4 4 4 1 1 1 1 1 1 1 4 4
4 1 1 1 1 1 1 1 4 4 1 4 4 4 1 4 4 4 4 1 1 4 4
4 1 1 1 1 1 1 1 4 4 1 1 1 1 1 4 4 4 4 1 1 4 4
4 1 1 1 1 1 1 1 4 4 1 1 1 1 1 4 4 4 4 1 1 4 4
4 1 1 1 1 1 1 1 4 4 1 1 1 1 1 4 4 4 4 1 1 4 4
4 1 1 1 1 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 4 4
4 1 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 4 4 4 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 4 4 4 4 4
4 4 4 4 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 2 2 2 4 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 2 2 2 2 2 8 2 4 2 8 8 8 8 8 8 8 2 4
2 1 1 1 1 1 1 1 2 2 8 2 2 2 8 6 6 6 6 8 8 2 4
2 1 1 1 1 1 1 1 2 2 8 8 8 8 8 6 6 6 6 8 8 2 4
2 1 1 1 1 1 1 1 2 2 8 8 8 8 8 6 6 6 6 8 8 2 4
2 1 1 1 1 1 1 1 2 2 8 8 8 8 8 6 6 6 6 8 8 2 4
2 1 1 1 1 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 2 4
2 1 1 1 1 2 4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 2 2 2 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 2 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 2 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 2 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 2 1 1 1 1 1 1 2 4 4 4 4
4 4 4 2 2 2 4 4 4 4 4 2 1 1 1 1 1 1 2 4 4 4 4
4 4 2 2 1 2 4 4 4 4 4 2 2 2 2 2 2 2 2 4 4 4 4
4 4 2 1 1 2 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 2 2 2 2 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 1 1 1 4 4 4 4 4 4 4 4 4
4 4 4 1 1 1 4 4 4 4 4 4 4 4 4
4 4 4 1 1 1 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 1 1 1 1 1 4 4 4 4 4 4
4 4 4 4 1 4 4 1 1 1 1 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 4 4 4 4
4 4 4 4 1 1 1 1 1 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 2 2 2 2 2 4 4 4 4 4 4 4 4
4 4 2 1 1 1 2 4 4 4 4 4 4 4 4
4 4 2 1 1 1 2 4 4 4 4 4 4 4 4
4 4 2 1 1 1 2 4 4 4 4 2 2 2 4
4 4 2 2 2 2 2 4 4 4 4 2 1 2 4
4 4 4 4 4 4 4 4 4 4 4 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 4 4 4 4 4
4 4 4 2 8 8 8 8 8 2 2 2 4 4 4
4 4 4 2 8 6 6 8 8 8 8 2 4 4 4
4 4 4 2 8 8 8 8 8 8 8 2 4 4 4
4 4 4 2 8 8 8 8 8 8 8 2 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

*   **Perception of Task Elements:**
    *   The input grids consist of a yellow (4) background and one or more disconnected shapes made of blue (1) pixels.
    *   The output grids retain the yellow (4) background but modify the areas around and including the original blue shapes.
    *   A red (2) border is created around each original blue shape. This border consists of pixels that were yellow in the input and were adjacent (including diagonally) to the blue shape.
    *   The area enclosed by the red border undergoes a color transformation based on its original content (blue or yellow pixels).
    *   If the enclosed area contained *only* blue pixels in the input, those pixels remain blue (1) in the output.
    *   If the enclosed area contained *both* blue and yellow pixels in the input:
        *   The original blue pixels are changed to azure (8).
        *   The original yellow pixels within the enclosure are filled with either azure (8) or magenta (6). Those adjacent (including diagonally) to the red (2) border become azure (8), while those not adjacent to the border become magenta (6).

*   **YAML Facts:**
    
```yaml
    elements:
      - object: background
        color: yellow (4)
        role: remains mostly unchanged, defines space outside shapes
      - object: blue_shape
        color: blue (1)
        property: connected component of pixels
        role: primary input feature, defines areas to be transformed
      - object: red_border
        color: red (2)
        property: 1-pixel thick, adjacent (including diagonal) to a blue_shape
        role: output feature, encloses transformed area, derived from yellow pixels
      - object: enclosed_region
        property: area surrounded by a red_border
        contains: original blue pixels, potentially original yellow pixels
        role: determines the transformation rule for pixels within
      - object: filled_interior
        colors: [blue (1), azure (8), magenta (6)]
        role: output state of the enclosed_region
    actions:
      - identify: find all connected components of blue (1) pixels (blue_shapes).
      - determine_border: for each blue_shape, find all adjacent (including diagonal) yellow (4) pixels.
      - create_border: change the determined border pixels to red (2).
      - analyze_enclosure: for each region enclosed by a red_border, check if it contained only blue (1) pixels or both blue (1) and yellow (4) pixels in the input.
      - apply_coloring_rule:
          - if enclosure was blue-only: keep original blue pixels as blue (1).
          - if enclosure was blue+yellow:
              - change original blue pixels to azure (8).
              - change original yellow pixels within enclosure:
                  - to azure (8) if adjacent (including diagonal) to any red (2) border pixel.
                  - to magenta (6) otherwise.
    relationships:
      - adjacency: yellow pixels adjacent (including diagonally) to blue pixels define the red border.
      - enclosure: the red border defines regions containing original blue/yellow pixels.
      - content: the original pixel colors (blue only vs blue+yellow) within an enclosure dictate the transformation rule (keep blue vs change blue to azure and fill yellow).
      - proximity_to_border: adjacency (including diagonal) of internal yellow pixels to the red border determines their fill color (azure vs magenta) when filling occurs.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify all distinct connected components (objects) of blue (1) pixels in the input grid.
    3.  For each identified blue object:
        a.  Find all yellow (4) pixels in the input grid that are adjacent (sharing a side or a corner) to any blue (1) pixel belonging to the current blue object. Store the coordinates of these adjacent yellow pixels; these will form the red border.
        b.  Temporarily mark the original blue pixels and the identified border pixels associated with this object.
        c.  Determine the set of pixels enclosed by the border pixels. Check if this enclosed region contains *any* yellow (4) pixels from the input grid that are *not* part of the border itself.
        d.  **Coloring Rule Application:**
            i.  If the enclosed region (excluding the border itself) contains *only* pixels that were originally blue (1):
                - Change the color of the border pixels (identified in step 3a) to red (2) in the output grid.
                - The original blue (1) pixels within the enclosure remain blue (1) in the output grid.
            ii. If the enclosed region (excluding the border itself) contains *both* pixels that were originally blue (1) and pixels that were originally yellow (4):
                - Change the color of the border pixels (identified in step 3a) to red (2) in the output grid.
                - Change the color of all original blue (1) pixels within the enclosure to azure (8) in the output grid.
                - For each original yellow (4) pixel within the enclosure (and not part of the border):
                    - Check if it is adjacent (sharing a side or a corner) to *any* red (2) border pixel (created in this step).
                    - If it is adjacent to a red (2) border pixel, change its color to azure (8) in the output grid.
                    - If it is *not* adjacent to any red (2) border pixel, change its color to magenta (6) in the output grid.
    4.  Ensure any pixels not modified by the above process retain their original color from the input grid (this mainly applies to the yellow background pixels far from any blue shapes).
