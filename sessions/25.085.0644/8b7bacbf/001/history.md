
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 0 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 0 0 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 7 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 7 7 7 7 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 7 7 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 7 7 7 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 7 7 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 2 0 0 2 2 0 0 2 0 0 2 2 0 2 0 0 2 0
0 0 2 0 0 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 4 4 2 0 0 0 0 0 2 4 4 2 0
0 0 2 4 4 2 2 4 4 2 0 0 2 2 0 2 4 4 2 0
0 0 2 4 4 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


## train_4

**input:**
```
0 0 2 2 0 0 0 0
0 2 0 0 2 0 0 0
0 2 0 0 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```


**output:**
```
0 0 2 2 0 0 0 0
0 2 4 4 2 0 0 0
0 2 4 4 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```

Okay, let's break down this task.

**Perception of Elements:**

1.  **Input/Output Grids:** The task provides pairs of input and output grids (2D arrays) filled with colored pixels (integers 0-9).
2.  **Colors:** Several colors are used: white (0), blue (1), red (2), green (3), yellow (4), gray (5), and orange (7).
3.  **Shapes/Regions:** The colored pixels often form shapes or contiguous regions. Some shapes appear to fully enclose regions of white pixels.
4.  **Unique Color:** In each input grid, there appears to be exactly one pixel of a specific color (orange (7) in train_1, yellow (4) in train_2, train_3, train_4). This unique color seems significant.
5.  **Transformation:** The primary transformation involves changing the color of *some* white (0) pixels to the unique color identified in the input. The pixels being changed are those located *inside* closed boundaries formed by non-white pixels.

**YAML Facts:**


```yaml
task_description: Fill enclosed white regions with a uniquely occurring color.
elements:
  - type: grid
    properties:
      - dimensions: variable (height x width, between 1x1 and 30x30)
      - pixels: integers 0-9 representing colors
  - type: color
    properties:
      - value: integer 0-9
      - role: background (white: 0), boundary (non-white), fill (unique color), target (white: 0)
  - type: region
    properties:
      - contiguity: pixels of the same color connected orthogonally or diagonally (based on observation, boundaries seem solid regardless of diagonal connection)
      - type: enclosed_white_region
        description: A contiguous area of white (0) pixels that cannot reach the grid border without crossing a non-white pixel.
      - type: boundary
        description: A contiguous structure of non-white pixels surrounding an enclosed region.
  - type: unique_color_pixel
    properties:
      - color: The color that appears exactly once in the input grid.
      - role: Determines the fill color for enclosed regions.

transformation:
  - action: identify_fill_color
    input: input_grid
    output: fill_color
    description: Scan the grid and count occurrences of each non-white color. The color appearing exactly once is the 'fill_color'.
  - action: identify_enclosed_regions
    input: input_grid
    output: set_of_enclosed_white_pixel_coordinates
    description: Find all white (0) pixels that are completely surrounded by non-white pixels (cannot reach the grid boundary via a path of only white pixels using orthogonal steps).
  - action: apply_fill
    input: input_grid, fill_color, set_of_enclosed_white_pixel_coordinates
    output: output_grid
    description: Create a copy of the input grid. Change the color of pixels at the 'set_of_enclosed_white_pixel_coordinates' to the 'fill_color'.

relationship:
  - The fill color used in the output is determined by the color that uniquely appears once in the input.
  - The locations filled are white pixels strictly inside boundaries formed by non-white pixels.
```


**Natural Language Program:**

1.  **Initialize:** Create a copy of the input grid, which will become the output grid.
2.  **Find Fill Color:** Analyze the input grid to find the color (from 1 to 9) that appears exactly once. Store this color as the `fill_color`.
3.  **Identify Enclosed White Pixels:**
    a. Create a boolean grid of the same dimensions as the input, initially all `False`. This grid will mark white pixels reachable from the border.
    b. Initialize a queue with the coordinates of all white (0) pixels located on the border (first/last row or first/last column) of the input grid. Mark these positions as `True` in the boolean grid.
    c. While the queue is not empty:
        i. Dequeue a coordinate `(r, c)`.
        ii. For each orthogonal neighbor `(nr, nc)` (up, down, left, right) of `(r, c)`:
            - If the neighbor is within the grid bounds, is white (0) in the input grid, and is marked `False` in the boolean grid:
                - Mark `(nr, nc)` as `True` in the boolean grid.
                - Enqueue `(nr, nc)`.
4.  **Apply Fill:** Iterate through every pixel `(r, c)` of the input grid. If the pixel is white (0) and its corresponding position `(r, c)` in the boolean grid is `False` (meaning it was not reachable from the border), change the color of the pixel at `(r, c)` in the output grid to the `fill_color`.
5.  **Return:** The modified output grid.
