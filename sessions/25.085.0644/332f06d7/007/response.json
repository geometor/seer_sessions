{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule Natural Language Program:\n\n1.  **Identify Objects and Features:**\n    *   Locate the unique red object (color 2), referred to as the 'agent'. If no agent exists, return the input grid unchanged.\n    *   Locate all distinct white objects (color 0), referred to as 'targets'. Count the total number of these target objects (`total_target_count`). If no targets exist, return the input grid unchanged.\n    *   Identify all blue pixels (color 1), forming the 'path'.\n    *   Note the background color (typically green, 3), which remains unchanged.\n\n2.  **Determine Reachability:**\n    *   Find all blue path pixels that are adjacent (including diagonally) to any pixel of the red agent. These are the starting points for the path search.\n    *   Perform a Breadth-First Search (BFS) starting simultaneously from all these initial blue path pixels.\n    *   The BFS explores the path by moving between adjacent (including diagonally) blue pixels.\n    *   The search stops when the BFS encounters the *first* blue pixel that is adjacent (including diagonally) to *any* pixel belonging to *any* white target object.\n    *   Identify the specific white target object that was reached ('reachable target'). If the BFS completes without finding such a connection, no target is reachable.\n\n3.  **Apply Transformations:**\n    *   Create the output grid as a copy of the input grid.\n    *   **If a white target object was reachable:**\n        *   Change the color of all pixels belonging to the 'reachable target' object to blue (color 1) in the output grid.\n        *   Check the `total_target_count` determined in step 1:\n            *   If `total_target_count` is exactly 1, change the color of all pixels belonging to the original red agent object to white (color 0) in the output grid.\n            *   If `total_target_count` is greater than 1, the red agent object remains unchanged (stays red, color 2) in the output grid.\n    *   **If no white target object was reachable:**\n        *   Make no changes to the output grid (it remains identical to the input grid).\n\n4.  **Return:** Output the modified grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color using 8-way connectivity (including diagonals).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a distinct object. Returns empty list if no objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited pixel of the target color\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is same color and unvisited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n                # Add the found object's coordinates to the list of objects\n                objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(coord, grid_shape, include_diagonal=True):\n    \"\"\"\n    Gets valid neighbor coordinates for a given coordinate within the grid boundaries.\n\n    Args:\n        coord (tuple): The (row, col) coordinate.\n        grid_shape (tuple): The (rows, cols) shape of the grid.\n        include_diagonal (bool): Whether to include diagonal neighbors.\n\n    Returns:\n        list[tuple]: A list of valid neighbor (row, col) coordinates.\n    \"\"\"\n    r, c = coord\n    rows, cols = grid_shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center pixel itself\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonal neighbors if not included (though default is True)\n            if not include_diagonal and abs(dr) + abs(dc) > 1:\n                 continue\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on agent, targets, and path reachability.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, ensuring the original input is unchanged\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Define colors used in the transformation logic\n    agent_color = 2             # Red\n    path_color = 1              # Blue\n    target_color = 0            # White\n    result_color_target = 1     # Blue (color to change reachable white object to)\n    result_color_agent_single = 0 # White (color to change red agent to if only 1 white obj)\n    # agent_color_multi = 2     # Red (agent color if multiple white objs - no change needed)\n\n    # --- Step 1: Identify Objects and Features ---\n\n    # Locate the red agent object\n    red_objects = find_objects(grid, agent_color)\n    # If no red agent is found, return the original grid unchanged\n    if not red_objects:\n        return input_grid # Return original list[list]\n    # Assumption based on examples: there is only one red object\n    red_object_coords = red_objects[0]\n\n    # Locate all white target objects and count them\n    white_objects = find_objects(grid, target_color)\n    num_white_objects = len(white_objects)\n    # If no white targets are found, return the original grid unchanged\n    if num_white_objects == 0:\n        return input_grid # Return original list[list]\n\n    # Create a lookup map for quick identification of which white object a coordinate belongs to\n    white_coord_to_object_index = {}\n    for idx, obj in enumerate(white_objects):\n        for coord in obj:\n            white_coord_to_object_index[coord] = idx\n\n    # Identify all blue path pixels\n    blue_path_coords = set(zip(*np.where(grid == path_color)))\n    if not blue_path_coords: # If there's no path, nothing can be reached\n        return input_grid\n\n    # --- Step 2: Determine Reachability ---\n\n    # Initialize BFS structures\n    queue = deque()\n    visited_path = set() # Keep track of visited blue path pixels during BFS\n    start_nodes = set()  # Collect unique blue pixels adjacent to the red object\n\n    # Find blue pixels adjacent (including diagonally) to any part of the red object\n    for r_coord in red_object_coords:\n        for neighbor in get_neighbors(r_coord, grid.shape, include_diagonal=True):\n            # Check if the neighbor is a blue path pixel and hasn't been visited yet (as a starting node)\n            if neighbor in blue_path_coords and neighbor not in start_nodes:\n                 start_nodes.add(neighbor)\n                 queue.append(neighbor) # Add valid starting nodes to the queue\n                 visited_path.add(neighbor) # Mark starting nodes as visited\n\n    reachable_white_object_index = -1 # Index of the first reachable white object found\n    reachable_white_object_coords = None # Coordinates of that object\n\n    # Perform BFS through the blue path\n    while queue:\n        current_coord = queue.popleft() # Get the next blue pixel from the path\n\n        # Check if the current blue pixel is adjacent (including diagonally) to any white pixel\n        found_target = False\n        potential_targets = [] # Store potential targets reached from this node\n\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            if neighbor in white_coord_to_object_index:\n                # A connection to a white object is found\n                target_object_index = white_coord_to_object_index[neighbor]\n                potential_targets.append(target_object_index)\n                found_target = True\n                # Don't break here, check all neighbors first to handle cases where\n                # a path node touches multiple targets simultaneously. We need the \"first\"\n                # reached overall, which BFS handles by level. If multiple are found\n                # at the same BFS level, the specific one chosen might depend on queue order,\n                # but the logic requires *any* first reachable one. We'll take the first one\n                # identified in this neighbor loop if multiple are hit by the same path node.\n\n        if found_target:\n            # Record the first reachable white object encountered at this BFS level\n            reachable_white_object_index = potential_targets[0] # Take the first one found\n            reachable_white_object_coords = white_objects[reachable_white_object_index]\n            break # Exit BFS entirely, as we only care about the first reachable object\n\n        # If no target found yet, expand the BFS to adjacent unvisited blue path pixels\n        if not found_target: # Only expand if we haven't found the target yet\n            for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n                # Check if the neighbor is part of the blue path and hasn't been visited in this BFS\n                if neighbor in blue_path_coords and neighbor not in visited_path:\n                    visited_path.add(neighbor)\n                    queue.append(neighbor)\n\n    # --- Step 3: Apply Transformations ---\n\n    # Check if the BFS successfully found a reachable white object\n    if reachable_white_object_coords is not None:\n        # Rule 3.If_true.i: Change all pixels of the reachable white object to blue\n        for r, c in reachable_white_object_coords:\n            output_grid[r, c] = result_color_target\n\n        # Rule 3.If_true.ii: Determine the transformation of the red object based on the *total* count of white objects\n        if num_white_objects == 1:\n            # If exactly one white object existed *in the input grid*, change the red object to white\n            for r, c in red_object_coords:\n                output_grid[r, c] = result_color_agent_single\n        elif num_white_objects > 1:\n            # If more than one white object existed *in the input grid*, the red object remains unchanged (red)\n            # No action needed as output_grid started as a copy with the red object intact\n            pass\n        # Note: The case num_white_objects == 0 was handled earlier\n\n    # Rule 3.If_false: If no white object was reachable (reachable_white_object_coords is None),\n    # no changes are made beyond the initial copy, so the grid remains as is.\n\n    # Convert the final NumPy array back to a standard list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14636,
    "candidates_token_count": 2808,
    "total_token_count": 17444,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.122613
}