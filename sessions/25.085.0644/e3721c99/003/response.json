{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom collections import deque\n\n\"\"\"\n1.  Identify the horizontal blue line that separates the grid into an upper and lower section.\n2.  Copy the input grid to create the output grid. The upper section and the blue line itself will remain unchanged.\n3.  Identify all distinct, connected, non-white objects in the upper section (above the blue line). For each object, record its color, its shape (relative coordinates of its pixels from its top-left corner), its absolute pixel coordinates, and the coordinates of its top-left corner. These are the 'key' objects.\n4.  Identify all distinct, connected, gray objects in the lower section (below the blue line). For each object, record its absolute pixel coordinates and the coordinates of its top-left corner. These are the 'target' objects.\n5.  For each target object:\n    a.  Calculate the minimum Euclidean distance from any pixel of the target object to any pixel of *every* key object identified in step 3.\n    b.  Select the key object that has the overall minimum distance to the target object.\n    c.  If two or more key objects are equidistant (have the same minimum distance), select the key object whose top-left corner has the smallest row index. If there is still a tie, select the one among the tied objects whose top-left corner has the smallest column index.\n    d.  In the output grid, set all pixels originally belonging to the current target object to white (0).\n    e.  Using the top-left corner of the *original* target object as an anchor point, draw the shape of the selected key object (from step 5c) onto the output grid using the selected key object's color. Ensure drawing stays within grid bounds.\n6.  Return the modified output grid.\n\"\"\"\n\ndef find_separator_row(grid):\n    \"\"\"Finds the row index of the first horizontal blue line.\"\"\"\n    rows, _ = grid.shape\n    for r in range(rows):\n        if np.all(grid[r, :] == 1): # Blue color is 1\n            return r\n    return -1 # Return -1 if no separator is found\n\ndef get_objects_bfs(grid, start_row, end_row, condition_func, get_color_shape=False):\n    \"\"\"\n    Finds connected components within a specified row range using BFS based on a condition.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): The starting row (inclusive) for object search.\n        end_row (int): The ending row (exclusive) for object search.\n        condition_func (callable): A function that takes a pixel value and returns True \n                                   if the pixel should be part of an object.\n        get_color_shape (bool): If True, extracts the object's color and relative shape.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'pixels' (set of (r, c) tuples),\n              'bbox' (tuple: min_r, min_c, max_r, max_c),\n              'top_left' (tuple: min_r, min_c),\n              'color' (int, optional),\n              'shape' (set of relative (dr, dc) tuples, optional).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(start_row, end_row):\n        for c in range(cols):\n            # Check condition, bounds, and if already visited\n            if not visited[r, c] and condition_func(grid[r, c]):\n                \n                color = grid[r, c] # Store the color of the starting pixel\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds, visited status, condition, and SAME COLOR\n                            if start_row <= nr < end_row and 0 <= nc < cols and \\\n                               not visited[nr, nc] and \\\n                               condition_func(grid[nr, nc]) and \\\n                               grid[nr, nc] == color: # Ensure connectivity is based on same color\n                                \n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                obj_info = {\n                    \"pixels\": obj_pixels,\n                    \"bbox\": (min_r, min_c, max_r, max_c),\n                    \"top_left\": (min_r, min_c)\n                }\n\n                if get_color_shape:\n                   obj_info[\"color\"] = color\n                   # Calculate relative shape based on the top-left of the bounding box\n                   shape = set((pr - min_r, pc - min_c) for pr, pc in obj_pixels)\n                   obj_info[\"shape\"] = shape\n\n                objects.append(obj_info)\n                \n    return objects\n\ndef calculate_min_distance(obj1_pixels, obj2_pixels):\n    \"\"\"Calculates the minimum Euclidean distance between any pair of pixels from two objects.\"\"\"\n    min_dist_sq = float('inf')\n    # If either object is empty, return infinity\n    if not obj1_pixels or not obj2_pixels:\n        return float('inf')\n        \n    for r1, c1 in obj1_pixels:\n        for r2, c2 in obj2_pixels:\n            dist_sq = (r1 - r2)**2 + (c1 - c2)**2\n            if dist_sq < min_dist_sq:\n                min_dist_sq = dist_sq\n                # Optimization: if distance is 0, can't get smaller\n                if min_dist_sq == 0:\n                    return 0.0 \n                    \n    return math.sqrt(min_dist_sq)\n\ndef draw_shape(grid, top_left, shape, color):\n    \"\"\"Draws a shape onto the grid at the specified anchor point.\"\"\"\n    rows, cols = grid.shape\n    anchor_r, anchor_c = top_left\n    for dr, dc in shape:\n        r, c = anchor_r + dr, anchor_c + dc\n        # Check if the pixel is within the grid boundaries\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replacing gray shapes below a blue separator \n    with the shape and color of the geometrically closest non-white object \n    from above the separator.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Find the horizontal blue separator line.\n    separator_row = find_separator_row(output_grid)\n    if separator_row == -1:\n        # If no separator found, return the original grid (or handle as error)\n        return output_grid \n\n    # 3. Identify 'key' objects (non-white) above the separator.\n    key_objects = get_objects_bfs(\n        grid=output_grid, \n        start_row=0, \n        end_row=separator_row, \n        condition_func=lambda x: x != 0, # Non-white\n        get_color_shape=True\n    )\n\n    # 4. Identify 'target' objects (gray) below the separator.\n    target_objects = get_objects_bfs(\n        grid=output_grid, \n        start_row=separator_row + 1, \n        end_row=rows, \n        condition_func=lambda x: x == 5, # Gray color is 5\n        get_color_shape=False\n    )\n\n    # If there are no key objects, no transformation can occur below the line.\n    if not key_objects:\n        return output_grid\n\n    # 5. Process each target object.\n    for target_obj in target_objects:\n        min_distance = float('inf')\n        closest_key = None\n\n        # 5a. Calculate distances to all key objects.\n        for key_obj in key_objects:\n            distance = calculate_min_distance(target_obj[\"pixels\"], key_obj[\"pixels\"])\n            \n            update_closest = False\n            # 5b. Select the key object with the minimum distance.\n            if distance < min_distance:\n                update_closest = True\n            # 5c. Apply tie-breaking rules.\n            elif distance == min_distance:\n                 # Compare top-left row index first\n                 if key_obj[\"top_left\"][0] < closest_key[\"top_left\"][0]:\n                     update_closest = True\n                 # If rows are equal, compare top-left column index\n                 elif key_obj[\"top_left\"][0] == closest_key[\"top_left\"][0] and \\\n                      key_obj[\"top_left\"][1] < closest_key[\"top_left\"][1]:\n                     update_closest = True\n\n            if update_closest:\n                min_distance = distance\n                closest_key = key_obj\n\n        # Ensure a closest key was found (should always happen if key_objects is not empty)\n        if closest_key:\n            # 5d. Clear the original target object pixels in the output grid.\n            for r, c in target_obj[\"pixels\"]:\n                 # Boundary check (though pixels should be within bounds by definition)\n                if 0 <= r < rows and 0 <= c < cols: \n                   output_grid[r, c] = 0 # Set to background color (white)\n\n            # 5e. Draw the closest key's shape at the target's anchor point.\n            draw_shape(\n                grid=output_grid, \n                top_left=target_obj[\"top_left\"], # Anchor using target's top-left\n                shape=closest_key[\"shape\"], \n                color=closest_key[\"color\"]\n            )\n\n    # 6. Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8275,
    "candidates_token_count": 2496,
    "total_token_count": 10771,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.042048
}