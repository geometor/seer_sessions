{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies isolated pixels of specific colors (red (2), green (3), gray (5)) and replaces the area around them with a 4x4 hollow square of a corresponding mapped color (yellow (4), blue (1), magenta (6), respectively). \n\nAn isolated pixel is defined as a pixel whose 8 neighbors (orthogonal and diagonal) are all the background color (white, 0). Pixels on the border or corner of the grid are considered isolated if all their existing neighbors are background color.\n\nWhen an isolated pixel of a trigger color is found at position (r, c), a 4x4 hollow square is drawn on the output grid. This square is centered at (r, c), meaning its top-left corner is at (r-1, c-1). The perimeter of the 4x4 square is set to the mapped color, and the inner 2x2 area is set to the background color (white, 0). Drawing respects grid boundaries.\n\nAll other pixels from the input grid that are not part of these transformations (i.e., not isolated trigger pixels and not part of the area where a hollow square is drawn) remain unchanged in the output grid.\n\"\"\"\n\n\ndef is_isolated(grid, r, c, trigger_colors, background_color=0):\n    \"\"\"\n    Checks if the pixel at (r, c) is one of the trigger_colors and \n    if all its 8 neighbors are the background_color.\n    Handles grid boundaries implicitly (out-of-bounds is treated as isolated).\n\n    Args:\n        grid (np.array): The input grid.\n        r (int): Row index of the pixel to check.\n        c (int): Column index of the pixel to check.\n        trigger_colors (set): Set of colors that trigger the transformation if isolated.\n        background_color (int): The color value considered as background.\n\n    Returns:\n        bool: True if the pixel is isolated and has a trigger color, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Check if the center pixel itself has a trigger color\n    if grid[r, c] not in trigger_colors:\n        return False\n        \n    # Check all 8 neighbors\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center cell itself\n            if dr == 0 and dc == 0:\n                continue\n            \n            nr, nc = r + dr, c + dc\n            \n            # Check if the neighbor coordinate is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # If the neighbor is within bounds, it MUST be the background color\n                if grid[nr, nc] != background_color:\n                    return False\n            # If the neighbor is out of bounds, it doesn't violate the isolation condition.\n            \n    # If all existing neighbors were background, the pixel is isolated\n    return True\n\ndef draw_hollow_square(grid, center_r, center_c, color, background_color=0):\n    \"\"\"\n    Draws a 4x4 hollow square of the specified 'color' onto the 'grid',\n    centered at (center_r, center_c). The inner 2x2 area is set to \n    'background_color'. Modifies the grid in place. Handles grid boundaries.\n\n    Args:\n        grid (np.array): The grid to draw on (modified in place).\n        center_r (int): Row index of the center of the square.\n        center_c (int): Column index of the center of the square.\n        color (int): The color to use for the square's perimeter.\n        background_color (int): The color to use for the square's interior.\n    \"\"\"\n    height, width = grid.shape\n    # Calculate the top-left corner of the 4x4 bounding box\n    start_r, start_c = center_r - 1, center_c - 1\n    \n    # Iterate over the 4x4 area where the square should be drawn\n    for r in range(start_r, start_r + 4):\n        for c in range(start_c, start_c + 4):\n            # Ensure the drawing coordinates are within the grid bounds\n            if 0 <= r < height and 0 <= c < width:\n                # Determine if the current cell (r, c) is on the perimeter\n                # A cell is on the perimeter if its row is the start/end row\n                # OR its column is the start/end column of the 4x4 box.\n                is_perimeter = (r == start_r or r == start_r + 3 or\n                                c == start_c or c == start_c + 3)\n                                \n                if is_perimeter:\n                    # Set perimeter cells to the specified color\n                    grid[r, c] = color\n                else:\n                    # Set inner (non-perimeter) cells to the background color\n                    grid[r, c] = background_color\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding isolated red (2), green (3), or gray (5) \n    pixels and replacing the area around them with a centered 4x4 hollow square \n    of yellow (4), blue (1), or magenta (6) respectively.\n\n    Args:\n        input_grid (np.array): The 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: The 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Define the colors that trigger the transformation when isolated\n    trigger_colors = {2, 3, 5} # Red, Green, Gray\n    \n    # Define the mapping from trigger color to the output square color\n    color_map = {\n        2: 4, # Red -> Yellow\n        3: 1, # Green -> Blue\n        5: 6  # Gray -> Magenta\n    }\n    \n    # Define the background color\n    background_color = 0\n\n    # Iterate through each cell of the input grid\n    for r in range(height):\n        for c in range(width):\n            # Check if the current cell contains an isolated trigger pixel\n            # Use the input_grid for checking conditions\n            if is_isolated(input_grid, r, c, trigger_colors, background_color):\n                # Get the corresponding color for the output square\n                output_color = color_map[input_grid[r, c]]\n                \n                # Draw the hollow square onto the output grid\n                # The draw function modifies the output_grid in place\n                draw_hollow_square(output_grid, r, c, output_color, background_color)\n                \n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5194,
    "candidates_token_count": 1589,
    "total_token_count": 6783,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.271491
}