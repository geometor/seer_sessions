{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies 5x5 square objects in the input grid, characterized by a 1-pixel thick frame of either Azure (8) or Red (2) and a 3x3 filled center of a single color different from the frame color.\nThe transformation rule translates these objects horizontally based on their frame color:\n- Objects with an Azure (8) frame are shifted left by 1 column.\n- Objects with a Red (2) frame are shifted right by 5 columns.\nThe output grid is initialized with the background color (determined as the most frequent color in the input grid) and then the translated objects are drawn onto it. Objects are identified by scanning the input grid top-to-bottom, left-to-right based on their top-left corner. They are drawn in the order they are found, meaning later objects can overwrite parts of earlier objects if their translated positions overlap. Pixels of objects moved outside the grid boundaries are clipped (not drawn).\n\"\"\"\n\ndef find_objects(input_grid):\n    \"\"\"\n    Finds all 5x5 frame/center objects in the grid.\n    An object has a 1-pixel frame (Azure=8 or Red=2) and a 3x3 center\n    of a single color different from the frame color.\n    Allows finding overlapping objects.\n    Returns a list of objects, each with 'top_left', 'frame_color', 'center_color'.\n    Objects are found by iterating through potential top-left corners (r, c).\n    \"\"\"\n    objects = []\n    height, width = input_grid.shape\n\n    # Iterate through all possible top-left corners (r, c) for a 5x5 object\n    for r in range(height - 4):\n        for c in range(width - 4):\n            # Check if the top-left pixel could be the start of an Azure or Red frame\n            potential_frame_color = input_grid[r, c]\n            if potential_frame_color != 8 and potential_frame_color != 2:\n                continue\n\n            # Verify the 5x5 area matches the frame/center pattern\n            is_object = True\n            potential_center_color = -1 # Sentinel value for uninitialized center color\n\n            # Check frame pixels (i=0 or 4, or j=0 or 4)\n            for i in range(5):\n                if input_grid[r + i, c + 0] != potential_frame_color or \\\n                   input_grid[r + i, c + 4] != potential_frame_color:\n                    is_object = False\n                    break\n            if not is_object: continue\n            for j in range(1, 4): # Check top/bottom frame rows (excluding corners already checked)\n                 if input_grid[r + 0, c + j] != potential_frame_color or \\\n                    input_grid[r + 4, c + j] != potential_frame_color:\n                     is_object = False\n                     break\n            if not is_object: continue\n\n            # Check center pixels (1<=i<=3 and 1<=j<=3)\n            for i in range(1, 4):\n                for j in range(1, 4):\n                    current_center_pixel = input_grid[r + i, c + j]\n                    \n                    # Initialize potential center color on first center pixel\n                    if potential_center_color == -1:\n                        potential_center_color = current_center_pixel\n                        # Center color must not be the same as frame color\n                        if potential_center_color == potential_frame_color:\n                            is_object = False\n                            break\n                    # Ensure all subsequent center pixels match the first one\n                    elif current_center_pixel != potential_center_color:\n                        is_object = False\n                        break\n                if not is_object: break # Break outer center loop if mismatch found\n            if not is_object: continue # Continue scanning if center check failed\n\n            # If a valid 5x5 object is found (frame and center checks passed)\n            if is_object and potential_center_color != -1:\n                objects.append({\n                    'top_left': (r, c),\n                    'frame_color': potential_frame_color,\n                    'center_color': potential_center_color\n                })\n\n    return objects\n\ndef draw_object(output_grid, top_left, frame_color, center_color):\n    \"\"\"\n    Draws a 5x5 object at the specified top_left coordinates on the output grid.\n    Handles boundary clipping. Overwrites existing pixels.\n    \"\"\"\n    new_r, new_c = top_left\n    height, width = output_grid.shape\n\n    # Iterate through the 5x5 area of the object\n    for i in range(5):\n        for j in range(5):\n            # Calculate target row and column in the output grid\n            tr, tc = new_r + i, new_c + j\n\n            # Check grid boundaries before drawing - skip pixel if outside\n            if 0 <= tr < height and 0 <= tc < width:\n                # Determine if it's a frame or center pixel based on relative position (i, j)\n                if i == 0 or i == 4 or j == 0 or j == 4:\n                    # Draw frame pixel\n                    output_grid[tr, tc] = frame_color\n                else:\n                    # Draw center pixel\n                    output_grid[tr, tc] = center_color\n\ndef get_background_color(grid):\n    \"\"\"\n    Determines the background color, assuming it's the most frequent color in the grid.\n    Handles tie-breaking by choosing the smallest color value if counts are equal.\n    \"\"\"\n    if grid.size == 0:\n        return 0 # Default background for empty grid\n    colors, counts = np.unique(grid, return_counts=True)\n    # Find the index of the maximum count\n    max_count_indices = np.where(counts == counts.max())[0]\n    # If there's a tie in counts, return the smallest color value among the most frequent\n    background_color = colors[max_count_indices].min()\n    return background_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    1. Determines the background color.\n    2. Initializes the output grid with the background color.\n    3. Finds all 5x5 frame/center objects (Azure or Red frame).\n    4. Calculates the new top-left position for each object based on its frame color.\n    5. Draws each translated object onto the output grid, handling clipping and overwriting.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Determine background color (most frequent color in input)\n    background_color = get_background_color(input_grid_np)\n\n    # Initialize output grid with the determined background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # Find all relevant 5x5 objects in the input grid\n    # Objects are returned in the order their top-left corner was encountered (row-major)\n    objects = find_objects(input_grid_np)\n\n    # Translate and draw each object onto the output grid\n    # The order of drawing matters for overlapping objects: later objects overwrite earlier ones.\n    for obj in objects:\n        r, c = obj['top_left']          # Original top-left row and column\n        frame_color = obj['frame_color']\n        center_color = obj['center_color']\n\n        # Calculate the new top-left position based on frame color\n        new_r = r # Row position remains unchanged\n        new_c = c # Initialize new column with original column\n\n        if frame_color == 8: # Azure frame: move left by 1 column\n            new_c = c - 1\n        elif frame_color == 2: # Red frame: move right by 5 columns\n            new_c = c + 5\n\n        # Draw the object at its new translated position on the output grid\n        # The draw_object function handles boundary clipping and overwrites pixels\n        draw_object(output_grid, (new_r, new_c), frame_color, center_color)\n\n    # Convert the final NumPy grid back to a standard Python list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11246,
    "candidates_token_count": 1951,
    "total_token_count": 13197,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 46.541187
}