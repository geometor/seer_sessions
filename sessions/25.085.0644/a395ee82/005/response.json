{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the largest connected object in the input grid as the 'pattern' and the smallest connected objects as 'markers'. \nIt then copies the input grid to the output grid and stamps copies of the 'pattern' onto the output grid. \nEach pattern copy is centered on the location of each pixel belonging to any 'marker' object.\n\n1.  **Identify Background:** Determine the background color by finding the most frequent color in the input grid.\n2.  **Find Objects:** Identify all distinct connected objects (contiguous groups of same-colored pixels, using 8-way adjacency) that are *not* the background color. For each object, note its color, size (pixel count), pixel coordinates, and bounding box.\n3.  **Identify Pattern Object:** Find the object with the largest size. This is the 'pattern object'. Record its color, its pixel coordinates relative to its bounding box's top-left corner (its shape), and calculate the relative center offset of its bounding box (`row_offset = bbox_height // 2`, `col_offset = bbox_width // 2`).\n4.  **Identify Marker Colors:** Find the minimum size among all non-background objects. Identify the set of all distinct colors associated with objects of this minimum size. These are the 'marker colors'.\n5.  **Find Marker Locations:** Locate all pixels in the *original input grid* that have any of the identified 'marker colors'. These coordinates are the 'marker locations'.\n6.  **Initialize Output:** Create the output grid by making an exact copy of the input grid.\n7.  **Stamp Pattern Copies:** For each 'marker location' `(marker_row, marker_col)`:\n    *   Calculate the intended top-left coordinate `(target_top_left_row, target_top_left_col)` for placing the pattern copy by aligning the pattern's bounding box center offset with the marker location.\n    *   Iterate through each relative pixel coordinate `(rel_row, rel_col)` defining the pattern's shape.\n    *   Calculate the destination coordinate `(dest_row, dest_col)` on the output grid.\n    *   If the destination coordinate is within the grid bounds, change the color of the pixel at this location in the output grid to the pattern object's color (overwriting the previous color).\n8.  **Return Output:** The modified grid after processing all marker locations is the final output.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_objects(grid, background_color):\n    \"\"\"\n    Finds all connected objects in the grid using BFS, excluding the background color.\n    Uses 8-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        dict: A dictionary where keys are object IDs (1-based) and values are\n              dictionaries containing 'color', 'coords' (list of tuples),\n              'size', and 'bbox' (tuple: min_r, min_c, max_r, max_c).\n    \"\"\"\n    objects = {}\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    obj_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and not visited[r, c]:\n                # Start BFS for a new object\n                obj_id_counter += 1\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_coords = []\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds, color match, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store found object\n                objects[obj_id_counter] = {\n                    'color': color,\n                    'coords': current_object_coords,\n                    'size': len(current_object_coords),\n                    'bbox': (min_r, min_c, max_r, max_c) # Store as tuple: min_r, min_c, max_r, max_c\n                }\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    if input_grid_np.size == 0:\n        return [] # Handle empty grid case\n    color_counts = Counter(input_grid_np.flatten())\n    # Handle case where grid has only one color or is uniform\n    if not color_counts:\n         background_color = 0 # Default if truly empty? Should be caught by size check.\n    else:\n        background_color = color_counts.most_common(1)[0][0]\n\n\n    # 2. Find Non-Background Objects\n    all_objects = find_connected_objects(input_grid_np, background_color)\n\n    # Edge Case: No non-background objects found\n    if not all_objects:\n        return input_grid # Return original grid as list of lists\n\n    # 3. Identify Pattern Object (Largest)\n    pattern_obj_id = max(all_objects, key=lambda k: all_objects[k]['size'])\n    pattern_obj = all_objects[pattern_obj_id]\n    pattern_color = pattern_obj['color']\n    pattern_coords_absolute = pattern_obj['coords']\n    min_r, min_c, max_r, max_c = pattern_obj['bbox']\n\n    # Calculate pattern shape relative to its bounding box top-left\n    pattern_coords_relative = []\n    for r_abs, c_abs in pattern_coords_absolute:\n        pattern_coords_relative.append((r_abs - min_r, c_abs - min_c))\n\n    # Calculate relative center offset of the pattern's bounding box\n    bbox_height = max_r - min_r + 1\n    bbox_width = max_c - min_c + 1\n    center_dr = bbox_height // 2\n    center_dc = bbox_width // 2\n\n    # 4. Identify Marker Color(s) (Color(s) of Smallest Object(s))\n    if not all_objects: # Should be caught earlier, but defensive check\n        min_size = 0\n    else:\n        min_size = min(obj['size'] for obj in all_objects.values())\n        \n    marker_colors = set(obj['color'] for obj in all_objects.values() if obj['size'] == min_size)\n\n    # 5. Find Marker Locations (all pixels with marker colors)\n    marker_locations = []\n    if marker_colors: # Only search if marker colors exist\n        marker_locations = list(zip(*np.where(np.isin(input_grid_np, list(marker_colors)))))\n        # The above is equivalent to:\n        # for r in range(height):\n        #     for c in range(width):\n        #         if input_grid_np[r, c] in marker_colors:\n        #             marker_locations.append((r, c))\n\n    # 6. Initialize Output Grid (as a copy of the input)\n    output_grid = np.copy(input_grid_np)\n\n    # 7. Stamp Pattern Copies onto the Output Grid\n    for marker_r, marker_c in marker_locations:\n        # a. Calculate target top-left for placing the pattern copy\n        target_top_left_r = marker_r - center_dr\n        target_top_left_c = marker_c - center_dc\n\n        # b. Iterate through pattern's relative coordinates\n        for rel_r, rel_c in pattern_coords_relative:\n            # c. Calculate destination coordinate\n            dest_r = target_top_left_r + rel_r\n            dest_c = target_top_left_c + rel_c\n\n            # d. Check bounds\n            if 0 <= dest_r < height and 0 <= dest_c < width:\n                # e. Set pixel color (overwrite)\n                output_grid[dest_r, dest_c] = pattern_color\n\n    # 8. Final Output (convert back to list of lists)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5044,
    "candidates_token_count": 2141,
    "total_token_count": 7185,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.504999
}