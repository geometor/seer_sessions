{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms a grid by identifying strictly hollow rectangular shapes (width > 2, height > 2, 1-pixel border, background interior), \nmodifying their interior based on background color parity, and removing all other non-background shapes.\n\n1.  **Identify Background**: Determine the most frequent color (`background_color`) and its parity (`background_parity`).\n2.  **Initialize Output**: Create an output grid of the same dimensions, filled with `background_color`.\n3.  **Find Connected Components**: Use a connected components search (like BFS) to find groups of connected, non-background pixels of the same color.\n4.  **Filter for Hollow Rectangles**: \n    *   For each component, check if it forms a valid \"hollow rectangle\":\n        *   Must consist of a single color (`rectangle_color`).\n        *   Calculate its bounding box (min/max row/col).\n        *   Bounding box `height` and `width` must both be strictly greater than 2.\n        *   Must form a single-pixel thick rectangular border (check pixel count against expected perimeter).\n        *   The area strictly inside the border must contain only the `background_color` in the input grid.\n    *   Keep only the components that satisfy all these conditions.\n5.  **Draw Borders**: Draw the border pixels of each identified hollow rectangle onto the output grid using its `rectangle_color`.\n6.  **Apply Midline Pattern**: For each identified hollow rectangle:\n    *   Calculate the row index of the horizontal midline of its *internal* area.\n    *   Identify the column indices corresponding to the *internal* area.\n    *   Iterate through these internal columns. If a column index's parity is **different** from the `background_parity` (`col % 2 != background_parity`), color the corresponding pixel on the midline row in the output grid with the `rectangle_color`.\n7.  **Return**: The modified output grid. All shapes not identified as hollow rectangles are effectively removed as they are not drawn onto the background-filled output grid.\n\"\"\"\n\ndef _get_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle potential ties by picking the most frequent; ARC usually has clear background\n    if not counts:\n        return 0 # Default to white if grid is empty\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _find_connected_components(grid: np.ndarray, background_color: int) -> list:\n    \"\"\"\n    Finds connected components of non-background colors using BFS.\n    Returns a list of components, where each component is a dict \n    containing {\"color\": color_value, \"coords\": list_of_tuples}.\n    Uses 4-way connectivity (up, down, left, right) for defining components.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new component\n                component_color = grid[r, c]\n                component_coords = []\n                queue = [(r, c)]\n                visited[r, c] = True\n\n                while queue:\n                    curr_r, curr_c = queue.pop(0)\n                    component_coords.append((curr_r, curr_c))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == component_color:\n                            visited[nr, nc] = True\n                            queue.append((nr, nc))\n                \n                if component_coords:\n                     components.append({\"color\": component_color, \"coords\": component_coords})\n\n    return components\n\n\ndef _is_strict_hollow_rectangle(grid: np.ndarray, component_coords: list, background_color: int) -> tuple:\n    \"\"\"\n    Checks if a component defined by coords is a STRICT hollow rectangle.\n    STRICT means: 1-pixel border, height > 2, width > 2, interior is background.\n    Returns (is_valid, rect_color, bounding_box)\n    \"\"\"\n    if not component_coords:\n        return False, -1, None\n\n    rows, cols = zip(*component_coords)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    # Get the color from the first coordinate (all should be the same)\n    rect_color = grid[component_coords[0]]\n\n    # 1. CRITICAL CHECK: Must have height > 2 AND width > 2 to have an interior\n    if not (height > 2 and width > 2):\n        return False, -1, None\n\n    # 2. Check if all component pixels lie on the bounding box edges\n    on_border = True\n    for r, c in component_coords:\n        if not (r == min_r or r == max_r or c == min_c or c == max_c):\n            on_border = False\n            break\n    if not on_border:\n        return False, -1, None\n        \n    # 3. Check if the number of pixels matches the perimeter for single thickness\n    # Perimeter = 2 * (height + width - 2) for rectangles with H>1, W>1\n    expected_perimeter_pixels = 2 * (height + width - 2)\n    if len(component_coords) != expected_perimeter_pixels :\n         return False, -1, None\n\n    # 4. Check internal area for background color\n    # This slice is guaranteed to exist because height > 2 and width > 2\n    internal_slice = grid[min_r + 1:max_r, min_c + 1:max_c]\n    if not np.all(internal_slice == background_color):\n        return False, -1, None\n            \n    # If all checks pass\n    bounding_box = (min_r, min_c, max_r, max_c)\n    return True, rect_color, bounding_box\n\n\ndef transform(input_grid: list) -> list:\n    \"\"\"\n    Applies the transformation: finds STRICT hollow rectangles, copies their borders,\n    draws a pattern on the internal midline based on the opposite of the background parity, \n    and removes all other shapes.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n\n    # 1. Identify Background Color and Parity\n    background_color = _get_background_color(input_array)\n    background_parity = background_color % 2 # 0 for even, 1 for odd\n\n    # 2. Initialize Output Grid - CRITICAL: Start with clean background\n    output_grid = np.full_like(input_array, background_color)\n\n    # 3. Find Connected Components (potential shapes)\n    components = _find_connected_components(input_array, background_color)\n\n    # Store valid hollow rectangles found\n    hollow_rectangles = [] \n    \n    # 4. Validate each component to find STRICT hollow rectangles\n    for component in components:\n        coords = component[\"coords\"]\n        is_valid, rect_color, bbox = _is_strict_hollow_rectangle(\n            input_array, \n            coords, \n            background_color\n        )\n        \n        if is_valid:\n            hollow_rectangles.append({\n                \"color\": rect_color,\n                \"coords\": coords,\n                \"bbox\": bbox # (min_r, min_c, max_r, max_c)\n            })\n\n    # 5. Draw Rectangle Borders onto Output\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        for r, c in rect[\"coords\"]:\n            # Basic bounds check (should always be true if coords are from grid)\n            if 0 <= r < height and 0 <= c < width:\n                output_grid[r, c] = rect_color\n\n    # 6. Apply Midline Pattern to the identified hollow rectangles\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        min_r, min_c, max_r, max_c = rect[\"bbox\"]\n        \n        # Calculate internal dimensions (guaranteed > 0 due to validation)\n        internal_height = max_r - min_r - 1\n        internal_width = max_c - min_c - 1\n\n        # Calculate midline row index relative to the top of the grid\n        # Add min_r + 1 (start of internal area) to the relative midline index\n        midline_row = min_r + 1 + (internal_height // 2) \n\n        # Iterate through internal column indices\n        start_col = min_c + 1\n        end_col = max_c # The range stops *before* end_col, corresponding to max_c - 1\n\n        for col in range(start_col, end_col):\n            # *** CORRECTED LOGIC ***\n            # Check if column index parity is DIFFERENT from background parity\n            if col % 2 != background_parity: \n                # Check bounds just in case (should be within grid)\n                if 0 <= midline_row < height and 0 <= col < width:\n                     # Since output_grid was initialized with background, we can directly color\n                     output_grid[midline_row, col] = rect_color\n\n    # 7. Return Output as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13079,
    "candidates_token_count": 2388,
    "total_token_count": 15467,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 147.264855
}