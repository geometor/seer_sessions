{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Identify Background:** Determine the most frequent color in the input grid (`background_color`) and its parity (`background_parity`).\n2.  **Initialize Output:** Create an output grid of the same dimensions as the input, filled with the `background_color`.\n3.  **Find Hollow Rectangles:**\n    *   Locate connected components (objects) of non-background colors.\n    *   Filter these components to find valid \"hollow rectangles\":\n        *   Must consist of a single color (`rectangle_color`).\n        *   Must form a single-pixel thick rectangular border.\n        *   The area strictly inside the border must contain only the `background_color` in the input grid.\n4.  **Draw Borders:** Draw the border pixels of each identified hollow rectangle onto the output grid using its `rectangle_color`.\n5.  **Apply Midline Pattern:** For each hollow rectangle:\n    *   Calculate the row index of the horizontal midline of its *internal* area.\n    *   Identify the column indices corresponding to the internal area.\n    *   Iterate through these internal columns on the midline row. If a column index's parity matches the `background_parity`, color the corresponding pixel in the output grid with the `rectangle_color`.\n6.  **Return:** The modified output grid.\n\"\"\"\n\ndef _get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle potential ties, though ARC tasks usually have a clear background\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _is_valid_hollow_rectangle(grid, coords, background_color):\n    \"\"\"\n    Checks if a component defined by coords is a hollow rectangle.\n    Returns (is_valid, rect_color, bounding_box)\n    \"\"\"\n    if not coords:\n        return False, -1, None\n\n    rows, cols = zip(*coords)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    # Check if component pixels form a single rectangle border\n    \n    # 1. Check for single color\n    first_pixel_color = grid[coords[0]]\n    if not all(grid[r, c] == first_pixel_color for r, c in coords):\n        return False, -1, None\n    rect_color = first_pixel_color\n\n    # 2. Check if all component pixels lie on the bounding box edges\n    on_border = True\n    for r, c in coords:\n        if not (r == min_r or r == max_r or c == min_c or c == max_c):\n            on_border = False\n            break\n    if not on_border:\n        return False, -1, None\n        \n    # 3. Check if the number of pixels matches the perimeter of the bounding box\n    #    This helps ensure single thickness and no gaps (though connectivity check helps)\n    #    Perimeter = 2 * (height + width - 2) handles corners correctly for thickness 1\n    expected_perimeter_pixels = 2 * (height + width - 2) if height > 1 and width > 1 else max(height, width) # Handle lines\n    if len(coords) != expected_perimeter_pixels :\n         # Allow simple lines as degenerate rectangles for robustness, though not seen in train\n         is_line = (height == 1 and len(coords) == width) or (width == 1 and len(coords) == height)\n         if not is_line:\n             #print(f\"Perimeter mismatch: expected {expected_perimeter_pixels}, got {len(coords)} for {min_r, min_c, max_r, max_c}\")\n             return False, -1, None\n\n    # 4. Check internal area (if it exists) for background color\n    if height > 2 and width > 2:\n        internal_area = grid[min_r + 1:max_r, min_c + 1:max_c]\n        if not np.all(internal_area == background_color):\n            return False, -1, None\n            \n    # If all checks pass\n    bounding_box = (min_r, min_c, max_r, max_c)\n    return True, rect_color, bounding_box\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify Background\n    background_color = _get_background_color(input_grid)\n    background_parity = background_color % 2 # 0 for even, 1 for odd\n\n    # 2. Initialize Output\n    output_grid = np.full_like(input_grid, background_color)\n\n    # 3. Find Hollow Rectangles\n    \n    # Create a mask of non-background pixels\n    non_background_mask = (input_grid != background_color)\n    \n    # Label connected components of non-background pixels\n    labeled_array, num_features = label(non_background_mask)\n    \n    hollow_rectangles = [] # Store tuples: (rect_color, border_coords, bounding_box)\n    \n    # Find object slices and iterate\n    object_slices = find_objects(labeled_array)\n    for i in range(num_features):\n        obj_label = i + 1\n        slices = object_slices[i]\n        # Extract coordinates of the current component\n        component_coords_relative = np.argwhere(labeled_array[slices] == obj_label)\n        component_coords_absolute = [\n            (r + slices[0].start, c + slices[1].start) \n            for r, c in component_coords_relative\n        ]\n\n        # Check if this component is a valid hollow rectangle\n        is_valid, rect_color, bbox = _is_valid_hollow_rectangle(\n            input_grid, \n            component_coords_absolute, \n            background_color\n        )\n        \n        if is_valid:\n            hollow_rectangles.append({\n                \"color\": rect_color,\n                \"coords\": component_coords_absolute,\n                \"bbox\": bbox # (min_r, min_c, max_r, max_c)\n            })\n\n    # 4. Draw Rectangle Borders\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        for r, c in rect[\"coords\"]:\n            if 0 <= r < height and 0 <= c < width:\n                output_grid[r, c] = rect_color\n\n    # 5. Apply Midline Pattern\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        min_r, min_c, max_r, max_c = rect[\"bbox\"]\n        \n        # Calculate internal dimensions\n        internal_height = max_r - min_r - 1\n        internal_width = max_c - min_c - 1\n\n        # Proceed only if there is an internal area\n        if internal_height > 0 and internal_width > 0:\n            # Calculate midline row index (assuming odd internal height based on examples)\n            # If internal_height is even, this picks the upper of the two middle rows.\n            midline_row = min_r + 1 + (internal_height // 2) \n\n            # Iterate through internal column indices\n            start_col = min_c + 1\n            end_col = max_c # Exclusive in range, so use max_c\n            \n            for col in range(start_col, end_col):\n                # Check if column index parity matches background parity\n                if col % 2 == background_parity:\n                    # Check bounds just in case, although should be within grid\n                    if 0 <= midline_row < height and 0 <= col < width:\n                         # Ensure we are coloring a background pixel (originally)\n                         # This check might be redundant if _is_valid_hollow_rectangle is perfect\n                        if output_grid[midline_row, col] == background_color:\n                            output_grid[midline_row, col] = rect_color\n\n    # 6. Return Output\n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8621,
    "candidates_token_count": 2021,
    "total_token_count": 10642,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 90.005051
}