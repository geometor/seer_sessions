{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color, connect_diagonal=True):\n    \"\"\"Finds contiguous objects of a specific color in the grid.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (4-way or 8-way)\n                    for dr in range(-1, 2):\n                        for dc in range(-1, 2):\n                            if dr == 0 and dc == 0:\n                                continue\n                            if not connect_diagonal and abs(dr) + abs(dc) > 1:\n                                continue\n                                \n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the min/max row/col for a set of coordinates.\"\"\"\n    if not coords:\n        return 0, 0, 0, 0\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef classify_gray_shape(obj_coords):\n    \"\"\"\n    Classifies a gray object (set of coordinates) as 'L', 'Z', or 'Other'.\n    Assumes canonical shapes have 3 pixels.\n    L-shape example: {(0,0), (1,0), (0,1)}\n    Z-shape example: {(0,1), (1,0), (1,1)}\n    Checks relative positions, allowing for rotation/reflection.\n    \"\"\"\n    if len(obj_coords) != 3:\n        return 'Other'\n\n    coords = list(obj_coords)\n    r_min, c_min, r_max, c_max = get_bounding_box(obj_coords)\n\n    # Both L and Z shapes fit within a 2x2 bounding box if canonical\n    if r_max - r_min != 1 or c_max - c_min != 1:\n        return 'Other' # Not confined to 2x2\n\n    # Check for the 'missing' corner within the 2x2 box\n    corners = {(r_min, c_min), (r_min, c_max), (r_max, c_min), (r_max, c_max)}\n    missing_corner = corners - obj_coords\n    \n    if len(missing_corner) != 1:\n        # This shouldn't happen if len=3 and fits 2x2, but defensively check\n        return 'Other' \n        \n    missing_r, missing_c = list(missing_corner)[0]\n\n    # Check relative positions of the 3 present pixels\n    # L-shape: The missing corner shares row or col with 2 of the 3 pixels\n    # Z-shape: The missing corner shares row or col with only 1 of the 3 pixels (the diagonal one)\n    shared_row_col_count = 0\n    for r, c in obj_coords:\n        if r == missing_r or c == missing_c:\n            shared_row_col_count += 1\n            \n    if shared_row_col_count == 2:\n         return 'L'\n    elif shared_row_col_count == 1:\n         return 'Z'\n    else:\n         # Should ideally not be reached if logic above is correct\n         return 'Other'\n\n\ndef check_pattern_C_over_CCC(obj_coords, grid):\n    \"\"\"Checks if an object matches the C / CCC pattern. \n       Pattern: {(r,c), (r+1,c-1), (r+1,c), (r+1,c+1)} - Needs adjustment based on example 1.\n       Example 1 Red pattern: {(r,c), (r+1,c), (r+1,c+1), (r+1,c+2)} -> C / CCC\n       Let's use the example 1 form: 1 pixel at (r, c) and 3 pixels at (r+1, c), (r+1, c+1), (r+1, c+2)\n       \n       Wait, the actual red shape in train_1 is:\n       2\n       2 2 2\n       Represented as {(r, c), (r+1, c), (r+1, c-1), (r+1, c+1)} if centered on the '2' at (r+1,c)\n       Or: {(r, c+1), (r+1, c), (r+1, c+1), (r+1, c+2)} if top-left is (r, c+1)\n       Let's check for a 4-pixel object with shape:\n       . C .\n       C C C\n    \"\"\"\n    if len(obj_coords) != 4:\n        return False\n    \n    r_min, c_min, r_max, c_max = get_bounding_box(obj_coords)\n    \n    if r_max - r_min != 1 or c_max - c_min != 2:\n        return False # Doesn't fit 2x3 bounding box needed for .C./CCC\n\n    # Check if pixels match the relative pattern\n    # Assume top-left of the 2x3 box is (r_min, c_min)\n    expected_coords = {\n        (r_min, c_min + 1), \n        (r_max, c_min), \n        (r_max, c_min + 1), \n        (r_max, c_min + 2)\n    }\n    return obj_coords == expected_coords\n\n\ndef check_pattern_CCC_C0C_CCC(obj_coords, grid):\n    \"\"\"Checks if an object matches the CCC / C0C / CCC pattern.\"\"\"\n    if len(obj_coords) != 8:\n        return False\n        \n    r_min, c_min, r_max, c_max = get_bounding_box(obj_coords)\n\n    if r_max - r_min != 2 or c_max - c_min != 2:\n        return False # Doesn't fit 3x3 bounding box\n\n    # Check for the missing center pixel\n    center_coord = (r_min + 1, c_min + 1)\n    if center_coord in obj_coords:\n        return False\n\n    # Check if all other pixels within the 3x3 box are present\n    all_box_coords = set()\n    for r in range(r_min, r_max + 1):\n        for c in range(c_min, c_max + 1):\n            all_box_coords.add((r, c))\n            \n    expected_coords = all_box_coords - {center_coord}\n    return obj_coords == expected_coords\n    \ndef get_stack_height(objects, grid):\n    \"\"\" Calculates the max height of vertically stacked C-patterns \"\"\"\n    if not objects:\n        return 0\n        \n    # Check if objects are C-patterns and get their top-left corners\n    c_patterns = []\n    for obj in objects:\n         if check_pattern_CCC_C0C_CCC(obj, grid):\n             r_min, c_min, _, _ = get_bounding_box(obj)\n             c_patterns.append((r_min, c_min))\n             \n    if not c_patterns:\n         return 0\n\n    # Sort by column then row to group potential stacks\n    c_patterns.sort(key=lambda x: (x[1], x[0]))\n    \n    max_height = 0\n    current_stack_height = 0\n    last_r, last_c = -10, -10 # Initialize far off\n\n    for r_min, c_min in c_patterns:\n        # Check if current pattern continues the stack (same column, 3 rows below)\n        if c_min == last_c and r_min == last_r + 3:\n             current_stack_height += 3 # Add height of one pattern\n        else:\n             # Start a new stack\n             max_height = max(max_height, current_stack_height + 3 if current_stack_height > 0 else 3) # Add last pattern height or start with 3\n             current_stack_height = 0 # Reset for new stack\n        \n        last_r, last_c = r_min, c_min\n        \n    # Check height of the very last stack\n    max_height = max(max_height, current_stack_height + 3 if current_stack_height >=0 else 0)\n\n    # The height is number of rows spanned, not number of patterns\n    return max_height\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the type of gray shapes present.\n    Case 1 (L-shape only): Find color C matching 'C/CCC' pattern, output fixed 3x6 border shape.\n    Case 2 (Z-shape only): Find color C matching 'CCC/C0C/CCC' (tallest stack), repeat C-pattern vertically based on max gray row index.\n    Case 3 (Both L & Z): Extract two central columns from the main pattern area.\n    \"\"\"\n    \n    height, width = input_grid.shape\n    gray_objects = find_objects(input_grid, 5)\n    \n    count_L = 0\n    count_Z = 0\n    max_gray_r = -1\n\n    if not gray_objects:\n         # Handle cases with no gray pixels if necessary, maybe return input or error\n         # Based on examples, assume gray objects are always present.\n         print(\"Warning: No gray objects found.\")\n         # Let's proceed assuming counts remain 0, might hit default case or error later.\n         pass\n         \n    for obj in gray_objects:\n        shape_type = classify_gray_shape(obj)\n        if shape_type == 'L':\n            count_L += 1\n        elif shape_type == 'Z':\n            count_Z += 1\n        \n        # Find max row index for case 2\n        for r, c in obj:\n            max_gray_r = max(max_gray_r, r)\n\n    # Determine case\n    case = None\n    if count_L > 0 and count_Z == 0:\n        case = 'L_only'\n    elif count_L == 0 and count_Z > 0:\n        case = 'Z_only'\n    elif count_L > 0 and count_Z > 0:\n        case = 'Both'\n    else:\n        # No L or Z shapes found (or no gray objects at all)\n        # Undefined behavior based on examples, maybe return input or empty grid?\n        print(\"Error: Neither L nor Z gray shapes identified.\")\n        return np.zeros((1, 1), dtype=int) # Return minimal grid\n\n\n    # --- Case 1: L-shape only ---\n    if case == 'L_only':\n        target_color = -1\n        colors_to_check = [c for c in np.unique(input_grid) if c not in [0, 5]] # Non-white, non-gray\n        \n        for color in colors_to_check:\n            color_objects = find_objects(input_grid, color)\n            found_pattern = False\n            if not color_objects: continue # Skip if no objects of this color\n            \n            # Check if *any* object of this color matches the pattern\n            # The description implies exclusivity, but let's try finding the first match\n            for obj in color_objects:\n                if check_pattern_C_over_CCC(obj, input_grid):\n                    found_pattern = True\n                    break # Found one, assume this is the color\n            \n            if found_pattern:\n                 # Simple assumption: first color found with the pattern is the one.\n                 # Refinement might be needed if multiple colors have this pattern.\n                 target_color = color\n                 break\n                 \n        if target_color == -1:\n             print(\"Error (Case L): Could not find color with C/CCC pattern.\")\n             return np.zeros((1, 1), dtype=int)\n\n        # Construct 3x6 output\n        output_grid = np.zeros((3, 6), dtype=int)\n        output_grid[0, :] = target_color  # Top row\n        output_grid[2, :] = target_color  # Bottom row\n        output_grid[1, 0] = target_color  # Middle row, left edge\n        output_grid[1, 5] = target_color  # Middle row, right edge\n        # Inner part remains 0 (white)\n        \n        return output_grid\n\n    # --- Case 2: Z-shape only ---\n    elif case == 'Z_only':\n        candidate_colors = {} # color -> max_stack_height\n        colors_to_check = [c for c in np.unique(input_grid) if c not in [0, 5]]\n\n        for color in colors_to_check:\n            color_objects = find_objects(input_grid, color)\n            is_c_pattern_color = False\n            # Check if any object is a C-pattern\n            for obj in color_objects:\n                 if check_pattern_CCC_C0C_CCC(obj, input_grid):\n                     is_c_pattern_color = True\n                     break\n            if is_c_pattern_color:\n                 # Calculate stack height for this color\n                 stack_height = get_stack_height(color_objects, input_grid)\n                 candidate_colors[color] = stack_height\n        \n        if not candidate_colors:\n             print(\"Error (Case Z): Could not find color with CCC/C0C/CCC pattern.\")\n             return np.zeros((1, 1), dtype=int)\n\n        # Select color with the maximum stack height\n        selected_color = max(candidate_colors, key=candidate_colors.get)\n        \n        output_height = max_gray_r + 1 # Height is max_row_index + 1\n        output_width = 3\n        output_grid = np.zeros((output_height, output_width), dtype=int)\n\n        # Define the 3x3 C-pattern\n        pattern_C = np.array([\n            [selected_color, selected_color, selected_color],\n            [selected_color, 0,              selected_color],\n            [selected_color, selected_color, selected_color]\n        ])\n\n        # Fill the output grid by repeating the pattern rows\n        for r in range(output_height):\n            output_grid[r, :] = pattern_C[r % 3, :]\n            \n        return output_grid\n\n    # --- Case 3: Both L and Z shapes ---\n    elif case == 'Both':\n         # Find bounding box of non-white, non-gray pixels\n         non_bg_gray_coords = []\n         for r in range(height):\n             for c in range(width):\n                 if input_grid[r, c] != 0 and input_grid[r, c] != 5:\n                     non_bg_gray_coords.append((r, c))\n                     \n         if not non_bg_gray_coords:\n             print(\"Error (Case Both): No non-white, non-gray pixels found.\")\n             return np.zeros((1,1), dtype=int)\n             \n         r_min, c_min, r_max, c_max = get_bounding_box(non_bg_gray_coords)\n         \n         # Calculate center columns\n         # Using floor division for index calculation\n         c_left_center = c_min + (c_max - c_min) // 2 \n         tc1 = c_left_center - 1\n         tc2 = c_left_center\n         \n         # Check if calculated columns are valid\n         if tc1 < 0 or tc2 >= width:\n              print(f\"Error (Case Both): Calculated columns {tc1}, {tc2} out of bounds.\")\n              return np.zeros((1,1), dtype=int)\n\n         # Find vertical range (r_start, r_end) within these two columns\n         r_start = -1\n         r_end = -1\n         for r in range(height):\n              if input_grid[r, tc1] != 0 or input_grid[r, tc2] != 0:\n                   if r_start == -1:\n                       r_start = r\n                   r_end = r\n                   \n         if r_start == -1:\n              print(f\"Error (Case Both): No non-white pixels found in columns {tc1}, {tc2}.\")\n              # Example 2 has white space at top/bottom, so maybe extract full columns?\n              # Let's stick to the derived rule for now.\n              return np.zeros((1,1), dtype=int)\n\n         # Extract the subgrid\n         output_grid = input_grid[r_start : r_end + 1, tc1 : tc2 + 1]\n         \n         return output_grid\n         \n    else: \n        # Should not be reached if initial case check is exhaustive\n        print(\"Error: Unhandled case.\")\n        return np.zeros((1, 1), dtype=int)\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14776,
    "candidates_token_count": 4235,
    "total_token_count": 19011,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.746077
}