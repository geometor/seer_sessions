{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThe transformation rule depends on the specific set of non-white colors present in the input grid. The rules are checked in a specific priority order:\n\n1.  **Magenta/Orange Swap & Flip:** If both Magenta (6) and Orange (7) are present:\n    *   Swap all Magenta pixels to Orange and all Orange pixels to Magenta.\n    *   Horizontally flip the positions of all Red (2) and Yellow (4) pixels relative to the grid's width.\n    *   All other non-white pixels (e.g., Azure 8) become white (0).\n2.  **Yellow/Blue Conversion:** If both Blue (1) and Yellow (4) are present (and rule 1 didn't apply):\n    *   Convert all Yellow (4) pixels to Red (2).\n    *   Convert all Blue (1) pixels to Orange (7).\n    *   Convert Azure (8) pixels based on row: If the row index is less than or equal to the median row index (floor((height - 1) / 2)), convert to Red (2); otherwise, convert to Orange (7).\n    *   All other non-white pixels (e.g., original Red 2, Orange 7) become white (0).\n3.  **Red/Yellow Swap:** If both Red (2) and Yellow (4) are present (and rules 1, 2 didn't apply):\n    *   Swap all Red pixels to Yellow and all Yellow pixels to Red.\n    *   All other non-white pixels become white (0).\n4.  **Blue/Red Swap:** If both Blue (1) and Red (2) are present (and rules 1, 2, 3 didn't apply):\n    *   Swap all Blue pixels to Red and all Red pixels to Blue.\n    *   All other non-white pixels (e.g., Azure 8) become white (0).\n5.  **Default:** If none of the above color combinations trigger a rule, the output grid is entirely white (0).\n\"\"\"\n\ndef get_present_colors(grid_np):\n    \"\"\"Finds the set of unique non-zero colors in a numpy grid.\"\"\"\n    return set(grid_np.flatten()) - {0}\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a transformation rule based on the set of colors present in the input grid.\n    Rules involve color swaps, conditional conversions, and positional flips,\n    prioritized in a specific order.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Initialize output grid with white (0)\n    output_np = np.zeros_like(input_np)\n    \n    # Determine the set of non-white colors present\n    present_colors = get_present_colors(input_np)\n    \n    # Calculate median row index for Rule 2\n    median_row = (height - 1) // 2\n\n    # --- Rule Priority Check ---\n\n    # Rule 1: Magenta(6)/Orange(7) swap + Red(2)/Yellow(4) horizontal flip\n    if {6, 7}.issubset(present_colors):\n        # Create a temporary grid to store flipped Red/Yellow positions\n        flipped_grid = np.zeros_like(input_np)\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 6:\n                    # Swap Magenta to Orange\n                    output_np[r, c] = 7\n                elif pixel == 7:\n                    # Swap Orange to Magenta\n                    output_np[r, c] = 6\n                elif pixel == 2:\n                    # Store Red in horizontally flipped position\n                    flipped_grid[r, width - 1 - c] = 2\n                elif pixel == 4:\n                    # Store Yellow in horizontally flipped position\n                    flipped_grid[r, width - 1 - c] = 4\n                # Other colors (like Azure 8) are ignored, remain 0 in output_np\n        \n        # Merge the flipped Red/Yellow pixels into the output grid\n        # Only update where flipped_grid has a non-zero value\n        output_np[flipped_grid != 0] = flipped_grid[flipped_grid != 0]\n\n    # Rule 2: Yellow(4)->Red(2), Blue(1)->Orange(7), Azure(8) split by median row\n    elif {1, 4}.issubset(present_colors):\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 4:\n                    # Convert Yellow to Red\n                    output_np[r, c] = 2\n                elif pixel == 1:\n                    # Convert Blue to Orange\n                    output_np[r, c] = 7\n                elif pixel == 8:\n                    # Convert Azure based on row position relative to median\n                    if r <= median_row:\n                        output_np[r, c] = 2\n                    else:\n                        output_np[r, c] = 7\n                # Other colors (original Red 2, Orange 7) are ignored, remain 0\n\n    # Rule 3: Red(2)/Yellow(4) swap (Hypothesized based on patterns)\n    elif {2, 4}.issubset(present_colors):\n         for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 2:\n                    # Swap Red to Yellow\n                    output_np[r, c] = 4\n                elif pixel == 4:\n                    # Swap Yellow to Red\n                    output_np[r, c] = 2\n                # Other colors are ignored, remain 0\n\n    # Rule 4: Blue(1)/Red(2) swap\n    elif {1, 2}.issubset(present_colors):\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 1:\n                    # Swap Blue to Red\n                    output_np[r, c] = 2\n                elif pixel == 2:\n                    # Swap Red to Blue\n                    output_np[r, c] = 1\n                # Other colors (like Azure 8) are ignored, remain 0\n\n    # Default: If no rules matched, output_np remains all zeros (white)\n\n    # Convert numpy array back to list of lists for the final output\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4206,
    "candidates_token_count": 1526,
    "total_token_count": 5732,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 183.809049
}