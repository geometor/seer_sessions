{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n\n    1.  Yellow Connection: Horizontally connect pairs of Yellow (4) pixels if the\n        path between them on the same row consists only of White (0) pixels. These\n        newly filled Yellow pixels act as obstacles for the next phase. This process\n        repeats until no more connections can be made.\n\n    2.  Expansion Color Determination:\n        - Identify all non-White, non-Yellow pixels in the original input grid as sources.\n        - Check if the original input contains any Magenta (6) source pixels (`has_magenta_source`).\n        - Check if the original input contains any Orange (7) pixels anywhere (`has_orange_anywhere`).\n        - Create a mapping for expansion colors:\n            - Azure (8) expands as Blue (1) if `has_magenta_source` is true.\n            - Magenta (6) expands as Orange (7) if `has_orange_anywhere` is true.\n            - All other source colors expand as themselves.\n\n    3.  Simultaneous Expansion (BFS):\n        - Start a simultaneous Breadth-First Search (BFS) from all source pixels identified in step 2.\n        - Expansion occurs one step (Manhattan distance) at a time into adjacent cells that were originally White (0) in the input grid.\n        - Expansion is blocked by grid boundaries, any non-White pixel in the original input, and any Yellow pixels filled during the connection phase.\n        - Conflict Resolution: If a White cell is reached by multiple different sources in the same BFS step, the cell remains White (0) and acts as an obstacle for further expansion from any source.\n        - The color used to fill an expanded cell is determined by the expansion color mapping from step 2 based on the color of the originating source pixel.\n\n    4.  Output: The final grid contains the original non-White pixels, the Yellow connections, and the colored expansions.\n    \"\"\"\n\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- 1. Yellow Connection Phase ---\n    made_connection = True\n    while made_connection:\n        made_connection = False\n        for r in range(rows):\n            yellow_indices = [c for c in range(cols) if output_grid[r, c] == 4]\n            if len(yellow_indices) >= 2:\n                for i in range(len(yellow_indices) - 1):\n                    c1 = yellow_indices[i]\n                    c2 = yellow_indices[i+1]\n                    # Check if path between c1 and c2 (exclusive) is all white (0)\n                    can_connect = True\n                    if c2 > c1 + 1: # Only check if there are cells between them\n                        for k in range(c1 + 1, c2):\n                            if output_grid[r, k] != 0:\n                                can_connect = False\n                                break\n                        if can_connect:\n                            # Fill the path with yellow (4)\n                            for k in range(c1 + 1, c2):\n                                if output_grid[r, k] == 0: # Double check, although logic implies it\n                                     output_grid[r, k] = 4\n                                     made_connection = True # Signal that a change occurred\n\n    # --- 2. Expansion Phase Preparation ---\n    sources = []\n    has_magenta_source = False\n    has_orange_anywhere = False\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            if color != 0:\n                if color == 7:\n                    has_orange_anywhere = True\n                if color != 4: # Non-white, non-yellow are potential sources\n                    sources.append(((r, c), color))\n                    if color == 6:\n                        has_magenta_source = True\n\n    expansion_color_map = {}\n    for _, color in sources:\n        if color not in expansion_color_map: # Avoid redundant mapping\n            if color == 8 and has_magenta_source:\n                expansion_color_map[color] = 1\n            elif color == 6 and has_orange_anywhere:\n                expansion_color_map[color] = 7\n            else:\n                expansion_color_map[color] = color\n\n    # --- 3. Simultaneous Expansion Phase (BFS) ---\n    # distance: Stores the step count when a cell is reached. -1 means unreached.\n    # owner: Stores the coordinate tuple (sr, sc) of the source that reached the cell.\n    #        None means unreached/unowned. \"CONTESTED\" means multiple sources reached simultaneously.\n    distance = np.full((rows, cols), -1, dtype=int)\n    owner = np.full((rows, cols), None, dtype=object)\n    queue = deque()\n\n    # Initialize BFS queue and grids with sources\n    for (r, c), color in sources:\n        if output_grid[r,c] != 0: # Check if source wasn't overwritten by yellow (unlikely but safe)\n            distance[r, c] = 0\n            owner[r, c] = (r, c)\n            queue.append(((r, c), 0)) # ((row, col), dist)\n\n    processed_in_step = {} # Store { (r,c): owner_coord } for conflict detection within a step\n\n    current_dist = 0\n    while queue:\n        # Process all nodes at the current distance level first\n        level_size = len(queue)\n        if level_size == 0: break # Should not happen if queue is not empty, but safe check\n\n        newly_reached_this_step = {} # Tracks cells reached in this specific step: {(r,c): owner_coord}\n\n        # Peek distance of the first element to confirm level\n        if queue:\n             _, peek_dist = queue[0]\n             current_dist = peek_dist\n\n        processed_count = 0\n        while queue and queue[0][1] == current_dist:\n             (r, c), dist = queue.popleft()\n             processed_count += 1\n             current_owner_coord = owner[r, c]\n\n             # If the current cell itself became contested earlier in this step, skip its expansion\n             if current_owner_coord == \"CONTESTED\":\n                 continue\n\n             # Explore neighbors\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n\n                 # Check bounds\n                 if 0 <= nr < rows and 0 <= nc < cols:\n                     # Check if neighbor is originally white AND currently unoccupied/uncontested in the output/BFS state\n                     # We only expand into originally white cells that haven't been filled yet by Yellow or previous expansion steps\n                     # And crucially, haven't been reached in *this* step by another source yet.\n                     if input_grid[nr, nc] == 0: # Must be originally white\n                         \n                         existing_owner = owner[nr, nc]\n                         existing_dist = distance[nr, nc]\n\n                         if existing_owner is None: # Unreached before this step\n                             if (nr, nc) not in newly_reached_this_step:\n                                 # First time reached in this step\n                                 newly_reached_this_step[(nr, nc)] = current_owner_coord\n                                 # Don't update distance/owner/queue yet, wait till end of step processing\n                             elif newly_reached_this_step[(nr, nc)] != current_owner_coord:\n                                 # Reached by a *different* source in the *same* step -> CONTESTED\n                                 newly_reached_this_step[(nr, nc)] = \"CONTESTED\"\n\n                         # This handles cases where a cell might be reached again in a later step,\n                         # or by the same owner in the current step (which is fine).\n                         # Conflicts (CONTESTED) are only triggered by different owners in the *same* step.\n\n\n        # End of step processing: Update grids and queue based on newly_reached_this_step\n        for (nr, nc), assigned_owner in newly_reached_this_step.items():\n            if assigned_owner != \"CONTESTED\":\n                 distance[nr, nc] = current_dist + 1\n                 owner[nr, nc] = assigned_owner\n                 queue.append(((nr, nc), current_dist + 1))\n            else:\n                 # Mark as contested permanently in the owner grid\n                 # No need to update distance, as it won't expand further\n                 owner[nr, nc] = \"CONTESTED\"\n                 # Do not add contested cells to the queue\n\n\n    # --- 4. Final Output Construction ---\n    for r in range(rows):\n        for c in range(cols):\n            cell_owner = owner[r, c]\n            # Fill if originally white and owned by a non-contested source\n            if input_grid[r, c] == 0 and isinstance(cell_owner, tuple):\n                sr, sc = cell_owner\n                source_color = input_grid[sr, sc]\n                fill_color = expansion_color_map.get(source_color, source_color) # Use map\n                output_grid[r, c] = fill_color\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7475,
    "candidates_token_count": 2181,
    "total_token_count": 9656,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.349638
}