{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all contiguous objects (non-white pixels, 4-way adjacency).\n2. Identify colors of single-pixel objects as 'ignored colors'.\n3. Filter out objects whose color is ignored. These are 'kept objects'.\n4. Find the largest kept object (by pixel count). This is the 'background object'. Its color is the 'background color'.\n5. Calculate the bounding box of the background object.\n6. Determine the output grid dimensions as twice the height and twice the width of the background object's bounding box.\n7. Create the output grid filled with the background color.\n8. Identify all other kept objects as 'foreground objects'.\n9. Determine the minimal bounding box containing all pixels of all foreground objects ('foreground group bbox').\n10. Copy the pixels of the foreground objects from the input grid into the output grid. The placement logic aims to preserve the relative arrangement of foreground objects. A simple placement strategy is used here: map the top-left corner of the foreground group bbox in the input to the top-left corner (0,0) of the output grid, copying only the foreground pixels within the output grid's bounds.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background (non-white) pixels in the grid using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (a set of (r, c) tuples), 'size',\n              and 'bbox' (min_r, min_c, max_r, max_c).\n              Returns an empty list if the grid is empty or only contains white (0).\n    \"\"\"\n    if grid is None or grid.size == 0:\n        return []\n\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color_val = 0 # Assuming white is the background to ignore during object finding\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is non-white and not visited\n            if grid[r, c] != background_color_val and not visited[r, c]:\n                color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds and if neighbor has the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if current_object_pixels:\n                    objects.append({\n                        'color': color,\n                        'pixels': current_object_pixels,\n                        'size': len(current_object_pixels),\n                        'bbox': (min_r, min_c, max_r, max_c) # top, left, bottom, right\n                    })\n\n    return objects\n\ndef get_bbox_dims(bbox):\n    \"\"\"Calculates height and width from a bbox tuple.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the derived rules.\n    \"\"\"\n    # 1. Identify all non-white objects\n    objects = find_objects(input_grid)\n\n    if not objects:\n        # Handle empty input or input with only background\n        # Return a 1x1 white grid as a default for empty cases\n        return np.array([[0]], dtype=int)\n\n    # 2. Identify ignored colors (from single-pixel objects)\n    ignored_colors = set()\n    for obj in objects:\n        if obj['size'] == 1:\n            ignored_colors.add(obj['color'])\n\n    # 3. Filter kept objects\n    kept_objects = [obj for obj in objects if obj['color'] not in ignored_colors]\n\n    if not kept_objects:\n         # Handle case where all objects are ignored\n         # Return a 1x1 white grid\n         return np.array([[0]], dtype=int)\n\n    # 4. Find background object (largest kept object)\n    background_object = max(kept_objects, key=lambda obj: obj['size'])\n    background_color = background_object['color']\n    bg_bbox = background_object['bbox']\n\n    # 5. Calculate output grid dimensions (double the background object's bbox dims)\n    bg_bbox_h, bg_bbox_w = get_bbox_dims(bg_bbox)\n    output_height = bg_bbox_h * 2\n    output_width = bg_bbox_w * 2\n\n    # 6. Create output grid filled with background color\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    # 7. Identify foreground objects\n    foreground_objects = [obj for obj in kept_objects if obj != background_object]\n\n    if not foreground_objects:\n        # If no foreground objects, return the background-filled grid\n        return output_grid\n\n    # 8. Determine the combined bounding box of all foreground objects\n    all_fg_pixels = set().union(*[obj['pixels'] for obj in foreground_objects])\n    if not all_fg_pixels:\n       # Should not happen if foreground_objects is not empty, but safety check\n       return output_grid\n\n    fg_min_r = min(r for r, c in all_fg_pixels)\n    fg_min_c = min(c for r, c in all_fg_pixels)\n    # max_r and max_c not strictly needed for this placement strategy, but good to have\n    # fg_max_r = max(r for r, c in all_fg_pixels)\n    # fg_max_c = max(c for r, c in all_fg_pixels)\n\n\n    # 9. & 10. Place foreground objects onto the output grid\n    # Placement Strategy: Map the top-left of the foreground group's bbox\n    # (fg_min_r, fg_min_c) to the output grid's origin (0, 0).\n    placement_offset_r = 0 - fg_min_r\n    placement_offset_c = 0 - fg_min_c\n\n    for obj in foreground_objects:\n        obj_color = obj['color']\n        for r, c in obj['pixels']:\n            # Calculate position relative to the output grid's origin\n            out_r = r + placement_offset_r\n            out_c = c + placement_offset_c\n\n            # Place the pixel if it's within the output grid bounds\n            if 0 <= out_r < output_height and 0 <= out_c < output_width:\n                 output_grid[out_r, out_c] = obj_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18140,
    "candidates_token_count": 1836,
    "total_token_count": 19976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 81.007134
}