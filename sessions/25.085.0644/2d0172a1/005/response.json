{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent) and foreground color (second most frequent) in the input grid.\n2. Find all contiguous objects composed of the foreground color pixels (using 8-way connectivity). Note whether each object touches the border of the input grid.\n3. Select the target object:\n    a. Preferentially select objects that *do not* touch the input grid's border.\n    b. Among the preferred (non-border) objects, choose the one with the largest number of pixels.\n    c. If *all* foreground objects touch the border, then select the object with the largest number of pixels among all found objects.\n4. Determine the minimal bounding box enclosing only the pixels of the selected target object.\n5. Create an output grid whose dimensions are 2 larger (in height and width) than the bounding box of the target object.\n6. Initialize the output grid with the background color.\n7. Draw a 1-pixel thick border around the output grid using the foreground color.\n8. Copy only the pixels belonging to the target object into the center of the output grid (inside the border), placed relative to the object's bounding box. The color copied is the foreground color. Pixels within the central area that do not correspond to a pixel from the target object remain the background color.\n\"\"\"\n\ndef find_colors(grid):\n    \"\"\"\n    Finds the background (most frequent) and foreground (typically the second most frequent) colors.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    \n    if len(colors) == 1:\n        return colors[0], None # Only one color present\n    \n    # Sort colors by frequency in descending order\n    sorted_indices = np.argsort(-counts)\n    background_color = colors[sorted_indices[0]]\n    foreground_color = colors[sorted_indices[1]]\n        \n    return background_color, foreground_color\n\ndef find_objects(grid, target_color):\n    \"\"\"\n    Finds all contiguous objects of the target_color using Breadth-First Search (BFS)\n    with 8-way connectivity. Records if an object touches the grid border.\n    Returns a list of objects (dictionaries with pixels, bbox, size, touches_border flag).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if pixel is target color and not visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                current_object_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                touches_border = False # Flag to check if object touches grid edges\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.append((row, col))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check if current pixel is on the border\n                    if row == 0 or row == rows - 1 or col == 0 or col == cols - 1:\n                        touches_border = True\n\n                    # Explore 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor is target color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store the found object's details\n                if current_object_pixels:\n                    objects.append({\n                        'pixels': set(current_object_pixels),\n                        'min_row': min_r, 'max_row': max_r,\n                        'min_col': min_c, 'max_col': max_c,\n                        'size': len(current_object_pixels),\n                        'touches_border': touches_border # Store the border flag\n                    })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Handle empty/invalid input grids\n    if input_np.size == 0: return []\n    if input_np.shape[0] == 0 or input_np.shape[1] == 0: return [[]] \n\n    # 1. Identify Background and Foreground Colors\n    background_color, foreground_color = find_colors(input_np)\n\n    # Handle edge case: Only one color in the grid\n    if foreground_color is None:\n        single_color = background_color\n        # Return a 3x3 grid with the single color as border and center\n        output_grid = np.full((3, 3), single_color, dtype=int)\n        return output_grid.tolist()\n\n    # 2. Find all contiguous objects of the foreground color\n    objects = find_objects(input_np, foreground_color)\n\n    # Handle edge case: No foreground objects found\n    if not objects:\n        # Return a minimal 3x3 grid: foreground border, background center.\n        output_grid = np.full((3, 3), background_color, dtype=int)\n        output_grid[0, :] = foreground_color\n        output_grid[-1, :] = foreground_color\n        output_grid[:, 0] = foreground_color\n        output_grid[:, -1] = foreground_color\n        return output_grid.tolist()\n\n    # 3. Select the target object\n    non_border_objects = [obj for obj in objects if not obj['touches_border']]\n\n    if non_border_objects:\n        # a/b: If non-border objects exist, find the largest among them\n        target_object = max(non_border_objects, key=lambda obj: obj['size'])\n    else:\n        # c: Otherwise (all objects touch border), find the largest object overall\n        target_object = max(objects, key=lambda obj: obj['size'])\n\n    # 4. Determine the bounding box coordinates of the target object\n    min_row, max_row = target_object['min_row'], target_object['max_row']\n    min_col, max_col = target_object['min_col'], target_object['max_col']\n    object_pixels = target_object['pixels'] # Set of (r, c) tuples\n\n    # Calculate bounding box dimensions and output grid dimensions\n    bbox_h = max_row - min_row + 1\n    bbox_w = max_col - min_col + 1\n    output_h = bbox_h + 2 # Add 2 for the border\n    output_w = bbox_w + 2 # Add 2 for the border\n\n    # 5. Create the OutputGrid initialized with the BackgroundColor\n    output_grid = np.full((output_h, output_w), background_color, dtype=int)\n\n    # 6. Draw the 1-pixel border using the ForegroundColor\n    output_grid[0, :] = foreground_color  # Top row\n    output_grid[-1, :] = foreground_color # Bottom row\n    output_grid[:, 0] = foreground_color  # Left column\n    output_grid[:, -1] = foreground_color # Right column\n\n    # 7. Copy the pixels belonging to the target object into the OutputGrid's inner area\n    for r_in, c_in in object_pixels:\n        # Calculate the corresponding position within the output grid's central area\n        # Offset by 1 due to the border\n        r_out = (r_in - min_row) + 1\n        c_out = (c_in - min_col) + 1\n        \n        # Place the foreground color at the calculated position\n        # Basic bounds check (should always be true given calculation)\n        if 1 <= r_out < output_h - 1 and 1 <= c_out < output_w - 1:\n             output_grid[r_out, c_out] = foreground_color\n\n    # Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9406,
    "candidates_token_count": 2047,
    "total_token_count": 11453,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 99.83567
}