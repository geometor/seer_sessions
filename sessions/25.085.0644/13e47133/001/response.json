{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\ndef find_divider_indices(grid, divider_color):\n    \"\"\"Finds the indices of the first complete horizontal and vertical divider lines.\"\"\"\n    rows, cols = grid.shape\n    h_div_idx = None\n    v_div_idx = None\n\n    # Find horizontal divider\n    for r in range(rows):\n        if np.all(grid[r, :] == divider_color):\n            h_div_idx = r\n            break # Assuming only one main horizontal divider relevant for the split\n\n    # Find vertical divider\n    for c in range(cols):\n        if np.all(grid[:, c] == divider_color):\n            v_div_idx = c\n            break # Assuming only one main vertical divider relevant for the split\n\n    return h_div_idx, v_div_idx\n\ndef find_background_color(grid, divider_color):\n    \"\"\"Finds the most frequent color excluding the divider color.\"\"\"\n    pixels = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] != divider_color:\n                pixels.append(grid[r, c])\n    if not pixels:\n        # Handle edge case where grid might only contain dividers or be empty\n        # For ARC, background is typically 0 (black) if nothing else specified, \n        # but here we expect a dominant color. Let's default to 0 if unsure.\n        # Based on examples, a dominant non-divider color always exists.\n        return 0 \n    count = Counter(pixels)\n    # Find the color with the highest count\n    background_color = count.most_common(1)[0][0]\n    return background_color\n\ndef flood_fill(grid, start_r, start_c, fill_color, target_color, divider_color):\n    \"\"\"Performs flood fill on grid, replacing target_color with fill_color.\"\"\"\n    rows, cols = grid.shape\n    if not (0 <= start_r < rows and 0 <= start_c < cols):\n        return # Start point out of bounds\n    if grid[start_r, start_c] != target_color:\n        # Start point isn't the target color (likely already filled or an obstacle)\n        # Or if the start point IS the fill_color already (part of this initiator's fill)\n        # Or if the start point is a divider or another non-background color\n        return\n\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)]) # Keep track to avoid re-processing\n\n    while q:\n        r, c = q.popleft()\n\n        # Check if current cell is valid and is the target color\n        if not (0 <= r < rows and 0 <= c < cols):\n            continue\n        if grid[r, c] != target_color:\n            continue # Hit boundary (divider, other color, already filled by other initiator)\n\n        # Fill the cell\n        grid[r, c] = fill_color\n\n        # Check neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if (0 <= nr < rows and 0 <= nc < cols and \n                (nr, nc) not in visited and \n                grid[nr,nc] == target_color): # Only queue if it's target color\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\ndef check_initiators_in_region(grid, r_start, r_end, c_start, c_end, background_color, divider_color):\n    \"\"\"Checks if any initiator pixels exist within the specified region of the grid.\"\"\"\n    for r in range(r_start, r_end):\n        for c in range(c_start, c_end):\n            if grid[r, c] != background_color and grid[r, c] != divider_color:\n                return True # Found an initiator\n    return False # No initiators found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on flood fills from initiator pixels and a specific reflection rule.\n\n    1. Identifies divider lines (red=2) and the background color (most common non-red color).\n    2. Creates an output grid initialized as a copy of the input.\n    3. Identifies 'initiator' pixels (non-background, non-divider).\n    4. Performs flood fill on the output grid starting from each initiator, replacing background pixels with the initiator's color. Fills stop at dividers, grid edges, and non-background pixels.\n    5. Checks if the bottom-left region in the *input* grid contained any initiators.\n    6. If the input bottom-left region had no initiators, the *processed* top-left region from the output grid is vertically flipped and copied into the bottom-left region of the output grid.\n    \"\"\"\n    \n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n    \n    # --- Step 1: Identify Grid Elements ---\n    divider_color = 2 \n    background_color = find_background_color(input_np, divider_color)\n    h_div, v_div = find_divider_indices(input_np, divider_color)\n\n    # --- Step 3 & 4: Identify Initiators and Perform Flood Fill ---\n    initiators = []\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = input_np[r, c]\n            if pixel_color != background_color and pixel_color != divider_color:\n                initiators.append((r, c, pixel_color))\n\n    # Perform flood fills on the output grid\n    # Note: Since fill only replaces background, order doesn't strictly matter,\n    # but filling from the original input locations onto the output grid is correct.\n    for r_init, c_init, color_init in initiators:\n        # We start the fill from the initiator's position using its color, \n        # targeting the background color in the output grid.\n        # The flood_fill function handles boundaries (edges, dividers, other colors).\n        \n        # Important: Need to check if the start position *in the output grid* \n        # is still background color before starting fill, in case another fill reached it.\n        # However, the logic is simpler: just try to fill from each initiator. \n        # The flood_fill internal check `if grid[start_r, start_c] != target_color:` handles this.\n        \n        # Re-target the original background color for replacement\n        flood_fill(output_np, r_init, c_init, color_init, background_color, divider_color)\n\n\n    # --- Step 5 & 6: Apply Reflection Rule ---\n    # Check only if both horizontal and vertical dividers were found (defines 4 main regions)\n    if h_div is not None and v_div is not None:\n        # Define region boundaries (exclusive end)\n        tl_r_start, tl_r_end = 0, h_div\n        tl_c_start, tl_c_end = 0, v_div\n        \n        bl_r_start, bl_r_end = h_div + 1, rows\n        bl_c_start, bl_c_end = 0, v_div\n\n        # Check the INPUT grid's bottom-left region for initiators\n        bottom_left_has_initiators = check_initiators_in_region(\n            input_np, bl_r_start, bl_r_end, bl_c_start, bl_c_end, background_color, divider_color\n        )\n\n        if not bottom_left_has_initiators:\n            # Extract the processed top-left region from the OUTPUT grid\n            top_left_region = output_np[tl_r_start:tl_r_end, tl_c_start:tl_c_end]\n            \n            # Flip it vertically\n            flipped_tl_region = np.flipud(top_left_region)\n            \n            # Ensure dimensions match before pasting\n            if flipped_tl_region.shape == (bl_r_end - bl_r_start, bl_c_end - bl_c_start):\n                 # Paste the flipped region into the bottom-left of the OUTPUT grid\n                output_np[bl_r_start:bl_r_end, bl_c_start:bl_c_end] = flipped_tl_region\n            # else: handle potential dimension mismatch, though unlikely with simple divider lines\n\n\n    # Convert back to list of lists for the expected output format\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5480,
    "candidates_token_count": 2068,
    "total_token_count": 7548,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.950003
}