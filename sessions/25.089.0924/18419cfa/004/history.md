
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 8 8 0 2 2 0 0 0 8 8 0 0 0 0 0 0
0 8 0 0 2 0 0 0 0 0 8 0 0 0 0 0 0
0 8 8 0 2 2 0 0 0 8 8 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 8 8 0 2 2 2 2 0 8 8 0 0 0 0 0 0
0 8 0 0 2 0 0 2 0 0 8 0 0 0 0 0 0
0 8 8 0 2 2 2 2 0 8 8 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 0 2 0 0 0 0 8 8 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 2 2 0 0 0 0 8 0 0 0 0 8 8 8 0 0
0 0 0 8 8 0 2 0 0 0 0 8 8 0 0 8 8 8 0 8 8 8
0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 8
0 0 0 0 8 8 8 8 8 8 8 8 0 0 0 8 0 2 0 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 2 2 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 0 2 0 0 2 0 8 8 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 2 2 2 2 0 0 8 0 0 0 0 8 8 8 0 0
0 0 0 8 8 0 2 0 0 2 0 8 8 0 0 8 8 8 0 8 8 8
0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 8
0 0 0 0 8 8 8 8 8 8 8 8 0 0 0 8 0 2 0 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 2 2 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 2 2 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 2 0 2 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0
0 0 8 8 8 8 0 8 8 8 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 0 2 2 2 0 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 8 8 8 0 8 8 8 8 0 0 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0
0 0 8 8 8 8 0 8 8 8 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 0 2 2 2 0 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 0 2 2 2 0 0 8 0 0 0 0 0
0 0 8 0 2 0 2 0 2 0 8 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 8 8 8 8 0 8 8 8 8 0 0 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception**

1.  **Grid Structure:** The input and output are 2D grids of pixels with colors represented by integers 0-9. White (0) is the background color.
2.  **Key Colors:** The significant colors involved in the transformation are azure (8) and red (2). White (0) pixels also play a crucial role as the fillable space.
3.  **Objects:** The grids contain distinct objects:
    *   Azure (8) shapes act as boundaries or containers. They appear to form closed loops in all examples.
    *   Red (2) shapes exist *inside* the azure boundaries. These seem to be the starting points or "seeds" for the transformation.
4.  **Transformation:** The core change occurs within the areas enclosed by the azure boundaries. White pixels (0) inside these boundaries are changed to red (2) if they are connected to existing red pixels.
5.  **Mechanism:** The transformation resembles a "flood fill" or "spreading" process. The red color expands from the initial red pixels to fill the adjacent white space, but this expansion is strictly limited by the azure boundary. Pixels outside the azure boundary remain unchanged. Adjacency seems to be cardinal (up, down, left, right), not diagonal.
6.  **Consistency:** The azure boundary itself remains unchanged in all examples. Only the white pixels *inside* the boundary are affected. If there are multiple separate azure boundaries, the fill process happens independently within each one.

**Facts**


```yaml
Objects:
  - Type: Boundary
    Color: Azure (8)
    Role: Defines enclosed regions, remains static.
  - Type: Fill Seed
    Color: Red (2)
    Location: Initially positioned inside the Azure boundaries.
    Role: Starting points for the fill process.
  - Type: Fillable Space
    Color: White (0)
    Location: Inside the Azure boundaries.
    Role: Pixels that can be changed to the fill color.
  - Type: Background
    Color: White (0)
    Location: Outside the Azure boundaries.
    Role: Unaffected by the transformation.

Properties:
  - Azure boundaries are closed loops.
  - Fill operation is constrained within Azure boundaries.
  - Fill propagates cardinally (up, down, left, right).

Actions:
  - Identify: Locate all Azure (8) pixels forming boundaries.
  - Identify: Locate all initial Red (2) pixels within the boundaries.
  - Identify: Locate all White (0) pixels within the boundaries.
  - Fill: Iteratively change White (0) pixels within the boundary to Red (2) if they are cardinally adjacent to an existing Red (2) pixel.
  - Termination: Stop filling when no more White (0) pixels within the boundary are adjacent to Red (2) pixels.

Relationships:
  - Containment: Red pixels and fillable White pixels are contained within the Azure boundaries.
  - Adjacency: The fill propagates based on cardinal adjacency between Red and White pixels inside the boundary.
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all pixels belonging to the azure (8) boundaries.
3.  Identify all regions enclosed by the azure boundaries.
4.  For each enclosed region:
    a.  Identify all initial red (2) pixels within that region. Add their coordinates to a 'current fill set'.
    b.  Create a 'potential fill set' containing the coordinates of all white (0) pixels within that region.
    c.  While the 'current fill set' is not empty:
        i.  Create an empty 'next fill set'.
        ii. For each coordinate (r, c) in the 'current fill set':
            -   Check its four cardinal neighbors (up, down, left, right).
            -   If a neighbor is within the grid boundaries, belongs to the 'potential fill set' (i.e., is a white pixel inside the current enclosed region):
                -   Change the color of the neighbor pixel in the output grid to red (2).
                -   Remove the neighbor's coordinate from the 'potential fill set'.
                -   Add the neighbor's coordinate to the 'next fill set'.
        iii. Replace the 'current fill set' with the 'next fill set'.
5.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule Natural Language Description:

The transformation identifies enclosed regions bounded by azure (8) pixels. 
Within each enclosed region, it performs a flood fill operation starting from any existing red (2) pixels. 
The fill color is red (2), and it propagates cardinally (up, down, left, right) to adjacent white (0) pixels. 
The fill is constrained by the azure (8) boundaries; it does not cross or change the azure pixels. 
Pixels outside the azure boundaries remain unchanged. If an enclosed region contains no initial red pixels, it remains unchanged.
"""

def transform(input_grid):
    """
    Performs a flood fill with red (2) starting from existing red pixels,
    constrained within regions bounded by azure (8) pixels.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # Initialize a queue for Breadth-First Search (BFS) flood fill
    queue = deque()
    # Use a set to keep track of visited white cells to prevent cycles and redundant processing
    visited_white = set()

    # Find initial red pixels and add them to the queue
    # Also, add initial red pixels to visited_white conceptually, 
    # so we don't try to fill them later. More accurately, the fill starts *from* them.
    # The key is to add the *white neighbors* of red pixels to the queue initially.
    
    initial_red_pixels = []
    for r in range(rows):
        for c in range(cols):
            if input_grid[r, c] == 2:
                 initial_red_pixels.append((r,c))

    # Seed the queue with the initial white neighbors of the red pixels
    for r_red, c_red in initial_red_pixels:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Cardinal neighbors
            nr, nc = r_red + dr, c_red + dc
            
            # Check bounds and if the neighbor is white and not visited
            if 0 <= nr < rows and 0 <= nc < cols and \
               input_grid[nr, nc] == 0 and \
               (nr, nc) not in visited_white:
                
                # Add the white neighbor to the queue and mark as visited
                visited_white.add((nr, nc))
                queue.append((nr, nc))
                # Immediately color this neighbor red in the output
                output_grid[nr, nc] = 2


    # Perform the flood fill using BFS
    while queue:
        r, c = queue.popleft()

        # Current pixel (r, c) is already colored red in output_grid
        # Explore its cardinal neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is an originally white pixel (color 0 in input_grid)
                # and has not been visited/added to the queue yet
                if input_grid[nr, nc] == 0 and (nr, nc) not in visited_white:
                    # Mark the neighbor as visited
                    visited_white.add((nr, nc))
                    # Change the neighbor's color to red in the output grid
                    output_grid[nr, nc] = 2
                    # Add the neighbor to the queue to explore from it later
                    queue.append((nr, nc))

    # Return the modified grid
    return output_grid
```
```python
"""
Transformation Rule Natural Language Description:

The transformation identifies regions enclosed by azure (8) pixels. 
First, it determines which white (0) pixels are 'inside' these regions by performing a flood fill from the grid borders; any white pixel *not* reached by this initial fill is considered 'inside'.
Then, within each enclosed region ('inside' area), it performs a separate flood fill operation starting from any existing red (2) pixels found within that specific 'inside' area. 
The fill color is red (2), and it propagates cardinally (up, down, left, right) only to adjacent 'inside' white (0) pixels. 
The fill is constrained by the azure (8) boundaries and does not spread to 'outside' white pixels or other non-white pixels. Pixels outside the azure boundaries and 'inside' white pixels not reachable from a red seed remain unchanged. Azure (8) pixels themselves remain unchanged.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Performs a constrained flood fill with red (2) starting from existing red pixels,
    limited to white (0) pixels located inside regions bounded by azure (8) pixels.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Identify 'inside' white pixels
    # Initialize a boolean grid to track if a white pixel is inside (True) or outside (False)
    # Initially assume all are potentially inside, except non-white pixels.
    is_inside = (input_grid == 0)
    outside_queue = deque()

    # Add all border white pixels to the queue and mark them as outside
    for r in range(rows):
        for c in [0, cols - 1]: # Left and right borders
            if is_inside[r, c]:
                is_inside[r, c] = False
                outside_queue.append((r, c))
        # Avoid double-adding corners
        if r == 0 or r == rows - 1:
            for c in range(1, cols - 1): # Top and bottom borders (excluding corners)
                 if is_inside[r, c]:
                    is_inside[r, c] = False
                    outside_queue.append((r, c))

    # Perform BFS to find all white pixels reachable from the outside
    while outside_queue:
        r, c = outside_queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            # Check bounds and if the neighbor is white and still marked as 'inside'
            if 0 <= nr < rows and 0 <= nc < cols and is_inside[nr, nc]:
                is_inside[nr, nc] = False # Mark as outside
                outside_queue.append((nr, nc))

    # 2. Perform constrained red flood fill
    red_fill_queue = deque()
    visited_red_fill = set() # Keep track of visited cells for *this* fill

    # Seed the queue with initial red pixels
    for r in range(rows):
        for c in range(cols):
            if input_grid[r, c] == 2:
                # Only add valid starting points (should inherently be inside, but good practice)
                if 0 <= r < rows and 0 <= c < cols: # Basic bounds check
                   red_fill_queue.append((r,c))
                   visited_red_fill.add((r,c))
                   # No need to change output_grid color here, it's already red

    # Perform BFS for the red fill, constrained to 'inside' white pixels
    while red_fill_queue:
        r, c = red_fill_queue.popleft()

        # Explore cardinal neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check conditions for filling the neighbor:
            # 1. Within grid bounds
            # 2. Not already visited in *this* red fill
            # 3. Is an 'inside' white pixel (input was 0 and is_inside is True)
            if (0 <= nr < rows and 0 <= nc < cols and
                    (nr, nc) not in visited_red_fill and
                    input_grid[nr, nc] == 0 and
                    is_inside[nr, nc]):

                # Conditions met: fill the pixel
                output_grid[nr, nc] = 2
                visited_red_fill.add((nr, nc))
                red_fill_queue.append((nr, nc))

    # Return the modified grid
    return output_grid
```
