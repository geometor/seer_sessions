
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 0 0
0 4 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 0 0
0 4 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 8 0 0 3 0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 8 0 0 3 0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 8 8 8 0 0 3 3 3 0 0 0 8 8 8 0 0
0 0 2 0 0 0 0 8 0 0 0 0 3 0 0 0 0 0 8 0 0 0
0 2 2 2 0 0 8 8 8 0 0 3 3 3 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 0 0 2 0 2 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 0 0 0 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0 0
0 0 8 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0 0
0 0 3 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 0 0 2 0 2 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:**
    *   The input grids contain a background (white), one larger contiguous shape made of red pixels (the 'template'), and several isolated single pixels of various non-white, non-red colors (or sometimes red, if isolated) - these are the 'markers'.
    *   The output grid retains all elements from the input grid.
    *   Additionally, the output grid contains multiple copies of the red 'template' shape.
    *   Each copy is recolored to match the color of one of the 'marker' pixels from the input.
    *   The position of each recolored copy is determined by the position of its corresponding marker pixel, but with an offset applied.
    *   This offset changes progressively for each marker, following an arithmetic progression. The progression (which coordinate changes and by how much) seems specific to the task instance but consistent within it. The markers are processed in a specific order (top-to-bottom, then left-to-right).

*   **Facts:**
    
```yaml
    elements:
      - object: grid
        description: A 2D array of pixels with colors 0-9.
      - object: background
        color: white (0)
        description: The predominant color in the grid.
      - object: template_shape
        color: red (2)
        property: contiguous
        property: largest red shape in the input grid
        description: A specific shape made of red pixels that serves as a pattern.
      - object: marker_pixel
        color: any non-white color (1-9)
        property: isolated (single pixel)
        property: not part of the template_shape
        description: Single pixels whose color and position dictate the creation of new shapes.
        relationship: Each marker corresponds to one new shape in the output.
      - object: copied_shape
        description: A shape identical in form to the template_shape but potentially different in color and position.
        color: Same as the corresponding marker_pixel.
        position: Determined by the corresponding marker_pixel's position plus a calculated offset.

    actions:
      - action: identify
        target: template_shape
        details: Find the largest contiguous block of red pixels. Record its shape relative to its top-left corner.
      - action: identify
        target: marker_pixels
        details: Find all single non-white pixels not belonging to the template_shape. Record their color and position.
      - action: order
        target: marker_pixels
        details: Sort marker pixels first by row index, then by column index.
      - action: calculate_offset_progression
        details:
          - Use the positions of the first two ordered markers (m1, m2) and the top-left positions of their corresponding output copies (c1_tl, c2_tl).
          - Calculate the base offset for the first marker: base_delta = c1_tl - m1.
          - Calculate the offset for the second marker: delta2 = c2_tl - m2.
          - Calculate the step change: step = delta2 - base_delta.
      - action: generate_copies
        details:
          - Initialize the output grid as a copy of the input grid.
          - For each marker pixel 'm_i' at index 'i' (starting from 1) with color 'C' and position 'pos_mi':
            - Calculate the offset for this marker: current_delta = base_delta + (i - 1) * step.
            - Calculate the target top-left position for the copy: target_tl = pos_mi + current_delta.
            - Create a copy of the template_shape.
            - Recolor the copy with color 'C'.
            - Place the recolored copy onto the output grid with its top-left corner at target_tl.

    relationships:
      - The number of marker_pixels equals the number of new copied_shapes added to the output.
      - The color of a copied_shape is determined by the color of its corresponding marker_pixel.
      - The position of a copied_shape is determined by the position of its corresponding marker_pixel and its order in the sorted list, applying a progressive offset derived from the first two markers/copies.
    ```


*   **Natural Language Program:**
    1.  Make a copy of the input grid to serve as the initial output grid.
    2.  Identify the 'template' shape: Find the largest connected component of red (2) pixels in the input grid. Determine the relative coordinates of all pixels belonging to this shape with respect to its top-left bounding box corner.
    3.  Identify the 'marker' pixels: Find all non-white pixels in the input grid that are *not* part of the identified template shape and are isolated (have no adjacent neighbors of the same color, excluding diagonals). Record the color and position (row, column) of each marker pixel.
    4.  Order the marker pixels: Create a list of the identified marker pixels, sorted first by row index (ascending) and then by column index (ascending).
    5.  If there are fewer than two marker pixels, stop (or handle based on expected behavior, though examples suggest at least two).
    6.  Determine the placement rule:
        a.  Take the first marker pixel (`m1`) from the ordered list and find the top-left position (`c1_tl`) of the corresponding colored copy of the template shape in the *example output grid*. Calculate the base offset: `base_delta = (c1_tl.row - m1.row, c1_tl.col - m1.col)`.
        b.  Take the second marker pixel (`m2`) from the ordered list and find the top-left position (`c2_tl`) of its corresponding copy in the *example output grid*. Calculate the second offset: `delta2 = (c2_tl.row - m2.row, c2_tl.col - m2.col)`.
        c.  Calculate the step change in the offset: `step = (delta2.row - base_delta.row, delta2.col - base_delta.col)`.
    7.  Generate and place copies: Iterate through the ordered list of marker pixels, starting with the first marker at index `i = 1`.
        a.  For the marker `m_i` at index `i` with color `C` and position `(mr, mc)`:
            i.  Calculate the offset to apply for this marker: `current_delta_row = base_delta.row + (i - 1) * step.row`, `current_delta_col = base_delta.col + (i - 1) * step.col`.
            ii. Calculate the target top-left position `(tr, tc)` for the copy: `tr = mr + current_delta_row`, `tc = mc + current_delta_col`.
            iii. For each relative pixel position `(pr, pc)` within the template shape:
                *   Place a pixel of color `C` at the absolute position `(tr + pr, tc + pc)` in the output grid. Ensure placement stays within grid boundaries.
    8.  Return the modified output grid.
