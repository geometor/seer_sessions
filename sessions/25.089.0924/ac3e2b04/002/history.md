
## train_1

**input:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0
2 2 2 2 1 2 1 2 2 2
0 0 0 0 1 1 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 3 2 3 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 3 2 3 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 1 1 1 0
1 1 3 2 3 1 1 1 1 2 1 1
0 0 3 3 3 0 0 0 1 1 1 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 1 1 1 0 0 0 3 3 3 0
1 1 1 2 1 1 1 1 3 2 3 1
0 0 1 1 1 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


## train_3

**input:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 3 2 3 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
1 1 1 3 2 3 1 1 1 1 1 1
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0 0
2 2 2 3 2 3 2 2 2 2 2 2 2 2
0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 0 0
2 2 2 2 2 2 2 2 2 3 2 3 2 2
0 0 0 0 0 0 0 0 0 3 3 3 0 0
```


**output:**
```
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 3 3 3 0 0 0 1 1 1 0 0
2 2 2 3 2 3 2 2 2 1 2 1 2 2
0 0 0 3 3 3 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 1 1 1 0 0
2 2 2 1 2 1 2 2 2 1 2 1 2 2
0 0 0 1 1 1 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 3 3 3 0 0
2 2 2 1 2 1 2 2 2 3 2 3 2 2
0 0 0 1 1 1 0 0 0 3 3 3 0 0
```

Okay, let's break down this task.

**Perception of Elements**

1.  **Input Grid Composition:** The input grids primarily consist of white (0) background pixels, red (2) pixels, and green (3) pixels.
2.  **Key Structures:**
    *   **Red Boundaries:** Red (2) pixels often form lines (horizontal or vertical) or more complex shapes that act as boundaries or walls.
    *   **Green H-Shape:** A recurring pattern is a 3x3 structure made of green (3) pixels surrounding a central red (2) pixel. It looks like this:
        
```
        3 3 3
        3 2 3
        3 3 3
        ```

        This 'H-shape' appears to be the trigger for the transformation. Let's call the central red pixel of this shape the 'source' pixel.
3.  **Output Grid Composition:** The output grid retains all the red (2) and green (3) pixels from the input grid in their original positions. Additionally, blue (1) pixels are introduced.
4.  **Transformation Logic:** The blue (1) pixels appear in areas that were originally white (0) in the input. The placement and extent of the blue pixels are determined by a process originating from the 'source' pixel(s) of the green H-shape(s) and constrained by the red (2) boundaries. It looks like a flood fill mechanism.
5.  **Flood Fill Behavior:**
    *   The fill process seems to start from the 'source' pixel (the red center of an H-shape).
    *   The fill spreads outwards (up, down, left, right) into adjacent cells.
    *   If the fill reaches a white (0) cell, that cell becomes blue (1) in the output.
    *   The fill can pass through green (3) cells without changing them.
    *   The fill is stopped by red (2) cells; these act as impenetrable walls.
    *   The fill is also stopped by the grid boundaries.
    *   If there are multiple H-shapes, each initiates its own fill process. The resulting blue areas might merge if they are part of the same connected region not separated by red walls.

**Facts (YAML)**


```yaml
Task: Fill enclosed areas triggered by a specific pattern.

Input_Objects:
  - Type: Background
    Color: white (0)
    Role: Fillable space.
  - Type: Boundary
    Color: red (2)
    Role: Acts as an impenetrable wall for the fill process. Forms lines or shapes. Persists in the output.
  - Type: Trigger_Pattern (H-shape)
    Structure: 3x3 grid
    Pixels:
      - Corners and Mid-Sides: green (3)
      - Center: red (2) - This is the 'source' pixel.
    Role: Initiates the fill process. The pattern itself (green and red pixels) persists in the output.

Output_Objects:
  - Type: Background
    Color: white (0)
    Role: Persists only if not part of a filled region.
  - Type: Boundary
    Color: red (2)
    Role: Same as input.
  - Type: Trigger_Pattern (H-shape)
    Pixels: Same as input.
    Role: Same as input.
  - Type: Filled_Area
    Color: blue (1)
    Role: Replaces white (0) pixels in regions reachable by the fill process.

Transformation_Rules:
  - Rule: Flood Fill
    Origin: Starts from the 'source' pixel (red center) of each H-shape identified in the input.
    Target: Changes white (0) pixels to blue (1).
    Connectivity: 4-way adjacency (up, down, left, right).
    Boundaries: Red (2) pixels and grid edges block the fill.
    Traversal: Fill can pass through green (3) pixels without altering them.
    Scope: Applies to all white (0) pixels reachable from a 'source' pixel without crossing a red (2) boundary.
  - Rule: Preservation
    Affected_Pixels: Red (2) and green (3) pixels.
    Action: Remain unchanged from input to output grid.

Relationships:
  - The H-shape's 'source' pixel location determines the starting point for filling.
  - Red (2) pixels define the containment regions for the blue (1) fill.
  - White (0) pixels within a reachable, contained area are converted to blue (1).
```


**Natural Language Program**

1.  Create a copy of the input grid; this will become the output grid.
2.  Identify all occurrences of the 3x3 "H-shape" pattern (green border, red center) in the input grid. Record the coordinates (row, column) of the central red pixel ('source' pixel) for each pattern found.
3.  Initialize a list or set of 'visited' coordinates, initially empty, to keep track of cells processed by the flood fill.
4.  Initialize a queue or stack for the flood fill process with all the identified 'source' coordinates. Add these source coordinates to the 'visited' set.
5.  While the flood fill queue/stack is not empty:
    a.  Dequeue/Pop a coordinate (r, c).
    b.  Examine its four neighbors (up, down, left, right): (nr, nc).
    c.  For each valid neighbor (within grid bounds):
        i.   Check if the neighbor coordinate (nr, nc) has already been visited. If yes, skip it.
        ii.  Check the color of the neighbor cell at (nr, nc) in the *input* grid.
        iii. If the neighbor's color is red (2), do nothing (it's a boundary). Mark (nr, nc) as visited to avoid re-checking from another path if needed, although strictly stopping is sufficient.
        iv.  If the neighbor's color is white (0) or green (3):
            *   Mark the neighbor coordinate (nr, nc) as visited.
            *   Add the neighbor coordinate (nr, nc) to the flood fill queue/stack.
            *   If the neighbor's color in the input grid was white (0), change the color of the cell at (nr, nc) in the *output* grid to blue (1). (Do not change green cells).
6.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule:

1.  Identify all occurrences of a specific 3x3 pattern ("H-shape") in the input grid. This pattern consists of a central red (2) pixel surrounded by eight green (3) pixels.
2.  For each identified H-shape, locate its central red pixel (the 'source').
3.  Initiate a flood fill process starting from the neighbors of each 'source' pixel.
4.  The flood fill spreads outwards in four directions (up, down, left, right) into adjacent cells.
5.  If the fill encounters a white (0) pixel in the input grid, that pixel is changed to blue (1) in the output grid.
6.  The fill can pass through green (3) pixels without changing their color.
7.  The fill is blocked by red (2) pixels (which act as boundaries) and the edges of the grid.
8.  All original red (2) and green (3) pixels from the input grid are preserved in the output grid.
9.  Pixels that are not part of the H-shape, are not red boundaries, and are not reachable by the flood fill remain white (0).
"""

def is_valid(r, c, height, width):
    """Checks if coordinates are within grid bounds."""
    return 0 <= r < height and 0 <= c < width

def find_h_sources(input_grid):
    """
    Finds the coordinates of the central red pixel of all 3x3 H-shapes.
    H-shape: 3x3 with green border and red center.
    """
    sources = []
    height, width = input_grid.shape
    # Iterate through possible center coordinates (avoiding edges)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            # Check if the center is red
            if input_grid[r, c] == 2:
                # Check the 8 surrounding pixels for green
                is_h_shape = True
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        # Skip the center pixel itself
                        if dr == 0 and dc == 0:
                            continue
                        # Check if neighbors are green
                        if input_grid[r + dr, c + dc] != 3:
                            is_h_shape = False
                            break
                    if not is_h_shape:
                        break
                
                if is_h_shape:
                    sources.append((r, c))
    return sources

def transform(input_grid):
    """
    Applies the flood fill transformation based on H-shape triggers.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    height, width = input_grid_np.shape
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid_np)
    
    # Find all H-shape source coordinates (the red centers)
    source_coords = find_h_sources(input_grid_np)
    
    if not source_coords:
        # If no H-shapes are found, return the original grid
        return output_grid.tolist()
        
    # Initialize queue for Breadth-First Search (BFS) flood fill
    queue = deque()
    # Initialize visited set to keep track of processed cells
    visited = set()

    # Add initial neighbors of all source points to the queue and visited set
    # The source points themselves are boundaries (red) and already visited in concept
    for r_src, c_src in source_coords:
        visited.add((r_src, c_src)) # Mark the source itself as visited
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 neighbors
            nr, nc = r_src + dr, c_src + dc
            # Check if neighbor is valid and not already visited
            if is_valid(nr, nc, height, width) and (nr, nc) not in visited:
                 # Check neighbor color in the *original* input grid
                neighbor_color = input_grid_np[nr, nc]
                # If the neighbor is not a red boundary
                if neighbor_color != 2:
                    visited.add((nr, nc)) # Mark as visited
                    queue.append((nr, nc)) # Add to queue for processing
                    # If the neighbor was originally white, change it to blue in output
                    if neighbor_color == 0:
                        output_grid[nr, nc] = 1


    # Perform the flood fill using BFS
    while queue:
        r, c = queue.popleft()
        
        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            
            # Check if neighbor is valid and not already visited
            if is_valid(nr, nc, height, width) and (nr, nc) not in visited:
                # Check neighbor color in the *original* input grid
                neighbor_color = input_grid_np[nr, nc]
                
                # If the neighbor is not a red boundary
                if neighbor_color != 2:
                    visited.add((nr, nc)) # Mark as visited
                    queue.append((nr, nc)) # Add to queue for further exploration
                    
                    # If the neighbor was originally white, change it to blue in output
                    if neighbor_color == 0:
                        output_grid[nr, nc] = 1
                        
    return output_grid.tolist()
```
