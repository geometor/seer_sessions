{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify all occurrences of a specific 3x3 pattern (\"H-shape\") in the input grid. This pattern consists of a central red (2) pixel surrounded by eight green (3) pixels.\n2.  For each identified H-shape, locate its central red pixel (the 'source').\n3.  Initiate a flood fill process starting from the neighbors of each 'source' pixel.\n4.  The flood fill spreads outwards in four directions (up, down, left, right) into adjacent cells.\n5.  If the fill encounters a white (0) pixel in the input grid, that pixel is changed to blue (1) in the output grid.\n6.  The fill can pass through green (3) pixels without changing their color.\n7.  The fill is blocked by red (2) pixels (which act as boundaries) and the edges of the grid.\n8.  All original red (2) and green (3) pixels from the input grid are preserved in the output grid.\n9.  Pixels that are not part of the H-shape, are not red boundaries, and are not reachable by the flood fill remain white (0).\n\"\"\"\n\ndef is_valid(r, c, height, width):\n    \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef find_h_sources(input_grid):\n    \"\"\"\n    Finds the coordinates of the central red pixel of all 3x3 H-shapes.\n    H-shape: 3x3 with green border and red center.\n    \"\"\"\n    sources = []\n    height, width = input_grid.shape\n    # Iterate through possible center coordinates (avoiding edges)\n    for r in range(1, height - 1):\n        for c in range(1, width - 1):\n            # Check if the center is red\n            if input_grid[r, c] == 2:\n                # Check the 8 surrounding pixels for green\n                is_h_shape = True\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        # Skip the center pixel itself\n                        if dr == 0 and dc == 0:\n                            continue\n                        # Check if neighbors are green\n                        if input_grid[r + dr, c + dc] != 3:\n                            is_h_shape = False\n                            break\n                    if not is_h_shape:\n                        break\n                \n                if is_h_shape:\n                    sources.append((r, c))\n    return sources\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the flood fill transformation based on H-shape triggers.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    \n    # Find all H-shape source coordinates (the red centers)\n    source_coords = find_h_sources(input_grid_np)\n    \n    if not source_coords:\n        # If no H-shapes are found, return the original grid\n        return output_grid.tolist()\n        \n    # Initialize queue for Breadth-First Search (BFS) flood fill\n    queue = deque()\n    # Initialize visited set to keep track of processed cells\n    visited = set()\n\n    # Add initial neighbors of all source points to the queue and visited set\n    # The source points themselves are boundaries (red) and already visited in concept\n    for r_src, c_src in source_coords:\n        visited.add((r_src, c_src)) # Mark the source itself as visited\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 neighbors\n            nr, nc = r_src + dr, c_src + dc\n            # Check if neighbor is valid and not already visited\n            if is_valid(nr, nc, height, width) and (nr, nc) not in visited:\n                 # Check neighbor color in the *original* input grid\n                neighbor_color = input_grid_np[nr, nc]\n                # If the neighbor is not a red boundary\n                if neighbor_color != 2:\n                    visited.add((nr, nc)) # Mark as visited\n                    queue.append((nr, nc)) # Add to queue for processing\n                    # If the neighbor was originally white, change it to blue in output\n                    if neighbor_color == 0:\n                        output_grid[nr, nc] = 1\n\n\n    # Perform the flood fill using BFS\n    while queue:\n        r, c = queue.popleft()\n        \n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor is valid and not already visited\n            if is_valid(nr, nc, height, width) and (nr, nc) not in visited:\n                # Check neighbor color in the *original* input grid\n                neighbor_color = input_grid_np[nr, nc]\n                \n                # If the neighbor is not a red boundary\n                if neighbor_color != 2:\n                    visited.add((nr, nc)) # Mark as visited\n                    queue.append((nr, nc)) # Add to queue for further exploration\n                    \n                    # If the neighbor was originally white, change it to blue in output\n                    if neighbor_color == 0:\n                        output_grid[nr, nc] = 1\n                        \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5163,
    "candidates_token_count": 1338,
    "total_token_count": 6501,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.62124,
  "retries": 1
}