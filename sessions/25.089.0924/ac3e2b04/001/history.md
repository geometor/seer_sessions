
## train_1

**input:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0
2 2 2 2 1 2 1 2 2 2
0 0 0 0 1 1 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 3 2 3 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 3 2 3 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 1 1 1 0
1 1 3 2 3 1 1 1 1 2 1 1
0 0 3 3 3 0 0 0 1 1 1 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 1 1 1 0 0 0 3 3 3 0
1 1 1 2 1 1 1 1 3 2 3 1
0 0 1 1 1 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


## train_3

**input:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 3 2 3 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
1 1 1 3 2 3 1 1 1 1 1 1
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0 0
2 2 2 3 2 3 2 2 2 2 2 2 2 2
0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 0 0
2 2 2 2 2 2 2 2 2 3 2 3 2 2
0 0 0 0 0 0 0 0 0 3 3 3 0 0
```


**output:**
```
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 3 3 3 0 0 0 1 1 1 0 0
2 2 2 3 2 3 2 2 2 1 2 1 2 2
0 0 0 3 3 3 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 1 1 1 0 0
2 2 2 1 2 1 2 2 2 1 2 1 2 2
0 0 0 1 1 1 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 3 3 3 0 0
2 2 2 1 2 1 2 2 2 3 2 3 2 2
0 0 0 1 1 1 0 0 0 3 3 3 0 0
```

Okay, let's break down this task.

**Perception of Elements**

1.  **Input Grid Composition:** The input grids primarily consist of white (0) background pixels, red (2) pixels, and green (3) pixels.
2.  **Key Structures:**
    *   **Red Boundaries:** Red (2) pixels often form lines (horizontal or vertical) or more complex shapes that act as boundaries or walls.
    *   **Green H-Shape:** A recurring pattern is a 3x3 structure made of green (3) pixels surrounding a central red (2) pixel. It looks like this:
        
```
        3 3 3
        3 2 3
        3 3 3
        ```

        This 'H-shape' appears to be the trigger for the transformation. Let's call the central red pixel of this shape the 'source' pixel.
3.  **Output Grid Composition:** The output grid retains all the red (2) and green (3) pixels from the input grid in their original positions. Additionally, blue (1) pixels are introduced.
4.  **Transformation Logic:** The blue (1) pixels appear in areas that were originally white (0) in the input. The placement and extent of the blue pixels are determined by a process originating from the 'source' pixel(s) of the green H-shape(s) and constrained by the red (2) boundaries. It looks like a flood fill mechanism.
5.  **Flood Fill Behavior:**
    *   The fill process seems to start from the 'source' pixel (the red center of an H-shape).
    *   The fill spreads outwards (up, down, left, right) into adjacent cells.
    *   If the fill reaches a white (0) cell, that cell becomes blue (1) in the output.
    *   The fill can pass through green (3) cells without changing them.
    *   The fill is stopped by red (2) cells; these act as impenetrable walls.
    *   The fill is also stopped by the grid boundaries.
    *   If there are multiple H-shapes, each initiates its own fill process. The resulting blue areas might merge if they are part of the same connected region not separated by red walls.

**Facts (YAML)**


```yaml
Task: Fill enclosed areas triggered by a specific pattern.

Input_Objects:
  - Type: Background
    Color: white (0)
    Role: Fillable space.
  - Type: Boundary
    Color: red (2)
    Role: Acts as an impenetrable wall for the fill process. Forms lines or shapes. Persists in the output.
  - Type: Trigger_Pattern (H-shape)
    Structure: 3x3 grid
    Pixels:
      - Corners and Mid-Sides: green (3)
      - Center: red (2) - This is the 'source' pixel.
    Role: Initiates the fill process. The pattern itself (green and red pixels) persists in the output.

Output_Objects:
  - Type: Background
    Color: white (0)
    Role: Persists only if not part of a filled region.
  - Type: Boundary
    Color: red (2)
    Role: Same as input.
  - Type: Trigger_Pattern (H-shape)
    Pixels: Same as input.
    Role: Same as input.
  - Type: Filled_Area
    Color: blue (1)
    Role: Replaces white (0) pixels in regions reachable by the fill process.

Transformation_Rules:
  - Rule: Flood Fill
    Origin: Starts from the 'source' pixel (red center) of each H-shape identified in the input.
    Target: Changes white (0) pixels to blue (1).
    Connectivity: 4-way adjacency (up, down, left, right).
    Boundaries: Red (2) pixels and grid edges block the fill.
    Traversal: Fill can pass through green (3) pixels without altering them.
    Scope: Applies to all white (0) pixels reachable from a 'source' pixel without crossing a red (2) boundary.
  - Rule: Preservation
    Affected_Pixels: Red (2) and green (3) pixels.
    Action: Remain unchanged from input to output grid.

Relationships:
  - The H-shape's 'source' pixel location determines the starting point for filling.
  - Red (2) pixels define the containment regions for the blue (1) fill.
  - White (0) pixels within a reachable, contained area are converted to blue (1).
```


**Natural Language Program**

1.  Create a copy of the input grid; this will become the output grid.
2.  Identify all occurrences of the 3x3 "H-shape" pattern (green border, red center) in the input grid. Record the coordinates (row, column) of the central red pixel ('source' pixel) for each pattern found.
3.  Initialize a list or set of 'visited' coordinates, initially empty, to keep track of cells processed by the flood fill.
4.  Initialize a queue or stack for the flood fill process with all the identified 'source' coordinates. Add these source coordinates to the 'visited' set.
5.  While the flood fill queue/stack is not empty:
    a.  Dequeue/Pop a coordinate (r, c).
    b.  Examine its four neighbors (up, down, left, right): (nr, nc).
    c.  For each valid neighbor (within grid bounds):
        i.   Check if the neighbor coordinate (nr, nc) has already been visited. If yes, skip it.
        ii.  Check the color of the neighbor cell at (nr, nc) in the *input* grid.
        iii. If the neighbor's color is red (2), do nothing (it's a boundary). Mark (nr, nc) as visited to avoid re-checking from another path if needed, although strictly stopping is sufficient.
        iv.  If the neighbor's color is white (0) or green (3):
            *   Mark the neighbor coordinate (nr, nc) as visited.
            *   Add the neighbor coordinate (nr, nc) to the flood fill queue/stack.
            *   If the neighbor's color in the input grid was white (0), change the color of the cell at (nr, nc) in the *output* grid to blue (1). (Do not change green cells).
6.  Return the modified output grid.
