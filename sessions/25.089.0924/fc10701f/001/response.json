{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set\n\n# Color mapping for clarity (optional, but helpful)\nCOLOR_MAP = {\n    0: \"white\", 1: \"blue\", 2: \"red\", 3: \"green\", 4: \"yellow\",\n    5: \"gray\", 6: \"magenta\", 7: \"orange\", 8: \"azure\", 9: \"maroon\",\n}\nMAGENTA = 6\nMAROON = 9\nORANGE = 7\nWHITE = 0\nRED = 2\n\ndef find_colored_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the min_row, max_row, min_col, max_col for a set of coordinates.\"\"\"\n    if not coords:\n        return -1, -1, -1, -1 # Indicate no object found\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), max(rows), min(cols), max(cols)\n\ndef find_white_segments_on_row(row_slice: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Finds contiguous segments of White (0) on a single row slice.\n       Returns a list of (start_col, end_col) tuples for each segment.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_col = -1\n    for c, color in enumerate(row_slice):\n        if color == WHITE and not in_segment:\n            in_segment = True\n            start_col = c\n        elif color != WHITE and in_segment:\n            in_segment = False\n            segments.append((start_col, c - 1))\n    # Handle segment ending at the edge\n    if in_segment:\n        segments.append((start_col, len(row_slice) - 1))\n    return segments\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify the unique Maroon (9) and Orange (7) objects.\n    2. Determine if they are primarily horizontally or vertically aligned based on overlapping rows or columns.\n    3. Create the output grid by copying the input.\n    4. Replace the Maroon object's location with Orange.\n    5. If Horizontally aligned:\n       - On the shared row(s), replace White (0) pixels located strictly between the column spans of the two objects with Red (2).\n    6. If Vertically aligned:\n       - Identify rows containing at least two distinct horizontal segments of White (0).\n       - For each such row, find the rightmost White segment.\n       - Place Red (2) pixels at two locations on that row in the output:\n         - One in the rightmost column shared by the original Maroon/Orange objects.\n         - One in the leftmost column of the rightmost White segment found on that row.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # --- Find Objects and Bounds ---\n    maroon_coords = find_colored_pixels(input_grid, MAROON)\n    orange_coords = find_colored_pixels(input_grid, ORANGE)\n\n    if not maroon_coords or not orange_coords:\n        # Should not happen based on examples, but handle defensively\n        return output_grid \n\n    maroon_min_r, maroon_max_r, maroon_min_c, maroon_max_c = get_bounding_box(maroon_coords)\n    orange_min_r, orange_max_r, orange_min_c, orange_max_c = get_bounding_box(orange_coords)\n\n    # --- Determine Alignment ---\n    rows_overlap = max(maroon_min_r, orange_min_r) <= min(maroon_max_r, orange_max_r)\n    cols_overlap = max(maroon_min_c, orange_min_c) <= min(orange_max_c, orange_max_c)\n\n    is_horizontal_alignment = False\n    is_vertical_alignment = False\n\n    # Prioritize horizontal if both overlap (e.g., single pixel objects on same row/col)\n    # Or if only rows overlap significantly\n    if rows_overlap and not cols_overlap:\n         is_horizontal_alignment = True\n    elif cols_overlap and not rows_overlap:\n         is_vertical_alignment = True\n    elif rows_overlap and cols_overlap:\n         # If bounds perfectly overlap, could be either. Check relative position.\n         # If they share rows but not columns -> horizontal\n         # If they share columns but not rows -> vertical\n         # If they share both rows and columns (contained or identical position) - Treat as Horizontal seems safer based on train_3 edge case where they touch.\n         # Let's refine: if number of shared rows > number of shared columns -> likely Horizontal\n         # Let's use the simple overlap for now, seems sufficient for examples\n         # Check if center points indicate alignment better?\n         maroon_center_r = (maroon_min_r + maroon_max_r) / 2\n         maroon_center_c = (maroon_min_c + maroon_max_c) / 2\n         orange_center_r = (orange_min_r + orange_max_r) / 2\n         orange_center_c = (orange_min_c + orange_max_c) / 2\n         \n         # If centers are much closer horizontally than vertically\n         if abs(maroon_center_r - orange_center_r) <= abs(maroon_center_c - orange_center_c) :\n             # More aligned vertically or equally, but let's check row span first\n             if maroon_min_r == orange_min_r and maroon_max_r == orange_max_r:\n                 is_horizontal_alignment = True # Same row(s) -> horizontal\n             else: # Different rows but same cols\n                 is_vertical_alignment = True\n         else: # More aligned horizontally\n             if maroon_min_c == orange_min_c and maroon_max_c == orange_max_c:\n                 is_vertical_alignment = True # Same col(s) -> vertical\n             else:\n                is_horizontal_alignment = True\n\n    # Fallback if no clear alignment from overlap (shouldn't occur with 1 obj each)\n    if not is_horizontal_alignment and not is_vertical_alignment:\n         # Default to horizontal if unsure, or handle error\n         # Based on examples, one must be true.\n         # Let's re-evaluate based purely on shared rows/cols\n         if rows_overlap:\n             is_horizontal_alignment = True # Train 2 & 3\n         elif cols_overlap:\n             is_vertical_alignment = True # Train 1\n\n\n    # --- Perform Base Transformation (Move Orange to Maroon position) ---\n    # Clear original Maroon location in output\n    for r, c in maroon_coords:\n        output_grid[r, c] = MAGENTA # Assuming magenta is background\n\n    # Place Orange color at Maroon's original location\n    for r, c in maroon_coords:\n        output_grid[r, c] = ORANGE\n\n\n    # --- Apply Alignment-Specific Rules ---\n    if is_horizontal_alignment:\n        # Find shared rows\n        shared_rows = range(max(maroon_min_r, orange_min_r), min(maroon_max_r, orange_max_r) + 1)\n        \n        # Find column span between the objects\n        obj1_min_c, obj1_max_c = maroon_min_c, maroon_max_c\n        obj2_min_c, obj2_max_c = orange_min_c, orange_max_c\n\n        start_col = min(obj1_max_c, obj2_max_c) + 1\n        end_col = max(obj1_min_c, obj2_min_c) # Exclusive end\n\n        # Ensure start_col is actually less than end_col\n        if start_col < end_col:\n             for r in shared_rows:\n                 for c in range(start_col, end_col):\n                      # Check original input grid for white\n                      if input_grid[r, c] == WHITE:\n                          output_grid[r, c] = RED\n\n    elif is_vertical_alignment:\n        # Find shared columns and the rightmost one\n        shared_cols = range(max(maroon_min_c, orange_min_c), min(maroon_max_c, orange_max_c) + 1)\n        if not shared_cols: # Should have overlap if vertical alignment detected\n            return output_grid # Error or unexpected case\n            \n        rightmost_shared_col = max(shared_cols)\n\n        # Iterate through rows to find those with >= 2 white segments\n        for r in range(height):\n            row_slice = input_grid[r, :]\n            white_segments = find_white_segments_on_row(row_slice)\n\n            if len(white_segments) >= 2:\n                # Find the rightmost white segment (max start col)\n                rightmost_segment = max(white_segments, key=lambda seg: seg[0])\n                right_white_left_col = rightmost_segment[0] # Leftmost column of the rightmost segment\n\n                # Place Red pixels\n                # Check bounds before writing\n                if 0 <= r < height and 0 <= rightmost_shared_col < width:\n                     output_grid[r, rightmost_shared_col] = RED\n                if 0 <= r < height and 0 <= right_white_left_col < width:\n                     output_grid[r, right_white_left_col] = RED\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4146,
    "candidates_token_count": 2357,
    "total_token_count": 6503,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.812087,
  "retries": 1
}