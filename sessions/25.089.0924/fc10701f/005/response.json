{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nMoves an Orange object (7) to the location of a Maroon object (9) and adds \nRed pixels (2) based on the relative alignment (Horizontal/Vertical) of the \ntwo objects and the positions of White pixels/objects (0) in the input grid. \nThe background color is Magenta (6).\n\nIf alignment is Horizontal:\nRed pixels replace White pixels located on the shared row(s) and strictly \nbetween the column spans of the Maroon and Orange objects. The specific columns \nare identified by finding White pixels within the 'between' range on any shared \nrow, and then applying Red to those columns across all shared rows.\n\nIf alignment is Vertical:\nRed pixels are added on rows that contain at least two distinct horizontal \nsegments of White pixels. On each such row, Red pixels are placed in two columns:\n1. The leftmost column shared by the original Maroon and Orange objects.\n2. The column immediately to the left of the starting column of the \n   rightmost White segment on that row.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n# Define color constants\nMAGENTA = 6\nMAROON = 9\nORANGE = 7\nWHITE = 0\nRED = 2\n\ndef find_colored_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the min_row, max_row, min_col, max_col for a set of coordinates.\"\"\"\n    if not coords:\n        # Return invalid box if no coordinates\n        return -1, -1, -1, -1\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), max(rows), min(cols), max(cols)\n\ndef find_white_segments_on_row(row_slice: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Finds contiguous segments of White (0) on a single row slice.\n       Returns a list of (start_col, end_col) tuples for each segment.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_col = -1\n    width = len(row_slice)\n    for c, color in enumerate(row_slice):\n        if color == WHITE and not in_segment:\n            in_segment = True\n            start_col = c\n        elif color != WHITE and in_segment:\n            in_segment = False\n            segments.append((start_col, c - 1))\n    # Handle segment ending at the edge\n    if in_segment:\n        segments.append((start_col, width - 1))\n    return segments\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"Applies the transformation rules to the input grid.\"\"\"\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find coordinates of Maroon and Orange objects\n    maroon_coords = find_colored_pixels(input_grid, MAROON)\n    orange_coords = find_colored_pixels(input_grid, ORANGE)\n\n    # If either object is missing, return the original grid copy\n    if not maroon_coords or not orange_coords:\n        return output_grid\n\n    # Calculate bounding boxes\n    maroon_min_r, maroon_max_r, maroon_min_c, maroon_max_c = get_bounding_box(maroon_coords)\n    orange_min_r, orange_max_r, orange_min_c, orange_max_c = get_bounding_box(orange_coords)\n\n    # Determine alignment\n    rows_overlap = max(maroon_min_r, orange_min_r) <= min(maroon_max_r, orange_max_r)\n    cols_overlap = max(maroon_min_c, orange_min_c) <= min(maroon_max_c, orange_max_c)\n\n    is_horizontal_alignment = False\n    is_vertical_alignment = False\n\n    if maroon_min_r == orange_min_r and maroon_max_r == orange_max_r:\n        is_horizontal_alignment = True\n    elif maroon_min_c == orange_min_c and maroon_max_c == orange_max_c:\n        is_vertical_alignment = True\n    elif rows_overlap and not cols_overlap:\n        is_horizontal_alignment = True\n    elif cols_overlap and not rows_overlap:\n        is_vertical_alignment = True\n    elif rows_overlap and cols_overlap:\n        # Default to horizontal if both overlap but spans are not identical\n        is_horizontal_alignment = True\n\n    # Clear original locations of both objects in output_grid\n    for r, c in maroon_coords:\n        output_grid[r, c] = MAGENTA\n    for r, c in orange_coords:\n        # Check if the orange pixel wasn't already overwritten by Magenta\n        # (in case Maroon and Orange objects touched or overlapped)\n        if output_grid[r, c] == ORANGE:\n            output_grid[r, c] = MAGENTA\n\n    # Place Orange color at Maroon's original location\n    for r, c in maroon_coords:\n        output_grid[r, c] = ORANGE\n\n    # Apply alignment-specific rules for placing Red pixels\n    if is_horizontal_alignment:\n        # Identify shared rows\n        shared_rows = list(range(max(maroon_min_r, orange_min_r), min(maroon_max_r, orange_max_r) + 1))\n        \n        # Define the column range strictly *between* the objects\n        between_start_col = min(maroon_max_c, orange_max_c) + 1\n        between_end_col = max(maroon_min_c, orange_min_c) # Exclusive end\n\n        target_cols: Set[int] = set()\n        # Check if there is actually space between the objects\n        if between_start_col < between_end_col:\n            # Iterate through shared rows to find white pixels in the 'between' zone\n            for r in shared_rows:\n                 # Ensure row index is valid\n                 if 0 <= r < height:\n                    for c in range(between_start_col, between_end_col):\n                         # Check bounds for column and check color in INPUT grid\n                         if 0 <= c < width and input_grid[r, c] == WHITE:\n                             target_cols.add(c)\n\n        # Place Red pixels on shared rows in the identified target columns\n        for r in shared_rows:\n             if 0 <= r < height: # Check row bounds\n                for c in target_cols:\n                    if 0 <= c < width: # Check column bounds\n                        output_grid[r, c] = RED\n\n    elif is_vertical_alignment:\n        # Identify shared columns and the leftmost one\n        shared_cols = list(range(max(maroon_min_c, orange_min_c), min(maroon_max_c, orange_max_c) + 1))\n        \n        # Handle case where alignment detected but no columns technically shared (e.g., touching corners)\n        # Use the minimum of the start columns as a fallback\n        leftmost_shared_col = min(shared_cols) if shared_cols else min(maroon_min_c, orange_min_c) \n        \n        # Iterate through all rows to check for multiple white segments\n        for r in range(height):\n            row_slice = input_grid[r, :]\n            white_segments = find_white_segments_on_row(row_slice)\n\n            # Check if the row contains two or more distinct white segments\n            if len(white_segments) >= 2:\n                # Find the rightmost white segment (the one with the largest start column)\n                rightmost_segment = max(white_segments, key=lambda seg: seg[0])\n                rightmost_segment_start_col = rightmost_segment[0]\n                \n                # Calculate the column immediately to the left of the rightmost segment's start\n                col_left_of_rightmost_white = rightmost_segment_start_col - 1\n\n                # Place Red pixel at the leftmost shared column on this row\n                if 0 <= r < height and 0 <= leftmost_shared_col < width:\n                     output_grid[r, leftmost_shared_col] = RED\n                     \n                # Place Red pixel at the column left of the rightmost white segment's start\n                if 0 <= r < height and 0 <= col_left_of_rightmost_white < width:\n                     output_grid[r, col_left_of_rightmost_white] = RED\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19144,
    "candidates_token_count": 2107,
    "total_token_count": 21251,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.520994,
  "retries": 1
}