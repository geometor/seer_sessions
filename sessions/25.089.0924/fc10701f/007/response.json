{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nReplaces a Maroon object (9) with an Orange object (7), clears the original Orange \nlocation, and adds Red pixels (2) based on the relative alignment (Horizontal/Vertical) \nof the Maroon and Orange objects in the input grid. The background is Magenta (6).\n\nAlignment Rules:\n- Determined by bounding box overlap/identity. Horizontal preferred if ambiguous.\n\nRed Pixel Placement Rules:\n- If Horizontal Alignment:\n  Red pixels are placed on the row(s) shared by the bounding boxes, in columns that \n  are strictly between the objects' column spans AND contain White (0) pixels anywhere\n  in the input grid.\n- If Vertical Alignment:\n  Red pixels are placed on rows containing at least two distinct horizontal segments \n  of White pixels. On each such row, Red pixels replace Magenta pixels in two columns:\n  1. The leftmost column shared by the original Maroon and Orange bounding boxes.\n  2. The column immediately to the left of the starting column of the rightmost \n     White segment on that row.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n# Define color constants\nMAGENTA = 6\nMAROON = 9\nORANGE = 7\nWHITE = 0\nRED = 2\n\ndef find_colored_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the min_row, max_row, min_col, max_col for a set of coordinates.\"\"\"\n    if not coords:\n        # Return invalid box if no coordinates\n        return -1, -1, -1, -1\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), max(rows), min(cols), max(cols)\n\ndef find_white_segments_on_row(row_slice: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Finds contiguous segments of White (0) on a single row slice.\n       Returns a list of (start_col, end_col) tuples for each segment.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_col = -1\n    width = len(row_slice)\n    for c, color in enumerate(row_slice):\n        if color == WHITE and not in_segment:\n            in_segment = True\n            start_col = c\n        elif color != WHITE and in_segment:\n            in_segment = False\n            segments.append((start_col, c - 1))\n    # Handle segment ending at the edge\n    if in_segment:\n        segments.append((start_col, width - 1))\n    return segments\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find coordinates of Maroon and Orange objects\n    maroon_coords = find_colored_pixels(input_grid, MAROON)\n    orange_coords = find_colored_pixels(input_grid, ORANGE)\n\n    # If either object is missing, return the original grid copy\n    if not maroon_coords or not orange_coords:\n        return output_grid\n\n    # Calculate bounding boxes\n    maroon_min_r, maroon_max_r, maroon_min_c, maroon_max_c = get_bounding_box(maroon_coords)\n    orange_min_r, orange_max_r, orange_min_c, orange_max_c = get_bounding_box(orange_coords)\n\n    # Determine alignment based on bounding box properties\n    rows_overlap = max(maroon_min_r, orange_min_r) <= min(maroon_max_r, orange_max_r)\n    cols_overlap = max(maroon_min_c, orange_min_c) <= min(maroon_max_c, orange_max_c)\n\n    is_horizontal_alignment = False\n    is_vertical_alignment = False\n\n    if maroon_min_r == orange_min_r and maroon_max_r == orange_max_r:\n        is_horizontal_alignment = True\n    elif maroon_min_c == orange_min_c and maroon_max_c == orange_max_c:\n        is_vertical_alignment = True\n    elif rows_overlap and not cols_overlap:\n        is_horizontal_alignment = True\n    elif cols_overlap and not rows_overlap:\n        is_vertical_alignment = True\n    elif rows_overlap and cols_overlap:\n        # Default to horizontal if both overlap but spans are not identical\n        is_horizontal_alignment = True\n        \n    # --- Perform Base Transformations ---\n        \n    # Clear original locations of both objects in output_grid (set to background)\n    for r, c in maroon_coords:\n        if 0 <= r < height and 0 <= c < width:\n            output_grid[r, c] = MAGENTA\n    for r, c in orange_coords:\n         if 0 <= r < height and 0 <= c < width:\n            # Check if the orange pixel wasn't already overwritten by Magenta\n            # This handles cases where Maroon and Orange objects might touch or overlap.\n            if output_grid[r, c] == ORANGE:\n                output_grid[r, c] = MAGENTA\n\n    # Place Orange color at Maroon's original location\n    for r, c in maroon_coords:\n        if 0 <= r < height and 0 <= c < width:\n            output_grid[r, c] = ORANGE\n\n    # --- Apply Alignment-Specific Rules for Placing Red Pixels ---\n    if is_horizontal_alignment:\n        # Identify shared rows using bounding boxes\n        shared_rows = list(range(max(maroon_min_r, orange_min_r), min(maroon_max_r, orange_max_r) + 1))\n        \n        # Define the column range strictly *between* the objects\n        between_start_col = min(maroon_max_c, orange_max_c) + 1\n        between_end_col = max(maroon_min_c, orange_min_c) # Exclusive end (range is start to end-1)\n\n        target_cols: Set[int] = set()\n        # Check if there is actually space between the objects\n        if between_start_col < between_end_col:\n             # Find all columns containing any White pixel in the *input* grid\n             white_pixels_coords = find_colored_pixels(input_grid, WHITE)\n             white_cols = {c for r, c in white_pixels_coords}\n\n             # Find the intersection of columns between objects and columns with white pixels\n             for c in range(between_start_col, between_end_col):\n                 if c in white_cols:\n                     target_cols.add(c)\n\n        # Place Red pixels on shared rows in the identified target columns\n        for r in shared_rows:\n             if 0 <= r < height: # Check row bounds\n                for c in target_cols:\n                    if 0 <= c < width: # Check column bounds\n                        # Place Red, overwriting whatever is there (usually Magenta)\n                        output_grid[r, c] = RED\n\n    elif is_vertical_alignment:\n        # Identify shared columns and the leftmost one\n        shared_cols = list(range(max(maroon_min_c, orange_min_c), min(maroon_max_c, orange_max_c) + 1))\n        \n        # Handle potential edge case where alignment=vertical but no shared columns found\n        # (e.g., touching corners). Use the leftmost of the two object starts as fallback.\n        leftmost_shared_col = min(shared_cols) if shared_cols else min(maroon_min_c, orange_min_c) \n        \n        # Iterate through all rows to check for multiple white segments\n        for r in range(height):\n            row_slice = input_grid[r, :]\n            white_segments = find_white_segments_on_row(row_slice)\n\n            # Check if the row contains two or more distinct white segments\n            if len(white_segments) >= 2:\n                # Find the rightmost white segment (the one with the largest start column)\n                rightmost_segment = max(white_segments, key=lambda seg: seg[0])\n                rightmost_segment_start_col = rightmost_segment[0]\n                \n                # Calculate the column immediately to the left of the rightmost segment's start\n                col_left_of_rightmost_white = rightmost_segment_start_col - 1\n\n                # Place Red pixel at the leftmost shared column on this row\n                if 0 <= r < height and 0 <= leftmost_shared_col < width:\n                     output_grid[r, leftmost_shared_col] = RED\n                     \n                # Place Red pixel at the column left of the rightmost white segment's start\n                # Ensure the calculated column index is valid (>= 0)\n                if 0 <= r < height and col_left_of_rightmost_white >= 0 and col_left_of_rightmost_white < width:\n                     output_grid[r, col_left_of_rightmost_white] = RED\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21409,
    "candidates_token_count": 2234,
    "total_token_count": 23643,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.749414,
  "retries": 1
}