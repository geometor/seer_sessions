{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\nfrom skimage.measure import label\n\n# Define color constants\nMAGENTA = 6\nMAROON = 9\nORANGE = 7\nWHITE = 0\nRED = 2\n\ndef find_colored_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the min_row, max_row, min_col, max_col for a set of coordinates.\"\"\"\n    if not coords:\n        # Return invalid box if no coordinates\n        return -1, -1, -1, -1 \n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), max(rows), min(cols), max(cols)\n\ndef find_objects(grid: np.ndarray, color: int) -> List[List[Tuple[int, int]]]:\n    \"\"\"Finds connected components of a specified color.\n       Uses 4-way connectivity. Returns a list of objects, where each object\n       is a list of its (row, col) coordinates.\n    \"\"\"\n    binary_grid = (grid == color)\n    # connectivity=1 means 4-way adjacency (von Neumann neighborhood)\n    labeled_grid, num_labels = label(binary_grid, connectivity=1, background=0, return_num=True) \n    objects = []\n    for label_id in range(1, num_labels + 1):\n        coords = list(zip(*np.where(labeled_grid == label_id)))\n        if coords:\n            objects.append(coords)\n    return objects\n\ndef find_white_segments_on_row(row_slice: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Finds contiguous segments of White (0) on a single row slice.\n       Returns a list of (start_col, end_col) tuples for each segment.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_col = -1\n    width = len(row_slice)\n    for c, color in enumerate(row_slice):\n        if color == WHITE and not in_segment:\n            in_segment = True\n            start_col = c\n        elif color != WHITE and in_segment:\n            in_segment = False\n            segments.append((start_col, c - 1))\n    # Handle segment ending at the edge\n    if in_segment:\n        segments.append((start_col, width - 1))\n    return segments\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid according to the following rules:\n    1. Identifies the unique Maroon (9) and Orange (7) objects and their coordinates.\n    2. Creates an output grid initialized with the background color (Magenta 6), \n       copying non-Maroon/Orange elements from the input.\n    3. Places the Orange (7) color in the output grid at the original location of the Maroon object.\n    4. Determines if the Maroon and Orange objects were primarily horizontally or vertically aligned\n       based on overlap of their bounding boxes in the input grid.\n    5. If Horizontally aligned:\n       a. Finds the row(s) shared by the bounding boxes.\n       b. Defines a column range strictly between the Maroon and Orange objects.\n       c. Identifies all White (0) objects from the input grid that lie entirely within this 'between' column range.\n       d. Collects the column indices occupied by these White objects.\n       e. Places Red (2) pixels in the output grid on the shared row(s) at the collected column indices.\n    6. If Vertically aligned:\n       a. Finds the column(s) shared by the bounding boxes and identifies the leftmost shared column.\n       b. Identifies rows in the input grid containing at least two distinct horizontal segments of White (0).\n       c. For each such row, finds the leftmost column of the rightmost White segment.\n       d. Places Red (2) pixels in the output grid at two locations on that row:\n          - One in the leftmost column shared by the original Maroon/Orange objects.\n          - One in the column immediately to the left of the rightmost White segment's start.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # --- Find Objects and Coordinates ---\n    maroon_coords = find_colored_pixels(input_grid, MAROON)\n    orange_coords = find_colored_pixels(input_grid, ORANGE)\n\n    # Handle cases where one or both objects might be missing (though not expected per examples)\n    if not maroon_coords or not orange_coords:\n        return output_grid \n\n    # --- Perform Base Transformation ---\n    # Clear original Maroon location in output grid (set to background)\n    for r, c in maroon_coords:\n        output_grid[r, c] = MAGENTA \n\n    # Clear original Orange location in output grid (set to background)\n    for r, c in orange_coords:\n         if output_grid[r, c] == ORANGE: # Avoid clearing if it overlaps with where maroon was\n             output_grid[r, c] = MAGENTA\n\n    # Place Orange color at Maroon's original location\n    for r, c in maroon_coords:\n        output_grid[r, c] = ORANGE\n\n    # --- Get Bounding Boxes for Alignment Check ---\n    maroon_min_r, maroon_max_r, maroon_min_c, maroon_max_c = get_bounding_box(maroon_coords)\n    orange_min_r, orange_max_r, orange_min_c, orange_max_c = get_bounding_box(orange_coords)\n\n    # --- Determine Alignment ---\n    rows_overlap = max(maroon_min_r, orange_min_r) <= min(maroon_max_r, orange_max_r)\n    cols_overlap = max(maroon_min_c, orange_min_c) <= min(maroon_max_c, orange_max_c)\n\n    is_horizontal_alignment = False\n    is_vertical_alignment = False\n\n    # Determine alignment based on shared rows/columns\n    # Prioritize horizontal if rows are identical, vertical if columns are identical\n    if maroon_min_r == orange_min_r and maroon_max_r == orange_max_r:\n        is_horizontal_alignment = True\n    elif maroon_min_c == orange_min_c and maroon_max_c == orange_max_c:\n        is_vertical_alignment = True\n    # Fallback based on simple overlap (covers cases where one dim overlaps but not identical spans)\n    elif rows_overlap and not cols_overlap:\n        is_horizontal_alignment = True\n    elif cols_overlap and not rows_overlap:\n        is_vertical_alignment = True\n    # If both overlap but aren't identical spans, default to horizontal (matches example 3 logic implicitly)\n    elif rows_overlap and cols_overlap:\n         is_horizontal_alignment = True # Default preference or could add more complex logic\n\n    # --- Apply Alignment-Specific Red Pixel Rules ---\n    if is_horizontal_alignment:\n        # Find shared rows using bounding boxes\n        shared_rows = list(range(max(maroon_min_r, orange_min_r), min(maroon_max_r, orange_max_r) + 1))\n        \n        # Define the column range strictly *between* the objects\n        between_start_col = min(maroon_max_c, orange_max_c) + 1\n        between_end_col = max(maroon_min_c, orange_min_c) # Exclusive end\n\n        target_cols = set()\n        if between_start_col < between_end_col: # Check if there is actually space between\n            # Find all white objects in the input\n            white_objects = find_objects(input_grid, WHITE)\n            \n            # Filter for white objects completely within the 'between' columns\n            for obj_coords in white_objects:\n                w_min_r, w_max_r, w_min_c, w_max_c = get_bounding_box(obj_coords)\n                if w_min_c >= between_start_col and w_max_c < between_end_col:\n                    # Collect the columns occupied by these objects\n                    for r_w, c_w in obj_coords:\n                        target_cols.add(c_w)\n\n        # Place Red pixels on shared rows in the target columns\n        for r in shared_rows:\n            for c in target_cols:\n                # Check bounds just in case, though target_cols should be valid\n                if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = RED\n\n    elif is_vertical_alignment:\n        # Find shared columns and the leftmost one\n        shared_cols = list(range(max(maroon_min_c, orange_min_c), min(maroon_max_c, orange_max_c) + 1))\n        if not shared_cols: \n             # This case indicates alignment detection might be flawed, but proceed assuming vertical\n             leftmost_shared_col = min(maroon_min_c, orange_min_c) # Best guess\n        else:\n             leftmost_shared_col = min(shared_cols)\n\n\n        # Iterate through rows to find those with >= 2 white segments\n        for r in range(height):\n            row_slice = input_grid[r, :]\n            white_segments = find_white_segments_on_row(row_slice)\n\n            if len(white_segments) >= 2:\n                # Find the rightmost white segment (one with the largest start column)\n                rightmost_segment = max(white_segments, key=lambda seg: seg[0])\n                right_white_left_col = rightmost_segment[0] # Leftmost column of the rightmost segment\n                col_left_of_right_white = right_white_left_col - 1\n\n                # Place Red pixel at leftmost shared column\n                if 0 <= r < height and 0 <= leftmost_shared_col < width:\n                     output_grid[r, leftmost_shared_col] = RED\n                     \n                # Place Red pixel at column left of the rightmost white segment start\n                if 0 <= r < height and 0 <= col_left_of_right_white < width:\n                     output_grid[r, col_left_of_right_white] = RED\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12252,
    "candidates_token_count": 2521,
    "total_token_count": 14773,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 48.320987,
  "retries": 1
}