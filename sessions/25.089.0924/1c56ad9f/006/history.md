
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 0 5 0 0 5 5 0 0 5 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 5 5 0 0 5 0 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 0 5 5 5 5 5 5 5 5 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 5 0 0 5 5 0 0 5 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The input grids contain a single large, connected object of a uniform color (green, red, gray, or azure) set against a white background. The object generally resembles a character or symbol constructed from segments. The output grid displays the same object, but its vertical columns appear to be shifted alternately up and down relative to their original positions. The background remains unchanged. The shifting pattern seems periodic based on the column's position within the object's horizontal extent.

*   **YAML Facts:**
    
```yaml
    task_description: Apply a periodic vertical shift to columns within the main colored object.
    
    elements:
      - element: grid
        description: A 2D array of pixels with integer values representing colors.
      - element: background
        properties:
          color: white (0)
          role: Static canvas for the object.
      - element: object
        description: A single, connected group of non-white pixels.
        properties:
          color: Varies (green, red, gray, azure in examples).
          shape: Resembles segmented characters or symbols.
          connectivity: Contiguous block of same-colored pixels.
        relationships:
          - type: located_on
            target: background
      - element: column
        description: A vertical line of pixels in the grid.

    actions:
      - action: identify_object
        description: Find the single connected non-white object and its color.
        inputs:
          - input_grid
        outputs:
          - object_pixels: List of (row, col) coordinates.
          - object_color: Integer color value.
          - object_min_col: Minimum column index occupied by the object.
          - object_max_col: Maximum column index occupied by the object.
      - action: calculate_shift
        description: Determine the vertical shift for a pixel based on its column index relative to the object's start.
        inputs:
          - column_index: The column index of the pixel.
          - object_min_col: The starting column index of the object.
        outputs:
          - vertical_shift: Integer value (+1 for down, -1 for up, 0 for no shift).
        logic: |
          relative_col = column_index - object_min_col
          if relative_col % 3 == 1:
            vertical_shift = 1  # Shift down
          elif relative_col % 3 == 2:
            vertical_shift = -1 # Shift up
          else: # relative_col % 3 == 0
            vertical_shift = 0  # No shift
      - action: apply_shift
        description: Move each pixel of the object vertically according to the calculated shift for its column.
        inputs:
          - input_grid
          - object_pixels
          - object_color
          - object_min_col
        outputs:
          - output_grid: The grid with the shifted object.
        logic: |
          Initialize output_grid same size as input_grid, filled with background color (white).
          For each pixel (r, c) in object_pixels:
            Calculate vertical_shift using calculate_shift(c, object_min_col).
            new_row = r + vertical_shift
            If new_row is within grid bounds:
              Set output_grid[new_row][c] = object_color

    relationships:
      - type: transformation_rule
        source: input_grid
        target: output_grid
        description: The object's pixels are vertically shifted based on their column's relative position within the object's horizontal span. Columns at relative index 0, 3, 6... are unchanged. Columns at relative index 1, 4, 7... are shifted down by 1. Columns at relative index 2, 5, 8... are shifted up by 1.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, filled entirely with the background color (white, 0).
    2.  Identify the single connected block of non-white pixels in the input grid. Determine its color (`object_color`) and the set of coordinates `(r, c)` it occupies.
    3.  Find the minimum column index (`min_col`) occupied by any pixel of the identified object.
    4.  Iterate through each pixel coordinate `(r, c)` belonging to the object identified in step 2.
    5.  For the current pixel at `(r, c)`, calculate its relative column index within the object: `relative_col = c - min_col`.
    6.  Determine the vertical shift amount (`dy`) based on the `relative_col`:
        *   If `relative_col` modulo 3 is 1, set `dy = 1` (shift down).
        *   If `relative_col` modulo 3 is 2, set `dy = -1` (shift up).
        *   Otherwise (if `relative_col` modulo 3 is 0), set `dy = 0` (no shift).
    7.  Calculate the target row for the shifted pixel: `new_r = r + dy`.
    8.  Check if the calculated `new_r` is a valid row index within the grid boundaries.
    9.  If `new_r` is valid, set the pixel at `(new_r, c)` in the output grid to the `object_color`.
    10. After iterating through all object pixels, the output grid contains the transformed object. Return the output grid.
```python
import numpy as np
from typing import List

"""
Transforms the input grid by identifying the single non-white object and applying a periodic vertical shift to its pixels based on their column position relative to the object's leftmost edge.

1. Find the non-white object pixels and their color.
2. Determine the minimum column index (leftmost edge) of the object.
3. For each object pixel at (row, col):
   a. Calculate the relative column index: relative_col = col - min_col.
   b. Determine the vertical shift (dy):
      - If relative_col % 3 == 1, dy = 1 (shift down).
      - If relative_col % 3 == 2, dy = -1 (shift up).
      - If relative_col % 3 == 0, dy = 0 (no shift).
   c. Calculate the new row: new_row = row + dy.
   d. If the new row is within the grid boundaries, place the object's color at (new_row, col) in the output grid.
4. The output grid starts filled with the background color (white, 0).
"""

def find_object_pixels(grid: np.ndarray) -> tuple[list[tuple[int, int]], int, int]:
    """
    Finds all pixels belonging to the first non-background object encountered.
    Assumes a single object color against a background color of 0.
    Returns the list of pixel coordinates, the object color, and the minimum column index.
    """
    object_pixels = []
    object_color = 0
    min_col = grid.shape[1] 
    max_col = -1 # Not strictly needed for the core logic, but good for bounding box understanding
    min_row = grid.shape[0]
    max_row = -1

    non_zero_indices = np.argwhere(grid != 0)
    
    if non_zero_indices.size == 0:
        # No object found, return empty list and defaults
        return [], 0, 0 

    # Assuming a single object color, get the color from the first non-zero pixel found
    first_r, first_c = non_zero_indices[0]
    object_color = grid[first_r, first_c]

    # Now find all pixels of that specific color and their bounds
    for r, c in non_zero_indices:
        if grid[r,c] == object_color: # Check if it matches the identified object color
            object_pixels.append((r, c))
            if c < min_col:
                min_col = c
            # Below are not strictly needed by the transform logic but useful for context
            # if c > max_col:
            #     max_col = c
            # if r < min_row:
            #     min_row = r
            # if r > max_row:
            #     max_row = r
        
    # If somehow the first non-zero wasn't the object, re-iterate (should not happen with task constraints)
    # This check ensures we only collect pixels of *one* specific non-background color.
    # For this specific task, we can likely simplify and just take *all* non-zero pixels,
    # assuming only one non-zero color exists. Let's refine based on that assumption.

    object_pixels = []
    object_color = 0
    min_col = grid.shape[1]
    
    non_zero_coords = list(zip(*np.where(grid != 0))) # More direct way to get coords

    if not non_zero_coords:
        return [], 0, 0

    # Get the color from the first non-zero coordinate
    object_color = grid[non_zero_coords[0][0], non_zero_coords[0][1]]

    # Collect all non-zero coords (assuming they are the same color) and find min_col
    for r, c in non_zero_coords:
        object_pixels.append((r, c))
        if c < min_col:
            min_col = c
            
    return object_pixels, object_color, min_col

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies a periodic vertical shift to the columns of the single non-white object.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    
    # Initialize output_grid with background color (0)
    output_np = np.zeros_like(input_np)

    # Find the object pixels, its color, and its starting column
    object_pixels, object_color, min_col = find_object_pixels(input_np)

    # If no object is found, return the empty grid
    if not object_pixels:
        return output_np.tolist()

    # Iterate through each pixel of the object
    for r, c in object_pixels:
        # Calculate the relative column index within the object's span
        relative_col = c - min_col
        
        # Determine the vertical shift based on the relative column index
        dy = 0 # Default no shift
        if relative_col % 3 == 1:
            dy = 1  # Shift down
        elif relative_col % 3 == 2:
            dy = -1 # Shift up
            
        # Calculate the new row position
        new_r = r + dy
        
        # Check if the new row is within the grid boundaries
        if 0 <= new_r < height:
            # Place the object pixel at the new position in the output grid
            output_np[new_r, c] = object_color

    # Convert the result back to a list of lists
    return output_np.tolist()
```
```python
import numpy as np
from typing import List, Tuple

"""
Transforms the input grid by applying a periodic vertical shift to the pixels of the single non-white object.
The shift pattern is determined by the column index relative to the object's leftmost edge (min_col).
- Columns where (col - min_col) % 3 == 0 remain unchanged.
- Columns where (col - min_col) % 3 == 1 are shifted down by 1 row.
- Columns where (col - min_col) % 3 == 2 are shifted up by 1 row.
The background remains white (0).
"""

def find_object_details(grid: np.ndarray) -> Tuple[List[Tuple[int, int]], int, int]:
    """
    Finds all pixels belonging to the single non-background object.
    Assumes a single object color against a background color of 0.
    
    Args:
        grid: The input numpy array representing the grid.

    Returns:
        A tuple containing:
        - A list of (row, col) coordinates of the object's pixels.
        - The integer color of the object.
        - The minimum column index (leftmost edge) occupied by the object.
        Returns ([], 0, grid.shape[1]) if no object is found.
    """
    object_pixels = []
    object_color = 0
    min_col = grid.shape[1] # Initialize min_col to a value larger than any possible index

    # Find coordinates of all non-zero pixels
    non_zero_coords = list(zip(*np.where(grid != 0)))

    if not non_zero_coords:
        # No object found
        return [], 0, min_col 

    # Determine the object color from the first non-zero pixel found
    # Assumes only one non-zero color exists in the grid per task description
    object_color = grid[non_zero_coords[0][0], non_zero_coords[0][1]]

    # Collect all pixels belonging to the object and find the minimum column
    for r, c in non_zero_coords:
        # Although we assume a single color, this check ensures correctness if that assumption failed
        if grid[r, c] == object_color: 
            object_pixels.append((r, c))
            if c < min_col:
                min_col = c
            
    # Check if min_col was updated (i.e., object was actually found)
    # If non_zero_coords was not empty, min_col should have been updated.
    # If only background color exists (0), min_col will remain grid.shape[1].
    if min_col == grid.shape[1] and object_pixels: 
         # This case should theoretically not happen given the non_zero_coords check,
         # but as a safeguard, recalculate min_col if needed.
         min_col = min(c for r,c in object_pixels)

    return object_pixels, object_color, min_col

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the periodic vertical column shift transformation to the input grid.
    
    Args:
        input_grid: A list of lists representing the input grid.
        
    Returns:
        A list of lists representing the transformed grid.
    """
    # Convert input to numpy array for efficient operations
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    
    # Initialize the output grid with the background color (0)
    output_np = np.zeros_like(input_np)

    # Find the object's pixels, color, and its leftmost column index
    object_pixels, object_color, min_col = find_object_details(input_np)

    # If no object is found, return the empty (background-filled) grid
    if not object_pixels:
        return output_np.tolist()

    # Iterate through each pixel belonging to the object
    for r, c in object_pixels:
        # Calculate the column index relative to the object's left edge
        relative_col = c - min_col
        
        # Determine the vertical shift (dy) based on the relative column index pattern
        dy = 0 # Default: no shift for relative_col % 3 == 0
        if relative_col % 3 == 1:
            dy = 1  # Shift down
        elif relative_col % 3 == 2:
            dy = -1 # Shift up
            
        # Calculate the new row position after applying the shift
        new_r = r + dy
        
        # Check if the new row position is within the grid's height boundaries
        if 0 <= new_r < height:
            # Place the object's pixel at the calculated new position in the output grid
            output_np[new_r, c] = object_color

    # Convert the resulting numpy array back to a list of lists format
    return output_np.tolist()
```
```python
import numpy as np
from typing import List, Tuple

"""
Transforms the input grid by vertically shifting pixels of the single colored object based on a periodic pattern determined by their column index relative to the object's left edge.

1. Identify the single non-white object, its color, its pixels' coordinates, and its leftmost column index (min_col).
2. Initialize an output grid of the same dimensions as the input, filled with the background color (white, 0).
3. For each pixel (r, c) of the identified object:
   a. Calculate the relative column index: relative_col = c - min_col.
   b. Determine the vertical shift (dy) based on the pattern:
      - dy = 0 if relative_col % 3 == 0
      - dy = 1 if relative_col % 3 == 1 (shift down)
      - dy = -1 if relative_col % 3 == 2 (shift up)
   c. Calculate the target row: new_r = r + dy.
   d. If the target row new_r is within the grid's boundaries, set the pixel at (new_r, c) in the output grid to the object's color.
4. Return the modified output grid.
"""

def find_object_details(grid: np.ndarray) -> Tuple[List[Tuple[int, int]], int, int]:
    """
    Finds all pixels belonging to the single non-background object.
    Assumes a single object color against a background color of 0.
    
    Args:
        grid: The input numpy array representing the grid.

    Returns:
        A tuple containing:
        - A list of (row, col) coordinates of the object's pixels.
        - The integer color of the object.
        - The minimum column index (leftmost edge) occupied by the object.
        Returns ([], 0, grid.shape[1]) if no object is found.
    """
    object_pixels = []
    object_color = 0
    # Initialize min_col to a value larger than any possible index
    min_col = grid.shape[1] 

    # Find coordinates of all non-zero (non-background) pixels
    non_zero_coords = list(zip(*np.where(grid != 0)))

    if not non_zero_coords:
        # No object found, return defaults
        return [], 0, min_col 

    # Determine the object color from the first non-zero pixel found
    # Assumes only one non-zero color exists in the grid per task description
    first_r, first_c = non_zero_coords[0]
    object_color = grid[first_r, first_c]

    # Collect all pixels belonging to the identified object color and find the minimum column
    for r, c in non_zero_coords:
        # Ensure the pixel has the determined object color (robustness)
        if grid[r, c] == object_color: 
            object_pixels.append((r, c))
            # Update min_col if this pixel's column is smaller
            if c < min_col:
                min_col = c
            
    # Final check: if min_col wasn't updated but we found pixels, recalculate.
    # This handles edge cases, though unlikely given the np.where check.
    if min_col == grid.shape[1] and object_pixels: 
         min_col = min(c for r,c in object_pixels)

    return object_pixels, object_color, min_col

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the periodic vertical column shift transformation to the input grid.
    
    Args:
        input_grid: A list of lists representing the input grid.
        
    Returns:
        A list of lists representing the transformed grid.
    """
    # Convert input list of lists to a numpy array for efficient processing
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    
    # Step 1: Identify object details
    object_pixels, object_color, min_col = find_object_details(input_np)

    # Step 2: Initialize the output grid with the background color (0)
    output_np = np.zeros_like(input_np)

    # If no object was found, return the empty (background-filled) grid
    if not object_pixels:
        return output_np.tolist()

    # Step 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10: Iterate, calculate shift, place pixel
    for r, c in object_pixels:
        # Step 6: Calculate the column index relative to the object's left edge
        relative_col = c - min_col
        
        # Step 7: Determine the vertical shift (dy) based on the relative column index pattern
        remainder = relative_col % 3
        if remainder == 1:
            dy = 1  # Shift down
        elif remainder == 2:
            dy = -1 # Shift up
        else: # remainder == 0
            dy = 0 # No shift
            
        # Step 8: Calculate the new row position after applying the shift
        new_r = r + dy
        
        # Step 9: Check if the new row position is within the grid's height boundaries
        if 0 <= new_r < height:
            # Step 10: Place the object's pixel at the calculated new position in the output grid
            output_np[new_r, c] = object_color

    # Step 11: Convert the resulting numpy array back to a list of lists format
    return output_np.tolist()
```
