
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0
0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 0 5 0 0 5 5 0 0 5 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 5 5 0 0 5 0 0 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 0 0 5 5 5 5 5 5 5 5 0 0
0 0 0 0 5 0 0 5 5 0 0 5 0 0 0
0 0 0 5 0 0 5 5 0 0 5 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The input grids contain a single large, connected object of a uniform color (green, red, gray, or azure) set against a white background. The object generally resembles a character or symbol constructed from segments. The output grid displays the same object, but its vertical columns appear to be shifted alternately up and down relative to their original positions. The background remains unchanged. The shifting pattern seems periodic based on the column's position within the object's horizontal extent.

*   **YAML Facts:**
    
```yaml
    task_description: Apply a periodic vertical shift to columns within the main colored object.
    
    elements:
      - element: grid
        description: A 2D array of pixels with integer values representing colors.
      - element: background
        properties:
          color: white (0)
          role: Static canvas for the object.
      - element: object
        description: A single, connected group of non-white pixels.
        properties:
          color: Varies (green, red, gray, azure in examples).
          shape: Resembles segmented characters or symbols.
          connectivity: Contiguous block of same-colored pixels.
        relationships:
          - type: located_on
            target: background
      - element: column
        description: A vertical line of pixels in the grid.

    actions:
      - action: identify_object
        description: Find the single connected non-white object and its color.
        inputs:
          - input_grid
        outputs:
          - object_pixels: List of (row, col) coordinates.
          - object_color: Integer color value.
          - object_min_col: Minimum column index occupied by the object.
          - object_max_col: Maximum column index occupied by the object.
      - action: calculate_shift
        description: Determine the vertical shift for a pixel based on its column index relative to the object's start.
        inputs:
          - column_index: The column index of the pixel.
          - object_min_col: The starting column index of the object.
        outputs:
          - vertical_shift: Integer value (+1 for down, -1 for up, 0 for no shift).
        logic: |
          relative_col = column_index - object_min_col
          if relative_col % 3 == 1:
            vertical_shift = 1  # Shift down
          elif relative_col % 3 == 2:
            vertical_shift = -1 # Shift up
          else: # relative_col % 3 == 0
            vertical_shift = 0  # No shift
      - action: apply_shift
        description: Move each pixel of the object vertically according to the calculated shift for its column.
        inputs:
          - input_grid
          - object_pixels
          - object_color
          - object_min_col
        outputs:
          - output_grid: The grid with the shifted object.
        logic: |
          Initialize output_grid same size as input_grid, filled with background color (white).
          For each pixel (r, c) in object_pixels:
            Calculate vertical_shift using calculate_shift(c, object_min_col).
            new_row = r + vertical_shift
            If new_row is within grid bounds:
              Set output_grid[new_row][c] = object_color

    relationships:
      - type: transformation_rule
        source: input_grid
        target: output_grid
        description: The object's pixels are vertically shifted based on their column's relative position within the object's horizontal span. Columns at relative index 0, 3, 6... are unchanged. Columns at relative index 1, 4, 7... are shifted down by 1. Columns at relative index 2, 5, 8... are shifted up by 1.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, filled entirely with the background color (white, 0).
    2.  Identify the single connected block of non-white pixels in the input grid. Determine its color (`object_color`) and the set of coordinates `(r, c)` it occupies.
    3.  Find the minimum column index (`min_col`) occupied by any pixel of the identified object.
    4.  Iterate through each pixel coordinate `(r, c)` belonging to the object identified in step 2.
    5.  For the current pixel at `(r, c)`, calculate its relative column index within the object: `relative_col = c - min_col`.
    6.  Determine the vertical shift amount (`dy`) based on the `relative_col`:
        *   If `relative_col` modulo 3 is 1, set `dy = 1` (shift down).
        *   If `relative_col` modulo 3 is 2, set `dy = -1` (shift up).
        *   Otherwise (if `relative_col` modulo 3 is 0), set `dy = 0` (no shift).
    7.  Calculate the target row for the shifted pixel: `new_r = r + dy`.
    8.  Check if the calculated `new_r` is a valid row index within the grid boundaries.
    9.  If `new_r` is valid, set the pixel at `(new_r, c)` in the output grid to the `object_color`.
    10. After iterating through all object pixels, the output grid contains the transformed object. Return the output grid.
