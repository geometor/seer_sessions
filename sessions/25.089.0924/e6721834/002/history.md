
## train_1

**input:**
```
6 6 6 6 6 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
6 6 6 6 6 6 6 6 6 6 1 1 1 1 1 8 1 8 1 1
6 6 3 3 3 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
6 6 8 3 8 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
6 6 3 3 3 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
6 6 3 3 3 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
6 6 6 6 6 6 6 6 6 6 1 1 1 1 2 1 1 1 1 1
6 6 6 6 6 6 6 6 6 6 1 1 2 1 1 1 1 1 1 1
6 6 6 6 3 3 3 2 6 6 1 1 1 1 1 1 1 1 1 1
6 6 6 6 3 2 3 3 6 6 1 1 1 1 1 1 1 1 1 1
6 6 6 6 3 3 3 3 6 6 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 8 3 8 1 1
1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 3 3 3 2 1 1 1 1 1
1 3 2 3 3 1 1 1 1 1
1 3 3 3 3 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 2 1 1 1 8 8 8 8 8 8 8 8
8 8 1 2 1 1 1 2 1 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 3 1 8 8 8 8 8 8 8 8 8 8 8
8 8 1 3 1 1 8 8 8 8 1 1 1 2 1 8 8
8 8 1 1 1 1 8 8 8 8 1 2 1 2 1 8 8
8 8 1 3 1 1 8 8 8 8 1 2 1 1 1 8 8
8 8 1 1 3 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 2 1 1 1 0 0
0 0 0 0 0 0 0 0 1 2 1 1 1 2 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 3 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 3 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 8
4 4 4 4 4 4 4 4 8 1 1 1 8 8 8 8
4 4 4 4 2 4 4 4 8 2 1 1 8 8 8 8
4 4 4 4 4 4 4 4 8 1 1 1 8 8 8 8
4 4 4 4 2 4 4 4 8 2 1 1 8 8 8 8
4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 8
4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 8
4 4 4 4 4 4 4 4 8 8 1 1 6 8 8 8
4 4 6 4 4 4 4 4 8 8 1 1 1 8 8 8
4 4 4 4 4 4 4 4 8 8 8 8 8 8 8 8
```


**output:**
```
4 4 4 4 4 4 4 4
4 4 4 4 1 1 1 4
4 4 4 4 2 1 1 4
4 4 4 4 1 1 1 4
4 4 4 4 2 1 1 4
4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4
1 1 6 4 4 4 4 4
1 1 1 4 4 4 4 4
```

Okay, let's break down this task.

**Perception of Task Elements**

1.  **Input Structure:** The input grids appear to be composed of two distinct regions, often separated vertically or horizontally into roughly equal halves.
2.  **Background Colors:** Each half is dominated by a single background color.
3.  **Foreground Objects:** Within at least one, and often both halves, there are foreground objects or pixels whose colors differ from the background color of that half.
4.  **Output Structure:** The output grid's dimensions always match the dimensions of one of the halves identified in the input.
5.  **Transformation:** The core transformation involves selecting foreground objects/pixels from one specific half of the input and placing them onto a new background in the output. The color of this new background is taken from the *other* half of the input.
6.  **Selection Logic:** The half whose foreground objects are preserved seems to be the one containing more "significant" or numerous foreground pixels compared to the other half. The background color of the *less* significant half (in terms of foreground content) becomes the background of the output.

**YAML Facts**


```yaml
task_description: Overlay foreground objects from one half of the input grid onto the background color of the other half.

definitions:
  half_A: The first half of the input grid after splitting.
  half_B: The second half of the input grid after splitting.
  bg_A: The most frequent color in half_A.
  bg_B: The most frequent color in half_B.
  foreground_A: Pixels in half_A whose color is not bg_A.
  foreground_B: Pixels in half_B whose color is not bg_B.
  source_half: The half (A or B) containing more foreground pixels.
  target_half: The half (A or B) containing fewer foreground pixels.
  bg_source: The background color of the source_half.
  bg_target: The background color of the target_half.
  output_grid: The resulting grid after transformation.

grid_properties:
  - input_grid: Variable dimensions (height H, width W).
  - output_grid: Dimensions match the dimensions of one input half (e.g., H/2 x W, H x W/2).

processing_steps:
  - step: Determine split axis based on input dimensions.
      - if H > W: Split horizontally into top (A) and bottom (B).
      - if W > H: Split vertically into left (A) and right (B).
      - if H == W: Split vertically into left (A) and right (B).
  - step: Identify background colors bg_A and bg_B by finding the most frequent color in each half.
  - step: Count the number of foreground pixels in each half (count_A, count_B).
  - step: Determine source_half and target_half based on counts (source has higher count).
  - step: Determine bg_source and bg_target based on which half is source/target.
  - step: Create output_grid with dimensions of one half, filled with bg_target.
  - step: Iterate through source_half. For each pixel P at relative coordinates (r, c):
      - if color(P) is not bg_source:
          - Set output_grid pixel at (r, c) to color(P).

examples:
  - example: train_1
    input_dims: 11x20
    split: Vertical (Left=A, Right=B)
    bg_A: gray(6)
    bg_B: blue(1)
    count_A: > count_B
    source_half: A (Left)
    target_half: B (Right)
    bg_source: gray(6)
    bg_target: blue(1)
    output_dims: 11x10
    output_bg: blue(1)
    output_fg: foreground_A pixels at original relative positions.
  - example: train_2
    input_dims: 30x17
    split: Horizontal (Top=A, Bottom=B)
    bg_A: azure(8)
    bg_B: white(0)
    count_A: > count_B
    source_half: A (Top)
    target_half: B (Bottom)
    bg_source: azure(8)
    bg_target: white(0)
    output_dims: 15x17
    output_bg: white(0)
    output_fg: foreground_A pixels at original relative positions.
  - example: train_3
    input_dims: 10x16
    split: Vertical (Left=A, Right=B)
    bg_A: yellow(4)
    bg_B: azure(8)
    count_B: > count_A
    source_half: B (Right)
    target_half: A (Left)
    bg_source: azure(8)
    bg_target: yellow(4)
    output_dims: 10x8
    output_bg: yellow(4)
    output_fg: foreground_B pixels at original relative positions.

```


**Natural Language Program**

1.  Analyze the dimensions of the input grid (Height H, Width W).
2.  Divide the input grid into two equal halves. If H > W, split horizontally (Top half, Bottom half). Otherwise (W >= H), split vertically (Left half, Right half).
3.  For each half, determine its background color by finding the most frequent color within that half.
4.  For each half, count the number of pixels that are *not* its background color (these are the foreground pixels).
5.  Identify the "source half" as the half with the greater number of foreground pixels. The other half is the "target half".
6.  Note the background color of the source half (`bg_source`) and the background color of the target half (`bg_target`).
7.  Create a new output grid with the same dimensions as one of the halves.
8.  Fill the entire output grid with the `bg_target` color.
9.  Iterate through each pixel in the source half of the input grid. If a pixel's color is different from `bg_source`, copy that pixel's color to the same relative position within the output grid, overwriting the `bg_target` color at that position.
10. The final output grid is the result.
```python
import numpy as np
from collections import Counter

def find_background_color(grid_half):
  """Finds the most frequent color in a grid section."""
  if grid_half.size == 0:
      # Handle empty grid sections if they could occur
      return 0 # Default to white or raise an error
  colors, counts = np.unique(grid_half, return_counts=True)
  return colors[np.argmax(counts)]

def count_foreground_pixels(grid_half, background_color):
  """Counts pixels that are not the background color."""
  if grid_half.size == 0:
      return 0
  return np.sum(grid_half != background_color)

def transform(input_grid):
  """
  Transforms the input grid by splitting it into two halves, identifying the half
  with more foreground pixels (source half) and the other half (target half).
  The output grid has the dimensions of one half, the background color of the
  target half, and the foreground pixels of the source half overlaid onto it.
  """
  # Convert input to numpy array for easier manipulation
  input_np = np.array(input_grid, dtype=int)
  H, W = input_np.shape

  # Determine split axis and define the two halves
  if H > W:
      # Split horizontally
      mid_h = H // 2
      # np.array_split handles potential odd dimensions gracefully
      halves = np.array_split(input_np, 2, axis=0)
      half_A = halves[0] # Top
      half_B = halves[1] # Bottom
      # Ensure consistent shape for output (take the shape of the first half)
      # In case of odd height, the first half might be smaller.
      # Let's adjust: target shape should be the shape of the *source* half later.
      # For now, just get the halves.
      output_shape = half_A.shape if H % 2 == 0 else halves[0].shape # default to first half shape
                                                                      # this will be updated later based on source

  else:
      # Split vertically (includes H == W case)
      mid_w = W // 2
      halves = np.array_split(input_np, 2, axis=1)
      half_A = halves[0] # Left
      half_B = halves[1] # Right
      # Get shape for output
      output_shape = half_A.shape if W % 2 == 0 else halves[0].shape # default to first half shape
                                                                      # this will be updated later based on source


  # Find background color for each half
  bg_A = find_background_color(half_A)
  bg_B = find_background_color(half_B)

  # Count foreground pixels in each half
  count_A = count_foreground_pixels(half_A, bg_A)
  count_B = count_foreground_pixels(half_B, bg_B)

  # Determine source and target halves based on foreground pixel count
  # If counts are equal, default to A as source (based on train_1 logic where left > right)
  # Although test cases imply one count is strictly greater. Let's stick to >= for robustness.
  if count_A >= count_B:
      source_half = half_A
      bg_source = bg_A
      # target_half = half_B # Not explicitly needed
      bg_target = bg_B
  else:
      source_half = half_B
      bg_source = bg_B
      # target_half = half_A # Not explicitly needed
      bg_target = bg_A

  # Determine the correct output shape based on the source half
  output_shape = source_half.shape

  # Create the output grid, initialized with the target background color
  output_grid = np.full(output_shape, bg_target, dtype=int)

  # Iterate through the source half and overlay its foreground pixels
  for r in range(source_half.shape[0]):
      for c in range(source_half.shape[1]):
          pixel_value = source_half[r, c]
          # If the pixel in the source half is not its background color...
          if pixel_value != bg_source:
              # ...place it onto the output grid at the same relative position
              output_grid[r, c] = pixel_value

  # Convert back to list of lists for standard ARC output format
  return output_grid.tolist()
```
