{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation rule:\n1. Find all non-background (non-zero) pixels in the input grid.\n2. If no non-zero pixels exist, return the input grid unchanged.\n3. Identify the color (`C`) of these non-zero pixels (assuming they are all the same color).\n4. Determine the minimum bounding box enclosing all pixels of color `C`.\n5. Create an output grid by copying the input grid.\n6. Starting with an expansion distance `k = 2`, draw concentric rectangular frames around the bounding box using color `C`.\n7. Each subsequent frame increases the expansion distance by 2 (k = 4, 6, 8, ...).\n8. Frames are drawn by calculating the expanded bounding box coordinates (min_row - k, max_row + k, min_col - k, max_col + k).\n9. Only draw pixels that fall within the grid boundaries.\n10. Continue drawing frames with increasing `k` until the expanded frame is entirely outside the grid boundaries.\n11. Return the modified output grid.\n\"\"\"\n\ndef find_non_background_pixels(grid):\n    \"\"\"Finds coordinates and the single color of non-background pixels.\"\"\"\n    non_zero_coords = np.argwhere(grid != 0)\n    if len(non_zero_coords) == 0:\n        return None, None, None # No non-background pixels found\n    \n    # Assuming all non-background pixels have the same color\n    color = grid[non_zero_coords[0][0], non_zero_coords[0][1]]\n    \n    # Separate rows and columns\n    rows = non_zero_coords[:, 0]\n    cols = non_zero_coords[:, 1]\n    \n    return rows, cols, color\n\ndef calculate_bounding_box(rows, cols):\n    \"\"\"Calculates the min/max row/col for a set of coordinates.\"\"\"\n    if rows is None or len(rows) == 0:\n        return None # Should not happen if find_non_background_pixels checks first\n        \n    min_r = np.min(rows)\n    max_r = np.max(rows)\n    min_c = np.min(cols)\n    max_c = np.max(cols)\n    \n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Draws concentric frames with spacing 2 around the bounding box of non-zero pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Find non-background pixels and their color\n    rows, cols, color = find_non_background_pixels(input_np)\n    \n    # If no non-background pixels, return the original grid\n    if rows is None:\n        return input_grid\n        \n    # Calculate the bounding box of the initial pixels\n    min_r, max_r, min_c, max_c = calculate_bounding_box(rows, cols)\n    \n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_np)\n    \n    # Start drawing frames with expansion k=2, incrementing by 2\n    k = 2\n    while True:\n        # Calculate coordinates of the expanded box for the current k\n        top_row = min_r - k\n        left_col = min_c - k\n        bottom_row = max_r + k\n        right_col = max_c + k\n        \n        # Check if the entire expanded box is outside the grid boundaries\n        # If the bottom is above the top edge OR the top is below the bottom edge OR\n        # the right is left of the left edge OR the left is right of the right edge\n        if bottom_row < 0 or top_row >= height or right_col < 0 or left_col >= width:\n            # The box is completely outside, no more frames can be drawn\n            break\n            \n        frame_drawn = False # Flag to check if any part of the frame was within bounds\n            \n        # Draw the frame border, clipping to grid boundaries\n        \n        # Top border\n        if 0 <= top_row < height:\n            for c in range(max(0, left_col), min(width, right_col + 1)):\n                 output_grid[top_row, c] = color\n                 frame_drawn = True\n                 \n        # Bottom border\n        if 0 <= bottom_row < height:\n             for c in range(max(0, left_col), min(width, right_col + 1)):\n                 output_grid[bottom_row, c] = color\n                 frame_drawn = True\n\n        # Left border (excluding corners already drawn)\n        if 0 <= left_col < width:\n            for r in range(max(0, top_row + 1), min(height, bottom_row)):\n                 output_grid[r, left_col] = color\n                 frame_drawn = True\n\n        # Right border (excluding corners already drawn)\n        if 0 <= right_col < width:\n            for r in range(max(0, top_row + 1), min(height, bottom_row)):\n                 output_grid[r, right_col] = color\n                 frame_drawn = True\n\n        # If no part of the frame could be drawn (e.g., k grew very large), stop.\n        # This is an alternative break condition, the first one should catch most cases.\n        if not frame_drawn and k > max(height, width): # Heuristic break\n             break\n\n        # Increment the expansion distance for the next frame\n        k += 2\n        \n    # Return the final grid (converted back to list of lists if necessary for ARC format)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8832,
    "candidates_token_count": 1357,
    "total_token_count": 10189,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.582174,
  "retries": 1
}