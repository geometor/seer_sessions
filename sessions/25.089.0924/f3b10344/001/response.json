{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nConnect adjacent objects of the same color by filling the intervening white space with azure (8).\n\n1. Identify all distinct objects (contiguous blocks of the same non-white color).\n2. For each pair of objects:\n   a. Check if they have the same color.\n   b. Check if they are adjacent (separated only by a direct horizontal or vertical path of white pixels).\n3. If both conditions are met, fill the white pixels on the path between them with azure (8).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies all contiguous objects of the same non-white color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of objects, where each object is represented as a dictionary\n              containing its 'color' and 'coords' (a set of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-white and not yet visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Breadth-First Search (BFS) to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor has the same color and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'color': color, 'coords': coords})\n                \n    return objects\n\ndef check_adjacency_and_find_path(obj1, obj2, grid):\n    \"\"\"\n    Checks if two objects are adjacent horizontally or vertically with only white pixels between them.\n    Returns the coordinates of the white path if adjacent, otherwise an empty set.\n\n    Args:\n        obj1 (dict): The first object {'color': int, 'coords': set}.\n        obj2 (dict): The second object {'color': int, 'coords': set}.\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        set: A set of (row, col) tuples representing the white path, or empty set if not adjacent.\n    \"\"\"\n    rows, cols = grid.shape\n    path_coords = set()\n    \n    coords1 = obj1['coords']\n    coords2 = obj2['coords']\n\n    # Check for horizontal adjacency\n    for r1, c1 in coords1:\n        # Check right\n        c_check = c1 + 1\n        path_segment = set()\n        while 0 <= c_check < cols and grid[r1, c_check] == 0:\n            path_segment.add((r1, c_check))\n            c_check += 1\n        if 0 <= c_check < cols and (r1, c_check) in coords2:\n             path_coords.update(path_segment)\n             \n        # Check left (only need one direction check per pair, but ensures completeness)\n        c_check = c1 - 1\n        path_segment = set()\n        while 0 <= c_check < cols and grid[r1, c_check] == 0:\n             path_segment.add((r1, c_check))\n             c_check -= 1\n        if 0 <= c_check < cols and (r1, c_check) in coords2:\n             path_coords.update(path_segment)\n\n\n    # Check for vertical adjacency\n    for r1, c1 in coords1:\n        # Check down\n        r_check = r1 + 1\n        path_segment = set()\n        while 0 <= r_check < rows and grid[r_check, c1] == 0:\n            path_segment.add((r_check, c1))\n            r_check += 1\n        if 0 <= r_check < rows and (r_check, c1) in coords2:\n            path_coords.update(path_segment)\n\n        # Check up (only need one direction check per pair, but ensures completeness)\n        r_check = r1 - 1\n        path_segment = set()\n        while 0 <= r_check < rows and grid[r_check, c1] == 0:\n             path_segment.add((r_check, c1))\n             r_check -= 1\n        if 0 <= r_check < rows and (r_check, c1) in coords2:\n             path_coords.update(path_segment)\n             \n    # Filter path_coords to ensure they are *strictly* between the objects\n    # This basic check might add paths alongside objects if they touch corners,\n    # but for straight lines between rectangles it should work.\n    # A more robust check would verify the entire line segment between bounding boxes.\n    # For now, let's rely on the fact that BFS starts from a pixel in obj1 and ends on a pixel in obj2.\n\n    # Refined check: ensure the path connects the two objects directly\n    # Check if any path pixel is adjacent to both object 1 and object 2 pixels (indirectly via path)\n    \n    # Bounding box approach for path validation might be better:\n    min_r1, min_c1 = min(r for r,c in coords1), min(c for r,c in coords1)\n    max_r1, max_c1 = max(r for r,c in coords1), max(c for r,c in coords1)\n    min_r2, min_c2 = min(r for r,c in coords2), min(c for r,c in coords2)\n    max_r2, max_c2 = max(r for r,c in coords2), max(c for r,c in coords2)\n    \n    final_path = set()\n\n    # Check Horizontal Gap\n    # Case 1: obj1 is left of obj2\n    if max_c1 < min_c2:\n        # Check if rows overlap\n        overlap_rows = range(max(min_r1, min_r2), min(max_r1, max_r2) + 1)\n        if overlap_rows:\n            # Iterate columns between objects\n            for c_path in range(max_c1 + 1, min_c2):\n                is_clear_column = True\n                path_col_segment = set()\n                # Check all cells in this column within the overlapping row range\n                for r_path in overlap_rows:\n                     # Check if cell is within the direct path between adjacent faces\n                    is_adjacent_to_obj1 = (r_path, c_path - 1) in coords1 if c_path - 1 >= 0 else False\n                    is_adjacent_to_obj2 = (r_path, c_path + 1) in coords2 if c_path + 1 < cols else False\n                    # More generally, check if this row in obj1 and obj2 are aligned\n                    row_in_obj1 = any((r_path, c) in coords1 for c in range(min_c1, max_c1+1))\n                    row_in_obj2 = any((r_path, c) in coords2 for c in range(min_c2, max_c2+1))\n\n                    if row_in_obj1 and row_in_obj2:\n                        if grid[r_path, c_path] == 0:\n                             path_col_segment.add((r_path, c_path))\n                        else:\n                            is_clear_column = False\n                            break # Non-white pixel found in the path column segment\n                if is_clear_column and path_col_segment: # Add segment if column was clear\n                     # Need to check if *this specific path* connects adjacent faces\n                     # Check if the segment boundaries touch the objects\n                    connects = False\n                    for r_p, c_p in path_col_segment:\n                         if (r_p, c_p-1) in coords1 or (r_p, c_p+1) in coords2:\n                              connects = True\n                              break\n                    if connects:\n                         final_path.update(path_col_segment)\n\n\n    # Case 2: obj2 is left of obj1 (swap roles for simplicity in logic)\n    elif max_c2 < min_c1:\n         return check_adjacency_and_find_path(obj2, obj1, grid) # Recursive call with swapped args\n\n\n    # Check Vertical Gap\n    # Case 3: obj1 is above obj2\n    elif max_r1 < min_r2:\n         # Check if columns overlap\n        overlap_cols = range(max(min_c1, min_c2), min(max_c1, max_c2) + 1)\n        if overlap_cols:\n            # Iterate rows between objects\n            for r_path in range(max_r1 + 1, min_r2):\n                is_clear_row = True\n                path_row_segment = set()\n                # Check all cells in this row within the overlapping column range\n                for c_path in overlap_cols:\n                    # Check if cell is within the direct path between adjacent faces\n                    col_in_obj1 = any((r, c_path) in coords1 for r in range(min_r1, max_r1+1))\n                    col_in_obj2 = any((r, c_path) in coords2 for r in range(min_r2, max_r2+1))\n                    \n                    if col_in_obj1 and col_in_obj2:\n                         if grid[r_path, c_path] == 0:\n                              path_row_segment.add((r_path, c_path))\n                         else:\n                              is_clear_row = False\n                              break # Non-white pixel found in the path row segment\n                if is_clear_row and path_row_segment: # Add segment if row was clear\n                     # Check if the segment boundaries touch the objects\n                     connects = False\n                     for r_p, c_p in path_row_segment:\n                           if (r_p-1, c_p) in coords1 or (r_p+1, c_p) in coords2:\n                                connects = True\n                                break\n                     if connects:\n                          final_path.update(path_row_segment)\n\n\n    # Case 4: obj2 is above obj1\n    elif max_r2 < min_r1:\n        return check_adjacency_and_find_path(obj2, obj1, grid) # Recursive call with swapped args\n\n    return final_path\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by connecting adjacent objects of the same color\n    with an azure path.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all colored objects in the input grid\n    objects = find_objects(input_grid)\n    \n    num_objects = len(objects)\n    \n    # Iterate through all unique pairs of objects\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            obj1 = objects[i]\n            obj2 = objects[j]\n            \n            # Check if the objects have the same color\n            if obj1['color'] == obj2['color']:\n                # Check if they are adjacent and get the path coordinates\n                path = check_adjacency_and_find_path(obj1, obj2, input_grid) # Use input grid for checks\n                \n                # If a path exists, fill it with azure (8) in the output grid\n                if path:\n                    for r, c in path:\n                        output_grid[r, c] = 8\n                        \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12104,
    "candidates_token_count": 2914,
    "total_token_count": 15018,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 113.023393,
  "retries": 2
}