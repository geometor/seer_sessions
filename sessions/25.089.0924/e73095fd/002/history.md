
## train_1

**input:**
```
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 5 0 0 5 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 5 0
0 0 0 5 0 0 0 5 5 5 5 5 5 5 5 0
0 0 0 5 0 0 0 5 0 0 0 0 0 0 5 0
0 0 0 5 5 5 5 5 0 0 0 0 0 0 5 5
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 5 0 0 5 5
0 0 0 5 4 4 4 5 0 0 0 5 0 0 5 4
0 0 0 5 4 4 4 5 5 5 5 5 5 5 5 4
0 0 0 5 4 4 4 5 0 0 0 0 0 0 5 4
0 0 0 5 5 5 5 5 0 0 0 0 0 0 5 5
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 5 5
5 5 0 0 0 5 5 5 5 0 0 0 0 5 0 0 0 5 0
0 5 5 5 5 5 0 0 5 5 5 5 5 5 5 5 5 5 0
5 5 0 0 0 5 0 0 5 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 5 0 0 5 0 0 0 0 5 0 0 0 5 5
0 0 0 0 0 5 0 0 5 0 0 5 5 5 5 0 0 0 0
0 0 0 0 0 5 0 0 5 0 0 5 0 0 5 0 0 0 0
0 0 0 0 0 5 5 5 5 0 0 5 0 0 5 5 5 5 5
0 0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 5 5
5 5 0 0 0 5 5 5 5 0 0 0 0 5 0 0 0 5 4
4 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 4
5 5 0 0 0 5 4 4 5 0 0 0 0 5 0 0 0 5 4
0 0 0 0 0 5 4 4 5 0 0 0 0 5 0 0 0 5 5
0 0 0 0 0 5 4 4 5 0 0 5 5 5 5 0 0 0 0
0 0 0 0 0 5 4 4 5 0 0 5 4 4 5 0 0 0 0
0 0 0 0 0 5 5 5 5 0 0 5 4 4 5 5 5 5 5
0 0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 5 5 5 5 0
5 5 5 5 5 5 5 5 5 5 5 5 0 0 0 5 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 5 5
0 0 0 5 5 5 5 0 0 0 0 5 0 0 0 5 0
5 5 5 5 0 0 5 0 0 0 0 5 5 5 5 5 0
0 0 0 5 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 0 0 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0
5 5 5 5 5 5 5 5 5 5 5 0 0 5 0 0 0
0 0 0 0 0 5 0 0 0 0 5 0 0 5 0 0 0
0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0
```


**output:**
```
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 5 5 5 5 0
5 5 5 5 5 5 5 5 5 5 5 5 4 4 4 5 0
0 0 0 0 0 5 0 0 0 0 0 5 4 4 4 5 5
0 0 0 5 5 5 5 0 0 0 0 5 4 4 4 5 0
5 5 5 5 4 4 5 0 0 0 0 5 5 5 5 5 0
0 0 0 5 4 4 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 4 4 5 0 0 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0
5 5 5 5 5 5 5 5 5 5 5 4 4 5 0 0 0
0 0 0 0 0 5 0 0 0 0 5 4 4 5 0 0 0
0 0 0 0 0 5 0 0 0 0 5 5 5 5 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0
```

*   **Perception**:
    *   The input grids contain white (0) and gray (5) pixels.
    *   The gray pixels often form closed or partially closed shapes or boundaries.
    *   The output grids are identical to the input grids, except that some white (0) pixels have been changed to yellow (4).
    *   The white pixels that change to yellow are those located *inside* regions completely enclosed by gray pixels.
    *   White pixels not enclosed by gray pixels remain white.
    *   Gray pixels remain unchanged.
    *   The concept of "inside" seems crucial; it refers to areas that cannot reach the edge of the grid without crossing a gray pixel.

*   **Facts**:
    
```yaml
    task_type: color_filling
    objects:
      - name: boundary
        color: gray (5)
        role: defines enclosed regions
        persistence: unchanged between input and output
      - name: background/fillable_area
        color: white (0)
        role: potential area to be filled
        persistence: may change color if enclosed
      - name: filled_area
        color: yellow (4)
        role: result of filling an enclosed white area
        persistence: appears only in output, replacing enclosed white pixels
    properties:
      - enclosure: White areas can be either enclosed by gray boundaries or connected to the grid edge.
    actions:
      - identify: Find all contiguous regions of white (0) pixels.
      - check_enclosure: For each white region, determine if it is completely surrounded by gray (5) pixels (i.e., cannot reach the grid edge without crossing gray).
      - fill: Change the color of all pixels within the enclosed white regions to yellow (4).
    relationships:
      - boundary_encloses_fillable: Gray pixels form boundaries that enclose white pixels.
      - fillable_becomes_filled: Enclosed white pixels in the input become yellow pixels in the output.
    ```


*   **Natural Language Program**:
    1.  Identify all contiguous regions of white pixels (color 0) in the input grid.
    2.  For each identified white region, check if it is fully enclosed by gray pixels (color 5). A region is considered fully enclosed if none of its pixels are on the border of the grid, and all adjacent non-white pixels are gray. (Alternatively, perform a flood fill starting from each white pixel; if the fill reaches the edge of the grid without crossing a gray pixel, it's not enclosed. If the fill stops only at gray pixels, it is enclosed).
    3.  Create the output grid by copying the input grid.
    4.  For every white pixel identified in step 1 that belongs to a fully enclosed region (determined in step 2), change its color to yellow (color 4) in the output grid.
    5.  Leave all other pixels (gray pixels and non-enclosed white pixels) unchanged in the output grid.
```python
import numpy as np
from collections import deque

"""
Identify contiguous regions of white pixels (0) that are completely enclosed by gray pixels (5).
Change the color of these enclosed white pixels to yellow (4).
Leave all other pixels (gray pixels and white pixels not enclosed) unchanged.

A white region is considered enclosed if it cannot reach the boundary of the grid 
by moving only through other white pixels. 
"""

def is_valid(r, c, height, width):
    """Check if coordinates are within grid bounds."""
    return 0 <= r < height and 0 <= c < width

def find_unenclosed_white_pixels(grid):
    """
    Finds all white pixels connected to the grid boundary using BFS.
    
    Args:
        grid (np.array): The input grid.

    Returns:
        set: A set of coordinates (r, c) for all white pixels reachable from the boundary.
    """
    height, width = grid.shape
    unenclosed = set()
    q = deque()

    # Add all white pixels on the boundary to the queue
    for r in range(height):
        for c in [0, width - 1]: # Left and right borders
            if grid[r, c] == 0 and (r, c) not in unenclosed:
                q.append((r, c))
                unenclosed.add((r, c))
    for c in range(width):
        for r in [0, height - 1]: # Top and bottom borders
             if grid[r, c] == 0 and (r, c) not in unenclosed:
                q.append((r, c))
                unenclosed.add((r, c))

    # Perform BFS to find all reachable white pixels from the boundary
    while q:
        r, c = q.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is valid, is white, and hasn't been visited
            if is_valid(nr, nc, height, width) and \
               grid[nr, nc] == 0 and \
               (nr, nc) not in unenclosed:
                unenclosed.add((nr, nc))
                q.append((nr, nc))
                
    return unenclosed


def transform(input_grid):
    """
    Transforms the input grid by filling enclosed white areas with yellow.

    Args:
        input_grid (list of lists): The input grid represented as a list of lists.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier processing
    grid_np = np.array(input_grid, dtype=int)
    height, width = grid_np.shape
    
    # Initialize output grid as a copy of the input
    output_grid = grid_np.copy()

    # Find all white pixels that are connected to the boundary
    unenclosed_white = find_unenclosed_white_pixels(grid_np)

    # Iterate through the grid
    for r in range(height):
        for c in range(width):
            # If a pixel is white (0) but not in the set of unenclosed pixels,
            # it must be enclosed.
            if grid_np[r, c] == 0 and (r, c) not in unenclosed_white:
                # Change its color to yellow (4) in the output grid
                output_grid[r, c] = 4
                
    # Convert back to list of lists for the required output format
    return output_grid.tolist()

```
