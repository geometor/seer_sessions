{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify horizontal line segments composed of a single non-white color 'C' that are interrupted by exactly one white (0) pixel gap.\n2. The total horizontal span covered by the colored pixels of the segment plus the single gap must be 3 pixels or more.\n3. For each such identified segment and its gap:\n    a. Fill the white gap pixel in the output grid with the line color 'C'.\n    b. Starting from the row directly above the filled gap, draw a vertical ray upwards in the same column.\n    c. This upward ray uses the same color 'C'.\n    d. The ray continues upwards, coloring white (0) pixels it encounters.\n    e. The ray stops extending upwards immediately if it encounters a non-white (non-zero) pixel in the output grid or reaches the top edge (row 0).\n    f. The pixels colored by the ray overwrite the original white pixels.\n4. Pixels in the grid that are not part of a filled gap or overwritten by an upward ray retain their original color from the input grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Keep track of gaps that have already been processed as part of a valid line segment\n    # to avoid redundant processing if the scanning loop hits the same segment again.\n    processed_gaps = set()\n\n    # Iterate through each cell to check if it's a potential gap location\n    # A gap needs neighbors, so iterate columns from 1 to width-2\n    for r in range(height):\n        for c in range(1, width - 1):\n\n            # Check Condition 1: Is the current cell a white pixel (potential gap)?\n            if input_grid[r, c] == 0:\n                \n                # Check Condition 2: Are immediate left/right neighbors non-white and the same color?\n                left_pixel_color = input_grid[r, c - 1]\n                right_pixel_color = input_grid[r, c + 1]\n\n                if left_pixel_color != 0 and left_pixel_color == right_pixel_color:\n                    line_color = left_pixel_color\n                    gap_row = r\n                    gap_col = c\n\n                    # Avoid reprocessing if this gap coordinate was already handled\n                    if (gap_row, gap_col) in processed_gaps:\n                        continue\n\n                    # --- Verify the full segment properties ---\n\n                    # Find the leftmost extent of the contiguous line_color segment\n                    start_c = c - 1\n                    while start_c > 0 and input_grid[r, start_c - 1] == line_color:\n                        start_c -= 1\n\n                    # Find the rightmost extent of the contiguous line_color segment\n                    end_c = c + 1\n                    while end_c < width - 1 and input_grid[r, end_c + 1] == line_color:\n                        end_c += 1\n                        \n                    # Calculate total span (colored parts + gap)\n                    span = end_c - start_c + 1\n\n                    # Check Condition 3: Is the total span at least 3?\n                    if span < 3:\n                        continue # Segment too short\n\n                    # Check Condition 4: Is there exactly one gap (at the expected column 'c') within this span?\n                    # And are all other pixels within the span the correct line_color?\n                    gap_count = 0\n                    found_gap_col = -1\n                    valid_segment = True\n                    for scan_c in range(start_c, end_c + 1):\n                        pixel = input_grid[r, scan_c]\n                        if pixel == 0:\n                            gap_count += 1\n                            found_gap_col = scan_c\n                        elif pixel != line_color:\n                            valid_segment = False # Found an unexpected color\n                            break\n                    \n                    # Final check for segment validity\n                    if not valid_segment or gap_count != 1 or found_gap_col != gap_col:\n                        continue # Segment structure is invalid (multiple gaps, wrong gap location, or wrong colors)\n\n                    # --- All conditions met, perform the transformation on the output grid ---\n\n                    # Mark this gap as processed so we don't re-evaluate it\n                    processed_gaps.add((gap_row, gap_col))\n\n                    # Action 1: Fill the gap in the output grid\n                    output_grid[r, gap_col] = line_color\n\n                    # Action 2: Draw the vertical ray upwards, checking the output grid state\n                    # Start from the row directly above the gap\n                    for ray_r in range(r - 1, -1, -1): # Iterate from r-1 down to 0\n                        # Check the pixel in the *output* grid at the ray's current position\n                        if output_grid[ray_r, gap_col] != 0:\n                            # Stop drawing if the pixel is not white (already colored, possibly by another ray)\n                            break \n                        else:\n                            # Color the white pixel\n                            output_grid[ray_r, gap_col] = line_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19258,
    "candidates_token_count": 1284,
    "total_token_count": 20542,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.834102,
  "retries": 1
}