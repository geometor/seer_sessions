
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 4 4 0 4 4 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0 4 0 4 0 0 0 0
0 0 0 3 3 0 3 3 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0 0 4 0 0 0 0 0
0 0 0 3 3 3 3 3 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 0 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
3 1 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 2 2 2 2 2 2 2 0 0
0 0 1 1 3 3 3 1 1 0 0 2 4 4 2 4 4 2 0 0
0 0 1 1 3 0 3 1 1 0 0 2 2 4 2 4 2 2 0 0
0 0 1 3 3 0 3 3 1 0 0 2 2 4 4 4 2 2 0 0
0 0 1 1 3 0 3 1 1 0 0 2 2 2 4 2 2 2 0 0
0 0 1 3 3 3 3 3 1 0 0 2 2 4 4 4 2 2 0 0
0 0 1 1 1 1 1 1 1 0 0 2 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 4 4 2 4 4 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 4 2 4 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 4 4 4 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 4 2 2 2 0 0 0 0 0 0
3 1 0 0 0 0 0 2 2 4 4 4 2 2 0 0 0 0 0 0
3 1 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 8 8 8 8 8 0 0 0
0 0 0 8 8 8 8 8 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 8 8 0 8 8 0 0 0
0 0 0 8 8 0 8 8 0 0 0 0 0 8 8 8 0 0 0 0
0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 3 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
8 3 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0
0 0 3 3 3 3 3 3 3 0 0 3 3 8 3 8 3 3 0 0
0 0 3 3 8 3 8 3 3 0 0 3 8 8 8 8 8 3 0 0
0 0 3 8 8 8 8 8 3 0 0 3 3 8 0 8 3 3 0 0
0 0 3 3 8 0 8 3 3 0 0 3 8 8 0 8 8 3 0 0
0 0 3 8 8 0 8 8 3 0 0 3 3 8 8 8 3 3 0 0
0 0 3 3 8 8 8 3 3 0 0 3 3 3 3 3 3 3 0 0
0 0 3 3 3 3 3 3 3 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 1 1 2 1 1 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 1 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 1 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0
8 3 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0 0 0 0
8 3 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 1 2 1 1 2 0 0 0 0 0 0 0
1 2 0 0 0 0 2 2 1 1 1 2 2 0 0 0 0 0 0 0
1 2 0 0 0 0 2 2 2 1 2 2 2 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

## Perception

1.  **Input/Output Structure**: Both input and output are 2D grids of colored pixels (represented by integers 0-9). The background is predominantly white (0).
2.  **Objects**: The input grid contains distinct, separated "objects" composed of contiguous pixels of a single color (e.g., green shapes, yellow shapes, azure shapes, blue shapes in the examples). These objects appear to represent figures or patterns.
3.  **Markers**: In the bottom-left corner of the input grid, there are specific pairs of colored pixels arranged vertically. These seem to act as keys or instructions. In `train_1`, we see (Green, Blue) and (Yellow, Red). In `train_2`, we see (Azure, Green) and (Blue, Red). The first color in the pair corresponds to the color of an object type found elsewhere in the grid, and the second color seems to be an associated instruction color.
4.  **Transformation**: The core transformation involves drawing a rectangular frame or border around each identified object (excluding the markers themselves).
5.  **Frame Properties**:
    *   The frame is drawn one pixel away from the object's extent (bounding box) on all sides (top, bottom, left, right).
    *   The color of the frame is determined by the marker pairs in the bottom-left. If an object has color X, and there's a marker pair (X, Y), the frame drawn around that object will have color Y.
6.  **Preservation**: The original objects and the marker pairs remain unchanged in their positions within the output grid. The added frames do not overwrite the original objects or markers.

## Facts


```yaml
Task: Draw colored frames around specific objects based on color-key markers.

Input_Grid:
  - Contains a background color (white: 0).
  - Contains distinct Objects:
      - Composed of contiguous pixels of a single non-white color.
      - Vary in shape and position.
      - Examples: Green(3) shapes, Yellow(4) shapes, Azure(8) shapes, Blue(1) shapes.
  - Contains Markers:
      - Located in the bottom-left corner.
      - Consist of vertical pairs of pixels.
      - Format: (Object_Color, Frame_Color) at (row, 0) and (row, 1).
      - Example pairs: (Green, Blue), (Yellow, Red), (Azure, Green), (Blue, Red).

Output_Grid:
  - Preserves all elements from the Input_Grid (background, objects, markers).
  - Adds Frames:
      - Rectangular borders drawn around identified Objects.
      - Position: One pixel offset outwards from the object's bounding box.
      - Thickness: One pixel.
      - Color: Determined by the Frame_Color associated with the Object_Color in the Markers.

Relationships:
  - Each Object (excluding markers) is a target for potential framing.
  - The color of an Object determines which Marker pair is relevant.
  - The second color in the relevant Marker pair dictates the color of the Frame for all objects of the corresponding Object_Color.
  - A Frame's location is defined relative to the bounding box of the Object it encloses.

Actions:
  1. Identify Marker pairs in the bottom-left corner to create a mapping: Object_Color -> Frame_Color.
  2. Identify all distinct Objects (contiguous non-white, non-marker pixels) in the grid.
  3. For each identified Object:
     a. Determine its color (Object_Color).
     b. Check if its Object_Color exists in the Marker mapping.
     c. If yes:
        i. Find the Frame_Color from the mapping.
        ii. Calculate the bounding box of the Object (min_row, min_col, max_row, max_col).
        iii. Define the Frame area as the perimeter of the rectangle from (min_row-1, min_col-1) to (max_row+1, max_col+1).
        iv. Draw the Frame onto the grid using the determined Frame_Color, ensuring not to overwrite existing non-white pixels from the input.
  4. Return the modified grid.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Scan the bottom-left corner of the input grid (columns 0 and 1) to identify vertical pairs of non-white pixels. Store these as a mapping where the color in column 0 is the key (Object Color) and the color in column 1 is the value (Frame Color).
3.  Identify all distinct, contiguous objects in the input grid made of a single non-white color, excluding the pixels identified as markers in step 2.
4.  For each identified object:
    a.  Determine the color of the object.
    b.  Check if this object color exists as a key in the marker mapping created in step 2.
    c.  If the object color is found in the mapping:
        i.  Retrieve the corresponding Frame Color from the mapping.
        ii. Calculate the minimum and maximum row and column indices occupied by the object (its bounding box).
        iii. Define the frame coordinates: Iterate through rows from `min_row - 1` to `max_row + 1` and columns from `min_col - 1` to `max_col + 1`. A pixel at `(r, c)` is part of the frame if it lies on the perimeter of this expanded rectangle (i.e., if `r == min_row - 1` or `r == max_row + 1` or `c == min_col - 1` or `c == max_col + 1`).
        iv. For each frame coordinate `(r, c)` calculated in the previous step, if the pixel at `(r, c)` in the *output grid* is currently the background color (white), change its color to the determined Frame Color. (This prevents overwriting original objects or other frames).
5.  Return the final output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule:
1. Identify marker pairs in the first two columns (col 0, col 1) of the input grid. These pairs define a mapping from an object color (col 0) to a frame color (col 1).
2. Find all distinct contiguous objects in the grid that are not part of the markers identified in step 1. An object is defined as a connected group of pixels of the same non-background color.
3. For each identified object:
    a. Determine its color.
    b. Check if this color has a corresponding frame color defined by the markers.
    c. If a frame color exists:
        i. Calculate the bounding box of the object.
        ii. Draw a rectangular frame one pixel outside this bounding box using the corresponding frame color.
        iii. The frame should only be drawn onto background (white) pixels in the output grid, preserving the original objects, markers, and potentially overlapping frames.
4. The final output grid contains the original input elements plus the newly drawn frames.
"""

def find_objects(grid, marker_coords):
    """
    Finds all distinct contiguous objects of the same color in the grid,
    excluding coordinates specified in marker_coords.

    Args:
        grid (np.array): The input grid.
        marker_coords (set): A set of (row, col) tuples representing marker locations.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color' (int) and 'coords' (set of (row, col) tuples).
    """
    height, width = grid.shape
    visited = set(marker_coords) # Start with markers as visited
    objects = []
    
    for r in range(height):
        for c in range(width):
            if grid[r, c] != 0 and (r, c) not in visited:
                object_color = grid[r, c]
                current_object_coords = set()
                q = deque([(r, c)])
                visited.add((r, c))
                current_object_coords.add((r, c))

                while q:
                    row, col = q.popleft()

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc

                        # Check bounds and color match
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == object_color and \
                           (nr, nc) not in visited:
                            
                            visited.add((nr, nc))
                            current_object_coords.add((nr, nc))
                            q.append((nr, nc))
                
                if current_object_coords: # Ensure we found something
                     objects.append({'color': object_color, 'coords': current_object_coords})

    return objects

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the output grid.
    """
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # --- Step 1: Identify Markers and Create Color Map ---
    color_map = {}
    marker_coords = set()
    for r in range(height):
        # Check if both column 0 and 1 have non-background colors
        # And they are vertically aligned markers (typical ARC pattern)
        # We assume markers are just pairs in the first two columns
        if input_grid[r, 0] != 0 and input_grid[r, 1] != 0:
             # Basic check: ensure they are different colors or handle specific logic if needed
             # For this task, they just form a pair.
             object_color = input_grid[r, 0]
             frame_color = input_grid[r, 1]
             color_map[object_color] = frame_color
             marker_coords.add((r, 0))
             marker_coords.add((r, 1))

    # --- Step 2: Find all distinct objects (excluding markers) ---
    objects = find_objects(input_grid, marker_coords)

    # --- Step 3 & 4: Process each object and draw frame if applicable ---
    for obj in objects:
        obj_color = obj['color']
        
        # Check if this object's color has a corresponding frame color
        if obj_color in color_map:
            frame_color = color_map[obj_color]
            coords = obj['coords']
            
            # Calculate bounding box
            min_r = min(r for r, c in coords)
            max_r = max(r for r, c in coords)
            min_c = min(c for r, c in coords)
            max_c = max(c for r, c in coords)
            
            # Define frame coordinates (one pixel outside bounding box)
            frame_min_r = max(0, min_r - 1)
            frame_max_r = min(height - 1, max_r + 1)
            frame_min_c = max(0, min_c - 1)
            frame_max_c = min(width - 1, max_c + 1)

            # Draw the frame onto the output grid
            for r in range(frame_min_r, frame_max_r + 1):
                for c in range(frame_min_c, frame_max_c + 1):
                    # Check if the current coordinate is on the perimeter of the frame box
                    is_perimeter = (r == frame_min_r or r == frame_max_r or 
                                    c == frame_min_c or c == frame_max_c)
                    
                    if is_perimeter:
                        # Only draw frame on background pixels of the output grid
                        if output_grid[r, c] == 0:
                            output_grid[r, c] = frame_color
                            
    return output_grid

```
