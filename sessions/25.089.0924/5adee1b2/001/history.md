
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 4 4 0 4 4 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0 4 0 4 0 0 0 0
0 0 0 3 3 0 3 3 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0 0 4 0 0 0 0 0
0 0 0 3 3 3 3 3 0 0 0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 0 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
3 1 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 2 2 2 2 2 2 2 0 0
0 0 1 1 3 3 3 1 1 0 0 2 4 4 2 4 4 2 0 0
0 0 1 1 3 0 3 1 1 0 0 2 2 4 2 4 2 2 0 0
0 0 1 3 3 0 3 3 1 0 0 2 2 4 4 4 2 2 0 0
0 0 1 1 3 0 3 1 1 0 0 2 2 2 4 2 2 2 0 0
0 0 1 3 3 3 3 3 1 0 0 2 2 4 4 4 2 2 0 0
0 0 1 1 1 1 1 1 1 0 0 2 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 4 4 2 4 4 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 4 2 4 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 4 4 4 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 4 2 2 2 0 0 0 0 0 0
3 1 0 0 0 0 0 2 2 4 4 4 2 2 0 0 0 0 0 0
3 1 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 8 8 8 8 8 0 0 0
0 0 0 8 8 8 8 8 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 8 8 0 8 8 0 0 0
0 0 0 8 8 0 8 8 0 0 0 0 0 8 8 8 0 0 0 0
0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 3 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
8 3 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0
0 0 3 3 3 3 3 3 3 0 0 3 3 8 3 8 3 3 0 0
0 0 3 3 8 3 8 3 3 0 0 3 8 8 8 8 8 3 0 0
0 0 3 8 8 8 8 8 3 0 0 3 3 8 0 8 3 3 0 0
0 0 3 3 8 0 8 3 3 0 0 3 8 8 0 8 8 3 0 0
0 0 3 8 8 0 8 8 3 0 0 3 3 8 8 8 3 3 0 0
0 0 3 3 8 8 8 3 3 0 0 3 3 3 3 3 3 3 0 0
0 0 3 3 3 3 3 3 3 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 1 1 2 1 1 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 1 1 1 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 1 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0
8 3 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0 0 0 0
8 3 0 0 0 0 2 2 1 2 1 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 1 2 1 1 2 0 0 0 0 0 0 0
1 2 0 0 0 0 2 2 1 1 1 2 2 0 0 0 0 0 0 0
1 2 0 0 0 0 2 2 2 1 2 2 2 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

## Perception

1.  **Input/Output Structure**: Both input and output are 2D grids of colored pixels (represented by integers 0-9). The background is predominantly white (0).
2.  **Objects**: The input grid contains distinct, separated "objects" composed of contiguous pixels of a single color (e.g., green shapes, yellow shapes, azure shapes, blue shapes in the examples). These objects appear to represent figures or patterns.
3.  **Markers**: In the bottom-left corner of the input grid, there are specific pairs of colored pixels arranged vertically. These seem to act as keys or instructions. In `train_1`, we see (Green, Blue) and (Yellow, Red). In `train_2`, we see (Azure, Green) and (Blue, Red). The first color in the pair corresponds to the color of an object type found elsewhere in the grid, and the second color seems to be an associated instruction color.
4.  **Transformation**: The core transformation involves drawing a rectangular frame or border around each identified object (excluding the markers themselves).
5.  **Frame Properties**:
    *   The frame is drawn one pixel away from the object's extent (bounding box) on all sides (top, bottom, left, right).
    *   The color of the frame is determined by the marker pairs in the bottom-left. If an object has color X, and there's a marker pair (X, Y), the frame drawn around that object will have color Y.
6.  **Preservation**: The original objects and the marker pairs remain unchanged in their positions within the output grid. The added frames do not overwrite the original objects or markers.

## Facts


```yaml
Task: Draw colored frames around specific objects based on color-key markers.

Input_Grid:
  - Contains a background color (white: 0).
  - Contains distinct Objects:
      - Composed of contiguous pixels of a single non-white color.
      - Vary in shape and position.
      - Examples: Green(3) shapes, Yellow(4) shapes, Azure(8) shapes, Blue(1) shapes.
  - Contains Markers:
      - Located in the bottom-left corner.
      - Consist of vertical pairs of pixels.
      - Format: (Object_Color, Frame_Color) at (row, 0) and (row, 1).
      - Example pairs: (Green, Blue), (Yellow, Red), (Azure, Green), (Blue, Red).

Output_Grid:
  - Preserves all elements from the Input_Grid (background, objects, markers).
  - Adds Frames:
      - Rectangular borders drawn around identified Objects.
      - Position: One pixel offset outwards from the object's bounding box.
      - Thickness: One pixel.
      - Color: Determined by the Frame_Color associated with the Object_Color in the Markers.

Relationships:
  - Each Object (excluding markers) is a target for potential framing.
  - The color of an Object determines which Marker pair is relevant.
  - The second color in the relevant Marker pair dictates the color of the Frame for all objects of the corresponding Object_Color.
  - A Frame's location is defined relative to the bounding box of the Object it encloses.

Actions:
  1. Identify Marker pairs in the bottom-left corner to create a mapping: Object_Color -> Frame_Color.
  2. Identify all distinct Objects (contiguous non-white, non-marker pixels) in the grid.
  3. For each identified Object:
     a. Determine its color (Object_Color).
     b. Check if its Object_Color exists in the Marker mapping.
     c. If yes:
        i. Find the Frame_Color from the mapping.
        ii. Calculate the bounding box of the Object (min_row, min_col, max_row, max_col).
        iii. Define the Frame area as the perimeter of the rectangle from (min_row-1, min_col-1) to (max_row+1, max_col+1).
        iv. Draw the Frame onto the grid using the determined Frame_Color, ensuring not to overwrite existing non-white pixels from the input.
  4. Return the modified grid.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Scan the bottom-left corner of the input grid (columns 0 and 1) to identify vertical pairs of non-white pixels. Store these as a mapping where the color in column 0 is the key (Object Color) and the color in column 1 is the value (Frame Color).
3.  Identify all distinct, contiguous objects in the input grid made of a single non-white color, excluding the pixels identified as markers in step 2.
4.  For each identified object:
    a.  Determine the color of the object.
    b.  Check if this object color exists as a key in the marker mapping created in step 2.
    c.  If the object color is found in the mapping:
        i.  Retrieve the corresponding Frame Color from the mapping.
        ii. Calculate the minimum and maximum row and column indices occupied by the object (its bounding box).
        iii. Define the frame coordinates: Iterate through rows from `min_row - 1` to `max_row + 1` and columns from `min_col - 1` to `max_col + 1`. A pixel at `(r, c)` is part of the frame if it lies on the perimeter of this expanded rectangle (i.e., if `r == min_row - 1` or `r == max_row + 1` or `c == min_col - 1` or `c == max_col + 1`).
        iv. For each frame coordinate `(r, c)` calculated in the previous step, if the pixel at `(r, c)` in the *output grid* is currently the background color (white), change its color to the determined Frame Color. (This prevents overwriting original objects or other frames).
5.  Return the final output grid.
