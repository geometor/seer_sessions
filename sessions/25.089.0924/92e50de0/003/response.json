{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_grid_color(grid):\n    \"\"\"\n    Attempts to determine the color used for the grid lines.\n    Assumes lines are regularly spaced (e.g., every 4th row/col).\n    \"\"\"\n    height, width = grid.shape\n    spacing = 4 # Assuming spacing based on examples\n    \n    # Check specific line coordinates first for efficiency\n    potential_coords = [(spacing - 1, 0), (spacing - 1, spacing - 1), (0, spacing - 1)]\n    for r, c in potential_coords:\n        if 0 <= r < height and 0 <= c < width:\n            color = grid[r, c]\n            if color != 0: # If not background\n                return color\n\n    # Fallback: Scan likely line locations if specific checks failed\n    for r in range(spacing - 1, height, spacing):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0:\n                return color\n                \n    for c in range(spacing - 1, width, spacing):\n        for r in range(height):\n             color = grid[r, c]\n             if color != 0:\n                 return color\n                 \n    # If no non-zero color found on expected lines, maybe no lines? Return 0 (background)\n    return 0 \n\ndef find_source_pattern(grid, grid_color, spacing, subgrid_size):\n    \"\"\"\n    Finds the unique non-background, non-gridline pattern and its location.\n    Returns the pattern, its subgrid row index, and its subgrid column index.\n    \"\"\"\n    height, width = grid.shape\n    num_subgrid_rows = (height + spacing - subgrid_size) // spacing # Adjusted calculation\n    num_subgrid_cols = (width + spacing - subgrid_size) // spacing # Adjusted calculation\n\n    for r_idx in range(num_subgrid_rows):\n        for c_idx in range(num_subgrid_cols):\n            start_row = r_idx * spacing\n            start_col = c_idx * spacing\n            \n            # Ensure extraction doesn't go out of bounds\n            end_row = min(start_row + subgrid_size, height)\n            end_col = min(start_col + subgrid_size, width)\n            \n            # Check if the subgrid size matches expected\n            if end_row - start_row != subgrid_size or end_col - start_col != subgrid_size:\n                 continue # Skip incomplete subgrids at edges if any\n\n            subgrid = grid[start_row:end_row, start_col:end_col]\n\n            # Check if this subgrid contains a pattern color\n            is_source = False\n            if np.any((subgrid != 0) & (subgrid != grid_color)):\n                 is_source = True\n\n            if is_source:\n                # Return a copy of the pattern to avoid modification issues\n                return np.copy(subgrid), r_idx, c_idx\n                \n    return None, -1, -1 # Should not happen in valid examples\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies a grid structure based on regularly spaced horizontal and vertical lines.\n    Locates a unique 3x3 pattern within one subgrid (the source).\n    Replicates this source pattern into other subgrids based on a checkerboard-like rule:\n    - Copies to subgrids in the same row as the source, but only if their column index has the same parity (even/odd) as the source's column index.\n    - Copies to subgrids in the same column as the source, but only if their row index has the same parity (even/odd) as the source's row index.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # Define grid parameters (assuming constant from examples)\n    spacing = 4\n    subgrid_size = 3\n\n    # Find the color used for grid lines\n    grid_color = find_grid_color(input_array)\n\n    # Find the unique source pattern and its subgrid coordinates\n    source_pattern, source_subgrid_row, source_subgrid_col = find_source_pattern(\n        input_array, grid_color, spacing, subgrid_size\n    )\n\n    # If no source pattern found, return the original grid\n    if source_pattern is None:\n        return output_array.tolist()\n\n    # Calculate number of subgrids\n    num_subgrid_rows = (height + spacing - subgrid_size) // spacing # Adjusted calculation\n    num_subgrid_cols = (width + spacing - subgrid_size) // spacing # Adjusted calculation\n\n\n    # Replicate the pattern based on the refined rule\n    for r_idx in range(num_subgrid_rows):\n        for c_idx in range(num_subgrid_cols):\n            \n            # Determine if this subgrid should receive the pattern\n            replicate = False\n            # Check row alignment and column parity\n            if r_idx == source_subgrid_row and c_idx % 2 == source_subgrid_col % 2:\n                replicate = True\n            # Check column alignment and row parity\n            elif c_idx == source_subgrid_col and r_idx % 2 == source_subgrid_row % 2:\n                 replicate = True\n\n            if replicate:\n                # Calculate top-left pixel coordinates for placement\n                start_row = r_idx * spacing\n                start_col = c_idx * spacing\n                \n                # Ensure we don't write outside the bounds of the output grid\n                # This check is important if the grid dimensions aren't perfect multiples\n                end_row = min(start_row + subgrid_size, height)\n                end_col = min(start_col + subgrid_size, width)\n                \n                # Calculate the actual size of the pattern slice to place\n                pattern_h = end_row - start_row\n                pattern_w = end_col - start_col\n\n                # Place the pattern (or the relevant part if near edge)\n                if pattern_h > 0 and pattern_w > 0:\n                    output_array[start_row:end_row, start_col:end_col] = source_pattern[:pattern_h, :pattern_w]\n\n    # Return the modified grid\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24098,
    "candidates_token_count": 1508,
    "total_token_count": 25606,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.341627,
  "retries": 1
}