{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a grid structure based on regularly spaced horizontal and vertical lines of a single color (grid_color), which divide the grid into smaller, equal-sized 3x3 subgrids with a spacing of 4 pixels.\nLocates a unique 3x3 pattern (source_pattern) within exactly one of these subgrids (the source_subgrid, identified by its row/column index r_idx, c_idx).\nCreates an output grid by copying the input grid.\nReplicates the source_pattern into specific subgrids in the output grid based on a parity rule: the pattern is copied to a subgrid at (r, c) if it's in the same row as the source (r == source_r_idx) and its column index c has the same parity (even/odd) as the source's column index (source_c_idx), OR if it's in the same column as the source (c == source_c_idx) and its row index r has the same parity as the source's row index (source_r_idx).\n\"\"\"\n\ndef find_grid_color(grid):\n    \"\"\"\n    Attempts to determine the color used for the grid lines.\n    Assumes lines are regularly spaced (every 4th row/col).\n    Returns the grid line color, or 0 (background) if no clear line color is found.\n    \"\"\"\n    height, width = grid.shape\n    spacing = 4 \n    \n    # Check specific likely line coordinates first for efficiency\n    potential_coords = []\n    if height > spacing - 1:\n        potential_coords.extend([(spacing - 1, 0), (spacing - 1, min(spacing - 1, width - 1))])\n    if width > spacing - 1:\n         potential_coords.append((0, spacing - 1))\n\n    for r, c in potential_coords:\n        if 0 <= r < height and 0 <= c < width:\n            color = grid[r, c]\n            if color != 0: # If not background\n                return color\n\n    # Fallback: Scan likely line locations if specific checks failed\n    for r in range(spacing - 1, height, spacing):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0:\n                return color\n                \n    for c in range(spacing - 1, width, spacing):\n        for r in range(height):\n             color = grid[r, c]\n             if color != 0:\n                 return color\n                 \n    # If no non-zero color found on expected lines, assume no grid or only background lines\n    return 0 \n\ndef find_source_pattern_info(grid, grid_color):\n    \"\"\"\n    Finds the unique non-background, non-gridline pattern and its location.\n    Assumes 3x3 subgrids and spacing of 4.\n    Returns the 3x3 pattern (as a numpy array), its subgrid row index, and its subgrid column index.\n    Returns (None, -1, -1) if no source pattern is found.\n    \"\"\"\n    height, width = grid.shape\n    spacing = 4\n    subgrid_size = 3\n    \n    # Calculate the number of subgrid rows/cols based on where a 3x3 grid could start\n    num_subgrid_rows = height // spacing + (1 if height % spacing >= subgrid_size else 0)\n    num_subgrid_cols = width // spacing + (1 if width % spacing >= subgrid_size else 0)\n\n    for r_idx in range(num_subgrid_rows):\n        for c_idx in range(num_subgrid_cols):\n            # Define the top-left corner of the subgrid content area\n            start_row = r_idx * spacing\n            start_col = c_idx * spacing\n            \n            # Define the actual extent of the subgrid, careful of grid boundaries\n            end_row = min(start_row + subgrid_size, height)\n            end_col = min(start_col + subgrid_size, width)\n            \n            # Extract the subgrid slice\n            subgrid = grid[start_row:end_row, start_col:end_col]\n\n            # Check if the extracted slice is actually 3x3 \n            # (Handles cases where grid dims aren't perfect multiples of spacing)\n            if subgrid.shape != (subgrid_size, subgrid_size):\n                 continue # Skip incomplete subgrids at the edges\n\n            # Check if this subgrid contains a pattern color (not background, not grid color)\n            is_source = False\n            if np.any((subgrid != 0) & (subgrid != grid_color)):\n                 is_source = True\n\n            if is_source:\n                # Return a copy of the pattern to avoid modification issues\n                return np.copy(subgrid), r_idx, c_idx\n                \n    # If loop completes without finding a source\n    return None, -1, -1 \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # Define grid parameters (assuming constant from examples)\n    spacing = 4\n    subgrid_size = 3\n\n    # Step 1: Find the color used for grid lines\n    grid_color = find_grid_color(input_array)\n\n    # Step 2 & 3: Find the unique source pattern and its subgrid coordinates\n    source_pattern, source_subgrid_row, source_subgrid_col = find_source_pattern_info(\n        input_array, grid_color\n    )\n\n    # If no source pattern found (e.g., input is blank or only grid lines), return the original grid\n    if source_pattern is None:\n        return output_array.tolist()\n\n    # Step 4: Output grid is already initialized as a copy (output_array)\n\n    # Step 5, 6, 7: Iterate through subgrids and replicate pattern based on parity rule\n    num_subgrid_rows = height // spacing + (1 if height % spacing >= subgrid_size else 0)\n    num_subgrid_cols = width // spacing + (1 if width % spacing >= subgrid_size else 0)\n\n    for r_idx in range(num_subgrid_rows):\n        for c_idx in range(num_subgrid_cols):\n            \n            # Determine if this subgrid should receive the pattern based on the parity rule\n            replicate = False\n            # Check Row Match + Column Parity Match\n            if r_idx == source_subgrid_row and c_idx % 2 == source_subgrid_col % 2:\n                replicate = True\n            # Check Column Match + Row Parity Match\n            elif c_idx == source_subgrid_col and r_idx % 2 == source_subgrid_row % 2:\n                 replicate = True\n\n            if replicate:\n                # Calculate top-left pixel coordinates for placement\n                start_row = r_idx * spacing\n                start_col = c_idx * spacing\n                \n                # Calculate bottom-right bounds, respecting grid boundaries\n                end_row = min(start_row + subgrid_size, height)\n                end_col = min(start_col + subgrid_size, width)\n                \n                # Calculate the actual size of the pattern slice needed from source_pattern\n                pattern_h = end_row - start_row\n                pattern_w = end_col - start_col\n\n                # Place the pattern slice (handles edge cases where subgrid space is < 3x3)\n                if pattern_h > 0 and pattern_w > 0:\n                    # Ensure source_pattern has the expected dimensions before slicing\n                    if source_pattern.shape == (subgrid_size, subgrid_size):\n                       output_array[start_row:end_row, start_col:end_col] = source_pattern[:pattern_h, :pattern_w]\n                    # else: This case shouldn't happen if find_source_pattern_info worked correctly\n\n    # Step 8: Return the modified grid as a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34256,
    "candidates_token_count": 1924,
    "total_token_count": 36180,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.149536,
  "retries": 1
}