{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, generate_binary_structure\n\n\"\"\"\nTransforms grids containing colored objects based on the configuration of associated yellow pixels (color 4).\n\nTwo transformation rules are applied:\n\n1.  Reflection Rule: If the yellow pixels associated with an object (non-white, non-yellow connected component) \n    form a single, contiguous, straight line (horizontal or vertical) that spans the object's dimension \n    perpendicular to the line, the object is reflected across that line. Original object pixels (not on the line) \n    are removed (set to white 0), and yellow pixels remain unchanged.\n\n2.  Complex Update Rule: If the yellow pixels do not meet the criteria for the Reflection Rule, a complex update is applied:\n    a. Pixels of the object's primary color that are completely surrounded by 8 neighbors of the *same* color \n       (in the input grid) are changed to yellow (4) in the output grid.\n    b. (Undetermined Part) Other changes involving pixels changing between the primary color and white (0) occur,\n       likely based on local neighborhood rules involving primary color and yellow pixels. \n       This part is not fully implemented due to undetermined rules. Currently, only step 2a is applied for the complex rule.\n\"\"\"\n\ndef find_connected_components(grid, target_colors):\n    \"\"\"Find connected components for specific colors.\"\"\"\n    objects = []\n    binary_grid = np.isin(grid, target_colors)\n    # Use 8-connectivity (Moore neighborhood)\n    structure = generate_binary_structure(2, 2) \n    labeled_array, num_features = label(binary_grid, structure=structure)\n    \n    if num_features > 0:\n        found_objs = find_objects(labeled_array)\n        for i, obj_slice in enumerate(found_objs):\n            obj_mask = labeled_array[obj_slice] == (i + 1)\n            obj_pixels_local = np.argwhere(obj_mask)\n            # Convert local coordinates to global grid coordinates\n            obj_pixels_global = [(r + obj_slice[0].start, c + obj_slice[1].start) for r, c in obj_pixels_local]\n            # Determine the main color (assuming one color per component for primary objects)\n            if obj_pixels_global:\n                 # Check only first pixel color for primary objects as components are defined by color group\n                 main_color = grid[obj_pixels_global[0]]\n                 objects.append({\n                     'id': i + 1,\n                     'main_color': main_color,\n                     'pixels': obj_pixels_global,\n                     'slice': obj_slice\n                 })\n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculate the bounding box [min_row, min_col, max_row, max_col] for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    rows = [p[0] for p in pixels]\n    cols = [p[1] for p in pixels]\n    return [min(rows), min(cols), max(rows), max(cols)]\n\ndef check_yellow_line(yellow_pixels, bbox, object_pixels_set):\n    \"\"\"\n    Analyze yellow pixel configuration relative to an object.\n    Checks if yellow pixels form a single contiguous straight line spanning the object's bbox.\n    Returns: ('type', axis_index) or (None, None)\n    'type' can be 'horizontal_line', 'vertical_line', or None.\n    axis_index is the row or column index of the line.\n    \"\"\"\n    if not yellow_pixels:\n        return None, None\n\n    rows = np.array([p[0] for p in yellow_pixels])\n    cols = np.array([p[1] for p in yellow_pixels])\n    min_r, min_c, max_r, max_c = bbox\n    \n    # Check for horizontal line\n    if len(np.unique(rows)) == 1:\n        line_row = rows[0]\n        line_cols = sorted(np.unique(cols))\n        # Check contiguity\n        if np.all(np.diff(line_cols) == 1):\n            # Check spanning\n            object_cols_at_row = {p[1] for p in object_pixels_set if p[0] == line_row}\n            bbox_width = max_c - min_c + 1\n            line_width = line_cols[-1] - line_cols[0] + 1\n            # A loose definition of spanning: the line covers the object's width *at that specific row*\n            # or spans the full bbox width. Let's try bbox width for simplicity first.\n            # Check if line is within bbox bounds\n            if line_cols[0] >= min_c and line_cols[-1] <= max_c and line_width == bbox_width :\n                 return 'horizontal_line', line_row\n            # Alternate check: Does the line span the columns occupied by the object *at that row*?\n            obj_min_c_at_row = min(object_cols_at_row) if object_cols_at_row else min_c\n            obj_max_c_at_row = max(object_cols_at_row) if object_cols_at_row else max_c\n            if line_cols[0] == obj_min_c_at_row and line_cols[-1] == obj_max_c_at_row:\n                 # Check if *all* object pixels at this row are covered by the line\n                 # Or maybe just if the *extent* matches. Let's try extent.\n                 # We also need to ensure the yellow line is *part* of the object visually.\n                 # For T1 Top, the yellow line sits *between* rows of blue pixels.\n                 # Let's require the line to be exactly within the bbox row range as well\n                 if line_row >= min_r and line_row <= max_r:\n                     # Check if the line length matches the bbox width\n                     if line_width == (max_c - min_c + 1):\n                         return 'horizontal_line', line_row\n\n\n    # Check for vertical line\n    if len(np.unique(cols)) == 1:\n        line_col = cols[0]\n        line_rows = sorted(np.unique(rows))\n        # Check contiguity\n        if np.all(np.diff(line_rows) == 1):\n            # Check spanning\n            object_rows_at_col = {p[0] for p in object_pixels_set if p[1] == line_col}\n            bbox_height = max_r - min_r + 1\n            line_height = line_rows[-1] - line_rows[0] + 1\n            # Similar spanning checks as above\n            if line_rows[0] >= min_r and line_rows[-1] <= max_r and line_height == bbox_height:\n                return 'vertical_line', line_col\n            obj_min_r_at_col = min(object_rows_at_col) if object_rows_at_col else min_r\n            obj_max_r_at_col = max(object_rows_at_col) if object_rows_at_col else max_r\n            if line_rows[0] == obj_min_r_at_col and line_rows[-1] == obj_max_r_at_col:\n                 if line_col >= min_c and line_col <= max_c:\n                     if line_height == (max_r - min_r + 1):\n                         return 'vertical_line', line_col\n\n    return None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformation rules based on object color and associated yellow pixels.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Find all unique primary colors (excluding white 0 and yellow 4)\n    primary_colors = np.unique(input_grid[(input_grid != 0) & (input_grid != 4)])\n    \n    if primary_colors.size == 0: # No primary objects, maybe only yellow?\n        # Handle cases with only yellow or only white/yellow if necessary\n        # For now, assume primary objects exist if transformation is expected\n         pass # Return copy\n\n    # Find yellow pixels once\n    yellow_pixels = list(zip(*np.where(input_grid == 4)))\n    yellow_pixels_set = set(yellow_pixels)\n\n    # Find primary objects (connected components of non-white, non-yellow colors)\n    # This assumes objects are single-colored (excluding yellow)\n    objects = []\n    all_primary_colors = set(np.unique(input_grid)) - {0, 4}\n    if all_primary_colors:\n         # We could find components for each color, or for all primaries together\n         # Let's assume objects are separated by color or space\n         temp_grid = input_grid.copy()\n         temp_grid[temp_grid == 4] = 0 # Temporarily treat yellow as background for object finding\n         binary_grid = np.isin(temp_grid, list(all_primary_colors))\n         structure = generate_binary_structure(2, 2) \n         labeled_array, num_features = label(binary_grid, structure=structure)\n         \n         if num_features > 0:\n             found_objs_indices = find_objects(labeled_array)\n             for i, obj_slice in enumerate(found_objs_indices):\n                 obj_mask = labeled_array[obj_slice] == (i + 1)\n                 obj_pixels_local = np.argwhere(obj_mask)\n                 obj_pixels_global = [(r + obj_slice[0].start, c + obj_slice[1].start) for r, c in obj_pixels_local]\n                 \n                 if obj_pixels_global:\n                     # Determine the main color from the first pixel\n                     main_color = input_grid[obj_pixels_global[0]]\n                     objects.append({\n                         'id': i + 1,\n                         'main_color': main_color,\n                         'pixels': obj_pixels_global,\n                         'slice': obj_slice\n                     })\n\n    # Process each found object\n    for obj in objects:\n        obj_pixels = obj['pixels']\n        obj_pixels_set = set(obj_pixels)\n        primary_color = obj['main_color']\n        \n        bbox = get_bounding_box(obj_pixels)\n        if bbox is None: continue\n\n        # Find associated yellow pixels (simple approach: all yellow pixels in grid)\n        # More refined: yellow pixels within bbox + adjacent? Using all for now.\n        current_yellow_pixels = yellow_pixels # Use all yellows\n        \n        # Check for reflection rule\n        line_type, axis_index = check_yellow_line(current_yellow_pixels, bbox, obj_pixels_set)\n\n        if line_type == 'horizontal_line':\n            # Apply Reflection Rule A (Vertical Reflection)\n            reflection_axis_row = axis_index\n            # Clear existing object pixels in output, except yellow line itself\n            for r, c in obj_pixels:\n                if input_grid[r, c] != 4: # Don't clear original yellows\n                   output_grid[r, c] = 0 # Set to white\n\n            # Add reflected pixels\n            for r, c in obj_pixels:\n                 # Only reflect primary color pixels\n                 if input_grid[r, c] == primary_color:\n                     reflected_r = 2 * reflection_axis_row - r\n                     # Ensure reflected pixel is within bounds\n                     if 0 <= reflected_r < height:\n                         output_grid[reflected_r, c] = primary_color\n            # Ensure yellow line remains\n            for r_y, c_y in current_yellow_pixels:\n                 if r_y == reflection_axis_row and bbox[1] <= c_y <= bbox[3]:\n                    output_grid[r_y, c_y] = 4\n            # Set flag to skip complex update for this object's region? Or handle overlaps?\n            # For now, assume objects processed independently based on initial detection.\n\n        elif line_type == 'vertical_line':\n             # Apply Reflection Rule A (Horizontal Reflection) - Not seen in examples, but for completeness\n             reflection_axis_col = axis_index\n             # Clear existing object pixels in output, except yellow line itself\n             for r, c in obj_pixels:\n                 if input_grid[r, c] != 4:\n                    output_grid[r, c] = 0 \n\n             # Add reflected pixels\n             for r, c in obj_pixels:\n                 if input_grid[r, c] == primary_color:\n                     reflected_c = 2 * reflection_axis_col - c\n                     if 0 <= reflected_c < width:\n                         output_grid[r, reflected_c] = primary_color\n             # Ensure yellow line remains\n             for r_y, c_y in current_yellow_pixels:\n                 if c_y == reflection_axis_col and bbox[0] <= r_y <= bbox[2]:\n                     output_grid[r_y, c_y] = 4\n        \n        else:\n            # Apply Complex Update Rule B\n            pixels_to_yellow = []\n            # Find primary color pixels surrounded by 8 same-color neighbors in INPUT grid\n            for r, c in obj_pixels:\n                 if input_grid[r, c] == primary_color:\n                     neighbor_count = 0\n                     for dr in [-1, 0, 1]:\n                         for dc in [-1, 0, 1]:\n                             if dr == 0 and dc == 0:\n                                 continue\n                             nr, nc = r + dr, c + dc\n                             if 0 <= nr < height and 0 <= nc < width:\n                                 if input_grid[nr, nc] == primary_color:\n                                     neighbor_count += 1\n                     \n                     if neighbor_count == 8:\n                         pixels_to_yellow.append((r, c))\n\n            # Change these pixels to yellow in the output grid\n            for r_change, c_change in pixels_to_yellow:\n                output_grid[r_change, c_change] = 4\n\n            # --- Placeholder for Undetermined Rule B part ---\n            # Here, additional rules would be applied to handle the\n            # Color <-> White changes observed in the examples.\n            # This might involve iterating through all pixels again and checking\n            # neighbor counts (primary color and yellow) in the input grid\n            # to decide the final state in the output grid for pixels not\n            # turned yellow by the above rule.\n            # Since the rule is unclear, this part is omitted for now.\n            # The current output for Rule B will only show the Color -> Yellow change.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14655,
    "candidates_token_count": 3487,
    "total_token_count": 18142,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.150107,
  "retries": 1
}