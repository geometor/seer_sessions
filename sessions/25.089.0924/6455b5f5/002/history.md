
## train_1

**input:**
```
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
```


**output:**
```
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 2 8 8 8 8 8 8 8 8
0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 2 2 2
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 0 0 2 8 8 8
0 0 0 2 0 0 0 0 0 0 0 0 2 8 8 8
0 0 0 2 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
2 2 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 2 2 2
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
```


## train_4

**input:**
```
0 2 0 0 0 0 2 0 0 0 0 0 0
2 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 2 2 2 2 2 0 0 2 0 0 0
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 0 0 2 0
2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 2 0 0 0 0 2 0 0 0 0 0 0
2 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 2 2 2 2 2 0 0 2 0 0 0
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 0 0 2 8
2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
```

*   **Perception:** The task involves modifying input grids containing white (0) background pixels and red (2) structures, often resembling walls or lines. The output grids retain the original red structures but fill certain white areas with either blue (1) or azure (8). The key transformation is identifying white areas completely enclosed by red pixels and filling them based on the shape or configuration of the enclosing red boundary. White areas not enclosed or areas enclosed in different ways receive different fill colors.

*   **Facts:**
    
```yaml
    task_elements:
      - description: Input and Output Grids
        properties:
          format: 2D array of integers (pixels)
          colors_used_input: [white (0), red (2)]
          colors_used_output: [white (0), blue (1), red (2), azure (8)]
          dimensionality: Varies per example (height/width up to 30)
      - description: Red Structures
        properties:
          color: red (2)
          role: Act as barriers or walls
          shape: Lines, corners, complex shapes formed by contiguous red pixels
          persistence: Red structures remain unchanged from input to output
      - description: White Areas
        properties:
          color: white (0)
          role: Background or space potentially modified
          state: Can be 'open' (connected to grid boundary) or 'enclosed' (surrounded by red pixels)
      - description: Filling Action
        properties:
          trigger: A white area is fully enclosed by red pixels (cannot reach the grid boundary by moving only through white pixels orthogonally).
          target: Enclosed white areas
          outcome: The enclosed white area is filled with a new color.
      - description: Fill Color Determination
        properties:
          condition_azure: The enclosed white area has at least one pixel adjacent to a 'concave' feature of the red boundary. This includes being adjacent to an 'inner corner' (a red pixel adjacent to the white pixel, which itself has at least two other red neighbours forming a corner around the white pixel) or having red neighbours on directly opposite sides (e.g., North and South, or East and West).
          fill_color_azure: azure (8)
          condition_blue: The enclosed white area does not meet the condition for azure fill (i.e., its boundary with red pixels consists only of straight segments or 'convex' corners relative to the white area).
          fill_color_blue: blue (1)
      - description: Unmodified Areas
        properties:
          target: White areas not fully enclosed by red pixels.
          outcome: Remain white (0).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify all connected components (areas) of white (0) pixels in the input grid using orthogonal adjacency.
    3.  For each distinct white area:
        a.  Determine if the area is "enclosed". Perform a search (e.g., Flood Fill, BFS, DFS) starting from any pixel within the area, moving only orthogonally through white pixels. If the search reaches any pixel on the boundary edge of the grid, the area is *not* enclosed. Otherwise, it *is* enclosed.
        b.  If the area is enclosed:
            i.  Set a flag `fill_with_azure` to `false`.
            ii. Iterate through each white pixel `(r, c)` belonging to this enclosed area.
            iii. Check the orthogonal neighbours of `(r, c)`.
            iv. If `(r, c)` has red (2) neighbours both to the North `(r-1, c)` and South `(r+1, c)`, OR if it has red neighbours both to the West `(r, c-1)` and East `(r, c+1)`, set `fill_with_azure` to `true` and break the loop for this area (move to step 3.b.vii).
            v.  Alternatively, check if `(r, c)` is adjacent to an "inner corner" of the red structure. This occurs if a red neighbour `(nr, nc)` of `(r, c)` itself has at least two red neighbours such that `(r, c)`, `(nr, nc)`, and the two other red neighbours form a 2x2 block where `(r, c)` is the only white pixel. If such an inner corner configuration is found adjacent to any pixel in the white area, set `fill_with_azure` to `true` and break the loop for this area (move to step 3.b.vii).
            vi. If after checking all pixels in the area, `fill_with_azure` remains `false`, the area should be filled with blue (1).
            vii. Based on the final value of `fill_with_azure`:
                *   If `true`, fill all pixels corresponding to this white area in the output grid with azure (8).
                *   If `false`, fill all pixels corresponding to this white area in the output grid with blue (1).
    4.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule Description:

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all distinct connected areas (components) of white (0) pixels using orthogonal adjacency.
3.  For each white area:
    a.  Determine if it is "enclosed" by red (2) pixels. An area is enclosed if none of its pixels are on the grid's outer border, AND a path of only white pixels cannot reach the border from any pixel within the area. (Effectively, check if any pixel in the area is on the border during the component finding process).
    b.  If the area is enclosed:
        i.  Check if *any* pixel within this enclosed white area has red (2) neighbors directly opposite each other (i.e., North and South neighbors are both red, OR East and West neighbors are both red).
        ii. If such a pixel exists, fill the entire enclosed white area in the output grid with azure (8).
        iii. Otherwise (if no pixel in the enclosed area has opposite red neighbors), fill the entire enclosed white area in the output grid with blue (1).
    c.  If the area is not enclosed (touches the grid border), leave it as white (0).
4.  Red (2) pixels remain unchanged.
5.  Return the modified output grid.
"""

def find_connected_components(grid):
    """Finds connected components of white pixels and checks enclosure."""
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = [] # List to store tuples: (area_coordinates, is_enclosed)

    for r in range(height):
        for c in range(width):
            if grid[r, c] == 0 and not visited[r, c]:
                component_coords = []
                is_enclosed_flag = True # Assume enclosed initially
                q = deque([(r, c)])
                visited[r, c] = True

                while q:
                    curr_r, curr_c = q.popleft()
                    component_coords.append((curr_r, curr_c))

                    # Check if this pixel is on the border
                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:
                        is_enclosed_flag = False # Touched border, not enclosed

                    # Explore neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == 0 and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # Store the found component and its enclosure status
                # The check during BFS/DFS is sufficient for enclosure. If it never hit the border, it's enclosed.
                components.append((component_coords, is_enclosed_flag))
                
    return components

def check_fill_color(area_coords, grid):
    """Determines the fill color (blue or azure) for an enclosed area."""
    height, width = grid.shape
    for r, c in area_coords:
        # Check for opposite red neighbours (North/South)
        has_north_red = (r > 0 and grid[r-1, c] == 2)
        has_south_red = (r < height - 1 and grid[r+1, c] == 2)
        if has_north_red and has_south_red:
            return 8 # Azure

        # Check for opposite red neighbours (West/East)
        has_west_red = (c > 0 and grid[r, c-1] == 2)
        has_east_red = (c < width - 1 and grid[r, c+1] == 2)
        if has_west_red and has_east_red:
            return 8 # Azure
            
    # If no pixel triggered the azure condition, fill with blue
    return 1 # Blue

def fill_area(output_grid, area_coords, fill_color):
    """Fills the specified area in the grid with the given color."""
    for r, c in area_coords:
        output_grid[r, c] = fill_color

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Identifies enclosed white areas and fills them with blue (1) or azure (8)
    based on the configuration of the surrounding red (2) pixels.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Find all connected white areas and their enclosure status
    white_components = find_connected_components(input_grid)

    # Process each white component
    for area_coords, is_enclosed in white_components:
        if is_enclosed:
            # Determine the fill color for this enclosed area
            fill_color = check_fill_color(area_coords, input_grid)
            # Fill the area in the output grid
            fill_area(output_grid, area_coords, fill_color)
        # Else (not enclosed), do nothing, leave as white (0)

    return output_grid
```
