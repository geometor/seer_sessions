
## train_1

**input:**
```
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
```


**output:**
```
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
0 0 0 2 8 8 8 2 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
0 0 0 0 0 0 0 2 8 8 2 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 2 8 8 8 8 8 8 8 8
0 0 0 0 2 2 2 2 2 2 2 2 2
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
0 0 0 0 2 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 2 2 2
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 0 0 2 8 8 8
0 0 0 2 0 0 0 0 0 0 0 0 2 8 8 8
0 0 0 2 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 2 0 0 0 0 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
2 2 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 2 2 2
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
0 0 2 1 1 1 1 1 1 1 1 1 2 0 0 0
```


## train_4

**input:**
```
0 2 0 0 0 0 2 0 0 0 0 0 0
2 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 2 2 2 2 2 0 0 2 0 0 0
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 0 0 2 0
2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 2 0 0 0 0 2 0 0 0 0 0 0
2 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 0 0 0 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 2 2 2 2 2 0 0 2 0 0 0
0 2 0 0 0 0 2 0 0 2 0 0 0
0 2 0 0 0 0 2 2 2 2 2 2 2
0 2 0 0 0 0 2 0 0 0 0 2 8
2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
0 0 2 1 1 1 1 1 1 1 1 1 1
```

*   **Perception:** The task involves modifying input grids containing white (0) background pixels and red (2) structures, often resembling walls or lines. The output grids retain the original red structures but fill certain white areas with either blue (1) or azure (8). The key transformation is identifying white areas completely enclosed by red pixels and filling them based on the shape or configuration of the enclosing red boundary. White areas not enclosed or areas enclosed in different ways receive different fill colors.

*   **Facts:**
    
```yaml
    task_elements:
      - description: Input and Output Grids
        properties:
          format: 2D array of integers (pixels)
          colors_used_input: [white (0), red (2)]
          colors_used_output: [white (0), blue (1), red (2), azure (8)]
          dimensionality: Varies per example (height/width up to 30)
      - description: Red Structures
        properties:
          color: red (2)
          role: Act as barriers or walls
          shape: Lines, corners, complex shapes formed by contiguous red pixels
          persistence: Red structures remain unchanged from input to output
      - description: White Areas
        properties:
          color: white (0)
          role: Background or space potentially modified
          state: Can be 'open' (connected to grid boundary) or 'enclosed' (surrounded by red pixels)
      - description: Filling Action
        properties:
          trigger: A white area is fully enclosed by red pixels (cannot reach the grid boundary by moving only through white pixels orthogonally).
          target: Enclosed white areas
          outcome: The enclosed white area is filled with a new color.
      - description: Fill Color Determination
        properties:
          condition_azure: The enclosed white area has at least one pixel adjacent to a 'concave' feature of the red boundary. This includes being adjacent to an 'inner corner' (a red pixel adjacent to the white pixel, which itself has at least two other red neighbours forming a corner around the white pixel) or having red neighbours on directly opposite sides (e.g., North and South, or East and West).
          fill_color_azure: azure (8)
          condition_blue: The enclosed white area does not meet the condition for azure fill (i.e., its boundary with red pixels consists only of straight segments or 'convex' corners relative to the white area).
          fill_color_blue: blue (1)
      - description: Unmodified Areas
        properties:
          target: White areas not fully enclosed by red pixels.
          outcome: Remain white (0).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify all connected components (areas) of white (0) pixels in the input grid using orthogonal adjacency.
    3.  For each distinct white area:
        a.  Determine if the area is "enclosed". Perform a search (e.g., Flood Fill, BFS, DFS) starting from any pixel within the area, moving only orthogonally through white pixels. If the search reaches any pixel on the boundary edge of the grid, the area is *not* enclosed. Otherwise, it *is* enclosed.
        b.  If the area is enclosed:
            i.  Set a flag `fill_with_azure` to `false`.
            ii. Iterate through each white pixel `(r, c)` belonging to this enclosed area.
            iii. Check the orthogonal neighbours of `(r, c)`.
            iv. If `(r, c)` has red (2) neighbours both to the North `(r-1, c)` and South `(r+1, c)`, OR if it has red neighbours both to the West `(r, c-1)` and East `(r, c+1)`, set `fill_with_azure` to `true` and break the loop for this area (move to step 3.b.vii).
            v.  Alternatively, check if `(r, c)` is adjacent to an "inner corner" of the red structure. This occurs if a red neighbour `(nr, nc)` of `(r, c)` itself has at least two red neighbours such that `(r, c)`, `(nr, nc)`, and the two other red neighbours form a 2x2 block where `(r, c)` is the only white pixel. If such an inner corner configuration is found adjacent to any pixel in the white area, set `fill_with_azure` to `true` and break the loop for this area (move to step 3.b.vii).
            vi. If after checking all pixels in the area, `fill_with_azure` remains `false`, the area should be filled with blue (1).
            vii. Based on the final value of `fill_with_azure`:
                *   If `true`, fill all pixels corresponding to this white area in the output grid with azure (8).
                *   If `false`, fill all pixels corresponding to this white area in the output grid with blue (1).
    4.  Return the modified output grid.
