
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

**Perception**

1.  **Input Structure:** The input grids contain a background color (white in the first example, yellow in the second) and several small, distinct objects of different colors.
2.  **Key Objects:** Two objects stand out as "anchors": one near the top-left and another near the bottom-right. In both examples, these anchor objects are identical in shape and color (3x3 blue squares in `train_1`, 2x2 blue squares in `train_2`).
3.  **Pattern Elements:** There are other objects located immediately to the right of the top-left anchor (forming a "vertical pattern") and immediately below the top-left anchor (forming a "horizontal pattern").
4.  **Transformation:** The core transformation involves using the anchor objects and the associated patterns to generate a larger structure within the grid.
5.  **Tiling/Repetition:** The vertical pattern (right of the top-left anchor) is tiled horizontally to fill the space between the top-left anchor and the vertical position of the bottom-right anchor. Similarly, the horizontal pattern (below the top-left anchor) is tiled vertically to fill the space between the top-left anchor and the horizontal position of the bottom-right anchor.
6.  **Framing:** A rectangular frame is drawn around the newly generated structure (composed of the anchors and the tiled patterns).
7.  **Frame Colors:** The color of the top and bottom segments of the frame is determined by the first non-background color encountered in the vertical pattern (moving right from the top-left anchor). The color of the left and right segments of the frame is determined by the first non-background color encountered in the horizontal pattern (moving down from the top-left anchor). The corners of the frame take the color of the left/right frame segments.
8.  **Output Structure:** The output grid retains the original dimensions and background, but the area defined by the anchors is modified by the tiling process, and a new frame is added around this modified area.

**Facts**


```yaml
Data:
  Input: 2D grid of pixels (0-9)
  Output: 2D grid of pixels (0-9)
  Background_Color: The most frequent color in the input grid.

Objects:
  - Type: Anchor
    Designation: TL_Anchor (Top-Left)
    Identification: The non-background object located furthest top-left.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Anchor
    Designation: BR_Anchor (Bottom-Right)
    Identification: The non-background object located furthest bottom-right.
    Constraint: Must have the same Anchor_Color and Shape as TL_Anchor.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Pattern_Source
    Designation: Vertical_Pattern_Region
    Identification: Rectangular region in the input grid immediately right of TL_Anchor.
    Properties: Shares rows with TL_Anchor, extends from `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Contains the Vertical_Pattern.
  - Type: Pattern_Source
    Designation: Horizontal_Pattern_Region
    Identification: Rectangular region in the input grid immediately below TL_Anchor.
    Properties: Shares columns with TL_Anchor, extends from `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`. Contains the Horizontal_Pattern.
  - Type: Frame
    Identification: A single-pixel-thick rectangle surrounding the generated structure.
    Properties:
      - Vertical_Frame_Color: Color of the top-leftmost non-background pixel in Vertical_Pattern_Region.
      - Horizontal_Frame_Color: Color of the top-leftmost non-background pixel in Horizontal_Pattern_Region.
      - Top/Bottom segments use Vertical_Frame_Color.
      - Left/Right segments (including corners) use Horizontal_Frame_Color.

Relationships:
  - TL_Anchor and BR_Anchor define the bounds of the primary transformation area.
  - Vertical_Pattern_Region is adjacent (right) to TL_Anchor.
  - Horizontal_Pattern_Region is adjacent (below) to TL_Anchor.

Actions:
  - Identify background color.
  - Find all non-background objects.
  - Identify TL_Anchor and BR_Anchor, verifying color/shape match.
  - Extract Vertical_Pattern from Vertical_Pattern_Region.
  - Extract Horizontal_Pattern from Horizontal_Pattern_Region.
  - Determine Vertical_Frame_Color and Horizontal_Frame_Color.
  - Copy input grid to create initial output grid.
  - Tile Vertical_Pattern horizontally into the output grid between anchors.
  - Tile Horizontal_Pattern vertically into the output grid between anchors.
  - Calculate frame boundaries based on the combined extent of anchors and tiled patterns.
  - Draw the frame onto the output grid using derived colors.
```


**Natural Language Program**

1.  Create a copy of the input grid; this will be the basis for the output grid.
2.  Identify the background color by finding the most frequent pixel value in the input grid.
3.  Find all contiguous objects composed of non-background colors. Record their properties (color, shape, bounding box).
4.  Identify the object whose top-left corner has the minimum row, then minimum column (TL_Anchor).
5.  Identify the object whose bottom-right corner has the maximum row, then maximum column (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor have the same color and shape. If not, the pattern doesn't apply.
7.  Define the Vertical Pattern Region in the input grid: rows = `TL_Anchor.top_row` to `TL_Anchor.bottom_row`, columns = `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Extract the subgrid corresponding to this region as the `Vertical_Pattern`.
8.  Define the Horizontal Pattern Region in the input grid: rows = `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`, columns = `TL_Anchor.left_col` to `TL_Anchor.right_col`. Extract the subgrid corresponding to this region as the `Horizontal_Pattern`.
9.  Determine the Vertical Frame Color: Find the color of the first non-background pixel encountered when scanning the `Vertical_Pattern` region row by row, then column by column.
10. Determine the Horizontal Frame Color: Find the color of the first non-background pixel encountered when scanning the `Horizontal_Pattern` region row by row, then column by column.
11. Tile the `Vertical_Pattern` horizontally into the output grid: Iterate through the rows from `TL_Anchor.top_row` to `TL_Anchor.bottom_row`. Within each row, repeatedly copy the corresponding row slice of the `Vertical_Pattern` into the output grid columns starting from `TL_Anchor.right_col + 1`, continuing until reaching `BR_Anchor.left_col`.
12. Tile the `Horizontal_Pattern` vertically into the output grid: Iterate through the columns from `TL_Anchor.left_col` to `TL_Anchor.right_col`. Within each column, repeatedly copy the corresponding column slice of the `Horizontal_Pattern` into the output grid rows starting from `TL_Anchor.bottom_row + 1`, continuing until reaching `BR_Anchor.top_row`.
13. Define the frame boundaries:
    *   `frame_top_row = TL_Anchor.top_row - 1`
    *   `frame_bottom_row = BR_Anchor.bottom_row + 1`
    *   `frame_left_c = TL_Anchor.left_col - 1`
    *   `frame_right_c = BR_Anchor.right_col + 1`
14. Draw the frame onto the output grid:
    *   Draw the left frame segment: Fill column `frame_left_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the right frame segment: Fill column `frame_right_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the top frame segment: Fill row `frame_top_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
    *   Draw the bottom frame segment: Fill row `frame_bottom_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
15. The modified grid is the final output.
