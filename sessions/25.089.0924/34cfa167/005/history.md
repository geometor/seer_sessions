
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

**Perception**

1.  **Input Structure:** The input grids contain a background color (white in the first example, yellow in the second) and several small, distinct objects of different colors.
2.  **Key Objects:** Two objects stand out as "anchors": one near the top-left and another near the bottom-right. In both examples, these anchor objects are identical in shape and color (3x3 blue squares in `train_1`, 2x2 blue squares in `train_2`).
3.  **Pattern Elements:** There are other objects located immediately to the right of the top-left anchor (forming a "vertical pattern") and immediately below the top-left anchor (forming a "horizontal pattern").
4.  **Transformation:** The core transformation involves using the anchor objects and the associated patterns to generate a larger structure within the grid.
5.  **Tiling/Repetition:** The vertical pattern (right of the top-left anchor) is tiled horizontally to fill the space between the top-left anchor and the vertical position of the bottom-right anchor. Similarly, the horizontal pattern (below the top-left anchor) is tiled vertically to fill the space between the top-left anchor and the horizontal position of the bottom-right anchor.
6.  **Framing:** A rectangular frame is drawn around the newly generated structure (composed of the anchors and the tiled patterns).
7.  **Frame Colors:** The color of the top and bottom segments of the frame is determined by the first non-background color encountered in the vertical pattern (moving right from the top-left anchor). The color of the left and right segments of the frame is determined by the first non-background color encountered in the horizontal pattern (moving down from the top-left anchor). The corners of the frame take the color of the left/right frame segments.
8.  **Output Structure:** The output grid retains the original dimensions and background, but the area defined by the anchors is modified by the tiling process, and a new frame is added around this modified area.

**Facts**


```yaml
Data:
  Input: 2D grid of pixels (0-9)
  Output: 2D grid of pixels (0-9)
  Background_Color: The most frequent color in the input grid.

Objects:
  - Type: Anchor
    Designation: TL_Anchor (Top-Left)
    Identification: The non-background object located furthest top-left.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Anchor
    Designation: BR_Anchor (Bottom-Right)
    Identification: The non-background object located furthest bottom-right.
    Constraint: Must have the same Anchor_Color and Shape as TL_Anchor.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Pattern_Source
    Designation: Vertical_Pattern_Region
    Identification: Rectangular region in the input grid immediately right of TL_Anchor.
    Properties: Shares rows with TL_Anchor, extends from `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Contains the Vertical_Pattern.
  - Type: Pattern_Source
    Designation: Horizontal_Pattern_Region
    Identification: Rectangular region in the input grid immediately below TL_Anchor.
    Properties: Shares columns with TL_Anchor, extends from `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`. Contains the Horizontal_Pattern.
  - Type: Frame
    Identification: A single-pixel-thick rectangle surrounding the generated structure.
    Properties:
      - Vertical_Frame_Color: Color of the top-leftmost non-background pixel in Vertical_Pattern_Region.
      - Horizontal_Frame_Color: Color of the top-leftmost non-background pixel in Horizontal_Pattern_Region.
      - Top/Bottom segments use Vertical_Frame_Color.
      - Left/Right segments (including corners) use Horizontal_Frame_Color.

Relationships:
  - TL_Anchor and BR_Anchor define the bounds of the primary transformation area.
  - Vertical_Pattern_Region is adjacent (right) to TL_Anchor.
  - Horizontal_Pattern_Region is adjacent (below) to TL_Anchor.

Actions:
  - Identify background color.
  - Find all non-background objects.
  - Identify TL_Anchor and BR_Anchor, verifying color/shape match.
  - Extract Vertical_Pattern from Vertical_Pattern_Region.
  - Extract Horizontal_Pattern from Horizontal_Pattern_Region.
  - Determine Vertical_Frame_Color and Horizontal_Frame_Color.
  - Copy input grid to create initial output grid.
  - Tile Vertical_Pattern horizontally into the output grid between anchors.
  - Tile Horizontal_Pattern vertically into the output grid between anchors.
  - Calculate frame boundaries based on the combined extent of anchors and tiled patterns.
  - Draw the frame onto the output grid using derived colors.
```


**Natural Language Program**

1.  Create a copy of the input grid; this will be the basis for the output grid.
2.  Identify the background color by finding the most frequent pixel value in the input grid.
3.  Find all contiguous objects composed of non-background colors. Record their properties (color, shape, bounding box).
4.  Identify the object whose top-left corner has the minimum row, then minimum column (TL_Anchor).
5.  Identify the object whose bottom-right corner has the maximum row, then maximum column (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor have the same color and shape. If not, the pattern doesn't apply.
7.  Define the Vertical Pattern Region in the input grid: rows = `TL_Anchor.top_row` to `TL_Anchor.bottom_row`, columns = `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Extract the subgrid corresponding to this region as the `Vertical_Pattern`.
8.  Define the Horizontal Pattern Region in the input grid: rows = `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`, columns = `TL_Anchor.left_col` to `TL_Anchor.right_col`. Extract the subgrid corresponding to this region as the `Horizontal_Pattern`.
9.  Determine the Vertical Frame Color: Find the color of the first non-background pixel encountered when scanning the `Vertical_Pattern` region row by row, then column by column.
10. Determine the Horizontal Frame Color: Find the color of the first non-background pixel encountered when scanning the `Horizontal_Pattern` region row by row, then column by column.
11. Tile the `Vertical_Pattern` horizontally into the output grid: Iterate through the rows from `TL_Anchor.top_row` to `TL_Anchor.bottom_row`. Within each row, repeatedly copy the corresponding row slice of the `Vertical_Pattern` into the output grid columns starting from `TL_Anchor.right_col + 1`, continuing until reaching `BR_Anchor.left_col`.
12. Tile the `Horizontal_Pattern` vertically into the output grid: Iterate through the columns from `TL_Anchor.left_col` to `TL_Anchor.right_col`. Within each column, repeatedly copy the corresponding column slice of the `Horizontal_Pattern` into the output grid rows starting from `TL_Anchor.bottom_row + 1`, continuing until reaching `BR_Anchor.top_row`.
13. Define the frame boundaries:
    *   `frame_top_row = TL_Anchor.top_row - 1`
    *   `frame_bottom_row = BR_Anchor.bottom_row + 1`
    *   `frame_left_c = TL_Anchor.left_col - 1`
    *   `frame_right_c = BR_Anchor.right_col + 1`
14. Draw the frame onto the output grid:
    *   Draw the left frame segment: Fill column `frame_left_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the right frame segment: Fill column `frame_right_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the top frame segment: Fill row `frame_top_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
    *   Draw the bottom frame segment: Fill row `frame_bottom_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
15. The modified grid is the final output.
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1. Identify the background color (most frequent color).
2. Find all distinct, contiguous non-background objects.
3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).
4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions).
5. Extract the rectangular region immediately to the right of TL_Anchor, up to the column before BR_Anchor, as the Vertical_Pattern.
6. Extract the rectangular region immediately below TL_Anchor, up to the row before BR_Anchor, as the Horizontal_Pattern.
7. Determine the Vertical_Frame_Color by finding the first non-background color in the Vertical_Pattern region (scanning row by row, then column by column).
8. Determine the Horizontal_Frame_Color by finding the first non-background color in the Horizontal_Pattern region (scanning row by row, then column by column).
9. Create an output grid initialized as a copy of the input grid.
10. Tile the Vertical_Pattern horizontally in the output grid, filling the area between the anchors' vertical extent and between the right edge of TL_Anchor and the left edge of BR_Anchor.
11. Tile the Horizontal_Pattern vertically in the output grid, filling the area between the anchors' horizontal extent and between the bottom edge of TL_Anchor and the top edge of BR_Anchor.
12. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.
13. Draw the frame:
    - Left and Right vertical segments use Horizontal_Frame_Color.
    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.
"""

# Helper class to store object information
class GridObject:
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        rows = [r for r, c in pixels]
        cols = [c for r, c in pixels]
        self.min_row = min(rows)
        self.min_col = min(cols)
        self.max_row = max(rows)
        self.max_col = max(cols)
        self.height = self.max_row - self.min_row + 1
        self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Simple shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"


def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region."""
    for r in range(r_start, r_end):
        for c in range(c_start, c_end):
            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                if grid[r, c] != background_color:
                    return grid[r, c]
    return None # Should not happen based on examples, but good practice


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the tiling and framing transformation based on anchor objects.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 1. Identify background color
    counts = Counter(input_grid.flatten())
    background_color = counts.most_common(1)[0][0]

    # 2. Find all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No objects, no transformation

    # 3. Identify TL_Anchor and BR_Anchor
    # Sort by top-row, then left-column for TL
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # Sort by bottom-row (desc), then right-column (desc) for BR
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure we didn't pick the same object if there's only one
    if len(objects) == 1:
         return output_grid # Cannot form pattern with one object

    # Handle cases where TL and BR might be the same due to sorting criteria
    # Re-find BR by explicitly looking for max row/col if TL and BR are identical initially
    if tl_anchor is br_anchor:
         potential_br = [o for o in objects if o is not tl_anchor]
         if not potential_br:
              return output_grid # Still only one effective anchor
         potential_br.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
         br_anchor = potential_br[0]

    # Check if TL and BR are distinct and valid candidates
    if tl_anchor is br_anchor or not tl_anchor or not br_anchor:
        # Fallback or error: Cannot determine distinct anchors
        # Based on examples, this shouldn't happen if the pattern is applicable
        return output_grid

    # 4. Verify anchors match in color and shape (dimensions)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        # Anchors don't match criteria
        return output_grid

    # --- Define pattern regions ---
    vp_r_start = tl_anchor.min_row
    vp_r_end = tl_anchor.max_row + 1
    vp_c_start = tl_anchor.max_col + 1
    vp_c_end = br_anchor.min_col

    hp_r_start = tl_anchor.max_row + 1
    hp_r_end = br_anchor.min_row
    hp_c_start = tl_anchor.min_col
    hp_c_end = tl_anchor.max_col + 1

    # Check if regions have valid dimensions (end > start)
    valid_vp = vp_r_end > vp_r_start and vp_c_end > vp_c_start
    valid_hp = hp_r_end > hp_r_start and hp_c_end > hp_c_start

    if not valid_vp or not valid_hp:
         # If either pattern region is invalid/empty, cannot proceed
         return output_grid

    # 5. Extract Vertical_Pattern
    vertical_pattern = input_grid[vp_r_start:vp_r_end, vp_c_start:vp_c_end]
    vp_h, vp_w = vertical_pattern.shape

    # 6. Extract Horizontal_Pattern
    horizontal_pattern = input_grid[hp_r_start:hp_r_end, hp_c_start:hp_c_end]
    hp_h, hp_w = horizontal_pattern.shape

    # Check if patterns are empty (although region check should cover this)
    if vp_h == 0 or vp_w == 0 or hp_h == 0 or hp_w == 0:
         return output_grid

    # 7. Determine Vertical_Frame_Color
    vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                     vp_r_start, vp_r_end, 
                                                     vp_c_start, vp_c_end)
                                                      
    # 8. Determine Horizontal_Frame_Color
    horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                       hp_r_start, hp_r_end,
                                                       hp_c_start, hp_c_end)

    # Check if frame colors were found
    if vertical_frame_color is None or horizontal_frame_color is None:
        # Should not happen in valid examples
        return output_grid
        
    # --- Apply Transformations to output_grid ---

    # 10. Tile Vertical_Pattern horizontally
    target_c_start = tl_anchor.max_col + 1
    target_c_end = br_anchor.min_col
    for c in range(target_c_start, target_c_end):
        pattern_col_idx = (c - target_c_start) % vp_w
        output_grid[vp_r_start:vp_r_end, c] = vertical_pattern[:, pattern_col_idx]

    # 11. Tile Horizontal_Pattern vertically
    target_r_start = tl_anchor.max_row + 1
    target_r_end = br_anchor.min_row
    for r in range(target_r_start, target_r_end):
        pattern_row_idx = (r - target_r_start) % hp_h
        output_grid[r, hp_c_start:hp_c_end] = horizontal_pattern[pattern_row_idx, :]

    # --- Draw Frame ---
    # 12. Define frame boundaries
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_col - 1
    frame_right = br_anchor.max_col + 1

    # 13. Draw the frame safely within grid bounds
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start = max(0, frame_top)
        row_end = min(height, frame_bottom + 1)
        output_grid[row_start:row_end, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start = max(0, frame_top)
        row_end = min(height, frame_bottom + 1)
        output_grid[row_start:row_end, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars
    col_start = max(0, frame_left + 1)
    col_end = min(width, frame_right)
    if 0 <= frame_top < height and col_end > col_start:
        output_grid[frame_top, col_start:col_end] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end > col_start:
        output_grid[frame_bottom, col_start:col_end] = vertical_frame_color

    return output_grid
```
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1. Identify the background color (most frequent color).
2. Find all distinct, contiguous non-background objects.
3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).
4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions). If not, return the input grid unchanged.
5. Extract the repeating Vertical Pattern: Find the rectangular region immediately to the right of TL_Anchor that shares its rows. Scan columns rightwards from TL_Anchor's right edge until a column consisting entirely of the background color is found. The pattern is the block of columns before this background column. If no background column is found before BR_Anchor's left edge, use all columns up to BR_Anchor's left edge.
6. Extract the repeating Horizontal Pattern: Find the rectangular region immediately below TL_Anchor that shares its columns. Scan rows downwards from TL_Anchor's bottom edge until a row consisting entirely of the background color is found. The pattern is the block of rows before this background row. If no background row is found before BR_Anchor's top edge, use all rows up to BR_Anchor's top edge.
7. Determine the Vertical_Frame_Color: Scan the region defined by TL_Anchor's rows and the columns between TL_Anchor's right edge and BR_Anchor's left edge. Find the first non-background color encountered (scanning row by row, then column by column).
8. Determine the Horizontal_Frame_Color: Scan the region defined by TL_Anchor's columns and the rows between TL_Anchor's bottom edge and BR_Anchor's top edge. Find the first non-background color encountered (scanning row by row, then column by column).
9. If either frame color cannot be determined (e.g., regions are empty or all background), return the input grid unchanged.
10. Create an output grid initialized as a copy of the input grid.
11. Tile the extracted Vertical_Pattern horizontally in the output grid, filling the area defined by TL_Anchor's rows and the columns between the right edge of TL_Anchor and the left edge of BR_Anchor. Use modulo arithmetic based on the pattern's width for repetition.
12. Tile the extracted Horizontal_Pattern vertically in the output grid, filling the area defined by TL_Anchor's columns and the rows between the bottom edge of TL_Anchor and the top edge of BR_Anchor. Use modulo arithmetic based on the pattern's height for repetition.
13. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.
14. Draw the frame onto the output grid, ensuring it stays within grid bounds:
    - Left and Right vertical segments (including corners) use Horizontal_Frame_Color.
    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.
15. Return the modified output grid.
"""

# Helper class to store object information
class GridObject:
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        if not pixels:
             # Should not happen with valid objects, but prevent errors
            self.min_row, self.min_col = -1, -1
            self.max_row, self.max_col = -1, -1
            self.height, self.width = 0, 0
        else:
            rows = [r for r, c in pixels]
            cols = [c for r, c in pixels]
            self.min_row = min(rows)
            self.min_col = min(cols)
            self.max_row = max(rows)
            self.max_col = max(cols)
            self.height = self.max_row - self.min_row + 1
            self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"

def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors using 4-connectivity."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                obj_pixels_list = [] # Keep order for easier debugging if needed
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))
                    obj_pixels_list.append((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region (row-major scan)."""
    height, width = grid.shape
    # Ensure ranges are valid and within grid bounds before iterating
    r_start_safe = max(0, r_start)
    r_end_safe = min(height, r_end)
    c_start_safe = max(0, c_start)
    c_end_safe = min(width, c_end)

    for r in range(r_start_safe, r_end_safe):
        for c in range(c_start_safe, c_end_safe):
             if grid[r, c] != background_color:
                 return grid[r, c]
    return None # No non-background color found


def transform(input_grid: np.ndarray) -> np.ndarray:
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 1. Identify background color
    counts = Counter(input_grid.flatten())
    if not counts: # Handle empty grid case
        return output_grid
    background_color = counts.most_common(1)[0][0]

    # 2. Find all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No objects, no transformation

    # 3. Identify TL_Anchor and BR_Anchor
    # Sort by top-row, then left-column for TL
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # Sort by bottom-row (desc), then right-column (desc) for BR
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure distinct anchors if multiple objects exist
    if len(objects) > 1 and tl_anchor is br_anchor:
         # If TL and BR based on initial sorts are the same, re-evaluate BR
         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], 
                                          key=lambda o: (o.max_row, o.max_col), 
                                          reverse=True)
         if potential_br_candidates:
             br_anchor = potential_br_candidates[0]
         else: # Only one object was found effectively
             return output_grid
             
    # Final check if anchors are distinct
    if tl_anchor is br_anchor:
         return output_grid # Cannot proceed if anchors are not distinct

    # 4. Verify anchors match in color and shape (dimensions)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        return output_grid # Anchors don't match criteria

    # --- Define Potential Regions for Frame Color Determination ---
    frame_vp_r_start = tl_anchor.min_row
    frame_vp_r_end = tl_anchor.max_row + 1
    frame_vp_c_start = tl_anchor.max_col + 1
    frame_vp_c_end = br_anchor.min_col

    frame_hp_r_start = tl_anchor.max_row + 1
    frame_hp_r_end = br_anchor.min_row
    frame_hp_c_start = tl_anchor.min_col
    frame_hp_c_end = tl_anchor.max_col + 1

    # Check if these frame determination regions have positive dimensions
    valid_frame_vp_region = frame_vp_r_end > frame_vp_r_start and frame_vp_c_end > frame_vp_c_start
    valid_frame_hp_region = frame_hp_r_end > frame_hp_r_start and frame_hp_c_end > frame_hp_c_start

    # 7. Determine Vertical_Frame_Color (from potential region)
    vertical_frame_color = None
    if valid_frame_vp_region:
        vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                         frame_vp_r_start, frame_vp_r_end, 
                                                         frame_vp_c_start, frame_vp_c_end)
                                                      
    # 8. Determine Horizontal_Frame_Color (from potential region)
    horizontal_frame_color = None
    if valid_frame_hp_region:
        horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                           frame_hp_r_start, frame_hp_r_end,
                                                           frame_hp_c_start, frame_hp_c_end)

    # 9. Check if frame colors were found (if regions were valid)
    if (valid_frame_vp_region and vertical_frame_color is None) or \
       (valid_frame_hp_region and horizontal_frame_color is None):
         # If a region exists but has no non-background color, rule might not apply
         # Or if frame colors are essential and missing, return original
         # For this task, frame colors seem essential.
         return output_grid
         
    # If a region didn't exist, we might still proceed if the other exists.
    # However, the examples imply both patterns and frame colors derived from them exist.
    # Let's enforce that both frame colors must be found if their regions are valid.
    if vertical_frame_color is None or horizontal_frame_color is None:
        return output_grid # Essential colors missing


    # --- Extract Actual Repeating Patterns ---
    
    # 5. Extract Vertical Pattern
    vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1)
    vp_start_col = tl_anchor.max_col + 1
    vp_end_col = vp_start_col 
    for c in range(vp_start_col, br_anchor.min_col):
        # Ensure column index is valid before checking
        if c >= width: break 
        # Check if the column slice within anchor rows is all background
        if np.all(input_grid[vp_rows, c] == background_color):
            vp_end_col = c # End column is the first background-only column
            break
    else: # No background column found before BR anchor
        vp_end_col = br_anchor.min_col

    # Check if vp_end_col makes sense (it must be > vp_start_col for a pattern)
    if vp_end_col <= vp_start_col:
         # Vertical pattern is empty or invalid
         return output_grid 
    vertical_pattern = input_grid[vp_rows, vp_start_col:vp_end_col]
    vp_h, vp_w = vertical_pattern.shape
    if vp_h == 0 or vp_w == 0: return output_grid # Pattern is empty

    # 6. Extract Horizontal Pattern
    hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1)
    hp_start_row = tl_anchor.max_row + 1
    hp_end_row = hp_start_row
    for r in range(hp_start_row, br_anchor.min_row):
        if r >= height: break
        if np.all(input_grid[r, hp_cols] == background_color):
            hp_end_row = r
            break
    else: # No background row found
        hp_end_row = br_anchor.min_row
        
    if hp_end_row <= hp_start_row:
        # Horizontal pattern is empty or invalid
        return output_grid
    horizontal_pattern = input_grid[hp_start_row:hp_end_row, hp_cols]
    hp_h, hp_w = horizontal_pattern.shape
    if hp_h == 0 or hp_w == 0: return output_grid # Pattern is empty


    # --- Apply Transformations to output_grid ---

    # 11. Tile Vertical_Pattern horizontally
    target_vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1) # Rows to fill
    target_vp_c_start = tl_anchor.max_col + 1
    target_vp_c_end = br_anchor.min_col 
    for c in range(target_vp_c_start, target_vp_c_end):
        # Check column bounds
        if c >= width: break 
        pattern_col_idx = (c - target_vp_c_start) % vp_w
        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]

    # 12. Tile Horizontal_Pattern vertically
    target_hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1) # Columns to fill
    target_hp_r_start = tl_anchor.max_row + 1
    target_hp_r_end = br_anchor.min_row
    for r in range(target_hp_r_start, target_hp_r_end):
        if r >= height: break
        pattern_row_idx = (r - target_hp_r_start) % hp_h
        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]

    # --- Draw Frame ---
    # 13. Define frame boundaries
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_col - 1
    frame_right = br_anchor.max_col + 1

    # 14. Draw the frame safely within grid bounds
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe: # Check if there's any row to draw
             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe:
             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges
    col_start_safe = max(0, frame_left + 1)
    col_end_safe = min(width, frame_right) # End index is exclusive for slicing
    
    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0
        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:
        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color

    # 15. Return final grid
    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1. Identify the background color (most frequent color).
2. Find all distinct, contiguous non-background objects.
3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).
4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions). If not, return the input grid unchanged.
5. Extract the repeating Vertical Pattern: Find the rectangular region immediately to the right of TL_Anchor that shares its rows. Scan columns rightwards from TL_Anchor's right edge until a column consisting entirely of the background color is found. The pattern is the block of columns before this background column. If no background column is found before BR_Anchor's left edge, use all columns up to BR_Anchor's left edge.
6. Extract the repeating Horizontal Pattern: Find the rectangular region immediately below TL_Anchor that shares its columns. Scan rows downwards from TL_Anchor's bottom edge until a row consisting entirely of the background color is found. The pattern is the block of rows before this background row. If no background row is found before BR_Anchor's top edge, use all rows up to BR_Anchor's top edge.
7. Determine the Vertical_Frame_Color: Scan the region defined by TL_Anchor's rows and the columns between TL_Anchor's right edge and BR_Anchor's left edge. Find the first non-background color encountered (scanning row by row, then column by column).
8. Determine the Horizontal_Frame_Color: Scan the region defined by TL_Anchor's columns and the rows between TL_Anchor's bottom edge and BR_Anchor's top edge. Find the first non-background color encountered (scanning row by row, then column by column).
9. If either frame color cannot be determined (e.g., regions are empty or all background), return the input grid unchanged.
10. Create an output grid initialized as a copy of the input grid.
11. Tile the extracted Vertical_Pattern horizontally in the output grid, filling the area defined by TL_Anchor's rows and the columns between the right edge of TL_Anchor and the left edge of BR_Anchor. Use modulo arithmetic based on the pattern's width for repetition.
12. Tile the extracted Horizontal_Pattern vertically in the output grid, filling the area defined by TL_Anchor's columns and the rows between the bottom edge of TL_Anchor and the top edge of BR_Anchor. Use modulo arithmetic based on the pattern's height for repetition.
13. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.
14. Draw the frame onto the output grid, ensuring it stays within grid bounds:
    - Left and Right vertical segments (including corners) use Horizontal_Frame_Color.
    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.
15. Return the modified output grid.
"""

# Helper class to store object information
class GridObject:
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        if not pixels:
             # Should not happen with valid objects, but prevent errors
            self.min_row, self.min_col = -1, -1
            self.max_row, self.max_col = -1, -1
            self.height, self.width = 0, 0
        else:
            rows = [r for r, c in pixels]
            cols = [c for r, c in pixels]
            self.min_row = min(rows)
            self.min_col = min(cols)
            self.max_row = max(rows)
            self.max_col = max(cols)
            self.height = self.max_row - self.min_row + 1
            self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"

def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors using 4-connectivity."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                obj_pixels_list = [] # Keep order for easier debugging if needed
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))
                    obj_pixels_list.append((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region (row-major scan)."""
    height, width = grid.shape
    # Ensure ranges are valid and within grid bounds before iterating
    r_start_safe = max(0, r_start)
    r_end_safe = min(height, r_end)
    c_start_safe = max(0, c_start)
    c_end_safe = min(width, c_end)

    for r in range(r_start_safe, r_end_safe):
        for c in range(c_start_safe, c_end_safe):
             if grid[r, c] != background_color:
                 return grid[r, c]
    return None # No non-background color found


def transform(input_grid: np.ndarray) -> np.ndarray:
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 1. Identify background color
    counts = Counter(input_grid.flatten())
    if not counts: # Handle empty grid case
        return output_grid
    background_color = counts.most_common(1)[0][0]

    # 2. Find all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No objects, no transformation

    # 3. Identify TL_Anchor and BR_Anchor
    # Sort by top-row, then left-column for TL
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # Sort by bottom-row (desc), then right-column (desc) for BR
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure distinct anchors if multiple objects exist
    if len(objects) > 1 and tl_anchor is br_anchor:
         # If TL and BR based on initial sorts are the same, re-evaluate BR
         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], 
                                          key=lambda o: (o.max_row, o.max_col), 
                                          reverse=True)
         if potential_br_candidates:
             br_anchor = potential_br_candidates[0]
         else: # Only one object was found effectively
             return output_grid
             
    # Final check if anchors are distinct
    if tl_anchor is br_anchor:
         return output_grid # Cannot proceed if anchors are not distinct

    # 4. Verify anchors match in color and shape (dimensions)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        return output_grid # Anchors don't match criteria

    # --- Define Potential Regions for Frame Color Determination ---
    frame_vp_r_start = tl_anchor.min_row
    frame_vp_r_end = tl_anchor.max_row + 1
    frame_vp_c_start = tl_anchor.max_col + 1
    frame_vp_c_end = br_anchor.min_col

    frame_hp_r_start = tl_anchor.max_row + 1
    frame_hp_r_end = br_anchor.min_row
    frame_hp_c_start = tl_anchor.min_col
    frame_hp_c_end = tl_anchor.max_col + 1

    # Check if these frame determination regions have positive dimensions
    valid_frame_vp_region = frame_vp_r_end > frame_vp_r_start and frame_vp_c_end > frame_vp_c_start
    valid_frame_hp_region = frame_hp_r_end > frame_hp_r_start and frame_hp_c_end > frame_hp_c_start

    # 7. Determine Vertical_Frame_Color (from potential region)
    vertical_frame_color = None
    if valid_frame_vp_region:
        vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                         frame_vp_r_start, frame_vp_r_end, 
                                                         frame_vp_c_start, frame_vp_c_end)
                                                      
    # 8. Determine Horizontal_Frame_Color (from potential region)
    horizontal_frame_color = None
    if valid_frame_hp_region:
        horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                           frame_hp_r_start, frame_hp_r_end,
                                                           frame_hp_c_start, frame_hp_c_end)

    # 9. Check if frame colors were found (if regions were valid)
    if (valid_frame_vp_region and vertical_frame_color is None) or \
       (valid_frame_hp_region and horizontal_frame_color is None):
         # If a region exists but has no non-background color, rule might not apply
         # Or if frame colors are essential and missing, return original
         # For this task, frame colors seem essential.
         return output_grid
         
    # If a region didn't exist, we might still proceed if the other exists.
    # However, the examples imply both patterns and frame colors derived from them exist.
    # Let's enforce that both frame colors must be found if their regions are valid.
    if vertical_frame_color is None or horizontal_frame_color is None:
        return output_grid # Essential colors missing


    # --- Extract Actual Repeating Patterns ---
    
    # 5. Extract Vertical Pattern
    vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1)
    vp_start_col = tl_anchor.max_col + 1
    vp_end_col = vp_start_col 
    for c in range(vp_start_col, br_anchor.min_col):
        # Ensure column index is valid before checking
        if c >= width: break 
        # Check if the column slice within anchor rows is all background
        if np.all(input_grid[vp_rows, c] == background_color):
            vp_end_col = c # End column is the first background-only column
            break
    else: # No background column found before BR anchor
        vp_end_col = br_anchor.min_col

    # Check if vp_end_col makes sense (it must be > vp_start_col for a pattern)
    if vp_end_col <= vp_start_col:
         # Vertical pattern is empty or invalid
         return output_grid 
    vertical_pattern = input_grid[vp_rows, vp_start_col:vp_end_col]
    vp_h, vp_w = vertical_pattern.shape
    if vp_h == 0 or vp_w == 0: return output_grid # Pattern is empty

    # 6. Extract Horizontal Pattern
    hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1)
    hp_start_row = tl_anchor.max_row + 1
    hp_end_row = hp_start_row
    for r in range(hp_start_row, br_anchor.min_row):
        if r >= height: break
        if np.all(input_grid[r, hp_cols] == background_color):
            hp_end_row = r
            break
    else: # No background row found
        hp_end_row = br_anchor.min_row
        
    if hp_end_row <= hp_start_row:
        # Horizontal pattern is empty or invalid
        return output_grid
    horizontal_pattern = input_grid[hp_start_row:hp_end_row, hp_cols]
    hp_h, hp_w = horizontal_pattern.shape
    if hp_h == 0 or hp_w == 0: return output_grid # Pattern is empty


    # --- Apply Transformations to output_grid ---

    # 11. Tile Vertical_Pattern horizontally
    target_vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1) # Rows to fill
    target_vp_c_start = tl_anchor.max_col + 1
    target_vp_c_end = br_anchor.min_col 
    for c in range(target_vp_c_start, target_vp_c_end):
        # Check column bounds
        if c >= width: break 
        pattern_col_idx = (c - target_vp_c_start) % vp_w
        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]

    # 12. Tile Horizontal_Pattern vertically
    target_hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1) # Columns to fill
    target_hp_r_start = tl_anchor.max_row + 1
    target_hp_r_end = br_anchor.min_row
    for r in range(target_hp_r_start, target_hp_r_end):
        if r >= height: break
        pattern_row_idx = (r - target_hp_r_start) % hp_h
        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]

    # --- Draw Frame ---
    # 13. Define frame boundaries
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_col - 1
    frame_right = br_anchor.max_col + 1

    # 14. Draw the frame safely within grid bounds
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe: # Check if there's any row to draw
             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe:
             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges
    col_start_safe = max(0, frame_left + 1)
    col_end_safe = min(width, frame_right) # End index is exclusive for slicing
    
    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0
        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:
        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color

    # 15. Return final grid
    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 0 0 0
0 0 8 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 8 0 0 0
0 0 8 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 8 0 0 0
0 0 8 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 8 0 0 0
0 0 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 142
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 45.5128205128205

## Example 2:
Input:
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Expected Output:
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Transformed Output:
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 4 4 4
3 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 3 4 4 4
3 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 3 4 4 4
3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Match: False
Pixels Off: 82
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 41.414141414141426
**General Assessment**

The initial analysis correctly identified the core concept of using Top-Left (TL) and Bottom-Right (BR) anchor objects to define regions for pattern tiling and framing. However, the code failed because the pattern extraction logic was incorrect. It stopped prematurely at the first encountered background column/row within the pattern region, instead of capturing the entire intended pattern block defined between the anchors. The frame color determination and application logic appeared correct in principle but produced incorrect results due to the faulty tiling caused by the incorrect pattern extraction.

The strategy for resolution is:

1.  **Correct Pattern Extraction:** Modify the logic to extract the *entire* rectangular region between the TL anchor's right edge and the BR anchor's left edge (for the vertical pattern) and between the TL anchor's bottom edge and the BR anchor's top edge (for the horizontal pattern).
2.  **Verify Frame Color Logic:** Re-confirm that the frame colors are derived correctly from the *first non-background pixel* within these *full* pattern regions.
3.  **Verify Tiling:** Ensure the corrected patterns are tiled correctly using modulo arithmetic within the bounds defined by the anchors.
4.  **Verify Framing:** Confirm the frame is drawn one pixel outside the anchors' bounding box using the correctly derived colors (Horizontal color for sides, Vertical color for top/bottom).

**Metrics and Analysis**


*code_execution:*
```python
import numpy as np
from collections import Counter

# Helper function to find objects (simplified for analysis)
def get_object_bounds(grid, background_color):
    objects = {}
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)
    obj_id = 0
    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                obj_id += 1
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))
                    min_r = min(min_r, row)
                    min_c = min(min_c, col)
                    max_r = max(max_r, row)
                    max_c = max(max_c, col)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                objects[obj_id] = {
                    'color': color, 'min_r': min_r, 'min_c': min_c,
                    'max_r': max_r, 'max_c': max_c,
                    'height': max_r - min_r + 1, 'width': max_c - min_c + 1
                }
    return objects

# Find first non-background helper
def find_first_non_bg(grid, bg_color, r0, r1, c0, c1):
     h, w = grid.shape
     for r in range(max(0, r0), min(h, r1)):
         for c in range(max(0, c0), min(w, c1)):
             if grid[r, c] != bg_color:
                 return grid[r, c]
     return None

# --- Example 1 Analysis ---
input_1 = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,1,1,4,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,1,1,4,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,1,1,4,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])
bg_1 = 0
objs_1 = get_object_bounds(input_1, bg_1)

# Find TL and BR anchors (simplified logic assumes they are found correctly by sorting)
tl_anchor_1 = {'min_r': 2, 'min_c': 3, 'max_r': 4, 'max_c': 5, 'color': 1, 'height': 3, 'width': 3}
br_anchor_1 = {'min_r': 18, 'min_c': 19, 'max_r': 20, 'max_c': 21, 'color': 1, 'height': 3, 'width': 3}

# Verify anchor match
match_1 = tl_anchor_1['color'] == br_anchor_1['color'] and \
          tl_anchor_1['height'] == br_anchor_1['height'] and \
          tl_anchor_1['width'] == br_anchor_1['width']

# Define full pattern regions
vp1_r0, vp1_r1 = tl_anchor_1['min_r'], tl_anchor_1['max_r'] + 1
vp1_c0, vp1_c1 = tl_anchor_1['max_c'] + 1, br_anchor_1['min_c']
hp1_r0, hp1_r1 = tl_anchor_1['max_r'] + 1, br_anchor_1['min_r']
hp1_c0, hp1_c1 = tl_anchor_1['min_c'], tl_anchor_1['max_c'] + 1

# Extract full patterns
vert_pattern_1 = input_1[vp1_r0:vp1_r1, vp1_c0:vp1_c1]
horz_pattern_1 = input_1[hp1_r0:hp1_r1, hp1_c0:hp1_c1]

# Get frame colors from full regions
vert_frame_color_1 = find_first_non_bg(input_1, bg_1, vp1_r0, vp1_r1, vp1_c0, vp1_c1)
horz_frame_color_1 = find_first_non_bg(input_1, bg_1, hp1_r0, hp1_r1, hp1_c0, hp1_c1)

# --- Example 2 Analysis ---
input_2 = np.array([
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,1,1,2,4,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,1,1,2,4,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
    [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
])
bg_2 = 4
objs_2 = get_object_bounds(input_2, bg_2)

tl_anchor_2 = {'min_r': 2, 'min_c': 1, 'max_r': 3, 'max_c': 2, 'color': 1, 'height': 2, 'width': 2}
br_anchor_2 = {'min_r': 13, 'min_c': 16, 'max_r': 14, 'max_c': 17, 'color': 1, 'height': 2, 'width': 2}

match_2 = tl_anchor_2['color'] == br_anchor_2['color'] and \
          tl_anchor_2['height'] == br_anchor_2['height'] and \
          tl_anchor_2['width'] == br_anchor_2['width']

vp2_r0, vp2_r1 = tl_anchor_2['min_r'], tl_anchor_2['max_r'] + 1
vp2_c0, vp2_c1 = tl_anchor_2['max_c'] + 1, br_anchor_2['min_c']
hp2_r0, hp2_r1 = tl_anchor_2['max_r'] + 1, br_anchor_2['min_r']
hp2_c0, hp2_c1 = tl_anchor_2['min_c'], tl_anchor_2['max_c'] + 1

vert_pattern_2 = input_2[vp2_r0:vp2_r1, vp2_c0:vp2_c1]
horz_pattern_2 = input_2[hp2_r0:hp2_r1, hp2_c0:hp2_c1]

vert_frame_color_2 = find_first_non_bg(input_2, bg_2, vp2_r0, vp2_r1, vp2_c0, vp2_c1)
horz_frame_color_2 = find_first_non_bg(input_2, bg_2, hp2_r0, hp2_r1, hp2_c0, hp2_c1)


print("--- Example 1 Metrics ---")
print(f"Input Shape: {input_1.shape}")
print(f"Background Color: {bg_1}")
print(f"TL Anchor: {tl_anchor_1}")
print(f"BR Anchor: {br_anchor_1}")
print(f"Anchors Match: {match_1}")
print(f"Vertical Pattern Region: Rows {vp1_r0}-{vp1_r1-1}, Cols {vp1_c0}-{vp1_c1-1}")
print(f"Vertical Pattern Shape: {vert_pattern_1.shape}")
# print("Vertical Pattern:\n", vert_pattern_1)
print(f"Horizontal Pattern Region: Rows {hp1_r0}-{hp1_r1-1}, Cols {hp1_c0}-{hp1_c1-1}")
print(f"Horizontal Pattern Shape: {horz_pattern_1.shape}")
# print("Horizontal Pattern:\n", horz_pattern_1)
print(f"Vertical Frame Color (Expected): {vert_frame_color_1} (Yellow)")
print(f"Horizontal Frame Color (Expected): {horz_frame_color_1} (Azure)")

print("\n--- Example 2 Metrics ---")
print(f"Input Shape: {input_2.shape}")
print(f"Background Color: {bg_2}")
print(f"TL Anchor: {tl_anchor_2}")
print(f"BR Anchor: {br_anchor_2}")
print(f"Anchors Match: {match_2}")
print(f"Vertical Pattern Region: Rows {vp2_r0}-{vp2_r1-1}, Cols {vp2_c0}-{vp2_c1-1}")
print(f"Vertical Pattern Shape: {vert_pattern_2.shape}")
# print("Vertical Pattern:\n", vert_pattern_2)
print(f"Horizontal Pattern Region: Rows {hp2_r0}-{hp2_r1-1}, Cols {hp2_c0}-{hp2_c1-1}")
print(f"Horizontal Pattern Shape: {horz_pattern_2.shape}")
# print("Horizontal Pattern:\n", horz_pattern_2)
print(f"Vertical Frame Color (Expected): {vert_frame_color_2} (Red)")
print(f"Horizontal Frame Color (Expected): {horz_frame_color_2} (Green)")
```

*code_execution_result:*
outcome: OUTCOME_OK
```
--- Example 1 Metrics ---
Input Shape: (24, 26)
Background Color: 0
TL Anchor: {'min_r': 2, 'min_c': 3, 'max_r': 4, 'max_c': 5, 'color': 1, 'height': 3, 'width': 3}
BR Anchor: {'min_r': 18, 'min_c': 19, 'max_r': 20, 'max_c': 21, 'color': 1, 'height': 3, 'width': 3}
Anchors Match: True
Vertical Pattern Region: Rows 2-4, Cols 6-18
Vertical Pattern Shape: (3, 13)
Horizontal Pattern Region: Rows 5-17, Cols 3-5
Horizontal Pattern Shape: (13, 3)
Vertical Frame Color (Expected): 4 (Yellow)
Horizontal Frame Color (Expected): 8 (Azure)

--- Example 2 Metrics ---
Input Shape: (18, 22)
Background Color: 4
TL Anchor: {'min_r': 2, 'min_c': 1, 'max_r': 3, 'max_c': 2, 'color': 1, 'height': 2, 'width': 2}
BR Anchor: {'min_r': 13, 'min_c': 16, 'max_r': 14, 'max_c': 17, 'color': 1, 'height': 2, 'width': 2}
Anchors Match: True
Vertical Pattern Region: Rows 2-3, Cols 3-15
Vertical Pattern Shape: (2, 13)
Horizontal Pattern Region: Rows 4-12, Cols 1-2
Horizontal Pattern Shape: (9, 2)
Vertical Frame Color (Expected): 2 (Red)
Horizontal Frame Color (Expected): 3 (Green)

```
**Facts**


```yaml
Data:
  Input: 2D grid of pixels (0-9)
  Output: 2D grid of pixels (0-9)
  Background_Color: The most frequent color in the input grid.

Objects:
  - Type: Anchor
    Designation: TL_Anchor (Top-Left)
    Identification: The non-background object whose bounding box top-left corner has the minimum row, then minimum column.
    Properties: Color (Anchor_Color), BoundingBox(min_r, min_c, max_r, max_c), Height, Width.
  - Type: Anchor
    Designation: BR_Anchor (Bottom-Right)
    Identification: The non-background object whose bounding box bottom-right corner has the maximum row, then maximum column.
    Constraint: Must have the same Anchor_Color, Height, and Width as TL_Anchor.
    Properties: Color (Anchor_Color), BoundingBox(min_r, min_c, max_r, max_c), Height, Width.
  - Type: Pattern_Source
    Designation: Vertical_Pattern
    Identification: The rectangular subgrid located entirely between the anchors, sharing rows with TL_Anchor.
    Location: Rows from TL_Anchor.min_r to TL_Anchor.max_r, Columns from TL_Anchor.max_c + 1 to BR_Anchor.min_c - 1.
    Properties: Subgrid (2D array).
  - Type: Pattern_Source
    Designation: Horizontal_Pattern
    Identification: The rectangular subgrid located entirely between the anchors, sharing columns with TL_Anchor.
    Location: Rows from TL_Anchor.max_r + 1 to BR_Anchor.min_r - 1, Columns from TL_Anchor.min_c to TL_Anchor.max_c.
    Properties: Subgrid (2D array).
  - Type: Frame
    Identification: A single-pixel-thick rectangle drawn one pixel outside the combined bounding box of TL_Anchor and BR_Anchor.
    Properties:
      - Vertical_Frame_Color: Color of the first non-background pixel found (scanning row-by-row, then column-by-column) within the full Vertical_Pattern region (Rows: TL_Anchor.min_r to TL_Anchor.max_r, Cols: TL_Anchor.max_c + 1 to BR_Anchor.min_c - 1).
      - Horizontal_Frame_Color: Color of the first non-background pixel found (scanning row-by-row, then column-by-column) within the full Horizontal_Pattern region (Rows: TL_Anchor.max_r + 1 to BR_Anchor.min_r - 1, Cols: TL_Anchor.min_c to TL_Anchor.max_c).
      - Application: Top/Bottom segments use Vertical_Frame_Color. Left/Right segments (including corners) use Horizontal_Frame_Color.

Relationships:
  - TL_Anchor and BR_Anchor define the bounds for pattern extraction, tiling, and framing.
  - Vertical_Pattern region is horizontally between the anchors and vertically aligned with TL_Anchor.
  - Horizontal_Pattern region is vertically between the anchors and horizontally aligned with TL_Anchor.

Actions:
  - Identify background color.
  - Find all non-background objects and their bounding boxes.
  - Identify TL_Anchor and BR_Anchor based on positional criteria.
  - Verify TL_Anchor and BR_Anchor match in color and dimensions. If not, return input unchanged.
  - Define the full Vertical_Pattern region based on anchor coordinates.
  - Define the full Horizontal_Pattern region based on anchor coordinates.
  - Extract Vertical_Pattern subgrid from the input using its full region definition.
  - Extract Horizontal_Pattern subgrid from the input using its full region definition.
  - Determine Vertical_Frame_Color from its full region.
  - Determine Horizontal_Frame_Color from its full region. If either color cannot be determined (region empty or all background), return input unchanged.
  - Create a copy of the input grid for the output.
  - Tile Vertical_Pattern horizontally into the output grid within the vertical pattern region, using modulo arithmetic on columns based on pattern width.
  - Tile Horizontal_Pattern vertically into the output grid within the horizontal pattern region, using modulo arithmetic on rows based on pattern height.
  - Calculate frame boundaries (one pixel outside the combined TL_Anchor/BR_Anchor extent).
  - Draw the frame onto the output grid (checking boundary conditions): Left/Right sides with Horizontal_Frame_Color, Top/Bottom sides with Vertical_Frame_Color.
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the output grid.
2.  Determine the background color by finding the most frequent pixel value in the input grid.
3.  Identify all contiguous non-background objects and calculate their bounding boxes (minimum/maximum row/column).
4.  Select the object whose bounding box top-left corner (`min_r`, `min_c`) is lexicographically smallest as the Top-Left Anchor (TL_Anchor).
5.  Select the object whose bounding box bottom-right corner (`max_r`, `max_c`) is lexicographically largest as the Bottom-Right Anchor (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor are distinct objects and that they have the same color, same height (`max_r - min_r + 1`), and same width (`max_c - min_c + 1`). If these conditions are not met, return the original input grid.
7.  Define the Vertical Pattern Region: Rows = `TL_Anchor.min_r` to `TL_Anchor.max_r`, Columns = `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`.
8.  Define the Horizontal Pattern Region: Rows = `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`, Columns = `TL_Anchor.min_c` to `TL_Anchor.max_c`.
9.  Check if both pattern regions have valid dimensions (height > 0 and width > 0). If not, return the original input grid.
10. Extract the `Vertical_Pattern` subgrid from the input grid using the Vertical Pattern Region coordinates.
11. Extract the `Horizontal_Pattern` subgrid from the input grid using the Horizontal Pattern Region coordinates. Check if the extracted patterns have non-zero dimensions. If either is empty, return the original input grid.
12. Determine the `Vertical_Frame_Color`: Scan the Vertical Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
13. Determine the `Horizontal_Frame_Color`: Scan the Horizontal Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
14. If either `Vertical_Frame_Color` or `Horizontal_Frame_Color` could not be determined (e.g., the corresponding region contained only background pixels), return the original input grid.
15. Tile the `Vertical_Pattern` into the output grid: For each column `c` within the Vertical Pattern Region (from `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`), copy the column from `Vertical_Pattern` at index `(c - (TL_Anchor.max_c + 1)) % Vertical_Pattern.width` into the output grid at column `c` and rows `TL_Anchor.min_r` to `TL_Anchor.max_r`.
16. Tile the `Horizontal_Pattern` into the output grid: For each row `r` within the Horizontal Pattern Region (from `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`), copy the row from `Horizontal_Pattern` at index `(r - (TL_Anchor.max_r + 1)) % Horizontal_Pattern.height` into the output grid at row `r` and columns `TL_Anchor.min_c` to `TL_Anchor.max_c`.
17. Define frame coordinates: `frame_top = TL_Anchor.min_r - 1`, `frame_bottom = BR_Anchor.max_r + 1`, `frame_left = TL_Anchor.min_c - 1`, `frame_right = BR_Anchor.max_c + 1`.
18. Draw the frame onto the output grid, respecting grid boundaries:
    *   Fill column `frame_left` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill column `frame_right` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill row `frame_top` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
    *   Fill row `frame_bottom` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
19. Return the modified output grid.
