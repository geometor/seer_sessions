{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom typing import List, Tuple, Dict, Optional, Set\n\n\"\"\"\nTransformation Rule:\n\n1.  Create a copy of the input grid to serve as the output grid.\n2.  Determine the background color by finding the most frequent pixel value in the input grid.\n3.  Identify all contiguous non-background objects and calculate their bounding boxes (`min_row`, `min_col`, `max_row`, `max_col`).\n4.  Select the object whose bounding box top-left corner (`min_row`, `min_col`) is lexicographically smallest as the Top-Left Anchor (TL_Anchor).\n5.  Select the object whose bounding box bottom-right corner (`max_row`, `max_col`) is lexicographically largest as the Bottom-Right Anchor (BR_Anchor).\n6.  Verify that TL_Anchor and BR_Anchor are distinct objects and that they have the same color, same height (`max_row - min_row + 1`), and same width (`max_col - min_col + 1`). If these conditions are not met, return the original input grid.\n7.  Define the Vertical Pattern Region coordinates: Start Row = `TL_Anchor.min_row`, End Row (exclusive) = `TL_Anchor.max_row + 1`, Start Column = `TL_Anchor.max_col + 1`, End Column (exclusive) = `BR_Anchor.min_col`.\n8.  Define the Horizontal Pattern Region coordinates: Start Row = `TL_Anchor.max_row + 1`, End Row (exclusive) = `BR_Anchor.min_row`, Start Column = `TL_Anchor.min_col`, End Column (exclusive) = `TL_Anchor.max_col + 1`.\n9.  Check if both pattern regions have valid dimensions (End Row > Start Row and End Column > Start Column). If not, return the original input grid.\n10. Extract the `Vertical_Pattern` subgrid from the input grid using the calculated Vertical Pattern Region coordinates.\n11. Extract the `Horizontal_Pattern` subgrid from the input grid using the calculated Horizontal Pattern Region coordinates.\n12. Check if the extracted `Vertical_Pattern` and `Horizontal_Pattern` have non-zero dimensions (height > 0 and width > 0). If either is empty, return the original input grid.\n13. Determine the `Vertical_Frame_Color`: Scan the Vertical Pattern Region (defined in step 7) in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.\n14. Determine the `Horizontal_Frame_Color`: Scan the Horizontal Pattern Region (defined in step 8) in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.\n15. If either `Vertical_Frame_Color` or `Horizontal_Frame_Color` could not be determined (because the respective region contained only background pixels), return the original input grid.\n16. Tile the `Vertical_Pattern` into the output grid: For each column `c` from `vp_c_start` to `vp_c_end - 1`, calculate the source column index in the pattern as `(c - vp_c_start) % Vertical_Pattern.width`. Copy the pixels from this source column of `Vertical_Pattern` into the output grid at column `c` and rows `vp_r_start` to `vp_r_end - 1`.\n17. Tile the `Horizontal_Pattern` into the output grid: For each row `r` from `hp_r_start` to `hp_r_end - 1`, calculate the source row index in the pattern as `(r - hp_r_start) % Horizontal_Pattern.height`. Copy the pixels from this source row of `Horizontal_Pattern` into the output grid at row `r` and columns `hp_c_start` to `hp_c_end - 1`.\n18. Define frame coordinates: `frame_top = TL_Anchor.min_row - 1`, `frame_bottom = BR_Anchor.max_row + 1`, `frame_left = TL_Anchor.min_col - 1`, `frame_right = BR_Anchor.max_col + 1`.\n19. Draw the frame onto the output grid, respecting grid boundaries:\n    *   Fill column `frame_left` from row `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.\n    *   Fill column `frame_right` from row `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.\n    *   Fill row `frame_top` from column `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.\n    *   Fill row `frame_bottom` from column `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.\n20. Return the modified output grid.\n\"\"\"\n\n# Helper class to store object information\nclass GridObject:\n    \"\"\"Represents a contiguous object in the grid with its properties.\"\"\"\n    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):\n        self.color = color\n        self.pixels = pixels\n        if not pixels:\n            self.min_row, self.min_col = -1, -1\n            self.max_row, self.max_col = -1, -1\n            self.height, self.width = 0, 0\n        else:\n            rows = [r for r, c in pixels]\n            cols = [c for r, c in pixels]\n            self.min_row = min(rows)\n            self.min_col = min(cols)\n            self.max_row = max(rows)\n            self.max_col = max(cols)\n            self.height = self.max_row - self.min_row + 1\n            self.width = self.max_col - self.min_col + 1\n\n    def __eq__(self, other):\n        if not isinstance(other, GridObject):\n            return NotImplemented\n        # Shape comparison based on dimensions and color\n        return self.color == other.color and self.height == other.height and self.width == other.width\n\n    def __repr__(self):\n        return f\"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})\"\n\ndef find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:\n    \"\"\"Finds all contiguous objects of non-background colors using 4-connectivity.\"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    pixels.add((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if pixels:\n                    objects.append(GridObject(color, pixels))\n    return objects\n\ndef find_first_non_background(grid: np.ndarray, background_color: int, \n                             r_start: int, r_end: int, \n                             c_start: int, c_end: int) -> Optional[int]:\n    \"\"\"Finds the first non-background color in a specified region (row-major scan).\"\"\"\n    height, width = grid.shape\n    # Ensure ranges are valid and within grid bounds before iterating\n    r_start_safe = max(0, r_start)\n    r_end_safe = min(height, r_end) # r_end is exclusive for range\n    c_start_safe = max(0, c_start)\n    c_end_safe = min(width, c_end)   # c_end is exclusive for range\n\n    for r in range(r_start_safe, r_end_safe):\n        for c in range(c_start_safe, c_end_safe):\n             if grid[r, c] != background_color:\n                 return grid[r, c]\n    return None # No non-background color found\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    # 1. Create a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Determine the background color\n    counts = Counter(input_grid.flatten())\n    if not counts: # Handle empty grid case\n        return output_grid\n    background_color = counts.most_common(1)[0][0]\n\n    # 3. Identify all non-background objects\n    objects = find_objects(input_grid, background_color)\n    if not objects:\n        return output_grid # No transformation if no objects\n\n    # 4. Select the Top-Left Anchor (TL_Anchor)\n    objects.sort(key=lambda o: (o.min_row, o.min_col))\n    tl_anchor = objects[0]\n    \n    # 5. Select the Bottom-Right Anchor (BR_Anchor)\n    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)\n    br_anchor = objects[0]\n\n    # Ensure distinct anchors if multiple objects exist\n    if len(objects) > 1 and tl_anchor is br_anchor:\n         # Re-evaluate BR if TL and BR are the same initially\n         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], \n                                          key=lambda o: (o.max_row, o.max_col), \n                                          reverse=True)\n         if potential_br_candidates:\n             br_anchor = potential_br_candidates[0]\n         else: # Only one effective object was found\n             return output_grid\n             \n    # Final check if anchors are distinct\n    if tl_anchor is br_anchor:\n         return output_grid # Cannot proceed if anchors are not distinct\n\n    # 6. Verify anchors match (color, height, width)\n    if tl_anchor.color != br_anchor.color or \\\n       tl_anchor.height != br_anchor.height or \\\n       tl_anchor.width != br_anchor.width:\n        return output_grid # Anchors don't match criteria\n\n    # 7. Define the Vertical Pattern Region coordinates\n    vp_r_start = tl_anchor.min_row\n    vp_r_end = tl_anchor.max_row + 1 # Exclusive end for slicing\n    vp_c_start = tl_anchor.max_col + 1\n    vp_c_end = br_anchor.min_col     # Exclusive end for slicing\n\n    # 8. Define the Horizontal Pattern Region coordinates\n    hp_r_start = tl_anchor.max_row + 1\n    hp_r_end = br_anchor.min_row     # Exclusive end for slicing\n    hp_c_start = tl_anchor.min_col\n    hp_c_end = tl_anchor.max_col + 1 # Exclusive end for slicing\n\n    # 9. Check if pattern regions have valid dimensions\n    valid_vp_region = (vp_r_end > vp_r_start) and (vp_c_end > vp_c_start)\n    valid_hp_region = (hp_r_end > hp_r_start) and (hp_c_end > hp_c_start)\n\n    # Both regions must be valid based on the problem structure\n    if not valid_vp_region or not valid_hp_region:\n         # If anchors are adjacent or overlapping such that no pattern region exists\n         return output_grid \n\n    # 10. Extract the Vertical_Pattern subgrid\n    vertical_pattern = input_grid[vp_r_start:vp_r_end, vp_c_start:vp_c_end]\n    \n    # 11. Extract the Horizontal_Pattern subgrid\n    horizontal_pattern = input_grid[hp_r_start:hp_r_end, hp_c_start:hp_c_end]\n\n    # 12. Check if extracted patterns have non-zero dimensions\n    vp_h, vp_w = vertical_pattern.shape\n    hp_h, hp_w = horizontal_pattern.shape\n    if vp_h == 0 or vp_w == 0 or hp_h == 0 or hp_w == 0:\n        # This case should be covered by step 9, but added for robustness\n        return output_grid # Cannot tile with empty patterns\n\n    # 13. Determine the Vertical_Frame_Color\n    vertical_frame_color = find_first_non_background(input_grid, background_color, \n                                                     vp_r_start, vp_r_end, \n                                                     vp_c_start, vp_c_end)\n                                                      \n    # 14. Determine the Horizontal_Frame_Color\n    horizontal_frame_color = find_first_non_background(input_grid, background_color,\n                                                       hp_r_start, hp_r_end,\n                                                       hp_c_start, hp_c_end)\n\n    # 15. Check if frame colors were found\n    if vertical_frame_color is None or horizontal_frame_color is None:\n        # If regions are valid but no color found, rule may not apply\n        return output_grid \n\n    # 16. Tile the Vertical_Pattern horizontally\n    target_vp_rows = slice(vp_r_start, vp_r_end) # Rows to fill\n    for c in range(vp_c_start, vp_c_end):\n        if c >= width: break # Boundary check\n        pattern_col_idx = (c - vp_c_start) % vp_w\n        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]\n\n    # 17. Tile the Horizontal_Pattern vertically\n    target_hp_cols = slice(hp_c_start, hp_c_end) # Columns to fill\n    for r in range(hp_r_start, hp_r_end):\n        if r >= height: break # Boundary check\n        pattern_row_idx = (r - hp_r_start) % hp_h\n        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]\n\n    # 18. Define frame coordinates\n    frame_top = tl_anchor.min_row - 1\n    frame_bottom = br_anchor.max_row + 1\n    frame_left = tl_anchor.min_col - 1\n    frame_right = br_anchor.max_col + 1\n\n    # 19. Draw the frame onto the output grid, respecting grid boundaries\n    # Draw vertical bars (left/right) - including corners\n    if 0 <= frame_left < width:\n        row_start_safe = max(0, frame_top)\n        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end range\n        if row_end_safe > row_start_safe: # Ensure there's at least one row to draw\n             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color\n    \n    if 0 <= frame_right < width:\n        row_start_safe = max(0, frame_top)\n        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end range\n        if row_end_safe > row_start_safe:\n             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color\n\n    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges\n    col_start_safe = max(0, frame_left + 1)\n    col_end_safe = min(width, frame_right) # Exclusive end index for slicing\n    \n    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0\n        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color\n        \n    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:\n        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color\n\n    # 20. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24644,
    "candidates_token_count": 4035,
    "total_token_count": 28679,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.896243,
  "retries": 1
}