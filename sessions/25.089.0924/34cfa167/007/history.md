
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 8 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 1 1 1 4 0 2 0 4 0 2 0 4 0 2 0 4 1 1 1 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 2 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 3 4 4 4
3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 4 4 4
3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 1 1 2 4 8 4 2 4 8 4 2 4 8 4 2 1 1 4 4 4 4
4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

**Perception**

1.  **Input Structure:** The input grids contain a background color (white in the first example, yellow in the second) and several small, distinct objects of different colors.
2.  **Key Objects:** Two objects stand out as "anchors": one near the top-left and another near the bottom-right. In both examples, these anchor objects are identical in shape and color (3x3 blue squares in `train_1`, 2x2 blue squares in `train_2`).
3.  **Pattern Elements:** There are other objects located immediately to the right of the top-left anchor (forming a "vertical pattern") and immediately below the top-left anchor (forming a "horizontal pattern").
4.  **Transformation:** The core transformation involves using the anchor objects and the associated patterns to generate a larger structure within the grid.
5.  **Tiling/Repetition:** The vertical pattern (right of the top-left anchor) is tiled horizontally to fill the space between the top-left anchor and the vertical position of the bottom-right anchor. Similarly, the horizontal pattern (below the top-left anchor) is tiled vertically to fill the space between the top-left anchor and the horizontal position of the bottom-right anchor.
6.  **Framing:** A rectangular frame is drawn around the newly generated structure (composed of the anchors and the tiled patterns).
7.  **Frame Colors:** The color of the top and bottom segments of the frame is determined by the first non-background color encountered in the vertical pattern (moving right from the top-left anchor). The color of the left and right segments of the frame is determined by the first non-background color encountered in the horizontal pattern (moving down from the top-left anchor). The corners of the frame take the color of the left/right frame segments.
8.  **Output Structure:** The output grid retains the original dimensions and background, but the area defined by the anchors is modified by the tiling process, and a new frame is added around this modified area.

**Facts**


```yaml
Data:
  Input: 2D grid of pixels (0-9)
  Output: 2D grid of pixels (0-9)
  Background_Color: The most frequent color in the input grid.

Objects:
  - Type: Anchor
    Designation: TL_Anchor (Top-Left)
    Identification: The non-background object located furthest top-left.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Anchor
    Designation: BR_Anchor (Bottom-Right)
    Identification: The non-background object located furthest bottom-right.
    Constraint: Must have the same Anchor_Color and Shape as TL_Anchor.
    Properties: Color (Anchor_Color), Shape, Size, Position (top_row, left_col, bottom_row, right_col).
  - Type: Pattern_Source
    Designation: Vertical_Pattern_Region
    Identification: Rectangular region in the input grid immediately right of TL_Anchor.
    Properties: Shares rows with TL_Anchor, extends from `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Contains the Vertical_Pattern.
  - Type: Pattern_Source
    Designation: Horizontal_Pattern_Region
    Identification: Rectangular region in the input grid immediately below TL_Anchor.
    Properties: Shares columns with TL_Anchor, extends from `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`. Contains the Horizontal_Pattern.
  - Type: Frame
    Identification: A single-pixel-thick rectangle surrounding the generated structure.
    Properties:
      - Vertical_Frame_Color: Color of the top-leftmost non-background pixel in Vertical_Pattern_Region.
      - Horizontal_Frame_Color: Color of the top-leftmost non-background pixel in Horizontal_Pattern_Region.
      - Top/Bottom segments use Vertical_Frame_Color.
      - Left/Right segments (including corners) use Horizontal_Frame_Color.

Relationships:
  - TL_Anchor and BR_Anchor define the bounds of the primary transformation area.
  - Vertical_Pattern_Region is adjacent (right) to TL_Anchor.
  - Horizontal_Pattern_Region is adjacent (below) to TL_Anchor.

Actions:
  - Identify background color.
  - Find all non-background objects.
  - Identify TL_Anchor and BR_Anchor, verifying color/shape match.
  - Extract Vertical_Pattern from Vertical_Pattern_Region.
  - Extract Horizontal_Pattern from Horizontal_Pattern_Region.
  - Determine Vertical_Frame_Color and Horizontal_Frame_Color.
  - Copy input grid to create initial output grid.
  - Tile Vertical_Pattern horizontally into the output grid between anchors.
  - Tile Horizontal_Pattern vertically into the output grid between anchors.
  - Calculate frame boundaries based on the combined extent of anchors and tiled patterns.
  - Draw the frame onto the output grid using derived colors.
```


**Natural Language Program**

1.  Create a copy of the input grid; this will be the basis for the output grid.
2.  Identify the background color by finding the most frequent pixel value in the input grid.
3.  Find all contiguous objects composed of non-background colors. Record their properties (color, shape, bounding box).
4.  Identify the object whose top-left corner has the minimum row, then minimum column (TL_Anchor).
5.  Identify the object whose bottom-right corner has the maximum row, then maximum column (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor have the same color and shape. If not, the pattern doesn't apply.
7.  Define the Vertical Pattern Region in the input grid: rows = `TL_Anchor.top_row` to `TL_Anchor.bottom_row`, columns = `TL_Anchor.right_col + 1` to `BR_Anchor.left_col - 1`. Extract the subgrid corresponding to this region as the `Vertical_Pattern`.
8.  Define the Horizontal Pattern Region in the input grid: rows = `TL_Anchor.bottom_row + 1` to `BR_Anchor.top_row - 1`, columns = `TL_Anchor.left_col` to `TL_Anchor.right_col`. Extract the subgrid corresponding to this region as the `Horizontal_Pattern`.
9.  Determine the Vertical Frame Color: Find the color of the first non-background pixel encountered when scanning the `Vertical_Pattern` region row by row, then column by column.
10. Determine the Horizontal Frame Color: Find the color of the first non-background pixel encountered when scanning the `Horizontal_Pattern` region row by row, then column by column.
11. Tile the `Vertical_Pattern` horizontally into the output grid: Iterate through the rows from `TL_Anchor.top_row` to `TL_Anchor.bottom_row`. Within each row, repeatedly copy the corresponding row slice of the `Vertical_Pattern` into the output grid columns starting from `TL_Anchor.right_col + 1`, continuing until reaching `BR_Anchor.left_col`.
12. Tile the `Horizontal_Pattern` vertically into the output grid: Iterate through the columns from `TL_Anchor.left_col` to `TL_Anchor.right_col`. Within each column, repeatedly copy the corresponding column slice of the `Horizontal_Pattern` into the output grid rows starting from `TL_Anchor.bottom_row + 1`, continuing until reaching `BR_Anchor.top_row`.
13. Define the frame boundaries:
    *   `frame_top_row = TL_Anchor.top_row - 1`
    *   `frame_bottom_row = BR_Anchor.bottom_row + 1`
    *   `frame_left_c = TL_Anchor.left_col - 1`
    *   `frame_right_c = BR_Anchor.right_col + 1`
14. Draw the frame onto the output grid:
    *   Draw the left frame segment: Fill column `frame_left_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the right frame segment: Fill column `frame_right_c` from row `frame_top_row` to `frame_bottom_row` with `Horizontal_Frame_Color`.
    *   Draw the top frame segment: Fill row `frame_top_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
    *   Draw the bottom frame segment: Fill row `frame_bottom_row` from column `frame_left_c + 1` to `frame_right_c - 1` with `Vertical_Frame_Color`.
15. The modified grid is the final output.
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1. Identify the background color (most frequent color).
2. Find all distinct, contiguous non-background objects.
3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).
4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions).
5. Extract the rectangular region immediately to the right of TL_Anchor, up to the column before BR_Anchor, as the Vertical_Pattern.
6. Extract the rectangular region immediately below TL_Anchor, up to the row before BR_Anchor, as the Horizontal_Pattern.
7. Determine the Vertical_Frame_Color by finding the first non-background color in the Vertical_Pattern region (scanning row by row, then column by column).
8. Determine the Horizontal_Frame_Color by finding the first non-background color in the Horizontal_Pattern region (scanning row by row, then column by column).
9. Create an output grid initialized as a copy of the input grid.
10. Tile the Vertical_Pattern horizontally in the output grid, filling the area between the anchors' vertical extent and between the right edge of TL_Anchor and the left edge of BR_Anchor.
11. Tile the Horizontal_Pattern vertically in the output grid, filling the area between the anchors' horizontal extent and between the bottom edge of TL_Anchor and the top edge of BR_Anchor.
12. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.
13. Draw the frame:
    - Left and Right vertical segments use Horizontal_Frame_Color.
    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.
"""

# Helper class to store object information
class GridObject:
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        rows = [r for r, c in pixels]
        cols = [c for r, c in pixels]
        self.min_row = min(rows)
        self.min_col = min(cols)
        self.max_row = max(rows)
        self.max_col = max(cols)
        self.height = self.max_row - self.min_row + 1
        self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Simple shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"


def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region."""
    for r in range(r_start, r_end):
        for c in range(c_start, c_end):
            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                if grid[r, c] != background_color:
                    return grid[r, c]
    return None # Should not happen based on examples, but good practice


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the tiling and framing transformation based on anchor objects.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 1. Identify background color
    counts = Counter(input_grid.flatten())
    background_color = counts.most_common(1)[0][0]

    # 2. Find all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No objects, no transformation

    # 3. Identify TL_Anchor and BR_Anchor
    # Sort by top-row, then left-column for TL
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # Sort by bottom-row (desc), then right-column (desc) for BR
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure we didn't pick the same object if there's only one
    if len(objects) == 1:
         return output_grid # Cannot form pattern with one object

    # Handle cases where TL and BR might be the same due to sorting criteria
    # Re-find BR by explicitly looking for max row/col if TL and BR are identical initially
    if tl_anchor is br_anchor:
         potential_br = [o for o in objects if o is not tl_anchor]
         if not potential_br:
              return output_grid # Still only one effective anchor
         potential_br.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
         br_anchor = potential_br[0]

    # Check if TL and BR are distinct and valid candidates
    if tl_anchor is br_anchor or not tl_anchor or not br_anchor:
        # Fallback or error: Cannot determine distinct anchors
        # Based on examples, this shouldn't happen if the pattern is applicable
        return output_grid

    # 4. Verify anchors match in color and shape (dimensions)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        # Anchors don't match criteria
        return output_grid

    # --- Define pattern regions ---
    vp_r_start = tl_anchor.min_row
    vp_r_end = tl_anchor.max_row + 1
    vp_c_start = tl_anchor.max_col + 1
    vp_c_end = br_anchor.min_col

    hp_r_start = tl_anchor.max_row + 1
    hp_r_end = br_anchor.min_row
    hp_c_start = tl_anchor.min_col
    hp_c_end = tl_anchor.max_col + 1

    # Check if regions have valid dimensions (end > start)
    valid_vp = vp_r_end > vp_r_start and vp_c_end > vp_c_start
    valid_hp = hp_r_end > hp_r_start and hp_c_end > hp_c_start

    if not valid_vp or not valid_hp:
         # If either pattern region is invalid/empty, cannot proceed
         return output_grid

    # 5. Extract Vertical_Pattern
    vertical_pattern = input_grid[vp_r_start:vp_r_end, vp_c_start:vp_c_end]
    vp_h, vp_w = vertical_pattern.shape

    # 6. Extract Horizontal_Pattern
    horizontal_pattern = input_grid[hp_r_start:hp_r_end, hp_c_start:hp_c_end]
    hp_h, hp_w = horizontal_pattern.shape

    # Check if patterns are empty (although region check should cover this)
    if vp_h == 0 or vp_w == 0 or hp_h == 0 or hp_w == 0:
         return output_grid

    # 7. Determine Vertical_Frame_Color
    vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                     vp_r_start, vp_r_end, 
                                                     vp_c_start, vp_c_end)
                                                      
    # 8. Determine Horizontal_Frame_Color
    horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                       hp_r_start, hp_r_end,
                                                       hp_c_start, hp_c_end)

    # Check if frame colors were found
    if vertical_frame_color is None or horizontal_frame_color is None:
        # Should not happen in valid examples
        return output_grid
        
    # --- Apply Transformations to output_grid ---

    # 10. Tile Vertical_Pattern horizontally
    target_c_start = tl_anchor.max_col + 1
    target_c_end = br_anchor.min_col
    for c in range(target_c_start, target_c_end):
        pattern_col_idx = (c - target_c_start) % vp_w
        output_grid[vp_r_start:vp_r_end, c] = vertical_pattern[:, pattern_col_idx]

    # 11. Tile Horizontal_Pattern vertically
    target_r_start = tl_anchor.max_row + 1
    target_r_end = br_anchor.min_row
    for r in range(target_r_start, target_r_end):
        pattern_row_idx = (r - target_r_start) % hp_h
        output_grid[r, hp_c_start:hp_c_end] = horizontal_pattern[pattern_row_idx, :]

    # --- Draw Frame ---
    # 12. Define frame boundaries
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_col - 1
    frame_right = br_anchor.max_col + 1

    # 13. Draw the frame safely within grid bounds
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start = max(0, frame_top)
        row_end = min(height, frame_bottom + 1)
        output_grid[row_start:row_end, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start = max(0, frame_top)
        row_end = min(height, frame_bottom + 1)
        output_grid[row_start:row_end, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars
    col_start = max(0, frame_left + 1)
    col_end = min(width, frame_right)
    if 0 <= frame_top < height and col_end > col_start:
        output_grid[frame_top, col_start:col_end] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end > col_start:
        output_grid[frame_bottom, col_start:col_end] = vertical_frame_color

    return output_grid
```
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1. Identify the background color (most frequent color).
2. Find all distinct, contiguous non-background objects.
3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).
4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions). If not, return the input grid unchanged.
5. Extract the repeating Vertical Pattern: Find the rectangular region immediately to the right of TL_Anchor that shares its rows. Scan columns rightwards from TL_Anchor's right edge until a column consisting entirely of the background color is found. The pattern is the block of columns before this background column. If no background column is found before BR_Anchor's left edge, use all columns up to BR_Anchor's left edge.
6. Extract the repeating Horizontal Pattern: Find the rectangular region immediately below TL_Anchor that shares its columns. Scan rows downwards from TL_Anchor's bottom edge until a row consisting entirely of the background color is found. The pattern is the block of rows before this background row. If no background row is found before BR_Anchor's top edge, use all rows up to BR_Anchor's top edge.
7. Determine the Vertical_Frame_Color: Scan the region defined by TL_Anchor's rows and the columns between TL_Anchor's right edge and BR_Anchor's left edge. Find the first non-background color encountered (scanning row by row, then column by column).
8. Determine the Horizontal_Frame_Color: Scan the region defined by TL_Anchor's columns and the rows between TL_Anchor's bottom edge and BR_Anchor's top edge. Find the first non-background color encountered (scanning row by row, then column by column).
9. If either frame color cannot be determined (e.g., regions are empty or all background), return the input grid unchanged.
10. Create an output grid initialized as a copy of the input grid.
11. Tile the extracted Vertical_Pattern horizontally in the output grid, filling the area defined by TL_Anchor's rows and the columns between the right edge of TL_Anchor and the left edge of BR_Anchor. Use modulo arithmetic based on the pattern's width for repetition.
12. Tile the extracted Horizontal_Pattern vertically in the output grid, filling the area defined by TL_Anchor's columns and the rows between the bottom edge of TL_Anchor and the top edge of BR_Anchor. Use modulo arithmetic based on the pattern's height for repetition.
13. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.
14. Draw the frame onto the output grid, ensuring it stays within grid bounds:
    - Left and Right vertical segments (including corners) use Horizontal_Frame_Color.
    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.
15. Return the modified output grid.
"""

# Helper class to store object information
class GridObject:
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        if not pixels:
             # Should not happen with valid objects, but prevent errors
            self.min_row, self.min_col = -1, -1
            self.max_row, self.max_col = -1, -1
            self.height, self.width = 0, 0
        else:
            rows = [r for r, c in pixels]
            cols = [c for r, c in pixels]
            self.min_row = min(rows)
            self.min_col = min(cols)
            self.max_row = max(rows)
            self.max_col = max(cols)
            self.height = self.max_row - self.min_row + 1
            self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"

def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors using 4-connectivity."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                obj_pixels_list = [] # Keep order for easier debugging if needed
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))
                    obj_pixels_list.append((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region (row-major scan)."""
    height, width = grid.shape
    # Ensure ranges are valid and within grid bounds before iterating
    r_start_safe = max(0, r_start)
    r_end_safe = min(height, r_end)
    c_start_safe = max(0, c_start)
    c_end_safe = min(width, c_end)

    for r in range(r_start_safe, r_end_safe):
        for c in range(c_start_safe, c_end_safe):
             if grid[r, c] != background_color:
                 return grid[r, c]
    return None # No non-background color found


def transform(input_grid: np.ndarray) -> np.ndarray:
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 1. Identify background color
    counts = Counter(input_grid.flatten())
    if not counts: # Handle empty grid case
        return output_grid
    background_color = counts.most_common(1)[0][0]

    # 2. Find all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No objects, no transformation

    # 3. Identify TL_Anchor and BR_Anchor
    # Sort by top-row, then left-column for TL
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # Sort by bottom-row (desc), then right-column (desc) for BR
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure distinct anchors if multiple objects exist
    if len(objects) > 1 and tl_anchor is br_anchor:
         # If TL and BR based on initial sorts are the same, re-evaluate BR
         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], 
                                          key=lambda o: (o.max_row, o.max_col), 
                                          reverse=True)
         if potential_br_candidates:
             br_anchor = potential_br_candidates[0]
         else: # Only one object was found effectively
             return output_grid
             
    # Final check if anchors are distinct
    if tl_anchor is br_anchor:
         return output_grid # Cannot proceed if anchors are not distinct

    # 4. Verify anchors match in color and shape (dimensions)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        return output_grid # Anchors don't match criteria

    # --- Define Potential Regions for Frame Color Determination ---
    frame_vp_r_start = tl_anchor.min_row
    frame_vp_r_end = tl_anchor.max_row + 1
    frame_vp_c_start = tl_anchor.max_col + 1
    frame_vp_c_end = br_anchor.min_col

    frame_hp_r_start = tl_anchor.max_row + 1
    frame_hp_r_end = br_anchor.min_row
    frame_hp_c_start = tl_anchor.min_col
    frame_hp_c_end = tl_anchor.max_col + 1

    # Check if these frame determination regions have positive dimensions
    valid_frame_vp_region = frame_vp_r_end > frame_vp_r_start and frame_vp_c_end > frame_vp_c_start
    valid_frame_hp_region = frame_hp_r_end > frame_hp_r_start and frame_hp_c_end > frame_hp_c_start

    # 7. Determine Vertical_Frame_Color (from potential region)
    vertical_frame_color = None
    if valid_frame_vp_region:
        vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                         frame_vp_r_start, frame_vp_r_end, 
                                                         frame_vp_c_start, frame_vp_c_end)
                                                      
    # 8. Determine Horizontal_Frame_Color (from potential region)
    horizontal_frame_color = None
    if valid_frame_hp_region:
        horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                           frame_hp_r_start, frame_hp_r_end,
                                                           frame_hp_c_start, frame_hp_c_end)

    # 9. Check if frame colors were found (if regions were valid)
    if (valid_frame_vp_region and vertical_frame_color is None) or \
       (valid_frame_hp_region and horizontal_frame_color is None):
         # If a region exists but has no non-background color, rule might not apply
         # Or if frame colors are essential and missing, return original
         # For this task, frame colors seem essential.
         return output_grid
         
    # If a region didn't exist, we might still proceed if the other exists.
    # However, the examples imply both patterns and frame colors derived from them exist.
    # Let's enforce that both frame colors must be found if their regions are valid.
    if vertical_frame_color is None or horizontal_frame_color is None:
        return output_grid # Essential colors missing


    # --- Extract Actual Repeating Patterns ---
    
    # 5. Extract Vertical Pattern
    vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1)
    vp_start_col = tl_anchor.max_col + 1
    vp_end_col = vp_start_col 
    for c in range(vp_start_col, br_anchor.min_col):
        # Ensure column index is valid before checking
        if c >= width: break 
        # Check if the column slice within anchor rows is all background
        if np.all(input_grid[vp_rows, c] == background_color):
            vp_end_col = c # End column is the first background-only column
            break
    else: # No background column found before BR anchor
        vp_end_col = br_anchor.min_col

    # Check if vp_end_col makes sense (it must be > vp_start_col for a pattern)
    if vp_end_col <= vp_start_col:
         # Vertical pattern is empty or invalid
         return output_grid 
    vertical_pattern = input_grid[vp_rows, vp_start_col:vp_end_col]
    vp_h, vp_w = vertical_pattern.shape
    if vp_h == 0 or vp_w == 0: return output_grid # Pattern is empty

    # 6. Extract Horizontal Pattern
    hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1)
    hp_start_row = tl_anchor.max_row + 1
    hp_end_row = hp_start_row
    for r in range(hp_start_row, br_anchor.min_row):
        if r >= height: break
        if np.all(input_grid[r, hp_cols] == background_color):
            hp_end_row = r
            break
    else: # No background row found
        hp_end_row = br_anchor.min_row
        
    if hp_end_row <= hp_start_row:
        # Horizontal pattern is empty or invalid
        return output_grid
    horizontal_pattern = input_grid[hp_start_row:hp_end_row, hp_cols]
    hp_h, hp_w = horizontal_pattern.shape
    if hp_h == 0 or hp_w == 0: return output_grid # Pattern is empty


    # --- Apply Transformations to output_grid ---

    # 11. Tile Vertical_Pattern horizontally
    target_vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1) # Rows to fill
    target_vp_c_start = tl_anchor.max_col + 1
    target_vp_c_end = br_anchor.min_col 
    for c in range(target_vp_c_start, target_vp_c_end):
        # Check column bounds
        if c >= width: break 
        pattern_col_idx = (c - target_vp_c_start) % vp_w
        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]

    # 12. Tile Horizontal_Pattern vertically
    target_hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1) # Columns to fill
    target_hp_r_start = tl_anchor.max_row + 1
    target_hp_r_end = br_anchor.min_row
    for r in range(target_hp_r_start, target_hp_r_end):
        if r >= height: break
        pattern_row_idx = (r - target_hp_r_start) % hp_h
        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]

    # --- Draw Frame ---
    # 13. Define frame boundaries
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_col - 1
    frame_right = br_anchor.max_col + 1

    # 14. Draw the frame safely within grid bounds
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe: # Check if there's any row to draw
             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1)
        if row_end_safe > row_start_safe:
             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges
    col_start_safe = max(0, frame_left + 1)
    col_end_safe = min(width, frame_right) # End index is exclusive for slicing
    
    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0
        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:
        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color

    # 15. Return final grid
    return output_grid
```
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1.  Create a copy of the input grid to serve as the output grid.
2.  Determine the background color by finding the most frequent pixel value in the input grid.
3.  Identify all contiguous non-background objects and calculate their bounding boxes (minimum/maximum row/column).
4.  Select the object whose bounding box top-left corner (`min_r`, `min_c`) is lexicographically smallest as the Top-Left Anchor (TL_Anchor).
5.  Select the object whose bounding box bottom-right corner (`max_r`, `max_c`) is lexicographically largest as the Bottom-Right Anchor (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor are distinct objects and that they have the same color, same height (`max_r - min_r + 1`), and same width (`max_c - min_c + 1`). If these conditions are not met, return the original input grid.
7.  Define the Vertical Pattern Region: Rows = `TL_Anchor.min_r` to `TL_Anchor.max_r`, Columns = `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`.
8.  Define the Horizontal Pattern Region: Rows = `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`, Columns = `TL_Anchor.min_c` to `TL_Anchor.max_c`.
9.  Check if both pattern regions have valid dimensions (height > 0 and width > 0). If not, return the original input grid.
10. Extract the `Vertical_Pattern` subgrid from the input grid using the Vertical Pattern Region coordinates.
11. Extract the `Horizontal_Pattern` subgrid from the input grid using the Horizontal Pattern Region coordinates. Check if the extracted patterns have non-zero dimensions. If either is empty, return the original input grid.
12. Determine the `Vertical_Frame_Color`: Scan the Vertical Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
13. Determine the `Horizontal_Frame_Color`: Scan the Horizontal Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
14. If either `Vertical_Frame_Color` or `Horizontal_Frame_Color` could not be determined (e.g., the corresponding region contained only background pixels), return the original input grid.
15. Tile the `Vertical_Pattern` into the output grid: For each column `c` within the Vertical Pattern Region (from `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`), copy the column from `Vertical_Pattern` at index `(c - (TL_Anchor.max_c + 1)) % Vertical_Pattern.width` into the output grid at column `c` and rows `TL_Anchor.min_r` to `TL_Anchor.max_r`.
16. Tile the `Horizontal_Pattern` into the output grid: For each row `r` within the Horizontal Pattern Region (from `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`), copy the row from `Horizontal_Pattern` at index `(r - (TL_Anchor.max_r + 1)) % Horizontal_Pattern.height` into the output grid at row `r` and columns `TL_Anchor.min_c` to `TL_Anchor.max_c`.
17. Define frame coordinates: `frame_top = TL_Anchor.min_r - 1`, `frame_bottom = BR_Anchor.max_r + 1`, `frame_left = TL_Anchor.min_c - 1`, `frame_right = BR_Anchor.max_c + 1`.
18. Draw the frame onto the output grid, respecting grid boundaries:
    *   Fill column `frame_left` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill column `frame_right` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill row `frame_top` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
    *   Fill row `frame_bottom` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
19. Return the modified output grid.
"""

# Helper class to store object information
class GridObject:
    """Represents a contiguous object in the grid with its properties."""
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        if not pixels:
            self.min_row, self.min_col = -1, -1
            self.max_row, self.max_col = -1, -1
            self.height, self.width = 0, 0
        else:
            rows = [r for r, c in pixels]
            cols = [c for r, c in pixels]
            self.min_row = min(rows)
            self.min_col = min(cols)
            self.max_row = max(rows)
            self.max_col = max(cols)
            self.height = self.max_row - self.min_row + 1
            self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"

def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors using 4-connectivity."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region (row-major scan)."""
    height, width = grid.shape
    # Ensure ranges are valid and within grid bounds before iterating
    r_start_safe = max(0, r_start)
    r_end_safe = min(height, r_end) # r_end is exclusive for range
    c_start_safe = max(0, c_start)
    c_end_safe = min(width, c_end)   # c_end is exclusive for range

    for r in range(r_start_safe, r_end_safe):
        for c in range(c_start_safe, c_end_safe):
             if grid[r, c] != background_color:
                 return grid[r, c]
    return None # No non-background color found


def transform(input_grid: np.ndarray) -> np.ndarray:
    # 1. Create a copy of the input grid
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 2. Determine the background color
    counts = Counter(input_grid.flatten())
    if not counts: # Handle empty grid case
        return output_grid
    background_color = counts.most_common(1)[0][0]

    # 3. Identify all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No transformation if no objects

    # 4. Select the Top-Left Anchor (TL_Anchor)
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # 5. Select the Bottom-Right Anchor (BR_Anchor)
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure distinct anchors if multiple objects exist
    if len(objects) > 1 and tl_anchor is br_anchor:
         # Re-evaluate BR if TL and BR are the same initially
         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], 
                                          key=lambda o: (o.max_row, o.max_col), 
                                          reverse=True)
         if potential_br_candidates:
             br_anchor = potential_br_candidates[0]
         else: # Only one effective object was found
             return output_grid
             
    # Final check if anchors are distinct
    if tl_anchor is br_anchor:
         return output_grid # Cannot proceed if anchors are not distinct

    # 6. Verify anchors match (color, height, width)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        return output_grid # Anchors don't match criteria

    # 7. Define the Vertical Pattern Region coordinates
    vp_r_start = tl_anchor.min_row
    vp_r_end = tl_anchor.max_row + 1 # Exclusive end for slicing
    vp_c_start = tl_anchor.max_c + 1
    vp_c_end = br_anchor.min_col     # Exclusive end for slicing

    # 8. Define the Horizontal Pattern Region coordinates
    hp_r_start = tl_anchor.max_row + 1
    hp_r_end = br_anchor.min_row     # Exclusive end for slicing
    hp_c_start = tl_anchor.min_c
    hp_c_end = tl_anchor.max_c + 1 # Exclusive end for slicing

    # 9. Check if pattern regions have valid dimensions
    valid_vp_region = (vp_r_end > vp_r_start) and (vp_c_end > vp_c_start)
    valid_hp_region = (hp_r_end > hp_r_start) and (hp_c_end > hp_c_start)

    # Both regions must be valid based on the problem structure
    if not valid_vp_region or not valid_hp_region:
         return output_grid 

    # 10. Extract the Vertical_Pattern subgrid
    vertical_pattern = input_grid[vp_r_start:vp_r_end, vp_c_start:vp_c_end]
    
    # 11. Extract the Horizontal_Pattern subgrid
    horizontal_pattern = input_grid[hp_r_start:hp_r_end, hp_c_start:hp_c_end]

    # Check if extracted patterns have non-zero dimensions
    vp_h, vp_w = vertical_pattern.shape
    hp_h, hp_w = horizontal_pattern.shape
    if vp_h == 0 or vp_w == 0 or hp_h == 0 or hp_w == 0:
        return output_grid # Cannot tile with empty patterns

    # 12. Determine the Vertical_Frame_Color
    vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                     vp_r_start, vp_r_end, 
                                                     vp_c_start, vp_c_end)
                                                      
    # 13. Determine the Horizontal_Frame_Color
    horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                       hp_r_start, hp_r_end,
                                                       hp_c_start, hp_c_end)

    # 14. Check if frame colors were found
    if vertical_frame_color is None or horizontal_frame_color is None:
        # If regions are valid but no color found, something is wrong
        # or the rule doesn't apply.
        return output_grid 

    # 15. Tile the Vertical_Pattern horizontally
    target_vp_rows = slice(vp_r_start, vp_r_end) # Rows to fill
    for c in range(vp_c_start, vp_c_end):
        if c >= width: break # Boundary check
        pattern_col_idx = (c - vp_c_start) % vp_w
        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]

    # 16. Tile the Horizontal_Pattern vertically
    target_hp_cols = slice(hp_c_start, hp_c_end) # Columns to fill
    for r in range(hp_r_start, hp_r_end):
        if r >= height: break # Boundary check
        pattern_row_idx = (r - hp_r_start) % hp_h
        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]

    # 17. Define frame coordinates
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_c - 1
    frame_right = br_anchor.max_c + 1

    # 18. Draw the frame onto the output grid, respecting grid boundaries
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end
        if row_end_safe > row_start_safe: 
             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end
        if row_end_safe > row_start_safe:
             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges
    col_start_safe = max(0, frame_left + 1)
    col_end_safe = min(width, frame_right) # Exclusive end index for slicing
    
    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0
        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:
        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color

    # 19. Return the modified output grid
    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import Counter
from typing import List, Tuple, Dict, Optional, Set

"""
Transformation Rule:

1.  Create a copy of the input grid to serve as the output grid.
2.  Determine the background color by finding the most frequent pixel value in the input grid.
3.  Identify all contiguous non-background objects and calculate their bounding boxes (minimum/maximum row/column).
4.  Select the object whose bounding box top-left corner (`min_r`, `min_c`) is lexicographically smallest as the Top-Left Anchor (TL_Anchor).
5.  Select the object whose bounding box bottom-right corner (`max_r`, `max_c`) is lexicographically largest as the Bottom-Right Anchor (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor are distinct objects and that they have the same color, same height (`max_r - min_r + 1`), and same width (`max_c - min_c + 1`). If these conditions are not met, return the original input grid.
7.  Define the Vertical Pattern Region: Rows = `TL_Anchor.min_r` to `TL_Anchor.max_r`, Columns = `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`.
8.  Define the Horizontal Pattern Region: Rows = `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`, Columns = `TL_Anchor.min_c` to `TL_Anchor.max_c`.
9.  Check if both pattern regions have valid dimensions (height > 0 and width > 0). If not, return the original input grid.
10. Extract the `Vertical_Pattern` subgrid from the input grid using the Vertical Pattern Region coordinates.
11. Extract the `Horizontal_Pattern` subgrid from the input grid using the Horizontal Pattern Region coordinates. Check if the extracted patterns have non-zero dimensions. If either is empty, return the original input grid.
12. Determine the `Vertical_Frame_Color`: Scan the Vertical Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
13. Determine the `Horizontal_Frame_Color`: Scan the Horizontal Pattern Region in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
14. If either `Vertical_Frame_Color` or `Horizontal_Frame_Color` could not be determined (e.g., the corresponding region contained only background pixels), return the original input grid.
15. Tile the `Vertical_Pattern` into the output grid: For each column `c` within the Vertical Pattern Region (from `TL_Anchor.max_c + 1` to `BR_Anchor.min_c - 1`), copy the column from `Vertical_Pattern` at index `(c - (TL_Anchor.max_c + 1)) % Vertical_Pattern.width` into the output grid at column `c` and rows `TL_Anchor.min_r` to `TL_Anchor.max_r`.
16. Tile the `Horizontal_Pattern` into the output grid: For each row `r` within the Horizontal Pattern Region (from `TL_Anchor.max_r + 1` to `BR_Anchor.min_r - 1`), copy the row from `Horizontal_Pattern` at index `(r - (TL_Anchor.max_r + 1)) % Horizontal_Pattern.height` into the output grid at row `r` and columns `TL_Anchor.min_c` to `TL_Anchor.max_c`.
17. Define frame coordinates: `frame_top = TL_Anchor.min_r - 1`, `frame_bottom = BR_Anchor.max_r + 1`, `frame_left = TL_Anchor.min_c - 1`, `frame_right = BR_Anchor.max_c + 1`.
18. Draw the frame onto the output grid, respecting grid boundaries:
    *   Fill column `frame_left` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill column `frame_right` from `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill row `frame_top` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
    *   Fill row `frame_bottom` from `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
19. Return the modified output grid.
"""

# Helper class to store object information
class GridObject:
    """Represents a contiguous object in the grid with its properties."""
    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):
        self.color = color
        self.pixels = pixels
        if not pixels:
            self.min_row, self.min_col = -1, -1
            self.max_row, self.max_col = -1, -1
            self.height, self.width = 0, 0
        else:
            rows = [r for r, c in pixels]
            cols = [c for r, c in pixels]
            self.min_row = min(rows)
            self.min_col = min(cols)
            self.max_row = max(rows)
            self.max_col = max(cols)
            self.height = self.max_row - self.min_row + 1
            self.width = self.max_col - self.min_col + 1

    def __eq__(self, other):
        if not isinstance(other, GridObject):
            return NotImplemented
        # Shape comparison based on dimensions and color
        return self.color == other.color and self.height == other.height and self.width == other.width

    def __repr__(self):
        return f"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})"

def find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:
    """Finds all contiguous objects of non-background colors using 4-connectivity."""
    objects = []
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    pixels.add((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                if pixels:
                    objects.append(GridObject(color, pixels))
    return objects

def find_first_non_background(grid: np.ndarray, background_color: int, 
                             r_start: int, r_end: int, 
                             c_start: int, c_end: int) -> Optional[int]:
    """Finds the first non-background color in a specified region (row-major scan)."""
    height, width = grid.shape
    # Ensure ranges are valid and within grid bounds before iterating
    r_start_safe = max(0, r_start)
    r_end_safe = min(height, r_end) # r_end is exclusive for range
    c_start_safe = max(0, c_start)
    c_end_safe = min(width, c_end)   # c_end is exclusive for range

    for r in range(r_start_safe, r_end_safe):
        for c in range(c_start_safe, c_end_safe):
             if grid[r, c] != background_color:
                 return grid[r, c]
    return None # No non-background color found


def transform(input_grid: np.ndarray) -> np.ndarray:
    # 1. Create a copy of the input grid
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # 2. Determine the background color
    counts = Counter(input_grid.flatten())
    if not counts: # Handle empty grid case
        return output_grid
    background_color = counts.most_common(1)[0][0]

    # 3. Identify all non-background objects
    objects = find_objects(input_grid, background_color)
    if not objects:
        return output_grid # No transformation if no objects

    # 4. Select the Top-Left Anchor (TL_Anchor)
    objects.sort(key=lambda o: (o.min_row, o.min_col))
    tl_anchor = objects[0]
    
    # 5. Select the Bottom-Right Anchor (BR_Anchor)
    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)
    br_anchor = objects[0]

    # Ensure distinct anchors if multiple objects exist
    if len(objects) > 1 and tl_anchor is br_anchor:
         # Re-evaluate BR if TL and BR are the same initially
         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], 
                                          key=lambda o: (o.max_row, o.max_col), 
                                          reverse=True)
         if potential_br_candidates:
             br_anchor = potential_br_candidates[0]
         else: # Only one effective object was found
             return output_grid
             
    # Final check if anchors are distinct
    if tl_anchor is br_anchor:
         return output_grid # Cannot proceed if anchors are not distinct

    # 6. Verify anchors match (color, height, width)
    if tl_anchor.color != br_anchor.color or \
       tl_anchor.height != br_anchor.height or \
       tl_anchor.width != br_anchor.width:
        return output_grid # Anchors don't match criteria

    # 7. Define the Vertical Pattern Region coordinates
    vp_r_start = tl_anchor.min_row
    vp_r_end = tl_anchor.max_row + 1 # Exclusive end for slicing
    vp_c_start = tl_anchor.max_c + 1
    vp_c_end = br_anchor.min_col     # Exclusive end for slicing

    # 8. Define the Horizontal Pattern Region coordinates
    hp_r_start = tl_anchor.max_row + 1
    hp_r_end = br_anchor.min_row     # Exclusive end for slicing
    hp_c_start = tl_anchor.min_c
    hp_c_end = tl_anchor.max_c + 1 # Exclusive end for slicing

    # 9. Check if pattern regions have valid dimensions
    valid_vp_region = (vp_r_end > vp_r_start) and (vp_c_end > vp_c_start)
    valid_hp_region = (hp_r_end > hp_r_start) and (hp_c_end > hp_c_start)

    # Both regions must be valid based on the problem structure
    if not valid_vp_region or not valid_hp_region:
         return output_grid 

    # 10. Extract the Vertical_Pattern subgrid
    vertical_pattern = input_grid[vp_r_start:vp_r_end, vp_c_start:vp_c_end]
    
    # 11. Extract the Horizontal_Pattern subgrid
    horizontal_pattern = input_grid[hp_r_start:hp_r_end, hp_c_start:hp_c_end]

    # Check if extracted patterns have non-zero dimensions
    vp_h, vp_w = vertical_pattern.shape
    hp_h, hp_w = horizontal_pattern.shape
    if vp_h == 0 or vp_w == 0 or hp_h == 0 or hp_w == 0:
        return output_grid # Cannot tile with empty patterns

    # 12. Determine the Vertical_Frame_Color
    vertical_frame_color = find_first_non_background(input_grid, background_color, 
                                                     vp_r_start, vp_r_end, 
                                                     vp_c_start, vp_c_end)
                                                      
    # 13. Determine the Horizontal_Frame_Color
    horizontal_frame_color = find_first_non_background(input_grid, background_color,
                                                       hp_r_start, hp_r_end,
                                                       hp_c_start, hp_c_end)

    # 14. Check if frame colors were found
    if vertical_frame_color is None or horizontal_frame_color is None:
        # If regions are valid but no color found, something is wrong
        # or the rule doesn't apply.
        return output_grid 

    # 15. Tile the Vertical_Pattern horizontally
    target_vp_rows = slice(vp_r_start, vp_r_end) # Rows to fill
    for c in range(vp_c_start, vp_c_end):
        if c >= width: break # Boundary check
        pattern_col_idx = (c - vp_c_start) % vp_w
        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]

    # 16. Tile the Horizontal_Pattern vertically
    target_hp_cols = slice(hp_c_start, hp_c_end) # Columns to fill
    for r in range(hp_r_start, hp_r_end):
        if r >= height: break # Boundary check
        pattern_row_idx = (r - hp_r_start) % hp_h
        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]

    # 17. Define frame coordinates
    frame_top = tl_anchor.min_row - 1
    frame_bottom = br_anchor.max_row + 1
    frame_left = tl_anchor.min_c - 1
    frame_right = br_anchor.max_c + 1

    # 18. Draw the frame onto the output grid, respecting grid boundaries
    # Draw vertical bars (left/right) - including corners
    if 0 <= frame_left < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end
        if row_end_safe > row_start_safe: 
             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color
    
    if 0 <= frame_right < width:
        row_start_safe = max(0, frame_top)
        row_end_safe = min(height, frame_bottom + 1) # +1 for inclusive row end
        if row_end_safe > row_start_safe:
             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color

    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges
    col_start_safe = max(0, frame_left + 1)
    col_end_safe = min(width, frame_right) # Exclusive end index for slicing
    
    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0
        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color
        
    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:
        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color

    # 19. Return the modified output grid
    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Error: 'GridObject' object has no attribute 'max_c'

## Example 2:
Error: 'GridObject' object has no attribute 'max_c'
## Assessment and Strategy

The error message `AttributeError: 'GridObject' object has no attribute 'max_c'` (and similar errors for `min_c`, `max_r`, `min_r`) clearly indicates a naming inconsistency between the `GridObject` class definition (which uses `min_col`, `max_col`, `min_row`, `max_row`) and the `transform` function's usage (which incorrectly used `min_c`, `max_c`, `min_r`, `max_r`).

The strategy is to correct these attribute names within the `transform` function to align with the `GridObject` class definition. The underlying logic of identifying anchors, extracting patterns based on anchor positions, tiling these patterns, determining frame colors from the pattern regions, and drawing the frame seems correct based on the visual comparison of inputs and outputs. No changes to the core transformation steps are needed, only the correction of attribute names.

## Metrics

Metrics gathering via code execution is not necessary here, as the error is a straightforward attribute naming issue identified during execution, not a logical flaw requiring data analysis. The visual structure and components identified previously (anchors, patterns, frame) remain consistent across both examples.

## Updated Facts


```yaml
Data:
  Input: 2D grid of pixels (0-9)
  Output: 2D grid of pixels (0-9)
  Background_Color: The most frequent color in the input grid.

Objects:
  - Type: Anchor
    Designation: TL_Anchor (Top-Left)
    Identification: The non-background object whose bounding box top-left corner (min_row, min_col) is lexicographically smallest.
    Properties: Color (Anchor_Color), BoundingBox (min_row, min_col, max_row, max_col), Height, Width.
  - Type: Anchor
    Designation: BR_Anchor (Bottom-Right)
    Identification: The non-background object whose bounding box bottom-right corner (max_row, max_col) is lexicographically largest.
    Constraint: Must have the same Anchor_Color, Height, and Width as TL_Anchor. Must be a distinct object from TL_Anchor.
    Properties: Color (Anchor_Color), BoundingBox (min_row, min_col, max_row, max_col), Height, Width.
  - Type: Pattern_Source
    Designation: Vertical_Pattern_Region
    Identification: Rectangular region in the input grid.
    Properties: Rows = `TL_Anchor.min_row` to `TL_Anchor.max_row`. Columns = `TL_Anchor.max_col + 1` to `BR_Anchor.min_col - 1`. Contains the Vertical_Pattern. Must have height > 0 and width > 0.
  - Type: Pattern_Source
    Designation: Horizontal_Pattern_Region
    Identification: Rectangular region in the input grid.
    Properties: Rows = `TL_Anchor.max_row + 1` to `BR_Anchor.min_row - 1`. Columns = `TL_Anchor.min_col` to `TL_Anchor.max_col`. Contains the Horizontal_Pattern. Must have height > 0 and width > 0.
  - Type: Pattern
    Designation: Vertical_Pattern
    Source: Input grid subgrid defined by Vertical_Pattern_Region coordinates.
  - Type: Pattern
    Designation: Horizontal_Pattern
    Source: Input grid subgrid defined by Horizontal_Pattern_Region coordinates.
  - Type: Frame
    Identification: A single-pixel-thick rectangle surrounding the combined area defined by TL_Anchor and BR_Anchor.
    Properties:
      - Vertical_Frame_Color: Color of the first non-background pixel found scanning the Vertical_Pattern_Region (row-major).
      - Horizontal_Frame_Color: Color of the first non-background pixel found scanning the Horizontal_Pattern_Region (row-major).
      - Top/Bottom segments use Vertical_Frame_Color.
      - Left/Right segments (including corners) use Horizontal_Frame_Color.

Relationships:
  - TL_Anchor and BR_Anchor define the bounds for pattern extraction, tiling, and framing.
  - Vertical_Pattern_Region is adjacent (right) to TL_Anchor and aligned vertically.
  - Horizontal_Pattern_Region is adjacent (below) to TL_Anchor and aligned horizontally.

Actions:
  - Find background color.
  - Find all non-background objects and their bounding boxes.
  - Identify TL_Anchor and BR_Anchor based on bounding box positions.
  - Verify TL_Anchor and BR_Anchor are distinct and match in color and dimensions.
  - Define Vertical and Horizontal Pattern Regions based on anchor coordinates.
  - Verify pattern regions are valid (positive dimensions).
  - Extract Vertical_Pattern and Horizontal_Pattern subgrids.
  - Verify extracted patterns have non-zero dimensions.
  - Determine Vertical_Frame_Color and Horizontal_Frame_Color by scanning pattern regions.
  - Verify frame colors were found.
  - Copy input grid to create initial output grid.
  - Tile Vertical_Pattern horizontally into the output grid within the Vertical Pattern Region's column span and TL_Anchor's row span.
  - Tile Horizontal_Pattern vertically into the output grid within the Horizontal Pattern Region's row span and TL_Anchor's column span.
  - Calculate frame boundaries (one pixel outside the combined TL_Anchor and BR_Anchor bounding box).
  - Draw the frame onto the output grid using derived colors, respecting grid boundaries.
```


## Updated Natural Language Program

1.  Create a copy of the input grid to serve as the output grid.
2.  Determine the background color by finding the most frequent pixel value in the input grid.
3.  Identify all contiguous non-background objects and calculate their bounding boxes (`min_row`, `min_col`, `max_row`, `max_col`).
4.  Select the object whose bounding box top-left corner (`min_row`, `min_col`) is lexicographically smallest as the Top-Left Anchor (TL_Anchor).
5.  Select the object whose bounding box bottom-right corner (`max_row`, `max_col`) is lexicographically largest as the Bottom-Right Anchor (BR_Anchor).
6.  Verify that TL_Anchor and BR_Anchor are distinct objects and that they have the same color, same height (`max_row - min_row + 1`), and same width (`max_col - min_col + 1`). If these conditions are not met, return the original input grid.
7.  Define the Vertical Pattern Region coordinates: Start Row = `TL_Anchor.min_row`, End Row (exclusive) = `TL_Anchor.max_row + 1`, Start Column = `TL_Anchor.max_col + 1`, End Column (exclusive) = `BR_Anchor.min_col`.
8.  Define the Horizontal Pattern Region coordinates: Start Row = `TL_Anchor.max_row + 1`, End Row (exclusive) = `BR_Anchor.min_row`, Start Column = `TL_Anchor.min_col`, End Column (exclusive) = `TL_Anchor.max_col + 1`.
9.  Check if both pattern regions have valid dimensions (End Row > Start Row and End Column > Start Column). If not, return the original input grid.
10. Extract the `Vertical_Pattern` subgrid from the input grid using the calculated Vertical Pattern Region coordinates.
11. Extract the `Horizontal_Pattern` subgrid from the input grid using the calculated Horizontal Pattern Region coordinates.
12. Check if the extracted `Vertical_Pattern` and `Horizontal_Pattern` have non-zero dimensions (height > 0 and width > 0). If either is empty, return the original input grid.
13. Determine the `Vertical_Frame_Color`: Scan the Vertical Pattern Region (defined in step 7) in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
14. Determine the `Horizontal_Frame_Color`: Scan the Horizontal Pattern Region (defined in step 8) in the input grid (row by row, then column by column) and find the color of the first non-background pixel encountered.
15. If either `Vertical_Frame_Color` or `Horizontal_Frame_Color` could not be determined (because the respective region contained only background pixels), return the original input grid.
16. Tile the `Vertical_Pattern` into the output grid: For each column `c` from `vp_c_start` to `vp_c_end - 1`, calculate the source column index in the pattern as `(c - vp_c_start) % Vertical_Pattern.width`. Copy the pixels from this source column of `Vertical_Pattern` into the output grid at column `c` and rows `vp_r_start` to `vp_r_end - 1`.
17. Tile the `Horizontal_Pattern` into the output grid: For each row `r` from `hp_r_start` to `hp_r_end - 1`, calculate the source row index in the pattern as `(r - hp_r_start) % Horizontal_Pattern.height`. Copy the pixels from this source row of `Horizontal_Pattern` into the output grid at row `r` and columns `hp_c_start` to `hp_c_end - 1`.
18. Define frame coordinates: `frame_top = TL_Anchor.min_row - 1`, `frame_bottom = BR_Anchor.max_row + 1`, `frame_left = TL_Anchor.min_col - 1`, `frame_right = BR_Anchor.max_col + 1`.
19. Draw the frame onto the output grid, respecting grid boundaries:
    *   Fill column `frame_left` from row `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill column `frame_right` from row `frame_top` to `frame_bottom` (inclusive) with `Horizontal_Frame_Color`.
    *   Fill row `frame_top` from column `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
    *   Fill row `frame_bottom` from column `frame_left + 1` to `frame_right - 1` (inclusive) with `Vertical_Frame_Color`.
20. Return the modified output grid.
