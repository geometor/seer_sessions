{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom typing import List, Tuple, Dict, Optional, Set\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background color (most frequent color).\n2. Find all distinct, contiguous non-background objects.\n3. Identify the top-leftmost object (TL_Anchor) and bottom-rightmost object (BR_Anchor).\n4. Verify that TL_Anchor and BR_Anchor have the same color and shape (based on bounding box dimensions). If not, return the input grid unchanged.\n5. Extract the repeating Vertical Pattern: Find the rectangular region immediately to the right of TL_Anchor that shares its rows. Scan columns rightwards from TL_Anchor's right edge until a column consisting entirely of the background color is found. The pattern is the block of columns before this background column. If no background column is found before BR_Anchor's left edge, use all columns up to BR_Anchor's left edge.\n6. Extract the repeating Horizontal Pattern: Find the rectangular region immediately below TL_Anchor that shares its columns. Scan rows downwards from TL_Anchor's bottom edge until a row consisting entirely of the background color is found. The pattern is the block of rows before this background row. If no background row is found before BR_Anchor's top edge, use all rows up to BR_Anchor's top edge.\n7. Determine the Vertical_Frame_Color: Scan the region defined by TL_Anchor's rows and the columns between TL_Anchor's right edge and BR_Anchor's left edge. Find the first non-background color encountered (scanning row by row, then column by column).\n8. Determine the Horizontal_Frame_Color: Scan the region defined by TL_Anchor's columns and the rows between TL_Anchor's bottom edge and BR_Anchor's top edge. Find the first non-background color encountered (scanning row by row, then column by column).\n9. If either frame color cannot be determined (e.g., regions are empty or all background), return the input grid unchanged.\n10. Create an output grid initialized as a copy of the input grid.\n11. Tile the extracted Vertical_Pattern horizontally in the output grid, filling the area defined by TL_Anchor's rows and the columns between the right edge of TL_Anchor and the left edge of BR_Anchor. Use modulo arithmetic based on the pattern's width for repetition.\n12. Tile the extracted Horizontal_Pattern vertically in the output grid, filling the area defined by TL_Anchor's columns and the rows between the bottom edge of TL_Anchor and the top edge of BR_Anchor. Use modulo arithmetic based on the pattern's height for repetition.\n13. Define a frame one pixel outside the combined bounding box of the TL_Anchor and BR_Anchor.\n14. Draw the frame onto the output grid, ensuring it stays within grid bounds:\n    - Left and Right vertical segments (including corners) use Horizontal_Frame_Color.\n    - Top and Bottom horizontal segments (between the vertical segments) use Vertical_Frame_Color.\n15. Return the modified output grid.\n\"\"\"\n\n# Helper class to store object information\nclass GridObject:\n    def __init__(self, color: int, pixels: Set[Tuple[int, int]]):\n        self.color = color\n        self.pixels = pixels\n        if not pixels:\n             # Should not happen with valid objects, but prevent errors\n            self.min_row, self.min_col = -1, -1\n            self.max_row, self.max_col = -1, -1\n            self.height, self.width = 0, 0\n        else:\n            rows = [r for r, c in pixels]\n            cols = [c for r, c in pixels]\n            self.min_row = min(rows)\n            self.min_col = min(cols)\n            self.max_row = max(rows)\n            self.max_col = max(cols)\n            self.height = self.max_row - self.min_row + 1\n            self.width = self.max_col - self.min_col + 1\n\n    def __eq__(self, other):\n        if not isinstance(other, GridObject):\n            return NotImplemented\n        # Shape comparison based on dimensions and color\n        return self.color == other.color and self.height == other.height and self.width == other.width\n\n    def __repr__(self):\n        return f\"Object(Color:{self.color}, Pos:({self.min_row},{self.min_col}) to ({self.max_row},{self.max_col}), Size:{self.height}x{self.width})\"\n\ndef find_objects(grid: np.ndarray, background_color: int) -> List[GridObject]:\n    \"\"\"Finds all contiguous objects of non-background colors using 4-connectivity.\"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                obj_pixels_list = [] # Keep order for easier debugging if needed\n                \n                while q:\n                    row, col = q.pop(0)\n                    pixels.add((row, col))\n                    obj_pixels_list.append((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if pixels:\n                    objects.append(GridObject(color, pixels))\n    return objects\n\ndef find_first_non_background(grid: np.ndarray, background_color: int, \n                             r_start: int, r_end: int, \n                             c_start: int, c_end: int) -> Optional[int]:\n    \"\"\"Finds the first non-background color in a specified region (row-major scan).\"\"\"\n    height, width = grid.shape\n    # Ensure ranges are valid and within grid bounds before iterating\n    r_start_safe = max(0, r_start)\n    r_end_safe = min(height, r_end)\n    c_start_safe = max(0, c_start)\n    c_end_safe = min(width, c_end)\n\n    for r in range(r_start_safe, r_end_safe):\n        for c in range(c_start_safe, c_end_safe):\n             if grid[r, c] != background_color:\n                 return grid[r, c]\n    return None # No non-background color found\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify background color\n    counts = Counter(input_grid.flatten())\n    if not counts: # Handle empty grid case\n        return output_grid\n    background_color = counts.most_common(1)[0][0]\n\n    # 2. Find all non-background objects\n    objects = find_objects(input_grid, background_color)\n    if not objects:\n        return output_grid # No objects, no transformation\n\n    # 3. Identify TL_Anchor and BR_Anchor\n    # Sort by top-row, then left-column for TL\n    objects.sort(key=lambda o: (o.min_row, o.min_col))\n    tl_anchor = objects[0]\n    \n    # Sort by bottom-row (desc), then right-column (desc) for BR\n    objects.sort(key=lambda o: (o.max_row, o.max_col), reverse=True)\n    br_anchor = objects[0]\n\n    # Ensure distinct anchors if multiple objects exist\n    if len(objects) > 1 and tl_anchor is br_anchor:\n         # If TL and BR based on initial sorts are the same, re-evaluate BR\n         potential_br_candidates = sorted([o for o in objects if o is not tl_anchor], \n                                          key=lambda o: (o.max_row, o.max_col), \n                                          reverse=True)\n         if potential_br_candidates:\n             br_anchor = potential_br_candidates[0]\n         else: # Only one object was found effectively\n             return output_grid\n             \n    # Final check if anchors are distinct\n    if tl_anchor is br_anchor:\n         return output_grid # Cannot proceed if anchors are not distinct\n\n    # 4. Verify anchors match in color and shape (dimensions)\n    if tl_anchor.color != br_anchor.color or \\\n       tl_anchor.height != br_anchor.height or \\\n       tl_anchor.width != br_anchor.width:\n        return output_grid # Anchors don't match criteria\n\n    # --- Define Potential Regions for Frame Color Determination ---\n    frame_vp_r_start = tl_anchor.min_row\n    frame_vp_r_end = tl_anchor.max_row + 1\n    frame_vp_c_start = tl_anchor.max_col + 1\n    frame_vp_c_end = br_anchor.min_col\n\n    frame_hp_r_start = tl_anchor.max_row + 1\n    frame_hp_r_end = br_anchor.min_row\n    frame_hp_c_start = tl_anchor.min_col\n    frame_hp_c_end = tl_anchor.max_col + 1\n\n    # Check if these frame determination regions have positive dimensions\n    valid_frame_vp_region = frame_vp_r_end > frame_vp_r_start and frame_vp_c_end > frame_vp_c_start\n    valid_frame_hp_region = frame_hp_r_end > frame_hp_r_start and frame_hp_c_end > frame_hp_c_start\n\n    # 7. Determine Vertical_Frame_Color (from potential region)\n    vertical_frame_color = None\n    if valid_frame_vp_region:\n        vertical_frame_color = find_first_non_background(input_grid, background_color, \n                                                         frame_vp_r_start, frame_vp_r_end, \n                                                         frame_vp_c_start, frame_vp_c_end)\n                                                      \n    # 8. Determine Horizontal_Frame_Color (from potential region)\n    horizontal_frame_color = None\n    if valid_frame_hp_region:\n        horizontal_frame_color = find_first_non_background(input_grid, background_color,\n                                                           frame_hp_r_start, frame_hp_r_end,\n                                                           frame_hp_c_start, frame_hp_c_end)\n\n    # 9. Check if frame colors were found (if regions were valid)\n    if (valid_frame_vp_region and vertical_frame_color is None) or \\\n       (valid_frame_hp_region and horizontal_frame_color is None):\n         # If a region exists but has no non-background color, rule might not apply\n         # Or if frame colors are essential and missing, return original\n         # For this task, frame colors seem essential.\n         return output_grid\n         \n    # If a region didn't exist, we might still proceed if the other exists.\n    # However, the examples imply both patterns and frame colors derived from them exist.\n    # Let's enforce that both frame colors must be found if their regions are valid.\n    if vertical_frame_color is None or horizontal_frame_color is None:\n        return output_grid # Essential colors missing\n\n\n    # --- Extract Actual Repeating Patterns ---\n    \n    # 5. Extract Vertical Pattern\n    vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1)\n    vp_start_col = tl_anchor.max_col + 1\n    vp_end_col = vp_start_col \n    for c in range(vp_start_col, br_anchor.min_col):\n        # Ensure column index is valid before checking\n        if c >= width: break \n        # Check if the column slice within anchor rows is all background\n        if np.all(input_grid[vp_rows, c] == background_color):\n            vp_end_col = c # End column is the first background-only column\n            break\n    else: # No background column found before BR anchor\n        vp_end_col = br_anchor.min_col\n\n    # Check if vp_end_col makes sense (it must be > vp_start_col for a pattern)\n    if vp_end_col <= vp_start_col:\n         # Vertical pattern is empty or invalid\n         return output_grid \n    vertical_pattern = input_grid[vp_rows, vp_start_col:vp_end_col]\n    vp_h, vp_w = vertical_pattern.shape\n    if vp_h == 0 or vp_w == 0: return output_grid # Pattern is empty\n\n    # 6. Extract Horizontal Pattern\n    hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1)\n    hp_start_row = tl_anchor.max_row + 1\n    hp_end_row = hp_start_row\n    for r in range(hp_start_row, br_anchor.min_row):\n        if r >= height: break\n        if np.all(input_grid[r, hp_cols] == background_color):\n            hp_end_row = r\n            break\n    else: # No background row found\n        hp_end_row = br_anchor.min_row\n        \n    if hp_end_row <= hp_start_row:\n        # Horizontal pattern is empty or invalid\n        return output_grid\n    horizontal_pattern = input_grid[hp_start_row:hp_end_row, hp_cols]\n    hp_h, hp_w = horizontal_pattern.shape\n    if hp_h == 0 or hp_w == 0: return output_grid # Pattern is empty\n\n\n    # --- Apply Transformations to output_grid ---\n\n    # 11. Tile Vertical_Pattern horizontally\n    target_vp_rows = slice(tl_anchor.min_row, tl_anchor.max_row + 1) # Rows to fill\n    target_vp_c_start = tl_anchor.max_col + 1\n    target_vp_c_end = br_anchor.min_col \n    for c in range(target_vp_c_start, target_vp_c_end):\n        # Check column bounds\n        if c >= width: break \n        pattern_col_idx = (c - target_vp_c_start) % vp_w\n        output_grid[target_vp_rows, c] = vertical_pattern[:, pattern_col_idx]\n\n    # 12. Tile Horizontal_Pattern vertically\n    target_hp_cols = slice(tl_anchor.min_col, tl_anchor.max_col + 1) # Columns to fill\n    target_hp_r_start = tl_anchor.max_row + 1\n    target_hp_r_end = br_anchor.min_row\n    for r in range(target_hp_r_start, target_hp_r_end):\n        if r >= height: break\n        pattern_row_idx = (r - target_hp_r_start) % hp_h\n        output_grid[r, target_hp_cols] = horizontal_pattern[pattern_row_idx, :]\n\n    # --- Draw Frame ---\n    # 13. Define frame boundaries\n    frame_top = tl_anchor.min_row - 1\n    frame_bottom = br_anchor.max_row + 1\n    frame_left = tl_anchor.min_col - 1\n    frame_right = br_anchor.max_col + 1\n\n    # 14. Draw the frame safely within grid bounds\n    # Draw vertical bars (left/right) - including corners\n    if 0 <= frame_left < width:\n        row_start_safe = max(0, frame_top)\n        row_end_safe = min(height, frame_bottom + 1)\n        if row_end_safe > row_start_safe: # Check if there's any row to draw\n             output_grid[row_start_safe:row_end_safe, frame_left] = horizontal_frame_color\n    \n    if 0 <= frame_right < width:\n        row_start_safe = max(0, frame_top)\n        row_end_safe = min(height, frame_bottom + 1)\n        if row_end_safe > row_start_safe:\n             output_grid[row_start_safe:row_end_safe, frame_right] = horizontal_frame_color\n\n    # Draw horizontal bars (top/bottom) - between vertical bars' inner edges\n    col_start_safe = max(0, frame_left + 1)\n    col_end_safe = min(width, frame_right) # End index is exclusive for slicing\n    \n    if 0 <= frame_top < height and col_end_safe > col_start_safe: # Check row valid and width > 0\n        output_grid[frame_top, col_start_safe:col_end_safe] = vertical_frame_color\n        \n    if 0 <= frame_bottom < height and col_end_safe > col_start_safe:\n        output_grid[frame_bottom, col_start_safe:col_end_safe] = vertical_frame_color\n\n    # 15. Return final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19740,
    "candidates_token_count": 4210,
    "total_token_count": 23950,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.255576,
  "retries": 1
}