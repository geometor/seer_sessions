
## train_1

**input:**
```
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```


## train_2

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```


## train_3

**input:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


**output:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


## train_4

**input:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 3 3 3 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


**output:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```

Okay, let's break down this task.

## Perception

1.  **Grid Structure:** Each input and output grid is 20x20.
2.  **Border:** All grids have a single-pixel border of a specific color (maroon, orange, gray, red in the examples). This border remains unchanged in the output.
3.  **Background:** The area inside the border is predominantly white (0).
4.  **Input Objects:** Inside the border, each input grid contains two key object types:
    *   An 'H' shape composed of a single color (magenta, blue, orange, green in the examples). The 'H' shape appears to be consistently formed by two 3-pixel vertical segments separated by one white pixel, connected by a single pixel horizontally in the middle row.
    *   Two isolated pixels of another identical color (orange, magenta, red, blue in the examples). These two pixels are always located on the same horizontal row, positioned symmetrically relative to the center, often near the border but not touching it.
5.  **Output Objects:** The output grid retains the border. The original 'H' shape from the input is removed (replaced with white). A *new* 'H' shape is drawn, using the color and row/column positions of the two isolated pixels from the input.
6.  **Transformation Logic:** The core transformation involves locating the pair of isolated, identically colored pixels on the same row. Their color determines the color of the new 'H' shape. Their row determines the row of the horizontal bar of the new 'H'. Their columns determine the start and end columns of the horizontal bar and the columns for the vertical bars. The original 'H' shape is erased. The new 'H' shape consists of a horizontal bar connecting the two identified pixel locations and two 3-pixel high vertical bars centered on the horizontal bar at those same column locations.

## Facts


```yaml
task_context:
  grid_size: 20x20 (constant)
  background_color: white (0)
  border:
    present: true
    thickness: 1 pixel
    color: variable (maroon, orange, gray, red), preserved in output
objects:
  - type: existing_h_shape
    description: An 'H' shape formed by two 3-pixel vertical segments separated by one pixel, connected by a single horizontal pixel in the middle row.
    color: variable (magenta, blue, orange, green)
    action: removed (pixels changed to white) in the output.
    count_per_input: 1
  - type: isolated_pixel_pair
    description: Two pixels of the same color, located on the same row, symmetrically placed.
    color: variable (orange, magenta, red, blue), different from existing_h_shape color.
    count_per_input: 1 (pair)
    role: determines the properties of the new_h_shape.
    properties:
      color: C
      row: R
      columns: [C1, C2] (where C1 < C2)
  - type: new_h_shape
    description: An 'H' shape constructed based on the isolated_pixel_pair.
    location: created in the output grid.
    color: C (from isolated_pixel_pair)
    structure:
      horizontal_bar: row R, from column C1 to C2.
      left_vertical_bar: column C1, rows R-1, R, R+1.
      right_vertical_bar: column C2, rows R-1, R, R+1.
relationships:
  - isolated_pixel_pair -> new_h_shape (determines color and position)
  - existing_h_shape -> removal (erased in output)
  - border -> preservation (unchanged in output)
```


## Natural Language Program

1.  Identify the grid's border; its color and position remain unchanged in the output.
2.  Scan the input grid (excluding the border) to find two pixels that:
    *   Have the same color (let this color be `TargetColor`).
    *   Are not the background color (white).
    *   Are located on the same row (let this row be `TargetRow`).
    *   Record their column indices (let them be `Col1` and `Col2`, with `Col1 < Col2`).
3.  Identify the pixels belonging to the pre-existing 'H' shape object (which will have a different color than `TargetColor`).
4.  Create the output grid by copying the input grid.
5.  In the output grid, change all pixels belonging to the pre-existing 'H' shape (identified in step 3) to the background color (white, 0).
6.  In the output grid, draw the new 'H' shape using `TargetColor`:
    *   Draw a horizontal line on `TargetRow` from `Col1` to `Col2` inclusive.
    *   Draw a vertical line at `Col1`, covering rows `TargetRow - 1`, `TargetRow`, and `TargetRow + 1`.
    *   Draw a vertical line at `Col2`, covering rows `TargetRow - 1`, `TargetRow`, and `TargetRow + 1`.
```python
import numpy as np
from collections import defaultdict

"""
Transformation Rule:
1. Identify the grid's border; its color and position remain unchanged.
2. Scan the input grid (excluding the border) to find two pixels that:
    * Have the same color (TargetColor).
    * Are not the background color (white, 0).
    * Are located on the same row (TargetRow).
    * Record their column indices (Col1 and Col2, with Col1 < Col2).
3. Identify the pixels belonging to the pre-existing 'H' shape object (which will have a different color than TargetColor).
4. Create the output grid by copying the input grid.
5. In the output grid, change all pixels belonging to the pre-existing 'H' shape to the background color (white, 0).
6. In the output grid, draw the new 'H' shape using TargetColor:
    * Draw a horizontal line on TargetRow from Col1 to Col2 inclusive.
    * Draw a vertical line at Col1, covering rows TargetRow - 1, TargetRow, and TargetRow + 1.
    * Draw a vertical line at Col2, covering rows TargetRow - 1, TargetRow, and TargetRow + 1.
"""

def find_objects(grid):
    """Finds contiguous or separated objects based on color."""
    height, width = grid.shape
    objects = defaultdict(list)
    # Iterate through the grid, excluding the border
    # Assuming border is 1 pixel thick
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            color = grid[r, c]
            if color != 0: # Ignore background
                objects[color].append((r, c))
    return objects

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Finds a pair of isolated pixels and an 'H' shape, erases the old 'H',
    and draws a new 'H' based on the isolated pair's properties.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. & 2. Find objects and identify the isolated pair and existing H
    objects = find_objects(input_grid_np)

    target_color = -1
    target_row = -1
    col1 = -1
    col2 = -1
    existing_h_color = -1
    existing_h_pixels = []

    for color, pixels in objects.items():
        if len(pixels) == 2:
            # Potential isolated pair
            p1_row, p1_col = pixels[0]
            p2_row, p2_col = pixels[1]
            if p1_row == p2_row: # Check if they are on the same row
                target_color = color
                target_row = p1_row
                col1 = min(p1_col, p2_col)
                col2 = max(p1_col, p2_col)
        elif len(pixels) > 2:
             # Assume this is the existing H shape
             existing_h_color = color
             existing_h_pixels = pixels
        # Handle cases where more than two types of objects are found if necessary

    # Check if we found the required objects
    if target_color == -1 or existing_h_color == -1:
        # Raise an error or return input if pattern not found
        # For now, let's assume the pattern always exists based on examples
        print("Warning: Could not identify both the pixel pair and the existing H shape.")
        # Depending on strictness, might return input or raise error.
        # Let's proceed assuming they were found for the examples.


    # 5. Erase the existing 'H' shape
    for r, c in existing_h_pixels:
         # Check bounds just in case, although H should be within borders
         if 0 <= r < height and 0 <= c < width:
              output_grid[r, c] = 0 # Set to background color

    # 6. Draw the new 'H' shape
    if target_color != -1:
        # Draw horizontal bar
        for c in range(col1, col2 + 1):
             if 0 <= target_row < height and 0 <= c < width:
                  output_grid[target_row, c] = target_color

        # Draw left vertical bar (3 pixels high)
        for r_offset in [-1, 0, 1]:
             r = target_row + r_offset
             if 0 <= r < height and 0 <= col1 < width:
                  output_grid[r, col1] = target_color

        # Draw right vertical bar (3 pixels high)
        for r_offset in [-1, 0, 1]:
             r = target_row + r_offset
             if 0 <= r < height and 0 <= col2 < width:
                  output_grid[r, col2] = target_color

    return output_grid.tolist()
```
```python
import numpy as np
from collections import defaultdict

"""
Transformation Rule:
1. Identify the grid's border color.
2. Scan the inner area (excluding the border) to find a pair of pixels that have the same color (TargetColor), are not background, and are on the same row (TargetRow) at columns Col1 and Col2.
3. Erase all pixels in the grid that are NOT the border color, NOT the TargetColor, and NOT the background color (0).
4. Draw a new 'H' shape using TargetColor, positioned based on TargetRow, Col1, and Col2. The 'H' consists of a horizontal bar from Col1 to Col2 on TargetRow, and two 3-pixel vertical bars centered on TargetRow at columns Col1 and Col2.
"""

def find_isolated_pair(grid_np, border_color):
    """
    Scans the inner area of the grid to find the isolated pair.

    Args:
        grid_np: The input grid as a numpy array.
        border_color: The color of the border pixels.

    Returns:
        A tuple (target_color, target_row, col1, col2) if found,
        otherwise raises ValueError.
    """
    height, width = grid_np.shape
    inner_pixels_by_color = defaultdict(list)

    # Scan inner grid (rows 1 to height-2, cols 1 to width-2)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            color = grid_np[r, c]
            # Ignore background and border colors found inside (shouldn't happen based on examples)
            if color != 0 and color != border_color:
                inner_pixels_by_color[color].append((r, c))

    # Find the color associated with exactly two pixels
    for color, pixels in inner_pixels_by_color.items():
        if len(pixels) == 2:
            p1_row, p1_col = pixels[0]
            p2_row, p2_col = pixels[1]
            # Check if they are on the same row
            if p1_row == p2_row:
                target_color = color
                target_row = p1_row
                col1 = min(p1_col, p2_col)
                col2 = max(p1_col, p2_col)
                return target_color, target_row, col1, col2

    raise ValueError("Isolated pixel pair not found in the inner grid.")


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    # Convert to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. Identify Border Color
    border_color = input_grid_np[0, 0]

    # 2. Find Isolated Pair properties
    try:
        target_color, target_row, col1, col2 = find_isolated_pair(input_grid_np, border_color)
    except ValueError as e:
        print(f"Error finding isolated pair: {e}")
        # Return unmodified grid or handle error as appropriate
        return input_grid # Return original if pattern not found

    # 3. Erase the old shape
    # Iterate through the entire grid
    for r in range(height):
        for c in range(width):
            current_color = input_grid_np[r, c]
            # Check if the color is not border, not target, and not background
            if current_color != border_color and \
               current_color != target_color and \
               current_color != 0:
                output_grid[r, c] = 0 # Set to background color

    # 4. Draw the new 'H' shape
    # Draw horizontal bar (ensure within bounds)
    if 0 <= target_row < height:
        for c in range(col1, col2 + 1):
            if 0 <= c < width:
                output_grid[target_row, c] = target_color

    # Draw left vertical bar (3 pixels high, ensure within bounds)
    if 0 <= col1 < width:
        for r_offset in [-1, 0, 1]:
            r = target_row + r_offset
            if 0 <= r < height:
                output_grid[r, col1] = target_color

    # Draw right vertical bar (3 pixels high, ensure within bounds)
    if 0 <= col2 < width:
        for r_offset in [-1, 0, 1]:
            r = target_row + r_offset
            if 0 <= r < height:
                output_grid[r, col2] = target_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import defaultdict

"""
Transformation Rule:
1. Preserve the border: Identify the border color and keep it unchanged.
2. Identify the target pair: Find two pixels in the inner grid (excluding the border) that:
    a. Have the same color (TargetColor).
    b. Are not the background color (0).
    c. Are on the same row (TargetRow).
    d. Note their column indices (Col1, Col2, where Col1 < Col2).
3. Identify the color to erase: Find the other non-background, non-border color present in the inner grid (EraseColor). This color belongs to the object that will be removed.
4. Define canonical H structures: Create a mapping that associates each possible TargetColor with predefined vertical column positions (CanonVCol1, CanonVCol2) and a vertical range relative to the TargetRow (MinOffset, MaxOffset). Based on the examples:
    - Orange (7): Cols (13, 15), Rows TargetRow-1 to TargetRow+2 (Height 4)
    - Magenta (6): Cols (2, 4), Rows TargetRow-2 to TargetRow+3 (Height 6)
    - Red (2): Cols (6, 8), Rows TargetRow-2 to TargetRow+2 (Height 5)
    - Blue (1): Cols (14, 16), Rows TargetRow-1 to TargetRow+1 (Height 3)
5. Initialize Output: Create a copy of the input grid.
6. Erase the old object: Iterate through the inner grid of the output grid and change any pixel matching EraseColor to the background color (0).
7. Draw the new H shape: In the output grid, using TargetColor:
    a. Draw a horizontal line on TargetRow from Col1 to Col2 inclusive.
    b. Retrieve the canonical structure (CanonVCol1, CanonVCol2, MinOffset, MaxOffset) based on TargetColor.
    c. Draw the first vertical line at column CanonVCol1, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset inclusive.
    d. Draw the second vertical line at column CanonVCol2, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset inclusive.
"""

# Define the canonical H structures based on observed patterns in training data
CANONICAL_H_STRUCTURES = {
    7: {'cols': (13, 15), 'rows': (-1, 2)},  # Orange: Cols 13, 15; Rows TargetRow-1 to TargetRow+2
    6: {'cols': (2, 4),   'rows': (-2, 3)},  # Magenta: Cols 2, 4; Rows TargetRow-2 to TargetRow+3
    2: {'cols': (6, 8),   'rows': (-2, 2)},  # Red: Cols 6, 8; Rows TargetRow-2 to TargetRow+2
    1: {'cols': (14, 16), 'rows': (-1, 1)},  # Blue: Cols 14, 16; Rows TargetRow-1 to TargetRow+1
}


def find_inner_pixels(grid_np):
    """
    Finds all non-background pixels within the border, grouped by color.

    Args:
        grid_np: The input grid as a numpy array.

    Returns:
        A dictionary mapping color to a list of (row, col) coordinates.
    """
    height, width = grid_np.shape
    inner_pixels_by_color = defaultdict(list)
    # Assume border is 1 pixel thick
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            color = grid_np[r, c]
            if color != 0:  # Ignore background
                inner_pixels_by_color[color].append((r, c))
    return inner_pixels_by_color


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    # Convert to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. Identify Border Color (not strictly needed for logic but good context)
    border_color = input_grid_np[0, 0]

    # Find all relevant pixels inside the border
    inner_pixels = find_inner_pixels(input_grid_np)

    target_color = -1
    target_row = -1
    col1 = -1
    col2 = -1
    erase_color = -1

    # 2. & 3. Identify Target Pair and Erase Color
    colors_found = list(inner_pixels.keys())
    if len(colors_found) != 2:
         # This case should not happen based on examples, but handle defensively
         print(f"Warning: Expected 2 non-background inner colors, found {len(colors_found)}. Returning input.")
         return input_grid

    for color, pixels in inner_pixels.items():
        if len(pixels) == 2:
            # This is the Target Pair
            p1_row, p1_col = pixels[0]
            p2_row, p2_col = pixels[1]
            if p1_row == p2_row: # Check if they are on the same row
                target_color = color
                target_row = p1_row
                col1 = min(p1_col, p2_col)
                col2 = max(p1_col, p2_col)
            else:
                 # Pair found but not on the same row - error condition?
                 print(f"Warning: Found pair of color {color} but not on same row. Returning input.")
                 return input_grid
        else:
            # Assume the other color is the one to erase
            erase_color = color

    # Validation checks
    if target_color == -1 or erase_color == -1:
        print("Warning: Could not identify both target pair and erase color. Returning input.")
        return input_grid
    if target_color not in CANONICAL_H_STRUCTURES:
        print(f"Warning: No canonical H structure defined for target color {target_color}. Returning input.")
        return input_grid


    # 6. Erase the old object
    pixels_to_erase = inner_pixels.get(erase_color, [])
    for r, c in pixels_to_erase:
         if 1 <= r < height - 1 and 1 <= c < width - 1: # Ensure erasing only inside border
              output_grid[r, c] = 0 # Set to background color

    # 7. Draw the new H shape
    # Retrieve canonical structure
    structure = CANONICAL_H_STRUCTURES[target_color]
    canon_vcol1, canon_vcol2 = structure['cols']
    min_offset, max_offset = structure['rows']

    # Draw horizontal bar (ensure within bounds)
    if 0 <= target_row < height:
        for c in range(col1, col2 + 1):
            if 0 <= c < width:
                # Avoid overwriting border if Col1/Col2 are adjacent to it
                if r > 0 and r < height - 1 and c > 0 and c < width - 1:
                     output_grid[target_row, c] = target_color
                elif input_grid_np[target_row, c] != border_color: # Allow drawing if original wasn't border
                     output_grid[target_row, c] = target_color


    # Draw first vertical bar (ensure within bounds)
    if 0 <= canon_vcol1 < width:
        for r_offset in range(min_offset, max_offset + 1):
            r = target_row + r_offset
            if 0 <= r < height:
                 # Avoid overwriting border
                 if r > 0 and r < height - 1 and canon_vcol1 > 0 and canon_vcol1 < width - 1:
                      output_grid[r, canon_vcol1] = target_color
                 elif input_grid_np[r, canon_vcol1] != border_color: # Allow drawing if original wasn't border
                      output_grid[r, canon_vcol1] = target_color


    # Draw second vertical bar (ensure within bounds)
    if 0 <= canon_vcol2 < width:
        for r_offset in range(min_offset, max_offset + 1):
            r = target_row + r_offset
            if 0 <= r < height:
                 # Avoid overwriting border
                 if r > 0 and r < height - 1 and canon_vcol2 > 0 and canon_vcol2 < width - 1:
                       output_grid[r, canon_vcol2] = target_color
                 elif input_grid_np[r, canon_vcol2] != border_color: # Allow drawing if original wasn't border
                       output_grid[r, canon_vcol2] = target_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import defaultdict

"""
Transformation Rule:
1. Preserve the border: Identify the border color and keep it unchanged.
2. Identify the target pair: Find two pixels in the inner grid (excluding the border) that:
    a. Have the same color (TargetColor).
    b. Are not the background color (0).
    c. Are on the same row (TargetRow).
    d. Note their column indices (Col1, Col2, where Col1 < Col2).
3. Identify the color to erase: Find the other non-background, non-border color present in the inner grid (EraseColor). This color belongs to the object that will be removed.
4. Define canonical H structures: Create a mapping that associates each possible TargetColor with predefined vertical column positions (CanonVCol1, CanonVCol2) and a vertical range relative to the TargetRow (MinOffset, MaxOffset). Based on the examples:
    - Orange (7): Cols (13, 15), Rows TargetRow-1 to TargetRow+2 (Height 4)
    - Magenta (6): Cols (2, 4), Rows TargetRow-2 to TargetRow+3 (Height 6)
    - Red (2): Cols (6, 8), Rows TargetRow-2 to TargetRow+2 (Height 5)
    - Blue (1): Cols (14, 16), Rows TargetRow-1 to TargetRow+1 (Height 3)
5. Initialize Output: Create a copy of the input grid.
6. Erase the old object: Iterate through the inner grid of the output grid and change any pixel matching EraseColor to the background color (0).
7. Draw the new H shape: In the output grid, using TargetColor:
    a. Draw a horizontal line on TargetRow from Col1 to Col2 inclusive.
    b. Retrieve the canonical structure (CanonVCol1, CanonVCol2, MinOffset, MaxOffset) based on TargetColor.
    c. Draw the first vertical line at column CanonVCol1, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset inclusive.
    d. Draw the second vertical line at column CanonVCol2, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset inclusive.
"""

# Define the canonical H structures based on observed patterns in training data
CANONICAL_H_STRUCTURES = {
    7: {'cols': (13, 15), 'rows': (-1, 2)},  # Orange: Cols 13, 15; Rows TargetRow-1 to TargetRow+2
    6: {'cols': (2, 4),   'rows': (-2, 3)},  # Magenta: Cols 2, 4; Rows TargetRow-2 to TargetRow+3
    2: {'cols': (6, 8),   'rows': (-2, 2)},  # Red: Cols 6, 8; Rows TargetRow-2 to TargetRow+2
    1: {'cols': (14, 16), 'rows': (-1, 1)},  # Blue: Cols 14, 16; Rows TargetRow-1 to TargetRow+1
}


def find_inner_pixels(grid_np):
    """
    Finds all non-background pixels within the border, grouped by color.

    Args:
        grid_np: The input grid as a numpy array.

    Returns:
        A dictionary mapping color to a list of (row, col) coordinates.
    """
    height, width = grid_np.shape
    inner_pixels_by_color = defaultdict(list)
    # Assume border is 1 pixel thick
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            color = grid_np[r, c]
            if color != 0:  # Ignore background
                inner_pixels_by_color[color].append((r, c))
    return inner_pixels_by_color


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    # Convert to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. Identify Border Color (not strictly needed for logic but good context)
    border_color = input_grid_np[0, 0]

    # Find all relevant pixels inside the border
    inner_pixels = find_inner_pixels(input_grid_np)

    target_color = -1
    target_row = -1
    col1 = -1
    col2 = -1
    erase_color = -1

    # 2. & 3. Identify Target Pair and Erase Color
    colors_found = list(inner_pixels.keys())
    if len(colors_found) != 2:
         # This case should not happen based on examples, but handle defensively
         print(f"Warning: Expected 2 non-background inner colors, found {len(colors_found)}. Returning input.")
         return input_grid

    for color, pixels in inner_pixels.items():
        if len(pixels) == 2:
            # This is the Target Pair
            p1_row, p1_col = pixels[0]
            p2_row, p2_col = pixels[1]
            if p1_row == p2_row: # Check if they are on the same row
                target_color = color
                target_row = p1_row
                col1 = min(p1_col, p2_col)
                col2 = max(p1_col, p2_col)
            else:
                 # Pair found but not on the same row - error condition?
                 print(f"Warning: Found pair of color {color} but not on same row. Returning input.")
                 return input_grid
        else:
            # Assume the other color is the one to erase
            erase_color = color

    # Validation checks
    if target_color == -1 or erase_color == -1:
        print("Warning: Could not identify both target pair and erase color. Returning input.")
        return input_grid
    if target_color not in CANONICAL_H_STRUCTURES:
        print(f"Warning: No canonical H structure defined for target color {target_color}. Returning input.")
        return input_grid


    # 6. Erase the old object
    pixels_to_erase = inner_pixels.get(erase_color, [])
    for r, c in pixels_to_erase:
         if 1 <= r < height - 1 and 1 <= c < width - 1: # Ensure erasing only inside border
              output_grid[r, c] = 0 # Set to background color

    # 7. Draw the new H shape
    # Retrieve canonical structure
    structure = CANONICAL_H_STRUCTURES[target_color]
    canon_vcol1, canon_vcol2 = structure['cols']
    min_offset, max_offset = structure['rows']

    # Draw horizontal bar (ensure within bounds)
    if 0 <= target_row < height:
        for c in range(col1, col2 + 1):
            if 0 <= c < width:
                # Avoid overwriting border if Col1/Col2 are adjacent to it
                if r > 0 and r < height - 1 and c > 0 and c < width - 1:
                     output_grid[target_row, c] = target_color
                elif input_grid_np[target_row, c] != border_color: # Allow drawing if original wasn't border
                     output_grid[target_row, c] = target_color


    # Draw first vertical bar (ensure within bounds)
    if 0 <= canon_vcol1 < width:
        for r_offset in range(min_offset, max_offset + 1):
            r = target_row + r_offset
            if 0 <= r < height:
                 # Avoid overwriting border
                 if r > 0 and r < height - 1 and canon_vcol1 > 0 and canon_vcol1 < width - 1:
                      output_grid[r, canon_vcol1] = target_color
                 elif input_grid_np[r, canon_vcol1] != border_color: # Allow drawing if original wasn't border
                      output_grid[r, canon_vcol1] = target_color


    # Draw second vertical bar (ensure within bounds)
    if 0 <= canon_vcol2 < width:
        for r_offset in range(min_offset, max_offset + 1):
            r = target_row + r_offset
            if 0 <= r < height:
                 # Avoid overwriting border
                 if r > 0 and r < height - 1 and canon_vcol2 > 0 and canon_vcol2 < width - 1:
                       output_grid[r, canon_vcol2] = target_color
                 elif input_grid_np[r, canon_vcol2] != border_color: # Allow drawing if original wasn't border
                       output_grid[r, canon_vcol2] = target_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```
Expected Output:
```
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```
Transformed Output:
```
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```
Match: False
Pixels Off: 5
Size Correct: True
Color Palette Correct: False
Color Count Correct: False
Score: 5.0

## Example 2:
Input:
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```
Expected Output:
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```
Transformed Output:
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```
Match: False
Pixels Off: 3
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 1.5

## Example 3:
Input:
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```
Expected Output:
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```
Transformed Output:
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```
Match: False
Pixels Off: 6
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 3.0

## Example 4:
Input:
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 3 3 3 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```
Expected Output:
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```
Transformed Output:
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0
## Assessment and Strategy

The previous attempt failed on 3 out of 4 training examples. The core logic of identifying a pair of identically colored pixels on the same row (`TargetPair`) and another distinct colored shape (`OriginalShape`) seems correct. The step of erasing the `OriginalShape` also appears valid. The failure lies in the construction of the `NewShape`.

The previous hypothesis incorrectly assumed that the `TargetPair`'s color dictated a fixed ("canonical") structure (vertical bar columns and height) for the `NewShape`. The results show this is not the case.

**Revised Hypothesis:**

1.  The `TargetPair` (color `C`, row `R`, columns `C1`, `C2`) determines:
    *   The color (`C`) of the `NewShape`.
    *   The row (`R`) and column extent (`C1` to `C2`) of the `NewShape`'s horizontal bar.
2.  The `OriginalShape` (color `EraseColor`) determines:
    *   The pixels to be erased.
    *   The structure (vertical bar columns `V1`, `V2` and relative height `H`) of the `NewShape`'s vertical components. The specific structure seems mapped based on `EraseColor`.

**Strategy:**

1.  Verify the properties (color, location) of the `TargetPair` and `OriginalShape` in each input using code execution.
2.  Verify the properties (color, horizontal bar location, vertical bar locations and heights) of the `NewShape` in each output using code execution.
3.  Establish the precise mapping between the `EraseColor` (color of the `OriginalShape`) and the structure (columns and relative height) of the `NewShape`'s vertical bars, centered vertically around the `TargetRow`.
4.  Update the YAML facts and Natural Language Program based on this revised understanding.

## Metrics Gathering

Let's confirm the properties identified manually.

**Example 1:**
Input: Border=9(maroon), Pair=7(orange) at (9,1), (9,18). OriginalH=6(magenta) with vertical bars at cols 2, 4.
Output: Border=9(maroon), NewH=7(orange). Horizontal bar at row 9, cols 1-18. Vertical bars at cols 13, 15, rows 8-11 (TargetRow=9, offsets -1 to +2).
Mapping Check: OriginalH color 6 (magenta) maps to vertical structure {cols: (13, 15), rows: (-1, 2)}. *Matches.*

**Example 2:**
Input: Border=7(orange), Pair=6(magenta) at (13,1), (13,18). OriginalH=1(blue) with vertical bars at cols 14, 16.
Output: Border=7(orange), NewH=6(magenta). Horizontal bar at row 13, cols 1-18. Vertical bars at cols 2, 4, rows 11-16 (TargetRow=13, offsets -2 to +3).
Mapping Check: OriginalH color 1 (blue) maps to vertical structure {cols: (2, 4), rows: (-2, 3)}. *Matches.*

**Example 3:**
Input: Border=5(gray), Pair=2(red) at (15,1), (15,18). OriginalH=7(orange) with vertical bars at cols 13, 15.
Output: Border=5(gray), NewH=2(red). Horizontal bar at row 15, cols 1-18. Vertical bars at cols 6, 8, rows 13-17 (TargetRow=15, offsets -2 to +2).
Mapping Check: OriginalH color 7 (orange) maps to vertical structure {cols: (6, 8), rows: (-2, 2)}. *Matches.*

**Example 4:**
Input: Border=2(red), Pair=1(blue) at (3,1), (3,18). OriginalH=3(green) with vertical bars at cols 4, 6.
Output: Border=2(red), NewH=1(blue). Horizontal bar at row 3, cols 1-18. Vertical bars at cols 14, 16, rows 2-4 (TargetRow=3, offsets -1 to +1).
Mapping Check: OriginalH color 3 (green) maps to vertical structure {cols: (14, 16), rows: (-1, 1)}. *Matches.*

The manual analysis and mapping appear correct and consistent across all examples.

## YAML Facts


```yaml
task_context:
  grid_size: 20x20 (constant)
  background_color: white (0)
  border:
    present: true
    thickness: 1 pixel
    color: variable, preserved in output
objects_input:
  - type: target_pixel_pair
    description: Two pixels of the same color, located on the same row, symmetrically placed near but not touching the vertical borders.
    count: 1 (pair)
    properties:
      color: TargetColor (variable: orange, magenta, red, blue)
      row: TargetRow (variable)
      columns: [Col1, Col2] (typically 1 and width-2)
    role: Determines the color and horizontal component of the output shape.
  - type: original_shape
    description: An 'H' shape or similar structure composed of a single color, distinct from TargetColor and border color.
    count: 1
    properties:
      color: EraseColor (variable: magenta, blue, orange, green)
      location: occupies a distinct area within the border.
    role: Determines the vertical structure of the output shape and is erased.
objects_output:
  - type: new_h_shape
    description: An 'H'-like shape constructed based on properties derived from both input objects.
    properties:
      color: TargetColor (from target_pixel_pair)
      horizontal_bar:
        row: TargetRow (from target_pixel_pair)
        columns: Col1 to Col2 (from target_pixel_pair)
      vertical_bars:
        columns: [VCol1, VCol2] (determined by EraseColor of original_shape)
        rows: TargetRow + MinOffset to TargetRow + MaxOffset (range [MinOffset, MaxOffset] determined by EraseColor of original_shape)
actions:
  - action: preserve_border
    description: The border pixels from the input are copied directly to the output.
  - action: identify_objects
    description: Locate the target_pixel_pair and the original_shape in the input grid's inner area. Determine their respective colors (TargetColor, EraseColor) and the location parameters (TargetRow, Col1, Col2).
  - action: erase_original_shape
    description: In the output grid (initialized as a copy of the input), change all pixels matching the EraseColor to the background color (white, 0).
  - action: draw_new_h_shape
    description: Draw the new_h_shape onto the output grid using TargetColor.
    details:
      - Map the EraseColor to its corresponding vertical structure {Columns: (VCol1, VCol2), Relative Height Range: (MinOffset, MaxOffset)}.
        - Magenta (6) -> {Cols: (13, 15), Rows: (-1, 2)}
        - Blue (1) -> {Cols: (2, 4), Rows: (-2, 3)}
        - Orange (7) -> {Cols: (6, 8), Rows: (-2, 2)}
        - Green (3) -> {Cols: (14, 16), Rows: (-1, 1)}
      - Draw the horizontal bar at TargetRow from Col1 to Col2.
      - Draw the first vertical bar at column VCol1, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset.
      - Draw the second vertical bar at column VCol2, spanning rows TargetRow + MinOffset to TargetRow + MaxOffset.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the color of the border pixels (`BorderColor`).
3.  Scan the inner area of the input grid (excluding the border) to find two pixels that:
    *   Have the same color (`TargetColor`).
    *   Are not the background color (white, 0).
    *   Are located on the same row (`TargetRow`).
    *   Record their column indices (`Col1` and `Col2`, with `Col1 < Col2`).
4.  Identify the color (`EraseColor`) of the other non-background, non-border object within the inner area of the input grid.
5.  Iterate through the inner area of the output grid. If a pixel's color is `EraseColor`, change it to the background color (white, 0).
6.  Determine the structure for the new vertical bars based on the `EraseColor`:
    *   If `EraseColor` is Magenta (6), set `VCol1=13`, `VCol2=15`, `MinOffset=-1`, `MaxOffset=2`.
    *   If `EraseColor` is Blue (1), set `VCol1=2`, `VCol2=4`, `MinOffset=-2`, `MaxOffset=3`.
    *   If `EraseColor` is Orange (7), set `VCol1=6`, `VCol2=8`, `MinOffset=-2`, `MaxOffset=2`.
    *   If `EraseColor` is Green (3), set `VCol1=14`, `VCol2=16`, `MinOffset=-1`, `MaxOffset=1`.
7.  Draw the new 'H' shape onto the output grid using `TargetColor`:
    *   Draw a horizontal line on `TargetRow` from `Col1` to `Col2` inclusive.
    *   Draw a vertical line at column `VCol1`, covering rows `TargetRow + MinOffset` to `TargetRow + MaxOffset` inclusive.
    *   Draw a vertical line at column `VCol2`, covering rows `TargetRow + MinOffset` to `TargetRow + MaxOffset` inclusive.
8.  Return the modified output grid.
