
## train_1

**input:**
```
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
```


## train_2

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7
```


## train_3

**input:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


**output:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 5
5 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


## train_4

**input:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 3 3 3 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 2
2 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


**output:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```

Okay, let's break down this task.

## Perception

1.  **Grid Structure:** Each input and output grid is 20x20.
2.  **Border:** All grids have a single-pixel border of a specific color (maroon, orange, gray, red in the examples). This border remains unchanged in the output.
3.  **Background:** The area inside the border is predominantly white (0).
4.  **Input Objects:** Inside the border, each input grid contains two key object types:
    *   An 'H' shape composed of a single color (magenta, blue, orange, green in the examples). The 'H' shape appears to be consistently formed by two 3-pixel vertical segments separated by one white pixel, connected by a single pixel horizontally in the middle row.
    *   Two isolated pixels of another identical color (orange, magenta, red, blue in the examples). These two pixels are always located on the same horizontal row, positioned symmetrically relative to the center, often near the border but not touching it.
5.  **Output Objects:** The output grid retains the border. The original 'H' shape from the input is removed (replaced with white). A *new* 'H' shape is drawn, using the color and row/column positions of the two isolated pixels from the input.
6.  **Transformation Logic:** The core transformation involves locating the pair of isolated, identically colored pixels on the same row. Their color determines the color of the new 'H' shape. Their row determines the row of the horizontal bar of the new 'H'. Their columns determine the start and end columns of the horizontal bar and the columns for the vertical bars. The original 'H' shape is erased. The new 'H' shape consists of a horizontal bar connecting the two identified pixel locations and two 3-pixel high vertical bars centered on the horizontal bar at those same column locations.

## Facts


```yaml
task_context:
  grid_size: 20x20 (constant)
  background_color: white (0)
  border:
    present: true
    thickness: 1 pixel
    color: variable (maroon, orange, gray, red), preserved in output
objects:
  - type: existing_h_shape
    description: An 'H' shape formed by two 3-pixel vertical segments separated by one pixel, connected by a single horizontal pixel in the middle row.
    color: variable (magenta, blue, orange, green)
    action: removed (pixels changed to white) in the output.
    count_per_input: 1
  - type: isolated_pixel_pair
    description: Two pixels of the same color, located on the same row, symmetrically placed.
    color: variable (orange, magenta, red, blue), different from existing_h_shape color.
    count_per_input: 1 (pair)
    role: determines the properties of the new_h_shape.
    properties:
      color: C
      row: R
      columns: [C1, C2] (where C1 < C2)
  - type: new_h_shape
    description: An 'H' shape constructed based on the isolated_pixel_pair.
    location: created in the output grid.
    color: C (from isolated_pixel_pair)
    structure:
      horizontal_bar: row R, from column C1 to C2.
      left_vertical_bar: column C1, rows R-1, R, R+1.
      right_vertical_bar: column C2, rows R-1, R, R+1.
relationships:
  - isolated_pixel_pair -> new_h_shape (determines color and position)
  - existing_h_shape -> removal (erased in output)
  - border -> preservation (unchanged in output)
```


## Natural Language Program

1.  Identify the grid's border; its color and position remain unchanged in the output.
2.  Scan the input grid (excluding the border) to find two pixels that:
    *   Have the same color (let this color be `TargetColor`).
    *   Are not the background color (white).
    *   Are located on the same row (let this row be `TargetRow`).
    *   Record their column indices (let them be `Col1` and `Col2`, with `Col1 < Col2`).
3.  Identify the pixels belonging to the pre-existing 'H' shape object (which will have a different color than `TargetColor`).
4.  Create the output grid by copying the input grid.
5.  In the output grid, change all pixels belonging to the pre-existing 'H' shape (identified in step 3) to the background color (white, 0).
6.  In the output grid, draw the new 'H' shape using `TargetColor`:
    *   Draw a horizontal line on `TargetRow` from `Col1` to `Col2` inclusive.
    *   Draw a vertical line at `Col1`, covering rows `TargetRow - 1`, `TargetRow`, and `TargetRow + 1`.
    *   Draw a vertical line at `Col2`, covering rows `TargetRow - 1`, `TargetRow`, and `TargetRow + 1`.
```python
import numpy as np
from collections import defaultdict

"""
Transformation Rule:
1. Identify the grid's border; its color and position remain unchanged.
2. Scan the input grid (excluding the border) to find two pixels that:
    * Have the same color (TargetColor).
    * Are not the background color (white, 0).
    * Are located on the same row (TargetRow).
    * Record their column indices (Col1 and Col2, with Col1 < Col2).
3. Identify the pixels belonging to the pre-existing 'H' shape object (which will have a different color than TargetColor).
4. Create the output grid by copying the input grid.
5. In the output grid, change all pixels belonging to the pre-existing 'H' shape to the background color (white, 0).
6. In the output grid, draw the new 'H' shape using TargetColor:
    * Draw a horizontal line on TargetRow from Col1 to Col2 inclusive.
    * Draw a vertical line at Col1, covering rows TargetRow - 1, TargetRow, and TargetRow + 1.
    * Draw a vertical line at Col2, covering rows TargetRow - 1, TargetRow, and TargetRow + 1.
"""

def find_objects(grid):
    """Finds contiguous or separated objects based on color."""
    height, width = grid.shape
    objects = defaultdict(list)
    # Iterate through the grid, excluding the border
    # Assuming border is 1 pixel thick
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            color = grid[r, c]
            if color != 0: # Ignore background
                objects[color].append((r, c))
    return objects

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Finds a pair of isolated pixels and an 'H' shape, erases the old 'H',
    and draws a new 'H' based on the isolated pair's properties.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. & 2. Find objects and identify the isolated pair and existing H
    objects = find_objects(input_grid_np)

    target_color = -1
    target_row = -1
    col1 = -1
    col2 = -1
    existing_h_color = -1
    existing_h_pixels = []

    for color, pixels in objects.items():
        if len(pixels) == 2:
            # Potential isolated pair
            p1_row, p1_col = pixels[0]
            p2_row, p2_col = pixels[1]
            if p1_row == p2_row: # Check if they are on the same row
                target_color = color
                target_row = p1_row
                col1 = min(p1_col, p2_col)
                col2 = max(p1_col, p2_col)
        elif len(pixels) > 2:
             # Assume this is the existing H shape
             existing_h_color = color
             existing_h_pixels = pixels
        # Handle cases where more than two types of objects are found if necessary

    # Check if we found the required objects
    if target_color == -1 or existing_h_color == -1:
        # Raise an error or return input if pattern not found
        # For now, let's assume the pattern always exists based on examples
        print("Warning: Could not identify both the pixel pair and the existing H shape.")
        # Depending on strictness, might return input or raise error.
        # Let's proceed assuming they were found for the examples.


    # 5. Erase the existing 'H' shape
    for r, c in existing_h_pixels:
         # Check bounds just in case, although H should be within borders
         if 0 <= r < height and 0 <= c < width:
              output_grid[r, c] = 0 # Set to background color

    # 6. Draw the new 'H' shape
    if target_color != -1:
        # Draw horizontal bar
        for c in range(col1, col2 + 1):
             if 0 <= target_row < height and 0 <= c < width:
                  output_grid[target_row, c] = target_color

        # Draw left vertical bar (3 pixels high)
        for r_offset in [-1, 0, 1]:
             r = target_row + r_offset
             if 0 <= r < height and 0 <= col1 < width:
                  output_grid[r, col1] = target_color

        # Draw right vertical bar (3 pixels high)
        for r_offset in [-1, 0, 1]:
             r = target_row + r_offset
             if 0 <= r < height and 0 <= col2 < width:
                  output_grid[r, col2] = target_color

    return output_grid.tolist()
```
