{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef find_bounding_box(grid, target_color):\n    \"\"\"\n    Finds the minimum bounding box coordinates for a target color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find the bounding box for.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) or None if target_color not found.\n    \"\"\"\n    rows, cols = np.where(grid == target_color)\n    if rows.size == 0:\n        return None  # Target color not found\n    min_row = np.min(rows)\n    max_row = np.max(rows)\n    min_col = np.min(cols)\n    max_col = np.max(cols)\n    return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts the minimal bounding box containing all pixels of the non-background color.\n\n    1. Identify the two colors present in the input grid.\n    2. Determine the background color (most frequent) and object color (less frequent).\n    3. Find the locations (row, column) of all pixels with the object color.\n    4. Calculate the minimum and maximum row and column indices (bounding box) for the object pixels.\n    5. Extract the subgrid defined by the bounding box from the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # Find unique colors and their counts\n    unique_colors, counts = np.unique(grid, return_counts=True)\n\n    if len(unique_colors) == 1:\n        # If only one color exists, maybe return the whole grid or an empty one?\n        # Based on examples, there are always at least two. Let's assume this.\n        # If the single color is the 'object' color somehow, the bounding box is the whole grid.\n        # If it's background, maybe return empty? Let's return the original grid for now.\n        # Or perhaps, treat the single color as the 'object' and return the full grid.\n         return input_grid # Or potentially an empty grid or handle as an error\n\n    if len(unique_colors) > 2:\n         # Find the most frequent color (background)\n        background_color = unique_colors[np.argmax(counts)]\n        # Find the object color(s) - assume the single least frequent? Or all non-background?\n        # The prompt implies a single object color. Let's find the least frequent.\n        object_color = unique_colors[np.argmin(counts)]\n        # This might fail if there are multiple non-background colors with the same count.\n        # Let's refine: Find the *second* most frequent, or simply the one that isn't the background.\n        counts_dict = {color: count for color, count in zip(unique_colors, counts)}\n        background_color = max(counts_dict, key=counts_dict.get)\n        # Assume any color that is not the background is the object color.\n        # If there are multiple, the problem description is slightly ambiguous.\n        # The examples only show one non-background color.\n        object_colors = [c for c in unique_colors if c != background_color]\n        if len(object_colors) != 1:\n             # If more than one non-background color, we need a clearer rule.\n             # For now, let's pick the first one found. Or perhaps the least frequent non-bg?\n             # Let's stick to the assumption of one object color based on examples.\n             # Re-evaluating: Maybe the background is *always* the most frequent,\n             # and *all* other colors contribute to the bounding box calculation?\n             # Let's try that.\n            rows, cols = np.where(grid != background_color)\n            if rows.size == 0:\n                 return [] # No object pixels found\n            min_row = np.min(rows)\n            max_row = np.max(rows)\n            min_col = np.min(cols)\n            max_col = np.max(cols)\n\n        else:\n             object_color = object_colors[0]\n             # Find bounding box for the single object color\n             bbox = find_bounding_box(grid, object_color)\n             if bbox is None:\n                 return [] # Should not happen if object_color exists\n             min_row, max_row, min_col, max_col = bbox\n\n    elif len(unique_colors) == 2:\n        # Identify background (most frequent) and object (least frequent) colors\n        if counts[0] > counts[1]:\n            background_color = unique_colors[0]\n            object_color = unique_colors[1]\n        else:\n            background_color = unique_colors[1]\n            object_color = unique_colors[0]\n            \n        # Find the bounding box coordinates for the object color\n        bbox = find_bounding_box(grid, object_color)\n        if bbox is None:\n            # This case implies the grid only had background color, handled above.\n             return []\n        min_row, max_row, min_col, max_col = bbox\n\n    # Extract the subgrid using the bounding box coordinates\n    # Slicing is inclusive of the start index and exclusive of the end index, so add 1 to max values\n    output_grid_np = grid[min_row:max_row + 1, min_col:max_col + 1]\n\n    # Convert the resulting NumPy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5716,
    "candidates_token_count": 1350,
    "total_token_count": 7066,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.092567,
  "retries": 1
}