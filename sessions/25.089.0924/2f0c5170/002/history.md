
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 3 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 4 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 4 4 4 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 3 4 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 4 4 4 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0
0 0 4 4 4 0 0 0 0
0 0 3 4 0 0 0 0 0
0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 0 0 0 2 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 4 4 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 4 4 2 4 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 4 4 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 4 4 0
0 4 4 2 4
0 0 4 4 0
0 0 0 0 0
0 0 0 0 0
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 4 0 0 8 8 8 8 8 8 8 8 8
8 8 0 0 4 4 4 0 0 8 8 8 8 8 8 8 8 8
8 8 0 4 4 1 4 4 0 8 8 8 8 8 8 8 8 8
8 8 0 0 4 4 0 0 0 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 1 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0 0 0
0 0 0 0 0 4 0
0 0 0 4 4 4 0
0 0 4 4 1 4 4
0 0 0 4 4 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of Elements:**

1.  **Input Grid Structure:** The input grids are relatively large and predominantly filled with an azure (8) background color.
2.  **Framed Objects:** Embedded within the azure background are distinct rectangular regions. These regions are characterized by having a border composed entirely of white (0) pixels.
3.  **Internal Patterns:** Inside these white-bordered frames, there are smaller patterns composed of various colors (green, yellow, red, blue). The space within the frame, not occupied by the pattern pixels, is also white (0).
4.  **Multiple Objects:** Some input grids contain more than one such framed pattern (e.g., train\_1, train\_2, train\_3).
5.  **Output Grid Structure:** The output grids are smaller than the input grids. They consist of one of the patterns found within a white frame in the input, placed on a white (0) background.
6.  **Selection Criteria:** The key transformation seems to involve selecting *one* specific pattern from the potentially multiple patterns present in the input. Comparing the patterns within the frames in each example reveals a selection logic:
    *   In train\_1, the top-left pattern has only green (1 unique color). The bottom-right pattern has green and yellow (2 unique colors). The output is the bottom-right pattern.
    *   In train\_2, the top-right pattern has only red (1 unique color). The bottom-left pattern has red and yellow (2 unique colors). The output is the bottom-left pattern.
    *   In train\_3, the top-left pattern has yellow and blue (2 unique colors). The bottom-right pattern has only blue (1 unique color). The output is the top-left pattern.
    *   This suggests the selection criterion is based on choosing the pattern with the greatest number of *unique* non-white colors.

**YAML Facts:**


```yaml
Description: The task involves identifying distinct patterns enclosed within white borders in a larger grid and selecting one specific pattern based on its color diversity to form the output.

Input Grid:
  - type: grid
  - background_color: azure (8)
  - contains:
    - object: Frame
      - border_color: white (0)
      - shape: rectangle
      - encloses:
        - object: Pattern
          - composed_of: various colors (excluding azure and white)
          - background_within_frame: white (0)
    - properties: May contain multiple 'Frame' objects.

Output Grid:
  - type: grid
  - background_color: white (0)
  - content: A single 'Pattern' object extracted from the input grid.
  - size: Determined by the dimensions of the selected 'Pattern' content (excluding the white frame).

Transformation:
  - action: identify_frames
    - description: Locate all rectangular areas fully bordered by white (0) pixels.
  - action: extract_patterns
    - description: For each frame, extract the content (pixels inside the white border).
  - action: analyze_patterns
    - description: For each extracted pattern, count the number of unique non-white colors.
  - action: select_pattern
    - criteria: Choose the pattern with the maximum count of unique non-white colors.
  - action: create_output
    - description: Place the selected pattern onto a white (0) background grid matching the pattern's dimensions.

Relationships:
  - The output grid's content is a sub-grid of the input grid, specifically the content of one of the identified frames.
  - The selection of which pattern to output depends on a comparative property (color diversity) among all identified patterns in the input.
```


**Natural Language Program:**

1.  Identify all rectangular regions within the input grid that are completely enclosed by a border of white (0) pixels. These regions contain patterns.
2.  For each identified region, isolate the pattern contained strictly within the white border (ignore the border pixels themselves).
3.  Count the number of distinct colors present within each isolated pattern, excluding the white (0) color.
4.  Determine which pattern has the highest count of unique non-white colors.
5.  Construct the output grid by taking only the pixels corresponding to this selected pattern (the content inside its white border) and placing them onto a new grid filled entirely with white (0). The dimensions of this output grid should exactly match the dimensions of the selected pattern's content.
```python
import numpy as np
from collections import deque

"""
Identify all rectangular regions ('patterns') enclosed entirely by a border of white (0) pixels within the input grid, which typically has an azure (8) background.
For each identified pattern, count the number of unique non-white colors present within it (excluding the white border).
Select the pattern that has the maximum number of unique non-white colors.
The output grid is the selected pattern itself, maintaining its original colors and dimensions.
"""

def find_connected_components(grid, target_colors):
    """Find connected components of specified colors using BFS."""
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] in target_colors and not visited[r, c]:
                component_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c

                while q:
                    row, col = q.popleft()
                    component_pixels.append((row, col))
                    min_r = min(min_r, row)
                    min_c = min(min_c, col)
                    max_r = max(max_r, row)
                    max_c = max(max_c, col)

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] in target_colors and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # Extract the component grid based on bounding box
                component_grid = grid[min_r:max_r+1, min_c:max_c+1]
                # Store component grid and its original bounding box
                components.append((component_grid, (min_r, min_c, max_r, max_c)))

    return components

def check_if_framed_by_white(grid, r0, c0, r1, c1):
    """Check if the area defined by the bounding box (r0, c0, r1, c1) is surrounded by white (0)."""
    rows, cols = grid.shape

    # Check top border (r = r0 - 1)
    if r0 > 0:
        for c in range(max(0, c0 - 1), min(cols, c1 + 2)):
            if grid[r0 - 1, c] != 0:
                return False
    # Check bottom border (r = r1 + 1)
    if r1 < rows - 1:
        for c in range(max(0, c0 - 1), min(cols, c1 + 2)):
             if grid[r1 + 1, c] != 0:
                return False
    # Check left border (c = c0 - 1)
    if c0 > 0:
        for r in range(max(0, r0), min(rows, r1 + 1)): # Check from r0 to r1 inclusive
             if grid[r, c0 - 1] != 0:
                return False
    # Check right border (c = c1 + 1)
    if c1 < cols - 1:
         for r in range(max(0, r0), min(rows, r1 + 1)): # Check from r0 to r1 inclusive
             if grid[r, c1 + 1] != 0:
                return False

    # Check corners explicitly (if they exist)
    if r0 > 0 and c0 > 0 and grid[r0 - 1, c0 - 1] != 0: return False
    if r0 > 0 and c1 < cols - 1 and grid[r0 - 1, c1 + 1] != 0: return False
    if r1 < rows - 1 and c0 > 0 and grid[r1 + 1, c0 - 1] != 0: return False
    if r1 < rows - 1 and c1 < cols - 1 and grid[r1 + 1, c1 + 1] != 0: return False

    return True


def count_unique_non_white(pattern_grid):
    """Counts unique colors in a grid, excluding white (0)."""
    if pattern_grid is None or pattern_grid.size == 0:
        return 0
    colors = set(pattern_grid.flatten())
    colors.discard(0) # Remove white
    return len(colors)

def transform(input_grid):
    """
    Finds patterns enclosed in white frames, selects the one with the most unique non-white colors,
    and returns that pattern as the output grid.
    """
    np_grid = np.array(input_grid, dtype=int)
    rows, cols = np_grid.shape

    # Define colors that can be part of a pattern (anything except the azure background)
    pattern_colors = set(range(10))
    pattern_colors.discard(8) # Exclude azure background color

    # Find all connected components made of potential pattern colors
    potential_components = find_connected_components(np_grid, pattern_colors)

    valid_patterns = []
    # Check each component to see if it's framed by white
    for component_grid, (r0, c0, r1, c1) in potential_components:
        # The component itself might contain white pixels, which is allowed.
        # The bounding box refers to the extent of the non-azure pixels found.
        if check_if_framed_by_white(np_grid, r0, c0, r1, c1):
            # If framed, extract the exact region within the frame
            # The frame is at r0-1, c0-1 to r1+1, c1+1
            # The content is from r0, c0 to r1, c1
            pattern_content = np_grid[r0:r1+1, c0:c1+1]
            unique_colors = count_unique_non_white(pattern_content)
            valid_patterns.append({'grid': pattern_content, 'colors': unique_colors})

    # Handle cases where no valid framed patterns are found
    if not valid_patterns:
        # Return empty or based on specific requirement (e.g., smallest possible white grid)
        # Based on examples, seems like there's always a valid pattern.
        # If not, returning a 1x1 white grid might be a safe default, but let's assume one is found.
         return [[0]] # Default fallback if no pattern found

    # Select the pattern with the maximum number of unique non-white colors
    best_pattern_info = max(valid_patterns, key=lambda item: item['colors'])
    output_grid = best_pattern_info['grid']

    # Return the selected pattern grid as a list of lists
    return output_grid.tolist()
```
