{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis program transforms an input grid based on reflection rules across a central axis.\nThe specific reflection behavior depends on the orientation and color of the axis,\nthe background color, and the color of the object being reflected.\n\nBased on the training examples:\n\nCase 1 (Vertical Blue Axis, Red Background - like train_1):\n1. Find the vertical axis (Blue, color 1) and background color (Red, color 2).\n2. Identify Azure objects (color 8) located to the left of the axis.\n3. Reflect these Azure objects across the axis, copying the Azure color to the destination.\n4. For each row containing part of an original left-side Azure object, fill the space between the original object's rightmost pixel and the axis with Blue (1).\n5. Similarly, fill the space between the axis and the reflected object's leftmost pixel with Blue (1) on those same rows.\n6. Other colors (like Yellow, color 4) remain unchanged.\n\nCase 2 (Horizontal Red Axis, Azure Background - like train_2):\n1. Find the horizontal axis (Red, color 2) and background color (Azure, color 8).\n2. Identify Green objects (color 3) located below the axis.\n3. Reflect these Green objects across the axis, copying the Green color to the destination.\n4. Identify Blue pixels (color 1) located above the axis.\n5. Reflect these Blue pixels across the axis.\n6. For each reflected Blue pixel, check the color of the corresponding destination cell in the *original input grid*.\n7. If the original destination cell was the background color (Azure, 8), change the cell in the *output grid* to Red (2). Otherwise, the destination cell keeps its value (which might have been changed by the Green reflection if they overlap, or its original value).\n\"\"\"\n\ndef find_axis(grid):\n    \"\"\"Finds the central axis (row or column).\"\"\"\n    height, width = grid.shape\n    \n    # Check for horizontal axis (row)\n    for r in range(height):\n        row = grid[r, :]\n        unique_colors = np.unique(row)\n        if len(unique_colors) == 1:\n             # Check if it spans the full width and is not the most frequent color overall (potential background)\n             counts = Counter(grid.flatten())\n             axis_color = unique_colors[0]\n             # Simple check: assume axis is not the absolute most frequent color if others exist\n             if len(counts) > 1 and counts[axis_color] == width: \n                 # Check if it's roughly central\n                 if abs(r - (height - 1) / 2) < height * 0.2: # Allow some leeway from perfect center\n                     return 'H', r, axis_color\n\n    # Check for vertical axis (column)\n    for c in range(width):\n        col = grid[:, c]\n        unique_colors = np.unique(col)\n        if len(unique_colors) == 1:\n             counts = Counter(grid.flatten())\n             axis_color = unique_colors[0]\n             if len(counts) > 1 and counts[axis_color] == height:\n                 # Check if it's roughly central\n                 if abs(c - (width - 1) / 2) < width * 0.2:\n                    return 'V', c, axis_color\n                    \n    # Fallback/Error case: No clear single-color axis found\n    # This part might need refinement based on more complex cases\n    # For now, assume an axis as described is always present based on examples\n    # Try finding the most frequent color that forms a line\n    counts = Counter(grid.flatten())\n    most_common_color, _ = counts.most_common(1)[0]\n    \n    for r in range(height):\n         row = grid[r, :]\n         if np.all(row == most_common_color):\n              # Is this the *only* row with this property? Could be ambiguous\n              # Check centrality again\n              if abs(r - (height - 1) / 2) < height * 0.2:\n                  return 'H', r, most_common_color\n\n    for c in range(width):\n         col = grid[:, c]\n         if np.all(col == most_common_color):\n              if abs(c - (width - 1) / 2) < width * 0.2:\n                 return 'V', c, most_common_color\n                 \n    # If still nothing, raise an error or return None\n    # Based on provided examples, we expect to find one.\n    # print(\"Warning: Axis not definitively found using simple checks.\")\n    # Let's try the most frequent color logic again, less strictly\n    if height > 1:\n        for r in range(height):\n            row = grid[r, :]\n            unique_colors = np.unique(row)\n            if len(unique_colors) == 1:\n                 # Simplification: First full line found is axis\n                 return 'H', r, unique_colors[0]\n    if width > 1:\n        for c in range(width):\n            col = grid[:, c]\n            unique_colors = np.unique(col)\n            if len(unique_colors) == 1:\n                 return 'V', c, unique_colors[0]\n                 \n    # Should not happen based on examples\n    raise ValueError(\"Could not find axis\")\n\n\ndef find_background_color(grid, axis_info):\n    \"\"\"Finds the most frequent color excluding the axis color.\"\"\"\n    axis_orientation, axis_index, axis_color = axis_info\n    counts = Counter(grid.flatten())\n    \n    # Remove axis color count\n    if axis_color in counts:\n        del counts[axis_color]\n        \n    if not counts:\n        # Handle grids that might only contain the axis color?\n        # Or grids where background is same as axis (unlikely in ARC?)\n        # Fallback: Assume 0 (black/white usually) if no other color exists\n         return 0 \n        \n    # Most frequent remaining color is background\n    background_color, _ = counts.most_common(1)[0]\n    return background_color\n\ndef reflect_point(r, c, axis_info, grid_shape):\n    \"\"\"Calculates reflected coordinates across the axis.\"\"\"\n    axis_orientation, axis_index, _ = axis_info\n    height, width = grid_shape\n    \n    r_refl, c_refl = r, c\n    \n    if axis_orientation == 'V':\n        c_refl = axis_index + (axis_index - c)\n    elif axis_orientation == 'H':\n        r_refl = axis_index + (axis_index - r)\n        \n    # Ensure reflected points are within bounds (although logic should handle this)\n    r_refl = max(0, min(height - 1, r_refl))\n    c_refl = max(0, min(width - 1, c_refl))\n            \n    return r_refl, c_refl\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on reflection rules derived from examples.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    output_grid = input_grid.copy()\n    height, width = input_grid.shape\n\n    # 1. Identify Axis and Background\n    try:\n        axis_info = find_axis(input_grid)\n    except ValueError as e:\n        print(f\"Error finding axis: {e}\")\n        # Return copy if axis isn't found (or handle as needed)\n        return output_grid.tolist() \n        \n    axis_orientation, axis_index, axis_color = axis_info\n    background_color = find_background_color(input_grid, axis_info)\n\n    # 2. Apply transformation rules based on axis type\n    \n    # Case 1: Vertical Axis (like train_1)\n    if axis_orientation == 'V' and axis_color == 1 and background_color == 2:\n        azure_pixels_left = []\n        affected_rows = set()\n        \n        # Find Azure (8) pixels left of the axis\n        for r in range(height):\n            for c in range(axis_index):\n                if input_grid[r, c] == 8:\n                    azure_pixels_left.append((r, c))\n                    affected_rows.add(r)\n\n        # Reflect Azure pixels\n        for r, c in azure_pixels_left:\n            r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))\n            # Check bounds just in case, though reflection logic should be okay\n            if 0 <= r_refl < height and 0 <= c_refl < width:\n                 output_grid[r_refl, c_refl] = 8\n\n        # Fill between original and reflected Azure pixels with Blue (1)\n        for r in affected_rows:\n            # Find original max col and reflected min col for this row\n            cols_orig = [c for row, c in azure_pixels_left if row == r]\n            if not cols_orig: continue # Should not happen if row is in affected_rows\n            \n            max_c_orig = max(cols_orig)\n            \n            # Reflect the original *minimum* column point to find the *minimum* reflected column\n            min_c_orig = min(cols_orig)\n            _, min_c_refl = reflect_point(r, min_c_orig, axis_info, (height,width))\n\n            # Fill left side of axis\n            if max_c_orig + 1 < axis_index:\n                output_grid[r, max_c_orig + 1 : axis_index] = 1\n            \n            # Fill right side of axis\n            if axis_index + 1 < min_c_refl:\n                 output_grid[r, axis_index + 1 : min_c_refl] = 1\n                 \n    # Case 2: Horizontal Axis (like train_2)\n    elif axis_orientation == 'H' and axis_color == 2 and background_color == 8:\n        # Reflect Green (3) from bottom to top first\n        for r in range(axis_index + 1, height):\n            for c in range(width):\n                if input_grid[r, c] == 3:\n                    r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))\n                    if 0 <= r_refl < height and 0 <= c_refl < width:\n                        output_grid[r_refl, c_refl] = 3\n                        \n        # Reflect Blue (1) from top to bottom conditionally\n        for r in range(axis_index):\n             for c in range(width):\n                 if input_grid[r, c] == 1:\n                     r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))\n                     if 0 <= r_refl < height and 0 <= c_refl < width:\n                         # Check the ORIGINAL input grid's destination color\n                         if input_grid[r_refl, c_refl] == background_color: # Background is 8\n                             output_grid[r_refl, c_refl] = 2 # Change to Red\n\n    # If axis/color combination doesn't match known cases, return copy\n    # else:\n        # print(f\"Warning: Unhandled axis/color combination: {axis_info}, bg: {background_color}\")\n        # pass # Returns the initial copy\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5628,
    "candidates_token_count": 2736,
    "total_token_count": 8364,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.500848,
  "retries": 1
}