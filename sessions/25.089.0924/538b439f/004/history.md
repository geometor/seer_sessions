
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 8 8 8 2 2 2 2 2 1 2 2 4 2 2 2 2 2 2 2
2 8 8 8 2 2 2 2 2 1 2 4 2 2 2 4 2 2 2 2
2 8 8 8 2 2 2 4 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 2 4 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 4 2 2 2 2
2 2 2 2 2 4 2 2 2 1 2 2 2 2 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 8 8 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 8 8 8 8 2 2 1 2 2 2 2 2 2 2 2 2 2
2 4 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 2 4 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 4 2 2 2 2
2 2 2 2 2 4 2 2 2 1 2 2 2 2 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 8 8 1 1 1 1 1 8 8 8 8 2 2 2 2
4 2 2 8 8 8 8 1 1 1 1 1 8 8 8 8 2 2 2 2
2 4 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8
8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8
8 8 8 8 1 8 8 1 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8
8 1 8 8 8 8 8 1 8 8 8 1 8 8 8 8 8 8
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 1
8 8 8 8 1 8 8 1 8 8 1 8 8 8 8 8 8 8
1 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 1 8
8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 8 1 8 8 1 8 3 3 3 8 1 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8
1 8 8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 1 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 1 8
8 2 2 8 8 8 8 8 8 2 2 2 8 1 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 8 8 8 8 1 8
8 2 2 8 1 8 8 1 8 2 2 2 8 8 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 1 8 8 8 8 8
8 2 2 8 8 8 8 1 8 2 2 2 8 8 8 8 8 8
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 2 2 8 1 1 8 8 8 2 2 2 8 8 8 8 8 1
8 2 2 8 1 8 8 1 8 2 2 2 8 8 8 8 8 8
1 2 2 8 8 8 8 1 8 2 2 2 8 8 8 8 1 8
8 2 2 8 8 8 8 8 8 2 2 2 1 8 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 8 8 8 8 8 8
8 3 3 8 1 8 8 1 8 3 3 3 8 1 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8
1 8 8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 1 8 8
```

Okay, let's break down the task based on the provided examples.

**Perception**

1.  **Axis of Symmetry:** Both examples feature a prominent line that acts as an axis of symmetry.
    *   In `train_1`, it's a vertical Blue (1) line in the center (column 9).
    *   In `train_2`, it's a horizontal Red (2) line in the center (row 8).
2.  **Background Color:** There's a dominant background color in each example, distinct from the axis color.
    *   `train_1`: Red (2) is the background.
    *   `train_2`: Azure (8) is the background.
3.  **Object Colors & Shapes:** Various other colors appear, forming distinct shapes or scattered pixels ('objects').
    *   `train_1`: Azure (8) shapes and scattered Yellow (4) pixels appear on a Red (2) background, split by a Blue (1) axis.
    *   `train_2`: Blue (1) scattered pixels and Green (3) shapes appear on an Azure (8) background, split by a Red (2) axis.
4.  **Transformation Logic - Reflection:** The core transformation seems to involve reflection across the identified axis. However, the *effect* of reflection depends on the color of the object being reflected.
5.  **Reflection Effects:**
    *   **Direct Copy/Replacement:** In `train_1`, Azure (8) shapes on the left are reflected to the right, creating copies of themselves. In `train_2`, Green (3) shapes below the axis are reflected above, creating copies. The reflected copy overwrites whatever was previously at the destination coordinates.
    *   **Conditional Background Change:** In `train_2`, Blue (1) pixels above the axis are reflected below. If the destination cell in the *input* contains the background color (Azure 8), it's changed to Red (2) in the *output*. Otherwise (if the destination was already Blue, Green, or the Red axis), it remains unchanged.
    *   **Area Filling:** In `train_1`, after reflecting the Azure (8) shapes, the space *between* the original shape and its reflection is filled with Blue (1), but only on the rows occupied by the shape, and excluding the axis column itself.
    *   **Inert Objects:** In `train_1`, the Yellow (4) pixels seem unaffected by the reflection process; they remain in their original positions in the output.
6.  **Source Side:** The reflection seems unidirectional for each type of interaction.
    *   `train_1`: Reflection happens from left to right (Azure shapes on the left cause changes on the right).
    *   `train_2`: Green shapes reflect from bottom to top. Blue pixels reflect from top to bottom.

**Facts**


```yaml
task_description: Reflect objects across a central axis, with effects depending on the object's color.

grid_properties:
  axis:
    present: true
    orientation: Varies (Vertical in train_1, Horizontal in train_2)
    color: Varies (Blue 1 in train_1, Red 2 in train_2)
    location: Central column or row dividing the grid.
  background_color: Varies (Red 2 in train_1, Azure 8 in train_2) - Most frequent color excluding the axis.

object_interactions:
  - type: primary_reflection_copy
    object_color: Azure (8) # As seen in train_1
    source_side: Left # Relative to vertical axis
    action:
      - Reflect object pixels across the axis.
      - Overwrite destination cells with the object_color (Azure 8).

  - type: primary_reflection_copy # Added based on train_2 observation
    object_color: Green (3) # As seen in train_2
    source_side: Bottom # Relative to horizontal axis
    action:
      - Reflect object pixels across the axis.
      - Overwrite destination cells with the object_color (Green 3).

  - type: fill_between_reflection
    trigger_object_color: Azure (8) # As seen in train_1
    fill_color: Blue (1)
    action:
      - After primary_reflection_copy for Azure (8) objects.
      - For each row occupied by an original Azure (8) object:
        - Identify the column range of the original object in that row.
        - Identify the column range of the reflected object in that row.
        - Fill cells between the original object's right edge and the axis with fill_color (Blue 1).
        - Fill cells between the axis and the reflected object's left edge with fill_color (Blue 1).
      - Condition: Do not overwrite axis or object pixels.

  - type: secondary_reflection_conditional_background_change
    object_color: Blue (1) # As seen in train_2
    source_side: Top # Relative to horizontal axis
    target_background_color: Azure (8) # Background on the destination side
    output_color: Red (2)
    action:
      - Reflect object pixels across the axis.
      - Check the color of the destination cell in the *input* grid.
      - If the destination cell color matches target_background_color (Azure 8), change the cell in the *output* grid to output_color (Red 2).
      - Otherwise, leave the destination cell in the output grid unchanged.

  - type: inert_object
    object_color: Yellow (4) # As seen in train_1
    action: No change. Object remains in its original position.

general_behavior:
  - The axis itself remains unchanged.
  - Pixels not involved in reflection or filling remain unchanged unless overwritten by a reflection copy.
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the initial output grid.
2.  Identify the axis of symmetry: Find the single row or column that consists of only one color and spans the entire width or height of the grid. Record its orientation (horizontal/vertical), index (row/column number), and color.
3.  Identify the background color: Determine the most frequent color in the input grid, excluding the axis color.
4.  Identify all unique colors present besides the axis and background colors. These are potential object colors.
5.  *Infer interaction types based on examples (
```python
import numpy as np
from collections import Counter

"""
This program transforms an input grid based on reflection rules across a central axis.
The specific reflection behavior depends on the orientation and color of the axis,
the background color, and the color of the object being reflected.

Based on the training examples:

Case 1 (Vertical Blue Axis, Red Background - like train_1):
1. Find the vertical axis (Blue, color 1) and background color (Red, color 2).
2. Identify Azure objects (color 8) located to the left of the axis.
3. Reflect these Azure objects across the axis, copying the Azure color to the destination.
4. For each row containing part of an original left-side Azure object, fill the space between the original object's rightmost pixel and the axis with Blue (1).
5. Similarly, fill the space between the axis and the reflected object's leftmost pixel with Blue (1) on those same rows.
6. Other colors (like Yellow, color 4) remain unchanged.

Case 2 (Horizontal Red Axis, Azure Background - like train_2):
1. Find the horizontal axis (Red, color 2) and background color (Azure, color 8).
2. Identify Green objects (color 3) located below the axis.
3. Reflect these Green objects across the axis, copying the Green color to the destination.
4. Identify Blue pixels (color 1) located above the axis.
5. Reflect these Blue pixels across the axis.
6. For each reflected Blue pixel, check the color of the corresponding destination cell in the *original input grid*.
7. If the original destination cell was the background color (Azure, 8), change the cell in the *output grid* to Red (2). Otherwise, the destination cell keeps its value (which might have been changed by the Green reflection if they overlap, or its original value).
"""

def find_axis(grid):
    """Finds the central axis (row or column)."""
    height, width = grid.shape
    
    # Check for horizontal axis (row)
    for r in range(height):
        row = grid[r, :]
        unique_colors = np.unique(row)
        if len(unique_colors) == 1:
             # Check if it spans the full width and is not the most frequent color overall (potential background)
             counts = Counter(grid.flatten())
             axis_color = unique_colors[0]
             # Simple check: assume axis is not the absolute most frequent color if others exist
             if len(counts) > 1 and counts[axis_color] == width: 
                 # Check if it's roughly central
                 if abs(r - (height - 1) / 2) < height * 0.2: # Allow some leeway from perfect center
                     return 'H', r, axis_color

    # Check for vertical axis (column)
    for c in range(width):
        col = grid[:, c]
        unique_colors = np.unique(col)
        if len(unique_colors) == 1:
             counts = Counter(grid.flatten())
             axis_color = unique_colors[0]
             if len(counts) > 1 and counts[axis_color] == height:
                 # Check if it's roughly central
                 if abs(c - (width - 1) / 2) < width * 0.2:
                    return 'V', c, axis_color
                    
    # Fallback/Error case: No clear single-color axis found
    # This part might need refinement based on more complex cases
    # For now, assume an axis as described is always present based on examples
    # Try finding the most frequent color that forms a line
    counts = Counter(grid.flatten())
    most_common_color, _ = counts.most_common(1)[0]
    
    for r in range(height):
         row = grid[r, :]
         if np.all(row == most_common_color):
              # Is this the *only* row with this property? Could be ambiguous
              # Check centrality again
              if abs(r - (height - 1) / 2) < height * 0.2:
                  return 'H', r, most_common_color

    for c in range(width):
         col = grid[:, c]
         if np.all(col == most_common_color):
              if abs(c - (width - 1) / 2) < width * 0.2:
                 return 'V', c, most_common_color
                 
    # If still nothing, raise an error or return None
    # Based on provided examples, we expect to find one.
    # print("Warning: Axis not definitively found using simple checks.")
    # Let's try the most frequent color logic again, less strictly
    if height > 1:
        for r in range(height):
            row = grid[r, :]
            unique_colors = np.unique(row)
            if len(unique_colors) == 1:
                 # Simplification: First full line found is axis
                 return 'H', r, unique_colors[0]
    if width > 1:
        for c in range(width):
            col = grid[:, c]
            unique_colors = np.unique(col)
            if len(unique_colors) == 1:
                 return 'V', c, unique_colors[0]
                 
    # Should not happen based on examples
    raise ValueError("Could not find axis")


def find_background_color(grid, axis_info):
    """Finds the most frequent color excluding the axis color."""
    axis_orientation, axis_index, axis_color = axis_info
    counts = Counter(grid.flatten())
    
    # Remove axis color count
    if axis_color in counts:
        del counts[axis_color]
        
    if not counts:
        # Handle grids that might only contain the axis color?
        # Or grids where background is same as axis (unlikely in ARC?)
        # Fallback: Assume 0 (black/white usually) if no other color exists
         return 0 
        
    # Most frequent remaining color is background
    background_color, _ = counts.most_common(1)[0]
    return background_color

def reflect_point(r, c, axis_info, grid_shape):
    """Calculates reflected coordinates across the axis."""
    axis_orientation, axis_index, _ = axis_info
    height, width = grid_shape
    
    r_refl, c_refl = r, c
    
    if axis_orientation == 'V':
        c_refl = axis_index + (axis_index - c)
    elif axis_orientation == 'H':
        r_refl = axis_index + (axis_index - r)
        
    # Ensure reflected points are within bounds (although logic should handle this)
    r_refl = max(0, min(height - 1, r_refl))
    c_refl = max(0, min(width - 1, c_refl))
            
    return r_refl, c_refl

def transform(input_grid):
    """
    Transforms the input grid based on reflection rules derived from examples.
    """
    input_grid = np.array(input_grid)
    output_grid = input_grid.copy()
    height, width = input_grid.shape

    # 1. Identify Axis and Background
    try:
        axis_info = find_axis(input_grid)
    except ValueError as e:
        print(f"Error finding axis: {e}")
        # Return copy if axis isn't found (or handle as needed)
        return output_grid.tolist() 
        
    axis_orientation, axis_index, axis_color = axis_info
    background_color = find_background_color(input_grid, axis_info)

    # 2. Apply transformation rules based on axis type
    
    # Case 1: Vertical Axis (like train_1)
    if axis_orientation == 'V' and axis_color == 1 and background_color == 2:
        azure_pixels_left = []
        affected_rows = set()
        
        # Find Azure (8) pixels left of the axis
        for r in range(height):
            for c in range(axis_index):
                if input_grid[r, c] == 8:
                    azure_pixels_left.append((r, c))
                    affected_rows.add(r)

        # Reflect Azure pixels
        for r, c in azure_pixels_left:
            r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))
            # Check bounds just in case, though reflection logic should be okay
            if 0 <= r_refl < height and 0 <= c_refl < width:
                 output_grid[r_refl, c_refl] = 8

        # Fill between original and reflected Azure pixels with Blue (1)
        for r in affected_rows:
            # Find original max col and reflected min col for this row
            cols_orig = [c for row, c in azure_pixels_left if row == r]
            if not cols_orig: continue # Should not happen if row is in affected_rows
            
            max_c_orig = max(cols_orig)
            
            # Reflect the original *minimum* column point to find the *minimum* reflected column
            min_c_orig = min(cols_orig)
            _, min_c_refl = reflect_point(r, min_c_orig, axis_info, (height,width))

            # Fill left side of axis
            if max_c_orig + 1 < axis_index:
                output_grid[r, max_c_orig + 1 : axis_index] = 1
            
            # Fill right side of axis
            if axis_index + 1 < min_c_refl:
                 output_grid[r, axis_index + 1 : min_c_refl] = 1
                 
    # Case 2: Horizontal Axis (like train_2)
    elif axis_orientation == 'H' and axis_color == 2 and background_color == 8:
        # Reflect Green (3) from bottom to top first
        for r in range(axis_index + 1, height):
            for c in range(width):
                if input_grid[r, c] == 3:
                    r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))
                    if 0 <= r_refl < height and 0 <= c_refl < width:
                        output_grid[r_refl, c_refl] = 3
                        
        # Reflect Blue (1) from top to bottom conditionally
        for r in range(axis_index):
             for c in range(width):
                 if input_grid[r, c] == 1:
                     r_refl, c_refl = reflect_point(r, c, axis_info, (height, width))
                     if 0 <= r_refl < height and 0 <= c_refl < width:
                         # Check the ORIGINAL input grid's destination color
                         if input_grid[r_refl, c_refl] == background_color: # Background is 8
                             output_grid[r_refl, c_refl] = 2 # Change to Red

    # If axis/color combination doesn't match known cases, return copy
    # else:
        # print(f"Warning: Unhandled axis/color combination: {axis_info}, bg: {background_color}")
        # pass # Returns the initial copy

    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter

"""
This program transforms an input grid based on reflection rules across a central axis.
The specific reflection behavior depends on the orientation and color of the axis,
the background color, and the color of the object being reflected.

The transformation identifies a single-color central axis (either horizontal or vertical)
and the primary background color. Based on the characteristics of the axis and background,
it applies specific reflection rules:

Rule Set 1 (Detected in train_1: Vertical Blue Axis (1), Red Background (2)):
1. Identify Azure (8) pixels located to the left of the axis.
2. Reflect these Azure pixels across the axis to the right side, overwriting existing pixels with Azure (8).
3. For each row containing an original left-side Azure pixel:
   - Find the rightmost column (`max_c_orig`) of the original Azure shape in that row.
   - Find the leftmost column (`min_c_refl`) of the reflected Azure shape in that row.
   - Fill the cells between `max_c_orig` and the axis (exclusive) with Blue (1).
   - Fill the cells between the axis and `min_c_refl` (exclusive) with Blue (1).
4. All other pixels (including the axis and background) remain unchanged unless overwritten by the reflection or filling steps.

Rule Set 2 (Detected in train_2: Horizontal Red Axis (2), Azure Background (8)):
1. Identify Green (3) pixels located below the axis.
2. Reflect these Green pixels across the axis to the upper side, overwriting existing pixels with Green (3).
3. Identify Blue (1) pixels located above the axis.
4. For each Blue (1) pixel above the axis:
   - Calculate its reflected coordinates below the axis.
   - Check if the *source* Blue (1) pixel is "isolated" (has no orthogonal neighbors of the same Blue color).
   - Check if the pixel at the *reflected coordinates* in the *original input grid* is the background color (Azure 8).
   - If *both* conditions (source is isolated Blue, destination was background) are true, change the pixel at the reflected coordinates in the *output grid* to Red (2).
   - Otherwise, the reflection of the Blue pixel does not change the output grid (the destination pixel retains whatever value it had after step 2 or its original value).
5. All other pixels (including the axis and background) remain unchanged unless overwritten by the reflection steps.
"""

def find_axis(grid):
    """
    Finds the central axis (row or column) that consists of a single color
    and spans the entire grid dimension. Prioritizes non-background colors
    and centrality.
    """
    height, width = grid.shape
    counts = Counter(grid.flatten())
    
    # Determine potential background color (most frequent overall)
    potential_background = counts.most_common(1)[0][0] if counts else 0

    best_axis = None

    # Check for horizontal axis (row)
    for r in range(height):
        row = grid[r, :]
        unique_colors = np.unique(row)
        if len(unique_colors) == 1:
            axis_color = unique_colors[0]
            # Prefer non-background, full-width lines
            if counts.get(axis_color, 0) == width and axis_color != potential_background:
                centrality = abs(r - (height - 1) / 2)
                if best_axis is None or centrality < best_axis[3]:
                   best_axis = ('H', r, axis_color, centrality)
            # Consider background color axis if no other found yet or equally central
            elif counts.get(axis_color, 0) == width and axis_color == potential_background:
                 centrality = abs(r - (height - 1) / 2)
                 if best_axis is None or (best_axis[2] == potential_background and centrality < best_axis[3]):
                     best_axis = ('H', r, axis_color, centrality)


    # Check for vertical axis (column)
    for c in range(width):
        col = grid[:, c]
        unique_colors = np.unique(col)
        if len(unique_colors) == 1:
            axis_color = unique_colors[0]
            # Prefer non-background, full-height lines
            if counts.get(axis_color, 0) == height and axis_color != potential_background:
                centrality = abs(c - (width - 1) / 2)
                # Vertical axis takes precedence over horizontal if centrality is equal and non-background
                if best_axis is None or centrality < best_axis[3] or \
                   (centrality == best_axis[3] and best_axis[2] == potential_background):
                    best_axis = ('V', c, axis_color, centrality)
            # Consider background color axis if needed
            elif counts.get(axis_color, 0) == height and axis_color == potential_background:
                 centrality = abs(c - (width - 1) / 2)
                 if best_axis is None or (best_axis[2] == potential_background and centrality < best_axis[3]):
                     best_axis = ('V', c, axis_color, centrality)

    if best_axis:
        return best_axis[0], best_axis[1], best_axis[2] # orientation, index, color

    # Fallback: If no clear non-background or central axis, try first full line found
    for r in range(height):
        row = grid[r, :]
        unique_colors = np.unique(row)
        if len(unique_colors) == 1 and counts.get(unique_colors[0], 0) == width:
            return 'H', r, unique_colors[0]
    for c in range(width):
        col = grid[:, c]
        unique_colors = np.unique(col)
        if len(unique_colors) == 1 and counts.get(unique_colors[0], 0) == height:
            return 'V', c, unique_colors[0]

    raise ValueError("Could not find a suitable axis")


def find_background_color(grid, axis_info):
    """Finds the most frequent color excluding the axis color."""
    _, _, axis_color = axis_info
    counts = Counter(grid.flatten())

    # Remove axis color count
    if axis_color in counts:
        del counts[axis_color]

    if not counts:
        # If only axis color exists, return a default (e.g., 0)
        return 0

    # Most frequent remaining color is background
    background_color, _ = counts.most_common(1)[0]
    return background_color

def reflect_point(r, c, axis_info, grid_shape):
    """Calculates reflected coordinates across the axis."""
    axis_orientation, axis_index, _ = axis_info
    height, width = grid_shape

    r_refl, c_refl = r, c

    if axis_orientation == 'V':
        # Reflect horizontally across a vertical axis
        c_refl = axis_index + (axis_index - c)
    elif axis_orientation == 'H':
        # Reflect vertically across a horizontal axis
        r_refl = axis_index + (axis_index - r)

    # Ensure reflected points are within bounds
    # This shouldn't strictly be necessary if source points are correctly chosen,
    # but good for safety.
    if not (0 <= r_refl < height and 0 <= c_refl < width):
        return None # Indicate reflection is out of bounds

    return r_refl, c_refl

def is_isolated(grid, r, c, color):
    """Checks if a pixel at (r, c) has no orthogonal neighbors of the same color."""
    height, width = grid.shape
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] == color:
            return False
    return True

def transform(input_grid):
    """
    Transforms the input grid based on reflection rules derived from examples.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = input_grid_np.copy()
    height, width = input_grid_np.shape

    # 1. Identify Axis and Background
    try:
        axis_info = find_axis(input_grid_np)
    except ValueError as e:
        # If no axis found, return the original grid
        # print(f"Error finding axis: {e}. Returning original grid.")
        return input_grid # Return original list format

    axis_orientation, axis_index, axis_color = axis_info
    background_color = find_background_color(input_grid_np, axis_info)

    # 2. Apply transformation rules based on axis type and colors

    # Rule Set 1: Vertical Blue(1) Axis, Red(2) Background
    if axis_orientation == 'V' and axis_color == 1 and background_color == 2:
        azure_pixels_left = {} # Store as dict {row: [cols]}
        
        # Find Azure (8) pixels left of the axis
        for r in range(height):
            for c in range(axis_index):
                if input_grid_np[r, c] == 8:
                    if r not in azure_pixels_left:
                        azure_pixels_left[r] = []
                    azure_pixels_left[r].append(c)

        # Reflect Azure pixels and fill
        for r in azure_pixels_left:
            cols_orig = sorted(azure_pixels_left[r])
            if not cols_orig: continue

            min_c_orig = cols_orig[0]
            max_c_orig = cols_orig[-1]

            # Calculate reflection bounds for this row
            refl_coords = [reflect_point(r, c, axis_info, (height, width)) for c in cols_orig]
            refl_coords = [coord for coord in refl_coords if coord is not None] # Filter out out-of-bounds reflections
            
            if not refl_coords: continue

            reflected_cols = sorted([c_refl for _, c_refl in refl_coords])
            min_c_refl = reflected_cols[0]
            max_c_refl = reflected_cols[-1] # Not strictly needed but good for clarity

            # Perform reflection by setting pixel colors
            for r_refl, c_refl in refl_coords:
                 output_grid[r_refl, c_refl] = 8

            # Fill left side of axis (between object and axis)
            fill_start_c_left = max_c_orig + 1
            fill_end_c_left = axis_index
            if fill_start_c_left < fill_end_c_left:
                output_grid[r, fill_start_c_left : fill_end_c_left] = 1

            # Fill right side of axis (between axis and reflected object)
            fill_start_c_right = axis_index + 1
            fill_end_c_right = min_c_refl
            if fill_start_c_right < fill_end_c_right:
                 output_grid[r, fill_start_c_right : fill_end_c_right] = 1

    # Rule Set 2: Horizontal Red(2) Axis, Azure(8) Background
    elif axis_orientation == 'H' and axis_color == 2 and background_color == 8:
        # Reflect Green (3) from bottom to top first
        for r in range(axis_index + 1, height):
            for c in range(width):
                if input_grid_np[r, c] == 3:
                    refl_coord = reflect_point(r, c, axis_info, (height, width))
                    if refl_coord:
                        r_refl, c_refl = refl_coord
                        output_grid[r_refl, c_refl] = 3

        # Conditionally reflect Blue (1) from top to bottom
        for r in range(axis_index):
             for c in range(width):
                 if input_grid_np[r, c] == 1:
                     refl_coord = reflect_point(r, c, axis_info, (height, width))
                     if refl_coord:
                         r_refl, c_refl = refl_coord
                         # Check conditions: source is isolated AND original destination is background
                         source_is_isolated = is_isolated(input_grid_np, r, c, 1)
                         dest_is_background = (input_grid_np[r_refl, c_refl] == background_color)

                         if source_is_isolated and dest_is_background:
                             output_grid[r_refl, c_refl] = 2 # Change to Red

    # If axis/color combination doesn't match known cases, the output_grid remains a copy of the input

    return output_grid.tolist()
```
