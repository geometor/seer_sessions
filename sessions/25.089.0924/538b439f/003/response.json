{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis program transforms an input grid based on reflection rules across a central axis.\nThe specific reflection behavior depends on the orientation and color of the axis,\nthe background color, and the color of the object being reflected.\n\nThe transformation identifies a single-color central axis (either horizontal or vertical)\nand the primary background color. Based on the characteristics of the axis and background,\nit applies specific reflection rules:\n\nRule Set 1 (Detected in train_1: Vertical Blue Axis (1), Red Background (2)):\n1. Identify Azure (8) pixels located to the left of the axis.\n2. Reflect these Azure pixels across the axis to the right side, overwriting existing pixels with Azure (8).\n3. For each row containing an original left-side Azure pixel:\n   - Find the rightmost column (`max_c_orig`) of the original Azure shape in that row.\n   - Find the leftmost column (`min_c_refl`) of the reflected Azure shape in that row.\n   - Fill the cells between `max_c_orig` and the axis (exclusive) with Blue (1).\n   - Fill the cells between the axis and `min_c_refl` (exclusive) with Blue (1).\n4. All other pixels (including the axis and background) remain unchanged unless overwritten by the reflection or filling steps.\n\nRule Set 2 (Detected in train_2: Horizontal Red Axis (2), Azure Background (8)):\n1. Identify Green (3) pixels located below the axis.\n2. Reflect these Green pixels across the axis to the upper side, overwriting existing pixels with Green (3).\n3. Identify Blue (1) pixels located above the axis.\n4. For each Blue (1) pixel above the axis:\n   - Calculate its reflected coordinates below the axis.\n   - Check if the *source* Blue (1) pixel is \"isolated\" (has no orthogonal neighbors of the same Blue color).\n   - Check if the pixel at the *reflected coordinates* in the *original input grid* is the background color (Azure 8).\n   - If *both* conditions (source is isolated Blue, destination was background) are true, change the pixel at the reflected coordinates in the *output grid* to Red (2).\n   - Otherwise, the reflection of the Blue pixel does not change the output grid (the destination pixel retains whatever value it had after step 2 or its original value).\n5. All other pixels (including the axis and background) remain unchanged unless overwritten by the reflection steps.\n\"\"\"\n\ndef find_axis(grid):\n    \"\"\"\n    Finds the central axis (row or column) that consists of a single color\n    and spans the entire grid dimension. Prioritizes non-background colors\n    and centrality.\n    \"\"\"\n    height, width = grid.shape\n    counts = Counter(grid.flatten())\n    \n    # Determine potential background color (most frequent overall)\n    potential_background = counts.most_common(1)[0][0] if counts else 0\n\n    best_axis = None\n\n    # Check for horizontal axis (row)\n    for r in range(height):\n        row = grid[r, :]\n        unique_colors = np.unique(row)\n        if len(unique_colors) == 1:\n            axis_color = unique_colors[0]\n            # Prefer non-background, full-width lines\n            if counts.get(axis_color, 0) == width and axis_color != potential_background:\n                centrality = abs(r - (height - 1) / 2)\n                if best_axis is None or centrality < best_axis[3]:\n                   best_axis = ('H', r, axis_color, centrality)\n            # Consider background color axis if no other found yet or equally central\n            elif counts.get(axis_color, 0) == width and axis_color == potential_background:\n                 centrality = abs(r - (height - 1) / 2)\n                 if best_axis is None or (best_axis[2] == potential_background and centrality < best_axis[3]):\n                     best_axis = ('H', r, axis_color, centrality)\n\n\n    # Check for vertical axis (column)\n    for c in range(width):\n        col = grid[:, c]\n        unique_colors = np.unique(col)\n        if len(unique_colors) == 1:\n            axis_color = unique_colors[0]\n            # Prefer non-background, full-height lines\n            if counts.get(axis_color, 0) == height and axis_color != potential_background:\n                centrality = abs(c - (width - 1) / 2)\n                # Vertical axis takes precedence over horizontal if centrality is equal and non-background\n                if best_axis is None or centrality < best_axis[3] or \\\n                   (centrality == best_axis[3] and best_axis[2] == potential_background):\n                    best_axis = ('V', c, axis_color, centrality)\n            # Consider background color axis if needed\n            elif counts.get(axis_color, 0) == height and axis_color == potential_background:\n                 centrality = abs(c - (width - 1) / 2)\n                 if best_axis is None or (best_axis[2] == potential_background and centrality < best_axis[3]):\n                     best_axis = ('V', c, axis_color, centrality)\n\n    if best_axis:\n        return best_axis[0], best_axis[1], best_axis[2] # orientation, index, color\n\n    # Fallback: If no clear non-background or central axis, try first full line found\n    for r in range(height):\n        row = grid[r, :]\n        unique_colors = np.unique(row)\n        if len(unique_colors) == 1 and counts.get(unique_colors[0], 0) == width:\n            return 'H', r, unique_colors[0]\n    for c in range(width):\n        col = grid[:, c]\n        unique_colors = np.unique(col)\n        if len(unique_colors) == 1 and counts.get(unique_colors[0], 0) == height:\n            return 'V', c, unique_colors[0]\n\n    raise ValueError(\"Could not find a suitable axis\")\n\n\ndef find_background_color(grid, axis_info):\n    \"\"\"Finds the most frequent color excluding the axis color.\"\"\"\n    _, _, axis_color = axis_info\n    counts = Counter(grid.flatten())\n\n    # Remove axis color count\n    if axis_color in counts:\n        del counts[axis_color]\n\n    if not counts:\n        # If only axis color exists, return a default (e.g., 0)\n        return 0\n\n    # Most frequent remaining color is background\n    background_color, _ = counts.most_common(1)[0]\n    return background_color\n\ndef reflect_point(r, c, axis_info, grid_shape):\n    \"\"\"Calculates reflected coordinates across the axis.\"\"\"\n    axis_orientation, axis_index, _ = axis_info\n    height, width = grid_shape\n\n    r_refl, c_refl = r, c\n\n    if axis_orientation == 'V':\n        # Reflect horizontally across a vertical axis\n        c_refl = axis_index + (axis_index - c)\n    elif axis_orientation == 'H':\n        # Reflect vertically across a horizontal axis\n        r_refl = axis_index + (axis_index - r)\n\n    # Ensure reflected points are within bounds\n    # This shouldn't strictly be necessary if source points are correctly chosen,\n    # but good for safety.\n    if not (0 <= r_refl < height and 0 <= c_refl < width):\n        return None # Indicate reflection is out of bounds\n\n    return r_refl, c_refl\n\ndef is_isolated(grid, r, c, color):\n    \"\"\"Checks if a pixel at (r, c) has no orthogonal neighbors of the same color.\"\"\"\n    height, width = grid.shape\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] == color:\n            return False\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on reflection rules derived from examples.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    height, width = input_grid_np.shape\n\n    # 1. Identify Axis and Background\n    try:\n        axis_info = find_axis(input_grid_np)\n    except ValueError as e:\n        # If no axis found, return the original grid\n        # print(f\"Error finding axis: {e}. Returning original grid.\")\n        return input_grid # Return original list format\n\n    axis_orientation, axis_index, axis_color = axis_info\n    background_color = find_background_color(input_grid_np, axis_info)\n\n    # 2. Apply transformation rules based on axis type and colors\n\n    # Rule Set 1: Vertical Blue(1) Axis, Red(2) Background\n    if axis_orientation == 'V' and axis_color == 1 and background_color == 2:\n        azure_pixels_left = {} # Store as dict {row: [cols]}\n        \n        # Find Azure (8) pixels left of the axis\n        for r in range(height):\n            for c in range(axis_index):\n                if input_grid_np[r, c] == 8:\n                    if r not in azure_pixels_left:\n                        azure_pixels_left[r] = []\n                    azure_pixels_left[r].append(c)\n\n        # Reflect Azure pixels and fill\n        for r in azure_pixels_left:\n            cols_orig = sorted(azure_pixels_left[r])\n            if not cols_orig: continue\n\n            min_c_orig = cols_orig[0]\n            max_c_orig = cols_orig[-1]\n\n            # Calculate reflection bounds for this row\n            refl_coords = [reflect_point(r, c, axis_info, (height, width)) for c in cols_orig]\n            refl_coords = [coord for coord in refl_coords if coord is not None] # Filter out out-of-bounds reflections\n            \n            if not refl_coords: continue\n\n            reflected_cols = sorted([c_refl for _, c_refl in refl_coords])\n            min_c_refl = reflected_cols[0]\n            max_c_refl = reflected_cols[-1] # Not strictly needed but good for clarity\n\n            # Perform reflection by setting pixel colors\n            for r_refl, c_refl in refl_coords:\n                 output_grid[r_refl, c_refl] = 8\n\n            # Fill left side of axis (between object and axis)\n            fill_start_c_left = max_c_orig + 1\n            fill_end_c_left = axis_index\n            if fill_start_c_left < fill_end_c_left:\n                output_grid[r, fill_start_c_left : fill_end_c_left] = 1\n\n            # Fill right side of axis (between axis and reflected object)\n            fill_start_c_right = axis_index + 1\n            fill_end_c_right = min_c_refl\n            if fill_start_c_right < fill_end_c_right:\n                 output_grid[r, fill_start_c_right : fill_end_c_right] = 1\n\n    # Rule Set 2: Horizontal Red(2) Axis, Azure(8) Background\n    elif axis_orientation == 'H' and axis_color == 2 and background_color == 8:\n        # Reflect Green (3) from bottom to top first\n        for r in range(axis_index + 1, height):\n            for c in range(width):\n                if input_grid_np[r, c] == 3:\n                    refl_coord = reflect_point(r, c, axis_info, (height, width))\n                    if refl_coord:\n                        r_refl, c_refl = refl_coord\n                        output_grid[r_refl, c_refl] = 3\n\n        # Conditionally reflect Blue (1) from top to bottom\n        for r in range(axis_index):\n             for c in range(width):\n                 if input_grid_np[r, c] == 1:\n                     refl_coord = reflect_point(r, c, axis_info, (height, width))\n                     if refl_coord:\n                         r_refl, c_refl = refl_coord\n                         # Check conditions: source is isolated AND original destination is background\n                         source_is_isolated = is_isolated(input_grid_np, r, c, 1)\n                         dest_is_background = (input_grid_np[r_refl, c_refl] == background_color)\n\n                         if source_is_isolated and dest_is_background:\n                             output_grid[r_refl, c_refl] = 2 # Change to Red\n\n    # If axis/color combination doesn't match known cases, the output_grid remains a copy of the input\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16319,
    "candidates_token_count": 3135,
    "total_token_count": 19454,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.314608,
  "retries": 1
}