
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 0 0 0 0 3 1 4 2 5 3 1 4 2 0 0 0 4 2 5 3 1 4 2 5 3
1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1
1 4 2 5 3 0 0 0 0 3 1 4 2 5 3 1 4 2 0 0 0 4 2 5 3 1 4 2 5 3
1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 0 0 0 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 0 0 0 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 0 0 0 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 0 0 0 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3 1 4 2 5 3
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 0 0 0 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 0 0 0 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 0 0 0 0 0 0 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 0 0 0 0 0 0 4
1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1
1 4 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 0 0 0 0 0 0 0 4 1 4
1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 0 0 0 0 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 0 0 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 0 0 0 0 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
```


## train_3

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 0 0 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 0 0 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 0 0 7 3 6 2 0 0 0 0 0 0 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 0 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 0 0 0 0 0 0 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 0 0 0 0 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 0 0 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4 7 3 6 2 5 1 4
```

*   **Perception**:
    *   The input and output grids are the same size (30x30) in all examples.
    *   The grids exhibit a clear background pattern consisting of alternating row types.
    *   Even-numbered rows (0, 2, 4, ...) consist entirely of blue (1) pixels.
    *   Odd-numbered rows (1, 3, 5, ...) consist of a horizontally repeating sequence of colors. This sequence starts with blue (1) and varies between examples.
    *   The input grids contain patches of white (0) pixels that overwrite sections of the background pattern. These patches are contiguous areas of white.
    *   The output grids are identical to the input grids, except that the white (0) patches have been replaced.
    *   The replacement color for each white pixel corresponds to the color that should exist at that position according to the underlying background pattern.
    *   The task is to identify the background pattern (specifically the sequence in the odd rows) and use it to "fill in" the white areas.

*   **Facts**:
    
```yaml
    grid_properties:
      size: 30x30 for all examples
      background_color: blue (1) - used as a base or filler
      pattern_color: white (0) - indicates areas to be modified
    
    row_types:
      - type: even_row
        index_rule: row % 2 == 0
        content: solid color
        color: blue (1)
      - type: odd_row
        index_rule: row % 2 != 0
        content: repeating_sequence
        sequence_details:
          - example: train_1
            sequence: [1, 4, 2, 5, 3] # blue, yellow, red, gray, green
            length: 5
          - example: train_2
            sequence: [1, 4]         # blue, yellow
            length: 2
          - example: train_3
            sequence: [1, 4, 7, 3, 6, 2, 5] # blue, yellow, orange, green, magenta, red, gray
            length: 7
    
    objects:
      - object: white_patch
        description: Contiguous areas of white (0) pixels in the input grid.
        location: Varies per example. Overlays the background pattern.
    
    actions:
      - action: identify_background_pattern
        actor: system
        input: input_grid
        output: definition of even_row content and odd_row repeating sequence
        details: Find an odd row without white pixels to determine the repeating sequence.
      - action: replace_white_pixels
        actor: system
        input: input_grid, background_pattern
        output: output_grid
        details: Iterate through the input grid. If a pixel is white (0), replace it with the color dictated by the background pattern for that specific row and column index. Otherwise, copy the pixel's color.
    
    relationships:
      - The output grid is derived from the input grid.
      - White pixels in the input signal locations where the background pattern needs to be restored.
      - The color used for replacement depends on the pixel's row (even or odd) and its column index relative to the repeating sequence length (for odd rows).
    ```


*   **Natural Language Program**:
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the repeating color sequence used in the odd-numbered rows (rows 1, 3, 5, ...). To do this, find an odd-numbered row in the input grid that does not contain any white (0) pixels. Extract the repeating unit of colors from this row. Let this sequence be `S` and its length be `L`.
    3.  Iterate through each cell `(row, col)` of the input grid.
    4.  If the value of the input cell `input[row, col]` is white (0):
        a.  If the `row` index is even (`row % 2 == 0`), set the corresponding output cell `output[row, col]` to blue (1).
        b.  If the `row` index is odd (`row % 2 != 0`), determine the correct color from the sequence `S` based on the column index. The color is `S[col % L]`. Set the corresponding output cell `output[row, col]` to this color.
    5.  If the value of the input cell `input[row, col]` is not white (0), keep its value in the output grid (it was already copied in step 1).
    6.  Return the modified output grid.
```python
import numpy as np

"""
The transformation restores a background pattern that has been partially obscured by white (0) pixels.
The background pattern consists of two alternating row types:
1. Even-numbered rows (0, 2, 4, ...) are entirely filled with blue (1).
2. Odd-numbered rows (1, 3, 5, ...) consist of a horizontally repeating sequence of colors, starting with blue (1).

The process is:
1. Identify the repeating color sequence used in the odd-numbered rows by finding an odd row without any white (0) pixels.
2. Create an output grid by copying the input grid.
3. Iterate through each cell of the input grid.
4. If a cell contains white (0), replace it in the output grid with the color that should be there according to the background pattern:
    - If the cell is in an even row, replace white with blue (1).
    - If the cell is in an odd row, replace white with the color from the repeating sequence corresponding to the cell's column index modulo the sequence length.
5. Return the modified output grid.
"""

def find_odd_row_pattern(grid):
    """
    Finds the repeating color sequence from the first odd row 
    that doesn't contain any white (0) pixels.
    """
    height, width = grid.shape
    sequence = None
    seq_len = 0
    
    # Iterate through odd rows (1, 3, 5...)
    for r in range(1, height, 2):
        row_data = grid[r, :]
        # Check if the row contains any white pixels (0)
        if 0 not in row_data:
            # Found a suitable row to determine the pattern
            # Assume pattern starts at column 0
            # Find the length of the repeating sequence
            start_color = row_data[0]
            for l in range(1, width):
                if row_data[l] == start_color:
                    # Found the repeat, sequence is from index 0 to l-1
                    sequence = list(row_data[0:l])
                    seq_len = l
                    return sequence, seq_len
            # If no repeat found within the row width, maybe the whole row is the sequence unit?
            # This is less likely given the examples, but handle it just in case.
            sequence = list(row_data)
            seq_len = width
            return sequence, seq_len
            
    # Raise an error or return default if no suitable row found (shouldn't happen based on examples)
    if sequence is None:
        raise ValueError("Could not determine the repeating pattern in odd rows.")
        
    return sequence, seq_len

def transform(input_grid):
    """
    Restores the background pattern obscured by white pixels.
    
    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the output grid with the pattern restored.
    """
    
    # Convert input_grid to numpy array if it's not already
    input_grid_np = np.array(input_grid)
    height, width = input_grid_np.shape
    
    # Initialize output_grid as a copy of the input
    output_grid = input_grid_np.copy()
    
    # Find the repeating sequence for odd rows
    odd_row_sequence, seq_len = find_odd_row_pattern(input_grid_np)

    # Iterate through each cell of the grid
    for r in range(height):
        for c in range(width):
            # Check if the current cell in the input is white (0)
            if input_grid_np[r, c] == 0:
                # Determine the correct background color based on row type
                if r % 2 == 0:
                    # Even row: background is blue (1)
                    output_grid[r, c] = 1
                else:
                    # Odd row: background follows the repeating sequence
                    # Calculate the index in the sequence based on column
                    pattern_index = c % seq_len
                    output_grid[r, c] = odd_row_sequence[pattern_index]
                    
    return output_grid.tolist() # Return as list of lists per ARC standard

```
