{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the palette colors: these are non-white (0), non-gray (5) pixels that are adjacent (4-connectivity) to at least one gray (5) pixel.\nSort these palette colors by their position (top-to-bottom, then left-to-right) to get an ordered list of replacement colors.\nIdentify the target color: this is the most frequent color in the grid among pixels that are non-white (0), non-gray (5), and are *not* adjacent to any gray (5) pixel.\nIdentify target objects: find all distinct connected components (objects) made solely of the target color using 4-connectivity.\nSort these target objects based on the position of their top-most, then left-most pixel.\nCreate a copy of the input grid.\nMap the sorted target objects to the sorted replacement colors in order. For the i-th target object, change the color of all its pixels in the copied grid to the i-th replacement color.\nReturn the modified grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components (objects) of a specific color in the grid.\n    Uses 4-connectivity (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of the pixels belonging to a single connected object.\n              Returns an empty list if the color is None or no objects are found.\n    \"\"\"\n    if color is None: # Handle cases where no target color is identified\n        return []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If it's the right color and not yet visited, start a search (BFS)\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check grid boundaries\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                # Add the found object coordinates set to the list of objects\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_object_top_left(obj_coords):\n    \"\"\"\n    Finds the top-most, then left-most coordinate of an object.\n    This is used for sorting objects.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        tuple: The (row, col) of the top-left pixel.\n               Returns (infinity, infinity) for an empty set to ensure it sorts last.\n    \"\"\"\n    if not obj_coords:\n        # Should not happen with valid objects from find_objects\n        return (float('inf'), float('inf'))\n    # Find the minimum row index present in the object coordinates\n    min_row = min(r for r, c in obj_coords)\n    # Among pixels in that minimum row, find the minimum column index\n    min_col = min(c for r, c in obj_coords if r == min_row)\n    return (min_row, min_col)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying palette colors near gray areas,\n    identifying target objects not near gray areas, and recoloring the target\n    objects using the palette colors based on sorted order.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists of integers.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid) # Start with a copy to modify\n    height, width = grid.shape\n\n    # --- 1. Identify Palette Colors and their Positions ---\n    # Palette colors are non-white(0), non-gray(5), and adjacent (4-connectivity) to gray(5).\n    palette_colors_data = []\n    # Create a boolean mask indicating pixels adjacent to gray\n    is_near_gray = np.zeros_like(grid, dtype=bool)\n\n    # Iterate through the grid to find gray pixels\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 5: # If this pixel is gray\n                # Check its 4 neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # If neighbor is within bounds, mark it as being near gray\n                    if 0 <= nr < height and 0 <= nc < width:\n                        is_near_gray[nr, nc] = True\n\n    # Iterate again to find pixels matching palette color criteria\n    for r in range(height):\n        for c in range(width):\n             color = grid[r,c]\n             # Conditions: color is not white(0), not gray(5), AND it is near gray\n             if color != 0 and color != 5 and is_near_gray[r,c]:\n                 # Store the color and its position\n                 palette_colors_data.append({'color': color, 'row': r, 'col': c})\n\n    # Sort the identified palette colors: primarily by row, secondarily by column\n    palette_colors_data.sort(key=lambda x: (x['row'], x['col']))\n    # Extract just the color values in the sorted order\n    replacement_colors = [p['color'] for p in palette_colors_data]\n\n    # --- 2. Identify Target Color ---\n    # Target color is the most frequent color that is:\n    # Not white(0), Not gray(5), and NOT adjacent to gray.\n    color_counts = Counter()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r,c]\n            # Conditions: color is not white(0), not gray(5), AND it is NOT near gray\n            if color != 0 and color != 5 and not is_near_gray[r,c]:\n                 # Increment count for this color\n                 color_counts[color] += 1\n\n    # Determine the most frequent color among the candidates\n    target_color = None\n    if color_counts:\n        # most_common(1) returns a list like [ (color, count) ], we need the color.\n        target_color = color_counts.most_common(1)[0][0]\n\n    # --- 3. Identify and Order Target Objects ---\n    # Find all distinct connected objects composed of the identified target_color.\n    # Pass the grid and the determined target_color to the helper function.\n    target_objects_coords = find_objects(grid, target_color)\n\n    # If no target objects were found (e.g., target_color was None or no objects exist),\n    # return the unmodified grid.\n    if not target_objects_coords:\n        return output_grid.tolist()\n\n    # Sort the list of target objects. The key for sorting is the\n    # top-left coordinate of each object (obtained via get_object_top_left).\n    target_objects_coords.sort(key=get_object_top_left)\n\n    # --- 4. Apply Transformation ---\n    # Check if the number of target objects matches the number of replacement colors found.\n    # This is expected based on the examples. If not, print a warning.\n    # The `zip` function will handle mismatches by stopping when the shorter list is exhausted.\n    if len(target_objects_coords) != len(replacement_colors):\n         # This warning helps in debugging if the assumption doesn't hold for new cases.\n         print(f\"Warning: Number of target objects ({len(target_objects_coords)}) \"\n               f\"does not match number of palette colors ({len(replacement_colors)}).\")\n\n    # Pair up the sorted target objects with the sorted replacement colors.\n    for obj_coords, new_color in zip(target_objects_coords, replacement_colors):\n        # For each object (represented by its set of coordinates),\n        # iterate through its pixels.\n        for r, c in obj_coords:\n            # Update the corresponding pixel in the output grid with the new color.\n            output_grid[r, c] = new_color\n\n    # Convert the final numpy array back to a standard Python list of lists format.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5115,
    "candidates_token_count": 2159,
    "total_token_count": 7274,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 71.273389,
  "retries": 1
}