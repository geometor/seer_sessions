{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nIdentifies hollow, single-pixel-thick rectangles and isolated single pixels (scattered pixels) in the input grid.\nDetermines a color mapping: sorts distinct rectangle frame colors and distinct scattered pixel colors numerically. Pairs the i-th frame color with the (n-1-i)-th scattered pixel color.\nFills the interior of each rectangle with its corresponding mapped color using a checkerboard pattern. The checkerboard is anchored such that the top-left interior pixel's color depends on the parity of the sum of its coordinates (row + column). Specifically, if the top-left interior pixel is at (r0, c0), a pixel at (r, c) inside the rectangle is colored if (r + c) % 2 == (r0 + c0) % 2.\nRemoves the original scattered pixels from the grid, setting them to the background color (0).\n\"\"\"\n\ndef is_valid(r, c, height, width):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Get valid neighbor coordinates.\"\"\"\n    neighbors = []\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1),  # 4-connectivity\n             (-1, -1), (-1, 1), (1, -1), (1, 1)] # Diagonals for 8-connectivity\n    \n    if connectivity == 4:\n        moves_to_use = moves[:4]\n    else: # Default to 8-connectivity\n        moves_to_use = moves\n\n    for dr, dc in moves_to_use:\n        nr, nc = r + dr, c + dc\n        if is_valid(nr, nc, height, width):\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_scattered_pixels(grid):\n    \"\"\"Find single non-background pixels surrounded by background.\"\"\"\n    scattered = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0:\n                is_scattered = True\n                neighbors = get_neighbors(r, c, height, width, connectivity=8)\n                if not neighbors: # Handle 1x1 grid case\n                     if height == 1 and width == 1:\n                         is_scattered = True # A single non-zero pixel is scattered\n                     else:\n                         is_scattered = False # Should not happen if is_valid works\n\n                for nr, nc in neighbors:\n                    if grid[nr, nc] != 0:\n                        is_scattered = False\n                        break\n                if is_scattered:\n                    scattered.append({'color': color, 'pos': (r, c)})\n    return scattered\n\ndef find_hollow_rectangles(grid):\n    \"\"\"Finds hollow rectangles with 1-pixel thick frames.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                frame_color = grid[r, c]\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                is_single_color = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    if grid[curr_r, curr_c] != frame_color:\n                        is_single_color = False\n                        # Continue BFS to mark component visited, but know it's not a candidate\n                        \n                    component.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Use 4-connectivity for finding frame components\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=4):\n                        if grid[nr, nc] == frame_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                        elif grid[nr, nc] != 0 and grid[nr, nc] != frame_color:\n                            # If adjacent to another color, mark those visited too to avoid re-processing\n                            # but invalidate the current component as a potential rectangle frame\n                             is_single_color = False\n\n\n                if not is_single_color:\n                    # Mark all pixels reachable through different colors as visited if needed\n                    # but simpler to just skip this component\n                    continue\n\n                # Check if the component forms a hollow rectangle\n                is_hollow_rect = True\n                expected_frame_size = 0\n                if max_r > min_r and max_c > min_c: # Needs at least 3x3 bounding box for hollow\n                   expected_frame_size = 2 * (max_r - min_r + 1) + 2 * (max_c - min_c + 1) - 4 # Perimeter\n                elif max_r == min_r and max_c > min_c: # Horizontal line\n                    expected_frame_size = max_c - min_c + 1\n                elif max_c == min_c and max_r > min_r: # Vertical line\n                    expected_frame_size = max_r - min_r + 1\n                else: # Single pixel\n                    expected_frame_size = 1\n                    \n                if len(component) != expected_frame_size:\n                    is_hollow_rect = False # Doesn't match perimeter count\n\n                if is_hollow_rect and expected_frame_size > 1: # Avoid classifying lines/single points as rectangles here\n                    # Verify all component pixels are on the border\n                    for pr, pc in component:\n                        if not (pr == min_r or pr == max_r or pc == min_c or pc == max_c):\n                            is_hollow_rect = False\n                            break\n                    if not is_hollow_rect: continue\n\n                    # Verify the interior is entirely background color (0)\n                    interior_coords = []\n                    interior_is_clear = True\n                    if max_r > min_r + 1 and max_c > min_c + 1: # Check only if there's an actual interior\n                        for ir in range(min_r + 1, max_r):\n                            for ic in range(min_c + 1, max_c):\n                                interior_coords.append((ir, ic))\n                                if grid[ir, ic] != 0:\n                                    interior_is_clear = False\n                                    break\n                            if not interior_is_clear: break\n                    elif not component: # handle empty component case? shouldnt happen\n                        interior_is_clear = False\n                    elif max_r <= min_r + 1 or max_c <= min_c + 1: # No interior space, technically valid but no fill needed\n                         interior_coords = []\n                         interior_is_clear = True # Treat as clear\n                    else: # Should cover all cases, but default to false if logic missed something\n                        interior_is_clear = False\n\n\n                    if interior_is_clear:\n                        rectangles.append({\n                            'frame_color': frame_color,\n                            'bounds': (min_r, min_c, max_r, max_c),\n                            'interior_coords': interior_coords,\n                            'component_coords': component # Store frame pixels\n                        })\n                        \n    # Filter out rectangles fully contained within other found rectangles' frames (corner cases)\n    # This is complex, might be unnecessary if the primary checks are robust\n    # For now, assume the primary checks are sufficient\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding hollow rectangles and scattered pixels,\n    determining a fill color mapping, filling rectangle interiors with a checkerboard\n    pattern using the mapped colors, and removing the original scattered pixels.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Find scattered pixels\n    scattered_pixels = find_scattered_pixels(input_grid_np)\n    scattered_colors = sorted(list(set(p['color'] for p in scattered_pixels)))\n    scattered_positions = [p['pos'] for p in scattered_pixels]\n\n    # 2. Find hollow rectangles\n    hollow_rectangles = find_hollow_rectangles(input_grid_np)\n    frame_colors = sorted(list(set(r['frame_color'] for r in hollow_rectangles)))\n\n    # 3. Determine color mapping\n    color_map = {}\n    if len(frame_colors) == len(scattered_colors) and len(frame_colors) > 0:\n        num_colors = len(frame_colors)\n        for i in range(num_colors):\n            color_map[frame_colors[i]] = scattered_colors[num_colors - 1 - i]\n    # Handle cases with mismatched numbers or no scattered/rectangles?\n    # Based on examples, assume counts match. If not, the behavior is undefined by examples.\n\n    # 4. Apply checkerboard fill\n    for rect in hollow_rectangles:\n        frame_color = rect['frame_color']\n        if frame_color in color_map and rect['interior_coords']:\n            fill_color = color_map[frame_color]\n            \n            # Anchor point for checkerboard is the top-left interior pixel\n            min_r, min_c, _, _ = rect['bounds']\n            anchor_r, anchor_c = min_r + 1, min_c + 1 # Assumes interior exists\n            \n            # Check if anchor is valid (rectangle might be too small for standard anchor)\n            if not rect['interior_coords']: continue # Skip if no interior\n                \n            if (anchor_r, anchor_c) not in rect['interior_coords']:\n                 # Find the actual top-left most interior coord if anchor isn't standard\n                 if rect['interior_coords']:\n                     anchor_r, anchor_c = min(rect['interior_coords'], key=lambda x: (x[0], x[1]))\n                 else: # Should not happen if check above works\n                      continue\n\n            target_parity = (anchor_r + anchor_c) % 2\n\n            for r, c in rect['interior_coords']:\n                if (r + c) % 2 == target_parity:\n                    output_grid[r, c] = fill_color\n\n    # 5. Remove scattered pixels\n    for r, c in scattered_positions:\n        # Make sure we don't erase part of a rectangle frame if a scattered pixel\n        # was somehow adjacent/part of the component finding logic boundary cases.\n        # Check if this position belongs to any identified rectangle frame.\n        is_part_of_frame = False\n        for rect in hollow_rectangles:\n            if (r,c) in rect['component_coords']:\n                 is_part_of_frame = True\n                 break\n        if not is_part_of_frame: # Only remove if it's truly isolated\n             output_grid[r, c] = 0\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6796,
    "candidates_token_count": 2741,
    "total_token_count": 9537,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.834843,
  "retries": 1
}