
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 1 3 2 0 2 3 3 2 0 2 1 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 1 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 8 2 0 2 3 3 2 0 2 3 3 2 0 2 3 8 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 1 3 2 0 2 1 3 2 0 2 1 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 1 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 1 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 3 2 0 2 6 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 2 3 8 2 0 2 3 8 2 0 2 3 8 2 0 2 3 8 2 0
0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0 2 3 3 2 0
0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 2 1 0 1 8 8 1 0 1 8 8 1 0 1 8 2 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 8 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 8 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 2 1 0 1 8 2 1 0 1 8 2 1 0 1 8 2 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 1 1 8 1 0 1 1 4 1 0 1 1 8 1 0 1 1 8 1 0
0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0 1 8 8 1 0
0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 7 4 8 0 8 4 4 8 0
0 8 4 8 8 0 8 4 8 8 0 8 4 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 4 4 8 0 8 4 4 8 0
0 8 3 8 8 0 8 4 8 8 0 8 3 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 7 4 8 0 8 4 4 8 0
0 8 4 8 8 0 8 4 8 8 0 8 4 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 7 4 8 0 8 4 4 8 0
0 8 4 8 8 0 8 4 8 8 0 8 4 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 7 4 8 0 8 4 4 8 0
0 8 3 8 8 0 8 3 8 8 0 8 3 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 8 4 4 8 0 8 7 4 8 0 8 4 4 8 0
0 8 4 8 8 0 8 4 8 8 0 8 4 8 8 0
0 8 8 8 8 0 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples for task `train_1`.

**Perception**

1.  **Grid Structure**: Both input and output grids exhibit a regular structure. They are composed of distinct 4x4 pixel blocks separated by single-pixel wide white (0) borders. The overall grid is formed by arranging these blocks in a larger grid pattern (e.g., 5 rows and 4 columns of blocks in `train_1`).
2.  **Block Structure**: Each 4x4 block has an outer border of a specific color (red=2 in `train_1`, blue=1 in `train_2`, azure=8 in `train_3`) and an inner 2x2 central region.
3.  **Central Region Content**: The inner 2x2 region contains pixels of various colors. Within each example pair (input/output), there appears to be a dominant or "default" color filling most positions in these central regions across the grid (green=3 in `train_1`, azure=8 in `train_2`, yellow=4 in `train_3`). Other "non-default" colors appear less frequently in these central regions.
4.  **Transformation**: The transformation primarily affects the pixels within the 2x2 central regions. Specifically, pixels with the "default" color are sometimes changed. Pixels with "non-default" colors in the input seem to remain unchanged in the output. The border pixels (white separators and the colored borders of the 4x4 blocks) also remain unchanged.
5.  **Rule Identification**: The change seems to be a form of propagation or "infection". If a cell within a block's 2x2 center has the "default" color, its value in the output grid is determined by looking at the colors in the *corresponding position* within the 2x2 centers of all its adjacent neighboring blocks (including diagonals) in the *input* grid. If any neighbor has a "non-default" color at that corresponding position, the current block's cell adopts that non-default color. If all neighbors have the default color (or are border pixels outside a valid center), the cell retains its default color. If multiple neighbors have *different* non-default colors at the corresponding position (which doesn't seem to occur in the examples), a priority rule would be needed, but based on the examples, it appears only one neighbor provides the "infecting" color.

**Facts**


```yaml
Grid:
  Structure: Composed of repeating subgrids (Blocks) separated by borders.
  Border_Color: 0 (white) separating Blocks.
Block:
  Type: Subgrid object.
  Size: 4x4 pixels.
  Structure:
    - Outer_Border: 1-pixel thick border, color varies per task (e.g., 2=red, 1=blue, 8=azure).
    - Center: Inner 2x2 pixel area.
  Arrangement: Tiled grid layout (e.g., 5 rows x 4 columns of Blocks).
Center_Region:
  Size: 2x2 pixels.
  Location: Inner area of a Block.
  Pixel_Colors:
    - Default_Color: The most frequent color found across all Center_Regions in the input grid (e.g., 3=green, 8=azure, 4=yellow). Identified per task.
    - Non_Default_Colors: Other colors appearing in Center_Regions.
Transformation:
  Scope: Affects only pixels within the Center_Regions.
  Condition: Applies only to pixels that have the Default_Color in the input grid.
  Rule:
    - For a pixel at relative position (dr, dc) within a Center_Region (where dr, dc can be 0 or 1):
      - If its color is the Default_Color:
        - Examine all 8 neighboring Blocks (adjacent/diagonal).
        - Check the pixel at the same relative position (dr, dc) within each neighbor's Center_Region in the *input* grid.
        - Collect the colors found in those corresponding positions.
        - Filter these collected colors to find any Non_Default_Colors.
        - If exactly one unique Non_Default_Color is found among neighbors:
          - Change the current pixel's color to that Non_Default_Color in the output grid.
        - Else (no Non_Default_Colors found, or multiple different ones - though the latter isn't observed):
          - The pixel retains its Default_Color in the output grid.
      - If its color is already a Non_Default_Color:
        - The pixel remains unchanged in the output grid.
  Invariance:
    - Grid borders (white=0) remain unchanged.
    - Block borders (red=2, blue=1, azure=8, etc.) remain unchanged.
    - Pixels within Center_Regions that are initially Non_Default_Colors remain unchanged.
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the repeating 4x4 block structure based on the white (0) borders that form a grid spacing (typically every 5th row and column).
3.  For each 4x4 block identified:
    a.  Note the location (top-left corner row `R`, column `C`) of the block.
    b.  Identify the 2x2 center region of the block (at rows `R+1` to `R+2`, columns `C+1` to `C+2`).
4.  Determine the "Default Color" by counting the occurrences of each color within *all* the 2x2 center regions across the entire input grid. The Default Color is the color with the highest frequency.
5.  Iterate through each block in the grid (indexed by block row `br` and block column `bc`).
6.  For the current block at (`br`, `bc`):
    a.  Iterate through each cell within its 2x2 center region (relative coordinates `dr`, `dc` where `dr`, `dc` are 0 or 1). Let the absolute grid coordinates be `r = R + 1 + dr`, `c = C + 1 + dc`.
    b.  Check the color of the input grid cell `input[r][c]`.
    c.  If `input[r][c]` is equal to the Default Color:
        i.  Initialize an empty list `neighbor_colors`.
        ii. Iterate through all 8 potential neighboring block positions (`nbr`, `nbc`) relative to the current block (`br`, `bc`) (i.e., `nbr` from `br-1` to `br+1`, `nbc` from `bc-1` to `bc+1`, excluding `nbr=br` and `nbc=bc`).
        iii. For each neighbor position (`nbr`, `nbc`):
            1.  Check if this neighbor position is valid (within the grid of blocks).
            2.  If valid, determine the absolute coordinates (`nr`, `nc`) of the cell corresponding to the *same relative position* (`dr`, `dc`) within the neighbor block's center: `nr = Neighbor_R + 1 + dr`, `nc = Neighbor_C + 1 + dc`.
            3.  Get the color `neighbor_color = input[nr][nc]`.
            4.  If `neighbor_color` is *not* the Default Color, add it to the `neighbor_colors` list.
        iv. Find the unique non-default colors in the `neighbor_colors` list.
        v.  If there is exactly one unique non-default color found (`source_color`):
            1.  Update the output grid at the current position: `output[r][c] = source_color`.
        vi. Otherwise (no non-default neighbors or multiple different ones), the output cell `output[r][c]` retains the Default Color (it's already set from the initial copy).
    d.  If `input[r][c]` is *not* the Default Color, do nothing (the output cell `output[r][c]` keeps the value from the initial copy).
7.  Return the completed output grid.
```python
import numpy as np
from collections import Counter

"""
Transformation Rule Description:

1.  **Grid Structure:** The input grid is composed of repeating 4x4 pixel blocks separated by single-pixel wide white (0) borders. These blocks form a larger grid structure.
2.  **Block Structure:** Each 4x4 block has an outer border of a specific color and an inner 2x2 central region.
3.  **Identify Default Color:** Determine the most frequent color ("Default Color") found within all the 2x2 central regions across the entire input grid.
4.  **Transformation Logic:**
    a.  Initialize the output grid as a copy of the input grid.
    b.  Iterate through each 4x4 block in the grid.
    c.  For each cell within the 2x2 center of the current block:
        i.  If the cell's color in the input grid is the Default Color:
            1.  Examine the cells at the *corresponding relative position* within the 2x2 centers of all 8 adjacent (including diagonal) neighboring blocks in the *input* grid.
            2.  Collect the colors of these corresponding neighbor cells *if* they are *not* the Default Color.
            3.  Find the unique non-default colors collected from the neighbors.
            4.  If exactly one unique non-default color was found, change the current cell's color in the *output* grid to this unique non-default color.
            5.  Otherwise (no non-default neighbors, or multiple different non-default colors), the cell retains its original Default Color in the output grid.
        ii. If the cell's color in the input grid is *not* the Default Color, it remains unchanged in the output grid.
5.  **Invariance:** All border pixels (white separators and the colored borders of the 4x4 blocks) remain unchanged.
"""

def find_block_centers(grid_shape):
    """
    Identifies the coordinates of the 2x2 centers of the 4x4 blocks.
    Assumes blocks are 4x4 separated by 1-pixel borders (pattern repeats every 5 pixels).

    Args:
        grid_shape (tuple): The (height, width) of the grid.

    Returns:
        dict: A dictionary mapping block indices (br, bc) to the
              top-left (r, c) coordinate of their 2x2 center.
              Example: {(0, 0): (2, 2), (0, 1): (2, 7), ...}
              Note: Uses 1-based indexing for center calculation from prompt,
                    adjusts to 0-based array indices. Top-left of grid is (0,0).
                    Top-left of first block is (1,1). Top-left of first center is (2,2).
    """
    height, width = grid_shape
    centers = {}
    # Block indices (br, bc)
    br = 0
    # Start row of the first block's border is 1
    for r in range(1, height - 1, 5):
        bc = 0
        # Start col of the first block's border is 1
        for c in range(1, width - 1, 5):
            # Check if block fits completely
            if r + 3 < height and c + 3 < width:
                # Center top-left is at (r+1, c+1) in 0-based index
                center_r, center_c = r + 1, c + 1
                centers[(br, bc)] = (center_r, center_c)
            bc += 1
        br += 1
    return centers

def get_default_color(grid, block_centers):
    """
    Finds the most frequent color within the 2x2 centers of all blocks.

    Args:
        grid (np.array): The input grid.
        block_centers (dict): Dictionary mapping block indices to center coordinates.

    Returns:
        int: The most frequent color (Default Color).
    """
    center_colors = []
    for center_r, center_c in block_centers.values():
        center_colors.extend(grid[center_r:center_r+2, center_c:center_c+2].flatten())

    if not center_colors:
        # Handle case with no blocks or empty grid if necessary
        return 0 # Default to white if no centers found

    color_counts = Counter(center_colors)
    # Find the color with the maximum count
    default_color = color_counts.most_common(1)[0][0]
    return default_color

def transform(input_grid):
    """
    Applies the transformation rule based on neighbor block center colors.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    grid = np.array(input_grid, dtype=np.int8)
    output_grid = grid.copy()
    grid_shape = grid.shape

    # 1. Find all block centers
    block_centers = find_block_centers(grid_shape)
    if not block_centers:
        return output_grid.tolist() # No blocks found, return copy

    # Create a reverse mapping for quick lookup of block index from center coords
    center_to_block_idx = {v: k for k, v in block_centers.items()}

    # 2. Determine the Default Color
    default_color = get_default_color(grid, block_centers)

    # 3. Iterate through each block and its center
    for (br, bc), (center_r, center_c) in block_centers.items():
        # Iterate through the 2x2 center of the current block
        for dr in range(2):
            for dc in range(2):
                r, c = center_r + dr, center_c + dc
                current_color = grid[r, c]

                # 4. Apply transformation only if the color is the Default Color
                if current_color == default_color:
                    neighbor_non_default_colors = []
                    # Check 8 neighboring blocks
                    for nbr_offset in range(-1, 2):
                        for nbc_offset in range(-1, 2):
                            if nbr_offset == 0 and nbc_offset == 0:
                                continue # Skip self

                            neighbor_br, neighbor_bc = br + nbr_offset, bc + nbc_offset

                            # Check if neighbor block exists
                            if (neighbor_br, neighbor_bc) in block_centers:
                                neighbor_center_r, neighbor_center_c = block_centers[(neighbor_br, neighbor_bc)]
                                # Get color at the corresponding position in the neighbor's center
                                neighbor_r, neighbor_c = neighbor_center_r + dr, neighbor_center_c + dc
                                neighbor_color = grid[neighbor_r, neighbor_c]

                                # Collect non-default colors
                                if neighbor_color != default_color:
                                    neighbor_non_default_colors.append(neighbor_color)

                    # Find unique non-default neighbor colors
                    unique_non_defaults = set(neighbor_non_default_colors)

                    # If exactly one unique non-default color is found, update output grid
                    if len(unique_non_defaults) == 1:
                        output_grid[r, c] = list(unique_non_defaults)[0]
                    # Else (0 or >1 unique non-defaults), color remains default (already set)

    return output_grid.tolist()
```
