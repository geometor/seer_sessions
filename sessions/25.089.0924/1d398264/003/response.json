{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies a block of three vertically adjacent rows containing horizontal non-white pixel segments. \nPerforms transformations based on these segments: \n1. Center row expands horizontally: Pixels to the left of the segment are filled with the segment's leftmost color, and pixels to the right are filled with the segment's rightmost color.\n2. Upper row projects pixels one step up and horizontally based on their offset from the segment center, then casts rays further upwards in the determined direction (diagonal left, straight up, or diagonal right).\n3. Lower row projects pixels one step down and horizontally based on their offset from the segment center, then casts rays further downwards in the determined direction (diagonal left, straight down, or diagonal right).\nThe output grid starts as a copy of the input, and these operations modify it.\n\"\"\"\n\ndef find_key_rows(grid: np.ndarray) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the indices of the first block of 3 consecutive rows, \n    each containing at least one non-white pixel.\n    Returns (upper_row_idx, center_row_idx, lower_row_idx) or None.\n    \"\"\"\n    height = grid.shape[0]\n    if height < 3:\n        return None\n    for r in range(height - 2):\n        if (np.any(grid[r] != 0) and \n            np.any(grid[r + 1] != 0) and \n            np.any(grid[r + 2] != 0)):\n            return r, r + 1, r + 2\n    return None\n\ndef analyze_segment(grid_row: np.ndarray) -> Optional[Tuple[int, int, int, np.ndarray]]:\n    \"\"\"\n    Finds the first contiguous horizontal segment of non-white pixels in a row.\n    Returns (start_col, end_col, center_col, pixels_array) or None if no segment found.\n    Assumes only one segment per relevant row based on examples.\n    \"\"\"\n    non_white_cols = np.where(grid_row != 0)[0]\n    if len(non_white_cols) == 0:\n        return None\n    \n    start_col = non_white_cols[0]\n    end_col = non_white_cols[-1]\n    \n    # Basic check for contiguity within the identified bounds\n    if not np.all(grid_row[start_col : end_col + 1] != 0):\n         # This case is not expected based on examples, but as a fallback,\n         # we still use the first and last non-white pixel as boundaries.\n         # A more robust implementation might find all contiguous sub-segments.\n         pass \n\n    center_col = start_col + (end_col - start_col) // 2\n    pixels = grid_row[start_col : end_col + 1]\n    \n    return start_col, end_col, center_col, pixels\n\ndef expand_center_row(output_np: np.ndarray, center_r: int, segment_info: Tuple[int, int, int, np.ndarray]):\n    \"\"\"Modifies the output grid by expanding the center row segment horizontally.\"\"\"\n    start_col, end_col, _, pixels = segment_info\n    width = output_np.shape[1]\n    \n    left_color = pixels[0]\n    right_color = pixels[-1]\n    \n    # Fill left side\n    if start_col > 0:\n        output_np[center_r, 0:start_col] = left_color\n        \n    # Fill right side\n    if end_col < width - 1:\n        output_np[center_r, end_col + 1 : width] = right_color\n        \n    # The segment itself is already copied from the input.\n\ndef project_and_cast(output_np: np.ndarray, orig_r: int, segment_info: Tuple[int, int, int, np.ndarray], dr: int):\n    \"\"\"\n    Projects pixels from the original row and casts rays in the output grid.\n    dr = -1 for upwards, dr = +1 for downwards.\n    \"\"\"\n    start_col, end_col, center_col, _ = segment_info\n    height, width = output_np.shape\n    \n    # Iterate through the columns of the original segment in the input grid (which is identical to output_np initially)\n    for c_orig in range(start_col, end_col + 1):\n        color = output_np[orig_r, c_orig] \n        # Although analyze_segment assumes non-white, double-check in case of sparse segments\n        if color == 0: \n            continue\n\n        # Calculate offset and direction\n        offset = c_orig - center_col\n        dc = 1 if offset > 0 else (-1 if offset < 0 else 0)\n        \n        # --- Initial Projection (one step) ---\n        r_proj = orig_r + dr\n        c_proj = c_orig + offset\n        \n        # Draw projection if within bounds\n        projected = False\n        if 0 <= r_proj < height and 0 <= c_proj < width:\n            output_np[r_proj, c_proj] = color\n            projected = True\n        \n        # --- Ray Casting (starts from *next* step after projection) ---\n        if projected: # Only cast ray if the initial projection landed within bounds\n            ray_r = r_proj + dr\n            ray_c = c_proj + dc\n            \n            while 0 <= ray_r < height and 0 <= ray_c < width:\n                output_np[ray_r, ray_c] = color\n                ray_r += dr\n                ray_c += dc\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation logic: finds key rows, expands center, projects and casts upper/lower rows.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    \n    # 1. Identify Key Rows\n    key_rows = find_key_rows(input_np)\n    if key_rows is None:\n        # If the structure isn't found, return the original grid\n        return input_grid \n        \n    upper_r, center_r, lower_r = key_rows\n\n    # 2. Analyze Segments in each key row\n    upper_seg_info = analyze_segment(input_np[upper_r])\n    center_seg_info = analyze_segment(input_np[center_r])\n    lower_seg_info = analyze_segment(input_np[lower_r])\n\n    # Check if all segments were found (required for the transformation)\n    if upper_seg_info is None or center_seg_info is None or lower_seg_info is None:\n         # This scenario might indicate an unexpected input format. Return original.\n         print(\"Warning: Could not find segments in all three key rows. Returning original grid.\")\n         return input_grid\n\n    # 3. Expand Center Row\n    expand_center_row(output_np, center_r, center_seg_info)\n\n    # 4. Project Upper Row and Cast Rays Upwards (dr = -1)\n    project_and_cast(output_np, upper_r, upper_seg_info, dr=-1)\n    \n    # 5. Project Lower Row and Cast Rays Downwards (dr = +1)\n    project_and_cast(output_np, lower_r, lower_seg_info, dr=1)\n\n    # 6. Return Result\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19072,
    "candidates_token_count": 1810,
    "total_token_count": 20882,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.766879,
  "retries": 1
}