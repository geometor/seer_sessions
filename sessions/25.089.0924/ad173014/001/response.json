{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Optional\n\n\"\"\"\nThis module transforms an input grid based on patterns found within red rectangular frames.\n\nThe core logic involves:\n1. Identifying all distinct rectangular frames made of red (2) pixels.\n2. For each frame, determining its size (height x width).\n3. Identifying the single color of the pattern enclosed within the frame (ignoring the red frame pixels and white background pixels).\n4. Applying a color transformation rule to the enclosed pattern. This rule depends on:\n    a. The dimensions of the frame (specifically 5x5 or 7x7).\n    b. The original color of the enclosed pattern.\n    c. For 5x5 frames containing magenta (6) patterns, whether the frame is adjacent (including diagonals) to any blue (1) pixel (part of the L-shaped border).\n5. Preserving all other pixels (background, blue border, red frames) in their original positions.\n\nColor Transformation Rules:\n- If frame is 5x5:\n    - Green (3) -> Azure (8)\n    - Azure (8) -> Magenta (6)\n    - Orange (7) -> Green (3)\n    - Magenta (6):\n        - If adjacent to Blue (1) -> Orange (7)\n        - Else -> Green (3)\n- If frame is 7x7:\n    - Green (3) -> Azure (8)\n    - Azure (8) -> Yellow (4)\n    - Yellow (4) -> Green (3)\n\"\"\"\n\n# Define color constants for clarity\nWHITE = 0\nBLUE = 1\nRED = 2\nGREEN = 3\nYELLOW = 4\nMAGENTA = 6\nORANGE = 7\nAZURE = 8\n\n# Define transformation maps based on frame size\nTRANSFORM_5x5 = {\n    GREEN: AZURE,\n    AZURE: MAGENTA,\n    ORANGE: GREEN,\n    # Magenta is handled separately due to adjacency condition\n}\n\nTRANSFORM_7x7 = {\n    GREEN: AZURE,\n    AZURE: YELLOW,\n    YELLOW: GREEN,\n}\n\ndef _find_red_frames(grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all distinct red rectangular frames in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of tuples, where each tuple represents a frame:\n        (top_row, left_col, height, width).\n    \"\"\"\n    frames = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check for potential top-left corner of a red frame that hasn't been visited\n            if grid[r, c] == RED and not visited[r, c]:\n                # Check if it's a real top-left corner (no red directly above or left, unless it's the edge)\n                is_top = (r == 0 or grid[r-1, c] != RED)\n                is_left = (c == 0 or grid[r, c-1] != RED)\n                \n                # Also check if the pixel below and right are red (start of frame sides)\n                has_right = (c + 1 < cols and grid[r, c+1] == RED)\n                has_down = (r + 1 < rows and grid[r+1, c] == RED)\n\n                if is_top and is_left and has_right and has_down:\n                    # Found a potential top-left corner, now determine width and height\n                    \n                    # Determine width\n                    w = 1\n                    while c + w < cols and grid[r, c + w] == RED:\n                        # Check if this horizontal line is valid (no red above)\n                        if r > 0 and grid[r-1, c+w] == RED:\n                            w = 0 # Invalid frame start\n                            break\n                        w += 1\n                    if w == 0: continue # Not a valid top edge start\n\n                    # Determine height\n                    h = 1\n                    while r + h < rows and grid[r + h, c] == RED:\n                         # Check if this vertical line is valid (no red to the left)\n                        if c > 0 and grid[r+h, c-1] == RED:\n                            h = 0 # Invalid frame start\n                            break\n                        h += 1\n                    if h == 0: continue # Not a valid left edge start\n                    \n                    # Verify the frame is closed and rectangular\n                    is_closed = True\n                    # Check bottom edge\n                    for i in range(w):\n                        if r + h - 1 >= rows or c + i >= cols or grid[r + h - 1, c + i] != RED:\n                            is_closed = False\n                            break\n                    if not is_closed: continue\n                    # Check right edge\n                    for i in range(h):\n                         if r + i >= rows or c + w - 1 >= cols or grid[r + i, c + w - 1] != RED:\n                            is_closed = False\n                            break\n                    if not is_closed: continue\n\n                    # Verify interior is not red (except maybe the pattern itself)\n                    # A simple check at the center might suffice for this problem's structure\n                    inner_r, inner_c = r + h // 2, c + w // 2\n                    if grid[inner_r, inner_c] == RED:\n                         # Check if the whole inner area is red - if so, it's not a frame with a pattern\n                         is_solid = True\n                         for ir in range(r + 1, r + h - 1):\n                             for ic in range(c + 1, c + w - 1):\n                                 if grid[ir, ic] != RED:\n                                     is_solid = False\n                                     break\n                             if not is_solid: break\n                         if is_solid: continue # Skip solid red blocks\n\n                    # Mark frame pixels as visited and add frame to list\n                    frames.append((r, c, h, w))\n                    for i in range(h):\n                        visited[r + i, c] = True\n                        visited[r + i, c + w - 1] = True\n                    for j in range(w):\n                        visited[r, c + j] = True\n                        visited[r + h - 1, c + j] = True\n                        \n    return frames\n\ndef _get_inner_color(grid: np.ndarray, r: int, c: int, h: int, w: int) -> Optional[int]:\n    \"\"\"\n    Finds the single dominant non-red, non-white color inside the frame boundaries.\n\n    Args:\n        grid: The input grid.\n        r, c, h, w: Frame definition (top_row, left_col, height, width).\n\n    Returns:\n        The color code of the inner pattern, or None if no single pattern color found.\n    \"\"\"\n    inner_color = None\n    for ir in range(r + 1, r + h - 1):\n        for ic in range(c + 1, c + w - 1):\n            pixel = grid[ir, ic]\n            if pixel != RED and pixel != WHITE:\n                if inner_color is None:\n                    inner_color = pixel\n                elif inner_color != pixel:\n                    return None # More than one color found, unexpected\n    return inner_color\n\ndef _is_adjacent_to_blue(grid: np.ndarray, r: int, c: int, h: int, w: int) -> bool:\n    \"\"\"\n    Checks if any red pixel of the frame border is adjacent (8-way) to a blue pixel.\n\n    Args:\n        grid: The input grid.\n        r, c, h, w: Frame definition (top_row, left_col, height, width).\n\n    Returns:\n        True if adjacent to blue, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n\n            # Check top/bottom border pixels\n            for i in range(w):\n                br_top, bc_top = r, c + i\n                br_bot, bc_bot = r + h - 1, c + i\n                \n                # Check neighbours of top border pixel\n                nr, nc = br_top + dr, bc_top + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == BLUE:\n                    return True\n                    \n                # Check neighbours of bottom border pixel\n                nr, nc = br_bot + dr, bc_bot + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == BLUE:\n                    return True\n\n            # Check left/right border pixels (excluding corners already checked)\n            for i in range(1, h - 1):\n                br_left, bc_left = r + i, c\n                br_right, bc_right = r + i, c + w - 1\n\n                # Check neighbours of left border pixel\n                nr, nc = br_left + dr, bc_left + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == BLUE:\n                    return True\n\n                # Check neighbours of right border pixel\n                nr, nc = br_right + dr, bc_right + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == BLUE:\n                    return True\n                    \n    return False\n\ndef _apply_transformation(output_grid: np.ndarray, r: int, c: int, h: int, w: int, c_in: int, c_out: int):\n    \"\"\"\n    Changes the color of the inner pattern within the frame boundaries.\n\n    Args:\n        output_grid: The grid to modify.\n        r, c, h, w: Frame definition.\n        c_in: The original color of the pattern.\n        c_out: The target color for the pattern.\n    \"\"\"\n    for ir in range(r + 1, r + h - 1):\n        for ic in range(c + 1, c + w - 1):\n            # Only change pixels matching the original inner color\n            if output_grid[ir, ic] == c_in:\n                output_grid[ir, ic] = c_out\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by identifying red frames and changing the color\n    of the pattern inside based on frame size, pattern color, and adjacency to blue.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid_np = grid_np.copy()\n\n    # Find all red frames\n    frames = _find_red_frames(grid_np)\n\n    # Process each frame\n    for r, c, h, w in frames:\n        # Identify the color inside the frame\n        c_in = _get_inner_color(grid_np, r, c, h, w)\n        \n        if c_in is None or c_in == WHITE or c_in == RED:\n            continue # Skip if no valid inner pattern color found\n\n        c_out = None\n        # Determine the target color based on frame size and inner color\n        if h == 5 and w == 5:\n            if c_in == MAGENTA:\n                # Special case for Magenta in 5x5 frame\n                if _is_adjacent_to_blue(grid_np, r, c, h, w):\n                    c_out = ORANGE\n                else:\n                    c_out = GREEN\n            elif c_in in TRANSFORM_5x5:\n                c_out = TRANSFORM_5x5[c_in]\n                \n        elif h == 7 and w == 7:\n            if c_in in TRANSFORM_7x7:\n                c_out = TRANSFORM_7x7[c_in]\n\n        # If a valid transformation rule was found, apply it\n        if c_out is not None:\n            _apply_transformation(output_grid_np, r, c, h, w, c_in, c_out)\n\n    # Convert the result back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8578,
    "candidates_token_count": 2962,
    "total_token_count": 11540,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.760632,
  "retries": 1
}