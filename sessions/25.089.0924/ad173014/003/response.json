{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Optional, Set\n\n\"\"\"\nTransforms the input grid based on patterns found within red rectangular frames.\n\nThe core logic involves:\n1. Identifying all distinct rectangular frames made of red (2) pixels.\n2. For each frame, determining its size (height x width, specifically 5x5 or 7x7).\n3. Identifying the single color of the pattern enclosed within the frame (ignoring the red frame pixels and white background pixels).\n4. Dynamically detecting the main L-shaped blue (1) border.\n5. Applying a color transformation rule to the enclosed pattern. This rule depends on:\n    a. The dimensions of the frame (5x5 or 7x7).\n    b. The original color of the enclosed pattern.\n    c. For 5x5 frames containing magenta (6) patterns, whether the frame is adjacent (including diagonals) to any blue (1) pixel belonging to the detected main L-shaped border.\n6. Preserving all other pixels (background, blue border, red frames) in their original positions.\n\nColor Transformation Rules:\n- If frame is 5x5:\n    - Green (3) -> Azure (8)\n    - Azure (8) -> Magenta (6)\n    - Orange (7) -> Green (3)\n    - Magenta (6):\n        - If adjacent to main Blue (1) border -> Orange (7)\n        - Else -> Green (3)\n- If frame is 7x7:\n    - Green (3) -> Azure (8)\n    - Azure (8) -> Yellow (4)\n    - Yellow (4) -> Green (3)\n\"\"\"\n\n# Define color constants for clarity\nWHITE = 0\nBLUE = 1\nRED = 2\nGREEN = 3\nYELLOW = 4\nMAGENTA = 6\nORANGE = 7\nAZURE = 8\n\n# Define transformation maps based on frame size\nTRANSFORM_5x5 = {\n    GREEN: AZURE,\n    AZURE: MAGENTA,\n    ORANGE: GREEN,\n    # Magenta is handled separately due to adjacency condition\n}\n\nTRANSFORM_7x7 = {\n    GREEN: AZURE,\n    AZURE: YELLOW,\n    YELLOW: GREEN,\n}\n\ndef _find_red_frames(grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all distinct red rectangular frames in the grid.\n    A frame is defined by red pixels forming a hollow rectangle.\n\n    Args:\n        grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of tuples, where each tuple represents a frame:\n        (top_row, left_col, height, width).\n    \"\"\"\n    frames = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check for potential top-left corner of a red frame that hasn't been visited\n            if grid[r, c] == RED and not visited[r, c]:\n                # Basic checks for top-left: no red directly above or left (unless edge)\n                is_top = (r == 0 or grid[r-1, c] != RED)\n                is_left = (c == 0 or grid[r, c-1] != RED)\n                # Must have red neighbours down and right to start a frame\n                has_right = (c + 1 < cols and grid[r, c+1] == RED)\n                has_down = (r + 1 < rows and grid[r+1, c] == RED)\n\n                if not (is_top and is_left and has_right and has_down):\n                    continue\n\n                # Determine width of the top edge\n                w = 1\n                while c + w < cols and grid[r, c + w] == RED:\n                    # Ensure this top edge isn't connected vertically upwards mid-way\n                    if r > 0 and grid[r-1, c+w] == RED:\n                        w = 0 # Invalid frame start\n                        break\n                    w += 1\n                if w <= 1: continue # Needs at least width 2\n\n                # Determine height of the left edge\n                h = 1\n                while r + h < rows and grid[r + h, c] == RED:\n                    # Ensure this left edge isn't connected horizontally leftwards mid-way\n                    if c > 0 and grid[r+h, c-1] == RED:\n                        h = 0 # Invalid frame start\n                        break\n                    h += 1\n                if h <= 1: continue # Needs at least height 2\n\n                # Verify the rectangle is closed and hollow\n                is_complete_frame = True\n                # Check bottom edge\n                if r + h - 1 >= rows: is_complete_frame = False; continue\n                for j in range(w):\n                    if c + j >= cols or grid[r + h - 1, c + j] != RED:\n                        is_complete_frame = False; break\n                if not is_complete_frame: continue\n\n                # Check right edge\n                if c + w - 1 >= cols: is_complete_frame = False; continue\n                for i in range(h):\n                     if r + i >= rows or grid[r + i, c + w - 1] != RED:\n                         is_complete_frame = False; break\n                if not is_complete_frame: continue\n\n                # Check if the inside is not red (must be hollow)\n                # We only need to check one internal pixel for this problem's constraints\n                if h > 2 and w > 2:\n                    if grid[r + 1, c + 1] == RED:\n                        # Check if the whole inside is red (solid block, not frame)\n                        is_solid = True\n                        for ir in range(r + 1, r + h - 1):\n                             for ic in range(c + 1, c + w - 1):\n                                 if ir>=rows or ic>=cols or grid[ir, ic] != RED:\n                                     is_solid = False\n                                     break\n                             if not is_solid: break\n                        if is_solid: continue # Skip solid red blocks\n\n                # Mark frame pixels as visited and add frame\n                # Use try-except for boundary checks, simpler than multiple ifs\n                try:\n                    frames.append((r, c, h, w))\n                    for i in range(h):\n                        visited[r + i, c] = True\n                        visited[r + i, c + w - 1] = True\n                    for j in range(w):\n                        visited[r, c + j] = True\n                        visited[r + h - 1, c + j] = True\n                except IndexError:\n                     # This case should ideally not happen with prior checks, but good safety\n                     continue\n\n    return frames\n\n\ndef _get_inner_color(grid: np.ndarray, r: int, c: int, h: int, w: int) -> Optional[int]:\n    \"\"\"\n    Finds the single dominant non-red, non-white color inside the frame boundaries.\n    Assumes frame height/width >= 3.\n\n    Args:\n        grid: The input grid.\n        r, c, h, w: Frame definition (top_row, left_col, height, width).\n\n    Returns:\n        The color code of the inner pattern, or None if no single pattern color found\n        or if inner area is empty/white/red.\n    \"\"\"\n    inner_color = None\n    # Iterate only within the inner area (excluding the frame border)\n    for ir in range(r + 1, r + h - 1):\n        for ic in range(c + 1, c + w - 1):\n            # Ensure indices are within bounds (should be, but safety check)\n            if ir >= grid.shape[0] or ic >= grid.shape[1]:\n                continue\n                \n            pixel = grid[ir, ic]\n            # Ignore background and frame color\n            if pixel != RED and pixel != WHITE:\n                if inner_color is None:\n                    inner_color = pixel\n                # If we find a different non-background/non-frame color, it's not a single pattern\n                elif inner_color != pixel:\n                    return None # More than one color found\n                    \n    return inner_color\n\ndef _detect_main_l_border(grid: np.ndarray) -> Set[Tuple[int, int]]:\n    \"\"\"\n    Detects the coordinates of the main L-shaped blue border.\n    Assumes the border is formed by the longest vertical blue segment\n    at the minimum blue column index, and the longest horizontal blue\n    segment at the maximum blue row index.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A set of (row, col) tuples representing the coordinates of the L-border.\n    \"\"\"\n    rows, cols = grid.shape\n    blue_coords = np.argwhere(grid == BLUE)\n    \n    if blue_coords.shape[0] == 0:\n        return set() # No blue pixels\n\n    main_border_coords = set()\n\n    # --- Find Vertical Part ---\n    min_c = np.min(blue_coords[:, 1])\n    vertical_candidates = sorted([coord[0] for coord in blue_coords if coord[1] == min_c])\n    \n    if vertical_candidates:\n        current_run_start = vertical_candidates[0]\n        current_run_len = 1\n        best_run_start = current_run_start\n        best_run_len = 1\n\n        for i in range(1, len(vertical_candidates)):\n            if vertical_candidates[i] == vertical_candidates[i-1] + 1:\n                current_run_len += 1\n            else:\n                if current_run_len > best_run_len:\n                    best_run_len = current_run_len\n                    best_run_start = current_run_start\n                current_run_start = vertical_candidates[i]\n                current_run_len = 1\n        \n        # Check the last run\n        if current_run_len > best_run_len:\n            best_run_len = current_run_len\n            best_run_start = current_run_start\n\n        # Add the longest contiguous vertical segment to the set\n        for r_idx in range(best_run_start, best_run_start + best_run_len):\n            main_border_coords.add((r_idx, min_c))\n\n    # --- Find Horizontal Part ---\n    max_r = np.max(blue_coords[:, 0])\n    horizontal_candidates = sorted([coord[1] for coord in blue_coords if coord[0] == max_r])\n\n    if horizontal_candidates:\n        current_run_start = horizontal_candidates[0]\n        current_run_len = 1\n        best_run_start = current_run_start\n        best_run_len = 1\n\n        for i in range(1, len(horizontal_candidates)):\n            if horizontal_candidates[i] == horizontal_candidates[i-1] + 1:\n                current_run_len += 1\n            else:\n                if current_run_len > best_run_len:\n                    best_run_len = current_run_len\n                    best_run_start = current_run_start\n                current_run_start = horizontal_candidates[i]\n                current_run_len = 1\n        \n        # Check the last run\n        if current_run_len > best_run_len:\n            best_run_len = current_run_len\n            best_run_start = current_run_start\n            \n        # Add the longest contiguous horizontal segment to the set\n        for c_idx in range(best_run_start, best_run_start + best_run_len):\n             main_border_coords.add((max_r, c_idx))\n\n    return main_border_coords\n\n\ndef _is_adjacent_to_main_border(grid: np.ndarray, r: int, c: int, h: int, w: int, main_border_coords: Set[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Checks if any red pixel of the specified frame's border is adjacent\n    (8-way connectivity) to a blue pixel belonging to the main L-border.\n\n    Args:\n        grid: The input grid.\n        r, c, h, w: Frame definition (top_row, left_col, height, width).\n        main_border_coords: A set of (row, col) tuples for the main border.\n\n    Returns:\n        True if the frame border is adjacent to the main blue border, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Iterate through all pixels forming the border of the frame\n    border_pixels = []\n    # Top and bottom rows\n    for j in range(w):\n        if r < rows and c + j < cols: border_pixels.append((r, c + j))\n        if r + h - 1 < rows and c + j < cols: border_pixels.append((r + h - 1, c + j))\n    # Left and right columns (excluding corners already added)\n    for i in range(1, h - 1):\n        if r + i < rows and c < cols: border_pixels.append((r + i, c))\n        if r + i < rows and c + w - 1 < cols: border_pixels.append((r + i, c + w - 1))\n\n    # Check 8 neighbours for each border pixel\n    for br, bc in border_pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n\n                nr, nc = br + dr, bc + dc\n\n                # Check if neighbour is within grid bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if neighbour is blue AND part of the main L-border set\n                    if grid[nr, nc] == BLUE and (nr, nc) in main_border_coords:\n                        return True # Found adjacency to the main border\n\n    return False # No adjacency found after checking all border pixels and neighbours\n\n\ndef _apply_transformation(output_grid: np.ndarray, r: int, c: int, h: int, w: int, c_in: int, c_out: int):\n    \"\"\"\n    Changes the color of the inner pattern within the frame boundaries.\n    Only pixels matching the original inner color (c_in) are changed.\n\n    Args:\n        output_grid: The grid to modify (numpy array).\n        r, c, h, w: Frame definition.\n        c_in: The original color of the pattern.\n        c_out: The target color for the pattern.\n    \"\"\"\n    rows, cols = output_grid.shape\n    # Iterate through the inner area of the frame\n    for ir in range(r + 1, r + h - 1):\n        for ic in range(c + 1, c + w - 1):\n            # Check bounds before accessing grid element\n            if 0 <= ir < rows and 0 <= ic < cols:\n                 # Only change pixels matching the original inner color\n                 if output_grid[ir, ic] == c_in:\n                    output_grid[ir, ic] = c_out\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Main function to transform the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid_np = grid_np.copy()\n\n    # Detect the main L-shaped blue border coordinates once\n    main_border_coords = _detect_main_l_border(grid_np)\n\n    # Find all red frames\n    frames = _find_red_frames(grid_np)\n\n    # Process each identified frame\n    for r, c, h, w in frames:\n        # Identify the color inside the frame\n        c_in = _get_inner_color(grid_np, r, c, h, w)\n\n        # Skip if no valid single inner pattern color found\n        if c_in is None or c_in == WHITE or c_in == RED:\n            continue\n\n        c_out = None # Target color initialization\n\n        # Determine the target color based on frame size and inner color\n        if h == 5 and w == 5:\n            if c_in == MAGENTA:\n                # Special case: Magenta in 5x5 frame depends on adjacency to main border\n                if _is_adjacent_to_main_border(grid_np, r, c, h, w, main_border_coords):\n                    c_out = ORANGE\n                else:\n                    c_out = GREEN\n            elif c_in in TRANSFORM_5x5:\n                # Standard 5x5 transformation\n                c_out = TRANSFORM_5x5[c_in]\n\n        elif h == 7 and w == 7:\n            if c_in in TRANSFORM_7x7:\n                # Standard 7x7 transformation\n                c_out = TRANSFORM_7x7[c_in]\n\n        # If a valid transformation rule resulted in a target color, apply it\n        if c_out is not None:\n            _apply_transformation(output_grid_np, r, c, h, w, c_in, c_out)\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24471,
    "candidates_token_count": 4153,
    "total_token_count": 28624,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.228257,
  "retries": 1
}