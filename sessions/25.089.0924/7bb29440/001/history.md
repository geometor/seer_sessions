
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 4 0 0 0 0 0 0
0 1 4 1 1 0 0 0 0 0 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 0
0 0 0 0 1 1 1 1 1 1 0
0 0 0 0 1 1 6 1 1 1 0
0 0 0 0 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 1 1 1 1 1
1 1 1 1 1 1
1 1 6 1 1 1
1 1 1 1 1 1
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 4 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 6 1 0 0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 6 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 0 0 0 1 1 6 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 4 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 6 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 1 1 1 4 1 0 0 0 0
0 0 1 1 1 1 1 4 1 0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 4 1 1 1 1 0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 6 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 1 4 1 1 1 0 0 0
0 0 1 1 4 1 1 6 1 0 0 0 1 1 1 6 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 6 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 4 1 1 1
1 1 1 6 1
6 1 1 1 1
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 6 1 4 1 0 0 0 1 1 1 1 1 1 0 0 0
0 1 1 4 1 1 1 1 1 0 0 0 1 1 6 1 1 1 0 0 0
0 1 1 1 1 4 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0
0 1 1 1 1 1 1 1 6 0 0 0 1 1 1 4 1 1 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 6 1 1 1 1 0 0 0
0 0 0 0 0 1 1 1 1 1 1 0 1 1 1 1 4 1 0 0 0
0 0 0 0 0 1 6 1 1 1 1 0 1 1 6 1 1 1 0 0 0
0 0 0 0 0 1 1 1 1 6 1 0 1 1 1 1 1 1 0 0 0
1 1 1 6 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 0 0
6 1 1 1 0 1 1 1 4 1 1 0 0 0 0 0 0 0 0 0 0
1 4 1 6 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 1 0 1 6 1 1 1 1 0 0 0 1 1 1 1 4 0 0
0 0 0 0 0 1 1 1 1 4 1 0 0 0 1 4 1 1 1 0 0
0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 6 1 0 0
0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 1 4 1 1 1 1 4 1 4 1 0
0 0 0 0 0 0 0 0 0 0 1 1 1 6 1 1 1 1 1 1 0
```


**output:**
```
1 1 1 1 4
1 4 1 1 1
1 1 1 6 1
1 1 1 1 1
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 4 1 1 1 1 0 0 0
0 0 0 0 0 0 1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 1 1 6 1 6 1 0 0 0
0 0 0 0 0 0 1 1 1 1 1 1 0 0 0
1 1 1 1 1 0 1 1 1 1 4 1 0 0 0
1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
1 4 1 1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
1 1 4 1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 0 0 0 0 1 1 1 1 1 1
1 1 1 1 1 0 0 0 0 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 1 6 1 6 1 1
1 1 1 1 4 0 0 0 0 1 1 4 1 1 1
1 4 1 1 1 0 0 0 0 1 1 1 1 1 1
1 1 6 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 4 1 1 6 1 4 1 1 0 0 0
0 0 0 0 1 4 1 1 1 1 6 1 0 0 0
```


**output:**
```
1 1 1 1 1
1 1 1 1 1
1 4 1 1 1
1 1 1 1 1
1 1 4 1 1
1 1 1 1 1
1 1 1 1 1
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 6 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 0 0 1 1 1 1 1 1 0 0 0 0 0 0
0 4 1 6 0 0 1 6 1 1 4 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 6 1 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 1 1 1 0 1 1 1 1 1
0 1 4 1 0 0 1 6 1 1 1 1 0 1 1 1 1 1
0 6 1 1 0 0 0 0 0 0 0 0 0 1 6 1 1 1
0 1 1 6 0 0 0 0 0 0 0 0 0 1 1 1 4 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 6 1 1 1 1 1 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1
0 0 1 1 1 1 1 1 1 1 4 1 0 0 1 1 6 1
0 0 1 1 1 6 1 1 1 6 1 1 0 0 6 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 4 1
0 0 1 1 1 1 1 6 1 1 1 1 0 0 0 0 0 0
0 0 1 4 1 1 1 1 1 1 1 1 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 1 1 1 1
1 1 1 1 1
1 6 1 1 1
1 1 1 4 1
1 1 1 1 1
```

## Perception

1.  **Input Structure:** The input grids contain a white (0) background with multiple distinct objects composed primarily of blue (1) pixels. These blue objects are often rectangular or L-shaped but can vary.
2.  **Embedded Colors:** Within these blue objects, there are often single pixels of yellow (4) and magenta (6). Some blue objects may contain multiple instances of these colors, while others might contain none or only one type.
3.  **Output Structure:** The output grid is always a single, solid object, primarily blue (1), sometimes containing magenta (6) pixels, but never yellow (4). The output grid dimensions are smaller than the input and match the bounding box of the selected object from the input.
4.  **Transformation:** The transformation involves selecting *one* of the blue objects from the input grid and producing it as the output.
5.  **Selection Criteria:** The key seems to be the presence and count of magenta (6) pixels within the blue objects. In each example, the blue object that appears in the output is the one containing the *most* magenta (6) pixels in the input. If there's a tie in the magenta count (or if no object has magenta), the specific selection rule needs further clarification, but the provided examples seem to have a unique object with the maximum magenta count. *Correction: In train\_4, two objects have two magenta pixels. However, one object has yellow pixels and the other does not. The output corresponds to the object *without* yellow pixels in this tie-breaker case. Let's re-examine. No, that's not right. Rereading train\_4: The top-right object has (1,4), (1,6), (1,6), (1,4). The bottom-right object has (1,6), (1,6), (1,4). The bottom-left object has (1,4), (1,4), (1,6). The middle-left object has (1,4), (1,4), (1,6). The object selected for output is the bottom-right one (6x3 rectangle), containing two 6s and one 4. Let's count 6s in others: top-right has two 6s, bottom-left has one 6, middle-left has one 6. So, there's a tie between top-right and bottom-right based *only* on the count of 6s. Let's count 4s: top-right has two 4s, bottom-right has one 4. The one with fewer 4s is selected in the tie? Let's check other examples. Train 2: Top-left object has one 6, two 4s. Bottom-right object has one 6, two 4s. Middle-right object has one 6, one 4. The middle-right is selected (fewest 4s among those tied for max 6s). Train 3: Top-left: two 6s, three 4s. Top-right: two 6s, two 4s. Bottom-left: three 6s, two 4s. Bottom-middle: two 6s, two 4s. Bottom-right: one 6, three 4s. The one with the most 6s (bottom-left) is selected. Train 5: Top-left: two 6s, two 4s. Top-middle: three 6s, two 4s. Top-right: one 6, one 4. Bottom-middle: three 6s, two 4s. Bottom-right: two 6s, two 4s. There's a tie between top-middle and bottom-middle for max 6s (three each). Both also have two 4s. How is the tie broken? Let's look at the objects themselves. Top-middle is 6x4. Bottom-middle is 8x4. The output is 8x4, corresponding to the bottom-middle object. So, if counts of 6s and 4s are tied, the larger object (by area? by height? by width?) is selected. Bottom-middle has area 32, top-middle has area 24. Seems like the larger area wins in a tie. Train 4 tie-breaker check: Top-right (6x3, area 18) vs Bottom-right (6x3, area 18). Areas are the same. Let's re-examine the pixels. Top-right object pixels: (2,6) to (6,11). Bottom-right object pixels: (11,9) to (16,14). The output corresponds to the bottom-right object. Is it the lower one? Or the rightmost one? In Train 5, the winner (bottom-middle) is lower than the other tied object (top-middle). So, the tie-breaker might be: largest area, then lowest top row index.
6.  **Color Modification:** After selecting the object, any yellow (4) pixels within its bounds are changed to blue (1). Magenta (6) pixels remain unchanged. All original blue (1) pixels also remain.

## Facts


```yaml
perception:
  background_color: white (0)
  objects:
    - type: primary_shape
      color: blue (1)
      connectivity: contiguous (including diagonals for pixel membership definition, but shapes themselves are separated by background)
      properties:
        - contains_pixels:
            - yellow (4)
            - magenta (6)
        - bounding_box: defines the extent of the shape
        - pixel_count: total number of non-background pixels within the shape
        - magenta_count: count of magenta (6) pixels within the shape
        - yellow_count: count of yellow (4) pixels within the shape
        - area: calculated from bounding_box dimensions or pixel_count
        - top_row_index: the minimum row index of any pixel in the shape
  relationships:
    - multiple primary_shape objects exist in the input grid, separated by the background_color.
  actions:
    - identify: find all distinct primary_shape objects in the input.
    - analyze: for each primary_shape object, count the occurrences of magenta (6) and yellow (4) pixels, determine its area, and find its top_row_index.
    - select: choose the primary_shape object based on the following criteria, applied sequentially:
        1. Maximum magenta_count.
        2. If tied, minimum yellow_count.
        3. If still tied, maximum area (pixel_count).
        4. If still tied, maximum top_row_index (lowest object visually).
    - extract: create a new grid containing only the selected primary_shape object, cropped to its bounding box.
    - modify: within the extracted grid, change all yellow (4) pixels to blue (1).
    - output: the modified, extracted grid.
```


## Natural Language Program

1.  Identify all distinct contiguous objects composed of non-white pixels in the input grid. Consider pixels connected orthogonally or diagonally as part of the same object if they are not white. Filter these to keep only objects that contain at least one blue (1) pixel (these are the primary shapes).
2.  For each primary shape identified:
    a.  Count the number of magenta (6) pixels it contains.
    b.  Count the number of yellow (4) pixels it contains.
    c.  Calculate its area (total number of non-white pixels belonging to it).
    d.  Determine the topmost row index occupied by any of its pixels.
3.  Select the target primary shape using the following priority:
    a.  The shape with the highest count of magenta (6) pixels.
    b.  If there is a tie in magenta count, select from the tied shapes the one with the lowest count of yellow (4) pixels.
    c.  If there is still a tie, select from the tied shapes the one with the largest area (pixel count).
    d.  If there is still a tie, select from the tied shapes the one that appears lowest in the grid (i.e., has the largest topmost row index).
4.  Determine the bounding box of the selected target shape.
5.  Create a new output grid with the dimensions of the bounding box.
6.  Copy the pixels of the selected target shape from the input grid into the new output grid, maintaining their relative positions within the bounding box.
7.  Iterate through the pixels of the new output grid. If a pixel is yellow (4), change its color to blue (1). Leave all other pixels (blue (1) and magenta (6)) unchanged.
8.  The resulting grid is the final output.
