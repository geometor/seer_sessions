{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct contiguous objects in the input grid composed of non-white (0) pixels, considering pixels connected orthogonally and diagonally (8-way connectivity). Filter this set to include only objects that contain at least one blue (1) pixel.\nFor each identified object:\n    a. Count the total number of magenta (6) pixels it contains (magenta_count).\n    b. Count the total number of yellow (4) pixels it contains (yellow_count).\n    c. Calculate its total area by counting all its non-white pixels (area).\n    d. Determine the topmost row index occupied by any of its pixels (top_row_index).\nSelect the target object using the following priority sequence:\n    a. The object with the highest magenta_count.\n    b. If there's a tie, select from the tied objects the one with the lowest yellow_count.\n    c. If there's still a tie, select from the tied objects the one with the largest area.\n    d. If there's still a tie, select from the tied objects the one that appears lowest in the grid (i.e., has the largest top_row_index).\nDetermine the minimum and maximum row and column indices (bounding box) of the selected target object.\nCreate a new output grid whose dimensions match the height and width of the bounding box.\nCopy each pixel belonging to the selected target object from the input grid into the new output grid, preserving its original color and adjusting its position relative to the top-left corner of the bounding box.\nFinally, iterate through the new output grid and change any yellow (4) pixels to blue (1). Leave all other pixel colors unchanged.\nThe resulting grid is the final output.\n\"\"\"\n\ndef find_objects_diag(grid):\n    \"\"\"\n    Finds all contiguous objects of non-white pixels in the grid using 8-way \n    (diagonal included) connectivity, keeping only those with at least one blue pixel.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of objects, where each object is represented as a list of \n              tuples (row, col, color).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-white and not visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                has_blue = False\n                \n                while q:\n                    row, col = q.popleft()\n                    color = grid[row, col]\n                    # Check if object contains blue\n                    if color == 1:\n                        has_blue = True\n                    obj_pixels.append((row, col, color))\n\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            # Check bounds, non-white color, and visited status\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != 0 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Add object to list only if it contained at least one blue pixel\n                if has_blue:\n                    objects.append(obj_pixels)\n                    \n    return objects\n\ndef analyze_object(obj_pixels):\n    \"\"\"\n    Analyzes an object (list of pixels) to calculate its properties for selection.\n\n    Args:\n        obj_pixels (list): List of (row, col, color) tuples for the object.\n\n    Returns:\n        dict: A dictionary containing 'magenta_count', 'yellow_count', \n              'area', 'top_row_index', and the original 'pixels'.\n    \"\"\"\n    magenta_count = 0\n    yellow_count = 0\n    min_r = float('inf')\n    \n    for r, c, color in obj_pixels:\n        if color == 6:\n            magenta_count += 1\n        elif color == 4:\n            yellow_count += 1\n        min_r = min(min_r, r) # Find the topmost row index\n        \n    area = len(obj_pixels) # Area is the total count of pixels in the object\n    \n    return {\n        'magenta_count': magenta_count,\n        'yellow_count': yellow_count,\n        'area': area,\n        'top_row_index': min_r,\n        'pixels': obj_pixels \n    }\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) of an object.\"\"\"\n    if not obj_pixels:\n        # Should not happen if objects are found, but handle defensively\n        return 0, 0, -1, -1 \n    rows = [p[0] for p in obj_pixels]\n    cols = [p[1] for p in obj_pixels]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier handling\n    grid_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct composite_shape objects using 8-way connectivity\n    #    that contain at least one blue pixel.\n    objects_pixels = find_objects_diag(grid_np)\n\n    # Handle case where no valid objects are found\n    if not objects_pixels:\n        return [] # Return empty grid \n\n    # 2. Analyze each object's properties (M, Y, Area, Top Row)\n    analyzed_objects = [analyze_object(obj) for obj in objects_pixels]\n\n    # 3. Select the target object based on sorting criteria:\n    #    - Maximize magenta_count (negative for descending sort)\n    #    - Minimize yellow_count (positive for ascending sort)\n    #    - Maximize area (negative for descending sort)\n    #    - Maximize top_row_index (negative for descending sort, lowest object visually)\n    analyzed_objects.sort(key=lambda x: (\n        -x['magenta_count'], \n         x['yellow_count'], \n        -x['area'], \n        -x['top_row_index'] \n    ))\n    \n    # The best object is the first one after sorting\n    selected_object = analyzed_objects[0]\n    selected_pixels = selected_object['pixels']\n\n    # 4. Determine bounding box of the selected object\n    min_r, min_c, max_r, max_c = get_bounding_box(selected_pixels)\n    \n    # Calculate output grid dimensions\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # 5. Create the output grid (initialize with background color 0)\n    output_grid_np = np.zeros((height, width), dtype=int) \n\n    # 6. Copy pixels from the selected object to the output grid, adjusting coordinates\n    for r, c, color in selected_pixels:\n        # Adjust coordinates to be relative to the output grid's top-left corner\n        out_r, out_c = r - min_r, c - min_c\n        # Preserve the original color for now\n        output_grid_np[out_r, out_c] = color \n\n    # 7. Modify the output grid: change yellow (4) pixels to blue (1)\n    output_grid_np[output_grid_np == 4] = 1\n\n    # Convert the final numpy array back to a list of lists for the expected format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20191,
    "candidates_token_count": 1945,
    "total_token_count": 22136,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.165966,
  "retries": 1
}