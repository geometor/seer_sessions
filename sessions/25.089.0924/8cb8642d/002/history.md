
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 1 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 1 0 0 0 0 1 2 0 0 0 0 0 0
0 2 0 1 0 0 1 0 2 0 0 0 0 0 0
0 2 0 0 1 1 0 0 2 0 0 0 0 0 0
0 2 0 1 0 0 1 0 2 0 0 0 0 0 0
0 2 1 0 0 0 0 1 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 6 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 6 0 0 0 0 0 6 3 0 0 0
0 0 3 0 6 0 0 0 6 0 3 0 0 0
0 0 3 0 0 6 0 6 0 0 3 0 0 0
0 0 3 0 0 0 6 0 0 0 3 0 0 0
0 0 3 0 0 0 6 0 0 0 3 0 0 0
0 0 3 0 0 6 0 6 0 0 3 0 0 0
0 0 3 0 6 0 0 0 6 0 3 0 0 0
0 0 3 6 0 0 0 0 0 6 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 2 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 2 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 3 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 2 0 0 0 2 1 0 0 3 2 0 0 2 3 0
0 0 1 0 2 0 2 0 1 0 0 3 0 2 2 0 3 0
0 0 1 0 0 2 0 0 1 0 0 3 0 2 2 0 3 0
0 0 1 0 2 0 2 0 1 0 0 3 2 0 0 2 3 0
0 0 1 2 0 0 0 2 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 3 4 0
0 0 0 0 0 0 4 0 3 0 0 0 0 0 3 0 4 0
0 0 0 0 0 0 4 0 0 3 3 3 3 3 0 0 4 0
0 0 0 0 0 0 4 0 3 0 0 0 0 0 3 0 4 0
0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 3 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception of the Elements:**

The input grids typically contain one or more large, solid-colored rectangular objects set against a white (0) background. Crucially, each of these main rectangular objects contains exactly one pixel of a different color somewhere within its boundaries. This single different-colored pixel acts as a "seed" or "source" for the transformation.

The transformation modifies the *interior* of these rectangular objects, leaving the white background and the border pixels of the rectangles unchanged. The modification involves creating a pattern radiating outwards from the location of the "seed" pixel. The pattern uses the color of the seed pixel and the white color (0). Specifically, pixels within the rectangle's interior (excluding the border) change color based on their Manhattan distance from the seed pixel: pixels at odd distances take the seed pixel's color, while pixels at even, non-zero distances turn white (0). The original seed pixel retains its color (distance 0). This process happens independently for each rectangular object present in the input.

**Facts:**


```yaml
task_description: Modify the interior of rectangular objects based on a single 'seed' pixel within each.
items:
  - item_type: background
    color: white (0)
    description: The default background color of the grid. Remains unchanged.
  - item_type: object
    shape: rectangle
    description: Solid-colored rectangles are the primary elements. Multiple can exist.
    properties:
      - border_color: The main color of the rectangle.
      - border_pixels: Pixels forming the outer edge of the rectangle. Remain unchanged.
      - interior_pixels: Pixels inside the border. These are subject to transformation.
  - item_type: seed_pixel
    description: A single pixel within each rectangle that has a different color than the rectangle's border_color.
    properties:
      - color: The color of the seed pixel (seed_color). Used in the output pattern.
      - location: The (row, column) coordinates of the seed pixel. Acts as the center for the pattern.
relationship:
  - type: containment
    item1: seed_pixel
    item2: object
    description: Each rectangular object contains exactly one seed_pixel.
action:
  - name: pattern_generation
    input: object, seed_pixel
    output: modified interior_pixels
    description: |
      For each pixel within the object's interior (excluding the border):
      1. Calculate the Manhattan distance (d) from the pixel to the seed_pixel's location.
      2. If d is 0 (the seed pixel itself), the color remains the seed_color.
      3. If d is odd, the pixel's color becomes the seed_color.
      4. If d is even and non-zero, the pixel's color becomes white (0).
invariants:
  - Grid dimensions remain the same.
  - Background pixels (white) remain unchanged.
  - Border pixels of the rectangular objects remain unchanged.
  - The location and color of the seed pixel itself define the center and color of the odd-distance pattern elements.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all distinct rectangular objects in the input grid. A rectangular object is a contiguous block of pixels of the same color (color C1), surrounded by the background color (white, 0) or the grid boundaries.
3.  For each identified rectangular object:
    a.  Find the single pixel *inside* this object that has a different color (color C2) than the object's main color (C1). This is the "seed pixel". Record its color (C2) and its location (seed\_row, seed\_col).
    b.  Identify all pixels that belong to this object but are *not* part of its outer border (these are the "interior pixels").
    c.  For each interior pixel at location (row, col):
        i.  Calculate the Manhattan distance: `distance = abs(row - seed_row) + abs(col - seed_col)`.
        ii. If `distance` is 0, do nothing (the pixel keeps its original seed color C2).
        iii.If `distance` is odd, change the color of the pixel at (row, col) in the *output grid* to the seed color (C2).
        iv. If `distance` is even and greater than 0, change the color of the pixel at (row, col) in the *output grid* to white (0).
4.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies rectangular objects in the input grid, each containing exactly one 'seed' pixel of a different color.
For each object, it modifies the interior pixels (excluding the border) based on their Manhattan distance from the seed pixel.
Pixels at odd distances from the seed take the seed's color.
Pixels at even, non-zero distances from the seed turn white (0).
The border pixels of the rectangle and the background remain unchanged.
"""

def find_objects(grid):
    """
    Finds all distinct rectangular objects with a single internal seed pixel.

    Args:
        grid (np.array): The input grid.

    Returns:
        list: A list of tuples, where each tuple represents an object and contains:
              (border_color, bounding_box, seed_color, seed_location)
              bounding_box = (min_row, max_row, min_col, max_col)
              seed_location = (seed_row, seed_col)
    """
    objects = []
    H, W = grid.shape
    visited = np.zeros_like(grid, dtype=bool)

    for r in range(H):
        for c in range(W):
            # Skip visited cells or background
            if visited[r, c] or grid[r, c] == 0:
                continue

            # Potential start of a new object found
            component_pixels = set()
            potential_seeds = []
            q = deque([(r, c)])
            bfs_visited_local = set([(r, c)]) # Visited set for this specific BFS run

            # --- Perform BFS to find all connected non-background pixels ---
            while q:
                curr_r, curr_c = q.popleft()

                # Check if this pixel was already globally visited (e.g., part of a previously identified object)
                # This check might be redundant if we correctly mark visited after processing an object,
                # but serves as a safeguard.
                if visited[curr_r, curr_c]:
                     continue

                px_color = grid[curr_r, curr_c]
                component_pixels.add((curr_r, curr_c))

                # Explore neighbors (4-directional)
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = curr_r + dr, curr_c + dc

                    # Check bounds
                    if 0 <= nr < H and 0 <= nc < W:
                        # If neighbor is not background and not visited in this BFS run
                        if grid[nr, nc] != 0 and (nr, nc) not in bfs_visited_local:
                            bfs_visited_local.add((nr, nc))
                            q.append((nr, nc))

            # --- Analyze the found component ---
            if not component_pixels: # Should not happen if we start on a non-zero pixel
                continue

            # Identify potential seed pixels (pixels within the component with a different color)
            # And determine the most likely border color
            pixel_colors = [grid[pr, pc] for pr, pc in component_pixels]
            color_counts = {}
            for color in pixel_colors:
                color_counts[color] = color_counts.get(color, 0) + 1

            if len(color_counts) != 2:
                 # Valid objects must have exactly two colors: border and seed
                 # Mark these pixels as visited globally and continue
                 for pr, pc in component_pixels:
                    visited[pr, pc] = True
                 continue

            # Find the minority color (seed) and majority color (border)
            sorted_colors = sorted(color_counts.items(), key=lambda item: item[1])
            seed_color, seed_count = sorted_colors[0]
            border_color, border_count = sorted_colors[1]

            if seed_count != 1:
                 # Must have exactly one seed pixel
                 for pr, pc in component_pixels:
                    visited[pr, pc] = True
                 continue

            # Find the location of the single seed pixel
            seed_loc = None
            for pr, pc in component_pixels:
                if grid[pr, pc] == seed_color:
                    seed_loc = (pr, pc)
                    break

            # Calculate bounding box (tight fit around the component pixels)
            min_r = min(pr for pr, pc in component_pixels)
            max_r = max(pr for pr, pc in component_pixels)
            min_c = min(pc for pr, pc in component_pixels)
            max_c = max(pc for pr, pc in component_pixels)
            bbox = (min_r, max_r, min_c, max_c)

            # Basic rectangle check: verify all pixels on the border *of the component* within the bbox have the border color
            is_rect = True
            for pr, pc in component_pixels:
                 # Check if pixel is on the component's bounding box edge
                 on_border = (pr == min_r or pr == max_r or pc == min_c or pc == max_c)
                 if on_border and grid[pr,pc] == seed_color:
                     is_rect = False # Seed pixel cannot be on the bounding box edge for the pattern rule
                     break
            if not is_rect:
                 for pr, pc in component_pixels:
                    visited[pr, pc] = True
                 continue


            # Add the found object
            objects.append((border_color, bbox, seed_color, seed_loc))

            # Mark component pixels as globally visited
            for pr, pc in component_pixels:
                visited[pr, pc] = True

    return objects


def transform(input_grid):
    """
    Transforms the input grid based on identified rectangular objects and their seeds.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    input_np = np.array(input_grid, dtype=int)
    output_np = input_np.copy()
    H, W = input_np.shape

    # Find all objects (rectangles with one seed)
    objects = find_objects(input_np)

    # Apply the transformation for each object
    for border_color, bbox, seed_color, seed_loc in objects:
        min_r, max_r, min_c, max_c = bbox
        seed_r, seed_c = seed_loc

        # Iterate through the *interior* of the bounding box
        # The border pixels (min_r, max_r, min_c, max_c) should remain unchanged.
        for r in range(min_r + 1, max_r):
            for c in range(min_c + 1, max_c):
                # Calculate Manhattan distance to the seed
                distance = abs(r - seed_r) + abs(c - seed_c)

                # Apply coloring rule based on distance
                if distance == 0:
                    # Seed pixel retains its color (already set in copy)
                    # output_np[r, c] = seed_color # Explicitly set for clarity
                    pass
                elif distance % 2 == 1:
                    # Odd distance -> seed color
                    output_np[r, c] = seed_color
                else: # distance % 2 == 0 and distance > 0
                    # Even positive distance -> white color
                    output_np[r, c] = 0

    # Convert back to list of lists
    return output_np.tolist()
```
