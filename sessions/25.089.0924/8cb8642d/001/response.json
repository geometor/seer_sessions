{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies rectangular objects in the input grid, each containing exactly one 'seed' pixel of a different color.\nFor each object, it modifies the interior pixels (excluding the border) based on their Manhattan distance from the seed pixel.\nPixels at odd distances from the seed take the seed's color.\nPixels at even, non-zero distances from the seed turn white (0).\nThe border pixels of the rectangle and the background remain unchanged.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all distinct rectangular objects with a single internal seed pixel.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object and contains:\n              (border_color, bounding_box, seed_color, seed_location)\n              bounding_box = (min_row, max_row, min_col, max_col)\n              seed_location = (seed_row, seed_col)\n    \"\"\"\n    objects = []\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(H):\n        for c in range(W):\n            # Skip visited cells or background\n            if visited[r, c] or grid[r, c] == 0:\n                continue\n\n            # Potential start of a new object found\n            component_pixels = set()\n            potential_seeds = []\n            q = deque([(r, c)])\n            bfs_visited_local = set([(r, c)]) # Visited set for this specific BFS run\n\n            # --- Perform BFS to find all connected non-background pixels ---\n            while q:\n                curr_r, curr_c = q.popleft()\n\n                # Check if this pixel was already globally visited (e.g., part of a previously identified object)\n                # This check might be redundant if we correctly mark visited after processing an object,\n                # but serves as a safeguard.\n                if visited[curr_r, curr_c]:\n                     continue\n\n                px_color = grid[curr_r, curr_c]\n                component_pixels.add((curr_r, curr_c))\n\n                # Explore neighbors (4-directional)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = curr_r + dr, curr_c + dc\n\n                    # Check bounds\n                    if 0 <= nr < H and 0 <= nc < W:\n                        # If neighbor is not background and not visited in this BFS run\n                        if grid[nr, nc] != 0 and (nr, nc) not in bfs_visited_local:\n                            bfs_visited_local.add((nr, nc))\n                            q.append((nr, nc))\n\n            # --- Analyze the found component ---\n            if not component_pixels: # Should not happen if we start on a non-zero pixel\n                continue\n\n            # Identify potential seed pixels (pixels within the component with a different color)\n            # And determine the most likely border color\n            pixel_colors = [grid[pr, pc] for pr, pc in component_pixels]\n            color_counts = {}\n            for color in pixel_colors:\n                color_counts[color] = color_counts.get(color, 0) + 1\n\n            if len(color_counts) != 2:\n                 # Valid objects must have exactly two colors: border and seed\n                 # Mark these pixels as visited globally and continue\n                 for pr, pc in component_pixels:\n                    visited[pr, pc] = True\n                 continue\n\n            # Find the minority color (seed) and majority color (border)\n            sorted_colors = sorted(color_counts.items(), key=lambda item: item[1])\n            seed_color, seed_count = sorted_colors[0]\n            border_color, border_count = sorted_colors[1]\n\n            if seed_count != 1:\n                 # Must have exactly one seed pixel\n                 for pr, pc in component_pixels:\n                    visited[pr, pc] = True\n                 continue\n\n            # Find the location of the single seed pixel\n            seed_loc = None\n            for pr, pc in component_pixels:\n                if grid[pr, pc] == seed_color:\n                    seed_loc = (pr, pc)\n                    break\n\n            # Calculate bounding box (tight fit around the component pixels)\n            min_r = min(pr for pr, pc in component_pixels)\n            max_r = max(pr for pr, pc in component_pixels)\n            min_c = min(pc for pr, pc in component_pixels)\n            max_c = max(pc for pr, pc in component_pixels)\n            bbox = (min_r, max_r, min_c, max_c)\n\n            # Basic rectangle check: verify all pixels on the border *of the component* within the bbox have the border color\n            is_rect = True\n            for pr, pc in component_pixels:\n                 # Check if pixel is on the component's bounding box edge\n                 on_border = (pr == min_r or pr == max_r or pc == min_c or pc == max_c)\n                 if on_border and grid[pr,pc] == seed_color:\n                     is_rect = False # Seed pixel cannot be on the bounding box edge for the pattern rule\n                     break\n            if not is_rect:\n                 for pr, pc in component_pixels:\n                    visited[pr, pc] = True\n                 continue\n\n\n            # Add the found object\n            objects.append((border_color, bbox, seed_color, seed_loc))\n\n            # Mark component pixels as globally visited\n            for pr, pc in component_pixels:\n                visited[pr, pc] = True\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified rectangular objects and their seeds.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy()\n    H, W = input_np.shape\n\n    # Find all objects (rectangles with one seed)\n    objects = find_objects(input_np)\n\n    # Apply the transformation for each object\n    for border_color, bbox, seed_color, seed_loc in objects:\n        min_r, max_r, min_c, max_c = bbox\n        seed_r, seed_c = seed_loc\n\n        # Iterate through the *interior* of the bounding box\n        # The border pixels (min_r, max_r, min_c, max_c) should remain unchanged.\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                # Calculate Manhattan distance to the seed\n                distance = abs(r - seed_r) + abs(c - seed_c)\n\n                # Apply coloring rule based on distance\n                if distance == 0:\n                    # Seed pixel retains its color (already set in copy)\n                    # output_np[r, c] = seed_color # Explicitly set for clarity\n                    pass\n                elif distance % 2 == 1:\n                    # Odd distance -> seed color\n                    output_np[r, c] = seed_color\n                else: # distance % 2 == 0 and distance > 0\n                    # Even positive distance -> white color\n                    output_np[r, c] = 0\n\n    # Convert back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4802,
    "candidates_token_count": 1774,
    "total_token_count": 6576,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.622563,
  "retries": 1
}