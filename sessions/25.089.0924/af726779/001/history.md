
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
7 3 7 3 7 3 7 3 7 7 3 7 3 7 3 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
7 3 7 3 7 3 7 3 7 7 3 7 3 7 3 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 6 3 6 3 6 3 6 3 3 6 3 6 3 6 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 7 3 7 3 7 3 3 3 3 7 3 7 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 6 3 6 3 3 3 3 3 3 6 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 7 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
7 7 7 3 7 3 7 3 7 7 3 7 3 7 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
7 7 7 3 7 3 7 3 7 7 3 7 3 7 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 6 3 6 3 6 3 3 6 3 6 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 7 3 7 3 3 3 3 7 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 7 3 7 7 7 3 7 7 3 7 7 3 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 7 3 7 7 7 3 7 7 3 7 7 3 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 6 3 3 3 6 3 3 6 3 3 6 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

Okay, let's analyze the task based on the provided examples.

**Perception**

1.  **Input Structure:** The input grids consist of a background color (green - 3) and typically one horizontal row containing a pattern of orange (7) and green (3) pixels.
2.  **Output Structure:** The output grids are identical in size to the input grids. They retain all the pixels from the input grid and add new pixels (magenta - 6 and orange - 7) in rows below the initial orange-containing row.
3.  **Transformation Goal:** The task is to determine the rules for placing the new magenta and orange pixels based on the patterns found in the input grid, and potentially patterns created by newly added pixels in an iterative manner.
4.  **Key Pattern Recognition:** The placement of new pixels seems dependent on specific horizontal 3-pixel patterns centered on a green (3) pixel within a relevant row.
    *   The pattern `orange (7) - green (3) - orange (7)` seems to trigger the placement of a magenta (6) pixel two rows below the central green pixel.
    *   The pattern `magenta (6) - green (3) - magenta (6)` seems to trigger the placement of an orange (7) pixel two rows below the central green pixel.
5.  **Iterative Process:** The generation of new pixels can create new patterns, which in turn trigger the generation of further pixels in subsequent rows below. This process continues until no new patterns that trigger pixel generation are found. The generation cascades downwards.

**Facts (YAML)**


```yaml
Input_Grid:
  Properties:
    - Contains a background color, typically green (3).
    - Contains at least one 'source' row featuring orange (7) pixels mixed with green (3) pixels.
  Objects:
    - Background: Contiguous areas of green (3).
    - Source Row Pattern: A sequence of orange (7) and green (3) pixels in a specific row.

Output_Grid:
  Properties:
    - Same dimensions as the input grid.
    - Contains all pixels from the input grid.
    - Contains additional pixels: magenta (6) and orange (7).
  Objects:
    - Generated Pixels: Magenta (6) and Orange (7) pixels added based on rules.

Transformations:
  - Action: Pattern Detection and Pixel Placement.
  - Rule 1 (Magenta Generation):
      - Trigger: A horizontal sequence `orange (7) - green (3) - orange (7)` found in a row `R` at column `C` (for the green pixel).
      - Effect: Place a magenta (6) pixel at row `R+2`, column `C` in the output grid.
  - Rule 2 (Orange Generation):
      - Trigger: A horizontal sequence `magenta (6) - green (3) - magenta (6)` found in a row `R` at column `C` (for the green pixel).
      - Effect: Place an orange (7) pixel at row `R+2`, column `C` in the output grid.
  - Process: Iterative Application.
      - Start with the source row(s) from the input.
      - Apply Rule 1 and Rule 2 to generate new pixels two rows below.
      - Treat rows containing newly generated pixels as potential sources for subsequent iterations.
      - Continue applying rules iteratively until no new pixels are generated in an iteration.

Relationships:
  - Spatial: New pixels are placed two rows directly below the center of the triggering 3-pixel horizontal pattern.
  - Dependency: The placement of orange (7) pixels depends on the prior placement of magenta (6) pixels, which in turn depends on the initial orange (7) patterns (or patterns generated in previous iterations).
  - Color Mapping: Input orange (7) influences magenta (6) generation; generated magenta (6) influences orange (7) generation.
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all row indices in the input grid that contain at least one orange (7) pixel. Store these indices in a set called `active_rows`.
3.  Start an iterative process that continues as long as `active_rows` is not empty.
4.  Inside the iteration, create two empty sets: `newly_added_magenta_rows` and `newly_added_orange_rows`.
5.  Create a temporary grid or buffer to store pixels added in the *current* iteration to avoid them triggering rules within the same iteration step.
6.  For each `row_index` in the current `active_rows`:
    a.  Iterate through each column index `col_index` from 1 to `width - 2` (to allow checking neighbors).
    b.  **Check for Magenta Generation Rule**: Examine the triplet of pixels at `(row_index, col_index - 1)`, `(row_index, col_index)`, `(row_index, col_index + 1)` in the *current state* of the output grid. If this triplet matches `orange (7), green (3), orange (7)`, then check if `row_index + 2` is within the grid height. If it is, mark the pixel at `(row_index + 2, col_index)` in the temporary buffer to become magenta (6) and add `row_index + 2` to `newly_added_magenta_rows`.
    c.  **Check for Orange Generation Rule**: Examine the triplet of pixels at `(row_index, col_index - 1)`, `(row_index, col_index)`, `(row_index, col_index + 1)` in the *current state* of the output grid. If this triplet matches `magenta (6), green (3), magenta (6)`, then check if `row_index + 2` is within the grid height. If it is, mark the pixel at `(row_index + 2, col_index)` in the temporary buffer to become orange (7) and add `row_index + 2` to `newly_added_orange_rows`.
7.  After checking all active rows and columns, update the output grid with the pixels marked in the temporary buffer.
8.  Update the `active_rows`
