
## train_1

**input:**
```
1 1 0 3 3 0 2 2 0 5 5 5 0 5 5 5 0 5 5 5
1 1 0 3 3 0 2 2 0 5 0 5 0 0 5 0 0 5 0 0
0 0 0 0 0 0 0 0 0 5 5 5 0 5 5 5 0 5 5 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 3 2 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 3 2 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
1 0 1 2 0 0 0 3 0 1 0 1 2 0 0
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
2 0 0 1 0 1 0 3 0 2 0 0 1 0 1
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 3 0 0 3 0 0 3 0 0 3 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
1 0 1 2 0 0 0 3 0 1 0 1 2 0 0
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
2 0 0 1 0 1 0 3 0 2 0 0 1 0 1
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
```


## train_2

**input:**
```
2 2 0 4 4 0 5 5 5 5 5 0 5 5 5 5 5
2 2 0 4 4 0 5 0 0 0 0 0 5 0 0 0 5
0 0 0 0 0 0 5 0 5 5 5 0 5 0 5 5 5
0 0 0 0 0 0 5 0 0 0 0 0 5 0 5 5 0
0 0 0 0 0 0 5 5 5 5 5 0 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 2 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
4 4 4 4 4 2 2 2 2 2 4 4 4 4 4 2 2 2 2 2
4 0 0 0 4 2 0 0 0 0 4 0 0 0 4 2 0 0 0 0
4 0 4 4 4 2 0 2 2 2 4 0 4 4 4 2 0 2 2 2
4 0 4 4 0 2 0 0 0 0 4 0 4 4 0 2 0 0 0 0
4 4 4 0 0 2 2 2 2 2 4 4 4 0 0 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 2 2 2 2 2
2 0 0 0 0 2 0 0 0 0 4 0 0 0 4 2 0 0 0 0
2 0 2 2 2 2 0 2 2 2 4 0 4 4 4 2 0 2 2 2
2 0 0 0 0 2 0 0 0 0 4 0 4 4 0 2 0 0 0 0
2 2 2 2 2 2 2 2 2 2 4 4 4 0 0 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2
4 0 0 0 4 4 0 0 0 4 4 0 0 0 4 2 0 0 0 0
4 0 4 4 4 4 0 4 4 4 4 0 4 4 4 2 0 2 2 2
4 0 4 4 0 4 0 4 4 0 4 0 4 4 0 2 0 0 0 0
4 4 4 0 0 4 4 4 0 0 4 4 4 0 0 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0
2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2
2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
8 8 0 1 1 0 5 5 5 5 5 0 5 5 5 5 5
8 8 0 1 1 0 5 0 0 0 5 0 5 0 0 0 5
0 0 0 0 0 0 5 0 5 0 5 0 5 0 5 0 5
0 0 0 0 0 0 5 0 5 5 5 0 5 5 5 0 5
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
```

Okay, let's break down the perception and logic of this task.

**Perception of Elements:**

1.  **Input Grid Structure:** The input grids consistently show distinct zones separated by white (0) pixels.
    *   **Top-Left Zone:** Contains small, solid 2x2 squares of various colors (blue, green, red, yellow, azure). These seem to act as color keys or identifiers.
    *   **Top-Right Zone:** Contains larger 5x5 patterns primarily composed of gray (5) pixels against a white (0) background. These appear to be templates or value patterns associated with the keys. The number of these 5x5 patterns matches the number of distinct key colors in the top-left zone.
    *   **Bottom-Left Zone:** Contains a pattern made up of the same colors found in the top-left key squares. This pattern looks like a blueprint or an arrangement guide for the output.
    *   **White Space:** White (0) pixels act as separators between these zones and as the background within the patterns.

2.  **Output Grid Structure:** The output grids are significantly larger and appear to be constructed by tiling 5x5 blocks.
    *   **Tiling:** The output is a composite grid where each element from the bottom-left input pattern corresponds to a 5x5 block in the output.
    *   **Pattern Replication:** The shapes within the 5x5 output blocks mirror the shapes found in the 5x5 gray patterns from the top-right of the input.
    *   **Color Substitution:** The colors used within each 5x5 output block are *not* gray (5). Instead, they match the color specified by the corresponding cell in the bottom-left input pattern. White (0) pixels from the template patterns remain white (0) in the output.

**Facts (YAML):**


```yaml
task_description: Tile a grid based on a color-to-pattern mapping and an arrangement grid derived from the input.

input_components:
  - component: Key Zone
    location: Top-left section of the input grid.
    description: Contains small (2x2) solid color squares separated by white space. Each color acts as a unique key.
    properties:
      - colors: Variable, depends on the example (e.g., [blue, green, red], [red, yellow], [azure, blue]).
      - size: Each key object is 2x2.
  - component: Value Zone
    location: Top-right section of the input grid.
    description: Contains larger (5x5) patterns, primarily using gray pixels, separated by white space. These are the value patterns.
    properties:
      - base_color: Gray (5).
      - background_color: White (0).
      - size: Each value pattern is 5x5.
      - count: The number of value patterns matches the number of distinct key colors.
      - mapping: Implicitly mapped to the key colors based on horizontal order (first key color maps to first value pattern, etc.).
  - component: Arrangement Zone
    location: Bottom-left section of the input grid.
    description: A grid pattern using the same colors found in the Key Zone. This defines the layout for the output grid.
    properties:
      - colors: Uses colors from the Key Zone.
      - background_color: White (0).
      - size: Variable height and width. Determines the macro-structure of the output.

output_components:
  - component: Tiled Grid
    description: A larger grid constructed by placing 5x5 blocks.
    properties:
      - block_size: 5x5.
      - structure: The arrangement of blocks follows the Arrangement Zone pattern from the input.
      - content: Each 5x5 block is a copy of a Value Zone pattern, but recolored.
      - recoloring_rule: For a block corresponding to a cell with color 'C' in the Arrangement Zone, the associated Value Zone pattern is retrieved, and all its non-white pixels are replaced with color 'C'. White pixels remain white.
      - dimensions: (height of Arrangement Zone * 5) rows x (width of Arrangement Zone * 5) columns.

relationships:
  - type: Mapping
    from: Key Zone colors
    to: Value Zone patterns (based on order).
  - type: Templating
    source: Arrangement Zone
    target: Output Grid structure.
  - type: Instantiation & Recoloring
    source_pattern: Value Zone pattern (selected via mapping).
    source_color: Arrangement Zone cell color.
    target: 5x5 block in the Output Grid.

constants:
  - background_color: White (0)
  - template_pattern_size: 5x5
  - key_pattern_size: 2x2 (though size isn't directly used, presence matters)
  - template_base_color: Gray (5) (in the input Value Zone)
```


**Natural Language Program:**

1.  **Analyze Input:** Divide the input grid into three main zones based on contiguous blocks of non-white pixels separated by white rows/columns: the Key Zone (top-left, small squares), the Value Zone (top-right, 5x5 gray patterns), and the Arrangement Zone (bottom-left, colored pattern).
2.  **Extract Keys:** Identify the distinct non-white colors present in the 2x2 squares within the Key Zone. Record these colors in their order of appearance (left-to-right, top-to-bottom).
3.  **Extract Values:** Identify the 5x5 patterns within the Value Zone. Record these patterns in their order of appearance.
4.  **Establish Mapping:** Create a mapping where each key color (from step 2) corresponds to a value pattern (from step 3) based on their respective orders.
5.  **Extract Arrangement:** Identify the grid pattern within the Arrangement Zone. This is the template for the output structure.
6.  **Determine Output Size:** Calculate the output grid dimensions: the height will be (height of Arrangement Zone grid) * 5, and the width will be (width of Arrangement Zone grid) * 5.
7.  **Initialize Output:** Create an empty output grid of the calculated size, filled with the background color (white, 0).
8.  **Construct Output:** Iterate through each cell `(r, c)` of the Arrangement Zone grid:
    *   Let `key_color` be the color at `ArrangementZone[r][c]`.
    *   If `key_color` is not the background color (white, 0):
        *   Retrieve the `value_pattern` (a 5x5 grid) associated with `key_color` using the mapping from step 4.
        *   Create a `recolored_pattern` (a 5x5 grid) by iterating through the `value_pattern`:
            *   If a pixel in `value_pattern` is *not* white (0), set the corresponding pixel in `recolored_pattern` to `key_color`.
            *   If a pixel in `value_pattern` *is* white (0), set the corresponding pixel in `recolored_pattern` to white (0).
        *   Place the `recolored_pattern` into the output grid, starting at the top-left corner `(r * 5, c * 5)`.
9.  **Finalize:** The completed output grid is the result.
