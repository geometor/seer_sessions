
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5
5 6 5
5 5 5
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8
8 3 3 3 8
8 3 2 3 8
8 3 3 3 8
8 8 8 8 8
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3
3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 1 1 1 1 1 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 1 1 1 1 1 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 1 1 1 1 1 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 2 2 2 2 2 2 2 2 2 8 8 8 3 3 3 3 3
3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3
3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3
3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3
3 8 8 8 8 8 3
3 8 2 2 2 8 3
3 8 2 1 2 8 3
3 8 2 2 2 8 3
3 8 8 8 8 8 3
3 3 3 3 3 3 3
```

*   **Perception:**
    *   The input grids contain large, nested rectangular regions of solid colors.
    *   The output grids are smaller squares representing these nested structures.
    *   The transformation involves identifying the sequence of colors from the innermost rectangle outwards.
    *   The output grid size depends on the number of distinct color layers found.
    *   The output grid arranges the colors as concentric squares, mirroring the nesting order of the input rectangles. The innermost input color becomes the center pixel(s) of the output, the next color forms the surrounding layer, and so on.

*   **Facts YAML:**
    
```yaml
    task_type: pattern_transformation
    input_features:
      - description: Nested rectangular regions of solid colors.
      - properties:
          - Each region fully contains the next inner region.
          - Regions are axis-aligned.
    output_features:
      - description: A square grid representing the nested structure.
      - properties:
          - Size depends on the number of nested layers (N): (2*N - 1) x (2*N - 1).
          - Colors are arranged in concentric squares.
          - The innermost color of the input forms the center 1x1 square of the output.
          - The second innermost color forms the surrounding 3x3 frame (excluding the center).
          - The third innermost color forms the surrounding 5x5 frame (excluding the inner 3x3), etc.
          - The outermost color forms the final border frame.
    transformation:
      - action: Identify distinct colors forming nested rectangular layers.
      - action: Determine the sequence of colors from innermost to outermost.
      - action: Count the number of layers (N).
      - action: Calculate output grid dimensions: width = height = 2*N - 1.
      - action: Construct the output grid by drawing concentric square frames, starting with the innermost color at the center and working outwards with subsequent colors.
    relationships:
      - The order of colors in the nested input rectangles directly maps to the order of colors in the concentric output squares (innermost to outermost).
      - The number of color layers determines the size of the output grid.
    ```


*   **Natural Language Program:**
    1.  Identify the sequence of distinct colors that form nested rectangular layers in the input grid, starting from the color of the centermost pixel(s) and moving outwards. Let this sequence be `C1, C2, ..., CN`, where `C1` is the innermost color and `CN` is the outermost color.
    2.  Determine the number of distinct color layers, `N`.
    3.  Calculate the dimension `D` for the square output grid: `D = 2 * N - 1`.
    4.  Create an output grid of size `D x D`.
    5.  Fill the output grid by drawing concentric square frames:
        *   Start with the outermost frame (layer `N`) using color `CN`.
        *   Fill the next inner frame (layer `N-1`) using color `C(N-1)`.
        *   Continue inwards until the centermost `1x1` square (layer 1) is filled with color `C1`.
```python
import numpy as np
from typing import List

"""
Identifies nested rectangular layers of colors in the input grid, starting from the center outwards.
Constructs a square output grid whose size is determined by the number of layers (N), with dimensions (2N-1)x(2N-1).
The output grid displays these colors as concentric square frames, mirroring the nesting order from the input. 
The innermost input color forms the 1x1 center of the output, the next color forms the surrounding 3x3 frame, and so on, up to the outermost color forming the largest frame.
"""

def _get_color_layers(grid: np.ndarray) -> List[int]:
    """
    Identifies the sequence of distinct colors forming nested layers, from center outwards.

    Args:
        grid: The input grid as a numpy array.

    Returns:
        A list of color integers representing the layers from innermost to outermost.
    """
    height, width = grid.shape
    center_row = height // 2
    center_col = width // 2

    layers = []
    last_color = -1 # Initialize with a value not in 0-9

    # Trace outwards from the center (e.g., moving right)
    # This assumes layers are roughly centered and axis-aligned.
    # We only need to trace in one direction until the edge to capture all layers.
    for c in range(center_col, width):
        current_color = grid[center_row, c]
        if current_color != last_color:
            layers.append(current_color)
            last_color = current_color
            
    # If the center itself wasn't the start of the trace (e.g., odd dimensions)
    # ensure the center pixel's color is the first layer
    center_color = grid[center_row, center_col]
    if not layers or layers[0] != center_color:
         # Re-evaluate by starting exactly at the center
         layers = []
         last_color = -1
         # Use a path guaranteed to start at the center pixel 
         # and go outwards, e.g., check center, then center+1, etc.
         for c in range(center_col, width):
             current_color = grid[center_row, c]
             if not layers or current_color != layers[-1]:
                 layers.append(current_color)

    # Minimal check if tracing fails (e.g., 1x1 grid)
    if not layers and height > 0 and width > 0:
        layers.append(grid[center_row, center_col])
        
    return layers


def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Transforms the input grid based on nested color layers.

    Args:
        input_grid: A list of lists representing the input grid.

    Returns:
        A list of lists representing the transformed output grid.
    """
    # Convert input to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)

    # Identify the color layers from innermost to outermost
    layers = _get_color_layers(grid_np)
    num_layers = len(layers)

    if num_layers == 0:
        # Handle empty input or unusual cases
        return [] 
        
    # Calculate the dimensions of the output grid
    output_dim = 2 * num_layers - 1

    # Initialize the output grid (e.g., with zeros or the outermost color)
    # Starting with the outermost color simplifies the filling process
    output_grid_np = np.full((output_dim, output_dim), layers[-1], dtype=int)

    # Fill the grid with concentric squares, starting from the second outermost layer
    # and working inwards towards the center.
    # Layer k (from 1=innermost to N=outermost) corresponds to color layers[k-1]
    # The size of the square for layer k is (2k-1)x(2k-1)
    # We iterate from N-1 down to 1.
    for k in range(num_layers - 1, 0, -1):
        color = layers[k-1] # Color for the current inner layer being drawn
        
        # Calculate the boundaries for the square of this layer k
        # The full square for layer k has size (2k-1)x(2k-1)
        # The top-left corner index offset from the center (N-1, N-1) is (N-1)-(k-1) = N-k
        start_index = num_layers - k 
        # The size of the square to fill is (output_dim - 2 * start_index)
        end_index = output_dim - start_index # Exclusive index for slicing

        # Fill the square region corresponding to this layer and inwards
        output_grid_np[start_index:end_index, start_index:end_index] = color

    # Convert the final numpy array back to a list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
