
## train_1

**input:**
```
0 0 1 4 1 0 0 4 0 0 0 4 0 0 1 4 0 0 1 4 0 1 0
1 1 0 4 0 1 0 4 1 0 1 4 1 1 1 4 1 1 0 4 0 0 1
1 1 1 4 0 0 1 4 1 0 1 4 0 0 1 4 0 0 1 4 1 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 1 0 4 1 0 0 4 1 0 0 4 1 1 0 4 0 0 1 4 1 0 0
0 0 0 4 0 0 1 4 0 1 0 4 1 0 0 4 0 0 0 4 0 0 1
0 1 0 4 0 0 1 4 1 0 1 4 0 1 0 4 1 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 0 4 0 1 0 4 1 1 1 4 0 0 0 4 0 1 0 4 0 1 1
0 0 0 4 0 1 0 4 0 0 0 4 1 0 1 4 0 0 1 4 0 0 1
0 1 1 4 0 1 0 4 1 0 0 4 0 0 0 4 0 0 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 1 4 1 1 0 4 1 0 0 4 0 0 1 4 0 0 1 4 0 0 1
1 1 1 4 1 0 1 4 0 0 1 4 0 0 0 4 1 1 0 4 1 0 0
1 1 0 4 1 1 0 4 1 1 0 4 0 0 1 4 0 1 1 4 1 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 4 0 1 0 4 1 0 1 4 1 0 1 4 0 0 0 0 6 6 4
1 1 0 4 0 1 1 4 0 0 0 4 1 0 0 4 0 0 0 0 6 6 4
0 0 0 4 0 0 1 4 0 0 0 4 0 1 1 4 6 6 6 6 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6 6 6 6 0 0 4
0 0 1 4 1 0 0 4 0 1 0 4 1 1 0 4 0 0 6 6 0 0 4
1 1 1 4 0 0 0 4 1 1 1 4 0 0 1 4 0 0 6 6 0 0 4
0 0 0 4 1 0 1 4 1 1 1 4 0 0 0 4 4 4 4 4 4 4 4
```


**output:**
```
0 0 6 4 1 0 0 4 0 0 0 4 0 0 1 4 0 0 1 4 0 1 0
6 6 0 4 0 1 0 4 1 0 1 4 1 1 1 4 1 1 0 4 0 0 1
1 6 1 4 0 0 1 4 1 0 1 4 0 0 1 4 0 0 1 4 1 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 1 0 4 1 0 0 4 1 0 0 4 1 1 0 4 0 0 1 4 1 0 0
0 0 0 4 0 0 1 4 0 1 0 4 1 0 0 4 0 0 0 4 0 0 1
0 1 0 4 0 0 1 4 1 0 1 4 0 1 0 4 1 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 0 4 0 1 0 4 1 1 1 4 0 0 0 4 0 1 0 4 0 1 1
0 0 0 4 0 1 0 4 0 0 0 4 1 0 1 4 0 0 1 4 0 0 1
0 1 1 4 0 1 0 4 1 0 0 4 0 0 0 4 0 0 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 6 4 1 1 0 4 1 0 0 4 0 0 1 4 0 0 6 4 0 0 1
6 6 1 4 1 0 1 4 0 0 1 4 0 0 0 4 6 6 0 4 1 0 0
1 6 0 4 1 1 0 4 1 1 0 4 0 0 1 4 0 6 1 4 1 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 4 0 1 0 4 1 0 1 4 1 0 1 4 0 0 0 0 6 6 4
1 1 0 4 0 1 1 4 0 0 0 4 1 0 0 4 0 0 0 0 6 6 4
0 0 0 4 0 0 1 4 0 0 0 4 0 1 1 4 6 6 6 6 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 6 6 6 6 0 0 4
0 0 1 4 1 0 0 4 0 1 0 4 1 1 0 4 0 0 6 6 0 0 4
1 1 1 4 0 0 0 4 1 1 1 4 0 0 1 4 0 0 6 6 0 0 4
0 0 0 4 1 0 1 4 1 1 1 4 0 0 0 4 4 4 4 4 4 4 4
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 0 0 1 4 1 0 1 4 0 1 0 4 0 0 0
4 8 8 0 0 8 8 4 0 0 1 4 0 1 0 4 0 0 0 4 0 1 0
4 8 8 0 0 8 8 4 0 1 1 4 0 0 0 4 0 0 0 4 0 0 0
4 0 0 8 8 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 8 8 0 0 4 1 1 1 4 0 1 0 4 0 0 0 4 0 0 0
4 0 0 0 0 0 0 4 0 1 1 4 0 1 0 4 0 1 0 4 0 0 0
4 0 0 0 0 0 0 4 0 1 1 4 0 1 0 4 0 1 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 4 1 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 1 0
0 1 1 4 0 0 0 4 1 0 0 4 0 0 0 4 0 1 1 4 0 0 0
0 0 0 4 0 0 0 4 1 0 0 4 0 0 1 4 0 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 0 0 4 0 0 0 4 1 1 0 4 0 1 1 4 0 1 0
0 0 0 4 0 1 1 4 0 1 1 4 1 0 0 4 1 0 0 4 0 1 0
0 0 0 4 0 1 1 4 0 1 0 4 1 0 0 4 1 0 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 1 0 4 0 0 0 4 0 0 0 4 1 0 0 4 0 0 1
0 1 0 4 1 0 1 4 0 1 0 4 0 1 0 4 0 0 1 4 1 0 0
1 0 0 4 1 0 0 4 0 1 0 4 0 0 0 4 0 0 0 4 1 0 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 1 0 4 1 0 0 4 1 0 0 4 0 0 1 4 1 1 0
1 1 0 4 1 0 1 4 0 0 1 4 0 1 0 4 1 1 0 4 1 0 1
1 0 0 4 1 1 1 4 0 1 0 4 0 1 1 4 1 1 1 4 0 0 0
```


**output:**
```
4 4 4 4 4 4 4 4 0 0 1 4 8 0 8 4 0 1 0 4 0 0 0
4 8 8 0 0 8 8 4 0 0 1 4 0 8 0 4 0 0 0 4 0 1 0
4 8 8 0 0 8 8 4 0 1 1 4 0 0 0 4 0 0 0 4 0 0 0
4 0 0 8 8 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 8 8 0 0 4 8 1 8 4 0 1 0 4 0 0 0 4 0 0 0
4 0 0 0 0 0 0 4 0 8 1 4 0 1 0 4 0 1 0 4 0 0 0
4 0 0 0 0 0 0 4 0 1 1 4 0 1 0 4 0 1 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 4 1 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 1 0
0 1 1 4 0 0 0 4 1 0 0 4 0 0 0 4 0 1 1 4 0 0 0
0 0 0 4 0 0 0 4 1 0 0 4 0 0 1 4 0 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 0 0 4 0 0 0 4 1 1 0 4 0 1 1 4 0 1 0
0 0 0 4 0 1 1 4 0 1 1 4 1 0 0 4 1 0 0 4 0 1 0
0 0 0 4 0 1 1 4 0 1 0 4 1 0 0 4 1 0 0 4 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 1 0 4 0 0 0 4 0 0 0 4 1 0 0 4 0 0 1
0 1 0 4 1 0 1 4 0 1 0 4 0 1 0 4 0 0 1 4 1 0 0
1 0 0 4 1 0 0 4 0 1 0 4 0 0 0 4 0 0 0 4 1 0 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 1 0 4 1 0 0 4 1 0 0 4 0 0 1 4 1 1 0
1 1 0 4 1 0 1 4 0 0 1 4 0 1 0 4 1 1 0 4 1 0 1
1 0 0 4 1 1 1 4 0 1 0 4 0 1 1 4 1 1 1 4 0 0 0
```


## train_3

**input:**
```
1 0 0 4 0 0 1 4 1 1 1 4 1 1 0 4 1 0 0 4 0 0 0
1 1 0 4 1 0 0 4 1 0 0 4 0 1 0 4 1 1 0 4 0 1 1
0 1 1 4 1 0 0 4 1 0 1 4 0 1 0 4 0 0 0 4 1 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 1 1 1 4 0 0 1 4 1 0 0 4 1 0 0 4 1 0 0
1 0 0 4 1 1 0 4 0 1 0 4 1 1 0 4 1 0 1 4 0 1 0
1 1 0 4 0 1 1 4 1 0 0 4 0 0 1 4 1 0 1 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 1 1 4 1 1 0 4 1 1 0 4 0 1 0 4 1 1 0 4 0 1 0
1 1 0 4 0 0 1 4 0 0 1 4 1 0 1 4 0 1 1 4 0 1 0
0 1 1 4 1 1 0 4 0 1 0 4 0 1 0 4 0 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 1 4 1 0 1 4 0 0 0 4 0 0 0 4 1 0 0 4 1 0 0
1 0 1 4 1 0 1 4 0 1 1 4 0 0 1 4 1 0 0 4 1 0 0
0 1 1 4 0 1 0 4 1 1 0 4 0 0 1 4 1 1 1 4 1 0 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 0 0 0 0 4 1 1 1 4 1 0 1 4 0 0 1 4 0 1 1
4 3 3 0 0 0 0 4 1 1 1 4 0 1 1 4 1 1 0 4 1 0 0
4 0 0 3 3 0 0 4 0 1 0 4 0 0 1 4 1 1 1 4 0 0 0
4 0 0 3 3 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 0 0 3 3 4 0 1 1 4 0 0 0 4 0 1 0 4 0 1 0
4 0 0 0 0 3 3 4 1 0 1 4 0 0 0 4 1 0 1 4 1 1 1
4 4 4 4 4 4 4 4 1 1 0 4 1 0 0 4 0 1 0 4 1 1 0
```


**output:**
```
3 0 0 4 0 0 1 4 1 1 1 4 1 1 0 4 1 0 0 4 0 0 0
1 3 0 4 1 0 0 4 1 0 0 4 0 1 0 4 1 1 0 4 0 1 1
0 1 3 4 1 0 0 4 1 0 1 4 0 1 0 4 0 0 0 4 1 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 0 0 4 3 1 1 4 0 0 1 4 3 0 0 4 1 0 0 4 1 0 0
1 0 0 4 1 3 0 4 0 1 0 4 1 3 0 4 1 0 1 4 0 1 0
1 1 0 4 0 1 3 4 1 0 0 4 0 0 3 4 1 0 1 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 1 1 4 1 1 0 4 1 1 0 4 0 1 0 4 1 1 0 4 0 1 0
1 1 0 4 0 0 1 4 0 0 1 4 1 0 1 4 0 1 1 4 0 1 0
0 1 1 4 1 1 0 4 0 1 0 4 0 1 0 4 0 0 0 4 0 1 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
1 1 1 4 1 0 1 4 0 0 0 4 0 0 0 4 1 0 0 4 1 0 0
1 0 1 4 1 0 1 4 0 1 1 4 0 0 1 4 1 0 0 4 1 0 0
0 1 1 4 0 1 0 4 1 1 0 4 0 0 1 4 1 1 1 4 1 0 1
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 3 3 0 0 0 0 4 1 1 1 4 3 0 1 4 0 0 1 4 0 1 1
4 3 3 0 0 0 0 4 1 1 1 4 0 3 1 4 1 1 0 4 1 0 0
4 0 0 3 3 0 0 4 0 1 0 4 0 0 3 4 1 1 1 4 0 0 0
4 0 0 3 3 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 0 0 3 3 4 0 1 1 4 0 0 0 4 0 1 0 4 0 1 0
4 0 0 0 0 3 3 4 1 0 1 4 0 0 0 4 1 0 1 4 1 1 1
4 4 4 4 4 4 4 4 1 1 0 4 1 0 0 4 0 1 0 4 1 1 0
```

*   **Perception**:
    *   The input and output grids are 23x23.
    *   The grids are visually partitioned by horizontal and vertical lines of yellow pixels (color 4). These lines occur every 4th row and column (indices 3, 7, 11, 15, 19).
    *   These yellow lines divide the grid into a 6x6 arrangement of smaller 3x3 subgrids.
    *   Most 3x3 subgrids contain patterns primarily composed of white (0) and blue (1) pixels.
    *   Each input grid features exactly one 3x3 subgrid that contains pixels of a color other than white, blue, or yellow. This unique color acts as a "source" color (magenta 6 in train\_1, azure 8 in train\_2, green 3 in train\_3). The subgrid containing this color is the "source" subgrid.
    *   The transformation involves changing the color of some blue (1) pixels in the *other* ("target") subgrids to the source color identified in the source subgrid.
    *   The change occurs based on a positional correspondence: A blue pixel in a target subgrid changes to the source color if and only if the pixel at the *same relative position* within the source subgrid has the source color.
    *   Pixels that are not blue (1) in the target subgrids, or blue pixels whose corresponding position in the source subgrid does not contain the source color, remain unchanged.
    *   The yellow separator lines remain unchanged.

*   **Facts**:
    
```yaml
    grid_properties:
      size: 23x23
      separator_color: yellow (4)
      separator_indices:
        rows: [3, 7, 11, 15, 19]
        cols: [3, 7, 11, 15, 19]
      structure: Divided into a 6x6 arrangement of 3x3 subgrids by separators.
    
    objects:
      - type: subgrid
        size: 3x3
        count: 36 per grid
        properties:
          - role: source (identified by containing a unique non-background, non-separator color)
          - role: target (all subgrids other than the source)
          - content: Primarily patterns of white (0) and blue (1) pixels.
      - type: pixel
        properties:
          - color: white (0), blue (1), yellow (4), magenta (6), azure (8), green (3)
          - position: (row, col) within the main grid
          - relative_position: (row_offset, col_offset) within its 3x3 subgrid (offsets 0, 1, 2)
    
    source_subgrid:
      identification: Contains pixels of a color C where C is not white (0), blue (1), or yellow (4).
      unique_color: The color C identified above (e.g., magenta, azure, green). Let's call this 'source_color'.
      location: Varies between examples.
    
    transformation:
      action: Conditional color change.
      target_elements: Pixels within the target subgrids.
      condition:
        - The pixel in the target subgrid must be blue (1).
        - The pixel at the same relative_position within the source_subgrid must have the 'source_color'.
      effect: If conditions are met, the target pixel's color changes from blue (1) to the 'source_color'. Otherwise, the pixel's color remains unchanged.
      ignored_elements: Yellow separator pixels, pixels in the source subgrid, pixels in target subgrids that are not blue (1).
    ```


*   **Natural Language Program**:
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the yellow (4) separator lines to conceptually divide the grid into 3x3 subgrids.
    3.  Locate the "source" 3x3 subgrid: Iterate through all 3x3 subgrids and find the one that contains at least one pixel whose color is *not* white (0), blue (1), or yellow (4). Record the unique color found as the `source_color` and the coordinates of this source subgrid.
    4.  Iterate through each 3x3 subgrid in the grid.
    5.  If the current subgrid is the source subgrid identified in step 3, skip it.
    6.  If the current subgrid is a "target" subgrid:
        a.  Iterate through each pixel within this 3x3 target subgrid using relative coordinates (row\_offset, col\_offset) ranging from (0,0) to (2,2).
        b.  Check the color of the current pixel in the target subgrid.
        c.  If the target pixel's color is blue (1):
            i.  Determine the corresponding pixel's location within the source subgrid using the same relative coordinates (row\_offset, col\_offset).
            ii. Check the color of this corresponding pixel in the source subgrid.
            iii.If the corresponding source pixel's color is equal to the `source_color`, change the color of the current pixel in the *output* grid (at the target subgrid location) to the `source_color`.
    7.  Return the modified output grid.
```python
import numpy as np

"""
Identifies a 'source' 3x3 subgrid containing a unique color (not white, blue, or yellow).
Iterates through all other 'target' 3x3 subgrids.
For each blue pixel in a target subgrid, checks the color of the pixel at the corresponding relative position within the source subgrid.
If the corresponding pixel in the source subgrid has the unique 'source_color', the blue pixel in the target subgrid is changed to the 'source_color' in the output grid.
The grid is structured with 3x3 subgrids separated by yellow (4) lines at every 4th row/column.
"""

def transform(input_grid):
    """
    Transforms the input grid based on a source subgrid pattern.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed output grid.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    source_color = -1 # Initialize with an invalid color
    source_r_start, source_c_start = -1, -1
    source_subgrid_found = False

    # Define the starting rows and columns for the 3x3 subgrids
    subgrid_starts = [i * 4 for i in range(height // 4 + 1) if i * 4 + 3 <= height]

    # 1. Find the source subgrid and the source color
    for r_start in subgrid_starts:
        for c_start in subgrid_starts:
            # Check pixels within the 3x3 subgrid area
            for r_offset in range(3):
                for c_offset in range(3):
                    row, col = r_start + r_offset, c_start + c_offset
                    if 0 <= row < height and 0 <= col < width:
                         pixel_color = input_grid[row, col]
                         # Source color is defined as not white(0), blue(1), or yellow(4)
                         if pixel_color not in [0, 1, 4]:
                            source_color = pixel_color
                            source_r_start, source_c_start = r_start, c_start
                            source_subgrid_found = True
                            break # Found the unique color in this subgrid
                if source_subgrid_found:
                    break
            if source_subgrid_found:
                break
        if source_subgrid_found:
            break
            
    if not source_subgrid_found:
        # Should not happen based on examples, but handle defensively
        return output_grid 

    # 2. Iterate through all subgrids again to apply the transformation
    for r_start in subgrid_starts:
        for c_start in subgrid_starts:
            # Skip the source subgrid itself
            if r_start == source_r_start and c_start == source_c_start:
                continue

            # 3. Process each pixel in the current (target) subgrid
            for r_offset in range(3):
                for c_offset in range(3):
                    target_row, target_col = r_start + r_offset, c_start + c_offset
                    
                    # Ensure target coordinates are within grid bounds (though they should be)
                    if not (0 <= target_row < height and 0 <= target_col < width):
                        continue

                    target_pixel_color = input_grid[target_row, target_col]

                    # 4. Check if the target pixel is blue (1)
                    if target_pixel_color == 1:
                        # Find the corresponding pixel in the source subgrid
                        source_corr_row = source_r_start + r_offset
                        source_corr_col = source_c_start + c_offset
                        
                        # Ensure source corresponding coordinates are valid
                        if 0 <= source_corr_row < height and 0 <= source_corr_col < width:
                            corr_source_pixel_color = input_grid[source_corr_row, source_corr_col]

                            # 5. If the corresponding source pixel has the source color, change the target pixel
                            if corr_source_pixel_color == source_color:
                                output_grid[target_row, target_col] = source_color
                        
    return output_grid
```
