
## train_1

**input:**
```
0 0 0 8 0 8 0 0 0 8 0 8 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 8 0 8
0 8 0 8 0 0 0 0 8 0 0 8 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 8 0
0 0 0 0 0 0 0 0 8 0 8 0 0 0 8 0 0 0 0 0
1 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0
0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
8 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 8
1 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 8 0
0 0 0 0 0 0 0 0 0 0 0 0 8 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 8 0
0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 8 0 0 0
1 0 8 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 8 0 0 8 0 8 0 0 0 8 0
0 0 8 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0
```


**output:**
```
0 0 0 8 0 8 0 0 0 8 0 8 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 8 0 8
0 8 0 8 0 0 0 0 8 0 0 8 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 8 0
0 0 0 0 1 1 1 0 8 0 8 0 0 0 8 0 0 0 0 0
1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1 1
0 8 0 0 1 1 1 0 0 8 1 1 1 0 0 0 0 0 8 0
0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 1 1
8 1 1 1 0 8 0 1 1 1 0 8 0 0 0 0 8 1 1 8
1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 8 1
0 1 1 1 0 0 0 1 1 1 0 0 8 0 8 0 8 1 1 1
0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 1 1 1 8 0
0 1 1 1 1 1 8 0 0 1 1 1 0 0 1 1 8 1 0 0
1 1 8 1 8 1 1 1 1 1 8 1 1 1 1 8 1 1 1 1
0 1 1 8 1 1 0 0 0 1 1 1 0 0 1 1 1 0 8 0
0 0 1 1 1 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 8 0 0 8 0 8 0 0 0 8 0
0 0 8 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0
```


## train_2

**input:**
```
0 0 5 0 0 0 0 0 0 0
0 0 0 0 0 5 0 5 0 0
0 0 0 0 0 0 0 0 5 0
1 0 5 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 0
0 0 5 0 0 0 5 0 0 0
0 0 0 0 0 0 0 0 0 0
1 0 0 0 5 0 0 0 0 0
0 5 0 0 0 0 0 0 5 0
```


**output:**
```
0 0 5 0 0 0 0 0 0 0
0 0 0 0 0 5 0 5 0 0
0 1 1 1 0 0 0 0 5 0
1 1 5 1 1 1 1 1 1 1
0 1 1 5 1 0 0 0 5 0
0 0 1 1 1 0 0 0 0 0
0 0 5 0 0 0 5 0 0 0
0 0 0 1 1 1 0 0 0 0
1 1 1 1 5 1 1 1 1 1
0 5 0 1 1 1 0 0 5 0
```


## train_3

**input:**
```
0 0 0 0 0 0
0 0 5 0 0 0
0 0 0 0 0 0
1 0 0 5 0 0
0 0 0 0 0 0
0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0
0 0 5 0 0 0
0 0 1 1 1 0
1 1 1 5 1 1
0 0 1 1 1 0
0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0
0 0 0 0 0 0
1 0 8 0 0 0
0 8 0 0 0 0
0 0 0 0 8 0
0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0
0 1 1 1 0 0
1 1 8 1 1 1
0 8 0 0 0 0
0 0 0 0 8 0
0 0 0 0 0 0
```


## train_5

**input:**
```
5 0 0 0 0 0 5 0 0 0 0 0 0
0 5 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 5 0 0 0 0 5 0 0 0
1 0 5 0 0 0 0 0 5 0 0 0 5
0 0 0 0 0 5 0 0 0 5 0 0 0
0 5 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0
5 0 0 5 0 0 5 0 5 0 0 5 0
0 0 0 0 5 0 0 0 0 5 0 0 0
1 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 5 0 5 0 0 5 0 0 0
```


**output:**
```
5 0 0 0 0 0 5 0 0 0 0 0 0
0 5 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 5 0
0 1 1 1 5 0 0 1 1 5 1 1 1
1 1 5 1 1 1 1 1 5 1 1 1 5
0 1 1 1 0 5 0 1 1 5 1 1 1
0 5 0 5 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0
5 0 0 5 0 0 5 0 5 0 0 5 0
0 0 0 0 5 0 0 0 0 5 1 1 1
1 1 1 1 1 1 1 1 1 1 1 5 1
0 0 0 0 5 0 5 0 0 5 1 1 1
```


## train_6

**input:**
```
0 0 0 8 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 8 0 8 0 0
0 0 0 0 0 0 0
0 0 8 0 0 0 0
0 0 0 0 0 0 0
```


**output:**
```
0 0 0 8 0 0 0
0 0 0 0 0 0 0
0 1 1 1 1 1 0
1 1 8 1 8 1 1
0 1 1 1 1 1 0
0 0 8 0 0 0 0
0 0 0 0 0 0 0
```

*   **Perception:** The input grids consist of a white background (color 0) with scattered pixels of other colors, notably azure (8) or gray (5), and at least one blue pixel (color 1). The output grids are identical to the input grids, except that some white pixels have been changed to blue. The newly added blue pixels form contiguous regions that originate from the blue pixels present in the input grid. These regions expand outwards through adjacent white pixels until they are stopped by non-white pixels (azure or gray in the examples) or the grid boundaries. This suggests a "flood fill" or "paint bucket" operation. The non-white pixels (azure, gray) act as barriers or boundaries for the fill. The fill color is always blue (1), and it starts from the locations of the original blue (1) pixels in the input.

*   **YAML Facts:**
    
```yaml
    task_type: flood_fill
    objects:
      - type: grid
        description: A 2D array of pixels with colors 0-9.
      - type: pixel
        properties:
          - color:
              values: [white (0), blue (1), red (2), green (3), yellow (4), gray (5), magenta (6), orange (7), azure (8), maroon (9)]
          - position: (row, column) coordinates
    elements:
      - role: background
        color: white (0)
      - role: fill_start_points
        color: blue (1)
        location: Present in the input grid.
      - role: fill_area
        color: white (0)
        description: Pixels eligible to be filled.
      - role: boundary
        color: Any color except white (0) and blue (1) initially (specifically gray (5) and azure (8) in examples, but likely any non-zero color acts as a boundary). These pixels stop the fill propagation.
    action:
      type: flood_fill
      parameters:
        - start_points: Locations of blue (1) pixels in the input grid.
        - fill_color: blue (1)
        - target_color: white (0)
        - boundary_colors: All colors except white (0).
      propagation: Spreads to adjacent (up, down, left, right) pixels of the target color (white).
    transformation:
      - description: Copy the input grid to the output grid.
      - description: Identify all pixels with blue (1) color in the input grid.
      - description: For each identified blue (1) pixel, initiate a flood fill operation.
      - description: The flood fill changes the color of connected white (0) pixels to blue (1).
      - description: The fill spreads horizontally and vertically.
      - description: The fill stops at pixels that are not white (0) or at the grid boundaries.
      - description: All original non-white pixels retain their color and position.
    ```


*   **Natural Language Program:**
    1.  Create the output grid as an exact copy of the input grid.
    2.  Identify the coordinates of all pixels in the input grid that have the color blue (1). These are the starting points for the fill.
    3.  Initialize a queue or stack data structure for the flood fill algorithm, adding all starting point coordinates to it. Maintain a set to keep track of visited coordinates to prevent redundant processing. Add the starting points to the visited set.
    4.  While the queue/stack is not empty:
        a.  Dequeue/pop a coordinate (row, col).
        b.  Examine its four adjacent neighbors (up, down, left, right).
        c.  For each neighbor (neighbor_row, neighbor_col):
            i.  Check if the neighbor is within the grid boundaries.
            ii. Check if the neighbor coordinate has already been visited.
            iii. Check if the color of the neighbor pixel in the *output* grid is white (0).
            iv. If all checks (i, ii, iii) pass:
                1.  Change the color of the neighbor pixel at (neighbor_row, neighbor_col) in the output grid to blue (1).
                2.  Add the neighbor coordinate (neighbor_row, neighbor_col) to the queue/stack.
                3.  Add the neighbor coordinate to the visited set.
    5.  Return the modified output grid.
```python
"""
Perform a flood fill operation starting from all blue (1) pixels in the input grid.
The fill color is blue (1) and it expands into adjacent white (0) pixels.
The fill stops at the grid boundaries or any non-white (0) pixels.
All original non-white pixels retain their color and position.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Applies a flood fill operation starting from blue pixels (1).

    Args:
        input_grid (list of lists): The input grid representing pixel colors.

    Returns:
        list of lists: The transformed grid with white areas adjacent to blue pixels
                       filled with blue, bounded by non-white pixels or grid edges.
    """
    # Convert input to numpy array for easier indexing and manipulation
    np_input_grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(np_input_grid)
    height, width = output_grid.shape

    # Find initial starting points for the flood fill (blue pixels)
    start_points = np.argwhere(np_input_grid == 1)

    # Initialize queue for BFS flood fill and a set to track visited cells
    queue = deque()
    visited = set()

    # Add initial blue points to the queue and visited set
    # Note: We start filling *from* these points into adjacent white cells.
    # The blue points themselves are already blue. We add them to visited
    # to ensure we don't try to process them as fill targets.
    for r, c in start_points:
        # We don't actually need to add the blue pixels themselves to the queue,
        # but we need to consider their *neighbors* as potential starting points
        # for the fill into white areas.
        visited.add((r, c)) # Mark the blue pixel itself as 'visited' conceptually

        # Check neighbors of the initial blue pixels
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor is white (0) and not already visited
                if output_grid[nr, nc] == 0 and (nr, nc) not in visited:
                    # This white neighbor is a starting point for the actual fill
                    output_grid[nr, nc] = 1 # Fill it blue
                    visited.add((nr, nc))
                    queue.append((nr, nc))


    # Perform Breadth-First Search (BFS) flood fill
    while queue:
        r, c = queue.popleft()

        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor is white (0) and not already visited
                if output_grid[nr, nc] == 0 and (nr, nc) not in visited:
                    # Change color to blue (1)
                    output_grid[nr, nc] = 1
                    # Mark as visited
                    visited.add((nr, nc))
                    # Add to queue for further exploration
                    queue.append((nr, nc))

    # Convert the result back to a list of lists
    return output_grid.tolist()
```
```python
"""
Perform a flood fill operation starting from all blue (1) pixels in the input grid.
The fill color is blue (1) and it expands into adjacent (up, down, left, right) 
white (0) pixels. The fill stops at the grid boundaries or any non-white (0) 
pixels (e.g., gray 5, azure 8), which act as barriers. All original non-white 
pixels retain their color and position.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Applies a flood fill operation starting from blue pixels (1).

    Args:
        input_grid (list of lists): The input grid representing pixel colors.

    Returns:
        list of lists: The transformed grid with white areas connected to blue pixels
                       filled with blue, bounded by non-white pixels or grid edges.
    """
    # Convert input to numpy array for easier indexing and manipulation
    np_input_grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(np_input_grid)
    height, width = output_grid.shape

    # Initialize queue for BFS flood fill
    queue = deque()
    
    # Initialize a set to track visited coordinates. 
    # Add all non-white pixels initially, as they are boundaries or starting points 
    # and should not be filled or added to the queue again.
    visited = set()
    for r in range(height):
        for c in range(width):
            if output_grid[r, c] != 0:
                visited.add((r, c))
                # If it's a blue pixel (1), add it to the queue to start the fill from here
                if output_grid[r, c] == 1:
                    queue.append((r, c))

    # Perform Breadth-First Search (BFS) flood fill
    while queue:
        r, c = queue.popleft()

        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor has not been visited. 
                # Since all non-white cells were added initially, 
                # a non-visited cell must be white (0).
                if (nr, nc) not in visited:
                    # Change color to blue (1)
                    output_grid[nr, nc] = 1
                    # Mark as visited
                    visited.add((nr, nc))
                    # Add to queue for further exploration
                    queue.append((nr, nc))

    # Convert the result back to a list of lists
    return output_grid.tolist()
```
