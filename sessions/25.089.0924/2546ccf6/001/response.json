{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentifies regions partitioned by grid lines of a single color. \nGroups regions containing identical patterns (ignoring background and grid line colors).\nWithin each group of identical patterns, sorts the regions by their top-left corner (row-major order).\nSwaps the content of consecutive pairs of regions in the sorted list (1st with 2nd, 3rd with 4th, etc.). \nGrid lines, empty regions, regions with unique patterns, and the last region in odd-sized groups remain unchanged.\n\"\"\"\n\ndef find_grid_lines(grid):\n    \"\"\"\n    Finds horizontal and vertical grid lines and the dominant color forming them.\n    A grid line is a full row or column composed of a single non-background color.\n    \"\"\"\n    height, width = grid.shape\n    rows = []\n    cols = []\n    potential_colors = set()\n    \n    # Check rows\n    for r in range(height):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            rows.append(r)\n            potential_colors.add(unique_colors[0])\n            \n    # Check columns\n    for c in range(width):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            cols.append(c)\n            potential_colors.add(unique_colors[0])\n\n    if not potential_colors:\n        # Handle cases with no grid lines? Or assume they always exist based on examples.\n        # For now, assume they exist and there's only one color.\n         return None, [], [] # Or raise error\n    \n    # In the examples, there's only one grid line color\n    # If multiple colors form full lines, this logic might need adjustment.\n    # We assume the color forming both row and col lines (if both exist) is the grid color.\n    grid_line_color = list(potential_colors)[0] # Simplistic assumption for now\n\n    # Verify consistency if needed (e.g., check if all line colors match)\n    \n    return grid_line_color, sorted(rows), sorted(cols)\n\ndef define_regions(height, width, grid_rows, grid_cols):\n    \"\"\"\n    Defines region boundaries based on grid lines.\n    Returns a list of tuples: (r1, c1, r2, c2) where r1, c1 are inclusive top-left\n    and r2, c2 are exclusive bottom-right coordinates.\n    \"\"\"\n    regions = []\n    row_starts = [0] + [r + 1 for r in grid_rows]\n    row_ends = [r for r in grid_rows] + [height]\n    col_starts = [0] + [c + 1 for c in grid_cols]\n    col_ends = [c for c in grid_cols] + [width]\n\n    for r_start, r_end in zip(row_starts, row_ends):\n        for c_start, c_end in zip(col_starts, col_ends):\n             # Ensure region has valid dimensions (handles adjacent grid lines)\n             if r_start < r_end and c_start < c_end:\n                regions.append((r_start, c_start, r_end, c_end))\n                \n    return regions\n\ndef extract_content(grid, r1, c1, r2, c2):\n    \"\"\"Extracts the subgrid content of a region.\"\"\"\n    return grid[r1:r2, c1:c2]\n\ndef get_pattern_tuple(content, background_color=0, grid_line_color=None):\n    \"\"\"\n    Creates a hashable representation (tuple of tuples) of the pattern within content,\n    ignoring background and grid line colors. Returns None if the region is empty\n    (only contains background/grid lines).\n    \"\"\"\n    pattern_list = []\n    has_pattern = False\n    for r in range(content.shape[0]):\n        row_list = []\n        for c in range(content.shape[1]):\n            pixel = content[r, c]\n            if pixel != background_color and pixel != grid_line_color:\n                 row_list.append(pixel)\n                 has_pattern = True\n            else:\n                 row_list.append(background_color) # Use background as placeholder\n        pattern_list.append(tuple(row_list))\n        \n    if not has_pattern:\n        return None # Indicate empty or non-pattern region\n\n    # Normalize by removing all-background rows/cols from edges? Might not be needed if regions are tight.\n    # For now, just return the tuple representation.\n    return tuple(pattern_list)\n\ndef place_content(grid, r1, c1, r2, c2, content_to_place):\n    \"\"\"Places the content_to_place into the specified region of the grid.\"\"\"\n    grid[r1:r2, c1:c2] = content_to_place\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping contents of regions with identical patterns.\n\n    1. Identifies grid lines and regions.\n    2. Extracts patterns from regions (ignoring grid lines and background).\n    3. Groups regions by identical patterns.\n    4. Sorts regions within each group by location (top-left corner, row-major).\n    5. Swaps the *full content* of paired regions (1st/2nd, 3rd/4th, etc.) in each group.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    background_color = 0\n\n    # 1. Identify Grid Structure\n    grid_line_color, grid_rows, grid_cols = find_grid_lines(input_grid)\n    \n    if grid_line_color is None:\n         # If no grid lines detected, maybe return input as is?\n         # Based on examples, grid lines seem guaranteed.\n         print(\"Warning: No grid lines detected.\")\n         return output_grid\n\n    # 2. Define Regions\n    region_coords = define_regions(height, width, grid_rows, grid_cols)\n\n    # 3. Extract and Characterize Region Contents & Group Regions\n    region_patterns = {} # Store pattern for each region coords: {(r1,c1,r2,c2): pattern_tuple}\n    pattern_groups = defaultdict(list) # Group coords by pattern: {pattern_tuple: [(r1,c1,r2,c2), ...]}\n\n    for coords in region_coords:\n        r1, c1, r2, c2 = coords\n        content = extract_content(input_grid, r1, c1, r2, c2)\n        pattern = get_pattern_tuple(content, background_color, grid_line_color)\n        \n        region_patterns[coords] = pattern\n        if pattern is not None: # Only group regions with actual patterns\n            pattern_groups[pattern].append(coords)\n\n    # 4. Identify Swap Pairs\n    swaps_to_perform = [] # List of pairs of coords to swap: [ ((rA1,cA1,rA2,cA2), (rB1,cB1,rB2,cB2)), ... ]\n\n    for pattern, coords_list in pattern_groups.items():\n        if len(coords_list) >= 2:\n            # Sort regions by top-left corner (row, then column)\n            sorted_coords = sorted(coords_list, key=lambda c: (c[0], c[1]))\n            \n            # Pair consecutive regions\n            for i in range(0, len(sorted_coords) // 2 * 2, 2):\n                region_A_coords = sorted_coords[i]\n                region_B_coords = sorted_coords[i+1]\n                swaps_to_perform.append((region_A_coords, region_B_coords))\n\n    # 5. Perform Swaps\n    # We need to extract content *before* modifying the output grid to avoid double-swapping issues\n    content_cache = {}\n    for coords_A, coords_B in swaps_to_perform:\n        if coords_A not in content_cache:\n            content_cache[coords_A] = extract_content(input_grid, *coords_A)\n        if coords_B not in content_cache:\n            content_cache[coords_B] = extract_content(input_grid, *coords_B)\n\n    # Now place the cached content into the output grid\n    for coords_A, coords_B in swaps_to_perform:\n        content_A = content_cache[coords_A]\n        content_B = content_cache[coords_B]\n        \n        # Place content B into region A location\n        place_content(output_grid, *coords_A, content_B)\n        # Place content A into region B location\n        place_content(output_grid, *coords_B, content_A)\n\n    # 6. Finalize Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5062,
    "candidates_token_count": 2130,
    "total_token_count": 7192,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.181457,
  "retries": 1
}