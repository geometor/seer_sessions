
## train_1

**input:**
```
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
3 0 3 3 2 0 0 0 0 2 0 0 0 0 2 0 0 0
0 3 3 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
0 0 3 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 3 0 2 0 3 0 0 2 0 0 0 0 2 0 0 0
0 3 3 0 2 0 3 3 0 2 0 0 0 0 2 0 0 0
3 0 3 3 2 3 3 0 3 2 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
0 0 0 0 2 0 1 0 0 2 0 0 1 0 2 0 0 0
0 0 0 0 2 0 0 1 1 2 1 1 0 0 2 0 0 0
0 0 0 0 2 0 0 1 0 2 0 1 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 0 0 2 0 1 0 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 1 1 0 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 1 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
```


**output:**
```
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
3 0 3 3 2 3 3 0 3 2 0 0 0 0 2 0 0 0
0 3 3 0 2 0 3 3 0 2 0 0 0 0 2 0 0 0
0 0 3 0 2 0 3 0 0 2 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 3 0 2 0 3 0 0 2 0 0 0 0 2 0 0 0
0 3 3 0 2 0 3 3 0 2 0 0 0 0 2 0 0 0
3 0 3 3 2 3 3 0 3 2 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
0 0 0 0 2 0 1 0 0 2 0 0 1 0 2 0 0 0
0 0 0 0 2 0 0 1 1 2 1 1 0 0 2 0 0 0
0 0 0 0 2 0 0 1 0 2 0 1 0 0 2 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 2 0 0 1 0 2 0 1 0 0 2 0 0 0
0 0 0 0 2 0 0 1 1 2 1 1 0 0 2 0 0 0
0 0 0 0 2 0 1 0 0 2 0 0 1 0 2 0 0 0
0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0
```


## train_2

**input:**
```
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 0 4 6 4 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
0 0 0 0 6 0 4 4 0 6 0 4 4 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 4 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 4 4 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 4 6 0 0 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
```


**output:**
```
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 0 4 6 4 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
0 0 0 0 6 0 4 4 0 6 0 4 4 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
0 0 0 0 6 0 4 4 0 6 0 4 4 0 6 0 0 0 0
0 0 0 0 6 0 0 4 0 6 0 4 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 4 6 4 0 0 0 6 0 0 0 0
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 6 0 0 0 0 6 0 0 0 0
```

**Perception**

1.  **Grid Structure:** The input grids are characterized by a clear grid structure formed by solid horizontal and vertical lines of a single, non-background color (Red=2 in train_1, Magenta=6 in train_2). This color acts as a frame or separator.
2.  **Regions:** These grid lines partition the grid into multiple rectangular sub-regions.
3.  **Region Content:** Some regions are empty (filled with the background color, White=0), while others contain distinct patterns or shapes composed of one or more non-background, non-grid-line colors (Green=3/Blue=1 in train_1, Yellow=4 in train_2).
4.  **Transformation:** The core transformation is a selective swapping of content between pairs of regions. The grid lines themselves, empty regions, and regions with unique patterns remain unchanged.
5.  **Pairing Logic:** The swapping occurs between regions that contain *identical* patterns (considering both shape and color).
6.  **Grouping and Ordering:** Regions with the same pattern are grouped. Within each group, regions are conceptually ordered (e.g., top-to-bottom, left-to-right based on their top-left corner).
7.  **Swapping Mechanism:** The swapping happens between consecutive regions in the ordered list within each group (the 1st swaps with the 2nd, the 3rd swaps with the 4th, and so on). If a group has an odd number of regions, the last one remains in its original place.

**Facts**


```yaml
grid_structure:
  description: Input grid is partitioned by solid horizontal and vertical lines of a single dominant color (grid_line_color).
  grid_line_color: Variable (e.g., Red=2, Magenta=6). Defines boundaries for regions.
  grid_lines_preserved: True. The positions and color of grid lines remain unchanged in the output.
regions:
  definition: Rectangular areas bounded by grid lines and/or the overall grid borders.
  properties:
    - location: Defined by top-left and bottom-right coordinates.
    - content: A subgrid containing pixels. Can be empty (background color only) or contain a pattern.
patterns:
  definition: The specific arrangement and colors of non-background pixels within a region's content. Excludes the grid_line_color.
  role: Used as the key for identifying regions to be potentially swapped. Identity requires matching shape, colors, and relative positions within the region.
transformation:
  type: Swapping content between pairs of regions.
  conditions:
    - Regions must contain identical patterns (shape and color).
    - Regions must belong to the same group of identical patterns.
  process:
    1. Identify grid lines and define regions.
    2. Extract the pattern from each non-empty region.
    3. Group regions based on identical patterns.
    4. For each group with 2 or more regions:
       a. Sort regions by position (e.g., row-major order of top-left corners).
       b. Form pairs: (1st, 2nd), (3rd, 4th), etc.
       c. Swap the *entire content* of the regions within each pair.
  unaffected_elements:
    - Grid lines.
    - Empty regions (containing only background color).
    - Regions with unique patterns (group size 1).
    - The last region in a group with an odd number of members.
```


**Natural Language Program**

1.  **Identify Grid Structure:** Detect the dominant non-background color forming complete horizontal and vertical lines; this is the `grid_line_color`. Find the row and column indices (`grid_rows`, `grid_cols`) corresponding to these lines.
2.  **Define Regions:** Use the `grid_rows` and `grid_cols` (along with the grid boundaries 0, H-1, 0, W-1) to define the bounding boxes of all rectangular regions within the grid.
3.  **Extract and Characterize Region Contents:** For each defined region:
    a.  Extract the subgrid representing its content.
    b.  Determine if the region is empty (contains only background color) or if it contains a pattern (includes non-background, non-`grid_line_color` pixels).
    c.  Store the pattern (the subgrid content) and the region's location/index.
4.  **Group Regions by Identical Patterns:** Create groups where each group contains the locations/indices of regions having identical non-empty patterns.
5.  **Identify Swap Pairs:** For each group of regions with identical patterns:
    a.  If the group contains fewer than two regions, do nothing with this group.
    b.  If the group contains two or more regions, sort the region locations/indices based on their top-left corner (primarily by row, secondarily by column).
    c.  Iterate through the sorted list, pairing the first with the second, the third with the fourth, and so on. Record these pairs (e.g., `(region_index_A, region_index_B)`).
6.  **Perform Swaps:** Create a copy of the input grid to serve as the output grid. For each identified pair `(region_A, region_B)`:
    a.  Get the content (subgrid) of `region_A` from the *input* grid.
    b.  Get the content (subgrid) of `region_B` from the *input* grid.
    c.  Place the content of `region_A` into the location of `region_B` in the *output* grid.
    d.  Place the content of `region_B` into the location of `region_A` in the *output* grid.
7.  **Finalize Output:** The modified output grid, containing the swapped region contents and all original unchanged elements (grid lines, empty regions, unswapped pattern regions), is the result.
```python
import numpy as np
from collections import defaultdict

"""
Identifies regions partitioned by grid lines of a single color. 
Groups regions containing identical patterns (ignoring background and grid line colors).
Within each group of identical patterns, sorts the regions by their top-left corner (row-major order).
Swaps the content of consecutive pairs of regions in the sorted list (1st with 2nd, 3rd with 4th, etc.). 
Grid lines, empty regions, regions with unique patterns, and the last region in odd-sized groups remain unchanged.
"""

def find_grid_lines(grid):
    """
    Finds horizontal and vertical grid lines and the dominant color forming them.
    A grid line is a full row or column composed of a single non-background color.
    """
    height, width = grid.shape
    rows = []
    cols = []
    potential_colors = set()
    
    # Check rows
    for r in range(height):
        unique_colors = np.unique(grid[r, :])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
            rows.append(r)
            potential_colors.add(unique_colors[0])
            
    # Check columns
    for c in range(width):
        unique_colors = np.unique(grid[:, c])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
            cols.append(c)
            potential_colors.add(unique_colors[0])

    if not potential_colors:
        # Handle cases with no grid lines? Or assume they always exist based on examples.
        # For now, assume they exist and there's only one color.
         return None, [], [] # Or raise error
    
    # In the examples, there's only one grid line color
    # If multiple colors form full lines, this logic might need adjustment.
    # We assume the color forming both row and col lines (if both exist) is the grid color.
    grid_line_color = list(potential_colors)[0] # Simplistic assumption for now

    # Verify consistency if needed (e.g., check if all line colors match)
    
    return grid_line_color, sorted(rows), sorted(cols)

def define_regions(height, width, grid_rows, grid_cols):
    """
    Defines region boundaries based on grid lines.
    Returns a list of tuples: (r1, c1, r2, c2) where r1, c1 are inclusive top-left
    and r2, c2 are exclusive bottom-right coordinates.
    """
    regions = []
    row_starts = [0] + [r + 1 for r in grid_rows]
    row_ends = [r for r in grid_rows] + [height]
    col_starts = [0] + [c + 1 for c in grid_cols]
    col_ends = [c for c in grid_cols] + [width]

    for r_start, r_end in zip(row_starts, row_ends):
        for c_start, c_end in zip(col_starts, col_ends):
             # Ensure region has valid dimensions (handles adjacent grid lines)
             if r_start < r_end and c_start < c_end:
                regions.append((r_start, c_start, r_end, c_end))
                
    return regions

def extract_content(grid, r1, c1, r2, c2):
    """Extracts the subgrid content of a region."""
    return grid[r1:r2, c1:c2]

def get_pattern_tuple(content, background_color=0, grid_line_color=None):
    """
    Creates a hashable representation (tuple of tuples) of the pattern within content,
    ignoring background and grid line colors. Returns None if the region is empty
    (only contains background/grid lines).
    """
    pattern_list = []
    has_pattern = False
    for r in range(content.shape[0]):
        row_list = []
        for c in range(content.shape[1]):
            pixel = content[r, c]
            if pixel != background_color and pixel != grid_line_color:
                 row_list.append(pixel)
                 has_pattern = True
            else:
                 row_list.append(background_color) # Use background as placeholder
        pattern_list.append(tuple(row_list))
        
    if not has_pattern:
        return None # Indicate empty or non-pattern region

    # Normalize by removing all-background rows/cols from edges? Might not be needed if regions are tight.
    # For now, just return the tuple representation.
    return tuple(pattern_list)

def place_content(grid, r1, c1, r2, c2, content_to_place):
    """Places the content_to_place into the specified region of the grid."""
    grid[r1:r2, c1:c2] = content_to_place

def transform(input_grid):
    """
    Transforms the input grid by swapping contents of regions with identical patterns.

    1. Identifies grid lines and regions.
    2. Extracts patterns from regions (ignoring grid lines and background).
    3. Groups regions by identical patterns.
    4. Sorts regions within each group by location (top-left corner, row-major).
    5. Swaps the *full content* of paired regions (1st/2nd, 3rd/4th, etc.) in each group.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    background_color = 0

    # 1. Identify Grid Structure
    grid_line_color, grid_rows, grid_cols = find_grid_lines(input_grid)
    
    if grid_line_color is None:
         # If no grid lines detected, maybe return input as is?
         # Based on examples, grid lines seem guaranteed.
         print("Warning: No grid lines detected.")
         return output_grid

    # 2. Define Regions
    region_coords = define_regions(height, width, grid_rows, grid_cols)

    # 3. Extract and Characterize Region Contents & Group Regions
    region_patterns = {} # Store pattern for each region coords: {(r1,c1,r2,c2): pattern_tuple}
    pattern_groups = defaultdict(list) # Group coords by pattern: {pattern_tuple: [(r1,c1,r2,c2), ...]}

    for coords in region_coords:
        r1, c1, r2, c2 = coords
        content = extract_content(input_grid, r1, c1, r2, c2)
        pattern = get_pattern_tuple(content, background_color, grid_line_color)
        
        region_patterns[coords] = pattern
        if pattern is not None: # Only group regions with actual patterns
            pattern_groups[pattern].append(coords)

    # 4. Identify Swap Pairs
    swaps_to_perform = [] # List of pairs of coords to swap: [ ((rA1,cA1,rA2,cA2), (rB1,cB1,rB2,cB2)), ... ]

    for pattern, coords_list in pattern_groups.items():
        if len(coords_list) >= 2:
            # Sort regions by top-left corner (row, then column)
            sorted_coords = sorted(coords_list, key=lambda c: (c[0], c[1]))
            
            # Pair consecutive regions
            for i in range(0, len(sorted_coords) // 2 * 2, 2):
                region_A_coords = sorted_coords[i]
                region_B_coords = sorted_coords[i+1]
                swaps_to_perform.append((region_A_coords, region_B_coords))

    # 5. Perform Swaps
    # We need to extract content *before* modifying the output grid to avoid double-swapping issues
    content_cache = {}
    for coords_A, coords_B in swaps_to_perform:
        if coords_A not in content_cache:
            content_cache[coords_A] = extract_content(input_grid, *coords_A)
        if coords_B not in content_cache:
            content_cache[coords_B] = extract_content(input_grid, *coords_B)

    # Now place the cached content into the output grid
    for coords_A, coords_B in swaps_to_perform:
        content_A = content_cache[coords_A]
        content_B = content_cache[coords_B]
        
        # Place content B into region A location
        place_content(output_grid, *coords_A, content_B)
        # Place content A into region B location
        place_content(output_grid, *coords_B, content_A)

    # 6. Finalize Output
    return output_grid
```
```python
import numpy as np
from collections import defaultdict
import itertools

"""
Transforms the input grid based on patterns within regions defined by grid lines.

1.  **Grid and Region Identification:** Identifies solid horizontal and vertical grid lines of a single non-background color. These lines partition the grid into rectangular regions.
2.  **Pattern Extraction:** For each region, extracts its content and determines its 'pattern' (the arrangement of non-background, non-grid-line colors). Empty regions have no pattern.
3.  **Transformation Rules:** Applies transformations based on the patterns and arrangement of regions:
    *   **2x2 Block - Identical Patterns:** If four adjacent regions forming a 2x2 block contain the *same* non-empty pattern, the content of the top-left region swaps with the bottom-left, and the top-right swaps with the bottom-right (vertical swaps).
    *   **2x2 Block - Distinct Patterns:** If four adjacent regions forming a 2x2 block contain four *distinct* non-empty patterns, their contents undergo a 3-cycle rotation: Top-Right moves to Bottom-Left, Bottom-Left moves to Bottom-Right, and Bottom-Right moves to Top-Right. The Top-Left region's content remains unchanged.
    *   **Group of 3 Identical Patterns:** If exactly three regions in the grid contain the *same* non-empty pattern, and they haven't been processed as part of a 2x2 block, the contents of the second and third regions (when sorted by top-left corner, row-major order) are swapped.
4.  **Execution:** Transformations are applied simultaneously to a copy of the input grid. Regions not matching these specific rules (empty regions, regions with unique patterns not part of a specific group, etc.) remain unchanged.
"""

def find_grid_lines(grid):
    """
    Finds horizontal and vertical grid lines and the single color forming them.
    A grid line is a full row or column composed of a single non-background color.
    Assumes only one such color exists based on examples.
    """
    height, width = grid.shape
    rows = []
    cols = []
    line_colors = set()

    for r in range(height):
        unique_colors = np.unique(grid[r, :])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
            rows.append(r)
            line_colors.add(unique_colors[0])

    for c in range(width):
        unique_colors = np.unique(grid[:, c])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
            cols.append(c)
            line_colors.add(unique_colors[0])

    if not line_colors:
        return None, [], []
    
    # Assume only one grid line color based on provided examples
    grid_line_color = list(line_colors)[0] 

    return grid_line_color, sorted(list(set(rows))), sorted(list(set(cols)))

def define_regions(height, width, grid_rows, grid_cols):
    """
    Defines region boundaries based on grid lines.
    Returns a list of tuples: (r1, c1, r2, c2) (inclusive top-left, exclusive bottom-right).
    Also returns a mapping from (row_idx, col_idx) of regions to their coords.
    """
    regions = []
    region_grid_map = {} # Map (region_row, region_col) index to coords
    coords_to_indices = {} # Map coords to (region_row, region_col) index

    row_starts = [0] + [r + 1 for r in grid_rows]
    row_ends = [r for r in grid_rows] + [height]
    col_starts = [0] + [c + 1 for c in grid_cols]
    col_ends = [c for c in grid_cols] + [width]

    region_row_idx = 0
    for r_start, r_end in zip(row_starts, row_ends):
        if r_start >= r_end: continue
        region_col_idx = 0
        for c_start, c_end in zip(col_starts, col_ends):
            if c_start >= c_end: continue
            
            coords = (r_start, c_start, r_end, c_end)
            regions.append(coords)
            indices = (region_row_idx, region_col_idx)
            region_grid_map[indices] = coords
            coords_to_indices[coords] = indices
            
            region_col_idx += 1
        region_row_idx += 1
                
    return regions, region_grid_map, coords_to_indices

def extract_content(grid, r1, c1, r2, c2):
    """Extracts the subgrid content of a region."""
    return grid[r1:r2, c1:c2]

def get_pattern_tuple(content, background_color=0, grid_line_color=None):
    """
    Creates a hashable representation (tuple of tuples) of the pattern,
    ignoring background and grid line colors. Returns None if the region
    contains no distinct pattern pixels.
    """
    pattern_list = []
    has_pattern = False
    if content.size == 0: # Handle empty content case
        return None
        
    for r in range(content.shape[0]):
        row_list = []
        for c in range(content.shape[1]):
            pixel = content[r, c]
            if pixel != background_color and pixel != grid_line_color:
                 row_list.append(pixel)
                 has_pattern = True
            else:
                 # Represent non-pattern pixels consistently (e.g., with background)
                 # This ensures patterns are compared correctly including empty space within them.
                 row_list.append(background_color) 
        pattern_list.append(tuple(row_list))
        
    # Return None only if NO pattern pixels were found at all
    if not has_pattern:
        return None 
        
    return tuple(pattern_list)

def place_content(grid, r1, c1, r2, c2, content_to_place):
    """Places the content_to_place into the specified region of the grid."""
    if grid[r1:r2, c1:c2].shape != content_to_place.shape:
        # This shouldn't happen if regions/content are handled correctly
        print(f"Warning: Shape mismatch during placement at {r1,c1,r2,c2}. Target: {grid[r1:r2, c1:c2].shape}, Source: {content_to_place.shape}")
        # Attempt resize or handle error? For now, skip placement if shapes mismatch.
        return
    grid[r1:r2, c1:c2] = content_to_place

def transform(input_grid):
    """
    Applies transformations based on region patterns and arrangements.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    background_color = 0

    # 1. Identify Grid Structure
    grid_line_color, grid_rows, grid_cols = find_grid_lines(input_grid)
    
    if grid_line_color is None:
         # No grid lines found, assume no transformation possible based on rules
         return output_grid 

    # 2. Define Regions
    region_coords_list, region_grid_map, coords_to_indices = define_regions(height, width, grid_rows, grid_cols)

    # 3. Extract Content and Patterns
    region_data = {} # {coords: {'content': ..., 'pattern': ...}}
    pattern_groups = defaultdict(list) # {pattern: [coords1, coords2, ...]}
    for coords in region_coords_list:
        r1, c1, r2, c2 = coords
        content = extract_content(input_grid, r1, c1, r2, c2)
        pattern = get_pattern_tuple(content, background_color, grid_line_color)
        region_data[coords] = {'content': content, 'pattern': pattern}
        if pattern is not None:
            pattern_groups[pattern].append(coords)

    processed_coords = set() # Track regions already handled by a rule
    swaps_to_perform = [] # List of (coords_A, coords_B)
    rotations_to_perform = [] # List of (coords_TL, coords_TR, coords_BL, coords_BR)

    # 4. Process 2x2 Blocks
    max_region_row = max(idx[0] for idx in region_grid_map.keys()) if region_grid_map else -1
    max_region_col = max(idx[1] for idx in region_grid_map.keys()) if region_grid_map else -1

    for r in range(max_region_row):
        for c in range(max_region_col):
            idx_tl = (r, c)
            idx_tr = (r, c + 1)
            idx_bl = (r + 1, c)
            idx_br = (r + 1, c + 1)

            # Check if all four indices exist in our region map
            if all(idx in region_grid_map for idx in [idx_tl, idx_tr, idx_bl, idx_br]):
                coords_tl = region_grid_map[idx_tl]
                coords_tr = region_grid_map[idx_tr]
                coords_bl = region_grid_map[idx_bl]
                coords_br = region_grid_map[idx_br]
                
                block_coords = {coords_tl, coords_tr, coords_bl, coords_br}

                # Check if any region in this block was already processed
                if not block_coords.intersection(processed_coords):
                    p_tl = region_data[coords_tl]['pattern']
                    p_tr = region_data[coords_tr]['pattern']
                    p_bl = region_data[coords_bl]['pattern']
                    p_br = region_data[coords_br]['pattern']

                    patterns = [p_tl, p_tr, p_bl, p_br]
                    
                    # Check if all patterns are non-empty
                    if all(p is not None for p in patterns):
                        # Case 2x2 Identical
                        if len(set(patterns)) == 1:
                            swaps_to_perform.append((coords_tl, coords_bl))
                            swaps_to_perform.append((coords_tr, coords_br))
                            processed_coords.update(block_coords)
                        # Case 2x2 Distinct
                        elif len(set(patterns)) == 4:
                             rotations_to_perform.append((coords_tl, coords_tr, coords_bl, coords_br))
                             processed_coords.update(block_coords)


    # 5. Process Remaining Identical Groups (Specifically N=3 case)
    for pattern, coords_list in pattern_groups.items():
        # Filter out coords already processed by 2x2 rules
        active_coords = [c for c in coords_list if c not in processed_coords]
        
        # Case N=3 Identical
        if len(active_coords) == 3:
            # Sort by top-left corner (row, then column)
            sorted_coords = sorted(active_coords, key=lambda c: (c[0], c[1]))
            # Swap 2nd and 3rd
            swaps_to_perform.append((sorted_coords[1], sorted_coords[2]))
            processed_coords.update(active_coords) # Mark these 3 as processed


    # 6. Perform Transformations
    # Cache original content for all involved regions *before* modifying output_grid
    content_cache = {}
    regions_to_cache = set()
    for coords_A, coords_B in swaps_to_perform:
        regions_to_cache.add(coords_A)
        regions_to_cache.add(coords_B)
    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_perform:
         regions_to_cache.add(coords_TR)
         regions_to_cache.add(coords_BL)
         regions_to_cache.add(coords_BR) # TL doesn't move, but its content might be needed if involved elsewhere? Better safe. Add all 4.
         regions_to_cache.add(coords_TL)


    for coords in regions_to_cache:
         if coords not in content_cache: # Avoid re-extracting if already cached
            content_cache[coords] = region_data[coords]['content'] # Use the originally extracted content


    # Apply swaps
    for coords_A, coords_B in swaps_to_perform:
        if coords_A in content_cache and coords_B in content_cache:
            content_A = content_cache[coords_A]
            content_B = content_cache[coords_B]
            place_content(output_grid, *coords_A, content_B)
            place_content(output_grid, *coords_B, content_A)
        else:
             print(f"Warning: Missing content cache for swap between {coords_A} and {coords_B}")

    # Apply rotations (3-cycle: TR->BL, BL->BR, BR->TR)
    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_perform:
         # Ensure all required contents are cached
        if all(c in content_cache for c in [coords_TR, coords_BL, coords_BR]):
            content_TR = content_cache[coords_TR]
            content_BL = content_cache[coords_BL]
            content_BR = content_cache[coords_BR]
            # Perform the cycle
            place_content(output_grid, *coords_BL, content_TR) # TR content goes to BL location
            place_content(output_grid, *coords_BR, content_BL) # BL content goes to BR location
            place_content(output_grid, *coords_TR, content_BR) # BR content goes to TR location
            # TL remains unchanged: place_content(output_grid, *coords_TL, content_TL) implicitly done by copy
        else:
            print(f"Warning: Missing content cache for rotation involving {coords_TL}, {coords_TR}, {coords_BL}, {coords_BR}")


    return output_grid
```
