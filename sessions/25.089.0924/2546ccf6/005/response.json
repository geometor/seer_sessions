{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport itertools\n\n\"\"\"\nTransforms the input grid based on patterns within regions defined by grid lines, applying specific rules for 2x2 blocks and groups of identical patterns.\n\n1.  **Grid and Region Identification:** Identifies solid horizontal and vertical grid lines of a single non-background color. These lines partition the grid into rectangular regions.\n2.  **Pattern Extraction:** For each region, extracts its content and determines its 'pattern' (the arrangement of non-background, non-grid-line colors, represented as a tuple of tuples). Empty regions (only background or grid line color) have a pattern of `None`.\n3.  **Rule Application Strategy:**\n    *   Rules are identified based on region patterns and arrangements.\n    *   Transformations are scheduled first.\n    *   Regions involved in a transformation are marked as 'processed' to prevent applying multiple rules to the same region.\n    *   Scheduled transformations are executed simultaneously on a copy of the input grid using cached original content.\n4.  **Transformation Rule 1: 2x2 Distinct Patterns:**\n    *   Identifies 2x2 blocks of adjacent regions where all four regions have distinct, non-empty patterns.\n    *   Schedules a 3-cycle rotation for the content of these regions: Top-Right -> Bottom-Left, Bottom-Left -> Bottom-Right, Bottom-Right -> Top-Right. The Top-Left region's content remains in place but the region is marked as processed.\n5.  **Transformation Rule 2: Identical Pattern Pairs:**\n    *   Groups regions with identical, non-empty patterns.\n    *   For each group, considers only regions *not* already processed by Rule 1.\n    *   If 2 or more unprocessed regions remain in a group, sorts them by top-left corner (row-major).\n    *   Schedules content swaps between consecutive pairs (1st <-> 2nd, 3rd <-> 4th, etc.) within the sorted, unprocessed regions of that group. Marks swapped regions as processed.\n6.  **Execution:** Applies all scheduled swaps and rotations to produce the final output grid. Regions not involved in any transformation remain unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_grid_lines(grid):\n    \"\"\"\n    Finds horizontal and vertical grid lines and the single color forming them.\n    A grid line is a full row or column composed of a single non-background color.\n    Assumes only one such color exists based on examples.\n    Returns: grid_line_color (int or None), rows (list of int), cols (list of int)\n    \"\"\"\n    height, width = grid.shape\n    rows = []\n    cols = []\n    line_colors = set()\n\n    # Find potential horizontal lines and their colors\n    for r in range(height):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            rows.append(r)\n            line_colors.add(unique_colors[0])\n\n    # Find potential vertical lines and their colors\n    for c in range(width):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            cols.append(c)\n            line_colors.add(unique_colors[0])\n\n    if not line_colors:\n        return None, [], [] # No grid lines found\n\n    # In this task, assume only one color forms the grid lines\n    # More complex logic might be needed if multiple colors could form lines\n    grid_line_color = list(line_colors)[0] \n    \n    # Filter rows/cols to only include those matching the determined grid_line_color\n    # This handles cases where other full lines might exist but aren't the 'grid'\n    final_rows = [r for r in rows if np.all(grid[r, :] == grid_line_color)]\n    final_cols = [c for c in cols if np.all(grid[:, c] == grid_line_color)]\n\n\n    return grid_line_color, sorted(list(set(final_rows))), sorted(list(set(final_cols)))\n\ndef define_regions(height, width, grid_rows, grid_cols):\n    \"\"\"\n    Defines region boundaries based on grid lines.\n    Returns:\n        regions_coords_list: List of tuples [(r1, c1, r2, c2), ...] (inclusive top-left, exclusive bottom-right).\n        region_grid_map: Dict mapping (region_row, region_col) index to coords tuple.\n        coords_to_indices: Dict mapping coords tuple back to (region_row, region_col) index.\n    \"\"\"\n    regions_coords_list = []\n    region_grid_map = {} \n    coords_to_indices = {} \n\n    # Define the start and end points for rows and columns based on grid lines\n    row_starts = [0] + [r + 1 for r in grid_rows]\n    row_ends = [r for r in grid_rows] + [height]\n    col_starts = [0] + [c + 1 for c in grid_cols]\n    col_ends = [c for c in grid_cols] + [width]\n\n    region_row_idx = 0\n    for r_start, r_end in zip(row_starts, row_ends):\n        # Skip if the region would have zero height (e.g., adjacent grid lines)\n        if r_start >= r_end: continue \n        region_col_idx = 0\n        for c_start, c_end in zip(col_starts, col_ends):\n            # Skip if the region would have zero width\n            if c_start >= c_end: continue \n            \n            coords = (r_start, c_start, r_end, c_end)\n            regions_coords_list.append(coords)\n            \n            indices = (region_row_idx, region_col_idx)\n            region_grid_map[indices] = coords\n            coords_to_indices[coords] = indices\n            \n            region_col_idx += 1\n        region_row_idx += 1\n                \n    return regions_coords_list, region_grid_map, coords_to_indices\n\ndef extract_content(grid, r1, c1, r2, c2):\n    \"\"\"Extracts the subgrid content of a region.\"\"\"\n    return grid[r1:r2, c1:c2]\n\ndef get_pattern_tuple(content, background_color=0, grid_line_color=None):\n    \"\"\"\n    Creates a hashable representation (tuple of tuples) of the pattern within content,\n    ignoring background and grid line colors by replacing them with background_color.\n    Returns None if the region contains no distinct pattern pixels (only background/grid_line_color).\n    \"\"\"\n    if content is None or content.size == 0:\n        return None\n        \n    pattern_list = []\n    has_pattern_pixel = False\n    \n    # Iterate through each pixel of the content subgrid\n    for r in range(content.shape[0]):\n        row_list = []\n        for c in range(content.shape[1]):\n            pixel = content[r, c]\n            # Check if the pixel is a pattern pixel (not background, not grid line)\n            if pixel != background_color and pixel != grid_line_color:\n                 row_list.append(pixel)\n                 has_pattern_pixel = True # Mark that we found at least one pattern pixel\n            else:\n                 # Replace background/grid line pixels with background color for pattern representation\n                 row_list.append(background_color) \n        pattern_list.append(tuple(row_list))\n        \n    # Only return a pattern if it contained at least one non-background, non-grid-line pixel\n    if not has_pattern_pixel:\n        return None \n        \n    return tuple(pattern_list)\n\ndef place_content(grid, r1, c1, r2, c2, content_to_place):\n    \"\"\"Places the content_to_place into the specified region of the grid.\"\"\"\n    # Check for shape mismatch to prevent errors\n    target_shape = grid[r1:r2, c1:c2].shape\n    source_shape = content_to_place.shape\n    if target_shape != source_shape:\n        print(f\"Error: Shape mismatch during placement at ({r1}:{r2}, {c1}:{c2}). Target: {target_shape}, Source: {source_shape}\")\n        # Optionally raise an error or handle differently\n        return # Skip placement if shapes don't match\n    grid[r1:r2, c1:c2] = content_to_place\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformations based on region patterns and arrangements following the described rules.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    background_color = 0\n\n    # 1. Identify Grid Structure\n    grid_line_color, grid_rows, grid_cols = find_grid_lines(input_grid)\n    \n    # If no grid lines, no regions defined by lines, so return the original grid\n    if grid_line_color is None:\n         return output_grid \n\n    # 2. Define Regions\n    region_coords_list, region_grid_map, coords_to_indices = define_regions(height, width, grid_rows, grid_cols)\n\n    # 3. Extract Content and Patterns for each region\n    region_data = {} # Stores data per region: {coords: {'content': ndarray, 'pattern': tuple/None, 'indices': (r_idx, c_idx)}}\n    pattern_groups = defaultdict(list) # Groups coords by pattern: {pattern_tuple: [coords1, coords2, ...]}\n    \n    for coords in region_coords_list:\n        r1, c1, r2, c2 = coords\n        content = extract_content(input_grid, r1, c1, r2, c2)\n        pattern = get_pattern_tuple(content, background_color, grid_line_color)\n        indices = coords_to_indices[coords]\n        \n        region_data[coords] = {'content': content, 'pattern': pattern, 'indices': indices}\n        \n        # Add to pattern group only if it has a non-empty pattern\n        if pattern is not None:\n            pattern_groups[pattern].append(coords)\n\n    # --- Identify Transformations to Schedule ---\n    processed_coords = set() # Track region coordinates already part of a transformation\n    swaps_to_schedule = [] # List of pairs of coords to swap: [ (coords_A, coords_B), ... ]\n    rotations_to_schedule = [] # List of 4-tuples for 2x2 distinct rotation: [ (tl, tr, bl, br), ... ]\n\n    # 4. Schedule Rule 1: 2x2 Distinct Patterns Rotation\n    max_region_row = max(idx[0] for idx in region_grid_map.keys()) if region_grid_map else -1\n    max_region_col = max(idx[1] for idx in region_grid_map.keys()) if region_grid_map else -1\n\n    # Iterate through top-left corners of potential 2x2 blocks\n    for r_idx in range(max_region_row):\n        for c_idx in range(max_region_col):\n            idx_tl = (r_idx, c_idx)\n            idx_tr = (r_idx, c_idx + 1)\n            idx_bl = (r_idx + 1, c_idx)\n            idx_br = (r_idx + 1, c_idx + 1)\n\n            # Check if all four region indices form a valid 2x2 block in the region grid\n            if all(idx in region_grid_map for idx in [idx_tl, idx_tr, idx_bl, idx_br]):\n                coords_tl = region_grid_map[idx_tl]\n                coords_tr = region_grid_map[idx_tr]\n                coords_bl = region_grid_map[idx_bl]\n                coords_br = region_grid_map[idx_br]\n                \n                block_coords_set = {coords_tl, coords_tr, coords_bl, coords_br}\n\n                # Check if any region in this block has already been processed by another rule\n                if not block_coords_set.intersection(processed_coords):\n                    # Get patterns for the four regions\n                    p_tl = region_data[coords_tl]['pattern']\n                    p_tr = region_data[coords_tr]['pattern']\n                    p_bl = region_data[coords_bl]['pattern']\n                    p_br = region_data[coords_br]['pattern']\n\n                    patterns_in_block = [p_tl, p_tr, p_bl, p_br]\n                    \n                    # Rule condition: All four patterns must be non-empty (not None)\n                    if all(p is not None for p in patterns_in_block):\n                        # Rule condition: All four patterns must be distinct\n                        if len(set(patterns_in_block)) == 4:\n                             # Schedule the rotation\n                             rotations_to_schedule.append((coords_tl, coords_tr, coords_bl, coords_br))\n                             # Mark these regions as processed so they aren't used in Rule 2\n                             processed_coords.update(block_coords_set)\n\n\n    # 5. Schedule Rule 2: Identical Pattern Swaps (Pairs)\n    for pattern, coords_list in pattern_groups.items():\n        # Consider only regions *not* already processed by the 2x2 rule\n        unprocessed_coords_in_group = [c for c in coords_list if c not in processed_coords]\n        \n        # Rule condition: Need at least 2 unprocessed regions with the same pattern\n        if len(unprocessed_coords_in_group) >= 2:\n            # Sort these regions by their top-left corner (row, then column) for consistent pairing\n            sorted_unprocessed_coords = sorted(unprocessed_coords_in_group, key=lambda c: (c[0], c[1]))\n            \n            # Iterate through pairs (0,1), (2,3), ...\n            for i in range(0, len(sorted_unprocessed_coords) // 2 * 2, 2):\n                coords_A = sorted_unprocessed_coords[i]\n                coords_B = sorted_unprocessed_coords[i+1]\n                # Schedule the swap\n                swaps_to_schedule.append((coords_A, coords_B))\n                # Mark these two regions as processed\n                processed_coords.add(coords_A)\n                processed_coords.add(coords_B)\n\n\n    # --- Execute Scheduled Transformations ---\n\n    # 6. Cache original content for all regions involved in any transformation\n    # This ensures we use the state from the *input* grid for all operations\n    content_cache = {}\n    regions_to_cache = set()\n    \n    # Gather regions involved in swaps\n    for coords_A, coords_B in swaps_to_schedule:\n        regions_to_cache.add(coords_A)\n        regions_to_cache.add(coords_B)\n        \n    # Gather regions involved in rotations (need original content of the 3 moving pieces)\n    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_schedule:\n         regions_to_cache.add(coords_TR)\n         regions_to_cache.add(coords_BL)\n         regions_to_cache.add(coords_BR)\n         # Note: coords_TL isn't strictly needed for the rotation itself, \n         # but caching it doesn't hurt and simplifies logic slightly.\n\n    # Populate the cache using the original region_data\n    for coords in regions_to_cache:\n         if coords in region_data: # Check if coords are valid\n            content_cache[coords] = region_data[coords]['content']\n         else:\n             print(f\"Warning: Attempting to cache content for unknown coords: {coords}\")\n\n\n    # 7. Apply Swaps to the output_grid using cached content\n    for coords_A, coords_B in swaps_to_schedule:\n        # Ensure both regions' original content was successfully cached\n        if coords_A in content_cache and coords_B in content_cache:\n            content_A_original = content_cache[coords_A]\n            content_B_original = content_cache[coords_B]\n            \n            # Perform swap on output grid\n            place_content(output_grid, *coords_A, content_B_original)\n            place_content(output_grid, *coords_B, content_A_original)\n        else:\n             print(f\"Warning: Could not perform swap. Missing original content for {coords_A} or {coords_B}\")\n\n    # 8. Apply Rotations to the output_grid using cached content\n    # Rotation is a 3-cycle: TR -> BL, BL -> BR, BR -> TR\n    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_schedule:\n         # Ensure the 3 moving pieces' original content was cached\n        if all(c in content_cache for c in [coords_TR, coords_BL, coords_BR]):\n            content_TR_original = content_cache[coords_TR]\n            content_BL_original = content_cache[coords_BL]\n            content_BR_original = content_cache[coords_BR]\n            \n            # Perform the cyclic placement on the output grid\n            place_content(output_grid, *coords_BL, content_TR_original) # TR content goes to BL location\n            place_content(output_grid, *coords_BR, content_BL_original) # BL content goes to BR location\n            place_content(output_grid, *coords_TR, content_BR_original) # BR content goes to TR location\n            # TL location remains unchanged (already copied in output_grid initialization)\n        else:\n            print(f\"Warning: Could not perform rotation. Missing original content for one of {coords_TR}, {coords_BL}, {coords_BR}\")\n\n    # 9. Return the final state of the output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18784,
    "candidates_token_count": 4283,
    "total_token_count": 23067,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.598554,
  "retries": 1
}