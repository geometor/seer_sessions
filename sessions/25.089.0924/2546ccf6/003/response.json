{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport itertools\n\n\"\"\"\nTransforms the input grid based on patterns within regions defined by grid lines.\n\n1.  **Grid and Region Identification:** Identifies solid horizontal and vertical grid lines of a single non-background color. These lines partition the grid into rectangular regions.\n2.  **Pattern Extraction:** For each region, extracts its content and determines its 'pattern' (the arrangement of non-background, non-grid-line colors). Empty regions have no pattern.\n3.  **Transformation Rules:** Applies transformations based on the patterns and arrangement of regions:\n    *   **2x2 Block - Identical Patterns:** If four adjacent regions forming a 2x2 block contain the *same* non-empty pattern, the content of the top-left region swaps with the bottom-left, and the top-right swaps with the bottom-right (vertical swaps).\n    *   **2x2 Block - Distinct Patterns:** If four adjacent regions forming a 2x2 block contain four *distinct* non-empty patterns, their contents undergo a 3-cycle rotation: Top-Right moves to Bottom-Left, Bottom-Left moves to Bottom-Right, and Bottom-Right moves to Top-Right. The Top-Left region's content remains unchanged.\n    *   **Group of 3 Identical Patterns:** If exactly three regions in the grid contain the *same* non-empty pattern, and they haven't been processed as part of a 2x2 block, the contents of the second and third regions (when sorted by top-left corner, row-major order) are swapped.\n4.  **Execution:** Transformations are applied simultaneously to a copy of the input grid. Regions not matching these specific rules (empty regions, regions with unique patterns not part of a specific group, etc.) remain unchanged.\n\"\"\"\n\ndef find_grid_lines(grid):\n    \"\"\"\n    Finds horizontal and vertical grid lines and the single color forming them.\n    A grid line is a full row or column composed of a single non-background color.\n    Assumes only one such color exists based on examples.\n    \"\"\"\n    height, width = grid.shape\n    rows = []\n    cols = []\n    line_colors = set()\n\n    for r in range(height):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            rows.append(r)\n            line_colors.add(unique_colors[0])\n\n    for c in range(width):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            cols.append(c)\n            line_colors.add(unique_colors[0])\n\n    if not line_colors:\n        return None, [], []\n    \n    # Assume only one grid line color based on provided examples\n    grid_line_color = list(line_colors)[0] \n\n    return grid_line_color, sorted(list(set(rows))), sorted(list(set(cols)))\n\ndef define_regions(height, width, grid_rows, grid_cols):\n    \"\"\"\n    Defines region boundaries based on grid lines.\n    Returns a list of tuples: (r1, c1, r2, c2) (inclusive top-left, exclusive bottom-right).\n    Also returns a mapping from (row_idx, col_idx) of regions to their coords.\n    \"\"\"\n    regions = []\n    region_grid_map = {} # Map (region_row, region_col) index to coords\n    coords_to_indices = {} # Map coords to (region_row, region_col) index\n\n    row_starts = [0] + [r + 1 for r in grid_rows]\n    row_ends = [r for r in grid_rows] + [height]\n    col_starts = [0] + [c + 1 for c in grid_cols]\n    col_ends = [c for c in grid_cols] + [width]\n\n    region_row_idx = 0\n    for r_start, r_end in zip(row_starts, row_ends):\n        if r_start >= r_end: continue\n        region_col_idx = 0\n        for c_start, c_end in zip(col_starts, col_ends):\n            if c_start >= c_end: continue\n            \n            coords = (r_start, c_start, r_end, c_end)\n            regions.append(coords)\n            indices = (region_row_idx, region_col_idx)\n            region_grid_map[indices] = coords\n            coords_to_indices[coords] = indices\n            \n            region_col_idx += 1\n        region_row_idx += 1\n                \n    return regions, region_grid_map, coords_to_indices\n\ndef extract_content(grid, r1, c1, r2, c2):\n    \"\"\"Extracts the subgrid content of a region.\"\"\"\n    return grid[r1:r2, c1:c2]\n\ndef get_pattern_tuple(content, background_color=0, grid_line_color=None):\n    \"\"\"\n    Creates a hashable representation (tuple of tuples) of the pattern,\n    ignoring background and grid line colors. Returns None if the region\n    contains no distinct pattern pixels.\n    \"\"\"\n    pattern_list = []\n    has_pattern = False\n    if content.size == 0: # Handle empty content case\n        return None\n        \n    for r in range(content.shape[0]):\n        row_list = []\n        for c in range(content.shape[1]):\n            pixel = content[r, c]\n            if pixel != background_color and pixel != grid_line_color:\n                 row_list.append(pixel)\n                 has_pattern = True\n            else:\n                 # Represent non-pattern pixels consistently (e.g., with background)\n                 # This ensures patterns are compared correctly including empty space within them.\n                 row_list.append(background_color) \n        pattern_list.append(tuple(row_list))\n        \n    # Return None only if NO pattern pixels were found at all\n    if not has_pattern:\n        return None \n        \n    return tuple(pattern_list)\n\ndef place_content(grid, r1, c1, r2, c2, content_to_place):\n    \"\"\"Places the content_to_place into the specified region of the grid.\"\"\"\n    if grid[r1:r2, c1:c2].shape != content_to_place.shape:\n        # This shouldn't happen if regions/content are handled correctly\n        print(f\"Warning: Shape mismatch during placement at {r1,c1,r2,c2}. Target: {grid[r1:r2, c1:c2].shape}, Source: {content_to_place.shape}\")\n        # Attempt resize or handle error? For now, skip placement if shapes mismatch.\n        return\n    grid[r1:r2, c1:c2] = content_to_place\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformations based on region patterns and arrangements.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    background_color = 0\n\n    # 1. Identify Grid Structure\n    grid_line_color, grid_rows, grid_cols = find_grid_lines(input_grid)\n    \n    if grid_line_color is None:\n         # No grid lines found, assume no transformation possible based on rules\n         return output_grid \n\n    # 2. Define Regions\n    region_coords_list, region_grid_map, coords_to_indices = define_regions(height, width, grid_rows, grid_cols)\n\n    # 3. Extract Content and Patterns\n    region_data = {} # {coords: {'content': ..., 'pattern': ...}}\n    pattern_groups = defaultdict(list) # {pattern: [coords1, coords2, ...]}\n    for coords in region_coords_list:\n        r1, c1, r2, c2 = coords\n        content = extract_content(input_grid, r1, c1, r2, c2)\n        pattern = get_pattern_tuple(content, background_color, grid_line_color)\n        region_data[coords] = {'content': content, 'pattern': pattern}\n        if pattern is not None:\n            pattern_groups[pattern].append(coords)\n\n    processed_coords = set() # Track regions already handled by a rule\n    swaps_to_perform = [] # List of (coords_A, coords_B)\n    rotations_to_perform = [] # List of (coords_TL, coords_TR, coords_BL, coords_BR)\n\n    # 4. Process 2x2 Blocks\n    max_region_row = max(idx[0] for idx in region_grid_map.keys()) if region_grid_map else -1\n    max_region_col = max(idx[1] for idx in region_grid_map.keys()) if region_grid_map else -1\n\n    for r in range(max_region_row):\n        for c in range(max_region_col):\n            idx_tl = (r, c)\n            idx_tr = (r, c + 1)\n            idx_bl = (r + 1, c)\n            idx_br = (r + 1, c + 1)\n\n            # Check if all four indices exist in our region map\n            if all(idx in region_grid_map for idx in [idx_tl, idx_tr, idx_bl, idx_br]):\n                coords_tl = region_grid_map[idx_tl]\n                coords_tr = region_grid_map[idx_tr]\n                coords_bl = region_grid_map[idx_bl]\n                coords_br = region_grid_map[idx_br]\n                \n                block_coords = {coords_tl, coords_tr, coords_bl, coords_br}\n\n                # Check if any region in this block was already processed\n                if not block_coords.intersection(processed_coords):\n                    p_tl = region_data[coords_tl]['pattern']\n                    p_tr = region_data[coords_tr]['pattern']\n                    p_bl = region_data[coords_bl]['pattern']\n                    p_br = region_data[coords_br]['pattern']\n\n                    patterns = [p_tl, p_tr, p_bl, p_br]\n                    \n                    # Check if all patterns are non-empty\n                    if all(p is not None for p in patterns):\n                        # Case 2x2 Identical\n                        if len(set(patterns)) == 1:\n                            swaps_to_perform.append((coords_tl, coords_bl))\n                            swaps_to_perform.append((coords_tr, coords_br))\n                            processed_coords.update(block_coords)\n                        # Case 2x2 Distinct\n                        elif len(set(patterns)) == 4:\n                             rotations_to_perform.append((coords_tl, coords_tr, coords_bl, coords_br))\n                             processed_coords.update(block_coords)\n\n\n    # 5. Process Remaining Identical Groups (Specifically N=3 case)\n    for pattern, coords_list in pattern_groups.items():\n        # Filter out coords already processed by 2x2 rules\n        active_coords = [c for c in coords_list if c not in processed_coords]\n        \n        # Case N=3 Identical\n        if len(active_coords) == 3:\n            # Sort by top-left corner (row, then column)\n            sorted_coords = sorted(active_coords, key=lambda c: (c[0], c[1]))\n            # Swap 2nd and 3rd\n            swaps_to_perform.append((sorted_coords[1], sorted_coords[2]))\n            processed_coords.update(active_coords) # Mark these 3 as processed\n\n\n    # 6. Perform Transformations\n    # Cache original content for all involved regions *before* modifying output_grid\n    content_cache = {}\n    regions_to_cache = set()\n    for coords_A, coords_B in swaps_to_perform:\n        regions_to_cache.add(coords_A)\n        regions_to_cache.add(coords_B)\n    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_perform:\n         regions_to_cache.add(coords_TR)\n         regions_to_cache.add(coords_BL)\n         regions_to_cache.add(coords_BR) # TL doesn't move, but its content might be needed if involved elsewhere? Better safe. Add all 4.\n         regions_to_cache.add(coords_TL)\n\n\n    for coords in regions_to_cache:\n         if coords not in content_cache: # Avoid re-extracting if already cached\n            content_cache[coords] = region_data[coords]['content'] # Use the originally extracted content\n\n\n    # Apply swaps\n    for coords_A, coords_B in swaps_to_perform:\n        if coords_A in content_cache and coords_B in content_cache:\n            content_A = content_cache[coords_A]\n            content_B = content_cache[coords_B]\n            place_content(output_grid, *coords_A, content_B)\n            place_content(output_grid, *coords_B, content_A)\n        else:\n             print(f\"Warning: Missing content cache for swap between {coords_A} and {coords_B}\")\n\n    # Apply rotations (3-cycle: TR->BL, BL->BR, BR->TR)\n    for coords_TL, coords_TR, coords_BL, coords_BR in rotations_to_perform:\n         # Ensure all required contents are cached\n        if all(c in content_cache for c in [coords_TR, coords_BL, coords_BR]):\n            content_TR = content_cache[coords_TR]\n            content_BL = content_cache[coords_BL]\n            content_BR = content_cache[coords_BR]\n            # Perform the cycle\n            place_content(output_grid, *coords_BL, content_TR) # TR content goes to BL location\n            place_content(output_grid, *coords_BR, content_BL) # BL content goes to BR location\n            place_content(output_grid, *coords_TR, content_BR) # BR content goes to TR location\n            # TL remains unchanged: place_content(output_grid, *coords_TL, content_TL) implicitly done by copy\n        else:\n            print(f\"Warning: Missing content cache for rotation involving {coords_TL}, {coords_TR}, {coords_BL}, {coords_BR}\")\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13827,
    "candidates_token_count": 3461,
    "total_token_count": 17288,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 136.496243,
  "retries": 2
}