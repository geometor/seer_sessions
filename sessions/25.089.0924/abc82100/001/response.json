{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule depends on specific features present in the input grid.\n\n1.  Check for a Vertical Red Line: If a contiguous vertical line of Red (2) exists spanning the grid's height:\n    - The Red line itself turns Blue (1).\n    - The area to the left of the line is filled with Red (2).\n    - The area to the right (excluding the original line) is filled with white (0).\n\n2.  Check for Azure: If no vertical Red line is found, check for the presence of Azure (8).\n    - If Azure (8) exists:\n        a. Count the frequency of all non-white (0) and non-azure (8) colors.\n        b. Identify the color with the highest frequency (Most Frequent Color - MFC).\n        c. If MFC is Blue (1):\n            - Find the largest contiguous Blue (1) object.\n            - Create a white output grid.\n            - Draw the largest Blue object onto the output grid, but colored Red (2).\n        d. If MFC is Magenta (6):\n            - Create an intermediate grid: Magenta(6)->Orange(7), Orange(7)->Magenta(6), Red(2)->Yellow(4), Yellow(4)->Red(2). Azure(8) and all other colors become white(0).\n            - Initialize the final output grid from this intermediate grid.\n            - Iterate through the *original* input grid. If an input pixel is Magenta(6) and the pixel below it is white(0), color the corresponding pixel below in the *output* grid Orange(7).\n            - Similarly, if an input pixel is Orange(7) and the pixel below it is white(0), color the corresponding pixel below in the *output* grid Magenta(6).\n        e. If MFC is Yellow (4):\n            - Create a white output grid.\n            - Iterate through the input grid. If a pixel is Yellow(4), set the output pixel to Red(2). If a pixel is Blue(1), set the output pixel to Orange(7). Other colors remain white.\n\n3.  Default Case: If neither a vertical Red line nor Azure is present, return the input grid unchanged (based on the lack of examples for this scenario).\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a given color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef find_vertical_line_column(grid, color):\n    \"\"\"Checks for a vertical line of a specific color and returns its column index.\"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        is_line = True\n        for r in range(height):\n            if grid[r, c] != color:\n                is_line = False\n                break\n        if is_line:\n            return c\n    return None\n\ndef get_color_counts(grid):\n    \"\"\"Counts the frequency of non-white (0) and non-azure (8) colors.\"\"\"\n    counts = Counter()\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != 0 and color != 8:\n                counts[color] += 1\n    return counts\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the presence of a vertical red line\n    or the most frequent color alongside azure.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    output_grid = np.array(input_grid_np, dtype=int) # Start with a copy, modify as needed\n\n    # 1. Check for Vertical Red Line\n    red_line_col = find_vertical_line_column(input_grid_np, 2)\n    if red_line_col is not None:\n        output_grid = np.zeros_like(input_grid_np) # Start fresh for this rule\n        # a. Fill left side with Red (2)\n        output_grid[:, :red_line_col] = 2\n        # b. Change line itself to Blue (1)\n        output_grid[:, red_line_col] = 1\n        # c. Right side is already white (0) due to initialization\n        return output_grid.tolist()\n\n    # 2. Check for Azure (8)\n    if 8 in input_grid_np:\n        color_counts = get_color_counts(input_grid_np)\n\n        # Handle cases where there are no non-white, non-azure colors\n        if not color_counts:\n             # If only white and azure exist, specific rules might apply,\n             # but based on examples, perhaps clear the grid?\n             # Let's clear Azure for now, consistent with other Azure rules.\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n\n        mfc = max(color_counts, key=color_counts.get)\n\n        # 2.c. MFC is Blue (1)\n        if mfc == 1:\n            blue_objects = find_objects(input_grid_np, 1)\n            if not blue_objects: # Should not happen if blue is MFC, but safe check\n                output_grid = np.zeros_like(input_grid_np)\n                return output_grid.tolist()\n\n            largest_blue_object = max(blue_objects, key=len)\n            output_grid = np.zeros_like(input_grid_np) # Start with white grid\n            for r, c in largest_blue_object:\n                output_grid[r, c] = 2 # Change to Red\n            return output_grid.tolist()\n\n        # 2.d. MFC is Magenta (6)\n        elif mfc == 6:\n            intermediate_grid = np.zeros_like(input_grid_np)\n            # Apply initial swaps and removals\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 6: # Magenta -> Orange\n                        intermediate_grid[r, c] = 7\n                    elif color == 7: # Orange -> Magenta\n                        intermediate_grid[r, c] = 6\n                    elif color == 2: # Red -> Yellow\n                        intermediate_grid[r, c] = 4\n                    elif color == 4: # Yellow -> Red\n                        intermediate_grid[r, c] = 2\n                    # Azure (8) and other colors become white (0) implicitly\n\n            output_grid = np.array(intermediate_grid) # Copy intermediate to final output\n\n            # Apply row duplication logic based on *original* input\n            for r in range(height - 1): # Iterate up to second to last row\n                for c in range(width):\n                    input_color = input_grid_np[r, c]\n                    below_input_color = input_grid_np[r + 1, c]\n\n                    if input_color == 6 and below_input_color == 0: # Magenta above white\n                        output_grid[r + 1, c] = 7 # Color below Orange\n                    elif input_color == 7 and below_input_color == 0: # Orange above white\n                        output_grid[r + 1, c] = 6 # Color below Magenta\n\n            return output_grid.tolist()\n\n        # 2.e. MFC is Yellow (4)\n        elif mfc == 4:\n            output_grid = np.zeros_like(input_grid_np) # Start with white grid\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 4: # Yellow -> Red\n                        output_grid[r, c] = 2\n                    elif color == 1: # Blue -> Orange\n                        output_grid[r, c] = 7\n                    # Other colors (including Azure, original Red, original Orange) remain white\n            return output_grid.tolist()\n        else:\n            # If MFC is some other color (not covered by examples),\n            # potentially remove Azure and return? For now, remove Azure.\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n\n    # 3. Default Case: No vertical red line and no Azure\n    # Return the input grid unchanged as per instruction\n    return input_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5803,
    "candidates_token_count": 2232,
    "total_token_count": 8035,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.900763,
  "retries": 1
}