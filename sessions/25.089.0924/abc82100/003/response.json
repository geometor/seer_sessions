{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on a hierarchical set of rules:\n\n1.  Vertical Red Line Rule: If a contiguous vertical line of Red (2) pixels exists spanning the grid's height at column 'c':\n    - Copy the input grid to the output grid.\n    - Change the pixels in the output grid at column 'c' to Blue (1).\n    - Fill the area in the output grid to the left of the line (columns < c) with Red (2).\n    - Pixels to the right (columns > c) remain as they were in the input grid.\n    This rule takes precedence over all others.\n\n2.  Azure Presence Rule: If no vertical Red line is found, check if Azure (8) is present in the input grid.\n    - If Azure (8) is present:\n        a. Count the frequency of all non-white (0) and non-azure (8) colors.\n        b. If no such colors exist (only white and/or azure present): Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n        c. If other colors exist, find the Most Frequent Color (MFC) among them. (Assume lowest color value wins ties, though none observed in examples).\n        d. Apply transformation based on MFC:\n            - If MFC is Blue (1):\n                i. Find all contiguous Blue (1) objects using 8-way adjacency (including diagonals).\n                ii. Identify the largest Blue object by pixel count.\n                iii. Create a new output grid filled entirely with white (0).\n                iv. Draw the shape of the largest Blue object onto the output grid using Red (2).\n            - If MFC is Magenta (6):\n                i. Create an intermediate grid, initially filled with white (0).\n                ii. Populate the intermediate grid by applying these transformations based on the input grid: Magenta(6)->Orange(7), Orange(7)->Magenta(6), Red(2)->Yellow(4), Yellow(4)->Red(2). All other input colors (including Azure) result in white(0) in the intermediate grid.\n                iii. Initialize the final output grid as a copy of this intermediate grid.\n                iv. Iterate through the *original input* grid. If an input pixel at (r, c) is Magenta(6) and the pixel below it (r+1, c) is white(0) (and within bounds), set the *final output* grid pixel at (r+1, c) to Orange(7).\n                v. Similarly, if an input pixel at (r, c) is Orange(7) and the pixel below it (r+1, c) is white(0) (and within bounds), set the *final output* grid pixel at (r+1, c) to Magenta(6).\n            - If MFC is Yellow (4):\n                i. Initialize the output grid filled entirely with white (0).\n                ii. Iterate through the input grid. If an input pixel is Yellow(4), set the corresponding output pixel to Red(2). If an input pixel is Blue(1), set the corresponding output pixel to Orange(7). All other input pixel colors result in white(0) at the corresponding output location.\n            - If MFC is any other color: (Fallback based on observed Azure removal) Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n\n3.  Default Rule: If no vertical Red line is found AND Azure (8) is not present, return the input grid unchanged.\n\"\"\"\n\ndef find_objects(grid, color, adjacency=4):\n    \"\"\"Finds all contiguous objects of a given color using specified adjacency.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    if adjacency == 8:\n        neighbor_deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else: # Default to 4-way\n        neighbor_deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check neighbors\n                    for dr, dc in neighbor_deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef find_vertical_line_column(grid, color):\n    \"\"\"Checks for a vertical line of a specific color and returns its column index.\"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        is_line = True\n        if height == 0: continue # Handle empty grid case\n        for r in range(height):\n            if grid[r, c] != color:\n                is_line = False\n                break\n        if is_line:\n            return c\n    return None\n\ndef get_color_counts(grid):\n    \"\"\"Counts the frequency of non-white (0) and non-azure (8) colors.\"\"\"\n    counts = Counter()\n    if grid.size == 0: return counts # Handle empty grid\n    grid_flat = grid.flatten()\n    for color in grid_flat:\n        if color != 0 and color != 8:\n            counts[color] += 1\n    return counts\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the presence of a vertical red line\n    or the most frequent color alongside azure.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    if height == 0 or width == 0: # Handle empty input\n        return []\n\n    # 1. Check for Vertical Red Line\n    red_line_col = find_vertical_line_column(input_grid_np, 2)\n    if red_line_col is not None:\n        output_grid = np.array(input_grid_np) # Start with a copy\n        # a. Fill left side with Red (2)\n        if red_line_col > 0:\n            output_grid[:, :red_line_col] = 2\n        # b. Change line itself to Blue (1)\n        output_grid[:, red_line_col] = 1\n        # c. Right side remains as copied from input\n        return output_grid.tolist()\n\n    # 2. Check for Azure (8)\n    if 8 in input_grid_np:\n        color_counts = get_color_counts(input_grid_np)\n\n        # 2.b Handle cases where there are no non-white, non-azure colors\n        if not color_counts:\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n        # 2.c Find MFC (using min color value as tie-breaker if needed)\n        mfc = max(color_counts, key=lambda k: (color_counts[k], -k)) # Higher count wins, then lower color value wins\n\n        # 2.d Apply transformation based on MFC\n        # MFC is Blue (1)\n        if mfc == 1:\n            # Find largest blue object using 8-way adjacency\n            blue_objects = find_objects(input_grid_np, 1, adjacency=8)\n            if not blue_objects:\n                # Should not happen if blue is MFC, but as a safe fallback, treat as 'other MFC'\n                 output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n                 return output_grid.tolist()\n\n            largest_blue_object = max(blue_objects, key=len)\n            output_grid = np.zeros_like(input_grid_np) # Start with white grid\n            for r, c in largest_blue_object:\n                output_grid[r, c] = 2 # Change to Red\n            return output_grid.tolist()\n\n        # MFC is Magenta (6)\n        elif mfc == 6:\n            # Create intermediate grid with initial swaps\n            intermediate_grid = np.zeros_like(input_grid_np)\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 6: intermediate_grid[r, c] = 7 # Magenta -> Orange\n                    elif color == 7: intermediate_grid[r, c] = 6 # Orange -> Magenta\n                    elif color == 2: intermediate_grid[r, c] = 4 # Red -> Yellow\n                    elif color == 4: intermediate_grid[r, c] = 2 # Yellow -> Red\n                    # Other colors (0, 1, 3, 5, 8, 9) result in 0\n\n            output_grid = np.array(intermediate_grid) # Copy intermediate to final output\n\n            # Apply row duplication logic based on *original* input\n            for r in range(height - 1): # Iterate up to second to last row\n                for c in range(width):\n                    input_color = input_grid_np[r, c]\n                    below_input_color = input_grid_np[r + 1, c]\n\n                    if input_color == 6 and below_input_color == 0: # Magenta above white in input\n                        output_grid[r + 1, c] = 7 # Color below Orange in output\n                    elif input_color == 7 and below_input_color == 0: # Orange above white in input\n                        output_grid[r + 1, c] = 6 # Color below Magenta in output\n\n            return output_grid.tolist()\n\n        # MFC is Yellow (4)\n        elif mfc == 4:\n            output_grid = np.zeros_like(input_grid_np) # Start with white grid\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 4: # Yellow -> Red\n                        output_grid[r, c] = 2\n                    elif color == 1: # Blue -> Orange\n                        output_grid[r, c] = 7\n                    # Other colors remain white (0)\n            return output_grid.tolist()\n\n        # MFC is any other color (Fallback)\n        else:\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n\n    # 3. Default Case: No vertical red line and no Azure\n    # Return the input grid unchanged\n    return input_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21241,
    "candidates_token_count": 2623,
    "total_token_count": 23864,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.050978,
  "retries": 1
}