{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple, Set\n\ndef find_key_pairs(grid: np.ndarray) -> Dict[int, int]:\n    \"\"\"\n    Scans the top-left corner (first few rows, first two columns)\n    of the input grid to identify key pairs (C1, C2).\n    Assumes keys are in input[r, 0] and input[r, 1] where both are non-zero.\n    \"\"\"\n    key_map = {}\n    rows, cols = grid.shape\n    # Scan first few rows (e.g., up to 5 or until first all-zero row in cols 0,1)\n    # and first two columns for pairs\n    for r in range(rows):\n        if cols < 2: # Grid too narrow for pairs\n            break\n        c1 = grid[r, 0]\n        c2 = grid[r, 1]\n        if c1 != 0 and c2 != 0:\n            if c1 not in key_map: # Avoid overwriting if C1 appears multiple times\n                 key_map[c1] = c2\n        # Heuristic: Stop scanning for keys if we encounter a row\n        # where the first two cells are zero, assuming keys are contiguous at the top.\n        # Adjust if keys can appear below empty rows.\n        elif c1 == 0 and c2 == 0 and r > 0: \n             # Check if previous row had a key to decide if we are past the key area\n             if grid[r-1, 0] != 0 and grid[r-1, 1] != 0:\n                 break # Likely finished the key section\n\n    return key_map\n\ndef find_pattern_pixels(grid: np.ndarray, pattern_color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (r, c) where the grid has the pattern_color.\"\"\"\n    rows, cols = grid.shape\n    pixels = []\n    # Iterate through the grid, potentially skipping the key area if needed,\n    # though bounding box calculation implicitly handles this if patterns don't overlap keys.\n    # For simplicity, search the whole grid.\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == pattern_color:\n                pixels.append((r, c))\n    return pixels\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms an input grid based on key pairs and pattern columns into an\n    output grid with corresponding filled checkerboard rectangles.\n\n    1. Identifies key pairs (C1, C2) in the top-left of the input grid.\n    2. For each unique color P found elsewhere in the grid:\n        a. Looks up the corresponding fill color K using the key pair (P, K).\n        b. Finds all locations of P in the input grid.\n        c. Calculates the bounding box enclosing these locations.\n        d. Fills the bounding box in the output grid:\n            - Input cells with color P become P in the output.\n            - Input cells with color 0 (white) become K in the output.\n    \"\"\"\n    \n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # Initialize the output grid with the background color (white, 0)\n    output_array = np.zeros_like(input_array)\n\n    # 1. Find key pairs (C1 maps to C2)\n    key_map = find_key_pairs(input_array)\n\n    # 2. Identify unique potential pattern colors (non-zero colors in the grid)\n    # We only care about colors that appear as C1 in the key_map.\n    potential_pattern_colors = set(key_map.keys())\n\n    # 3. Process each pattern color found in the keys\n    for pattern_color in potential_pattern_colors:\n        fill_color = key_map[pattern_color]\n\n        # 4. Find all pixels matching the current pattern_color\n        pattern_pixels = find_pattern_pixels(input_array, pattern_color)\n\n        # If this pattern color doesn't actually appear in the grid (outside keys maybe?)\n        # or only appears in the key area itself, skip. find_pattern_pixels helps here.\n        if not pattern_pixels:\n            continue\n\n        # 5. Determine the bounding box for these pixels\n        min_r = min(r for r, c in pattern_pixels)\n        max_r = max(r for r, c in pattern_pixels)\n        min_c = min(c for r, c in pattern_pixels)\n        max_c = max(c for r, c in pattern_pixels)\n\n        # 6. Fill the bounding box in the output grid based on input values\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                # Check if the coordinate (r,c) is within the grid bounds (redundant if loop is correct)\n                # if 0 <= r < rows and 0 <= c < cols: # Safety check, likely not needed with range()\n                input_color = input_array[r, c]\n                if input_color == pattern_color:\n                    output_array[r, c] = pattern_color\n                elif input_color == 0: # Background color\n                    output_array[r, c] = fill_color\n                # else: # Handle cases where other colors might be inside the bounding box\n                    # Based on examples, the bounding box seems to only contain\n                    # the pattern_color and background(0). If other colors exist,\n                    # the current logic leaves them as 0 in the output.\n                    # If they should be preserved or handled differently, logic needs adjustment.\n                    # For now, we assume only pattern_color and 0 exist within the minimal bbox\n                    # of pattern_color pixels when considering the checkerboard fill.\n\n    # Convert the result back to a list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7719,
    "candidates_token_count": 1432,
    "total_token_count": 9151,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 111.618891,
  "retries": 2
}