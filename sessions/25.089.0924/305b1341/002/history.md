
## train_1

**input:**
```
5 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 8 0 0 4 0 4 0 4 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 5 0 5 0 5 0 0 4 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 5 0 5 0 5 0 0 4 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 5 0 5 0 5 0 0 4 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 5 0 5 0 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 7 7 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0
0 0 0 7 8 7 8 7 8 7 0 0 0 0 0 0 0 0 0 0
0 0 0 7 7 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0
0 0 0 7 8 7 8 7 8 7 0 0 0 0 0 0 0 0 0 0
0 0 0 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 0
0 0 0 7 8 7 8 7 8 7 3 4 3 4 3 4 3 4 3 0
0 0 0 7 7 7 7 6 6 6 6 6 6 6 3 3 3 3 3 0
0 0 0 7 8 7 8 6 5 6 5 6 5 6 3 4 3 4 3 0
0 0 0 7 7 7 7 6 6 6 6 6 6 6 3 3 3 3 3 0
0 0 0 7 8 7 8 6 5 6 5 6 5 6 3 4 3 4 3 0
0 0 0 7 7 7 7 6 6 6 6 6 6 6 3 3 3 3 3 0
0 0 0 7 8 7 8 6 5 6 5 6 5 6 3 4 3 4 3 0
0 0 0 7 7 7 7 6 6 6 6 6 6 6 3 3 3 3 3 0
0 0 0 7 8 7 8 6 5 6 5 6 5 6 0 0 0 0 0 0
0 0 0 7 7 7 7 6 6 6 6 6 6 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 4 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 4 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 4 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 4 0 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 7 8 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 0 0 0 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 7 8 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 0 0 0 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 7 8 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 1 1 1 1 1 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 1 4 1 4 1 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 1 1 1 1 1 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 1 4 1 4 1 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 1 1 1 1 1 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 1 4 1 4 1 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 1 1 1 1 1 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 1 4 1 4 1 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 1 1 1 1 1 7 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 7 8 7 8 7 8 7 8 7 0 0 0 0 0 0
0 0 0 0 0 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0
```


## train_3

**input:**
```
1 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 1 0 0 7 0 7 0 7 0 7 0 7 0 0 0 0 0 0 0
7 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 8 7 8 7 8 7 8 7 8 7 8 0 0 0 0 0 0
0 0 0 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 8 7 1 1 1 1 1 1 1 7 8 0 0 0 0 0 0
0 0 0 8 8 1 8 1 8 1 8 1 8 8 0 0 0 0 0 0
0 0 0 8 7 1 1 1 1 1 1 1 7 8 0 0 0 0 0 0
0 0 0 8 8 1 8 1 8 1 8 1 8 8 0 0 0 0 0 0
0 0 0 8 7 1 1 1 1 1 1 1 7 8 0 0 0 0 0 0
0 0 0 8 8 1 8 1 8 1 8 1 8 8 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 1 8 1 8 1 8 1 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 1 8 1 8 1 8 1 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1 3 1 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1 3 1 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception of Task Elements:**

1.  **Input Structure:**
    *   The input grids contain distinct regions.
    *   The top-left corner (typically the first few rows and first two columns) features pairs of non-white pixels. These pairs appear unique in each example and seem to act as a legend or key.
    *   The rest of the grid often contains vertical columns characterized by a repeating pattern of a single color alternating with white (`C 0 C 0 ...`). These pattern columns are separated by columns of all white pixels. Different pattern colors can exist in the same input grid.

2.  **Output Structure:**
    *   The output grids consist of rectangular blocks filled with checkerboard patterns.
    *   Each checkerboard pattern uses two colors.
    *   The locations and colors of these checkerboard rectangles correspond to the locations and colors of the pattern columns in the input.

3.  **Transformation:**
    *   The key pairs in the input's top-left define the two colors used for the checkerboard fill in the output. If a key pair is `(C1, C2)`, it seems to relate to input pattern columns of color `C1`. The corresponding output rectangle uses `C1` and `C2` for its checkerboard.
    *   For each distinct pattern color `C1` found in the input columns:
        *   Locate the corresponding key pair `(C1, C2)` in the top-left.
        *   Identify all columns containing the pattern color `C1`.
        *   Determine the bounding box (minimum and maximum row and column) that encloses all instances of `C1` within its pattern columns.
        *   In the output grid, fill this bounding box area. Cells within the bounding box that corresponded to `C1` in the input are filled with `C1` (which is `F2` in the logic below). Cells that corresponded to white (`0`) in the input are filled with `C2` (which is `F1` in the logic below).

**YAML Fact Document:**


```yaml
task_description: Transform input grids based on key pairs and pattern columns into output grids with corresponding filled checkerboard rectangles.

elements:
  - object: key_pairs
    description: Pairs of non-white pixels located in the top-left area of the input grid.
    properties:
      - location: Typically rows 0-2, columns 0-1.
      - structure: Two adjacent non-white pixels, e.g., `(C1, C2)`.
    role: Define the color mapping for the transformation. A pair `(C1, C2)` indicates that input patterns of color `C1` should be transformed using colors `C1` and `C2`.

  - object: pattern_columns
    description: Vertical columns in the input grid containing a repeating sequence of a specific color `C` and white `0` (e.g., `C 0 C 0...`).
    properties:
      - structure: Alternating non-white color `C` and white `0`.
      - separation: Pattern columns are usually separated by columns containing only white pixels.
      - multiplicity: Multiple pattern columns with different colors can exist in one input.
    role: Define the areas to be transformed in the output grid.

  - object: output_rectangle
    description: A rectangular area in the output grid filled with a two-color checkerboard pattern.
    properties:
      - fill: Two colors, determined by a key pair from the input.
      - pattern: Checkerboard fill.
      - location: Corresponds to the bounding box of a specific pattern color `C1` from the input's pattern columns.
      - color_rule: Input cells with `C1` become `C1` in output; input cells with `0` become `C2` in output (where `(C1, C2)` is the key pair).

actions:
  - action: identify_key_pairs
    description: Scan the top-left region of the input grid to find all color pairs `(C1, C2)`.
    output: A mapping from `C1` to `C2`. (Implicitly, `C1` also maps to itself).

  - action: identify_pattern_areas
    description: For each unique pattern color `C1` found outside the key pair region:
      - Find all columns containing `C1`.
      - Calculate the bounding box (min_row, max_row, min_col, max_col) enclosing all `C1` pixels within these columns.
    output: A set of bounding boxes, one for each pattern color `C1`, associated with the colors `(C1, C2)` derived from the key pairs.

  - action: generate_output
    description: Create an output grid of the same dimensions as the input, initially filled with white (`0`).
    input: Bounding boxes and associated fill colors `(C1, C2)`.
    process: For each bounding box associated with `(C1, C2)`:
      - Iterate through each cell `(r, c)` within the bounding box.
      - If the corresponding input cell `input[r][c]` was `C1`, set `output[r][c]` to `C1`.
      - If the corresponding input cell `input[r][c]` was `0`, set `output[r][c]` to `C2`.

relationships:
  - relationship: key_pair_to_pattern
    description: The first color `C1` of a key pair `(C1, C2)` corresponds to the color `C1` found in pattern columns.
  - relationship: pattern_to_rectangle
    description: The bounding box of a pattern color `C1` in the input defines the location and extent of the corresponding output rectangle.
  - relationship: key_pair_to_fill
    description: The key pair `(C1, C2)` determines the two colors (`C1` and `C2`) used to fill the output rectangle corresponding to pattern `C1`.
```


**Natural Language Program:**

1.  Initialize an empty output grid with the same dimensions as the input grid, filled with the background color (white, 0).
2.  Scan the top-left corner of the input grid (e.g., first 3 rows, first 2 columns) to identify all pairs of adjacent non-white pixels `(C1, C2)`. Store these as a mapping where the first color `C1` maps to the second color `C2`. Let's call this the `key_map`.
3.  Identify all unique non-white colors present in the input grid *outside* the key pair region. These are the pattern colors.
4.  For each unique pattern color `P` identified in step 3:
    a.  Check if `P` exists as a first color (`C1`) in the `key_map`. If not, skip this pattern color. Let the corresponding second color from the map be `K` (so `K = key_map[P]`).
    b.  Find all cell coordinates `(r, c)` in the input grid where the pixel value is `P`.
    c.  Determine the minimum and maximum row indices (`min_r`, `max_r`) and minimum and maximum column indices (`min_c`, `max_c`) from the coordinates found in step 4b. This defines the bounding box for pattern `P`.
    d.  Iterate through all cells `(r, c)` within this bounding box (from `min_r` to `max_r`, and `min_c` to `max_c`).
    e.  For each cell `(r, c)` inside the bounding box:
        i.  If the input grid at `input[r][c]` has the color `P`, set the output grid at `output[r][c]` to `P`.
        ii. If the input grid at `input[r][c]` has the background color (white, 0), set the output grid at `output[r][c]` to `K` (the corresponding second color from the key pair).
5.  Return the completed output grid.
```python
import numpy as np
from typing import List, Dict, Tuple, Set

def find_key_pairs(grid: np.ndarray) -> Dict[int, int]:
    """
    Scans the top-left corner (first few rows, first two columns)
    of the input grid to identify key pairs (C1, C2).
    Assumes keys are in input[r, 0] and input[r, 1] where both are non-zero.
    """
    key_map = {}
    rows, cols = grid.shape
    # Scan first few rows (e.g., up to 5 or until first all-zero row in cols 0,1)
    # and first two columns for pairs
    for r in range(rows):
        if cols < 2: # Grid too narrow for pairs
            break
        c1 = grid[r, 0]
        c2 = grid[r, 1]
        if c1 != 0 and c2 != 0:
            if c1 not in key_map: # Avoid overwriting if C1 appears multiple times
                 key_map[c1] = c2
        # Heuristic: Stop scanning for keys if we encounter a row
        # where the first two cells are zero, assuming keys are contiguous at the top.
        # Adjust if keys can appear below empty rows.
        elif c1 == 0 and c2 == 0 and r > 0: 
             # Check if previous row had a key to decide if we are past the key area
             if grid[r-1, 0] != 0 and grid[r-1, 1] != 0:
                 break # Likely finished the key section

    return key_map

def find_pattern_pixels(grid: np.ndarray, pattern_color: int) -> List[Tuple[int, int]]:
    """Finds all coordinates (r, c) where the grid has the pattern_color."""
    rows, cols = grid.shape
    pixels = []
    # Iterate through the grid, potentially skipping the key area if needed,
    # though bounding box calculation implicitly handles this if patterns don't overlap keys.
    # For simplicity, search the whole grid.
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == pattern_color:
                pixels.append((r, c))
    return pixels


def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Transforms an input grid based on key pairs and pattern columns into an
    output grid with corresponding filled checkerboard rectangles.

    1. Identifies key pairs (C1, C2) in the top-left of the input grid.
    2. For each unique color P found elsewhere in the grid:
        a. Looks up the corresponding fill color K using the key pair (P, K).
        b. Finds all locations of P in the input grid.
        c. Calculates the bounding box enclosing these locations.
        d. Fills the bounding box in the output grid:
            - Input cells with color P become P in the output.
            - Input cells with color 0 (white) become K in the output.
    """
    
    # Convert input list of lists to a numpy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    rows, cols = input_array.shape

    # Initialize the output grid with the background color (white, 0)
    output_array = np.zeros_like(input_array)

    # 1. Find key pairs (C1 maps to C2)
    key_map = find_key_pairs(input_array)

    # 2. Identify unique potential pattern colors (non-zero colors in the grid)
    # We only care about colors that appear as C1 in the key_map.
    potential_pattern_colors = set(key_map.keys())

    # 3. Process each pattern color found in the keys
    for pattern_color in potential_pattern_colors:
        fill_color = key_map[pattern_color]

        # 4. Find all pixels matching the current pattern_color
        pattern_pixels = find_pattern_pixels(input_array, pattern_color)

        # If this pattern color doesn't actually appear in the grid (outside keys maybe?)
        # or only appears in the key area itself, skip. find_pattern_pixels helps here.
        if not pattern_pixels:
            continue

        # 5. Determine the bounding box for these pixels
        min_r = min(r for r, c in pattern_pixels)
        max_r = max(r for r, c in pattern_pixels)
        min_c = min(c for r, c in pattern_pixels)
        max_c = max(c for r, c in pattern_pixels)

        # 6. Fill the bounding box in the output grid based on input values
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                # Check if the coordinate (r,c) is within the grid bounds (redundant if loop is correct)
                # if 0 <= r < rows and 0 <= c < cols: # Safety check, likely not needed with range()
                input_color = input_array[r, c]
                if input_color == pattern_color:
                    output_array[r, c] = pattern_color
                elif input_color == 0: # Background color
                    output_array[r, c] = fill_color
                # else: # Handle cases where other colors might be inside the bounding box
                    # Based on examples, the bounding box seems to only contain
                    # the pattern_color and background(0). If other colors exist,
                    # the current logic leaves them as 0 in the output.
                    # If they should be preserved or handled differently, logic needs adjustment.
                    # For now, we assume only pattern_color and 0 exist within the minimal bbox
                    # of pattern_color pixels when considering the checkerboard fill.

    # Convert the result back to a list of lists
    output_grid = output_array.tolist()

    return output_grid
```
