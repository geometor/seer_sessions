{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on the properties of non-background objects (assumed to be solid rectangles).\n\nThe transformation rule depends on the presence of exactly one 1x1 object:\n\n1. If exactly one 1x1 non-background object exists in the input grid:\n   - This 1x1 object expands into a 9x9 square of the same color, centered at the original pixel's location, in the output grid.\n   - All other non-background objects in the input grid shrink by removing their outer layer (1 pixel from each side). An object of size WxH becomes (W-2)x(H-2). Objects smaller than 3x3 in either dimension disappear after shrinking.\n\n2. If the number of 1x1 non-background objects is not exactly one (zero or more than one):\n   - All non-background objects shrink by removing their outer layer, as described above.\n\nThe background color (orange, 7) remains unchanged unless overwritten by expanding or shrinking objects.\n\"\"\"\n\ndef find_objects(grid, background_color=7):\n    \"\"\"\n    Finds all contiguous objects of the same color, excluding the background color.\n    Assumes objects are solid rectangles based on task description.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'pixels' (set of (r, c) tuples), and\n              'bbox' (tuple: min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity should be sufficient for solid rectangles)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef draw_rectangle(grid, r1, c1, r2, c2, color):\n    \"\"\"Draws a solid rectangle on the grid, handling boundary conditions.\"\"\"\n    rows, cols = grid.shape\n    min_r = max(0, r1)\n    min_c = max(0, c1)\n    max_r = min(rows - 1, r2)\n    max_c = min(cols - 1, c2)\n    if min_r <= max_r and min_c <= max_c:\n        grid[min_r:max_r + 1, min_c:max_c + 1] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list or np.array): The input grid.\n\n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    background_color = 7\n\n    # Initialize output grid with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # Find all non-background objects\n    objects = find_objects(input_np, background_color)\n\n    # Count 1x1 objects and identify the expanding one if applicable\n    one_by_one_objects = []\n    other_objects = []\n    expander_obj = None\n\n    for obj in objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        if height == 1 and width == 1:\n            one_by_one_objects.append(obj)\n        else:\n            other_objects.append(obj)\n\n    # Determine if the special expansion case applies\n    apply_expansion = len(one_by_one_objects) == 1\n    if apply_expansion:\n        expander_obj = one_by_one_objects[0]\n\n    # Apply transformations\n    if apply_expansion:\n        # Case 1: Expand the 1x1 object and shrink others\n        print(f\"Found one 1x1 object. Expanding.\")\n        \n        # Expand the 1x1 object\n        r, c = list(expander_obj['pixels'])[0] # Get the single pixel coordinate\n        color = expander_obj['color']\n        draw_rectangle(output_grid, r - 4, c - 4, r + 4, c + 4, color)\n        print(f\"  Expanded object {expander_obj['color']} at ({r},{c}) to 9x9.\")\n\n\n        # Shrink other objects\n        for obj in other_objects:\n            min_r, min_c, max_r, max_c = obj['bbox']\n            height = max_r - min_r + 1\n            width = max_c - min_c + 1\n            color = obj['color']\n\n            if width >= 3 and height >= 3:\n                draw_rectangle(output_grid, min_r + 1, min_c + 1, max_r - 1, max_c - 1, color)\n                print(f\"  Shrunk object {color} from {width}x{height} to {width-2}x{height-2}.\")\n            else:\n                 print(f\"  Object {color} ({width}x{height}) disappeared after shrinking.\")\n\n\n    else:\n        # Case 2: Shrink all objects (including any 1x1 or larger ones)\n        print(f\"Found {len(one_by_one_objects)} 1x1 objects. Shrinking all.\")\n        for obj in objects: # Process all original objects\n            min_r, min_c, max_r, max_c = obj['bbox']\n            height = max_r - min_r + 1\n            width = max_c - min_c + 1\n            color = obj['color']\n\n            if width >= 3 and height >= 3:\n                draw_rectangle(output_grid, min_r + 1, min_c + 1, max_r - 1, max_c - 1, color)\n                print(f\"  Shrunk object {color} from {width}x{height} to {width-2}x{height-2}.\")\n            else:\n                 print(f\"  Object {color} ({width}x{height}) disappeared after shrinking.\")\n\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6868,
    "candidates_token_count": 1850,
    "total_token_count": 8718,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.422448,
  "retries": 1
}