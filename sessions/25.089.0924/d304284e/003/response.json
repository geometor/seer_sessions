{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the single connected object (input pattern) of non-background color (white=0) in the input grid. Record its shape as relative pixel offsets (`input_pattern_shape`), its original color (`original_color`), and the coordinates of its top-left pixel (`r0`, `c0`).\n2. Define a fixed 3x3 '8' pattern shape using relative offsets: `fixed_pattern_shape = [(0,0), (0,1), (0,2), (1,0), (1,2), (2,0), (2,1), (2,2)]`.\n3. Define an alternate color (magenta=6) and a step size (4).\n4. Create an output grid of the same dimensions as the input, filled with the background color.\n5. Tile patterns across the output grid. The top-left corner of each potential tile is calculated as `(r, c) = (r0 + step_size * j, c0 + step_size * i)` for non-negative integers `i` (column index) and `j` (row index).\n6. For each potential tile position `(i, j)`:\n    a. If it's in the original row (`j == 0`):\n        - Use the `input_pattern_shape`.\n        - Use the `alternate_color` if `i % 3 == 2`, otherwise use the `original_color`.\n        - Draw the pattern.\n    b. If it's in a subsequent row (`j > 0`):\n        - Only draw if `i % 3 == 2`.\n        - If drawing, use the `fixed_pattern_shape` and the `alternate_color`.\n    c. When drawing, iterate through the chosen pattern's relative offsets `(dr, dc)`. Calculate the absolute pixel coordinates `(pr, pc) = (r + dr, c + dc)`. If `(pr, pc)` is within the grid boundaries, set the output grid pixel at that location to the chosen color. This allows for partial patterns at the edges.\n7. Return the final output grid.\n\"\"\"\n\ndef find_pattern_details(grid):\n    \"\"\"\n    Finds the first non-background connected object in the grid using BFS.\n\n    Args:\n        grid: numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - original_color (int): The color of the pattern.\n        - top_left (tuple): The (row, col) of the top-left pixel of the pattern.\n        - shape_offsets (list): A list of (dr, dc) offsets relative to top_left.\n        Returns None if no pattern is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    q = deque()\n    pattern_pixels = []\n    original_color = -1\n    start_pixel = None\n\n    # Find the first non-background pixel to start the search\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                start_pixel = (r, c)\n                original_color = grid[r, c]\n                break\n        if start_pixel:\n            break\n\n    if not start_pixel:\n        return None # No pattern found\n\n    # Use BFS to find all connected pixels of the same color (4-connectivity)\n    q.append(start_pixel)\n    visited[start_pixel] = True\n    min_r, min_c = start_pixel\n\n    while q:\n        r, c = q.popleft()\n        pattern_pixels.append((r, c))\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not visited[nr, nc] and grid[nr, nc] == original_color:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n\n    if not pattern_pixels:\n         return None # Should not happen\n\n    top_left = (min_r, min_c)\n\n    # Calculate relative offsets\n    shape_offsets = sorted([(r - min_r, c - min_c) for r, c in pattern_pixels])\n\n    return original_color, top_left, shape_offsets\n\ndef place_pattern_clipped(grid, shape_offsets, r_start, c_start, color):\n    \"\"\"\n    Places the pattern onto the grid pixel by pixel, clipping at boundaries.\n\n    Args:\n        grid: The output grid (numpy array) to modify.\n        shape_offsets: List of (dr, dc) offsets for the pattern relative to (r_start, c_start).\n        r_start: The target row for the top-left corner of the pattern.\n        c_start: The target column for the top-left corner of the pattern.\n        color: The color to use for drawing the pattern.\n    \"\"\"\n    rows, cols = grid.shape\n    for dr, dc in shape_offsets:\n        pr, pc = r_start + dr, c_start + dc\n        # Check bounds before placing pixel\n        if 0 <= pr < rows and 0 <= pc < cols:\n            grid[pr, pc] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the tiling and color transformation rule to the input grid.\n    \"\"\"\n    # Define constants and parameters\n    BACKGROUND_COLOR = 0\n    ALTERNATE_COLOR = 6\n    STEP_SIZE = 4\n    fixed_pattern_shape = [(0,0), (0,1), (0,2), (1,0), (1,2), (2,0), (2,1), (2,2)]\n\n    # --- Step 1 & 2: Identify input pattern and define fixed pattern ---\n    details = find_pattern_details(input_grid)\n    if details is None:\n        # If no pattern, return an empty grid matching input size\n        return np.full_like(input_grid, BACKGROUND_COLOR)\n\n    original_color, (r0, c0), input_pattern_shape = details\n    rows, cols = input_grid.shape\n\n    # --- Step 4: Initialize output grid ---\n    output_grid = np.full_like(input_grid, BACKGROUND_COLOR)\n\n    # --- Step 5-10: Iterate through tiles and draw patterns ---\n    j = 0 # Row index for tiling\n    while True:\n        r_base = r0 + STEP_SIZE * j\n        # Optimization: If the starting row is already off-grid, stop\n        if r_base >= rows:\n            break\n\n        i = 0 # Column index for tiling\n        while True:\n            c_base = c0 + STEP_SIZE * i\n            # Optimization: If the starting column is already off-grid for this row, move to next row\n            if c_base >= cols:\n                break\n\n            # Determine pattern shape, color, and if we should draw\n            should_draw = False\n            shape_to_draw = None\n            color_to_use = -1\n\n            if j == 0: # Original row\n                should_draw = True\n                shape_to_draw = input_pattern_shape\n                if i % 3 == 2:\n                    color_to_use = ALTERNATE_COLOR\n                else:\n                    color_to_use = original_color\n            elif j > 0: # Subsequent rows\n                if i % 3 == 2:\n                    should_draw = True\n                    shape_to_draw = fixed_pattern_shape\n                    color_to_use = ALTERNATE_COLOR\n\n            # Place the determined pattern if applicable\n            if should_draw:\n                place_pattern_clipped(output_grid, shape_to_draw, r_base, c_base, color_to_use)\n\n            i += 1\n        j += 1\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22166,
    "candidates_token_count": 1891,
    "total_token_count": 24057,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.669681,
  "retries": 1
}