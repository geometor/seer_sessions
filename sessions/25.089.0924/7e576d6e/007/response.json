{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent color in the grid).\n2. Identify the path color and the two endpoint coordinates. This color appears exactly twice and is different from the background color.\n3. Identify obstacle pixels/colors (any color that is not the background or path color).\n4. Find the shortest path between the two endpoints using Breadth-First Search (BFS). The path can only move horizontally or vertically onto cells containing the background color. Obstacle cells cannot be part of the path. The target endpoint cell is considered traversable even though it's not background color.\n5. Create an output grid by copying the input grid.\n6. Draw the found shortest path onto the output grid using the path color, changing the color of the background cells that form the path. The endpoints remain their original color.\n\"\"\"\n\n\ndef find_colors_and_endpoints(grid):\n    \"\"\"\n    Identifies background color, path color, endpoint coordinates,\n    and obstacle colors from the input grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (background_color, path_color, endpoints, obstacle_colors)\n               obstacle_colors is a set.\n    Raises:\n        ValueError: If the grid is empty, path color is not found, or\n                    exactly two endpoints for the path color are not found.\n    \"\"\"\n    if grid.size == 0:\n        raise ValueError(\"Grid is empty.\")\n\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    # Background color is the most frequent\n    # Handle ties by picking one arbitrarily (max behavior)\n    background_color = max(color_counts, key=color_counts.get)\n\n    path_color = None\n    endpoints = []\n    obstacle_colors = set()\n    path_color_candidates = []\n\n    # Find path color (appears twice) and obstacle colors\n    for color, count in color_counts.items():\n        if color == background_color:\n            continue\n        if count == 2:\n            path_color_candidates.append(color)\n        else:\n            # Treat any other non-background color as obstacle initially\n            obstacle_colors.add(color)\n\n    if len(path_color_candidates) == 1:\n        path_color = path_color_candidates[0]\n    elif len(path_color_candidates) > 1:\n         # If multiple colors appear twice, add them all to obstacles and raise error\n         # as the path endpoints are ambiguous.\n         for pc in path_color_candidates:\n             obstacle_colors.add(pc)\n         raise ValueError(f\"Ambiguous: Multiple colors appear twice: {path_color_candidates}\")\n    else: # No color (other than potentially background) appears exactly twice\n        # Check if background color appears exactly twice (edge case)\n        if color_counts[background_color] == 2:\n             path_color = background_color\n             # Obstacles are all other colors\n             obstacle_colors = set(color_counts.keys()) - {background_color}\n        else:\n            raise ValueError(\"Path color (exactly two pixels) not found.\")\n\n\n    # Find endpoint coordinates\n    endpoint_coords = np.argwhere(grid == path_color)\n    if len(endpoint_coords) != 2:\n         # This check should be redundant given the logic above but acts as a safeguard\n         raise ValueError(f\"Expected 2 endpoints for color {path_color}, found {len(endpoint_coords)}.\")\n    endpoints = [tuple(coord) for coord in endpoint_coords]\n\n    # Ensure endpoint color is not accidentally listed as an obstacle color\n    # (Can happen if path_color was background_color)\n    if path_color in obstacle_colors:\n        obstacle_colors.remove(path_color)\n\n    return background_color, path_color, endpoints, obstacle_colors\n\n\ndef reconstruct_path(came_from, current):\n    \"\"\"Reconstructs the path from the came_from dictionary.\"\"\"\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    return path[::-1] # Return reversed path (start to end)\n\ndef bfs_shortest_path_optimized(grid, start, end, background_color, obstacle_colors):\n    \"\"\"\n    Finds the shortest path using optimized Breadth-First Search (BFS)\n    with parent pointers for path reconstruction.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start (tuple): Starting coordinates (row, col).\n        end (tuple): Ending coordinates (row, col).\n        background_color (int): The color of traversable cells.\n        obstacle_colors (set): A set of colors representing obstacles.\n\n    Returns:\n        list: A list of coordinates (tuples) representing the shortest path\n              from start to end (inclusive), or None if no path is found.\n    \"\"\"\n    rows, cols = grid.shape\n    queue = deque([start])  # Queue stores positions to visit\n    visited = {start}\n    came_from = {} # Dictionary to store parent pointers: {child_pos: parent_pos}\n\n    while queue:\n        current_pos = queue.popleft()\n        r, c = current_pos\n\n        if current_pos == end:\n            # Path found, reconstruct it using came_from map\n            return reconstruct_path(came_from, end)\n\n        # Explore neighbors (Up, Down, Left, Right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n\n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if already visited\n                if neighbor_pos not in visited:\n                    neighbor_color = grid[nr, nc]\n\n                    # Check if valid move:\n                    # Must NOT be an obstacle color.\n                    # Must BE the background color OR the target endpoint.\n                    is_obstacle = neighbor_color in obstacle_colors\n                    is_traversable_background = (neighbor_color == background_color)\n                    is_target = (neighbor_pos == end)\n\n                    if not is_obstacle and (is_traversable_background or is_target):\n                        visited.add(neighbor_pos)\n                        came_from[neighbor_pos] = current_pos # Record parent\n                        queue.append(neighbor_pos)\n\n    return None # No path found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Finds and draws the shortest path between two designated points on a grid,\n    avoiding obstacles. The path consists of horizontal and vertical moves\n    on background-colored cells. The path itself is drawn using the color\n    of the start/end points.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = grid.copy()\n\n    try:\n        # 1. Identify background color, path color, endpoints, and obstacles\n        background_color, path_color, endpoints, obstacle_colors = find_colors_and_endpoints(grid)\n        start_point, end_point = endpoints[0], endpoints[1]\n\n        # 2. Find the shortest path using optimized BFS\n        shortest_path = bfs_shortest_path_optimized(grid, start_point, end_point, background_color, obstacle_colors)\n\n        # 3. Draw the path if found\n        if shortest_path:\n            # Iterate through the path coordinates.\n            # Start and end points are already the correct color.\n            # Color the intermediate points (those that were background).\n            for r, c in shortest_path[1:-1]: # Exclude start and end points\n                 # Only color if it's currently background color.\n                 if output_grid[r, c] == background_color:\n                     output_grid[r, c] = path_color\n        else:\n            # Handle cases where no path is found (though problem implies one exists).\n            # If no path found, the output grid remains an unmodified copy of the input.\n            print(f\"Warning: No path found between {start_point} and {end_point}.\")\n\n    except ValueError as e:\n        # Handle errors during identification (e.g., no unique path color/endpoints)\n        # If identification fails, return the original grid unmodified.\n        print(f\"Error during grid analysis: {e}. Returning original grid.\")\n        # output_grid is already a copy, so no action needed.\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 5431,
            "end_index": 5604,
            "uri": "https://github.com/nguyengiabinh/SWIN-COS30019-INTRO-TO-AI",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20562,
    "candidates_token_count": 2039,
    "total_token_count": 22601,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.911469,
  "retries": 1
}