{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies all maximal monochromatic rectangles within the input grid.\nA rectangle is monochromatic if all its pixels share the same color.\nA rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) \nwithout either going out of bounds or including a pixel of a different color.\n\nFor each maximal monochromatic rectangle found, its area (height * width) is calculated.\nIf the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid \nare replaced with the color yellow (4). \nIf the area is less than 25, the pixels within that rectangle remain unchanged from the input grid.\nAll pixels outside of any maximal monochromatic rectangle also remain unchanged.\n\"\"\"\n\ndef find_maximal_monochromatic_rectangles(grid):\n    \"\"\"\n    Finds all maximal monochromatic rectangles in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a maximal monochromatic rectangle\n              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.\n    \"\"\"\n    rows, cols = grid.shape\n    # Keep track of visited cells to avoid redundant checks and overlapping rectangles\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    # Iterate through each cell as a potential top-left corner of a rectangle\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if this cell has already been included in a found rectangle\n            if visited[r, c]:\n                continue\n\n            color = grid[r, c]\n\n            # Find the initial maximum width starting from (r, c) in the current row\n            initial_w = 0\n            for k in range(c, cols):\n                # Only extend width if the cell has the same color and hasn't been visited\n                if not visited[r, k] and grid[r, k] == color:\n                    initial_w += 1\n                else:\n                    # Stop extending width at the first mismatch or visited cell\n                    break\n            \n            # If no width found (e.g., starting cell was already visited), mark and skip\n            if initial_w == 0:\n                visited[r,c] = True # Ensure the starting cell is marked visited\n                continue\n\n            # Determine the maximum possible height for this rectangle\n            # The width might shrink as we check lower rows\n            final_h = 0\n            min_w = initial_w # Start with the width found for the first row\n            \n            # Iterate downwards from the starting row\n            for i in range(r, rows):\n                current_row_w = 0\n                # Check cells in the current row up to the current minimum width (min_w)\n                for j in range(c, c + min_w):\n                    # Stop if the cell is out of bounds, visited, or has the wrong color\n                    if j >= cols or visited[i, j] or grid[i, j] != color:\n                        # The rectangle cannot extend this wide in this row.\n                        # Update min_w to the width that *did* match in this row.\n                        min_w = j - c \n                        break # Stop checking this row further\n                    current_row_w +=1\n                \n                # If the width shrank to zero, or the loop finished because width became 0, stop extending height\n                if min_w == 0:\n                    break\n                \n                # If we successfully checked min_w columns in this row (current_row_w == min_w)\n                if current_row_w == min_w:\n                     final_h += 1 # Increment the height of the rectangle\n                else:\n                    # This should technically be caught by min_w becoming 0, but as a safeguard:\n                    # If the row check didn't complete fully up to min_w, stop extending height\n                     break\n\n\n            # We have found a maximal rectangle anchored at (r, c)\n            # with dimensions (final_h, min_w)\n            if final_h > 0 and min_w > 0:\n                # Mark all cells within the identified rectangle as visited\n                visited[r : r + final_h, c : c + min_w] = True\n                # Store the details of the found rectangle\n                rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})\n            elif not visited[r,c]:\n                 # If for some reason no rectangle was formed (e.g. h=0 or w=0)\n                 # ensure the starting cell is marked as visited.\n                 visited[r,c] = True\n\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling large monochromatic rectangles with yellow.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to a NumPy array for efficient array operations and slicing\n    np_grid = np.array(input_grid, dtype=int)\n    # Create a copy of the input grid to modify, this will be the output\n    output_grid = np_grid.copy()\n\n    # Define the minimum area threshold for a rectangle to be filled\n    min_area = 25\n\n    # Find all maximal monochromatic rectangles in the input grid\n    rectangles = find_maximal_monochromatic_rectangles(np_grid)\n\n    # Process each found rectangle\n    for rect in rectangles:\n        # Calculate the area of the current rectangle\n        area = rect['h'] * rect['w']\n\n        # Check if the area meets the minimum requirement\n        if area >= min_area:\n            # Get the position (top-left corner) and dimensions\n            r, c = rect['r'], rect['c']\n            h, w = rect['h'], rect['w']\n            \n            # Fill the area defined by the rectangle in the output grid with yellow (color 4)\n            # NumPy slicing allows efficient modification of the rectangular region\n            output_grid[r : r + h, c : c + w] = 4\n\n    # Convert the final NumPy array back to a list of lists format for the output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9242,
    "candidates_token_count": 1464,
    "total_token_count": 10706,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.605962,
  "retries": 1
}