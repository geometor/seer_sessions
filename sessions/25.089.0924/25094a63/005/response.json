{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies all maximal monochromatic rectangles within the input grid. \nA rectangle is monochromatic if all its pixels share the same color. \nA rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) \nwithout either going out of bounds or including a pixel of a different color.\n\nFor each maximal monochromatic rectangle found, its area (height * width) is calculated. \nIf the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid \nare replaced with the color yellow (4). \nIf the area is less than 25, the pixels within that rectangle remain unchanged from the input grid. \nAll pixels outside of any maximal monochromatic rectangle also remain unchanged.\n\"\"\"\n\ndef find_maximal_monochromatic_rectangles(grid):\n    \"\"\"\n    Finds all maximal monochromatic rectangles in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a maximal monochromatic rectangle\n              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.\n    \"\"\"\n    rows, cols = grid.shape\n    # visited helps track cells that are already part of a confirmed maximal rectangle\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    # Iterate through each cell as a potential top-left corner of a rectangle\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if this cell has already been included in a confirmed maximal rectangle\n            if visited[r, c]:\n                continue\n\n            color = grid[r, c]\n            \n            # --- Find potential rectangle dimensions starting at (r, c) ---\n            # 1. Find initial width in the starting row 'r'\n            current_w = 0\n            for k in range(c, cols):\n                if grid[r, k] == color:\n                    current_w += 1\n                else:\n                    break # Stop at first color change or boundary\n            \n            if current_w == 0: # Should not happen if loop starts correctly, but safeguard\n                 visited[r,c] = True # Mark this single cell visited if it leads nowhere\n                 continue\n\n            # 2. Find height, adjusting width if necessary\n            final_h = 0\n            min_w = current_w # Start with width from the first row\n            for i in range(r, rows):\n                row_w = 0\n                possible = True\n                for j in range(c, c + min_w):\n                     # Check boundary and color match for the current potential width (min_w)\n                    if j >= cols or grid[i, j] != color:\n                        min_w = j - c # Reduce width to the matched part\n                        possible = False\n                        break # Stop checking this row\n                    row_w += 1\n                \n                if not possible or min_w == 0: # If row didn't match full min_w or width became 0\n                    break # Stop extending height\n\n                # If the row matched the current min_w, increment height\n                final_h += 1\n\n            # Found a potential rectangle: (r, c) with dimensions (final_h, min_w)\n            if final_h > 0 and min_w > 0:\n                # --- Check for Maximality ---\n                is_maximal = True\n                \n                # Check Up: Can it extend upwards?\n                if r > 0:\n                    for k in range(c, c + min_w):\n                        if grid[r - 1, k] == color:\n                            is_maximal = False\n                            break\n                \n                # Check Down: Can it extend downwards?\n                if is_maximal and r + final_h < rows:\n                    for k in range(c, c + min_w):\n                        if grid[r + final_h, k] == color:\n                            is_maximal = False\n                            break\n                            \n                # Check Left: Can it extend leftwards?\n                if is_maximal and c > 0:\n                    for i in range(r, r + final_h):\n                        if grid[i, c - 1] == color:\n                            is_maximal = False\n                            break\n                            \n                # Check Right: Can it extend rightwards?\n                if is_maximal and c + min_w < cols:\n                     for i in range(r, r + final_h):\n                        if grid[i, c + min_w] == color:\n                            is_maximal = False\n                            break\n\n                # --- Store if Maximal and Mark Visited ---\n                if is_maximal:\n                    # Check if any part of this maximal rectangle has already been visited\n                    # This prevents adding duplicates if the algorithm somehow restarts\n                    # within an already found maximal region.\n                    if not visited[r : r + final_h, c : c + min_w].any():\n                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})\n                        # Mark the *entire area* of the confirmed maximal rectangle as visited\n                        visited[r : r + final_h, c : c + min_w] = True\n                else:\n                     # If the rectangle starting at (r,c) wasn't maximal, \n                     # only mark the starting cell (r, c) visited. \n                     # This prevents re-evaluating (r,c) as a top-left corner, \n                     # but allows its pixels to be included in the true maximal \n                     # rectangle when its actual top-left corner is processed.\n                     visited[r, c] = True\n            else:\n                 # Mark single cell visited if no rect formed (h=0 or w=0)\n                 visited[r,c] = True\n\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling large monochromatic rectangles with yellow.\n    \"\"\"\n    # Convert input to a NumPy array for easier manipulation\n    np_grid = np.array(input_grid, dtype=int)\n    # Initialize the output grid as a copy of the input\n    output_grid = np_grid.copy()\n\n    # Define the minimum area threshold\n    min_area = 25\n\n    # Find all maximal monochromatic rectangles in the input grid\n    rectangles = find_maximal_monochromatic_rectangles(np_grid)\n\n    # Iterate through the found maximal rectangles\n    for rect in rectangles:\n        # Calculate the area of the rectangle\n        area = rect['h'] * rect['w']\n\n        # Check if the area meets the threshold\n        if area >= min_area:\n            # Get the rectangle's position and dimensions\n            r, c = rect['r'], rect['c']\n            h, w = rect['h'], rect['w']\n            \n            # Fill the corresponding area in the output grid with yellow (color 4)\n            output_grid[r : r + h, c : c + w] = 4\n\n    # Convert the result back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 26780,
    "candidates_token_count": 1641,
    "total_token_count": 28421,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.479877,
  "retries": 1
}