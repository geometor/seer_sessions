{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies all maximal monochromatic rectangles within the input grid.\nA rectangle is monochromatic if all its pixels share the same color.\nA rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) \nwithout either going out of bounds or including a pixel of a different color.\n\nFor each maximal monochromatic rectangle found, its area (height * width) is calculated.\nIf the area is 36 or greater, all pixels within the bounds of that rectangle in the output grid \nare replaced with the color yellow (4). \nIf the area is less than 36, the pixels within that rectangle remain unchanged from the input grid.\nAll pixels outside of any maximal monochromatic rectangle also remain unchanged.\n\"\"\"\n\ndef find_maximal_monochromatic_rectangles(grid):\n    \"\"\"\n    Finds all maximal monochromatic rectangles in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a maximal monochromatic rectangle\n              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.\n    \"\"\"\n    rows, cols = grid.shape\n    # Keep track of visited cells to avoid redundant checks and overlapping rectangles\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    # Iterate through each cell as a potential top-left corner of a rectangle\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if this cell has already been included in a found rectangle\n            if visited[r, c]:\n                continue\n\n            color = grid[r, c]\n\n            # Find the initial maximum width starting from (r, c) in the current row\n            initial_w = 0\n            # Check rightwards from the current column 'c'\n            for k in range(c, cols):\n                # Only extend width if the cell has the same color and hasn't been visited\n                # Note: Checking 'visited' here might prevent finding *maximal* rects\n                # if part of it was 'visited' by a suboptimal rect found earlier.\n                # A better approach might be to find all possible rectangles first,\n                # then filter for maximality. However, this approach attempts to find\n                # maximal ones directly by expanding from unvisited cells.\n                if grid[r, k] == color:\n                    initial_w += 1\n                else:\n                    # Stop extending width at the first color mismatch\n                    break\n            \n            # This check was added previously but seems redundant if the outer loop iterates correctly\n            # if initial_w == 0:\n            #     visited[r,c] = True \n            #     continue\n\n            # Determine the maximum possible height for this rectangle\n            # The width might shrink as we check lower rows\n            final_h = 0\n            min_w = initial_w # Start with the width found for the first row\n            \n            # Iterate downwards from the starting row\n            for i in range(r, rows):\n                current_row_w = 0\n                # Check cells in the current row up to the current minimum width (min_w)\n                for j in range(c, c + min_w):\n                    # Stop if the cell is out of bounds, or has the wrong color\n                    # Crucially, don't stop based on 'visited' here, as we need to check the full\n                    # potential extent of the rectangle, even if parts overlap previous checks.\n                    if j >= cols or grid[i, j] != color:\n                        # The rectangle cannot extend this wide in this row.\n                        # Update min_w to the width that *did* match in this row.\n                        min_w = j - c \n                        break # Stop checking this row further\n                    current_row_w +=1\n                \n                # If the width shrank to zero, or the loop finished because width became 0, stop extending height\n                if min_w == 0:\n                    break\n                \n                # If we successfully checked min_w columns in this row (current_row_w == min_w)\n                if current_row_w == min_w:\n                     final_h += 1 # Increment the height of the rectangle\n                else:\n                    # If the row check didn't complete fully up to min_w, stop extending height\n                     break\n\n\n            # We have found a potential maximal rectangle anchored at (r, c)\n            # with dimensions (final_h, min_w).\n            # Mark only the cells within *this specific* found rectangle as visited.\n            if final_h > 0 and min_w > 0:\n                is_maximal = True\n                # Check for horizontal maximality (can it extend left/right?)\n                # Check left boundary\n                if c > 0:\n                    for row_idx in range(r, r + final_h):\n                       if grid[row_idx, c - 1] == color:\n                           is_maximal = False\n                           break\n                # Check right boundary\n                if is_maximal and c + min_w < cols:\n                    for row_idx in range(r, r + final_h):\n                        if grid[row_idx, c + min_w] == color:\n                            is_maximal = False\n                            break\n                \n                # Check for vertical maximality (can it extend up/down?)\n                # Check top boundary\n                if is_maximal and r > 0:\n                     for col_idx in range(c, c + min_w):\n                        if grid[r - 1, col_idx] == color:\n                            is_maximal = False\n                            break\n                # Check bottom boundary\n                if is_maximal and r + final_h < rows:\n                    for col_idx in range(c, c + min_w):\n                        if grid[r + final_h, col_idx] == color:\n                             is_maximal = False\n                             break\n\n                # Store the rectangle only if it's maximal\n                if is_maximal:\n                    # Only mark as visited *after* confirming maximality to allow overlap checks\n                    visited[r : r + final_h, c : c + min_w] = True\n                    rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})\n                else:\n                    # If not maximal, still mark the starting cell visited to avoid re-processing it\n                    # as the top-left of the same non-maximal shape. This might need refinement.\n                     visited[r,c] = True\n\n\n            # Ensure the starting point is marked visited even if no rectangle forms from it\n            # or if it wasn't part of a maximal rectangle starting there.\n            if not visited[r,c]:\n                 visited[r,c] = True\n\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling large monochromatic rectangles with yellow.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to a NumPy array for efficient array operations and slicing\n    np_grid = np.array(input_grid, dtype=int)\n    # Create a copy of the input grid to modify, this will be the output\n    output_grid = np_grid.copy()\n\n    # --- Refined Area Threshold ---\n    # Define the minimum area threshold based on re-evaluation of examples\n    min_area = 36 \n\n    # --- Find Rectangles ---\n    # Find all maximal monochromatic rectangles in the input grid\n    # Using a potentially refined finder function\n    rectangles = find_maximal_monochromatic_rectangles(np_grid)\n\n    # --- Apply Transformation ---\n    # Process each found maximal rectangle\n    for rect in rectangles:\n        # Calculate the area of the current rectangle\n        area = rect['h'] * rect['w']\n\n        # Check if the area meets the minimum requirement\n        if area >= min_area:\n            # Get the position (top-left corner) and dimensions\n            r, c = rect['r'], rect['c']\n            h, w = rect['h'], rect['w']\n            \n            # Fill the area defined by the rectangle in the output grid with yellow (color 4)\n            # NumPy slicing allows efficient modification of the rectangular region\n            output_grid[r : r + h, c : c + w] = 4\n\n    # Convert the final NumPy array back to a list of lists format for the output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23396,
    "candidates_token_count": 1964,
    "total_token_count": 25360,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.181004,
  "retries": 1
}