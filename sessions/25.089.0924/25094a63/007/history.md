
## train_1

**input:**
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 6 6 6 6 6 6 6 6 6 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 6 6 6 6 6 6 6 6 6 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 6 6 6 6 6 6 6 6 6 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 6 6 6 6 6 6 6 6 6 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 6 6 6 6 6 6 6 6 6 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 8 8 8 8 8 8 8 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 8 8 8 8 8 8 8 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 8 8 8 8 8 8 8 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 8 8 8 8 8 8 8 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 8 8 8 8 8 8 8 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 8 8 8 8 8 8 8 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```


**output:**
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 4 4 4 4 4 4 4 4 4 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 4 4 4 4 4 4 4 4 4 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 4 4 4 4 4 4 4 4 4 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 4 4 4 4 4 4 4 4 4 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 4 4 4 4 4 4 4 4 4 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 4 4 4 4 4 4 4 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 4 4 4 4 4 4 4 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 4 4 4 4 4 4 4 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 4 4 4 4 4 4 4 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 4 4 4 4 4 4 4 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 4 4 4 4 4 4 4 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```


## train_2

**input:**
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 8 8 8 8 8 8 1 3 2 3 3 6 6 2 3 6 2 2 2 2 2 2 2 3 2 3
1 2 8 1 8 8 8 8 8 8 3 8 1 2 1 1 2 3 8 3 2 2 2 2 2 2 2 2 1 3
1 3 8 1 8 8 8 8 8 8 3 2 3 3 8 3 1 1 3 3 2 2 2 2 2 2 2 6 8 3
3 3 8 2 8 8 8 8 8 8 3 3 1 3 2 3 6 1 1 2 2 2 2 2 2 2 2 3 6 2
8 2 1 1 8 8 8 8 8 8 3 3 6 1 3 1 8 1 2 1 2 2 2 2 2 2 2 2 3 8
1 3 3 6 8 8 8 8 8 8 8 1 2 8 2 8 2 1 3 3 2 2 2 2 2 2 2 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 3 3 3 3 3 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 3 3 3 3 3 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 3 3 3 3 3 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 3 3 3 3 3 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 3 3 3 3 3 8 3 3
6 2 3 8 6 2 2 1 8 8 1 1 1 1 1 1 1 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 1 1 1 1 1 1 1 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 1 1 1 1 1 1 1 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 1 1 1 1 1 1 1 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 1 1 1 1 1 1 1 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 1 1 1 1 1 1 1 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```


**output:**
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 4 4 4 4 4 4 1 3 2 3 3 6 6 2 3 6 4 4 4 4 4 4 4 3 2 3
1 2 8 1 4 4 4 4 4 4 3 8 1 2 1 1 2 3 8 3 4 4 4 4 4 4 4 2 1 3
1 3 8 1 4 4 4 4 4 4 3 2 3 3 8 3 1 1 3 3 4 4 4 4 4 4 4 6 8 3
3 3 8 2 4 4 4 4 4 4 3 3 1 3 2 3 6 1 1 2 4 4 4 4 4 4 4 3 6 2
8 2 1 1 4 4 4 4 4 4 3 3 6 1 3 1 8 1 2 1 4 4 4 4 4 4 4 2 3 8
1 3 3 6 4 4 4 4 4 4 8 1 2 8 2 8 2 1 3 3 4 4 4 4 4 4 4 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 4 4 4 4 4 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 4 4 4 4 4 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 4 4 4 4 4 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 4 4 4 4 4 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 4 4 4 4 4 8 3 3
6 2 3 8 6 2 2 1 8 8 4 4 4 4 4 4 4 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 4 4 4 4 4 4 4 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 4 4 4 4 4 4 4 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 4 4 4 4 4 4 4 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 4 4 4 4 4 4 4 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 4 4 4 4 4 4 4 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```

Okay, let's break down this task.

**Perception of Elements:**

The task involves transforming an input grid into an output grid of the same dimensions. By visually comparing the input and output grids in the examples, I observe the following:

1.  **Grid Size:** The grid dimensions remain constant (30x30 in these examples).
2.  **Background:** Most pixels in the grid remain unchanged between input and output.
3.  **Transformation:** Specific rectangular areas within the input grid are completely filled with yellow pixels (color 4) in the output grid.
4.  **Target Rectangles:** The rectangles that are filled appear to be composed of a single, uniform color in the input grid (monochromatic).
5.  **Multiple Rectangles:** In both examples, more than one such monochromatic rectangle is transformed. In `train_1`, a gray (6) rectangle and an azure (8) rectangle are filled. In `train_2`, three black (8) rectangles and one blue (1) rectangle are filled.
6.  **Size Matters:** Not all monochromatic rectangles are filled. The ones that are filled seem relatively large. Comparing the sizes (area = width * height):
    *   `train_1`: Gray (5x10 = 50 pixels), Azure (7x8 = 56 pixels).
    *   `train_2`: Black (6x6 = 36 pixels), Black (8x8 = 64 pixels), Black (7x7 = 49 pixels), Blue (7x8 = 56 pixels).
7.  **Threshold:** The smallest rectangle filled in either example has an area of 36 (the 6x6 black rectangle in `train_2`). It seems plausible that there's a minimum area threshold for a monochromatic rectangle to be filled. Let's hypothesize the threshold is 36. All filled rectangles in both examples (50, 56, 36, 64, 49, 56) meet or exceed this threshold. We need to assume that any monochromatic rectangles with area >= 36 *not* shown as filled were either not present or not *maximal* (i.e., they were part of a larger non-rectangular monochromatic shape). The rule likely applies to *maximal* monochromatic rectangles (those that cannot be extended further in any direction while remaining monochromatic).

**YAML Facts:**


```yaml
GridProperties:
  - Input and output grids have the same dimensions.
  - Most pixels remain unchanged.

Objects:
  - Type: Maximal Monochromatic Rectangles
  - Definition: Rectangular areas composed of a single color that cannot be extended horizontally or vertically without changing color or going out of bounds.
  - Properties:
      - Color (original color in the input)
      - Position (top-left corner coordinates)
      - Size (width, height)
      - Area (width * height)

Action:
  - Name: FillRectangle
  - Target: Maximal monochromatic rectangles meeting a specific criterion.
  - Criterion: Area >= 36.
  - Effect: All pixels within the target rectangle's boundaries are changed to yellow (color 4).

Relationships:
  - The transformation identifies specific objects (maximal monochromatic rectangles) based on a property (area >= 36) and applies a uniform action (fill with yellow) to them.
  - The final output is the input grid modified by these fill actions.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Scan the input grid to identify all *maximal monochromatic rectangles*. A rectangle is monochromatic if all its pixels have the same color. It is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) and remain a monochromatic rectangle within the grid's bounds.
3.  For each maximal monochromatic rectangle found:
    a.  Calculate its area (Area = width * height).
    b.  Check if the Area is greater than or equal to 36.
4.  For every maximal monochromatic rectangle that meets the area condition (Area >= 36):
    a.  Iterate through all pixel coordinates (row, column) within the boundaries of that rectangle.
    b.  Set the color of the corresponding pixel in the output grid to yellow (color 4).
5.  Return the modified output grid.
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid.
A rectangle is monochromatic if all its pixels share the same color.
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated.
If the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 25, the pixels within that rectangle remain unchanged from the input grid.
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # Keep track of visited cells to avoid redundant checks and overlapping rectangles
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a found rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]

            # Find the initial maximum width starting from (r, c) in the current row
            initial_w = 0
            for k in range(c, cols):
                # Only extend width if the cell has the same color and hasn't been visited
                if not visited[r, k] and grid[r, k] == color:
                    initial_w += 1
                else:
                    # Stop extending width at the first mismatch or visited cell
                    break
            
            # If no width found (e.g., starting cell was already visited), mark and skip
            if initial_w == 0:
                visited[r,c] = True # Ensure the starting cell is marked visited
                continue

            # Determine the maximum possible height for this rectangle
            # The width might shrink as we check lower rows
            final_h = 0
            min_w = initial_w # Start with the width found for the first row
            
            # Iterate downwards from the starting row
            for i in range(r, rows):
                current_row_w = 0
                # Check cells in the current row up to the current minimum width (min_w)
                for j in range(c, c + min_w):
                    # Stop if the cell is out of bounds, visited, or has the wrong color
                    if j >= cols or visited[i, j] or grid[i, j] != color:
                        # The rectangle cannot extend this wide in this row.
                        # Update min_w to the width that *did* match in this row.
                        min_w = j - c 
                        break # Stop checking this row further
                    current_row_w +=1
                
                # If the width shrank to zero, or the loop finished because width became 0, stop extending height
                if min_w == 0:
                    break
                
                # If we successfully checked min_w columns in this row (current_row_w == min_w)
                if current_row_w == min_w:
                     final_h += 1 # Increment the height of the rectangle
                else:
                    # This should technically be caught by min_w becoming 0, but as a safeguard:
                    # If the row check didn't complete fully up to min_w, stop extending height
                     break


            # We have found a maximal rectangle anchored at (r, c)
            # with dimensions (final_h, min_w)
            if final_h > 0 and min_w > 0:
                # Mark all cells within the identified rectangle as visited
                visited[r : r + final_h, c : c + min_w] = True
                # Store the details of the found rectangle
                rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
            elif not visited[r,c]:
                 # If for some reason no rectangle was formed (e.g. h=0 or w=0)
                 # ensure the starting cell is marked as visited.
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The transformed grid.
    """
    # Convert input to a NumPy array for efficient array operations and slicing
    np_grid = np.array(input_grid, dtype=int)
    # Create a copy of the input grid to modify, this will be the output
    output_grid = np_grid.copy()

    # Define the minimum area threshold for a rectangle to be filled
    min_area = 25

    # Find all maximal monochromatic rectangles in the input grid
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # Process each found rectangle
    for rect in rectangles:
        # Calculate the area of the current rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the minimum requirement
        if area >= min_area:
            # Get the position (top-left corner) and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the area defined by the rectangle in the output grid with yellow (color 4)
            # NumPy slicing allows efficient modification of the rectangular region
            output_grid[r : r + h, c : c + w] = 4

    # Convert the final NumPy array back to a list of lists format for the output
    return output_grid.tolist()
```
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid.
A rectangle is monochromatic if all its pixels share the same color.
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated.
If the area is 36 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 36, the pixels within that rectangle remain unchanged from the input grid.
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # Keep track of visited cells to avoid redundant checks and overlapping rectangles
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a found rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]

            # Find the initial maximum width starting from (r, c) in the current row
            initial_w = 0
            # Check rightwards from the current column 'c'
            for k in range(c, cols):
                # Only extend width if the cell has the same color and hasn't been visited
                # Note: Checking 'visited' here might prevent finding *maximal* rects
                # if part of it was 'visited' by a suboptimal rect found earlier.
                # A better approach might be to find all possible rectangles first,
                # then filter for maximality. However, this approach attempts to find
                # maximal ones directly by expanding from unvisited cells.
                if grid[r, k] == color:
                    initial_w += 1
                else:
                    # Stop extending width at the first color mismatch
                    break
            
            # This check was added previously but seems redundant if the outer loop iterates correctly
            # if initial_w == 0:
            #     visited[r,c] = True 
            #     continue

            # Determine the maximum possible height for this rectangle
            # The width might shrink as we check lower rows
            final_h = 0
            min_w = initial_w # Start with the width found for the first row
            
            # Iterate downwards from the starting row
            for i in range(r, rows):
                current_row_w = 0
                # Check cells in the current row up to the current minimum width (min_w)
                for j in range(c, c + min_w):
                    # Stop if the cell is out of bounds, or has the wrong color
                    # Crucially, don't stop based on 'visited' here, as we need to check the full
                    # potential extent of the rectangle, even if parts overlap previous checks.
                    if j >= cols or grid[i, j] != color:
                        # The rectangle cannot extend this wide in this row.
                        # Update min_w to the width that *did* match in this row.
                        min_w = j - c 
                        break # Stop checking this row further
                    current_row_w +=1
                
                # If the width shrank to zero, or the loop finished because width became 0, stop extending height
                if min_w == 0:
                    break
                
                # If we successfully checked min_w columns in this row (current_row_w == min_w)
                if current_row_w == min_w:
                     final_h += 1 # Increment the height of the rectangle
                else:
                    # If the row check didn't complete fully up to min_w, stop extending height
                     break


            # We have found a potential maximal rectangle anchored at (r, c)
            # with dimensions (final_h, min_w).
            # Mark only the cells within *this specific* found rectangle as visited.
            if final_h > 0 and min_w > 0:
                is_maximal = True
                # Check for horizontal maximality (can it extend left/right?)
                # Check left boundary
                if c > 0:
                    for row_idx in range(r, r + final_h):
                       if grid[row_idx, c - 1] == color:
                           is_maximal = False
                           break
                # Check right boundary
                if is_maximal and c + min_w < cols:
                    for row_idx in range(r, r + final_h):
                        if grid[row_idx, c + min_w] == color:
                            is_maximal = False
                            break
                
                # Check for vertical maximality (can it extend up/down?)
                # Check top boundary
                if is_maximal and r > 0:
                     for col_idx in range(c, c + min_w):
                        if grid[r - 1, col_idx] == color:
                            is_maximal = False
                            break
                # Check bottom boundary
                if is_maximal and r + final_h < rows:
                    for col_idx in range(c, c + min_w):
                        if grid[r + final_h, col_idx] == color:
                             is_maximal = False
                             break

                # Store the rectangle only if it's maximal
                if is_maximal:
                    # Only mark as visited *after* confirming maximality to allow overlap checks
                    visited[r : r + final_h, c : c + min_w] = True
                    rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
                else:
                    # If not maximal, still mark the starting cell visited to avoid re-processing it
                    # as the top-left of the same non-maximal shape. This might need refinement.
                     visited[r,c] = True


            # Ensure the starting point is marked visited even if no rectangle forms from it
            # or if it wasn't part of a maximal rectangle starting there.
            if not visited[r,c]:
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The transformed grid.
    """
    # Convert input to a NumPy array for efficient array operations and slicing
    np_grid = np.array(input_grid, dtype=int)
    # Create a copy of the input grid to modify, this will be the output
    output_grid = np_grid.copy()

    # --- Refined Area Threshold ---
    # Define the minimum area threshold based on re-evaluation of examples
    min_area = 36 

    # --- Find Rectangles ---
    # Find all maximal monochromatic rectangles in the input grid
    # Using a potentially refined finder function
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # --- Apply Transformation ---
    # Process each found maximal rectangle
    for rect in rectangles:
        # Calculate the area of the current rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the minimum requirement
        if area >= min_area:
            # Get the position (top-left corner) and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the area defined by the rectangle in the output grid with yellow (color 4)
            # NumPy slicing allows efficient modification of the rectangular region
            output_grid[r : r + h, c : c + w] = 4

    # Convert the final NumPy array back to a list of lists format for the output
    return output_grid.tolist()
```
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid. 
A rectangle is monochromatic if all its pixels share the same color. 
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated. 
If the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 25, the pixels within that rectangle remain unchanged from the input grid. 
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # visited helps track cells that are already part of a confirmed maximal rectangle
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a confirmed maximal rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]
            
            # --- Find potential rectangle dimensions starting at (r, c) ---
            # 1. Find initial width in the starting row 'r'
            current_w = 0
            for k in range(c, cols):
                if grid[r, k] == color:
                    current_w += 1
                else:
                    break # Stop at first color change or boundary
            
            if current_w == 0: # Should not happen if loop starts correctly, but safeguard
                 visited[r,c] = True # Mark this single cell visited if it leads nowhere
                 continue

            # 2. Find height, adjusting width if necessary
            final_h = 0
            min_w = current_w # Start with width from the first row
            for i in range(r, rows):
                row_w = 0
                possible = True
                for j in range(c, c + min_w):
                     # Check boundary and color match for the current potential width (min_w)
                    if j >= cols or grid[i, j] != color:
                        min_w = j - c # Reduce width to the matched part
                        possible = False
                        break # Stop checking this row
                    row_w += 1
                
                if not possible or min_w == 0: # If row didn't match full min_w or width became 0
                    break # Stop extending height

                # If the row matched the current min_w, increment height
                final_h += 1

            # Found a potential rectangle: (r, c) with dimensions (final_h, min_w)
            if final_h > 0 and min_w > 0:
                # --- Check for Maximality ---
                is_maximal = True
                
                # Check Up: Can it extend upwards?
                if r > 0:
                    for k in range(c, c + min_w):
                        if grid[r - 1, k] == color:
                            is_maximal = False
                            break
                
                # Check Down: Can it extend downwards?
                if is_maximal and r + final_h < rows:
                    for k in range(c, c + min_w):
                        if grid[r + final_h, k] == color:
                            is_maximal = False
                            break
                            
                # Check Left: Can it extend leftwards?
                if is_maximal and c > 0:
                    for i in range(r, r + final_h):
                        if grid[i, c - 1] == color:
                            is_maximal = False
                            break
                            
                # Check Right: Can it extend rightwards?
                if is_maximal and c + min_w < cols:
                     for i in range(r, r + final_h):
                        if grid[i, c + min_w] == color:
                            is_maximal = False
                            break

                # --- Store if Maximal and Mark Visited ---
                if is_maximal:
                    # Check if any part of this maximal rectangle has already been visited
                    # This prevents adding duplicates if the algorithm somehow restarts
                    # within an already found maximal region.
                    if not visited[r : r + final_h, c : c + min_w].any():
                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
                        # Mark the *entire area* of the confirmed maximal rectangle as visited
                        visited[r : r + final_h, c : c + min_w] = True
                else:
                     # If the rectangle starting at (r,c) wasn't maximal, 
                     # only mark the starting cell (r, c) visited. 
                     # This prevents re-evaluating (r,c) as a top-left corner, 
                     # but allows its pixels to be included in the true maximal 
                     # rectangle when its actual top-left corner is processed.
                     visited[r, c] = True
            else:
                 # Mark single cell visited if no rect formed (h=0 or w=0)
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.
    """
    # Convert input to a NumPy array for easier manipulation
    np_grid = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input
    output_grid = np_grid.copy()

    # Define the minimum area threshold
    min_area = 25

    # Find all maximal monochromatic rectangles in the input grid
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # Iterate through the found maximal rectangles
    for rect in rectangles:
        # Calculate the area of the rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the threshold
        if area >= min_area:
            # Get the rectangle's position and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the corresponding area in the output grid with yellow (color 4)
            output_grid[r : r + h, c : c + w] = 4

    # Convert the result back to a list of lists format
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid. 
A rectangle is monochromatic if all its pixels share the same color. 
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated. 
If the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 25, the pixels within that rectangle remain unchanged from the input grid. 
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # visited helps track cells that are already part of a confirmed maximal rectangle
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a confirmed maximal rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]
            
            # --- Find potential rectangle dimensions starting at (r, c) ---
            # 1. Find initial width in the starting row 'r'
            current_w = 0
            for k in range(c, cols):
                if grid[r, k] == color:
                    current_w += 1
                else:
                    break # Stop at first color change or boundary
            
            if current_w == 0: # Should not happen if loop starts correctly, but safeguard
                 visited[r,c] = True # Mark this single cell visited if it leads nowhere
                 continue

            # 2. Find height, adjusting width if necessary
            final_h = 0
            min_w = current_w # Start with width from the first row
            for i in range(r, rows):
                row_w = 0
                possible = True
                for j in range(c, c + min_w):
                     # Check boundary and color match for the current potential width (min_w)
                    if j >= cols or grid[i, j] != color:
                        min_w = j - c # Reduce width to the matched part
                        possible = False
                        break # Stop checking this row
                    row_w += 1
                
                if not possible or min_w == 0: # If row didn't match full min_w or width became 0
                    break # Stop extending height

                # If the row matched the current min_w, increment height
                final_h += 1

            # Found a potential rectangle: (r, c) with dimensions (final_h, min_w)
            if final_h > 0 and min_w > 0:
                # --- Check for Maximality ---
                is_maximal = True
                
                # Check Up: Can it extend upwards?
                if r > 0:
                    for k in range(c, c + min_w):
                        if grid[r - 1, k] == color:
                            is_maximal = False
                            break
                
                # Check Down: Can it extend downwards?
                if is_maximal and r + final_h < rows:
                    for k in range(c, c + min_w):
                        if grid[r + final_h, k] == color:
                            is_maximal = False
                            break
                            
                # Check Left: Can it extend leftwards?
                if is_maximal and c > 0:
                    for i in range(r, r + final_h):
                        if grid[i, c - 1] == color:
                            is_maximal = False
                            break
                            
                # Check Right: Can it extend rightwards?
                if is_maximal and c + min_w < cols:
                     for i in range(r, r + final_h):
                        if grid[i, c + min_w] == color:
                            is_maximal = False
                            break

                # --- Store if Maximal and Mark Visited ---
                if is_maximal:
                    # Check if any part of this maximal rectangle has already been visited
                    # This prevents adding duplicates if the algorithm somehow restarts
                    # within an already found maximal region.
                    if not visited[r : r + final_h, c : c + min_w].any():
                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
                        # Mark the *entire area* of the confirmed maximal rectangle as visited
                        visited[r : r + final_h, c : c + min_w] = True
                else:
                     # If the rectangle starting at (r,c) wasn't maximal, 
                     # only mark the starting cell (r, c) visited. 
                     # This prevents re-evaluating (r,c) as a top-left corner, 
                     # but allows its pixels to be included in the true maximal 
                     # rectangle when its actual top-left corner is processed.
                     visited[r, c] = True
            else:
                 # Mark single cell visited if no rect formed (h=0 or w=0)
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.
    """
    # Convert input to a NumPy array for easier manipulation
    np_grid = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input
    output_grid = np_grid.copy()

    # Define the minimum area threshold
    min_area = 25

    # Find all maximal monochromatic rectangles in the input grid
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # Iterate through the found maximal rectangles
    for rect in rectangles:
        # Calculate the area of the rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the threshold
        if area >= min_area:
            # Get the rectangle's position and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the corresponding area in the output grid with yellow (color 4)
            output_grid[r : r + h, c : c + w] = 4

    # Convert the result back to a list of lists format
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 6 6 6 6 6 6 6 6 6 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 6 6 6 6 6 6 6 6 6 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 6 6 6 6 6 6 6 6 6 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 6 6 6 6 6 6 6 6 6 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 6 6 6 6 6 6 6 6 6 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 8 8 8 8 8 8 8 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 8 8 8 8 8 8 8 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 8 8 8 8 8 8 8 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 8 8 8 8 8 8 8 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 8 8 8 8 8 8 8 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 8 8 8 8 8 8 8 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```
Expected Output:
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 4 4 4 4 4 4 4 4 4 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 4 4 4 4 4 4 4 4 4 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 4 4 4 4 4 4 4 4 4 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 4 4 4 4 4 4 4 4 4 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 4 4 4 4 4 4 4 4 4 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 4 4 4 4 4 4 4 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 4 4 4 4 4 4 4 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 4 4 4 4 4 4 4 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 4 4 4 4 4 4 4 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 4 4 4 4 4 4 4 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 4 4 4 4 4 4 4 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```
Transformed Output:
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 6 6 6 6 6 6 6 6 6 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 6 6 6 6 6 6 6 6 6 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 6 6 6 6 6 6 6 6 6 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 6 6 6 6 6 6 6 6 6 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 6 6 6 6 6 6 6 6 6 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 8 8 8 8 8 8 8 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 8 8 8 8 8 8 8 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 8 8 8 8 8 8 8 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 8 8 8 8 8 8 8 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 8 8 8 8 8 8 8 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 8 8 8 8 8 8 8 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```
Match: False
Pixels Off: 87
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 19.333333333333343

## Example 2:
Input:
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 8 8 8 8 8 8 1 3 2 3 3 6 6 2 3 6 2 2 2 2 2 2 2 3 2 3
1 2 8 1 8 8 8 8 8 8 3 8 1 2 1 1 2 3 8 3 2 2 2 2 2 2 2 2 1 3
1 3 8 1 8 8 8 8 8 8 3 2 3 3 8 3 1 1 3 3 2 2 2 2 2 2 2 6 8 3
3 3 8 2 8 8 8 8 8 8 3 3 1 3 2 3 6 1 1 2 2 2 2 2 2 2 2 3 6 2
8 2 1 1 8 8 8 8 8 8 3 3 6 1 3 1 8 1 2 1 2 2 2 2 2 2 2 2 3 8
1 3 3 6 8 8 8 8 8 8 8 1 2 8 2 8 2 1 3 3 2 2 2 2 2 2 2 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 3 3 3 3 3 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 3 3 3 3 3 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 3 3 3 3 3 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 3 3 3 3 3 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 3 3 3 3 3 8 3 3
6 2 3 8 6 2 2 1 8 8 1 1 1 1 1 1 1 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 1 1 1 1 1 1 1 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 1 1 1 1 1 1 1 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 1 1 1 1 1 1 1 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 1 1 1 1 1 1 1 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 1 1 1 1 1 1 1 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```
Expected Output:
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 4 4 4 4 4 4 1 3 2 3 3 6 6 2 3 6 4 4 4 4 4 4 4 3 2 3
1 2 8 1 4 4 4 4 4 4 3 8 1 2 1 1 2 3 8 3 4 4 4 4 4 4 4 2 1 3
1 3 8 1 4 4 4 4 4 4 3 2 3 3 8 3 1 1 3 3 4 4 4 4 4 4 4 6 8 3
3 3 8 2 4 4 4 4 4 4 3 3 1 3 2 3 6 1 1 2 4 4 4 4 4 4 4 3 6 2
8 2 1 1 4 4 4 4 4 4 3 3 6 1 3 1 8 1 2 1 4 4 4 4 4 4 4 2 3 8
1 3 3 6 4 4 4 4 4 4 8 1 2 8 2 8 2 1 3 3 4 4 4 4 4 4 4 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 4 4 4 4 4 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 4 4 4 4 4 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 4 4 4 4 4 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 4 4 4 4 4 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 4 4 4 4 4 8 3 3
6 2 3 8 6 2 2 1 8 8 4 4 4 4 4 4 4 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 4 4 4 4 4 4 4 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 4 4 4 4 4 4 4 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 4 4 4 4 4 4 4 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 4 4 4 4 4 4 4 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 4 4 4 4 4 4 4 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```
Transformed Output:
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 8 8 8 8 8 8 1 3 2 3 3 6 6 2 3 6 2 2 2 2 2 2 2 3 2 3
1 2 8 1 8 8 8 8 8 8 3 8 1 2 1 1 2 3 8 3 2 2 2 2 2 2 2 2 1 3
1 3 8 1 8 8 8 8 8 8 3 2 3 3 8 3 1 1 3 3 2 2 2 2 2 2 2 6 8 3
3 3 8 2 8 8 8 8 8 8 3 3 1 3 2 3 6 1 1 2 2 2 2 2 2 2 2 3 6 2
8 2 1 1 8 8 8 8 8 8 3 3 6 1 3 1 8 1 2 1 2 2 2 2 2 2 2 2 3 8
1 3 3 6 8 8 8 8 8 8 8 1 2 8 2 8 2 1 3 3 2 2 2 2 2 2 2 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 3 3 3 3 3 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 3 3 3 3 3 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 3 3 3 3 3 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 3 3 3 3 3 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 3 3 3 3 3 8 3 3
6 2 3 8 6 2 2 1 8 8 1 1 1 1 1 1 1 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 1 1 1 1 1 1 1 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 1 1 1 1 1 1 1 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 1 1 1 1 1 1 1 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 1 1 1 1 1 1 1 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 1 1 1 1 1 1 1 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```
Match: False
Pixels Off: 145
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 32.22222222222223
**General Assessment:**

The initial analysis correctly identified the core task: finding monochromatic rectangles and filling those above a certain area threshold with yellow. However, the implementation failed significantly, producing outputs with zero filled rectangles for both examples where several should have been filled.

The errors indicate a fundamental problem in either:
1.  **Rectangle Identification:** The `find_maximal_monochromatic_rectangles` function is not correctly identifying the target rectangles. This could be due to flaws in detecting monochromatic areas, calculating their boundaries, ensuring maximality, or handling overlaps/visited cells.
2.  **Area Threshold Application:** While the initial analysis pointed towards a threshold of 36, the tested code used 25. Even with this lower threshold, no rectangles were filled, strongly suggesting the primary issue lies in rectangle identification. However, the threshold hypothesis needs re-validation.

**Strategy for Resolution:**

1.  **Verify Rectangle Finding:** Execute the `find_maximal_monochromatic_rectangles` function separately on the input grids. Log the details (position, size, color, area) of *all* rectangles it finds.
2.  **Compare Found vs. Expected:** Compare the list of found rectangles against the actual rectangles filled in the expected output grids. Determine which expected rectangles were missed and if any incorrect rectangles were found.
3.  **Debug `find_maximal_monochromatic_rectangles`:** Based on the comparison, debug the rectangle finding logic. Pay close attention to the maximality checks and the use of the `visited` array, as these are common sources of errors in such algorithms. Ensure the algorithm correctly handles cases where rectangles might share edges or corners.
4.  **Reconfirm Area Threshold:** Once the rectangle finding is reliable, re-evaluate the minimum area threshold by examining the areas of the correctly identified rectangles that *are* filled yellow in the training outputs versus those that are *not*. The smallest area filled in the examples seems to be 36 (6x6 rectangle in train_2).
5.  **Update Logic:** Refine the YAML facts and natural language program based on the corrected understanding of rectangle identification and the confirmed area threshold.

**Metrics Gathering:**

Let's execute code to find the rectangles identified by the *provided failing code* and check their areas against the threshold originally hypothesized (36) and the one used in the code (25).



*code_execution:*
```python
import numpy as np

# --- Function from the provided failing code ---
def find_maximal_monochromatic_rectangles(grid):
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []
    for r in range(rows):
        for c in range(cols):
            if visited[r, c]:
                continue
            color = grid[r, c]
            current_w = 0
            for k in range(c, cols):
                if grid[r, k] == color:
                    current_w += 1
                else:
                    break
            if current_w == 0:
                 visited[r,c] = True
                 continue
            final_h = 0
            min_w = current_w
            for i in range(r, rows):
                row_w = 0
                possible = True
                for j in range(c, c + min_w):
                    if j >= cols or grid[i, j] != color:
                        min_w = j - c
                        possible = False
                        break
                    row_w += 1
                if not possible or min_w == 0:
                    break
                final_h += 1
            if final_h > 0 and min_w > 0:
                is_maximal = True
                if r > 0:
                    for k in range(c, c + min_w):
                        if grid[r - 1, k] == color:
                            is_maximal = False; break
                if is_maximal and r + final_h < rows:
                    for k in range(c, c + min_w):
                        if grid[r + final_h, k] == color:
                            is_maximal = False; break
                if is_maximal and c > 0:
                    for i in range(r, r + final_h):
                        if grid[i, c - 1] == color:
                            is_maximal = False; break
                if is_maximal and c + min_w < cols:
                     for i in range(r, r + final_h):
                        if grid[i, c + min_w] == color:
                            is_maximal = False; break
                if is_maximal:
                    if not visited[r : r + final_h, c : c + min_w].any():
                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color, 'area': final_h * min_w})
                        visited[r : r + final_h, c : c + min_w] = True
                else:
                     visited[r, c] = True
            else:
                 visited[r,c] = True
    return rectangles

# --- Inputs ---
input_1 = np.array([
    [6,8,6,8,8,8,8,6,6,3,8,6,2,3,8,1,2,8,1,3,8,3,3,6,6,1,2,6,2,2],
    [2,3,3,2,2,3,6,2,6,2,8,1,3,8,1,8,1,8,8,8,8,2,2,3,2,1,2,8,6,3],
    [2,3,8,2,3,6,6,6,6,6,6,6,6,6,3,8,2,6,6,2,8,3,8,8,3,2,3,3,3,2],
    [8,6,8,2,3,6,6,6,6,6,6,6,6,6,3,1,1,2,1,2,6,8,2,6,2,1,8,3,3,8],
    [6,8,6,2,3,6,6,6,6,6,6,6,6,6,3,3,3,8,1,1,2,1,8,3,8,2,3,6,8,2],
    [3,8,3,3,6,6,6,6,6,6,6,6,6,6,2,8,6,3,2,6,1,6,6,2,8,8,3,2,6,6],
    [2,6,3,2,8,6,6,6,6,6,6,6,6,6,8,3,8,3,3,6,3,1,8,8,1,2,3,1,8,8],
    [3,8,1,6,1,8,1,3,8,3,2,3,2,8,1,3,1,2,2,8,1,6,3,3,3,6,2,2,8,6],
    [8,3,3,8,3,8,2,2,8,8,8,8,8,1,1,6,3,3,6,2,2,6,1,3,3,6,3,1,3,3],
    [2,3,3,2,3,2,6,2,3,6,8,3,3,8,3,6,1,3,3,8,8,1,6,6,8,8,1,6,2,6],
    [3,6,3,3,3,2,3,6,1,6,3,8,2,8,2,3,2,6,3,6,6,8,3,6,6,1,6,8,8,6],
    [8,3,3,1,2,2,6,8,2,3,6,8,3,2,2,6,3,2,1,2,6,3,6,8,8,8,1,8,1,6],
    [1,8,8,1,6,6,8,2,8,2,1,2,8,8,1,8,2,8,3,8,3,3,8,8,2,3,3,3,3,3],
    [8,8,3,8,3,2,8,6,3,3,1,3,2,1,6,6,8,3,6,6,3,6,3,1,8,1,2,6,3,8],
    [8,6,6,3,2,6,6,8,6,1,3,2,8,3,1,2,8,3,6,2,8,8,3,2,2,6,1,8,6,3],
    [1,8,1,6,2,3,2,2,1,8,2,2,8,3,6,8,8,8,2,8,8,3,3,1,3,2,2,1,3,2],
    [8,1,3,6,8,8,6,6,3,3,2,2,3,8,8,8,8,8,8,8,1,3,3,8,2,3,6,2,8,2],
    [3,3,3,6,3,2,2,2,6,3,2,3,3,8,8,8,8,8,8,8,8,3,3,2,3,2,2,2,2,3],
    [3,2,1,2,2,8,6,3,8,8,8,3,1,8,8,8,8,8,8,8,6,1,8,3,8,3,6,8,1,8],
    [3,6,1,3,2,3,6,6,6,3,2,1,3,8,8,8,8,8,8,8,3,3,2,1,8,3,6,3,2,3],
    [8,1,3,8,6,2,3,3,3,3,2,8,6,8,8,8,8,8,8,8,2,8,8,3,8,2,3,1,3,2],
    [3,6,3,2,8,6,6,3,8,3,1,2,3,8,8,8,8,8,8,8,3,6,8,6,1,2,1,3,3,6],
    [3,8,8,2,3,8,3,6,8,8,3,1,3,3,8,8,2,2,2,2,3,8,1,1,3,3,2,3,1,3],
    [3,3,6,8,1,6,6,2,8,6,6,1,8,1,2,2,1,6,8,3,2,6,8,6,8,8,6,2,8,3],
    [8,3,3,1,8,3,2,3,3,3,8,3,3,3,3,2,3,8,3,1,3,6,6,6,6,6,3,6,2,3],
    [3,6,8,3,2,1,8,6,6,8,6,6,1,6,6,1,3,3,6,2,6,1,3,3,8,1,2,2,3,3],
    [1,8,3,6,3,2,6,8,8,1,6,6,8,6,6,6,2,6,8,3,8,1,3,8,2,6,3,2,6,6],
    [8,8,6,8,1,1,8,2,2,3,6,2,8,3,8,2,1,1,8,6,8,6,8,6,3,3,3,3,2,3],
    [1,3,8,1,3,1,6,3,6,8,2,3,3,8,2,2,2,1,3,2,8,8,3,8,6,6,3,8,3,8],
    [6,2,6,2,8,2,3,3,3,3,1,3,3,3,2,6,3,8,2,3,6,3,3,2,2,3,8,8,1,3]
])

input_2 = np.array([
    [3,3,2,6,3,6,8,8,8,2,3,3,3,3,3,6,3,3,8,8,1,2,2,6,3,3,2,8,1,1],
    [8,2,1,6,3,1,8,3,1,8,3,8,8,1,3,2,8,3,8,8,3,1,3,1,8,3,2,6,2,6],
    [1,8,3,1,8,8,8,8,8,8,1,3,2,3,3,6,6,2,3,6,2,2,2,2,2,2,2,3,2,3],
    [1,2,8,1,8,8,8,8,8,8,3,8,1,2,1,1,2,3,8,3,2,2,2,2,2,2,2,2,1,3],
    [1,3,8,1,8,8,8,8,8,8,3,2,3,3,8,3,1,1,3,3,2,2,2,2,2,2,2,6,8,3],
    [3,3,8,2,8,8,8,8,8,8,3,3,1,3,2,3,6,1,1,2,2,2,2,2,2,2,2,3,6,2],
    [8,2,1,1,8,8,8,8,8,8,3,3,6,1,3,1,8,1,2,1,2,2,2,2,2,2,2,2,3,8],
    [1,3,3,6,8,8,8,8,8,8,8,1,2,8,2,8,2,1,3,3,2,2,2,2,2,2,2,2,8,6],
    [3,1,3,8,3,2,3,8,1,3,1,8,1,3,1,2,3,1,8,6,2,1,3,1,1,8,3,1,6,3],
    [2,8,6,3,1,3,8,2,1,3,2,3,3,3,3,1,8,3,3,6,2,8,2,2,6,2,1,6,2,3],
    [8,8,2,2,3,1,1,3,2,3,3,8,2,3,3,8,8,6,6,2,1,2,6,2,3,3,3,2,6,3],
    [6,3,2,2,8,3,2,3,3,1,3,2,2,3,2,6,3,2,2,1,1,2,1,8,6,3,2,1,8,2],
    [8,6,2,8,2,2,2,3,3,8,1,1,3,1,6,1,3,2,8,3,8,3,3,3,3,3,3,1,8,1],
    [8,8,2,8,8,6,8,6,3,8,6,1,3,2,8,3,6,6,2,6,3,8,3,3,3,3,3,3,8,1],
    [1,8,2,6,2,8,1,3,6,3,8,2,2,3,6,1,6,2,8,3,8,3,3,3,3,3,3,2,2,3],
    [3,2,8,1,1,3,2,2,2,6,8,3,8,8,1,2,8,6,1,3,1,2,3,3,3,3,3,2,2,2],
    [8,3,8,1,2,3,8,6,3,3,3,1,6,3,1,2,1,3,2,3,2,8,3,3,3,3,3,8,3,3],
    [6,2,3,8,6,2,2,1,8,8,1,1,1,1,1,1,1,6,6,2,1,6,3,1,6,8,3,1,2,3],
    [2,1,2,1,8,2,3,2,6,8,1,1,1,1,1,1,1,1,1,1,3,6,2,1,2,2,2,3,3,1],
    [1,8,8,2,8,2,2,2,3,1,1,1,1,1,1,1,1,8,2,3,2,3,6,6,2,3,3,3,6,3],
    [2,6,8,3,6,1,3,8,3,6,1,1,1,1,1,1,1,2,3,3,3,1,6,3,3,6,1,3,2,2],
    [6,8,6,2,3,2,6,3,3,1,1,1,1,1,1,1,1,3,3,8,1,6,3,3,3,8,1,8,2,3],
    [6,3,1,3,6,6,1,6,3,8,1,1,1,1,1,1,1,1,2,1,6,3,3,8,1,8,3,8,2,1],
    [3,2,2,3,1,1,2,3,8,6,1,3,3,1,8,3,1,8,8,3,8,3,1,8,8,1,1,2,1,8],
    [3,2,3,6,1,8,3,6,3,3,2,2,1,3,6,3,2,3,8,3,8,3,2,2,2,2,3,3,1,6],
    [2,8,6,2,2,1,8,3,1,6,8,2,3,2,3,2,3,3,3,3,2,2,2,8,6,8,3,6,1,3],
    [6,2,3,2,3,3,8,3,3,6,2,2,3,3,8,8,1,3,1,2,8,3,8,3,3,3,6,1,2,2],
    [2,3,2,1,2,6,3,1,8,3,1,6,2,3,8,2,6,1,1,1,3,6,8,1,2,8,6,2,3,2],
    [2,1,8,2,6,3,8,2,3,6,8,8,2,8,8,3,2,3,1,6,8,2,6,3,2,3,2,1,8,3],
    [1,6,3,1,6,6,3,1,2,8,8,1,8,1,3,3,1,2,6,8,3,1,6,8,3,8,3,1,1,8]
])

# --- Analysis ---
min_area_used = 25
min_area_hypothesized = 36

print("--- Analysis of Input 1 ---")
rects_1 = find_maximal_monochromatic_rectangles(input_1)
print(f"Found {len(rects_1)} 'maximal' rectangles.")
rects_1_over_25 = [r for r in rects_1 if r['area'] >= min_area_used]
rects_1_over_36 = [r for r in rects_1 if r['area'] >= min_area_hypothesized]
print(f"Rectangles with area >= {min_area_used}: {len(rects_1_over_25)}")
# for r in rects_1_over_25: print(r)
print(f"Rectangles with area >= {min_area_hypothesized}: {len(rects_1_over_36)}")
# for r in rects_1_over_36: print(r)

# Expected Rectangles in Input 1 (Manually identified from problem description)
expected_rects_1 = [
    {'r': 2, 'c': 5, 'h': 5, 'w': 10, 'color': 6, 'area': 50},
    {'r': 16, 'c': 13, 'h': 7, 'w': 8, 'color': 8, 'area': 56}
]
print("\nExpected Rectangles >= 36:")
for r in expected_rects_1: print(r)


print("\n--- Analysis of Input 2 ---")
rects_2 = find_maximal_monochromatic_rectangles(input_2)
print(f"Found {len(rects_2)} 'maximal' rectangles.")
rects_2_over_25 = [r for r in rects_2 if r['area'] >= min_area_used]
rects_2_over_36 = [r for r in rects_2 if r['area'] >= min_area_hypothesized]
print(f"Rectangles with area >= {min_area_used}: {len(rects_2_over_25)}")
# for r in rects_2_over_25: print(r)
print(f"Rectangles with area >= {min_area_hypothesized}: {len(rects_2_over_36)}")
# for r in rects_2_over_36: print(r)

# Expected Rectangles in Input 2 (Manually identified from problem description)
expected_rects_2 = [
    {'r': 2, 'c': 4, 'h': 6, 'w': 6, 'color': 8, 'area': 36},
    {'r': 2, 'c': 20, 'h': 6, 'w': 7, 'color': 2, 'area': 42},
    {'r': 12, 'c': 22, 'h': 6, 'w': 6, 'color': 8, 'area': 36},
    {'r': 17, 'c': 10, 'h': 7, 'w': 8, 'color': 1, 'area': 56}
]
print("\nExpected Rectangles >= 36:")
for r in expected_rects_2: print(r)
```

*code_execution_result:*
outcome: OUTCOME_OK
```
--- Analysis of Input 1 ---
Found 17 'maximal' rectangles.
Rectangles with area >= 25: 0
Rectangles with area >= 36: 0

Expected Rectangles >= 36:
{'r': 2, 'c': 5, 'h': 5, 'w': 10, 'color': 6, 'area': 50}
{'r': 16, 'c': 13, 'h': 7, 'w': 8, 'color': 8, 'area': 56}

--- Analysis of Input 2 ---
Found 22 'maximal' rectangles.
Rectangles with area >= 25: 0
Rectangles with area >= 36: 0

Expected Rectangles >= 36:
{'r': 2, 'c': 4, 'h': 6, 'w': 6, 'color': 8, 'area': 36}
{'r': 2, 'c': 20, 'h': 6, 'w': 7, 'color': 2, 'area': 42}
{'r': 12, 'c': 22, 'h': 6, 'w': 6, 'color': 8, 'area': 36}
{'r': 17, 'c': 10, 'h': 7, 'w': 8, 'color': 1, 'area': 56}

```
**Findings from Metrics:**

The code execution confirms that the `find_maximal_monochromatic_rectangles` function, as implemented in the failing code, finds *zero* rectangles with an area of 25 or greater (and therefore also zero with area 36 or greater) for both input examples. This definitively proves the issue lies within the rectangle identification logic. It is failing to identify the large rectangles present in the inputs. The specific reason likely lies in the complex interaction between finding potential dimensions, checking maximality, and marking cells as `visited`. The current logic appears to prematurely stop expansions or incorrectly mark cells, preventing the discovery of the actual large, maximal rectangles.

The area threshold of 36 still appears correct based on the expected outputs (smallest filled area is 36). The immediate priority is fixing the rectangle finding algorithm.

**Updated YAML Facts:**


```yaml
GridProperties:
  - Input and output grids have the same dimensions (W, H).
  - Most pixels remain unchanged between input and output.

Objects:
  - Type: Maximal Monochromatic Rectangle
  - Definition: A rectangular region within the grid where all pixels have the same color ('C'), and the rectangle cannot be expanded further up, down, left, or right without including a pixel of a different color or exceeding the grid boundaries.
  - Properties:
      - Color (C): The single color of the pixels within the rectangle in the input grid.
      - Position (r, c): The row and column index of the top-left pixel.
      - Size (h, w): The height and width of the rectangle in pixels.
      - Area (A): Calculated as h * w.

Action:
  - Name: ConditionalFillYellow
  - Target: Identified Maximal Monochromatic Rectangles.
  - Condition: The rectangle's Area (A) must be greater than or equal to 36 (A >= 36).
  - Effect: If the condition is met, all pixels within the rectangle's boundaries (from (r, c) to (r+h-1, c+w-1)) in the *output* grid are set to yellow (color 4). Otherwise, the pixels remain unchanged from the input.

TransformationRule:
  - Find all objects matching the 'Maximal Monochromatic Rectangle' definition in the input grid.
  - For each found object, apply the 'ConditionalFillYellow' action.
  - The final output grid is the result of applying these actions to a copy of the input grid.
```


**Updated Natural Language Program:**

1.  Create the output grid as an identical copy of the input grid.
2.  Identify all *maximal monochromatic rectangles* present in the input grid.
    *   A rectangle is monochromatic if all pixels within its bounds share the same single color.
    *   A rectangle is maximal if it cannot be extended in any of the four cardinal directions (up, down, left, right) while remaining monochromatic and within the grid boundaries. Note: Ensure the identification process correctly finds all such rectangles, even if they are adjacent or nested within larger non-rectangular shapes of the same color.
3.  For each identified maximal monochromatic rectangle:
    a.  Calculate its area: `Area = height * width`.
    b.  Check if the `Area` is greater than or equal to 36.
4.  If a maximal monochromatic rectangle's area meets the condition (`Area >= 36`):
    a.  Determine its boundaries (top row `r`, left column `c`, height `h`, width `w`).
    b.  In the *output* grid, change the color of all pixels within these boundaries (from row `r` to `r+h-1` and column `c` to `c+w-1`) to yellow (color 4).
5.  Pixels belonging to maximal monochromatic rectangles with `Area < 36` remain unchanged in the output grid.
6.  Pixels not belonging to *any* maximal monochromatic rectangle remain unchanged in the output grid.
7.  Return the modified output grid.
