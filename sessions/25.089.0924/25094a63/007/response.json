{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies all maximal monochromatic rectangles within the input grid.\nA rectangle is monochromatic if all its pixels share the same color.\nA rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right)\nwithout either going out of bounds or including a pixel of a different color.\n\nFor each maximal monochromatic rectangle found, its area (height * width) is calculated.\nIf the area is 36 or greater, all pixels within the bounds of that rectangle in the output grid\nare replaced with the color yellow (4).\nIf the area is less than 36, the pixels within that rectangle remain unchanged from the input grid.\nAll pixels outside of any maximal monochromatic rectangle also remain unchanged.\n\"\"\"\n\ndef find_maximal_monochromatic_rectangles(grid):\n    \"\"\"\n    Finds all maximal monochromatic rectangles in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a maximal monochromatic rectangle\n              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.\n    \"\"\"\n    rows, cols = grid.shape\n    # visited tracks cells that are part of *confirmed* maximal rectangles\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    # Iterate through each cell as a potential top-left corner of a rectangle\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if this cell has already been included in a confirmed maximal rectangle\n            if visited[r, c]:\n                continue\n\n            color = grid[r, c]\n\n            # --- Find the largest possible rectangle starting at (r, c) ---\n            # 1. Find initial max width in the starting row 'r'\n            current_w = 0\n            for k in range(c, cols):\n                if grid[r, k] == color:\n                    current_w += 1\n                else:\n                    break # Stop at first color change or boundary\n\n            if current_w == 0: # Should not happen normally, but safeguard\n                 continue # No rectangle starts here\n\n            # 2. Expand height downwards, adjusting width (min_w) if rows don't support initial width\n            final_h = 0\n            min_w = current_w # Start with width from the first row\n            for i in range(r, rows):\n                row_w_check = 0\n                possible = True\n                # Check if the current row 'i' supports the current min_w\n                for j in range(c, c + min_w):\n                     # Check boundary and color match\n                    if j >= cols or grid[i, j] != color:\n                        min_w = j - c # Reduce width to the matched part\n                        possible = False\n                        break # Stop checking this row\n                    row_w_check += 1\n\n                if not possible or min_w == 0: # If row didn't match full min_w or width became 0\n                    break # Stop extending height\n\n                # If the row fully matched the current min_w, increment height\n                final_h += 1\n\n            # Potential rectangle found: anchored at (r, c) with dimensions (final_h, min_w)\n            if final_h > 0 and min_w > 0:\n                # --- Check if this specific rectangle is Maximal ---\n                is_maximal = True\n\n                # Check Up: Can it extend upwards? (Check row r-1 within the rect's width)\n                if r > 0:\n                    for k in range(c, c + min_w):\n                        if grid[r - 1, k] == color:\n                            is_maximal = False\n                            break\n\n                # Check Down: Can it extend downwards? (Check row r+final_h within the rect's width)\n                if is_maximal and r + final_h < rows:\n                    for k in range(c, c + min_w):\n                        if grid[r + final_h, k] == color:\n                            is_maximal = False\n                            break\n\n                # Check Left: Can it extend leftwards? (Check col c-1 within the rect's height)\n                if is_maximal and c > 0:\n                    for i in range(r, r + final_h):\n                        if grid[i, c - 1] == color:\n                            is_maximal = False\n                            break\n\n                # Check Right: Can it extend rightwards? (Check col c+min_w within the rect's height)\n                if is_maximal and c + min_w < cols:\n                     for i in range(r, r + final_h):\n                        if grid[i, c + min_w] == color:\n                            is_maximal = False\n                            break\n\n                # --- Store if Maximal and Mark Visited ---\n                if is_maximal:\n                    # Check if any part of this maximal rectangle has *already* been visited.\n                    # This prevents adding duplicates if the algorithm somehow restarts\n                    # within an already found maximal region due to complex overlaps.\n                    if not visited[r : r + final_h, c : c + min_w].any():\n                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})\n                        # Mark the *entire area* of the confirmed maximal rectangle as visited\n                        visited[r : r + final_h, c : c + min_w] = True\n                # If not maximal, we do nothing. We don't add it, and we don't mark (r,c) visited,\n                # allowing (r,c) to be included when the *actual* maximal rectangle containing it is found.\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling large monochromatic rectangles with yellow.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to a NumPy array for easier manipulation and slicing\n    np_grid = np.array(input_grid, dtype=int)\n    # Initialize the output grid as a copy of the input\n    output_grid = np_grid.copy()\n\n    # Define the minimum area threshold for filling\n    min_area = 36\n\n    # Find all maximal monochromatic rectangles in the input grid\n    # Uses the refined helper function designed to correctly identify maximality.\n    rectangles = find_maximal_monochromatic_rectangles(np_grid)\n\n    # Iterate through the found maximal rectangles\n    for rect in rectangles:\n        # Calculate the area of the rectangle\n        area = rect['h'] * rect['w']\n\n        # Check if the area meets the threshold\n        if area >= min_area:\n            # Get the rectangle's position (top-left) and dimensions\n            r, c = rect['r'], rect['c']\n            h, w = rect['h'], rect['w']\n\n            # Fill the corresponding area in the output grid with yellow (color 4)\n            # NumPy slicing makes this efficient.\n            output_grid[r : r + h, c : c + w] = 4\n\n    # Convert the final NumPy array back to a list of lists format for the ARC standard output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 33955,
    "candidates_token_count": 1696,
    "total_token_count": 35651,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.811296,
  "retries": 1
}