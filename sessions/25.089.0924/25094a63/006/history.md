
## train_1

**input:**
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 6 6 6 6 6 6 6 6 6 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 6 6 6 6 6 6 6 6 6 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 6 6 6 6 6 6 6 6 6 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 6 6 6 6 6 6 6 6 6 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 6 6 6 6 6 6 6 6 6 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 8 8 8 8 8 8 8 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 8 8 8 8 8 8 8 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 8 8 8 8 8 8 8 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 8 8 8 8 8 8 8 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 8 8 8 8 8 8 8 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 8 8 8 8 8 8 8 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```


**output:**
```
6 8 6 8 8 8 8 6 6 3 8 6 2 3 8 1 2 8 1 3 8 3 3 6 6 1 2 6 2 2
2 3 3 2 2 3 6 2 6 2 8 1 3 8 1 8 1 8 8 8 8 2 2 3 2 1 2 8 6 3
2 3 8 2 3 4 4 4 4 4 4 4 4 4 3 8 2 6 6 2 8 3 8 8 3 2 3 3 3 2
8 6 8 2 3 4 4 4 4 4 4 4 4 4 3 1 1 2 1 2 6 8 2 6 2 1 8 3 3 8
6 8 6 2 3 4 4 4 4 4 4 4 4 4 3 3 3 8 1 1 2 1 8 3 8 2 3 6 8 2
3 8 3 3 6 4 4 4 4 4 4 4 4 4 2 8 6 3 2 6 1 6 6 2 8 8 3 2 6 6
2 6 3 2 8 4 4 4 4 4 4 4 4 4 8 3 8 3 3 6 3 1 8 8 1 2 3 1 8 8
3 8 1 6 1 8 1 3 8 3 2 3 2 8 1 3 1 2 2 8 1 6 3 3 3 6 2 2 8 6
8 3 3 8 3 8 2 2 8 8 8 8 8 1 1 6 3 3 6 2 2 6 1 3 3 6 3 1 3 3
2 3 3 2 3 2 6 2 3 6 8 3 3 8 3 6 1 3 3 8 8 1 6 6 8 8 1 6 2 6
3 6 3 3 3 2 3 6 1 6 3 8 2 8 2 3 2 6 3 6 6 8 3 6 6 1 6 8 8 6
8 3 3 1 2 2 6 8 2 3 6 8 3 2 2 6 3 2 1 2 6 3 6 8 8 8 1 8 1 6
1 8 8 1 6 6 8 2 8 2 1 2 8 8 1 8 2 8 3 8 3 3 8 8 2 3 3 3 3 3
8 8 3 8 3 2 8 6 3 3 1 3 2 1 6 6 8 3 6 6 3 6 3 1 8 1 2 6 3 8
8 6 6 3 2 6 6 8 6 1 3 2 8 3 1 2 8 3 6 2 8 8 3 2 2 6 1 8 6 3
1 8 1 6 2 3 2 2 1 8 2 2 8 3 6 8 8 8 2 8 8 3 3 1 3 2 2 1 3 2
8 1 3 6 8 8 6 6 3 3 2 2 3 4 4 4 4 4 4 4 1 3 3 8 2 3 6 2 8 2
3 3 3 6 3 2 2 2 6 3 2 3 3 4 4 4 4 4 4 4 8 3 3 2 3 2 2 2 2 3
3 2 1 2 2 8 6 3 8 8 8 3 1 4 4 4 4 4 4 4 6 1 8 3 8 3 6 8 1 8
3 6 1 3 2 3 6 6 6 3 2 1 3 4 4 4 4 4 4 4 3 3 2 1 8 3 6 3 2 3
8 1 3 8 6 2 3 3 3 3 2 8 6 4 4 4 4 4 4 4 2 8 8 3 8 2 3 1 3 2
3 6 3 2 8 6 6 3 8 3 1 2 3 4 4 4 4 4 4 4 3 6 8 6 1 2 1 3 3 6
3 8 8 2 3 8 3 6 8 8 3 1 3 3 8 8 2 2 2 2 3 8 1 1 3 3 2 3 1 3
3 3 6 8 1 6 6 2 8 6 6 1 8 1 2 2 1 6 8 3 2 6 8 6 8 8 6 2 8 3
8 3 3 1 8 3 2 3 3 3 8 3 3 3 3 2 3 8 3 1 3 6 6 6 6 6 3 6 2 3
3 6 8 3 2 1 8 6 6 8 6 6 1 6 6 1 3 3 6 2 6 1 3 3 8 1 2 2 3 3
1 8 3 6 3 2 6 8 8 1 6 6 8 6 6 6 2 6 8 3 8 1 3 8 2 6 3 2 6 6
8 8 6 8 1 1 8 2 2 3 6 2 8 3 8 2 1 1 8 6 8 6 8 6 3 3 3 3 2 3
1 3 8 1 3 1 6 3 6 8 2 3 3 8 2 2 2 1 3 2 8 8 3 8 6 6 3 8 3 8
6 2 6 2 8 2 3 3 3 3 1 3 3 3 2 6 3 8 2 3 6 3 3 2 2 3 8 8 1 3
```


## train_2

**input:**
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 8 8 8 8 8 8 1 3 2 3 3 6 6 2 3 6 2 2 2 2 2 2 2 3 2 3
1 2 8 1 8 8 8 8 8 8 3 8 1 2 1 1 2 3 8 3 2 2 2 2 2 2 2 2 1 3
1 3 8 1 8 8 8 8 8 8 3 2 3 3 8 3 1 1 3 3 2 2 2 2 2 2 2 6 8 3
3 3 8 2 8 8 8 8 8 8 3 3 1 3 2 3 6 1 1 2 2 2 2 2 2 2 2 3 6 2
8 2 1 1 8 8 8 8 8 8 3 3 6 1 3 1 8 1 2 1 2 2 2 2 2 2 2 2 3 8
1 3 3 6 8 8 8 8 8 8 8 1 2 8 2 8 2 1 3 3 2 2 2 2 2 2 2 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 3 3 3 3 3 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 3 3 3 3 3 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 3 3 3 3 3 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 3 3 3 3 3 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 3 3 3 3 3 8 3 3
6 2 3 8 6 2 2 1 8 8 1 1 1 1 1 1 1 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 1 1 1 1 1 1 1 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 1 1 1 1 1 1 1 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 1 1 1 1 1 1 1 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 1 1 1 1 1 1 1 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 1 1 1 1 1 1 1 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```


**output:**
```
3 3 2 6 3 6 8 8 8 2 3 3 3 3 3 6 3 3 8 8 1 2 2 6 3 3 2 8 1 1
8 2 1 6 3 1 8 3 1 8 3 8 8 1 3 2 8 3 8 8 3 1 3 1 8 3 2 6 2 6
1 8 3 1 4 4 4 4 4 4 1 3 2 3 3 6 6 2 3 6 4 4 4 4 4 4 4 3 2 3
1 2 8 1 4 4 4 4 4 4 3 8 1 2 1 1 2 3 8 3 4 4 4 4 4 4 4 2 1 3
1 3 8 1 4 4 4 4 4 4 3 2 3 3 8 3 1 1 3 3 4 4 4 4 4 4 4 6 8 3
3 3 8 2 4 4 4 4 4 4 3 3 1 3 2 3 6 1 1 2 4 4 4 4 4 4 4 3 6 2
8 2 1 1 4 4 4 4 4 4 3 3 6 1 3 1 8 1 2 1 4 4 4 4 4 4 4 2 3 8
1 3 3 6 4 4 4 4 4 4 8 1 2 8 2 8 2 1 3 3 4 4 4 4 4 4 4 2 8 6
3 1 3 8 3 2 3 8 1 3 1 8 1 3 1 2 3 1 8 6 2 1 3 1 1 8 3 1 6 3
2 8 6 3 1 3 8 2 1 3 2 3 3 3 3 1 8 3 3 6 2 8 2 2 6 2 1 6 2 3
8 8 2 2 3 1 1 3 2 3 3 8 2 3 3 8 8 6 6 2 1 2 6 2 3 3 3 2 6 3
6 3 2 2 8 3 2 3 3 1 3 2 2 3 2 6 3 2 2 1 1 2 1 8 6 3 2 1 8 2
8 6 2 8 2 2 2 3 3 8 1 1 3 1 6 1 3 2 8 3 8 3 4 4 4 4 4 1 8 1
8 8 2 8 8 6 8 6 3 8 6 1 3 2 8 3 6 6 2 6 3 8 4 4 4 4 4 3 8 1
1 8 2 6 2 8 1 3 6 3 8 2 2 3 6 1 6 2 8 3 8 3 4 4 4 4 4 2 2 3
3 2 8 1 1 3 2 2 2 6 8 3 8 8 1 2 8 6 1 3 1 2 4 4 4 4 4 2 2 2
8 3 8 1 2 3 8 6 3 3 3 1 6 3 1 2 1 3 2 3 2 8 4 4 4 4 4 8 3 3
6 2 3 8 6 2 2 1 8 8 4 4 4 4 4 4 4 6 6 2 1 6 3 1 6 8 3 1 2 3
2 1 2 1 8 2 3 2 6 8 4 4 4 4 4 4 4 1 1 1 3 6 2 1 2 2 2 3 3 1
1 8 8 2 8 2 2 2 3 1 4 4 4 4 4 4 4 8 2 3 2 3 6 6 2 3 3 3 6 3
2 6 8 3 6 1 3 8 3 6 4 4 4 4 4 4 4 2 3 3 3 1 6 3 3 6 1 3 2 2
6 8 6 2 3 2 6 3 3 1 4 4 4 4 4 4 4 3 3 8 1 6 3 3 3 8 1 8 2 3
6 3 1 3 6 6 1 6 3 8 4 4 4 4 4 4 4 1 2 1 6 3 3 8 1 8 3 8 2 1
3 2 2 3 1 1 2 3 8 6 1 3 3 1 8 3 1 8 8 3 8 3 1 8 8 1 1 2 1 8
3 2 3 6 1 8 3 6 3 3 2 2 1 3 6 3 2 3 8 3 8 3 2 2 2 2 3 3 1 6
2 8 6 2 2 1 8 3 1 6 8 2 3 2 3 2 3 3 3 3 2 2 2 8 6 8 3 6 1 3
6 2 3 2 3 3 8 3 3 6 2 2 3 3 8 8 1 3 1 2 8 3 8 3 3 3 6 1 2 2
2 3 2 1 2 6 3 1 8 3 1 6 2 3 8 2 6 1 1 1 3 6 8 1 2 8 6 2 3 2
2 1 8 2 6 3 8 2 3 6 8 8 2 8 8 3 2 3 1 6 8 2 6 3 2 3 2 1 8 3
1 6 3 1 6 6 3 1 2 8 8 1 8 1 3 3 1 2 6 8 3 1 6 8 3 8 3 1 1 8
```

Okay, let's break down this task.

**Perception of Elements:**

The task involves transforming an input grid into an output grid of the same dimensions. By visually comparing the input and output grids in the examples, I observe the following:

1.  **Grid Size:** The grid dimensions remain constant (30x30 in these examples).
2.  **Background:** Most pixels in the grid remain unchanged between input and output.
3.  **Transformation:** Specific rectangular areas within the input grid are completely filled with yellow pixels (color 4) in the output grid.
4.  **Target Rectangles:** The rectangles that are filled appear to be composed of a single, uniform color in the input grid (monochromatic).
5.  **Multiple Rectangles:** In both examples, more than one such monochromatic rectangle is transformed. In `train_1`, a gray (6) rectangle and an azure (8) rectangle are filled. In `train_2`, three black (8) rectangles and one blue (1) rectangle are filled.
6.  **Size Matters:** Not all monochromatic rectangles are filled. The ones that are filled seem relatively large. Comparing the sizes (area = width * height):
    *   `train_1`: Gray (5x10 = 50 pixels), Azure (7x8 = 56 pixels).
    *   `train_2`: Black (6x6 = 36 pixels), Black (8x8 = 64 pixels), Black (7x7 = 49 pixels), Blue (7x8 = 56 pixels).
7.  **Threshold:** The smallest rectangle filled in either example has an area of 36 (the 6x6 black rectangle in `train_2`). It seems plausible that there's a minimum area threshold for a monochromatic rectangle to be filled. Let's hypothesize the threshold is 36. All filled rectangles in both examples (50, 56, 36, 64, 49, 56) meet or exceed this threshold. We need to assume that any monochromatic rectangles with area >= 36 *not* shown as filled were either not present or not *maximal* (i.e., they were part of a larger non-rectangular monochromatic shape). The rule likely applies to *maximal* monochromatic rectangles (those that cannot be extended further in any direction while remaining monochromatic).

**YAML Facts:**


```yaml
GridProperties:
  - Input and output grids have the same dimensions.
  - Most pixels remain unchanged.

Objects:
  - Type: Maximal Monochromatic Rectangles
  - Definition: Rectangular areas composed of a single color that cannot be extended horizontally or vertically without changing color or going out of bounds.
  - Properties:
      - Color (original color in the input)
      - Position (top-left corner coordinates)
      - Size (width, height)
      - Area (width * height)

Action:
  - Name: FillRectangle
  - Target: Maximal monochromatic rectangles meeting a specific criterion.
  - Criterion: Area >= 36.
  - Effect: All pixels within the target rectangle's boundaries are changed to yellow (color 4).

Relationships:
  - The transformation identifies specific objects (maximal monochromatic rectangles) based on a property (area >= 36) and applies a uniform action (fill with yellow) to them.
  - The final output is the input grid modified by these fill actions.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Scan the input grid to identify all *maximal monochromatic rectangles*. A rectangle is monochromatic if all its pixels have the same color. It is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) and remain a monochromatic rectangle within the grid's bounds.
3.  For each maximal monochromatic rectangle found:
    a.  Calculate its area (Area = width * height).
    b.  Check if the Area is greater than or equal to 36.
4.  For every maximal monochromatic rectangle that meets the area condition (Area >= 36):
    a.  Iterate through all pixel coordinates (row, column) within the boundaries of that rectangle.
    b.  Set the color of the corresponding pixel in the output grid to yellow (color 4).
5.  Return the modified output grid.
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid.
A rectangle is monochromatic if all its pixels share the same color.
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated.
If the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 25, the pixels within that rectangle remain unchanged from the input grid.
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # Keep track of visited cells to avoid redundant checks and overlapping rectangles
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a found rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]

            # Find the initial maximum width starting from (r, c) in the current row
            initial_w = 0
            for k in range(c, cols):
                # Only extend width if the cell has the same color and hasn't been visited
                if not visited[r, k] and grid[r, k] == color:
                    initial_w += 1
                else:
                    # Stop extending width at the first mismatch or visited cell
                    break
            
            # If no width found (e.g., starting cell was already visited), mark and skip
            if initial_w == 0:
                visited[r,c] = True # Ensure the starting cell is marked visited
                continue

            # Determine the maximum possible height for this rectangle
            # The width might shrink as we check lower rows
            final_h = 0
            min_w = initial_w # Start with the width found for the first row
            
            # Iterate downwards from the starting row
            for i in range(r, rows):
                current_row_w = 0
                # Check cells in the current row up to the current minimum width (min_w)
                for j in range(c, c + min_w):
                    # Stop if the cell is out of bounds, visited, or has the wrong color
                    if j >= cols or visited[i, j] or grid[i, j] != color:
                        # The rectangle cannot extend this wide in this row.
                        # Update min_w to the width that *did* match in this row.
                        min_w = j - c 
                        break # Stop checking this row further
                    current_row_w +=1
                
                # If the width shrank to zero, or the loop finished because width became 0, stop extending height
                if min_w == 0:
                    break
                
                # If we successfully checked min_w columns in this row (current_row_w == min_w)
                if current_row_w == min_w:
                     final_h += 1 # Increment the height of the rectangle
                else:
                    # This should technically be caught by min_w becoming 0, but as a safeguard:
                    # If the row check didn't complete fully up to min_w, stop extending height
                     break


            # We have found a maximal rectangle anchored at (r, c)
            # with dimensions (final_h, min_w)
            if final_h > 0 and min_w > 0:
                # Mark all cells within the identified rectangle as visited
                visited[r : r + final_h, c : c + min_w] = True
                # Store the details of the found rectangle
                rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
            elif not visited[r,c]:
                 # If for some reason no rectangle was formed (e.g. h=0 or w=0)
                 # ensure the starting cell is marked as visited.
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The transformed grid.
    """
    # Convert input to a NumPy array for efficient array operations and slicing
    np_grid = np.array(input_grid, dtype=int)
    # Create a copy of the input grid to modify, this will be the output
    output_grid = np_grid.copy()

    # Define the minimum area threshold for a rectangle to be filled
    min_area = 25

    # Find all maximal monochromatic rectangles in the input grid
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # Process each found rectangle
    for rect in rectangles:
        # Calculate the area of the current rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the minimum requirement
        if area >= min_area:
            # Get the position (top-left corner) and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the area defined by the rectangle in the output grid with yellow (color 4)
            # NumPy slicing allows efficient modification of the rectangular region
            output_grid[r : r + h, c : c + w] = 4

    # Convert the final NumPy array back to a list of lists format for the output
    return output_grid.tolist()
```
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid.
A rectangle is monochromatic if all its pixels share the same color.
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated.
If the area is 36 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 36, the pixels within that rectangle remain unchanged from the input grid.
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # Keep track of visited cells to avoid redundant checks and overlapping rectangles
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a found rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]

            # Find the initial maximum width starting from (r, c) in the current row
            initial_w = 0
            # Check rightwards from the current column 'c'
            for k in range(c, cols):
                # Only extend width if the cell has the same color and hasn't been visited
                # Note: Checking 'visited' here might prevent finding *maximal* rects
                # if part of it was 'visited' by a suboptimal rect found earlier.
                # A better approach might be to find all possible rectangles first,
                # then filter for maximality. However, this approach attempts to find
                # maximal ones directly by expanding from unvisited cells.
                if grid[r, k] == color:
                    initial_w += 1
                else:
                    # Stop extending width at the first color mismatch
                    break
            
            # This check was added previously but seems redundant if the outer loop iterates correctly
            # if initial_w == 0:
            #     visited[r,c] = True 
            #     continue

            # Determine the maximum possible height for this rectangle
            # The width might shrink as we check lower rows
            final_h = 0
            min_w = initial_w # Start with the width found for the first row
            
            # Iterate downwards from the starting row
            for i in range(r, rows):
                current_row_w = 0
                # Check cells in the current row up to the current minimum width (min_w)
                for j in range(c, c + min_w):
                    # Stop if the cell is out of bounds, or has the wrong color
                    # Crucially, don't stop based on 'visited' here, as we need to check the full
                    # potential extent of the rectangle, even if parts overlap previous checks.
                    if j >= cols or grid[i, j] != color:
                        # The rectangle cannot extend this wide in this row.
                        # Update min_w to the width that *did* match in this row.
                        min_w = j - c 
                        break # Stop checking this row further
                    current_row_w +=1
                
                # If the width shrank to zero, or the loop finished because width became 0, stop extending height
                if min_w == 0:
                    break
                
                # If we successfully checked min_w columns in this row (current_row_w == min_w)
                if current_row_w == min_w:
                     final_h += 1 # Increment the height of the rectangle
                else:
                    # If the row check didn't complete fully up to min_w, stop extending height
                     break


            # We have found a potential maximal rectangle anchored at (r, c)
            # with dimensions (final_h, min_w).
            # Mark only the cells within *this specific* found rectangle as visited.
            if final_h > 0 and min_w > 0:
                is_maximal = True
                # Check for horizontal maximality (can it extend left/right?)
                # Check left boundary
                if c > 0:
                    for row_idx in range(r, r + final_h):
                       if grid[row_idx, c - 1] == color:
                           is_maximal = False
                           break
                # Check right boundary
                if is_maximal and c + min_w < cols:
                    for row_idx in range(r, r + final_h):
                        if grid[row_idx, c + min_w] == color:
                            is_maximal = False
                            break
                
                # Check for vertical maximality (can it extend up/down?)
                # Check top boundary
                if is_maximal and r > 0:
                     for col_idx in range(c, c + min_w):
                        if grid[r - 1, col_idx] == color:
                            is_maximal = False
                            break
                # Check bottom boundary
                if is_maximal and r + final_h < rows:
                    for col_idx in range(c, c + min_w):
                        if grid[r + final_h, col_idx] == color:
                             is_maximal = False
                             break

                # Store the rectangle only if it's maximal
                if is_maximal:
                    # Only mark as visited *after* confirming maximality to allow overlap checks
                    visited[r : r + final_h, c : c + min_w] = True
                    rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
                else:
                    # If not maximal, still mark the starting cell visited to avoid re-processing it
                    # as the top-left of the same non-maximal shape. This might need refinement.
                     visited[r,c] = True


            # Ensure the starting point is marked visited even if no rectangle forms from it
            # or if it wasn't part of a maximal rectangle starting there.
            if not visited[r,c]:
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The transformed grid.
    """
    # Convert input to a NumPy array for efficient array operations and slicing
    np_grid = np.array(input_grid, dtype=int)
    # Create a copy of the input grid to modify, this will be the output
    output_grid = np_grid.copy()

    # --- Refined Area Threshold ---
    # Define the minimum area threshold based on re-evaluation of examples
    min_area = 36 

    # --- Find Rectangles ---
    # Find all maximal monochromatic rectangles in the input grid
    # Using a potentially refined finder function
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # --- Apply Transformation ---
    # Process each found maximal rectangle
    for rect in rectangles:
        # Calculate the area of the current rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the minimum requirement
        if area >= min_area:
            # Get the position (top-left corner) and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the area defined by the rectangle in the output grid with yellow (color 4)
            # NumPy slicing allows efficient modification of the rectangular region
            output_grid[r : r + h, c : c + w] = 4

    # Convert the final NumPy array back to a list of lists format for the output
    return output_grid.tolist()
```
```python
import numpy as np

"""
The transformation identifies all maximal monochromatic rectangles within the input grid. 
A rectangle is monochromatic if all its pixels share the same color. 
A rectangle is maximal if it cannot be expanded in any of the four cardinal directions (up, down, left, right) 
without either going out of bounds or including a pixel of a different color.

For each maximal monochromatic rectangle found, its area (height * width) is calculated. 
If the area is 25 or greater, all pixels within the bounds of that rectangle in the output grid 
are replaced with the color yellow (4). 
If the area is less than 25, the pixels within that rectangle remain unchanged from the input grid. 
All pixels outside of any maximal monochromatic rectangle also remain unchanged.
"""

def find_maximal_monochromatic_rectangles(grid):
    """
    Finds all maximal monochromatic rectangles in the grid.

    Args:
        grid (np.ndarray): The input grid.

    Returns:
        list: A list of dictionaries, each representing a maximal monochromatic rectangle
              with keys 'r' (row), 'c' (column), 'h' (height), 'w' (width), 'color'.
    """
    rows, cols = grid.shape
    # visited helps track cells that are already part of a confirmed maximal rectangle
    visited = np.zeros_like(grid, dtype=bool)
    rectangles = []

    # Iterate through each cell as a potential top-left corner of a rectangle
    for r in range(rows):
        for c in range(cols):
            # Skip if this cell has already been included in a confirmed maximal rectangle
            if visited[r, c]:
                continue

            color = grid[r, c]
            
            # --- Find potential rectangle dimensions starting at (r, c) ---
            # 1. Find initial width in the starting row 'r'
            current_w = 0
            for k in range(c, cols):
                if grid[r, k] == color:
                    current_w += 1
                else:
                    break # Stop at first color change or boundary
            
            if current_w == 0: # Should not happen if loop starts correctly, but safeguard
                 visited[r,c] = True # Mark this single cell visited if it leads nowhere
                 continue

            # 2. Find height, adjusting width if necessary
            final_h = 0
            min_w = current_w # Start with width from the first row
            for i in range(r, rows):
                row_w = 0
                possible = True
                for j in range(c, c + min_w):
                     # Check boundary and color match for the current potential width (min_w)
                    if j >= cols or grid[i, j] != color:
                        min_w = j - c # Reduce width to the matched part
                        possible = False
                        break # Stop checking this row
                    row_w += 1
                
                if not possible or min_w == 0: # If row didn't match full min_w or width became 0
                    break # Stop extending height

                # If the row matched the current min_w, increment height
                final_h += 1

            # Found a potential rectangle: (r, c) with dimensions (final_h, min_w)
            if final_h > 0 and min_w > 0:
                # --- Check for Maximality ---
                is_maximal = True
                
                # Check Up: Can it extend upwards?
                if r > 0:
                    for k in range(c, c + min_w):
                        if grid[r - 1, k] == color:
                            is_maximal = False
                            break
                
                # Check Down: Can it extend downwards?
                if is_maximal and r + final_h < rows:
                    for k in range(c, c + min_w):
                        if grid[r + final_h, k] == color:
                            is_maximal = False
                            break
                            
                # Check Left: Can it extend leftwards?
                if is_maximal and c > 0:
                    for i in range(r, r + final_h):
                        if grid[i, c - 1] == color:
                            is_maximal = False
                            break
                            
                # Check Right: Can it extend rightwards?
                if is_maximal and c + min_w < cols:
                     for i in range(r, r + final_h):
                        if grid[i, c + min_w] == color:
                            is_maximal = False
                            break

                # --- Store if Maximal and Mark Visited ---
                if is_maximal:
                    # Check if any part of this maximal rectangle has already been visited
                    # This prevents adding duplicates if the algorithm somehow restarts
                    # within an already found maximal region.
                    if not visited[r : r + final_h, c : c + min_w].any():
                        rectangles.append({'r': r, 'c': c, 'h': final_h, 'w': min_w, 'color': color})
                        # Mark the *entire area* of the confirmed maximal rectangle as visited
                        visited[r : r + final_h, c : c + min_w] = True
                else:
                     # If the rectangle starting at (r,c) wasn't maximal, 
                     # only mark the starting cell (r, c) visited. 
                     # This prevents re-evaluating (r,c) as a top-left corner, 
                     # but allows its pixels to be included in the true maximal 
                     # rectangle when its actual top-left corner is processed.
                     visited[r, c] = True
            else:
                 # Mark single cell visited if no rect formed (h=0 or w=0)
                 visited[r,c] = True


    return rectangles


def transform(input_grid):
    """
    Transforms the input grid by filling large monochromatic rectangles with yellow.
    """
    # Convert input to a NumPy array for easier manipulation
    np_grid = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input
    output_grid = np_grid.copy()

    # Define the minimum area threshold
    min_area = 25

    # Find all maximal monochromatic rectangles in the input grid
    rectangles = find_maximal_monochromatic_rectangles(np_grid)

    # Iterate through the found maximal rectangles
    for rect in rectangles:
        # Calculate the area of the rectangle
        area = rect['h'] * rect['w']

        # Check if the area meets the threshold
        if area >= min_area:
            # Get the rectangle's position and dimensions
            r, c = rect['r'], rect['c']
            h, w = rect['h'], rect['w']
            
            # Fill the corresponding area in the output grid with yellow (color 4)
            output_grid[r : r + h, c : c + w] = 4

    # Convert the result back to a list of lists format
    return output_grid.tolist()
```
