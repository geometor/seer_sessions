{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies closed loops formed by blue (1) pixels in the input grid.\nFor each closed loop found:\n1. Fills the area enclosed by the loop with green (3) pixels.\n2. Creates a one-pixel thick border of red (2) pixels immediately outside the loop, replacing adjacent white (0) pixels.\nIf a blue shape does not form a closed loop, it remains unchanged.\nThe background is white (0).\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Yields valid orthogonal neighbors for a given cell.\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            yield nr, nc\n\ndef find_regions(grid, target_color):\n    \"\"\"\n    Finds connected regions of a specific color using BFS.\n    Returns a list of sets, where each set contains the (r, c) coordinates of a region.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new region\n                current_region = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_region.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            current_region.add((nr, nc))\n                            q.append((nr, nc))\n                regions.append(current_region)\n    return regions\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies closed blue loops, fills their interior with green, \n    and borders them externally with red.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    height, width = input_grid_np.shape\n\n    # 1. Identify all white regions and classify them as exterior or interior\n    white_regions = [] # List to store tuples: (region_pixels, is_interior)\n    visited_white = np.zeros_like(input_grid_np, dtype=bool)\n    exterior_white_pixels = set()\n\n    q = deque()\n    # Initialize queue with boundary white pixels\n    for r in range(height):\n        for c in [0, width - 1]:\n             if input_grid_np[r, c] == 0 and not visited_white[r,c]:\n                 q.append((r,c))\n                 visited_white[r,c] = True\n                 exterior_white_pixels.add((r,c))\n    for c in range(width): # Use range(width) instead of range(1, width-1) to include corners\n        for r in [0, height -1]:\n             if input_grid_np[r, c] == 0 and not visited_white[r,c]:\n                 q.append((r,c))\n                 visited_white[r,c] = True\n                 exterior_white_pixels.add((r,c))\n                 \n    # BFS for exterior white region(s)\n    while q:\n        r, c = q.popleft()\n        for nr, nc in get_neighbors(r, c, height, width):\n            if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:\n                visited_white[nr, nc] = True\n                exterior_white_pixels.add((nr,nc))\n                q.append((nr, nc))\n\n    if exterior_white_pixels: # Check if there are any exterior white pixels found\n         white_regions.append((exterior_white_pixels, False)) # Add the combined exterior region\n\n    # Find interior white regions (those not visited yet)\n    for r in range(height):\n        for c in range(width):\n            if input_grid_np[r, c] == 0 and not visited_white[r, c]:\n                # Start BFS for a new interior region\n                current_interior_region = set()\n                q_interior = deque([(r, c)])\n                visited_white[r, c] = True\n                current_interior_region.add((r, c))\n\n                while q_interior:\n                    row, col = q_interior.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:\n                            visited_white[nr, nc] = True\n                            current_interior_region.add((nr, nc))\n                            q_interior.append((nr, nc))\n                \n                if current_interior_region: # Ensure we found something\n                     white_regions.append((current_interior_region, True))\n\n\n    # 2. Process interior white regions (these define the closed loops)\n    for region_pixels, is_interior in white_regions:\n        if is_interior:\n            adjacent_blue_pixels = set()\n            adjacent_exterior_white_for_border = set()\n\n            # Fill the interior region with green\n            for r, c in region_pixels:\n                output_grid[r, c] = 3 # Green\n                # While iterating interior pixels, find adjacent blue pixels\n                for nr, nc in get_neighbors(r, c, height, width):\n                    if input_grid_np[nr, nc] == 1: # Blue\n                        adjacent_blue_pixels.add((nr, nc))\n\n            # Find exterior white pixels adjacent to the identified blue border\n            for br, bc in adjacent_blue_pixels:\n                 for nr, nc in get_neighbors(br, bc, height, width):\n                     # Check if neighbor is white AND belongs to the exterior set\n                     if (nr, nc) in exterior_white_pixels: \n                         adjacent_exterior_white_for_border.add((nr,nc))\n\n            # Color the adjacent exterior white pixels red\n            for r, c in adjacent_exterior_white_for_border:\n                 output_grid[r, c] = 2 # Red\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5493,
    "candidates_token_count": 1545,
    "total_token_count": 7038,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.695169,
  "retries": 1
}