
## train_1

**input:**
```
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0 1 1 1 1 0 0
0 0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 1 1 1 1 0 0 0 1 0 0
0 0 0 0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0
0 0 0 0 0 0 0 0 0 0 1 0 1 0
0 0 0 1 0 1 1 1 0 0 1 1 1 0
0 0 0 1 0 0 0 1 0 0 0 0 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 2 1 1 1 1 1 1 2 0 0 0 0
0 0 2 1 3 3 3 3 1 2 2 2 2 0
0 0 2 1 3 0 0 3 1 1 1 1 2 0
0 0 2 1 3 0 0 3 3 3 3 1 2 0
0 0 2 1 3 3 3 3 3 0 3 1 2 0
0 0 2 1 1 1 1 1 3 0 3 1 2 0
0 0 2 2 2 2 2 1 3 3 3 1 2 0
0 0 0 0 0 0 2 1 1 1 1 1 2 0
0 0 0 0 0 0 2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 2 2 2 2 2
0 0 0 0 0 0 0 0 0 2 1 1 1 2
0 0 0 0 0 0 0 0 0 2 1 3 1 2
0 0 0 1 0 1 1 1 0 2 1 1 1 2
0 0 0 1 0 0 0 1 0 2 2 2 2 2
0 0 0 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0
0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0
0 0 0 0 0 1 1 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 0
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0
0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 1 1 1 1 1 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 0 3 1 2 0 0 0 0 1 1 1 1 1 0 0
0 0 2 1 1 1 3 0 3 1 2 0 0 0 0 1 0 0 0 1 0 0
0 0 2 2 2 1 3 3 3 1 2 0 0 0 1 1 0 0 0 1 0 0
0 0 0 0 2 1 1 1 1 1 2 0 0 0 1 0 0 0 0 1 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 1 1 0 1 0 1 0 0
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 2 2 1 1 1 1 2 0 0 0 0 1 0 1 0 0 0 0 0
0 0 0 2 1 1 3 3 1 2 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 2 1 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 1 1 1 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 1 1 1 0 0
0 1 1 1 0 1 0 0
0 1 0 0 0 1 0 0
0 1 0 0 0 1 0 0
0 1 0 0 0 1 0 0
0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 1 1 1 2 0
2 1 1 1 3 1 2 0
2 1 3 3 3 1 2 0
2 1 3 0 3 1 2 0
2 1 3 3 3 1 2 0
2 1 1 1 1 1 2 0
2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

**Perception of Elements:**

*   The input grids contain a white (0) background and various shapes formed by blue (1) pixels.
*   The blue shapes in the input can be closed loops or open structures.
*   The output grids often introduce red (2) and green (3) pixels in relation to the blue shapes, but only when the blue shape forms a closed loop.
*   If a blue shape is not a closed loop (like in `train_2`), the output grid is identical to the input grid for that shape.
*   When a transformation occurs (for closed blue loops):
    *   Red (2) pixels appear immediately *outside* the blue (1) loop, forming a one-pixel thick border. These red pixels replace original white (0) pixels. The border seems to be placed on orthogonally adjacent white cells.
    *   Green (3) pixels fill the area *inside* the blue (1) loop, replacing the original white (0) pixels enclosed by the loop.
*   The original blue (1) shapes remain unchanged in the output.
*   Multiple independent blue shapes can exist in one grid (`train_1`, `train_3`), and the transformation rules apply individually to each closed loop.

**YAML Facts:**


```yaml
task_description: "Identify closed loops formed by blue pixels and color the areas immediately outside and inside them."
elements:
  - element: "background"
    color_name: "white"
    color_value: 0
  - element: "shape"
    color_name: "blue"
    color_value: 1
    properties:
      - "can form closed loops"
      - "can form open structures"
  - element: "outer_border"
    color_name: "red"
    color_value: 2
    properties:
      - "appears only around closed blue loops"
      - "replaces orthogonally adjacent white pixels outside the loop"
      - "is one pixel thick"
  - element: "inner_fill"
    color_name: "green"
    color_value: 3
    properties:
      - "appears only inside closed blue loops"
      - "replaces white pixels enclosed by the loop"
actions:
  - action: "identify_shapes"
    input: "input grid"
    target: "blue pixels"
    output: "sets of connected blue pixels (shapes)"
  - action: "check_closure"
    input: "blue shape"
    target: "enclosed white pixels"
    condition: "determine if the enclosed white region is bounded entirely by the blue shape (does not touch grid edge)"
    output: "boolean (is_closed_loop)"
  - action: "apply_border"
    condition: "is_closed_loop is true"
    input: "closed blue loop"
    target: "orthogonally adjacent white pixels outside the loop"
    effect: "change target pixels to red"
  - action: "apply_fill"
    condition: "is_closed_loop is true"
    input: "closed blue loop"
    target: "white pixels inside the loop"
    effect: "change target pixels to green"
relationships:
  - relationship: "spatial"
    between: ["red pixels", "blue loop"]
    details: "red pixels are orthogonally adjacent to the outside of the closed blue loop."
  - relationship: "containment"
    between: ["green pixels", "blue loop"]
    details: "green pixels are contained within the closed blue loop."
  - relationship: "conditional_transformation"
    element: "blue shape"
    condition: "shape forms a closed loop"
    effect: "red border and green fill are applied"
    alternative_effect: "no changes are applied"
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the initial output grid.
2.  Scan the input grid to find all distinct contiguous groups (shapes) of blue (1) pixels.
3.  For each identified blue shape:
    a.  Determine if the shape forms a closed loop. This can be checked by attempting a flood fill starting from a white (0) pixel known to be adjacent to the shape. If the flood fill can reach the boundary of the grid without crossing the blue shape, the shape is not a closed loop enclosing that region. Conversely, if a flood fill initiated *within* an area surrounded by the shape cannot reach the grid boundary, it is an enclosed region, and the shape is a closed loop.
    b.  If the blue shape is identified as a closed loop:
        i.  Identify all white (0) pixels enclosed within this loop. Change the color of these pixels in the output grid to green (3).
        ii. Identify all white (0) pixels in the input grid that are orthogonally adjacent (share a side, not just a corner) to any blue (1) pixel belonging to this closed loop. Change the color of these adjacent white pixels in the output grid to red (2).
4.  If a blue shape is not a closed loop, make no changes related to it in the output grid (it remains as it was in the input).
5.  Return the final modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies closed loops formed by blue (1) pixels in the input grid.
For each closed loop found:
1. Fills the area enclosed by the loop with green (3) pixels.
2. Creates a one-pixel thick border of red (2) pixels immediately outside the loop, replacing adjacent white (0) pixels.
If a blue shape does not form a closed loop, it remains unchanged.
The background is white (0).
"""

def get_neighbors(r, c, height, width):
    """Yields valid orthogonal neighbors for a given cell."""
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            yield nr, nc

def find_regions(grid, target_color):
    """
    Finds connected regions of a specific color using BFS.
    Returns a list of sets, where each set contains the (r, c) coordinates of a region.
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    regions = []

    for r in range(height):
        for c in range(width):
            if grid[r, c] == target_color and not visited[r, c]:
                # Start BFS for a new region
                current_region = set()
                q = deque([(r, c)])
                visited[r, c] = True
                current_region.add((r, c))

                while q:
                    row, col = q.popleft()
                    for nr, nc in get_neighbors(row, col, height, width):
                        if grid[nr, nc] == target_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            current_region.add((nr, nc))
                            q.append((nr, nc))
                regions.append(current_region)
    return regions


def transform(input_grid):
    """
    Identifies closed blue loops, fills their interior with green, 
    and borders them externally with red.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = input_grid_np.copy()
    height, width = input_grid_np.shape

    # 1. Identify all white regions and classify them as exterior or interior
    white_regions = [] # List to store tuples: (region_pixels, is_interior)
    visited_white = np.zeros_like(input_grid_np, dtype=bool)
    exterior_white_pixels = set()

    q = deque()
    # Initialize queue with boundary white pixels
    for r in range(height):
        for c in [0, width - 1]:
             if input_grid_np[r, c] == 0 and not visited_white[r,c]:
                 q.append((r,c))
                 visited_white[r,c] = True
                 exterior_white_pixels.add((r,c))
    for c in range(width): # Use range(width) instead of range(1, width-1) to include corners
        for r in [0, height -1]:
             if input_grid_np[r, c] == 0 and not visited_white[r,c]:
                 q.append((r,c))
                 visited_white[r,c] = True
                 exterior_white_pixels.add((r,c))
                 
    # BFS for exterior white region(s)
    while q:
        r, c = q.popleft()
        for nr, nc in get_neighbors(r, c, height, width):
            if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:
                visited_white[nr, nc] = True
                exterior_white_pixels.add((nr,nc))
                q.append((nr, nc))

    if exterior_white_pixels: # Check if there are any exterior white pixels found
         white_regions.append((exterior_white_pixels, False)) # Add the combined exterior region

    # Find interior white regions (those not visited yet)
    for r in range(height):
        for c in range(width):
            if input_grid_np[r, c] == 0 and not visited_white[r, c]:
                # Start BFS for a new interior region
                current_interior_region = set()
                q_interior = deque([(r, c)])
                visited_white[r, c] = True
                current_interior_region.add((r, c))

                while q_interior:
                    row, col = q_interior.popleft()
                    for nr, nc in get_neighbors(row, col, height, width):
                        if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:
                            visited_white[nr, nc] = True
                            current_interior_region.add((nr, nc))
                            q_interior.append((nr, nc))
                
                if current_interior_region: # Ensure we found something
                     white_regions.append((current_interior_region, True))


    # 2. Process interior white regions (these define the closed loops)
    for region_pixels, is_interior in white_regions:
        if is_interior:
            adjacent_blue_pixels = set()
            adjacent_exterior_white_for_border = set()

            # Fill the interior region with green
            for r, c in region_pixels:
                output_grid[r, c] = 3 # Green
                # While iterating interior pixels, find adjacent blue pixels
                for nr, nc in get_neighbors(r, c, height, width):
                    if input_grid_np[nr, nc] == 1: # Blue
                        adjacent_blue_pixels.add((nr, nc))

            # Find exterior white pixels adjacent to the identified blue border
            for br, bc in adjacent_blue_pixels:
                 for nr, nc in get_neighbors(br, bc, height, width):
                     # Check if neighbor is white AND belongs to the exterior set
                     if (nr, nc) in exterior_white_pixels: 
                         adjacent_exterior_white_for_border.add((nr,nc))

            # Color the adjacent exterior white pixels red
            for r, c in adjacent_exterior_white_for_border:
                 output_grid[r, c] = 2 # Red

    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Identifies closed loops formed by blue (1) pixels in the input grid.
For each closed loop found:
1. Fills the area enclosed by the loop with green (3) pixels.
2. Creates a one-pixel thick border of red (2) pixels immediately outside the loop, replacing adjacent white (0) pixels.
If a blue shape does not form a closed loop, it remains unchanged.
The background is white (0).
"""

def get_neighbors(r, c, height, width):
    """Yields valid orthogonal neighbors for a given cell."""
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            yield nr, nc

def find_regions(grid, target_color):
    """
    Finds connected regions of a specific color using BFS.
    Returns a list of sets, where each set contains the (r, c) coordinates of a region.
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    regions = []

    for r in range(height):
        for c in range(width):
            if grid[r, c] == target_color and not visited[r, c]:
                # Start BFS for a new region
                current_region = set()
                q = deque([(r, c)])
                visited[r, c] = True
                current_region.add((r, c))

                while q:
                    row, col = q.popleft()
                    for nr, nc in get_neighbors(row, col, height, width):
                        if grid[nr, nc] == target_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            current_region.add((nr, nc))
                            q.append((nr, nc))
                regions.append(current_region)
    return regions


def transform(input_grid):
    """
    Identifies closed blue loops, fills their interior with green, 
    and borders them externally with red.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = input_grid_np.copy()
    height, width = input_grid_np.shape

    # 1. Identify all white regions and classify them as exterior or interior
    white_regions = [] # List to store tuples: (region_pixels, is_interior)
    visited_white = np.zeros_like(input_grid_np, dtype=bool)
    exterior_white_pixels = set()

    q = deque()
    # Initialize queue with boundary white pixels
    for r in range(height):
        for c in [0, width - 1]:
             if input_grid_np[r, c] == 0 and not visited_white[r,c]:
                 q.append((r,c))
                 visited_white[r,c] = True
                 exterior_white_pixels.add((r,c))
    for c in range(width): # Use range(width) instead of range(1, width-1) to include corners
        for r in [0, height -1]:
             if input_grid_np[r, c] == 0 and not visited_white[r,c]:
                 q.append((r,c))
                 visited_white[r,c] = True
                 exterior_white_pixels.add((r,c))
                 
    # BFS for exterior white region(s)
    while q:
        r, c = q.popleft()
        for nr, nc in get_neighbors(r, c, height, width):
            if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:
                visited_white[nr, nc] = True
                exterior_white_pixels.add((nr,nc))
                q.append((nr, nc))

    if exterior_white_pixels: # Check if there are any exterior white pixels found
         white_regions.append((exterior_white_pixels, False)) # Add the combined exterior region

    # Find interior white regions (those not visited yet)
    for r in range(height):
        for c in range(width):
            if input_grid_np[r, c] == 0 and not visited_white[r, c]:
                # Start BFS for a new interior region
                current_interior_region = set()
                q_interior = deque([(r, c)])
                visited_white[r, c] = True
                current_interior_region.add((r, c))

                while q_interior:
                    row, col = q_interior.popleft()
                    for nr, nc in get_neighbors(row, col, height, width):
                        if input_grid_np[nr, nc] == 0 and not visited_white[nr, nc]:
                            visited_white[nr, nc] = True
                            current_interior_region.add((nr, nc))
                            q_interior.append((nr, nc))
                
                if current_interior_region: # Ensure we found something
                     white_regions.append((current_interior_region, True))


    # 2. Process interior white regions (these define the closed loops)
    for region_pixels, is_interior in white_regions:
        if is_interior:
            adjacent_blue_pixels = set()
            adjacent_exterior_white_for_border = set()

            # Fill the interior region with green
            for r, c in region_pixels:
                output_grid[r, c] = 3 # Green
                # While iterating interior pixels, find adjacent blue pixels
                for nr, nc in get_neighbors(r, c, height, width):
                    if input_grid_np[nr, nc] == 1: # Blue
                        adjacent_blue_pixels.add((nr, nc))

            # Find exterior white pixels adjacent to the identified blue border
            for br, bc in adjacent_blue_pixels:
                 for nr, nc in get_neighbors(br, bc, height, width):
                     # Check if neighbor is white AND belongs to the exterior set
                     if (nr, nc) in exterior_white_pixels: 
                         adjacent_exterior_white_for_border.add((nr,nc))

            # Color the adjacent exterior white pixels red
            for r, c in adjacent_exterior_white_for_border:
                 output_grid[r, c] = 2 # Red

    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0 1 1 1 1 0 0
0 0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 1 1 1 1 0 0 0 1 0 0
0 0 0 0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0
0 0 0 0 0 0 0 0 0 0 1 0 1 0
0 0 0 1 0 1 1 1 0 0 1 1 1 0
0 0 0 1 0 0 0 1 0 0 0 0 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 2 1 1 1 1 1 1 2 0 0 0 0
0 0 2 1 3 3 3 3 1 2 2 2 2 0
0 0 2 1 3 0 0 3 1 1 1 1 2 0
0 0 2 1 3 0 0 3 3 3 3 1 2 0
0 0 2 1 3 3 3 3 3 0 3 1 2 0
0 0 2 1 1 1 1 1 3 0 3 1 2 0
0 0 2 2 2 2 2 1 3 3 3 1 2 0
0 0 0 0 0 0 2 1 1 1 1 1 2 0
0 0 0 0 0 0 2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 2 2 2 2 2
0 0 0 0 0 0 0 0 0 2 1 1 1 2
0 0 0 0 0 0 0 0 0 2 1 3 1 2
0 0 0 1 0 1 1 1 0 2 1 1 1 2
0 0 0 1 0 0 0 1 0 2 2 2 2 2
0 0 0 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 2 1 3 3 3 3 1 2 2 0 0 0
0 0 2 1 3 3 3 3 1 1 1 1 0 0
0 0 2 1 3 3 3 3 3 3 3 1 2 0
0 0 2 1 3 3 3 3 3 3 3 1 2 0
0 0 0 1 1 1 1 1 3 3 3 1 2 0
0 0 0 0 2 2 2 1 3 3 3 1 2 0
0 0 0 0 0 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0
0 0 0 0 0 0 0 0 0 2 1 3 1 2
0 0 0 1 0 1 1 1 0 0 1 1 1 0
0 0 0 1 0 0 0 1 0 0 0 2 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 32
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 28.571428571428584

## Example 2:
Input:
```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 0 0 0 0 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0

## Example 3:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0
0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0
0 0 0 0 0 1 1 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 0
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0
0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 1 1 1 1 1 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 0 3 1 2 0 0 0 0 1 1 1 1 1 0 0
0 0 2 1 1 1 3 0 3 1 2 0 0 0 0 1 0 0 0 1 0 0
0 0 2 2 2 1 3 3 3 1 2 0 0 0 1 1 0 0 0 1 0 0
0 0 0 0 2 1 1 1 1 1 2 0 0 0 1 0 0 0 0 1 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 1 1 0 1 0 1 0 0
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 2 2 1 1 1 1 2 0 0 0 0 1 0 1 0 0 0 0 0
0 0 0 2 1 1 3 3 1 2 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 2 1 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 1 1 1 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 1 3 3 3 3 3 1 2 0 0 0 0 1 1 1 1 1 0 0
0 0 0 1 1 1 3 3 3 1 2 0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 2 1 3 3 3 1 2 0 0 0 1 1 0 0 0 1 0 0
0 0 0 0 0 1 1 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0
0 0 0 0 0 0 2 2 2 0 0 0 0 0 1 1 0 1 0 1 0 0
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 2 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0
0 0 0 0 1 1 3 3 1 2 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 2 1 3 3 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 32
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 15.311004784688976

## Example 4:
Input:
```
0 0 0 1 1 1 0 0
0 1 1 1 0 1 0 0
0 1 0 0 0 1 0 0
0 1 0 0 0 1 0 0
0 1 0 0 0 1 0 0
0 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```
Expected Output:
```
2 2 2 1 1 1 2 0
2 1 1 1 3 1 2 0
2 1 3 3 3 1 2 0
2 1 3 0 3 1 2 0
2 1 3 3 3 1 2 0
2 1 1 1 1 1 2 0
2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 2 1 1 1 0 0
0 1 1 1 3 1 2 0
2 1 3 3 3 1 2 0
2 1 3 3 3 1 2 0
2 1 3 3 3 1 2 0
0 1 1 1 1 1 0 0
0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 11
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 34.375
Okay, the metrics confirm the assessment.

**General Assessment and Strategy**

The initial approach correctly identified the core task: finding closed blue loops, filling their interiors green, and bordering their exteriors red. However, the implementation failed on three out of four examples, primarily by missing most of the required red border pixels and occasionally misidentifying interior/exterior areas, leading to incorrect green fills. Example 2 passed because the blue shape was *not* a closed loop, and the correct behavior was to do nothing.

The key errors revealed by the metrics are:
*   **Missing Red Pixels:** The vast majority of errors involve failing to place red (2) pixels where they belong (26 missing in Ex1, 30 in Ex3, 10 in Ex4). The code is not correctly identifying all the exterior white pixels adjacent to the loop boundaries.
*   **Incorrect Green Pixels:** A smaller number of errors involve placing green (3) where it shouldn't be (6 in Ex1, 2 in Ex3, 1 in Ex4). This suggests the identification of "interior" regions is sometimes flawed, perhaps capturing small areas that aren't truly enclosed or misclassifying parts of the exterior.
*   **No Incorrect Red Pixels:** The code never placed red pixels where they didn't belong, indicating the *condition* for placing red (adjacency to blue) was correct, but the *target identification* (finding the *right* adjacent white pixels) was wrong.

**Strategy:**

The strategy needs refinement in how "interior" and "exterior" white regions are defined and identified relative to the blue shapes.

1.  **Define Exterior Rigorously:** The "exterior" should encompass *all* white (0) pixels reachable from any point on the grid's outer boundary (top, bottom, left, right edges) *without* crossing a blue (1) pixel. A single Flood Fill/BFS starting from all boundary white cells simultaneously will identify this entire connected exterior region.
2.  **Define Interior:** Any white (0) pixel *not* part of the identified exterior region is, by definition, "interior" to *some* blue loop.
3.  **Process Interior Regions:**
    *   Find all connected components of these interior white pixels. Each component represents the inside of a closed loop.
    *   For each interior component:
        *   Fill all pixels within the component with green (3).
        *   Identify the set of blue (1) pixels immediately adjacent (orthogonally) to this green-filled region. This is the specific blue loop boundary for this interior region.
        *   Identify the set of *exterior* white pixels (found in step 1) that are immediately adjacent (orthogonally) to this *specific* blue loop boundary.
        *   Fill these adjacent *exterior* white pixels with red (2).
4.  **Handle Non-Loops:** Blue shapes that do not enclose any interior white regions will not trigger steps 3.i, 3.ii, or 3.iii, and will therefore remain unchanged, as will the white space around them (unless that white space is adjacent to a *different*, closed loop).

This revised strategy ensures that the red border is only applied to white pixels confirmed to be part of the main exterior region and are adjacent to a blue pixel that forms part of a confirmed closed loop. It also correctly handles multiple loops and non-looping shapes.

**Metrics Summary**

| Example | Passed | Pixels Off | Missing Red (2) | Incorrect Red (2) | Missing Green (3) | Incorrect Green (3) | Other Differences |
| :------ | :----- | :--------- | :-------------- | :---------------- | :---------------- | :------------------ | :---------------- |
| 1       | False  | 32         | 26              | 0                 | 0                 | 6                   | 0                 |
| 2       | True   | 0          | 0               | 0                 | 0                 | 0                   | 0                 |
| 3       | False  | 32         | 30              | 0                 | 0                 | 2                   | 0                 |
| 4       | False  | 11         | 10              | 0                 | 0                 | 1                   | 0                 |

**YAML Facts**


```yaml
task_description: "Identify closed loops formed by blue pixels. Fill the enclosed regions with green and border the loops externally with red on adjacent exterior white pixels."
elements:
  - element: "grid"
    properties:
      - "height"
      - "width"
      - "boundary (edges)"
  - element: "background"
    color_name: "white"
    color_value: 0
    properties:
      - "can be exterior or interior"
  - element: "shape_outline"
    color_name: "blue"
    color_value: 1
    properties:
      - "forms contiguous shapes"
      - "can enclose white regions (form loops)"
      - "can be open structures"
  - element: "outer_border"
    color_name: "red"
    color_value: 2
    properties:
      - "replaces exterior white pixels"
      - "must be orthogonally adjacent to a blue pixel that is part of a closed loop boundary"
      - "is one pixel thick"
  - element: "inner_fill"
    color_name: "green"
    color_value: 3
    properties:
      - "replaces interior white pixels"
      - "fills the entire region enclosed by a blue loop"
regions:
  - region_type: "exterior_white"
    definition: "All white pixels connected to the grid boundary without crossing blue pixels."
    identification: "BFS/Flood fill starting from all boundary white pixels."
  - region_type: "interior_white"
    definition: "Any white pixel not belonging to the exterior_white region."
    properties:
      - "May consist of multiple disconnected components."
      - "Each component is enclosed by a blue loop."
actions:
  - action: "identify_exterior_white"
    input: "input grid"
    target: "white (0) pixels"
    method: "BFS/Flood fill starting from all grid boundary white pixels."
    output: "Set of coordinates for all exterior white pixels."
  - action: "identify_interior_white_regions"
    input: "input grid, set of exterior white pixels"
    target: "white (0) pixels not in the exterior set"
    method: "Find connected components (BFS/DFS) of the remaining white pixels."
    output: "List of sets, where each set contains coordinates for one interior white region."
  - action: "process_interior_region"
    input: "interior white region (set of coordinates), input grid, exterior white pixel set, output grid"
    steps:
      - "1. Fill: Change color of all pixels in the interior region to green (3) in the output grid."
      - "2. Find Boundary: Identify blue (1) pixels in the input grid orthogonally adjacent to any pixel in the (now green) interior region."
      - "3. Find Border Target: Identify exterior white pixels (from exterior set) orthogonally adjacent to any blue pixel found in step 2."
      - "4. Apply Border: Change color of target exterior white pixels (from step 3) to red (2) in the output grid."
relationships:
  - relationship: "spatial_adjacency"
    between: ["red pixels", "blue loop boundary pixels"]
    condition: "red pixel must be an exterior white pixel"
  - relationship: "spatial_adjacency"
    between: ["green pixels", "blue loop boundary pixels"]
    condition: "green pixel must be an interior white pixel"
  - relationship: "containment"
    region: "interior_white region"
    boundary: "specific blue loop"
  - relationship: "connectivity"
    region: "exterior_white region"
    connects_to: "grid boundary"
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the output grid.
2.  Identify the "exterior" white region: Perform a breadth-first search (BFS) or flood fill starting simultaneously from all white (0) pixels located on the grid's outer border (top, bottom, left, right edges). Mark all reachable white pixels as belonging to the exterior region. Store the coordinates of these exterior white pixels.
3.  Identify all "interior" white regions:
    a.  Iterate through every pixel of the grid.
    b.  If a white (0) pixel is found that has *not* been marked as exterior:
        i.  Start a new BFS/flood fill from this pixel, exploring only adjacent white pixels that are also not marked as exterior.
        ii. All white pixels reached by this fill constitute one distinct interior region. Store the coordinates of this region.
        iii. Mark all pixels in this newly found interior region to avoid processing them again.
    c.  Repeat until all pixels have been checked. This results in a list of disjoint interior white regions.
4.  Process each identified interior white region:
    a.  Initialize an empty set to store the coordinates of the blue (1) pixels forming the boundary of the current interior region.
    b.  For each pixel coordinate `(r, c)` within the current interior region:
        i.  Change the color of the pixel at `(r, c)` in the *output grid* to green (3).
        ii. Check all orthogonal neighbors `(nr, nc)` of `(r, c)`. If a neighbor contains a blue (1) pixel in the *input grid*, add the coordinate `(nr, nc)` to the boundary set for this region.
    c.  Initialize an empty set to store the coordinates of the exterior white pixels that need to be turned red for this specific loop.
    d.  For each blue boundary pixel coordinate `(br, bc)` identified in step 4b:
        i.  Check all orthogonal neighbors `(nr, nc)` of `(br, bc)`.
        ii. If a neighbor `(nr, nc)` exists in the set of *exterior* white pixel coordinates (identified in step 2), add `(nr, nc)` to the red border target set.
    e.  For each pixel coordinate `(rr, rc)` in the red border target set:
        i.  Change the color of the pixel at `(rr, rc)` in the *output grid* to red (2).
5.  Return the final modified output grid.**General Assessment and Strategy**

The initial code successfully processed Example 2 (no closed loop), but failed on Examples 1, 3, and 4, which contain closed loops. The primary failure mode, confirmed by the metrics, was the insufficient placement of red (2) border pixels on the exterior of the loops. There were also minor errors where green (3) was incorrectly placed, suggesting issues in distinguishing truly enclosed ("interior") white areas from the main "exterior" white area.

The strategy needs to more robustly differentiate between the single, connected "exterior" white region (reachable from the grid boundary) and potentially multiple, disconnected "interior" white regions (enclosed by blue loops). The red border should *only* be applied to pixels belonging to the identified "exterior" region that are adjacent to the blue loop boundary.

**Revised Strategy:**

1.  **Identify Exterior White:** Use a flood fill (BFS) starting from all white pixels on the grid edges to find all connected white pixels reachable from the outside. Mark these as 'exterior'.
2.  **Identify Interior White Regions:** Find all connected components of white pixels *not* marked as 'exterior'. Each component is an 'interior' region.
3.  **Process Each Interior Region:**
    *   Fill the interior region pixels with green (3).
    *   Identify the blue (1) pixels directly adjacent to this green region; these form the loop's boundary.
    *   Identify the 'exterior' white pixels (from step 1) directly adjacent to these boundary blue pixels.
    *   Color these adjacent 'exterior' white pixels red (2).
4.  Leave non-looping blue shapes and non-adjacent exterior white pixels unchanged.

**Metrics Summary**

| Example | Passed | Pixels Off | Missing Red (2) | Incorrect Red (2) | Missing Green (3) | Incorrect Green (3) | Other Differences |
| :------ | :----- | :--------- | :-------------- | :---------------- | :---------------- | :------------------ | :---------------- |
| 1       | False  | 32         | 26              | 0                 | 0                 | 6                   | 0                 |
| 2       | True   | 0          | 0               | 0                 | 0                 | 0                   | 0                 |
| 3       | False  | 32         | 30              | 0                 | 0                 | 2                   | 0                 |
| 4       | False  | 11         | 10              | 0                 | 0                 | 1                   | 0                 |

*Analysis:* The metrics clearly show the algorithm failed to identify the correct exterior white pixels for placing the red border (large number of 'Missing Red'). The 'Incorrect Green' errors indicate that the initial method sometimes misclassified parts of the exterior as interior.

**YAML Facts**


```yaml
task_description: "Identify closed loops formed by blue pixels. Fill the enclosed white regions with green and border the loops externally by coloring adjacent exterior white pixels red."
elements:
  - element: "grid"
    properties:
      - "height"
      - "width"
      - "boundary (edges)"
  - element: "pixel_colors"
    values:
      - color_name: "white"
        value: 0
        role: "background (exterior or interior)"
      - color_name: "blue"
        value: 1
        role: "shape_outline"
      - color_name: "red"
        value: 2
        role: "outer_border"
      - color_name: "green"
        value: 3
        role: "inner_fill"
objects:
  - object: "blue_shape"
    composed_of: "connected blue (1) pixels"
    properties:
      - "can be open or closed (loop)"
  - object: "exterior_white_region"
    composed_of: "connected white (0) pixels"
    properties:
      - "connected to the grid boundary"
      - "unique (usually only one, unless fully partitioned by blue)"
  - object: "interior_white_region"
    composed_of: "connected white (0) pixels"
    properties:
      - "not connected to the grid boundary"
      - "fully enclosed by a blue_shape loop"
      - "can be multiple distinct regions per grid"
actions:
  - action: "identify_exterior"
    input: "input grid"
    target: "white (0) pixels"
    method: "Flood fill (e.g., BFS) starting from all boundary white pixels."
    output: "Set of coordinates for the exterior_white_region."
  - action: "identify_interiors"
    input: "input grid, exterior_white_region coordinates"
    target: "white (0) pixels not in exterior_white_region"
    method: "Find connected components (e.g., BFS) of the remaining white pixels."
    output: "List of sets, each set contains coordinates for one interior_white_region."
  - action: "apply_fill_and_border"
    input: "interior_white_region coordinates, exterior_white_region coordinates, input grid"
    output_effect: "Modifies the output grid"
    steps:
      - "1. Fill Interior: Change all pixels in the interior_white_region to green (3)."
      - "2. Find Blue Boundary: Identify blue (1) pixels adjacent to the green (3) region."
      - "3. Find Red Border Target: Identify pixels from exterior_white_region adjacent to the blue boundary pixels found in step 2."
      - "4. Apply Border: Change the target red border pixels to red (2)."
relationships:
  - relationship: "spatial"
    type: "adjacency (orthogonal)"
    between: ["exterior_white_region", "blue_shape boundary (for closed loops)"]
    result: "defines placement for red (2) pixels"
  - relationship: "spatial"
    type: "enclosure"
    container: "blue_shape (closed loop)"
    contained: "interior_white_region"
    result: "defines placement for green (3) pixels"
  - relationship: "topology"
    type: "connectivity"
    element: "exterior_white_region"
    connects_to: "grid boundary"
  - relationship: "topology"
    type: "separation"
    element: "interior_white_region"
    separated_from: "grid boundary"
    by: "blue_shape (closed loop)"
```


**Natural Language Program**

1.  Initialize an output grid as a copy of the input grid.
2.  Create a boolean grid `is_exterior` of the same dimensions, initialized to `False`.
3.  Create a queue and add the coordinates of all white (0) pixels located on the input grid's outer boundary (rows 0 and H-1, columns 0 and W-1). Mark these coordinates as `True` in `is_exterior`.
4.  While the queue is not empty:
    a.  Dequeue a coordinate `(r, c)`.
    b.  For each orthogonal neighbor `(nr, nc)`:
        i.  If the neighbor is within grid bounds, is white (0) in the input grid, and `is_exterior[nr, nc]` is `False`:
            *   Mark `is_exterior[nr, nc]` as `True`.
            *   Enqueue `(nr, nc)`.
5.  Create a boolean grid `visited_interior` of the same dimensions, initialized to `False`.
6.  Iterate through all pixels `(r, c)` of the grid:
    a.  If the pixel `(r, c)` is white (0) in the input grid, `is_exterior[r, c]` is `False`, and `visited_interior[r, c]` is `False`:
        i.   This pixel belongs to a new interior region. Start a flood fill (BFS) from `(r, c)`:
            *   Initialize `current_interior_region = set()` and `blue_boundary = set()`.
            *   Create a queue for this fill, add `(r, c)`. Mark `visited_interior[r, c]` as `True`.
            *   While the interior fill queue is not empty:
                *   Dequeue `(ir, ic)`. Add `(ir, ic)` to `current_interior_region`.
                *   Change `output_grid[ir, ic]` to green (3).
                *   For each orthogonal neighbor `(nir, nic)` of `(ir, ic)`:
                    *   If the neighbor is within bounds:
                        *   If it's blue (1) in the input grid, add `(nir, nic)` to `blue_boundary`.
                        *   If it's white (0), `is_exterior[nir, nic]` is `False`, and `visited_interior[nir, nic]` is `False`:
                            *   Mark `visited_interior[nir, nic]` as `True`.
                            *   Enqueue `(nir, nic)`.
        ii.  Identify the red border locations for this loop:
            *   Initialize `red_border_locations = set()`.
            *   For each blue pixel `(br, bc)` in `blue_boundary`:
                *   For each orthogonal neighbor `(nr, nc)` of `(br, bc)`:
                    *   If the neighbor `(nr, nc)` is within bounds and `is_exterior[nr, nc]` is `True`:
                        *   Add `(nr, nc)` to `red_border_locations`.
        iii. Apply the red border: For each pixel `(rr, rc)` in `red_border_locations`, change `output_grid[rr, rc]` to red (2).
7.  Return the final `output_grid`.
