
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 3 3 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 3 3 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 3 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 4 1 1 1 1 2 0 1 1 1 1 1 1 1 1 1 1
1 1 4 4 0 0 0 0 0 0 2 2 1 1 1 1 1 1 1 1 1
1 1 4 4 1 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 4 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 0 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 8 7 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 3 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 0 6 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 6 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 8 8 8 7 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 0 2 0 7 0 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 8 7 7 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 3 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 0 3 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 0 0 0 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 1 2 2 2 3 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 1 1 0 0 0 3 3 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 9 9 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 9 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 8 2 2 2 2 2 9 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 0 0 0 0 0 9 9 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 3 3 0 0 0 0 0 8 8 2 2 2 2 2 2 2 2 2
2 2 2 2 3 2 2 2 2 2 8 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Background Color:** Each example seems to have a dominant background color (blue in train_1, azure in train_2, red in train_3). This color remains largely unchanged in the output, except for specific modifications.
2.  **White Regions:** There are distinct areas or shapes composed of white (0) pixels scattered within the background. These white regions themselves appear unchanged between input and output.
3.  **Trigger Pixels:** Inside or immediately adjacent to these white regions, there are single pixels of various other colors (non-white, non-background). Examples include green, yellow, red in train_1; blue, yellow, magenta, green, red, orange in train_2; blue, green, yellow, maroon, azure in train_3.
4.  **Transformation:** The core transformation involves changing the color of *background* pixels that are directly adjacent (up, down, left, right) to these "trigger" pixels. The background pixels take on the color of the adjacent trigger pixel.
5.  **Condition for Transformation:** The trigger pixel must be adjacent (cardinally) to at least one white (0) pixel for the transformation to occur on its neighboring background pixels.
6.  **Result:** This process often effectively expands the single trigger pixel into a 2x2 block, where the original trigger pixel and its newly colored background neighbors form the block. If a trigger pixel has multiple background neighbors, they all change color.

**YAML Facts:**


```yaml
elements:
  - role: background
    property: dominant color in the grid (e.g., blue, azure, red)
    persistence: remains mostly constant, except for targeted changes
  - role: region
    property: contiguous area of white (0) pixels
    persistence: shape and location are preserved in the output
  - role: trigger_pixel
    property:
      - color is not white (0)
      - color is not the background color
      - is cardinally adjacent to at least one white (0) pixel
    location: typically found inside or bordering the white regions
    action: causes adjacent background pixels to change color
  - role: target_pixel
    property:
      - color is the background color
      - is cardinally adjacent to a trigger_pixel
    action: color changes to match the adjacent trigger_pixel's color

relationships:
  - type: adjacency
    from: trigger_pixel
    to: white (0) pixel
    direction: cardinal (N, S, E, W)
    relevance: condition for the trigger_pixel to activate the transformation
  - type: adjacency
    from: trigger_pixel
    to: target_pixel (background color)
    direction: cardinal (N, S, E, W)
    relevance: defines which pixels will be transformed
```


**Natural Language Program:**

1.  Identify the primary background color of the input grid (the most frequent color).
2.  Create a new grid, initially identical to the input grid. This will be the output grid.
3.  Iterate through every pixel `P` in the input grid at position `(row, col)`.
4.  Let `C` be the color of pixel `P`.
5.  Check if color `C` is *not* white (0) and *not* the background color.
6.  If `C` meets this condition, then check if pixel `P` is cardinally adjacent (up, down, left, or right) to at least one white (0) pixel in the input grid.
7.  If pixel `P` has color `C` (potential trigger) and is adjacent to a white pixel, then examine the cardinal neighbors of `P` again.
8.  For each cardinal neighbor `N` of `P` at position `(neighbor_row, neighbor_col)`:
    *   Check if the color of neighbor `N` in the *input* grid is the background color.
    *   If it is, change the color of the pixel at `(neighbor_row, neighbor_col)` in the *output* grid to color `C`.
9.  After checking all pixels `P` in the input grid, the final state of the output grid represents the result.
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1. Identify the background color (the most frequent color in the grid).
2. Iterate through each pixel in the input grid.
3. If a pixel's color is neither white (0) nor the background color (let's call this a 'trigger pixel'), check if it is cardinally adjacent (up, down, left, right) to at least one white pixel.
4. If a trigger pixel is adjacent to a white pixel, then find all of its cardinal neighbors that have the background color.
5. Change the color of these background-colored neighbors in the output grid to match the color of the trigger pixel.
6. Pixels that are not modified retain their original color from the input grid.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Flatten the grid and count color occurrences
    colors, counts = np.unique(grid, return_counts=True)
    # Find the index of the maximum count
    max_count_index = np.argmax(counts)
    # Return the color with the maximum count
    return colors[max_count_index]

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Identifies 'trigger pixels' (non-white, non-background colors adjacent to white)
    and colors their adjacent background pixels with the trigger pixel's color.
    """
    # Convert input list of lists to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    # Create a copy to modify, which will become the output grid
    output_array = np.copy(input_array)
    
    # Get grid dimensions
    height, width = input_array.shape
    
    # Determine the background color
    background_color = find_background_color(input_array)

    # Define cardinal directions (row_change, col_change)
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up

    # Iterate through each pixel of the input grid
    for r in range(height):
        for c in range(width):
            current_color = input_array[r, c]

            # Check if the current pixel is a potential trigger pixel
            # (i.e., not white and not the background color)
            if current_color != 0 and current_color != background_color:
                
                is_adjacent_to_white = False
                # Check cardinal neighbors for white pixels
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    # Check boundary conditions
                    if 0 <= nr < height and 0 <= nc < width:
                        # If a white neighbor is found, mark it and stop checking neighbors
                        if input_array[nr, nc] == 0:
                            is_adjacent_to_white = True
                            break 
                
                # If the trigger pixel condition (adjacent to white) is met
                if is_adjacent_to_white:
                    # Check cardinal neighbors again to find background pixels to color
                    for dr, dc in directions:
                        nr, nc = r + dr, c + dc
                        # Check boundary conditions
                        if 0 <= nr < height and 0 <= nc < width:
                            # If the neighbor has the background color in the *original* grid
                            if input_array[nr, nc] == background_color:
                                # Change this neighbor's color in the *output* grid
                                output_array[nr, nc] = current_color

    # Convert the final NumPy array back to a list of lists
    return output_array.tolist()
```
