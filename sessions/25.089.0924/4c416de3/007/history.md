
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 3 3 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 3 3 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 3 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 4 1 1 1 1 2 0 1 1 1 1 1 1 1 1 1 1
1 1 4 4 0 0 0 0 0 0 2 2 1 1 1 1 1 1 1 1 1
1 1 4 4 1 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 4 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 0 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 8 7 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 3 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 0 6 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 6 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 8 8 8 7 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 0 2 0 7 0 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 8 7 7 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 3 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 0 3 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 0 0 0 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 1 2 2 2 3 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 1 1 0 0 0 3 3 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 9 9 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 9 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 8 2 2 2 2 2 9 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 0 0 0 0 0 9 9 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 3 3 0 0 0 0 0 8 8 2 2 2 2 2 2 2 2 2
2 2 2 2 3 2 2 2 2 2 8 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Background Color:** Each example seems to have a dominant background color (blue in train_1, azure in train_2, red in train_3). This color remains largely unchanged in the output, except for specific modifications.
2.  **White Regions:** There are distinct areas or shapes composed of white (0) pixels scattered within the background. These white regions themselves appear unchanged between input and output.
3.  **Trigger Pixels:** Inside or immediately adjacent to these white regions, there are single pixels of various other colors (non-white, non-background). Examples include green, yellow, red in train_1; blue, yellow, magenta, green, red, orange in train_2; blue, green, yellow, maroon, azure in train_3.
4.  **Transformation:** The core transformation involves changing the color of *background* pixels that are directly adjacent (up, down, left, right) to these "trigger" pixels. The background pixels take on the color of the adjacent trigger pixel.
5.  **Condition for Transformation:** The trigger pixel must be adjacent (cardinally) to at least one white (0) pixel for the transformation to occur on its neighboring background pixels.
6.  **Result:** This process often effectively expands the single trigger pixel into a 2x2 block, where the original trigger pixel and its newly colored background neighbors form the block. If a trigger pixel has multiple background neighbors, they all change color.

**YAML Facts:**


```yaml
elements:
  - role: background
    property: dominant color in the grid (e.g., blue, azure, red)
    persistence: remains mostly constant, except for targeted changes
  - role: region
    property: contiguous area of white (0) pixels
    persistence: shape and location are preserved in the output
  - role: trigger_pixel
    property:
      - color is not white (0)
      - color is not the background color
      - is cardinally adjacent to at least one white (0) pixel
    location: typically found inside or bordering the white regions
    action: causes adjacent background pixels to change color
  - role: target_pixel
    property:
      - color is the background color
      - is cardinally adjacent to a trigger_pixel
    action: color changes to match the adjacent trigger_pixel's color

relationships:
  - type: adjacency
    from: trigger_pixel
    to: white (0) pixel
    direction: cardinal (N, S, E, W)
    relevance: condition for the trigger_pixel to activate the transformation
  - type: adjacency
    from: trigger_pixel
    to: target_pixel (background color)
    direction: cardinal (N, S, E, W)
    relevance: defines which pixels will be transformed
```


**Natural Language Program:**

1.  Identify the primary background color of the input grid (the most frequent color).
2.  Create a new grid, initially identical to the input grid. This will be the output grid.
3.  Iterate through every pixel `P` in the input grid at position `(row, col)`.
4.  Let `C` be the color of pixel `P`.
5.  Check if color `C` is *not* white (0) and *not* the background color.
6.  If `C` meets this condition, then check if pixel `P` is cardinally adjacent (up, down, left, or right) to at least one white (0) pixel in the input grid.
7.  If pixel `P` has color `C` (potential trigger) and is adjacent to a white pixel, then examine the cardinal neighbors of `P` again.
8.  For each cardinal neighbor `N` of `P` at position `(neighbor_row, neighbor_col)`:
    *   Check if the color of neighbor `N` in the *input* grid is the background color.
    *   If it is, change the color of the pixel at `(neighbor_row, neighbor_col)` in the *output* grid to color `C`.
9.  After checking all pixels `P` in the input grid, the final state of the output grid represents the result.
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1. Identify the background color (the most frequent color in the grid).
2. Iterate through each pixel in the input grid.
3. If a pixel's color is neither white (0) nor the background color (let's call this a 'trigger pixel'), check if it is cardinally adjacent (up, down, left, right) to at least one white pixel.
4. If a trigger pixel is adjacent to a white pixel, then find all of its cardinal neighbors that have the background color.
5. Change the color of these background-colored neighbors in the output grid to match the color of the trigger pixel.
6. Pixels that are not modified retain their original color from the input grid.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Flatten the grid and count color occurrences
    colors, counts = np.unique(grid, return_counts=True)
    # Find the index of the maximum count
    max_count_index = np.argmax(counts)
    # Return the color with the maximum count
    return colors[max_count_index]

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Identifies 'trigger pixels' (non-white, non-background colors adjacent to white)
    and colors their adjacent background pixels with the trigger pixel's color.
    """
    # Convert input list of lists to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    # Create a copy to modify, which will become the output grid
    output_array = np.copy(input_array)
    
    # Get grid dimensions
    height, width = input_array.shape
    
    # Determine the background color
    background_color = find_background_color(input_array)

    # Define cardinal directions (row_change, col_change)
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up

    # Iterate through each pixel of the input grid
    for r in range(height):
        for c in range(width):
            current_color = input_array[r, c]

            # Check if the current pixel is a potential trigger pixel
            # (i.e., not white and not the background color)
            if current_color != 0 and current_color != background_color:
                
                is_adjacent_to_white = False
                # Check cardinal neighbors for white pixels
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    # Check boundary conditions
                    if 0 <= nr < height and 0 <= nc < width:
                        # If a white neighbor is found, mark it and stop checking neighbors
                        if input_array[nr, nc] == 0:
                            is_adjacent_to_white = True
                            break 
                
                # If the trigger pixel condition (adjacent to white) is met
                if is_adjacent_to_white:
                    # Check cardinal neighbors again to find background pixels to color
                    for dr, dc in directions:
                        nr, nc = r + dr, c + dc
                        # Check boundary conditions
                        if 0 <= nr < height and 0 <= nc < width:
                            # If the neighbor has the background color in the *original* grid
                            if input_array[nr, nc] == background_color:
                                # Change this neighbor's color in the *output* grid
                                output_array[nr, nc] = current_color

    # Convert the final NumPy array back to a list of lists
    return output_array.tolist()
```
```python
import numpy as np
from collections import Counter
import math
from scipy.ndimage import label

"""
Transformation Rule (v3.1):

1. Identify the background color (BGC) as the most frequent color.
2. Find all distinct contiguous regions of white (0) pixels.
3. For each white region:
    a. Determine its bounding box (r_min, c_min) to (r_max, c_max).
    b. Identify the four potential corner background pixels located diagonally outside the bounding box: 
       TL=(r_min-1, c_min-1), TR=(r_min-1, c_max+1), BL=(r_max+1, c_min-1), BR=(r_max+1, c_max+1). 
       Validate that these corners are within grid bounds and have the BGC.
    c. Find all 'color pixels' (non-BGC, non-white) associated with this region. A color pixel is associated if it's within the bounding box OR cardinally adjacent to any white pixel of this region.
    d. Assign a color to each valid corner pixel based on proximity: For each color pixel, calculate its Euclidean distance to each valid corner pixel. The color of the *closest* color pixel is assigned to the corner. Ties are implicitly broken by processing order (last closest pixel wins).
    e. For each corner that received a color assignment, paint a specific 2x2 block in the output grid with that color. The top-left coordinate of the 2x2 block depends on the corner type:
        - TL corner (cr, cc) -> paint block starting at (cr, cc+1)
        - TR corner (cr, cc) -> paint block starting at (cr, cc-1)
        - BL corner (cr, cc) -> paint block starting at (cr-1, cc+1)
        - BR corner (cr, cc) -> paint block starting at (cr-1, cc-1)
4. Pixels not part of these 2x2 blocks retain their original color.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid, ignoring white (0) if possible."""
    colors, counts = np.unique(grid, return_counts=True)
    non_white_indices = np.where(colors != 0)[0]
    
    if len(non_white_indices) > 0:
        # Find the most frequent non-white color
        max_count_idx_non_white = non_white_indices[np.argmax(counts[non_white_indices])]
        return colors[max_count_idx_non_white]
    else:
        # If only white exists, return white (or handle as error/edge case)
        # For robustness, return the most frequent overall if no non-white
        return colors[np.argmax(counts)]


def get_bounding_box(coords):
    """Calculates the bounding box for a list of (row, col) coordinates."""
    if not coords:
        return None
    rows, cols = zip(*coords)
    return min(rows), min(cols), max(rows), max(cols)

def euclidean_distance(p1, p2):
    """Calculates Euclidean distance between two points (r1, c1) and (r2, c2)."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def get_region_pixels(grid, region_coords_set):
    """Finds color pixels associated with a white region."""
    height, width = grid.shape
    bbox = get_bounding_box(list(region_coords_set))
    if bbox is None:
        return []
    
    r_min, c_min, r_max, c_max = bbox
    associated_pixels = []
    processed_coords = set() # Avoid duplicates if inside bbox AND adjacent

    # Check inside bounding box
    for r in range(r_min, r_max + 1):
        for c in range(c_min, c_max + 1):
             # Ensure coords are valid before checking grid value
            if 0 <= r < height and 0 <= c < width:
                color = grid[r, c]
                # Check if it's a color pixel (not white, not background - handled later)
                if color != 0:
                    coord = (r, c)
                    if coord not in processed_coords:
                         associated_pixels.append((coord, color))
                         processed_coords.add(coord)


    # Check adjacency to white pixels in the region
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # R, L, D, U
    for wr, wc in region_coords_set:
        for dr, dc in directions:
            nr, nc = wr + dr, wc + dc
            if 0 <= nr < height and 0 <= nc < width:
                color = grid[nr, nc]
                # Check if it's a color pixel
                if color != 0:
                    coord = (nr, nc)
                    if coord not in processed_coords:
                        associated_pixels.append((coord, color))
                        processed_coords.add(coord)
                        
    return associated_pixels


def transform(input_grid):
    """
    Applies the transformation rule based on white regions, corners, 
    and closest color pixels.
    """
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array)
    height, width = input_array.shape

    # 1. Identify background color
    bgc = find_background_color(input_array)

    # 2. Find white regions
    white_mask = (input_array == 0)
    labeled_array, num_labels = label(white_mask)

    # 3. Process each white region
    for i in range(1, num_labels + 1):
        region_coords = list(zip(*np.where(labeled_array == i)))
        if not region_coords:
            continue
            
        region_coords_set = set(region_coords)

        # a. Calculate bounding box
        bbox = get_bounding_box(region_coords)
        if bbox is None: continue
        r_min, c_min, r_max, c_max = bbox

        # b. Identify valid corner background pixels
        potential_corners = {
            "TL": (r_min - 1, c_min - 1),
            "TR": (r_min - 1, c_max + 1),
            "BL": (r_max + 1, c_min - 1),
            "BR": (r_max + 1, c_max + 1)
        }
        valid_corners = {}
        for name, (cr, cc) in potential_corners.items():
            if 0 <= cr < height and 0 <= cc < width and input_array[cr, cc] == bgc:
                valid_corners[name] = (cr, cc)

        if not valid_corners: # Skip region if no valid corners
             continue

        # c. Find associated color pixels (filtering out BGC here)
        all_associated = get_region_pixels(input_array, region_coords_set)
        color_pixels = [p for p in all_associated if p[1] != bgc]
        
        if not color_pixels: # Skip region if no associated color pixels
            continue

        # d. Assign colors to corners based on distance
        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_corners}
        for (pr, pc), color in color_pixels:
            pixel_coord = (pr, pc)
            for name, corner_coord in valid_corners.items():
                d = euclidean_distance(pixel_coord, corner_coord)
                if d < assignments[name]['dist']:
                    assignments[name]['dist'] = d
                    assignments[name]['color'] = color
                # Implicit tie-breaking: last pixel processed with equal min distance wins

        # e. Paint 2x2 blocks
        for name, corner_coord in valid_corners.items():
            assigned_color = assignments[name]['color']
            if assigned_color is not None:
                cr, cc = corner_coord
                start_r, start_c = -1, -1 # Initialize invalid start coords

                if name == "TL":
                    start_r, start_c = cr, cc + 1
                elif name == "TR":
                    start_r, start_c = cr, cc - 1
                elif name == "BL":
                    start_r, start_c = cr - 1, cc + 1
                elif name == "BR":
                    start_r, start_c = cr - 1, cc - 1

                # Paint the 2x2 block if start coords are valid
                if start_r != -1:
                    for r_offset in range(2):
                        for c_offset in range(2):
                            paint_r, paint_c = start_r + r_offset, start_c + c_offset
                            # Check bounds before painting
                            if 0 <= paint_r < height and 0 <= paint_c < width:
                                output_array[paint_r, paint_c] = assigned_color

    return output_array.tolist()
```
```python
import numpy as np
import math
from scipy.ndimage import label
from collections import Counter

"""
Transformation Rule:

1. Identify the background color (BGC) as the most frequent color in the grid, 
   preferring non-white colors if multiple have the same max frequency.
2. Find all distinct contiguous regions of white (0) pixels using connected components labeling.
3. For each white region:
    a. Determine its bounding box (minimum and maximum row and column indices: r_min, c_min, r_max, c_max).
    b. Identify the four potential 'corner anchor' pixels located diagonally outside the bounding box:
       - Top-Left (TL): (r_min - 1, c_min - 1)
       - Top-Right (TR): (r_min - 1, c_max + 1)
       - Bottom-Left (BL): (r_max + 1, c_min - 1)
       - Bottom-Right (BR): (r_max + 1, c_max + 1)
    c. Validate these corner anchors: They must be within the grid boundaries and have the background color (BGC). Keep track of valid anchors.
    d. Find all 'color pixels' associated with the current white region. A color pixel is associated if:
       - It is not white (0) and not the BGC.
       - It is either located within the bounding box of the white region OR is cardinally adjacent (up, down, left, right) to any white pixel belonging to the region.
    e. Assign a color to each valid corner anchor based on proximity to the associated color pixels:
       - For each associated color pixel, calculate its Euclidean distance to each valid corner anchor.
       - For each corner anchor, determine which associated color pixel is closest to it.
       - Assign the color of this closest color pixel to the corner anchor. Ties are broken by the order in which color pixels are processed (the last closest pixel encountered determines the color).
    f. For each corner anchor that received a color assignment, paint a 2x2 block in the output grid using that assigned color. The top-left coordinate of the 2x2 block depends on the corner anchor type:
        - TL anchor at (ar, ac) paints block starting at (ar, ac + 1)
        - TR anchor at (ar, ac) paints block starting at (ar, ac - 1)
        - BL anchor at (ar, ac) paints block starting at (ar - 1, ac + 1)
        - BR anchor at (ar, ac) paints block starting at (ar - 1, ac - 1)
       Ensure the painting stays within grid bounds.
4. Initialize the output grid as a copy of the input grid. The painting of 2x2 blocks modifies this copy. Pixels not part of these painted blocks retain their original color.
"""

# === Helper Functions ===

def find_background_color(grid: np.ndarray) -> int:
    """
    Finds the most frequent color in the grid.
    Prefers non-white if counts are equal.
    """
    colors, counts = np.unique(grid, return_counts=True)
    
    # If only one color exists, it's the background
    if len(colors) == 1:
        return colors[0]

    # Separate white and non-white counts
    white_count = 0
    non_white_colors = []
    non_white_counts = []
    for color, count in zip(colors, counts):
        if color == 0:
            white_count = count
        else:
            non_white_colors.append(color)
            non_white_counts.append(count)

    # Find the most frequent non-white color
    if non_white_counts:
        max_non_white_count = max(non_white_counts)
        most_frequent_non_white = [
            non_white_colors[i] for i, count in enumerate(non_white_counts) if count == max_non_white_count
        ]
        # If the most frequent non-white count is >= white count, return one of them (e.g., the first)
        if max_non_white_count >= white_count:
             # Return the smallest color value among most frequent non-white in case of ties
            return min(most_frequent_non_white)
        else:
            # White is strictly most frequent
            return 0
    else:
        # Only white exists
        return 0


def get_bounding_box(coords: list[tuple[int, int]]) -> tuple[int, int, int, int] | None:
    """Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates."""
    if not coords:
        return None
    rows, cols = zip(*coords)
    return min(rows), min(cols), max(rows), max(cols)

def euclidean_distance(p1: tuple[int, int], p2: tuple[int, int]) -> float:
    """Calculates Euclidean distance between two points (r1, c1) and (r2, c2)."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def get_associated_color_pixels(grid: np.ndarray, 
                                region_coords_set: set[tuple[int, int]], 
                                bbox: tuple[int, int, int, int], 
                                bgc: int) -> list[tuple[tuple[int, int], int]]:
    """
    Finds color pixels (non-white, non-BGC) associated with a white region.
    Association means within the bounding box or cardinally adjacent to the region's white pixels.
    """
    height, width = grid.shape
    r_min, c_min, r_max, c_max = bbox
    associated_pixels = []
    processed_coords = set()  # Avoid duplicates

    # 1. Check inside bounding box (inclusive)
    # Iterate using numpy slicing for potential efficiency if needed, but direct iteration is clearer here.
    for r in range(r_min, r_max + 1):
        for c in range(c_min, c_max + 1):
            coord = (r, c)
             # Ensure coord is valid (though bbox should guarantee this unless 1x1 region)
            if 0 <= r < height and 0 <= c < width:
                color = grid[r, c]
                # Check if it's a color pixel (not white, not BGC)
                if color != 0 and color != bgc:
                    if coord not in processed_coords:
                        associated_pixels.append((coord, color))
                        processed_coords.add(coord)

    # 2. Check cardinal adjacency to white pixels in the region
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # R, L, D, U
    for wr, wc in region_coords_set:
        for dr, dc in directions:
            nr, nc = wr + dr, wc + dc
            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                coord = (nr, nc)
                # Check if already processed (could be inside bbox too)
                if coord not in processed_coords:
                    color = grid[nr, nc]
                    # Check if it's a color pixel
                    if color != 0 and color != bgc:
                        associated_pixels.append((coord, color))
                        processed_coords.add(coord)
                        
    return associated_pixels

def paint_block(grid: np.ndarray, start_r: int, start_c: int, color: int):
    """Paints a 2x2 block starting at (start_r, start_c), checking bounds."""
    height, width = grid.shape
    for r_offset in range(2):
        for c_offset in range(2):
            paint_r, paint_c = start_r + r_offset, start_c + c_offset
            # Check bounds before painting
            if 0 <= paint_r < height and 0 <= paint_c < width:
                grid[paint_r, paint_c] = color


# === Main Transform Function ===

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule based on white regions, corner anchors, 
    and closest associated color pixels, painting 2x2 blocks.
    """
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array) # Initialize output grid
    height, width = input_array.shape

    # 1. Identify background color
    bgc = find_background_color(input_array)

    # 2. Find white regions using connected components labeling
    # structure defines connectivity (4-connectivity: cardinal directions)
    structure = np.array([[0,1,0], [1,1,1], [0,1,0]], dtype=bool) 
    white_mask = (input_array == 0)
    labeled_array, num_labels = label(white_mask, structure=structure)

    # 3. Process each distinct white region
    for i in range(1, num_labels + 1):
        # Get coordinates of all pixels in the current region
        region_coords = list(zip(*np.where(labeled_array == i)))
        if not region_coords:
            continue # Skip if region is empty (shouldn't happen with label)
            
        region_coords_set = set(region_coords)

        # a. Calculate bounding box
        bbox = get_bounding_box(region_coords)
        if bbox is None: continue # Should also not happen if region_coords not empty
        r_min, c_min, r_max, c_max = bbox

        # b. & c. Identify and validate corner anchor pixels
        potential_anchors = {
            "TL": (r_min - 1, c_min - 1),
            "TR": (r_min - 1, c_max + 1),
            "BL": (r_max + 1, c_min - 1),
            "BR": (r_max + 1, c_max + 1)
        }
        valid_anchors = {}
        for name, (ar, ac) in potential_anchors.items():
            # Check bounds and if the anchor pixel has the background color
            if 0 <= ar < height and 0 <= ac < width and input_array[ar, ac] == bgc:
                valid_anchors[name] = (ar, ac)

        # If no valid anchors found for this region, skip to the next region
        if not valid_anchors: 
             continue

        # d. Find associated color pixels (non-white, non-BGC) for this region
        color_pixels = get_associated_color_pixels(input_array, region_coords_set, bbox, bgc)
        
        # If no associated color pixels found, skip to the next region
        if not color_pixels: 
            continue

        # e. Assign colors to anchors based on closest color pixel
        # Initialize assignments with infinite distance and no color
        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_anchors}
        
        # Iterate through each associated color pixel
        for pixel_coord, color in color_pixels:
            # Compare its distance to each valid anchor
            for name, anchor_coord in valid_anchors.items():
                d = euclidean_distance(pixel_coord, anchor_coord)
                # If this pixel is closer than the current closest, update the assignment
                # Using '<=' implicitly handles ties by favoring the last processed pixel
                if d <= assignments[name]['dist']: 
                    assignments[name]['dist'] = d
                    assignments[name]['color'] = color

        # f. Paint 2x2 blocks based on assignments
        for name, anchor_coord in valid_anchors.items():
            assigned_color = assignments[name]['color']
            # Only paint if a color was actually assigned (dist wasn't infinity)
            if assigned_color is not None:
                ar, ac = anchor_coord
                start_r, start_c = -1, -1 # Initialize invalid start coords

                # Determine the top-left corner of the 2x2 block based on anchor type
                if name == "TL":
                    start_r, start_c = ar, ac + 1
                elif name == "TR":
                    start_r, start_c = ar, ac - 1
                elif name == "BL":
                    start_r, start_c = ar - 1, ac + 1
                elif name == "BR":
                    start_r, start_c = ar - 1, ac - 1

                # Paint the 2x2 block using the helper function (handles bounds)
                if start_r != -1: # Check if start coords were set
                    paint_block(output_array, start_r, start_c, assigned_color)

    # Convert the final NumPy array back to a list of lists
    return output_array.tolist()
```

Previous Code:
```python
import numpy as np
import math
from scipy.ndimage import label
from collections import Counter

"""
Transformation Rule:

1. Identify the background color (BGC) as the most frequent color in the grid, 
   preferring non-white colors if multiple have the same max frequency.
2. Find all distinct contiguous regions of white (0) pixels using connected components labeling.
3. For each white region:
    a. Determine its bounding box (minimum and maximum row and column indices: r_min, c_min, r_max, c_max).
    b. Identify the four potential 'corner anchor' pixels located diagonally outside the bounding box:
       - Top-Left (TL): (r_min - 1, c_min - 1)
       - Top-Right (TR): (r_min - 1, c_max + 1)
       - Bottom-Left (BL): (r_max + 1, c_min - 1)
       - Bottom-Right (BR): (r_max + 1, c_max + 1)
    c. Validate these corner anchors: They must be within the grid boundaries and have the background color (BGC). Keep track of valid anchors.
    d. Find all 'color pixels' associated with the current white region. A color pixel is associated if:
       - It is not white (0) and not the BGC.
       - It is either located within the bounding box of the white region OR is cardinally adjacent (up, down, left, right) to any white pixel belonging to the region.
    e. Assign a color to each valid corner anchor based on proximity to the associated color pixels:
       - For each associated color pixel, calculate its Euclidean distance to each valid corner anchor.
       - For each corner anchor, determine which associated color pixel is closest to it.
       - Assign the color of this closest color pixel to the corner anchor. Ties are broken by the order in which color pixels are processed (the last closest pixel encountered determines the color).
    f. For each corner anchor that received a color assignment, paint a 2x2 block in the output grid using that assigned color. The top-left coordinate of the 2x2 block depends on the corner anchor type:
        - TL anchor at (ar, ac) paints block starting at (ar, ac + 1)
        - TR anchor at (ar, ac) paints block starting at (ar, ac - 1)
        - BL anchor at (ar, ac) paints block starting at (ar - 1, ac + 1)
        - BR anchor at (ar, ac) paints block starting at (ar - 1, ac - 1)
       Ensure the painting stays within grid bounds.
4. Initialize the output grid as a copy of the input grid. The painting of 2x2 blocks modifies this copy. Pixels not part of these painted blocks retain their original color.
"""

# === Helper Functions ===

def find_background_color(grid: np.ndarray) -> int:
    """
    Finds the most frequent color in the grid.
    Prefers non-white if counts are equal.
    """
    colors, counts = np.unique(grid, return_counts=True)
    
    # If only one color exists, it's the background
    if len(colors) == 1:
        return colors[0]

    # Separate white and non-white counts
    white_count = 0
    non_white_colors = []
    non_white_counts = []
    for color, count in zip(colors, counts):
        if color == 0:
            white_count = count
        else:
            non_white_colors.append(color)
            non_white_counts.append(count)

    # Find the most frequent non-white color
    if non_white_counts:
        max_non_white_count = max(non_white_counts)
        most_frequent_non_white = [
            non_white_colors[i] for i, count in enumerate(non_white_counts) if count == max_non_white_count
        ]
        # If the most frequent non-white count is >= white count, return one of them (e.g., the first)
        if max_non_white_count >= white_count:
             # Return the smallest color value among most frequent non-white in case of ties
            return min(most_frequent_non_white)
        else:
            # White is strictly most frequent
            return 0
    else:
        # Only white exists
        return 0


def get_bounding_box(coords: list[tuple[int, int]]) -> tuple[int, int, int, int] | None:
    """Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates."""
    if not coords:
        return None
    rows, cols = zip(*coords)
    return min(rows), min(cols), max(rows), max(cols)

def euclidean_distance(p1: tuple[int, int], p2: tuple[int, int]) -> float:
    """Calculates Euclidean distance between two points (r1, c1) and (r2, c2)."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def get_associated_color_pixels(grid: np.ndarray, 
                                region_coords_set: set[tuple[int, int]], 
                                bbox: tuple[int, int, int, int], 
                                bgc: int) -> list[tuple[tuple[int, int], int]]:
    """
    Finds color pixels (non-white, non-BGC) associated with a white region.
    Association means within the bounding box or cardinally adjacent to the region's white pixels.
    """
    height, width = grid.shape
    r_min, c_min, r_max, c_max = bbox
    associated_pixels = []
    processed_coords = set()  # Avoid duplicates

    # 1. Check inside bounding box (inclusive)
    # Iterate using numpy slicing for potential efficiency if needed, but direct iteration is clearer here.
    for r in range(r_min, r_max + 1):
        for c in range(c_min, c_max + 1):
            coord = (r, c)
             # Ensure coord is valid (though bbox should guarantee this unless 1x1 region)
            if 0 <= r < height and 0 <= c < width:
                color = grid[r, c]
                # Check if it's a color pixel (not white, not BGC)
                if color != 0 and color != bgc:
                    if coord not in processed_coords:
                        associated_pixels.append((coord, color))
                        processed_coords.add(coord)

    # 2. Check cardinal adjacency to white pixels in the region
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # R, L, D, U
    for wr, wc in region_coords_set:
        for dr, dc in directions:
            nr, nc = wr + dr, wc + dc
            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                coord = (nr, nc)
                # Check if already processed (could be inside bbox too)
                if coord not in processed_coords:
                    color = grid[nr, nc]
                    # Check if it's a color pixel
                    if color != 0 and color != bgc:
                        associated_pixels.append((coord, color))
                        processed_coords.add(coord)
                        
    return associated_pixels

def paint_block(grid: np.ndarray, start_r: int, start_c: int, color: int):
    """Paints a 2x2 block starting at (start_r, start_c), checking bounds."""
    height, width = grid.shape
    for r_offset in range(2):
        for c_offset in range(2):
            paint_r, paint_c = start_r + r_offset, start_c + c_offset
            # Check bounds before painting
            if 0 <= paint_r < height and 0 <= paint_c < width:
                grid[paint_r, paint_c] = color


# === Main Transform Function ===

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule based on white regions, corner anchors, 
    and closest associated color pixels, painting 2x2 blocks.
    """
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array) # Initialize output grid
    height, width = input_array.shape

    # 1. Identify background color
    bgc = find_background_color(input_array)

    # 2. Find white regions using connected components labeling
    # structure defines connectivity (4-connectivity: cardinal directions)
    structure = np.array([[0,1,0], [1,1,1], [0,1,0]], dtype=bool) 
    white_mask = (input_array == 0)
    labeled_array, num_labels = label(white_mask, structure=structure)

    # 3. Process each distinct white region
    for i in range(1, num_labels + 1):
        # Get coordinates of all pixels in the current region
        region_coords = list(zip(*np.where(labeled_array == i)))
        if not region_coords:
            continue # Skip if region is empty (shouldn't happen with label)
            
        region_coords_set = set(region_coords)

        # a. Calculate bounding box
        bbox = get_bounding_box(region_coords)
        if bbox is None: continue # Should also not happen if region_coords not empty
        r_min, c_min, r_max, c_max = bbox

        # b. & c. Identify and validate corner anchor pixels
        potential_anchors = {
            "TL": (r_min - 1, c_min - 1),
            "TR": (r_min - 1, c_max + 1),
            "BL": (r_max + 1, c_min - 1),
            "BR": (r_max + 1, c_max + 1)
        }
        valid_anchors = {}
        for name, (ar, ac) in potential_anchors.items():
            # Check bounds and if the anchor pixel has the background color
            if 0 <= ar < height and 0 <= ac < width and input_array[ar, ac] == bgc:
                valid_anchors[name] = (ar, ac)

        # If no valid anchors found for this region, skip to the next region
        if not valid_anchors: 
             continue

        # d. Find associated color pixels (non-white, non-BGC) for this region
        color_pixels = get_associated_color_pixels(input_array, region_coords_set, bbox, bgc)
        
        # If no associated color pixels found, skip to the next region
        if not color_pixels: 
            continue

        # e. Assign colors to anchors based on closest color pixel
        # Initialize assignments with infinite distance and no color
        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_anchors}
        
        # Iterate through each associated color pixel
        for pixel_coord, color in color_pixels:
            # Compare its distance to each valid anchor
            for name, anchor_coord in valid_anchors.items():
                d = euclidean_distance(pixel_coord, anchor_coord)
                # If this pixel is closer than the current closest, update the assignment
                # Using '<=' implicitly handles ties by favoring the last processed pixel
                if d <= assignments[name]['dist']: 
                    assignments[name]['dist'] = d
                    assignments[name]['color'] = color

        # f. Paint 2x2 blocks based on assignments
        for name, anchor_coord in valid_anchors.items():
            assigned_color = assignments[name]['color']
            # Only paint if a color was actually assigned (dist wasn't infinity)
            if assigned_color is not None:
                ar, ac = anchor_coord
                start_r, start_c = -1, -1 # Initialize invalid start coords

                # Determine the top-left corner of the 2x2 block based on anchor type
                if name == "TL":
                    start_r, start_c = ar, ac + 1
                elif name == "TR":
                    start_r, start_c = ar, ac - 1
                elif name == "BL":
                    start_r, start_c = ar - 1, ac + 1
                elif name == "BR":
                    start_r, start_c = ar - 1, ac - 1

                # Paint the 2x2 block using the helper function (handles bounds)
                if start_r != -1: # Check if start coords were set
                    paint_block(output_array, start_r, start_c, assigned_color)

    # Convert the final NumPy array back to a list of lists
    return output_array.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```
Expected Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 3 3 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 3 3 0 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 3 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 4 1 1 1 1 2 0 1 1 1 1 1 1 1 1 1 1
1 1 4 4 0 0 0 0 0 0 2 2 1 1 1 1 1 1 1 1 1
1 1 4 4 1 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 4 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```
Transformed Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1
1 1 1 3 3 0 0 0 0 0 8 8 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 8 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 3 1 1 8 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 4 1 1 2 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 4 4 0 0 0 0 0 2 2 1 1 1 1 1 1 1 1 1
1 1 1 4 4 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
```
Match: False
Pixels Off: 16
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 7.256235827664398

## Example 2:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 0 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 8 7 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 3 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 0 1 0 0 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 0 6 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 6 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 8 8 8 7 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 0 2 0 7 0 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 8 7 7 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 3 8 4 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 0 3 0 4 0 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 8 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 1 1 1 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 1 1 1 0 0 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 0 6 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 0 0 3 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 3 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 8 8 7 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 0 0 7 7 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 2 8 7 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 3 8 4 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 3 0 0 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 3 8 8 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 39
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 14.744801512287353

## Example 3:
Input:
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 0 0 0 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```
Expected Output:
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 1 2 2 2 3 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 1 1 0 0 0 3 3 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 9 9 0 0 0 0
2 2 0 0 0 0 4 4 2 2 2 2 2 2 2 2 9 2 2 2 2
2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 8 2 2 2 2 2 9 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 0 0 0 0 0 9 9 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 3 3 0 0 0 0 0 8 8 2 2 2 2 2 2 2 2 2
2 2 2 2 3 2 2 2 2 2 8 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```
Transformed Output:
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 1 1 2 2 3 3 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 1 1 0 0 3 3 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 1 2 3 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2
2 2 0 2 2 2 0 2 2 2 2 2 2 2 2 2 0 9 2 2 2
2 2 0 2 2 4 0 2 2 2 2 2 2 2 2 2 9 9 0 0 0
2 2 4 4 0 0 4 4 2 2 2 2 2 2 2 2 9 9 2 2 2
2 2 4 4 2 2 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 8 8 2 2 2 2 9 9 2 2 2 2 2 2 2 2 2
2 2 2 2 8 8 0 0 0 0 9 9 2 2 2 2 2 2 2 2 2
2 2 2 2 0 8 2 2 2 9 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 0 3 2 2 2 8 0 2 2 2 2 2 2 2 2 2 2
2 2 2 2 3 3 0 0 0 0 8 8 2 2 2 2 2 2 2 2 2
2 2 2 2 3 3 2 2 2 2 8 8 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```
Match: False
Pixels Off: 20
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 9.070294784580511
**General Assessment:**

The initial hypothesis, focusing on direct adjacency between trigger pixels and background pixels, was incorrect. The generated outputs failed because the transformation involves a more complex spatial relationship based on the *corners* of white regions and the *proximity* of non-background, non-white "color pixels" associated with those regions. The transformation paints 2x2 blocks diagonally offset from the corners of the white regions' bounding boxes, using the color of the nearest associated color pixel.

**Strategy for Resolution:**

1.  **Identify White Regions:** Use connected components labeling to find each distinct area of white pixels.
2.  **Determine Bounding Box:** For each white region, calculate its minimum bounding box.
3.  **Identify Corner Anchors:** Locate the four pixels diagonally adjacent to the corners of the bounding box. These must be within the grid and have the background color to be considered valid "anchors".
4.  **Find Associated Color Pixels:** Identify all non-white, non-background pixels that are either within the bounding box or cardinally adjacent to any white pixel of the current region.
5.  **Calculate Closest Color:** For each valid corner anchor, calculate the Euclidean distance to all associated color pixels. Assign the color of the *closest* associated pixel to that anchor. Handle ties consistently (e.g., by order of processing pixels).
6.  **Paint 2x2 Blocks:** For each anchor that received a color assignment, paint a 2x2 block of that color in the output grid. The position of the 2x2 block is specifically offset relative to the anchor's position (e.g., the Top-Left anchor determines a block below and to its right).
7.  **Maintain Original Grid:** Start with a copy of the input grid and apply the 2x2 block painting modifications.

**Metrics and Analysis:**

We need tools to accurately identify regions, calculate distances, and manage the logic.

