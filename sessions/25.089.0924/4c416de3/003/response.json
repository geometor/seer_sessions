{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\nfrom scipy.ndimage import label\n\n\"\"\"\nTransformation Rule (v3.1):\n\n1. Identify the background color (BGC) as the most frequent color.\n2. Find all distinct contiguous regions of white (0) pixels.\n3. For each white region:\n    a. Determine its bounding box (r_min, c_min) to (r_max, c_max).\n    b. Identify the four potential corner background pixels located diagonally outside the bounding box: \n       TL=(r_min-1, c_min-1), TR=(r_min-1, c_max+1), BL=(r_max+1, c_min-1), BR=(r_max+1, c_max+1). \n       Validate that these corners are within grid bounds and have the BGC.\n    c. Find all 'color pixels' (non-BGC, non-white) associated with this region. A color pixel is associated if it's within the bounding box OR cardinally adjacent to any white pixel of this region.\n    d. Assign a color to each valid corner pixel based on proximity: For each color pixel, calculate its Euclidean distance to each valid corner pixel. The color of the *closest* color pixel is assigned to the corner. Ties are implicitly broken by processing order (last closest pixel wins).\n    e. For each corner that received a color assignment, paint a specific 2x2 block in the output grid with that color. The top-left coordinate of the 2x2 block depends on the corner type:\n        - TL corner (cr, cc) -> paint block starting at (cr, cc+1)\n        - TR corner (cr, cc) -> paint block starting at (cr, cc-1)\n        - BL corner (cr, cc) -> paint block starting at (cr-1, cc+1)\n        - BR corner (cr, cc) -> paint block starting at (cr-1, cc-1)\n4. Pixels not part of these 2x2 blocks retain their original color.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, ignoring white (0) if possible.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    non_white_indices = np.where(colors != 0)[0]\n    \n    if len(non_white_indices) > 0:\n        # Find the most frequent non-white color\n        max_count_idx_non_white = non_white_indices[np.argmax(counts[non_white_indices])]\n        return colors[max_count_idx_non_white]\n    else:\n        # If only white exists, return white (or handle as error/edge case)\n        # For robustness, return the most frequent overall if no non-white\n        return colors[np.argmax(counts)]\n\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a list of (row, col) coordinates.\"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef euclidean_distance(p1, p2):\n    \"\"\"Calculates Euclidean distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef get_region_pixels(grid, region_coords_set):\n    \"\"\"Finds color pixels associated with a white region.\"\"\"\n    height, width = grid.shape\n    bbox = get_bounding_box(list(region_coords_set))\n    if bbox is None:\n        return []\n    \n    r_min, c_min, r_max, c_max = bbox\n    associated_pixels = []\n    processed_coords = set() # Avoid duplicates if inside bbox AND adjacent\n\n    # Check inside bounding box\n    for r in range(r_min, r_max + 1):\n        for c in range(c_min, c_max + 1):\n             # Ensure coords are valid before checking grid value\n            if 0 <= r < height and 0 <= c < width:\n                color = grid[r, c]\n                # Check if it's a color pixel (not white, not background - handled later)\n                if color != 0:\n                    coord = (r, c)\n                    if coord not in processed_coords:\n                         associated_pixels.append((coord, color))\n                         processed_coords.add(coord)\n\n\n    # Check adjacency to white pixels in the region\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # R, L, D, U\n    for wr, wc in region_coords_set:\n        for dr, dc in directions:\n            nr, nc = wr + dr, wc + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                color = grid[nr, nc]\n                # Check if it's a color pixel\n                if color != 0:\n                    coord = (nr, nc)\n                    if coord not in processed_coords:\n                        associated_pixels.append((coord, color))\n                        processed_coords.add(coord)\n                        \n    return associated_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on white regions, corners, \n    and closest color pixels.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # 1. Identify background color\n    bgc = find_background_color(input_array)\n\n    # 2. Find white regions\n    white_mask = (input_array == 0)\n    labeled_array, num_labels = label(white_mask)\n\n    # 3. Process each white region\n    for i in range(1, num_labels + 1):\n        region_coords = list(zip(*np.where(labeled_array == i)))\n        if not region_coords:\n            continue\n            \n        region_coords_set = set(region_coords)\n\n        # a. Calculate bounding box\n        bbox = get_bounding_box(region_coords)\n        if bbox is None: continue\n        r_min, c_min, r_max, c_max = bbox\n\n        # b. Identify valid corner background pixels\n        potential_corners = {\n            \"TL\": (r_min - 1, c_min - 1),\n            \"TR\": (r_min - 1, c_max + 1),\n            \"BL\": (r_max + 1, c_min - 1),\n            \"BR\": (r_max + 1, c_max + 1)\n        }\n        valid_corners = {}\n        for name, (cr, cc) in potential_corners.items():\n            if 0 <= cr < height and 0 <= cc < width and input_array[cr, cc] == bgc:\n                valid_corners[name] = (cr, cc)\n\n        if not valid_corners: # Skip region if no valid corners\n             continue\n\n        # c. Find associated color pixels (filtering out BGC here)\n        all_associated = get_region_pixels(input_array, region_coords_set)\n        color_pixels = [p for p in all_associated if p[1] != bgc]\n        \n        if not color_pixels: # Skip region if no associated color pixels\n            continue\n\n        # d. Assign colors to corners based on distance\n        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_corners}\n        for (pr, pc), color in color_pixels:\n            pixel_coord = (pr, pc)\n            for name, corner_coord in valid_corners.items():\n                d = euclidean_distance(pixel_coord, corner_coord)\n                if d < assignments[name]['dist']:\n                    assignments[name]['dist'] = d\n                    assignments[name]['color'] = color\n                # Implicit tie-breaking: last pixel processed with equal min distance wins\n\n        # e. Paint 2x2 blocks\n        for name, corner_coord in valid_corners.items():\n            assigned_color = assignments[name]['color']\n            if assigned_color is not None:\n                cr, cc = corner_coord\n                start_r, start_c = -1, -1 # Initialize invalid start coords\n\n                if name == \"TL\":\n                    start_r, start_c = cr, cc + 1\n                elif name == \"TR\":\n                    start_r, start_c = cr, cc - 1\n                elif name == \"BL\":\n                    start_r, start_c = cr - 1, cc + 1\n                elif name == \"BR\":\n                    start_r, start_c = cr - 1, cc - 1\n\n                # Paint the 2x2 block if start coords are valid\n                if start_r != -1:\n                    for r_offset in range(2):\n                        for c_offset in range(2):\n                            paint_r, paint_c = start_r + r_offset, start_c + c_offset\n                            # Check bounds before painting\n                            if 0 <= paint_r < height and 0 <= paint_c < width:\n                                output_array[paint_r, paint_c] = assigned_color\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 30711,
    "candidates_token_count": 2216,
    "total_token_count": 32927,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.439673,
  "retries": 1
}