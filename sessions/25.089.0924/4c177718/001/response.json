{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set, Optional\n\n\"\"\"\nThis module transforms an input grid based on the following rules:\n\n1. Identify a horizontal gray separator line (color 5) dividing the input into upper and lower sections.\n2. Find all distinct, contiguous, non-background objects in both sections.\n3. The lower section contains one object ('bottom_object'). The upper section contains three objects.\n4. In the upper section, identify:\n    a. The object identical in shape and color to 'bottom_object' ('match_object').\n    b. A specific red (color 2) 'H' shaped object ('ignore_object').\n    c. The remaining object ('target_top_object').\n5. Create an output grid of size 9xW, where W is the input grid's width, initialized with background color 0.\n6. Determine the vertical stacking order of 'target_top_object' and 'bottom_object':\n    a. If 'target_top_object' color > 5, 'bottom_object' is placed above 'target_top_object'.\n    b. Otherwise, 'target_top_object' is placed above 'bottom_object'.\n7. Calculate the horizontal center column based on the 'bottom_object's bounding box in the original input grid.\n8. Place the selected objects ('target_top_object' and 'bottom_object') into the output grid, centered horizontally according to the calculated center column.\n9. The vertically topmost object starts at row 1, and the bottommost object starts at row 5 (leaving a 1-row gap of background color between them).\n10. Return the resulting output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_separator_row(grid: np.ndarray, separator_color: int = 5) -> Optional[int]:\n    \"\"\"Finds the row index of the horizontal separator line.\"\"\"\n    for r in range(grid.shape[0]):\n        if np.all(grid[r, :] == separator_color):\n            return r\n    return None\n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> List[Tuple[int, int]]:\n    \"\"\"Gets valid 4-directional neighbors for a cell.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> List[Dict]:\n    \"\"\"Finds all contiguous objects of non-background colors.\"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        if grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Extract shape relative to bounding box\n                obj_height = max_r - min_r + 1\n                obj_width = max_c - min_c + 1\n                shape = np.full((obj_height, obj_width), background_color, dtype=int)\n                for pr, pc in obj_pixels:\n                    shape[pr - min_r, pc - min_c] = color\n                \n                objects.append({\n                    \"pixels\": obj_pixels,\n                    \"color\": color,\n                    \"bbox\": (min_r, min_c, max_r, max_c),\n                    \"shape\": shape\n                })\n    return objects\n\ndef are_objects_identical(obj1: Dict, obj2: Dict) -> bool:\n    \"\"\"Checks if two objects have the same color and shape.\"\"\"\n    return obj1[\"color\"] == obj2[\"color\"] and np.array_equal(obj1[\"shape\"], obj2[\"shape\"])\n\ndef get_center_col(bbox: Tuple[int, int, int, int]) -> float:\n    \"\"\"Calculates the center column index of a bounding box.\"\"\"\n    min_c, max_c = bbox[1], bbox[3]\n    return min_c + (max_c - min_c) / 2.0\n\ndef place_object(target_grid: np.ndarray, obj_shape: np.ndarray, color: int, top_left_coord: Tuple[int, int]):\n    \"\"\"Places an object's shape onto a target grid at the specified top-left coordinate.\"\"\"\n    start_r, start_c = top_left_coord\n    obj_h, obj_w = obj_shape.shape\n    target_h, target_w = target_grid.shape\n\n    for r in range(obj_h):\n        for c in range(obj_w):\n            if obj_shape[r, c] == color: # Only copy non-background pixels of the shape\n                target_r, target_c = start_r + r, start_c + c\n                # Check bounds before placing\n                if 0 <= target_r < target_h and 0 <= target_c < target_w:\n                    target_grid[target_r, target_c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid according to the identified rules.\n    \"\"\"\n    input_h, input_w = input_grid.shape\n    output_h = 9\n    output_w = input_w\n\n    # 1. Find the separator row\n    separator_r = find_separator_row(input_grid)\n    if separator_r is None:\n        # Handle error case: No separator found (though unlikely based on examples)\n        print(\"Error: Separator row not found.\")\n        return np.zeros((output_h, output_w), dtype=int)\n\n    # 2. Split grid and find objects\n    upper_grid = input_grid[:separator_r, :]\n    lower_grid = input_grid[separator_r + 1:, :] # Skip the separator row itself\n\n    upper_objects = find_objects(upper_grid)\n    lower_objects = find_objects(lower_grid)\n\n    # Basic validation based on example structure\n    if len(lower_objects) != 1 or len(upper_objects) != 3:\n        print(f\"Error: Expected 1 lower object and 3 upper objects, found {len(lower_objects)} and {len(upper_objects)}.\")\n        # Return empty grid or handle appropriately\n        return np.zeros((output_h, output_w), dtype=int)\n\n    bottom_object = lower_objects[0]\n    # Adjust bottom_object bbox row coordinates to be relative to the original input grid\n    bottom_obj_orig_bbox = (\n        bottom_object[\"bbox\"][0] + separator_r + 1,\n        bottom_object[\"bbox\"][1],\n        bottom_object[\"bbox\"][2] + separator_r + 1,\n        bottom_object[\"bbox\"][3]\n    )\n\n\n    # 3 & 4. Identify the three specific upper objects\n    match_object = None\n    ignore_object = None # The red 'H'\n    target_top_object = None\n    remaining_upper_objects = []\n\n    for obj in upper_objects:\n        # Identify match object\n        if are_objects_identical(obj, bottom_object):\n            if match_object is not None: print(\"Warning: Found multiple matching objects!\") # Should not happen per pattern\n            match_object = obj\n        # Identify ignore object (Red 'H' - check color first, then shape if needed)\n        # Note: Assuming the H shape is consistently 3x3 for simplicity.\n        # A more robust check would compare the shape array explicitly.\n        elif obj[\"color\"] == 2 and obj[\"shape\"].shape == (3, 3):\n             # Check if it looks like an H:\n             # [[2,0,2], [2,2,2], [2,0,2]] -> this is one H shape, there could be others\n             # For this task, let's assume color 2 is sufficient unique identifier for the ignore object\n             if ignore_object is not None: print(\"Warning: Found multiple potential ignore objects!\")\n             ignore_object = obj\n        else:\n            remaining_upper_objects.append(obj)\n\n    # The target object is the one remaining\n    if len(remaining_upper_objects) == 1:\n        target_top_object = remaining_upper_objects[0]\n    else:\n        # Error handling if identification failed\n        print(f\"Error: Could not uniquely identify target_top_object. Remaining: {len(remaining_upper_objects)}\")\n        # Check if identification missed any object\n        if match_object is None: print(\"Error: Match object not found.\")\n        if ignore_object is None: print(\"Error: Ignore object (Red H) not found.\")\n        return np.zeros((output_h, output_w), dtype=int) # Return empty on error\n\n\n    # 5. Create output grid\n    output_grid = np.zeros((output_h, output_w), dtype=int)\n\n    # 6. Determine stacking order\n    if target_top_object[\"color\"] > 5:\n        top_obj = bottom_object\n        bottom_placed_obj = target_top_object\n    else:\n        top_obj = target_top_object\n        bottom_placed_obj = bottom_object\n\n    # 7. Calculate horizontal center\n    # Use the original bbox of the bottom object for centering reference\n    center_col_ref = get_center_col(bottom_obj_orig_bbox)\n\n    # 8 & 9. Place objects\n    # Place top object (starts at row 1)\n    top_shape = top_obj[\"shape\"]\n    top_h, top_w = top_shape.shape\n    top_start_c = round(center_col_ref - top_w / 2.0)\n    place_object(output_grid, top_shape, top_obj[\"color\"], (1, top_start_c))\n\n    # Place bottom object (starts at row 5)\n    bottom_shape = bottom_placed_obj[\"shape\"]\n    bottom_h, bottom_w = bottom_shape.shape\n    bottom_start_c = round(center_col_ref - bottom_w / 2.0)\n    place_object(output_grid, bottom_shape, bottom_placed_obj[\"color\"], (5, bottom_start_c))\n\n    # 10. Return result\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5497,
    "candidates_token_count": 2697,
    "total_token_count": 8194,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.896854,
  "retries": 1
}