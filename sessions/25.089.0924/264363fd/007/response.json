{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy import ndimage\n\n\"\"\"\nIdentifies contiguous regions of non-background colors in the input grid using 4-connectivity.\nThe background color is determined as the most frequent color overall.\nFor each distinct region, its 'base color' is found (most frequent color excluding potential triggers).\nThen, identifies 'trigger' pixels within each region based on the region's base color and the pixel's color, \naccording to specific rules:\n  - Base Blue-2 (2), Trigger Yellow-4 (4) -> Target Green-3 (3), trigger unchanged.\n  - Base Blue-1 (1), Trigger Green-3 (3) -> Target Red-2 (2), trigger *changes* to Red-2.\n  - Base Green-3 (3), Trigger Yellow-4 (4) -> Target Gray-5 (5), trigger unchanged.\nFor each column within a specific region that contains a trigger pixel, modifies the color of all pixels \nin the output grid that belong to that *same region* and are in that *same column* to the rule's target color.\nThe trigger pixel itself is only changed if the rule explicitly dictates it. \nIf multiple triggers exist in the same column for the same region, the effect is applied based on the first \ntrigger encountered during iteration (though examples don't show conflicts).\nPixels belonging to the background or pixels in non-background regions that are not \nin an affected column/region combination remain unchanged.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Determines the background color by finding the most frequent pixel value.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    if counts:\n        # Return the most common color\n        return counts.most_common(1)[0][0]\n    return 0 # Default fallback if grid is empty\n\ndef determine_region_base_color(grid, coords_list):\n    \"\"\"\n    Determines the base color of a region, preferentially excluding known trigger colors.\n    \"\"\"\n    if not coords_list:\n        return -1 # No coordinates, no base color\n\n    region_pixels = [grid[r, c] for r, c in coords_list]\n    pixel_counts = Counter(region_pixels)\n\n    # Potential trigger colors to exclude when determining base color\n    potential_trigger_colors = {3, 4}\n    base_color_counts = {color: count for color, count in pixel_counts.items() if color not in potential_trigger_colors}\n\n    if base_color_counts:\n         # Return the most common color excluding triggers\n         return max(base_color_counts, key=base_color_counts.get)\n    elif pixel_counts:\n         # Fallback: if only trigger colors exist, return the most common one\n         return pixel_counts.most_common(1)[0][0]\n    else:\n         return -1 # Should not happen if coords_list is not empty\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on region, trigger, and column rules.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Create a copy to modify and return\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # 1. Determine the background color\n    background_color = get_background_color(input_array)\n\n    # 2. Identify contiguous regions of non-background pixels\n    non_background_mask = input_array != background_color\n    # Use 4-connectivity (von Neumann neighbors)\n    connectivity_structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_array, num_labels = ndimage.label(non_background_mask, structure=connectivity_structure)\n\n    # 3. Precompute region coordinates and base colors\n    region_coords = {}\n    region_base_colors = {}\n    for label_idx in range(1, num_labels + 1):\n        # Find all coordinates for the current label\n        coords = list(zip(*np.where(labeled_array == label_idx)))\n        if coords:\n            region_coords[label_idx] = set(coords) # Use set for faster lookups later\n            base_color = determine_region_base_color(input_array, coords)\n            region_base_colors[label_idx] = base_color\n\n    # 4. Identify trigger actions required for each (region, column) pair\n    # Stores { (region_label, column): (target_color, change_trigger_flag, trigger_row) }\n    column_actions = {}\n    for r in range(height):\n        for c in range(width):\n            region_label = labeled_array[r, c]\n\n            # Skip background pixels or columns already marked for action in this region\n            if region_label == 0 or (region_label, c) in column_actions:\n                continue\n\n            pixel_color = input_array[r, c]\n            region_base_color = region_base_colors.get(region_label, -1)\n\n            # Check trigger rules\n            target_color = -1\n            change_trigger = False\n\n            # Rule 1: Blue-2 region, Yellow-4 trigger\n            if region_base_color == 2 and pixel_color == 4:\n                target_color = 3  # Green\n                change_trigger = False\n            # Rule 2: Blue-1 region, Green-3 trigger\n            elif region_base_color == 1 and pixel_color == 3:\n                target_color = 2  # Red\n                change_trigger = True\n            # Rule 3: Green-3 region, Yellow-4 trigger\n            elif region_base_color == 3 and pixel_color == 4:\n                target_color = 5  # Gray\n                change_trigger = False\n\n            # If a rule matched, store the action for this region/column\n            if target_color != -1:\n                column_actions[(region_label, c)] = (target_color, change_trigger, r) # Store trigger row 'r'\n\n    # 5. Apply the identified transformations\n    for (label, col), (target_color, change_trigger, trigger_row) in column_actions.items():\n        coords_set = region_coords.get(label)\n        if not coords_set: # Safety check\n            continue\n\n        # Iterate through rows in the affected column\n        for r_prime in range(height):\n            # Check if the pixel (r_prime, col) is part of the current region\n            if (r_prime, col) in coords_set:\n                # Check if it's the specific trigger pixel that initiated this action\n                if r_prime == trigger_row:\n                    if change_trigger:\n                        output_array[r_prime, col] = target_color\n                    # else: the trigger pixel keeps its original color (already copied)\n                else:\n                    # It's another pixel in the same column and region\n                    output_array[r_prime, col] = target_color\n\n    # 6. Convert the final numpy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20818,
    "candidates_token_count": 1718,
    "total_token_count": 22536,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.03417,
  "retries": 1
}