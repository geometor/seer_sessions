{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy import ndimage\n\n\"\"\"\nIdentifies contiguous regions of non-background colors in the input grid using 4-connectivity.\nThe background color is determined as the most frequent color overall.\nFor each distinct region, its 'base color' is found (most frequent color excluding potential triggers).\nThen, for each pixel in the grid:\nIf the pixel is a potential trigger color (Green-3 or Yellow-4) and belongs to a labeled region:\n  Check if its color combined with its region's base color matches a transformation rule:\n    - Base Blue-2 (2), Trigger Yellow-4 (4) -> Target Green-3 (3), trigger unchanged.\n    - Base Blue-1 (1), Trigger Green-3 (3) -> Target Red-2 (2), trigger *changes* to Red-2.\n    - Base Green-3 (3), Trigger Yellow-4 (4) -> Target Gray-5 (5), trigger unchanged.\n  If a rule matches and the column for this specific region hasn't been processed yet:\n    Modify the color of all pixels in the output grid that are in the *same column* and belong to the *same region* to the target color.\n    The trigger pixel itself is only changed if the rule dictates it.\n    Mark the (region, column) pair as processed.\nFinally, return the modified grid.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Determines the background color by finding the most frequent pixel value.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    if counts:\n        # Return the most common color\n        return counts.most_common(1)[0][0]\n    return 0 # Default fallback if grid is empty\n\ndef determine_region_base_color(grid, coords_list):\n    \"\"\"\n    Determines the base color of a region, excluding known trigger colors.\n    \"\"\"\n    if not coords_list:\n        return -1 # No coordinates, no base color\n\n    region_pixels = [grid[r, c] for r, c in coords_list]\n    pixel_counts = Counter(region_pixels)\n\n    # Potential trigger colors to exclude when determining base color\n    potential_trigger_colors = {3, 4}\n    base_color_counts = {color: count for color, count in pixel_counts.items() if color not in potential_trigger_colors}\n\n    if base_color_counts:\n         # Return the most common color excluding triggers\n         return max(base_color_counts, key=base_color_counts.get)\n    elif pixel_counts:\n         # Fallback: if only trigger colors exist, return the most common one\n         return pixel_counts.most_common(1)[0][0]\n    else:\n         return -1 # Should not happen if coords_list is not empty\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on region, trigger, and column rules using connected components.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Create a copy to modify and return\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # 1. Determine the background color\n    background_color = get_background_color(input_array)\n\n    # 2. Identify contiguous regions of non-background pixels\n    non_background_mask = input_array != background_color\n    # Use 4-connectivity (von Neumann neighbors)\n    connectivity_structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_array, num_labels = ndimage.label(non_background_mask, structure=connectivity_structure)\n\n    # 3. Determine the base color for each region\n    region_base_colors_map = {}\n    for label_idx in range(1, num_labels + 1):\n        # Get coordinates for the current region label\n        region_coords_list = list(zip(*np.where(labeled_array == label_idx)))\n        if region_coords_list:\n            # Calculate and store the base color for this region label\n            base_color = determine_region_base_color(input_array, region_coords_list)\n            region_base_colors_map[label_idx] = base_color\n\n    # 4. Initialize set to track processed (region_label, column) pairs\n    processed_region_columns = set()\n\n    # 5. Iterate through each pixel to find triggers and apply transformations\n    for r in range(height):\n        for c in range(width):\n            pixel_color = input_array[r, c]\n            region_label = labeled_array[r, c]\n\n            # Skip background or unlabeled pixels\n            if region_label == 0:\n                continue\n\n            # Check if this pixel's column has already been processed for this region\n            if (region_label, c) in processed_region_columns:\n                continue\n\n            # Retrieve the base color for this region\n            region_base_color = region_base_colors_map.get(region_label, -1)\n\n            # Check if the current pixel is a trigger based on region base color\n            is_trigger = False\n            target_color = -1\n            change_trigger = False\n\n            # Rule 1: Blue-2 region, Yellow-4 trigger\n            if region_base_color == 2 and pixel_color == 4:\n                is_trigger = True\n                target_color = 3  # Green\n                change_trigger = False\n            # Rule 2: Blue-1 region, Green-3 trigger\n            elif region_base_color == 1 and pixel_color == 3:\n                is_trigger = True\n                target_color = 2  # Red\n                change_trigger = True\n            # Rule 3: Green-3 region, Yellow-4 trigger\n            elif region_base_color == 3 and pixel_color == 4:\n                is_trigger = True\n                target_color = 5  # Gray\n                change_trigger = False\n\n            # 6. If it's a valid trigger for an unprocessed column in this region:\n            if is_trigger:\n                # Apply the change to the entire column *within the current region*\n                for r_prime in range(height):\n                    # Check if the pixel at (r_prime, c) belongs to the *same region*\n                    if labeled_array[r_prime, c] == region_label:\n                        # Check if it's the trigger pixel itself\n                        if r_prime == r:\n                            if change_trigger:\n                                output_array[r_prime, c] = target_color\n                            # If change_trigger is False, the original color from the copy remains\n                        else:\n                            # It's another pixel in the same column and same region\n                            output_array[r_prime, c] = target_color\n\n                # Mark this column as processed for this region label\n                processed_region_columns.add((region_label, c))\n\n    # 7. Convert the final numpy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21095,
    "candidates_token_count": 1698,
    "total_token_count": 22793,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.761998,
  "retries": 1
}