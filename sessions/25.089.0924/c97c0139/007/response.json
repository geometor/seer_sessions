{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all distinct connected objects (8-way connectivity) composed of red \n   pixels (color 2).\n2. For each red object, calculate its size 'L' (number of pixels) and determine \n   a maximum Manhattan distance threshold 'k' using the formula: \n   k = floor((L - 1) / 2). Store the pixels and 'k' for each object.\n3. Create a copy of the input grid.\n4. Iterate through every pixel (r, c) in the grid.\n5. If the pixel at (r, c) in the original input grid is white (color 0):\n    a. Find the minimum Manhattan distance ('d_min') from this white pixel (r, c) \n       to *any* red pixel across *all* identified red objects.\n    b. Determine which specific red object ('closest_object') contains the red \n       pixel that yielded this minimum distance 'd_min'.\n    c. Retrieve the threshold 'k_closest' calculated for this 'closest_object'.\n    d. If the condition '0 < d_min <= k_closest' holds true:\n        i. Change the color of the pixel at (r, c) in the output grid to \n           azure (color 8).\n6. Return the modified output grid. Original red pixels remain unchanged.\n\"\"\"\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points (row, col tuples).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds connected components of a specific color using 8-way connectivity.\n\n    Args:\n        grid: The 2D numpy array grid.\n        color: The target color integer.\n\n    Returns:\n        A dictionary where keys are object IDs (starting from 1) and values\n        are lists of (row, col) tuples representing the pixels of that object.\n        Returns an empty dictionary if no objects of the specified color are found.\n    \"\"\"\n    # Structure for 8-way connectivity\n    structure = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) \n    # Create a boolean mask where the target color is present\n    mask = (grid == color)\n    # Label the connected components in the mask\n    labeled_array, num_features = label(mask, structure=structure)\n    \n    objects = {}\n    if num_features > 0:\n        # Iterate through each found feature (object) ID (1 to num_features)\n        for i in range(1, num_features + 1):\n            # Find the coordinates (indices) where the labeled array equals the current feature ID\n            pixels = np.argwhere(labeled_array == i)\n            # Convert the numpy array of [row, col] pairs to a list of (row, col) tuples\n            pixel_tuples = [tuple(p) for p in pixels]\n            # Store the list of pixel tuples in the dictionary with the object ID as the key\n            if pixel_tuples: # Ensure the object is not empty\n                 objects[i] = pixel_tuples\n    return objects\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule: colors white pixels azure if they are within\n    a specific Manhattan distance 'k' (derived from the size of the *closest* red object)\n    from that closest red object.\n    \"\"\"\n    # Define colors\n    white_color = 0\n    red_color = 2\n    azure_color = 8\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # --- Step 1 & 2: Find red objects and calculate their properties ---\n    red_objects_pixels = find_objects(input_grid, red_color)\n    \n    # If no red objects, return the original grid copy\n    if not red_objects_pixels:\n        return output_grid\n\n    # Store object properties (pixels and threshold k)\n    object_properties = {}\n    for obj_id, pixels in red_objects_pixels.items():\n        L = len(pixels)\n        # Calculate the object-specific distance threshold k\n        k = math.floor((L - 1) / 2)\n        # Store the pixels and the calculated k for this object\n        object_properties[obj_id] = {'pixels': pixels, 'k': k}\n\n    # --- Step 4-6: Iterate through grid and color qualifying white pixels ---\n    for r in range(height):\n        for c in range(width):\n            # Check if the pixel in the original input is white (Step 5)\n            if input_grid[r, c] == white_color:\n                current_pos = (r, c)\n                min_overall_distance = float('inf')\n                closest_object_id = None\n\n                # Step 6a, 6b: Find the minimum distance and the ID of the closest object\n                for obj_id, properties in object_properties.items():\n                    obj_pixels = properties['pixels']\n                    \n                    # Calculate min distance from current_pos to this object\n                    min_dist_to_this_obj = float('inf')\n                    for obj_pixel_coords in obj_pixels:\n                        dist = manhattan_distance(current_pos, obj_pixel_coords)\n                        min_dist_to_this_obj = min(min_dist_to_this_obj, dist)\n                        # Optimization: if distance is 1, it's the minimum possible positive distance \n                        # for this specific object, no need to check other pixels *within this object*.\n                        if min_dist_to_this_obj == 1:\n                           break \n                    \n                    # Check if this object is closer than the current closest object found so far\n                    if min_dist_to_this_obj < min_overall_distance:\n                        min_overall_distance = min_dist_to_this_obj\n                        closest_object_id = obj_id\n                        # Optimization: if the overall minimum distance becomes 1, \n                        # we've found the absolute closest pixel possible, but we still\n                        # need its associated object ID, so we can't break the outer loop yet.\n\n                # Step 6c, 6d: Check the condition using the closest object's k\n                if closest_object_id is not None: # Ensure a closest object was found\n                    k_closest = object_properties[closest_object_id]['k']\n                    \n                    # Apply the coloring rule based on the closest object's threshold\n                    if 0 < min_overall_distance <= k_closest:\n                        output_grid[r, c] = azure_color\n\n    # --- Step 7: Return the modified grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18581,
    "candidates_token_count": 1621,
    "total_token_count": 20202,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.216625,
  "retries": 1
}