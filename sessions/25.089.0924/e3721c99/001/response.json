{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation rule:\n1. Identify distinct contiguous shapes of non-white (0) and non-gray (5) colors in the input grid. These are \"reference shapes\". Store their relative pixel patterns (forms) and colors.\n2. Identify distinct contiguous shapes of gray (5) color in the input grid. These are \"target shapes\".\n3. For each target shape:\n    a. Compare its relative pixel pattern (form) with the forms of all reference shapes.\n    b. If a match is found with a reference shape, change the color of all pixels belonging to that target shape in the output grid to the color of the matching reference shape.\n    c. If no match is found, change the color of all pixels belonging to that target shape in the output grid to the background color (white, 0).\n4. All pixels not part of a gray target shape retain their original color in the output grid.\n\"\"\"\n\ndef find_objects(grid, colors_to_find):\n    \"\"\"\n    Finds all contiguous objects of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of color values to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains:\n              'color': The color of the object.\n              'pixels': A list of (row, col) tuples for the object's pixels.\n              'form': A tuple of sorted (row, col) tuples representing the\n                      relative pixel coordinates (canonical form).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in colors_to_find and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                \n                # Use BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Calculate relative coordinates (form)\n                relative_pixels = sorted([(p_r - min_r, p_c - min_c) for p_r, p_c in obj_pixels])\n                form = tuple(relative_pixels) # Use tuple for hashability\n                \n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'form': form\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify reference shapes (all non-white, non-gray colors)\n    all_colors = set(np.unique(input_grid))\n    reference_colors = all_colors - {0, 5} # Exclude white (0) and gray (5)\n    \n    # Handle edge case where there are no reference colors\n    if not reference_colors:\n        # If no references, all gray shapes become white\n        reference_objects = []\n    else:\n        reference_objects = find_objects(input_grid, reference_colors)\n    \n    # Store reference forms and their colors\n    reference_forms = {obj['form']: obj['color'] for obj in reference_objects}\n\n    # 2. Identify target shapes (gray color 5)\n    target_objects = find_objects(input_grid, {5})\n\n    # 3. Iterate through target shapes and apply transformations\n    for target_obj in target_objects:\n        target_form = target_obj['form']\n        matched = False\n        \n        # Check if the target form matches any reference form\n        if target_form in reference_forms:\n            # Match found: Recolor target shape with reference color\n            new_color = reference_forms[target_form]\n            for r, c in target_obj['pixels']:\n                if 0 <= r < rows and 0 <= c < cols: # Ensure coordinates are valid\n                     output_grid[r, c] = new_color\n            matched = True\n            \n        if not matched:\n            # No match found: Erase target shape (set to white 0)\n            for r, c in target_obj['pixels']:\n                 if 0 <= r < rows and 0 <= c < cols: # Ensure coordinates are valid\n                    output_grid[r, c] = 0\n\n    # 4. Pixels not part of a gray shape retain their original color (already handled by copying)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9575,
    "candidates_token_count": 1282,
    "total_token_count": 10857,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.897491,
  "retries": 1
}