
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 1 3 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0 0
0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 5 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0
0 0 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 1 3 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 1 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 4 3 1 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 4 3 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 1 4 0 0 0 0 0 0 0
0 0 0 0 0 4 4 4 3 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 4 3 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 1 4 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 3 1 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0
0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 5 5 5 5 5 5 5 0 0 0 0 0 0
0 0 0 0 0 0 0 5 5 5 5 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 3 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 2 3 8 1 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 3 8 1 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 8 1 2 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 1 2 3 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 2 3 8 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 3 8 1 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 8 1 2 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 1 2 3 8 8 8 8 0 0 0
0 0 0 0 0 0 0 0 0 0 2 3 8 8 8 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 8 8 8 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 8 3 0 0 0 0 0 0 0 0 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 0
0 5 5 5 5 0 0 0 0 0 0 5 5 5 5 5 5 0
0 5 5 5 5 5 0 0 0 0 0 5 5 5 5 5 5 0
0 5 5 5 5 5 5 0 0 0 0 5 5 5 5 5 0 0
0 5 5 5 5 5 5 5 0 0 0 5 5 5 5 0 0 0
0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 0 5 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 5 5 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 8 3 0 0 0 0 0 0 0 0 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 2 0
0 2 2 2 2 0 0 0 0 0 0 3 3 3 3 8 2 0
0 2 8 8 8 8 0 0 0 0 0 3 3 3 3 8 2 0
0 2 8 3 3 3 3 0 0 0 0 3 3 3 3 8 0 0
0 2 8 3 2 2 2 2 0 0 0 3 3 3 3 0 0 0
0 0 8 3 2 8 8 8 8 0 0 0 0 0 0 0 0 0
0 0 0 3 2 8 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 2 8 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 8 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception of Task Elements:**

1.  **Input Structure:** Each input grid contains two distinct types of non-background (white/0) elements:
    *   A sequence of colored pixels, usually located near the top of the grid. I'll call this the "palette". The palette colors are read from left to right.
    *   One or more larger shapes composed entirely of gray (5) pixels. I'll call these "canvases". These shapes are often diagonal or somewhat amorphous.
2.  **Output Structure:** The output grid retains the palette exactly as it was in the input. The gray pixels of the canvas(es) are replaced with colors from the palette. The background (white/0) remains unchanged.
3.  **Transformation:** The core transformation involves coloring the gray pixels of the canvas(es) using the colors from the palette.
4.  **Coloring Pattern:** The colors from the palette are applied sequentially to the gray pixels. When the end of the palette sequence is reached, it wraps around and starts again from the beginning.
5.  **Pixel Order:** The gray pixels within each canvas seem to be colored in a specific order. Observing the examples, the order appears to be standard reading order: top-to-bottom, then left-to-right within each row.
6.  **Multiple Canvases:** Example 3 shows two distinct gray canvases. The coloring process applies independently to each contiguous gray shape. The palette sequence is applied to the pixels of the first shape (in reading order), and then the sequence restarts from the beginning for the pixels of the second shape (also in reading order).

**Facts:**


```yaml
task_elements:
  - element: background
    color: white (0)
    role: static backdrop
  - element: palette
    description: A sequence of non-white, non-gray pixels, usually in a single row near the top.
    properties:
      - colors: variable, defines the color sequence
      - position: usually near the top, fixed between input and output
    role: defines the coloring sequence
  - element: canvas
    description: One or more contiguous shapes made of gray (5) pixels.
    properties:
      - color: gray (5) in input
      - shape: variable, often diagonal or irregular
      - position: variable
    role: the area to be colored
  - element: colored_canvas
    description: The output version of the canvas(es) where gray pixels are replaced.
    properties:
      - color: derived from the palette sequence
      - shape: identical to the input canvas shape
      - position: identical to the input canvas position
    role: the result of the transformation

transformation:
  action: color_fill
  input_elements: [palette, canvas]
  output_elements: [colored_canvas]
  rule: Replace gray pixels in each canvas with colors from the palette.
  details:
    - Identify the palette colors by scanning the input grid for non-white, non-gray pixels (usually in a row near the top), reading left-to-right.
    - Identify all contiguous gray (5) objects (canvases).
    - For each canvas object:
        - Iterate through its gray pixels in reading order (top-to-bottom, left-to-right).
        - Assign colors to these pixels sequentially using the palette colors.
        - If the end of the palette sequence is reached, cycle back to the first palette color.
        - The palette sequence application restarts for each distinct canvas object.
    - Leave all other pixels (background and original palette) unchanged.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the sequence of colors in the palette by finding all non-white (0) and non-gray (5) pixels in the input grid, typically located together in a row. Store these colors in the order they appear (e.g., left-to-right). Let the number of colors in the palette be `N`.
3.  Find all distinct contiguous objects composed solely of gray (5) pixels in the input grid.
4.  For each distinct gray object found:
    a.  Create a list of the coordinates `(row, col)` of all gray pixels belonging to this object.
    b.  Sort this list of coordinates first by row index (ascending), and then by column index (ascending) for pixels in the same row. This establishes the "reading order" for the pixels within the object.
    c.  Initialize a counter `palette_index` to 0.
    d.  Iterate through the sorted list of gray pixel coordinates. For each coordinate `(r, c)`:
        i.  Get the color from the identified palette sequence at the current `palette_index`.
        ii. Set the pixel at `(r, c)` in the output grid to this palette color.
        iii. Increment `palette_index` by 1.
        iv. If `palette_index` equals `N` (the length of the palette), reset `palette_index` to 0 (to cycle through the palette).
5.  Return the modified output grid.
```python
import numpy as np

"""
Transformation Rule:

1. Identify the sequence of colors in the palette by finding all non-white (0) 
   and non-gray (5) pixels in the input grid, reading them in standard reading 
   order (top-to-bottom, left-to-right).
2. Find all distinct contiguous objects composed solely of gray (5) pixels.
3. For each distinct gray object found:
    a. Get the coordinates of all pixels belonging to the object.
    b. Sort these coordinates first by row index (ascending), then by column 
       index (ascending).
    c. Iterate through the sorted coordinates, replacing the gray pixel in the 
       output grid with colors from the palette sequence.
    d. Cycle through the palette sequence: when the end is reached, wrap around 
       to the beginning.
    e. The palette sequence application restarts from the beginning for each 
       new distinct gray object encountered.
4. Leave all other pixels (background and original palette pixels) unchanged.
"""

def _find_palette(grid):
    """Finds the palette colors in the grid."""
    palette = []
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            if color != 0 and color != 5:
                palette.append(color)
    return palette

def _find_objects(grid, target_color):
    """Finds all contiguous objects of a specific color."""
    rows, cols = grid.shape
    visited = np.zeros((rows, cols), dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == target_color and not visited[r, c]:
                # Start finding a new object using Breadth-First Search (BFS)
                current_object_coords = []
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    curr_r, curr_c = q.pop(0)
                    current_object_coords.append((curr_r, curr_c))
                    
                    # Check 4 orthogonal neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        
                        # Check bounds, color, and visited status
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == target_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            
                if current_object_coords:
                    objects.append(current_object_coords)
                    
    return objects

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    Finds a palette sequence and uses it to color gray objects.
    """
    # Convert input to numpy array for easier manipulation
    grid = np.array(input_grid)
    
    # Initialize output_grid as a copy of the input grid
    output_grid = grid.copy()

    # 1. Find the palette
    palette = _find_palette(grid)
    if not palette: # Handle cases with no palette
        return output_grid.tolist() 

    # 2. Find all gray (5) objects
    gray_objects = _find_objects(grid, 5)
    if not gray_objects: # Handle cases with no gray objects
        return output_grid.tolist()

    # 3. Process each gray object
    for obj_coords in gray_objects:
        # a. Get coordinates (already done by _find_objects)
        # b. Sort coordinates in reading order (row first, then column)
        sorted_coords = sorted(obj_coords, key=lambda x: (x[0], x[1]))
        
        # c. & d. Iterate through sorted coordinates and apply palette colors cyclically
        palette_index = 0
        num_palette_colors = len(palette)
        
        for r, c in sorted_coords:
            color_to_apply = palette[palette_index]
            output_grid[r, c] = color_to_apply
            palette_index = (palette_index + 1) % num_palette_colors
            # e. Palette sequence restarts implicitly for the next object in the outer loop

    # 4. Other pixels remain unchanged (done by starting with a copy)
    
    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
