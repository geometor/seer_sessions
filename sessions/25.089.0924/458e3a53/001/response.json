{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, center_of_mass\n\n\"\"\"\nIdentifies solid, single-color rectangular objects within the input grid that are distinct from background patterns and potential separator lines. \nDetermines the relative grid layout formed by these objects.\nCreates an output grid with dimensions matching this layout.\nFills the output grid cells with the colors of the corresponding objects from the input grid, maintaining their relative positions.\n\"\"\"\n\ndef find_solid_rectangles(grid):\n    \"\"\"\n    Finds all solid, monochromatic rectangular objects in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a found rectangle\n              with keys: 'color', 'bbox', 'center', 'pixels'.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                q = [(r, c)]\n                pixels = set([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            pixels.add((nr, nc))\n\n                # Check if it's a solid rectangle\n                bbox_h = max_r - min_r + 1\n                bbox_w = max_c - min_c + 1\n                if len(pixels) == bbox_h * bbox_w and len(pixels) > 1: # Ensure solid and not 1x1\n                     # Check if all pixels within the bounding box match the color (redundant if BFS finds all connected)\n                     is_solid = True\n                     for br in range(min_r, max_r + 1):\n                         for bc in range(min_c, max_c + 1):\n                             if grid[br, bc] != color:\n                                 is_solid = False\n                                 break\n                         if not is_solid:\n                             break\n                     \n                     if is_solid:\n                        bbox = (slice(min_r, max_r + 1), slice(min_c, max_c + 1))\n                        center = ((min_r + max_r) / 2, (min_c + max_c) / 2)\n                        objects.append({\n                            'color': color,\n                            'bbox': bbox,\n                            'center': center,\n                            'pixels': pixels,\n                            'size': len(pixels)\n                        })\n    return objects\n\ndef is_separator_line(rect, grid_shape):\n    \"\"\"Checks if a rectangle is likely a separator line (long and thin).\"\"\"\n    height, width = grid_shape\n    bbox = rect['bbox']\n    rect_h = bbox[0].stop - bbox[0].start\n    rect_w = bbox[1].stop - bbox[1].start\n\n    # Check if it spans a large portion of the grid dimension and is thin\n    is_long_horizontal = (rect_h == 1 and rect_w > width / 2)\n    is_long_vertical = (rect_w == 1 and rect_h > height / 2)\n    \n    # Also consider lines that form the grid in example 2 (width/height > some threshold)\n    aspect_ratio_threshold = 5 \n    is_very_elongated = (rect_h > 1 and rect_w > 1 and \n                         (rect_w / rect_h > aspect_ratio_threshold or \n                          rect_h / rect_w > aspect_ratio_threshold))\n\n    return is_long_horizontal or is_long_vertical or is_very_elongated\n\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts colors from solid rectangular objects arranged in a grid within the input\n    and creates an output grid showing these colors in their relative positions.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all solid, monochromatic rectangles\n    solid_rects = find_solid_rectangles(input_grid)\n\n    # 2. Filter out rectangles that look like separator lines\n    #    In this specific task, the separators have distinct colors (4 or 8) \n    #    and are lines, while target objects are blocks.\n    #    A simpler filter might be to just remove colors 4 and 8 if they form lines.\n    #    Let's try filtering based on shape first.\n    \n    potential_objects = []\n    for rect in solid_rects:\n         if not is_separator_line(rect, input_grid.shape):\n              potential_objects.append(rect)\n\n    # If filtering by shape removed too much (e.g. if target objects are thin), \n    # we might need a color-based filter or size-based filter.\n    # For now, assume shape filtering is sufficient.\n\n    if not potential_objects:\n        # Handle cases where no objects are found (return empty or based on specific rules)\n        return np.array([[]]) # Or handle as error\n\n    # 3. Determine the grid layout based on object centers\n    centers = np.array([obj['center'] for obj in potential_objects])\n    \n    # Find unique approximate row and column coordinates\n    # Use tolerance to group close centers\n    row_tolerance = 1.0 # Adjust if needed based on object sizes/spacing\n    col_tolerance = 1.0\n    \n    unique_rows = []\n    sorted_row_centers = sorted(centers[:, 0])\n    if sorted_row_centers:\n        current_row_group = [sorted_row_centers[0]]\n        for r in sorted_row_centers[1:]:\n            if r - np.mean(current_row_group) <= row_tolerance:\n                current_row_group.append(r)\n            else:\n                unique_rows.append(np.mean(current_row_group))\n                current_row_group = [r]\n        unique_rows.append(np.mean(current_row_group))\n\n    unique_cols = []\n    sorted_col_centers = sorted(centers[:, 1])\n    if sorted_col_centers:\n        current_col_group = [sorted_col_centers[0]]\n        for c in sorted_col_centers[1:]:\n             if c - np.mean(current_col_group) <= col_tolerance:\n                current_col_group.append(c)\n             else:\n                unique_cols.append(np.mean(current_col_group))\n                current_col_group = [c]\n        unique_cols.append(np.mean(current_col_group))\n        \n    output_h = len(unique_rows)\n    output_w = len(unique_cols)\n\n    if output_h == 0 or output_w == 0:\n         # Fallback or error - couldn't determine layout\n         # Maybe only one object found?\n         if len(potential_objects) == 1:\n             return np.array([[potential_objects[0]['color']]])\n         return np.array([[]]) # Or raise error\n\n    # Create mapping from coordinate to grid index\n    row_map = {coord: i for i, coord in enumerate(unique_rows)}\n    col_map = {coord: i for i, coord in enumerate(unique_cols)}\n\n    # 4. Create and populate the output grid\n    output_grid = np.zeros((output_h, output_w), dtype=int) # Default to black/0\n\n    for obj in potential_objects:\n        center_r, center_c = obj['center']\n        # Find the closest unique row/col coordinate\n        best_row_coord = min(unique_rows, key=lambda r: abs(r - center_r))\n        best_col_coord = min(unique_cols, key=lambda c: abs(c - center_c))\n        \n        out_r = row_map[best_row_coord]\n        out_c = col_map[best_col_coord]\n        \n        output_grid[out_r, out_c] = obj['color']\n\n    return output_grid.tolist() # Return as list of lists per spec\n\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6191,
    "candidates_token_count": 2127,
    "total_token_count": 8318,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 128.102051,
  "retries": 2
}