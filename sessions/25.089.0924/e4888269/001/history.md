
## train_1

**input:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
4 6 0 0 0 0 0 0 0 2 0 0 0 0 6 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
4 6 0 0 0 0 0 0 0 2 0 0 0 0 7 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 7 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 6 0 0 0 0 0
4 6 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 7 0 0 0 0 0
4 6 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 6 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 4 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
6 7 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
3 5 0 0 0 0 0 0 0 2 0 0 0 0 7 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
```

*   **Perception of the elements:**
    *   The input and output grids are of the same size (10x20).
    *   A vertical red line (color 2) consistently appears in column index 9, dividing the grid into a left and right section.
    *   The left section (columns 0 and 1) contains pairs of colored pixels (colors other than white/0). These pairs vary slightly between examples but define the transformation rule.
    *   The right section (columns 10 to 19) contains scattered colored pixels (colors other than white/0) on a white background.
    *   The transformation only affects the colors of the scattered pixels in the right section. The left section and the red line remain unchanged in the output.
    *   The color change on the right side depends on the pairs present on the left side.

*   **YAML documenting facts:**
    
```yaml
    grid:
      size: [10, 20]
      separator:
        color: red (2)
        location: vertical line at column index 9
    objects:
      - type: mapping_pairs
        location: left of the separator (columns 0 and 1)
        structure: vertically stacked pairs of non-white pixels
        properties: each pair consists of [color_A, color_B] at [row, 0] and [row, 1]
        role: define a set of color transformation rules (A -> B)
      - type: target_pixels
        location: right of the separator (columns 10 to 19)
        structure: scattered single non-white pixels
        properties: color (C), position (row, col)
        role: pixels whose color might change based on the mapping_pairs
    transformation:
      area_affected: only pixels to the right of the red separator
      type: color_replacement
      rule_definition: based on the mapping_pairs found on the left
      mechanism:
        description: >
          For each target_pixel with color C, find a mapping_pair (A, B) where A equals C.
          If found, check if another mapping_pair (B, D) exists.
          Continue following this chain (C -> B -> D -> ...) until a color is reached that is not the start of any further mapping_pair.
          The final color in this chain replaces the original color C of the target_pixel.
          If no mapping_pair starts with C, the color remains unchanged (though in the examples, all target pixels match a starting pair).
      unchanged_elements:
        - pixels left of the separator
        - the red separator line itself
        - white background pixels (color 0)
    ```


*   **Natural Language Program:**
    1.  Identify the vertical red line (color 2) that separates the grid into a left part and a right part.
    2.  Extract all the color pairs `(color_A, color_B)` from the first two columns (index 0 and 1) on the left side of the red line. Store these pairs as a set of directed transformation rules: `color_A` maps to `color_B`.
    3.  Create a final mapping dictionary. For each initial color `C` present as `color_A` in any extracted pair:
        a.  Start with the current color `Current = C`.
        b.  Find the `color_B` such that the pair `(Current, color_B)` exists in the extracted rules.
        c.  Update `Current = color_B`.
        d.  Repeat step 3b-3c: Check if a pair starting with the new `Current` color exists. If yes, follow the chain. If no, stop.
        e.  The final value of `Current` after the chain stops is the target color for the initial color `C`. Store this `C -> final_Current` mapping in the final mapping dictionary.
    4.  Initialize the output grid as a copy of the input grid.
    5.  Iterate through each pixel located to the *right* of the red separator line in the input grid.
    6.  If a pixel has a non-white color `C` and `C` exists as a key in the final mapping dictionary, update the color of the corresponding pixel in the output grid to the mapped target color.
    7.  Leave all pixels to the left of the red line, the red line itself, and all white pixels unchanged from the input grid.
    8.  Return the modified output grid.
