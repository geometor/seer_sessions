
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 5 0 0 0 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 6 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 1 1 0 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 3 1 1 0 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 0 1 1 0 0
0 0 0 0 0 0 0 0 0 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 4 4 4 4 0
0 1 0 0 1 4 0 0 4 0
0 1 0 0 1 4 0 0 4 0
0 0 1 1 0 4 4 4 4 0
0 4 4 4 4 0 1 1 0 0
0 4 0 0 4 1 0 0 1 0
0 4 0 0 4 1 0 0 1 0
0 4 4 4 4 0 1 1 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
4 4 4 4 0 0 2 0 0 0
4 0 0 4 0 0 0 0 0 0
4 0 0 4 0 0 0 0 0 0
4 4 4 4 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 4 4 4 0 0 4 4 4 4
4 0 0 4 0 0 4 0 0 4
4 0 0 4 0 0 4 0 0 4
4 4 4 4 0 0 4 4 4 4
```

**Perception**

The core transformation logic involves identifying specific types of objects or pixels in the input grid and applying distinct rules based on their color and shape.

1.  **Pixel-to-Shape Transformation:** Single pixels of specific colors (red and green) expand into larger, hollow square shapes of different colors (yellow and blue, respectively). This transformation is conditional on the resulting shape fitting entirely within the grid boundaries.
2.  **Object Manipulation:** Certain predefined objects undergo specific transformations: 2x2 magenta squares are shifted diagonally up-left, while 4x4 hollow blue squares are copied directly to the output in the same position.
3.  **Filtering/Removal:** Any input pixel or object that does not match the criteria for transformation (Cases 1 & 2) is effectively removed, resulting in white (0) pixels in the corresponding output locations. This includes single pixels of colors other than red or green (e.g., gray), single red/green pixels whose expanded shape would go out of bounds, and larger objects of colors/shapes not explicitly handled (e.g., the 4x4 hollow yellow square in `train_3`).
4.  **Output Construction:** The output grid is built by applying these transformations and copying/shifting rules onto an initially white grid. The transformations from different input elements can potentially overlap in the output grid. The order of application doesn't seem to matter based on the examples, as the transformed/copied objects don't overlap destructively.

**Facts**


```yaml
task_context:
  grid_size: variable, input and output grids have the same dimensions.
  colors_used_input: [white(0), blue(1), red(2), green(3), yellow(4), gray(5), magenta(6)]
  colors_used_output: [white(0), blue(1), yellow(4), magenta(6)] # Note: Gray(5), Red(2), Green(3) disappear or transform
objects:
  - type: single_pixel
    properties:
      - color: red(2)
      - location: (r, c)
    actions:
      - condition: A 4x4 square anchored at (r, c) fits within grid boundaries.
      - transformation: Replace with a 4x4 hollow square of yellow(4) anchored at (r, c) in the output.
      - else: Remove (becomes white(0)).
  - type: single_pixel
    properties:
      - color: green(3)
      - location: (r, c)
    actions:
      - condition: A 4x4 square anchored at (r, c) fits within grid boundaries.
      - transformation: Replace with a 4x4 hollow square of blue(1) anchored at (r, c) in the output.
      - else: Remove (becomes white(0)).
  - type: single_pixel
    properties:
      - color: any color other than red(2) or green(3) (e.g., gray(5))
    actions:
      - transformation: Remove (becomes white(0)).
  - type: square_2x2
    properties:
      - color: magenta(6)
      - top_left_corner: (r, c)
    actions:
      - condition: r > 0 and c > 0
      - transformation: Draw a 2x2 magenta(6) square anchored at (r-1, c-1) in the output.
      - else: Remove? (Although not seen in examples, assume removal if shift goes out of bounds).
  - type: hollow_square_4x4
    properties:
      - color: blue(1)
      - top_left_corner: (r, c)
    actions:
      - transformation: Draw a 4x4 hollow blue(1) square anchored at (r, c) in the output.
  - type: any_other_object # e.g., hollow_square_4x4 of yellow(4)
    properties:
      - shape: not a single pixel, not 2x2 magenta, not 4x4 hollow blue
    actions:
      - transformation: Remove (becomes white(0)).
relationships:
  - Transformation depends on both the color and shape/size of the input object/pixel.
  - Positional constraints (fitting within bounds, specific shifts) are crucial.
  - Input objects that don't meet specific criteria are discarded.
```


**Natural Language Program**

1.  Create a new output grid with the same dimensions as the input grid, initialized with all white (0) pixels.
2.  Identify all distinct objects (contiguous blocks of the same non-white color) in the input grid.
3.  For each identified object:
    a.  **Check for Single Red Pixel:** If the object consists of a single pixel of red (2) located at `(row, col)`:
        i.  Determine if a 4x4 square starting at `(row, col)` would fit entirely within the grid boundaries (i.e., `row + 3 < grid_height` and `col + 3 < grid_width`).
        ii. If it fits, draw a 4x4 hollow square using yellow (4) onto the output grid, with its top-left corner at `(row, col)`.
    b.  **Check for Single Green Pixel:** If the object consists of a single pixel of green (3) located at `(row, col)`:
        i.  Determine if a 4x4 square starting at `(row, col)` would fit entirely within the grid boundaries.
        ii. If it fits, draw a 4x4 hollow square using blue (1) onto the output grid, with its top-left corner at `(row, col)`.
    c.  **Check for 2x2 Magenta Square:** If the object is a 2x2 square of magenta (6) with its top-left corner at `(row, col)`:
        i.  Determine if the target top-left position `(row-1, col-1)` is valid (i.e., `row > 0` and `col > 0`).
        ii. If valid, draw a 2x2 square of magenta (6) onto the output grid, with its top-left corner at `(row-1, col-1)`.
    d.  **Check for 4x4 Hollow Blue Square:** If the object is a 4x4 hollow square of blue (1) with its top-left corner at `(row, col)`:
        i.  Draw a 4x4 hollow square of blue (1) onto the output grid, with its top-left corner at `(row, col)`.
    e.  **Ignore Other Objects:** If the object does not match any of the conditions in steps 3a, 3b, 3c, or 3d, do nothing with it (it effectively gets removed as the output grid started white).
4.  Return the final output grid.
