{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two main regions (left and right) separated by a vertical line, with a surrounding border of the same color as the separator.\nFinds distinct objects within the left region (contiguous pixels different from the left background and the border/separator color).\nCopies these objects into the right region, preserving their vertical position relative to the top of the region and their horizontal position relative to the left edge of the region.\nObjects overwrite the original background color of the right region.\nA special case exists for objects that span the full horizontal width of the left region: these objects are copied such that they span the full horizontal width of the *right* region, while maintaining their vertical position.\nThe border, separator line, and the original content of the left region remain unchanged.\n\"\"\"\n\ndef find_separator_and_regions(grid):\n    \"\"\"Identifies the separator column and defines the left/right content regions.\"\"\"\n    h, w = grid.shape\n    sep_col_idx = -1\n    sep_color = -1\n    \n    # Assume border is 1 pixel thick. Look for a vertical line.\n    # A simple check: find the first column (after the left border) \n    # where the color differs from the immediate left, and check if it's uniform.\n    border_color = grid[0, 0]\n    \n    for c in range(1, w - 1):\n        # Check if this column might be a separator\n        col_content = grid[:, c]\n        if np.all(col_content == col_content[0]) and col_content[0] != grid[1, c-1]: \n             # Check if it differs from the left content area's potential background\n             # And check if it's the same as the border color (heuristic)\n             if col_content[0] == border_color:\n                 sep_col_idx = c\n                 sep_color = col_content[0]\n                 break\n                 \n    if sep_col_idx == -1:\n         # Fallback or more robust search needed if the simple check fails.\n         # Maybe check every column that matches border color.\n         for c in range(1, w - 1):\n             col_content = grid[:, c]\n             if np.all(col_content == border_color):\n                 # Potential separator, assume the first one found\n                 sep_col_idx = c\n                 sep_color = border_color\n                 break\n         if sep_col_idx == -1:\n            raise ValueError(\"Could not reliably identify separator column.\")\n\n    # Define regions based on 1px border and separator\n    left_region = {\n        \"r\": 1, \"c\": 1, \n        \"h\": h - 2, \"w\": sep_col_idx - 1, \n        \"grid\": grid[1:h-1, 1:sep_col_idx]\n    }\n    right_region = {\n        \"r\": 1, \"c\": sep_col_idx + 1, \n        \"h\": h - 2, \"w\": w - sep_col_idx - 2,\n        \"grid\": grid[1:h-1, sep_col_idx + 1:w-1]\n    }\n    \n    return sep_col_idx, sep_color, left_region, right_region\n\ndef find_objects(grid_segment, background_color, ignored_colors):\n    \"\"\"Finds connected components (objects) in a grid segment.\"\"\"\n    h, w = grid_segment.shape\n    visited = np.zeros((h, w), dtype=bool)\n    objects = []\n    \n    for r in range(h):\n        for c in range(w):\n            pixel_color = grid_segment[r, c]\n            if not visited[r, c] and pixel_color != background_color and pixel_color not in ignored_colors:\n                # Start BFS for a new object\n                object_color = pixel_color\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        if 0 <= nr < h and 0 <= nc < w and \\\n                           not visited[nr, nc] and \\\n                           grid_segment[nr, nc] == object_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Determine if the object spans the full width of the segment\n                spans_full_width = (min_c == 0 and max_c == w - 1)\n                \n                objects.append({\n                    'color': object_color,\n                    'pixels': current_object_pixels, # Relative coords within grid_segment\n                    'min_r': min_r, 'max_r': max_r,\n                    'min_c': min_c, 'max_c': max_c,\n                    'spans_full_width': spans_full_width\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying objects from the left region to the right region.\n    Objects spanning the full width of the left region are expanded to span the full width of the right region.\n    Other objects maintain their relative position and size.\n    \"\"\"\n    h, w = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify separator and regions\n    try:\n        sep_col_idx, sep_color, left_rgn, right_rgn = find_separator_and_regions(input_grid)\n    except ValueError as e:\n        print(f\"Error identifying regions: {e}\")\n        # Handle error case - perhaps return input if structure is unexpected\n        return output_grid \n\n    # 2. Determine left background color (simple heuristic: top-left pixel of the content area)\n    #    Ensure it's not the separator/border color itself.\n    left_bg_color = left_rgn[\"grid\"][0, 0] if left_rgn[\"h\"] > 0 and left_rgn[\"w\"] > 0 else -1 # Handle empty region\n    if left_bg_color == sep_color:\n         # Need a better heuristic if top-left is border color or an object\n         # Try finding the most frequent color that is not sep_color\n         colors, counts = np.unique(left_rgn[\"grid\"], return_counts=True)\n         valid_colors = colors[colors != sep_color]\n         if len(valid_colors) > 0:\n             valid_counts = counts[colors != sep_color]\n             left_bg_color = valid_colors[np.argmax(valid_counts)]\n         else:\n             # If only separator color exists, maybe bg is sep_color or region is empty\n             left_bg_color = sep_color # Or handle as error/edge case\n\n    # 3. Find objects in the left region\n    ignored_colors = {sep_color} \n    if left_rgn[\"h\"] > 0 and left_rgn[\"w\"] > 0:\n        objects_in_left = find_objects(left_rgn[\"grid\"], left_bg_color, ignored_colors)\n    else:\n        objects_in_left = [] # No objects if region is empty\n\n    # 4. Copy objects to the right region in the output grid\n    for obj in objects_in_left:\n        obj_color = obj['color']\n        \n        if obj['spans_full_width']:\n            # Find unique relative rows the object occupies\n            rel_rows = sorted(list(set(r for r, c in obj['pixels'])))\n            for rel_r in rel_rows:\n                # Calculate absolute row in the output grid\n                abs_row = right_rgn['r'] + rel_r\n                # Check bounds before writing\n                if 0 <= abs_row < h and right_rgn['w'] > 0:\n                     # Fill the corresponding row segment in the right region\n                     output_grid[abs_row, right_rgn['c'] : right_rgn['c'] + right_rgn['w']] = obj_color\n        else:\n            # Copy pixel by pixel preserving relative coordinates\n            for rel_r, rel_c in obj['pixels']:\n                # Calculate absolute coordinates in the output grid\n                abs_row = right_rgn['r'] + rel_r\n                abs_col = right_rgn['c'] + rel_c\n                # Check bounds before writing\n                if 0 <= abs_row < h and 0 <= abs_col < w:\n                    output_grid[abs_row, abs_col] = obj_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5110,
    "candidates_token_count": 2203,
    "total_token_count": 7313,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.717472,
  "retries": 1
}