
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 1 1 1 1 1 3 1 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 4 4 3 4 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 4 3 4 4 4 4 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 8 1 8 1 1 1 1 1
1 1 1 1 8 1 8 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 8 8 1 8 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 1 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

*   **Perception of Task Elements:**
    *   The inputs consist of a background color grid with scattered pixels or shapes of one or more other colors.
    *   The background color appears to be the most frequent color in each input grid (green=3 in ex1, azure=8 in ex2, blue=1 in ex3).
    *   The output grids retain the original non-background pixels and add more pixels of those same non-background colors.
    *   The added pixels seem to fill gaps or connect separate components of the same non-background color.
    *   The transformation operates independently for each non-background color.
    *   The filling mechanism appears constrained: it only happens within the bounding box defined by all pixels of a specific non-background color and only affects background pixels that are adjacent (including diagonally) to an existing pixel of that non-background color.

*   **YAML Fact Sheet:**
    
```yaml
    task_description: Fill background pixels within the bounding box of each non-background color group if they are adjacent to a pixel of that color.

    elements:
      - role: background
        property: most frequent color in the input grid.
        example_1: green (3)
        example_2: azure (8)
        example_3: blue (1)
      - role: objects
        property: groups of contiguous or scattered pixels of the same non-background color.
        example_1: blue (1) objects, yellow (4) objects
        example_2: green (3) objects
        example_3: azure (8) objects
      - role: bounding_box
        property: the smallest rectangle enclosing all pixels of a specific non-background color.
      - role: adjacency
        property: includes 8 neighbors (cardinal and diagonal).

    transformation:
      - action: identify_background_color
        input: input grid
        output: background color value
      - action: identify_non_background_colors
        input: input grid
        output: set of color values present, excluding background
      - action: process_each_non_background_color
        steps:
          - find_pixels: locate all pixels of the current non-background color C.
          - calculate_bounding_box: determine the min/max row/column for pixels of color C.
          - iterate_within_bounding_box: examine each pixel (r, c) within the calculated box.
          - check_pixel_condition:
              - condition_1: input grid at (r, c) has the background color.
              - condition_2: input grid has at least one neighbor (8-way adjacency) of (r, c) with color C.
          - update_output: if both conditions are met, set the output grid at (r, c) to color C.
      - action: initialize_output
        input: input grid
        output: a copy of the input grid
      - action: preserve_original_pixels
        rule: pixels that are not background color in the input, or background pixels not meeting the update condition, retain their original color in the output.

    relationship:
      - A background pixel changes to color C if and only if it resides within the bounding box defined by all pixels of color C in the input and is adjacent (including diagonally) to at least one pixel of color C in the input.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as an identical copy of the input grid.
    2.  Determine the background color by finding the most frequent pixel value in the input grid.
    3.  Identify all unique pixel colors present in the input grid, other than the background color.
    4.  For each unique non-background color `C` found:
        a.  Find the coordinates of all pixels in the input grid that have the color `C`.
        b.  If no pixels of color `C` exist, skip to the next color.
        c.  Calculate the minimum bounding box (minimum row, minimum column, maximum row, maximum column) that encloses all found coordinates for color `C`.
        d.  Iterate through every grid cell `(r, c)` within this bounding box (from minimum row to maximum row, and minimum column to maximum column).
        e.  Check the color of the cell `(r, c)` in the *input* grid. If it is the background color:
            i.  Examine all 8 neighbors (horizontal, vertical, and diagonal) of the cell `(r, c)` in the *input* grid.
            ii. Count how many of these neighbors have the color `C`.
            iii. If the count of neighbors with color `C` is one or more, change the color of the cell `(r, c)` in the *output* grid to `C`.
    5.  After processing all non-background colors, return the final output grid.
