
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 1 1 1 1 1 3 1 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 4 4 3 4 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 4 3 4 4 4 4 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 8 1 8 1 1 1 1 1
1 1 1 1 8 1 8 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 8 8 1 8 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 1 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

*   **Perception of Task Elements:**
    *   The inputs consist of a background color grid with scattered pixels or shapes of one or more other colors.
    *   The background color appears to be the most frequent color in each input grid (green=3 in ex1, azure=8 in ex2, blue=1 in ex3).
    *   The output grids retain the original non-background pixels and add more pixels of those same non-background colors.
    *   The added pixels seem to fill gaps or connect separate components of the same non-background color.
    *   The transformation operates independently for each non-background color.
    *   The filling mechanism appears constrained: it only happens within the bounding box defined by all pixels of a specific non-background color and only affects background pixels that are adjacent (including diagonally) to an existing pixel of that non-background color.

*   **YAML Fact Sheet:**
    
```yaml
    task_description: Fill background pixels within the bounding box of each non-background color group if they are adjacent to a pixel of that color.

    elements:
      - role: background
        property: most frequent color in the input grid.
        example_1: green (3)
        example_2: azure (8)
        example_3: blue (1)
      - role: objects
        property: groups of contiguous or scattered pixels of the same non-background color.
        example_1: blue (1) objects, yellow (4) objects
        example_2: green (3) objects
        example_3: azure (8) objects
      - role: bounding_box
        property: the smallest rectangle enclosing all pixels of a specific non-background color.
      - role: adjacency
        property: includes 8 neighbors (cardinal and diagonal).

    transformation:
      - action: identify_background_color
        input: input grid
        output: background color value
      - action: identify_non_background_colors
        input: input grid
        output: set of color values present, excluding background
      - action: process_each_non_background_color
        steps:
          - find_pixels: locate all pixels of the current non-background color C.
          - calculate_bounding_box: determine the min/max row/column for pixels of color C.
          - iterate_within_bounding_box: examine each pixel (r, c) within the calculated box.
          - check_pixel_condition:
              - condition_1: input grid at (r, c) has the background color.
              - condition_2: input grid has at least one neighbor (8-way adjacency) of (r, c) with color C.
          - update_output: if both conditions are met, set the output grid at (r, c) to color C.
      - action: initialize_output
        input: input grid
        output: a copy of the input grid
      - action: preserve_original_pixels
        rule: pixels that are not background color in the input, or background pixels not meeting the update condition, retain their original color in the output.

    relationship:
      - A background pixel changes to color C if and only if it resides within the bounding box defined by all pixels of color C in the input and is adjacent (including diagonally) to at least one pixel of color C in the input.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as an identical copy of the input grid.
    2.  Determine the background color by finding the most frequent pixel value in the input grid.
    3.  Identify all unique pixel colors present in the input grid, other than the background color.
    4.  For each unique non-background color `C` found:
        a.  Find the coordinates of all pixels in the input grid that have the color `C`.
        b.  If no pixels of color `C` exist, skip to the next color.
        c.  Calculate the minimum bounding box (minimum row, minimum column, maximum row, maximum column) that encloses all found coordinates for color `C`.
        d.  Iterate through every grid cell `(r, c)` within this bounding box (from minimum row to maximum row, and minimum column to maximum column).
        e.  Check the color of the cell `(r, c)` in the *input* grid. If it is the background color:
            i.  Examine all 8 neighbors (horizontal, vertical, and diagonal) of the cell `(r, c)` in the *input* grid.
            ii. Count how many of these neighbors have the color `C`.
            iii. If the count of neighbors with color `C` is one or more, change the color of the cell `(r, c)` in the *output* grid to `C`.
    5.  After processing all non-background colors, return the final output grid.
```python
import numpy as np
from collections import Counter

"""
Fill background pixels within the bounding box of each non-background color group 
if they are adjacent (including diagonally) to a pixel of that color in the input grid.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    unique, counts = np.unique(grid, return_counts=True)
    return unique[np.argmax(counts)]

def find_pixels_of_color(grid, color):
    """Finds the coordinates of all pixels with the specified color."""
    rows, cols = np.where(grid == color)
    return list(zip(rows, cols))

def calculate_bounding_box(coords):
    """Calculates the min/max row/col for a list of coordinates."""
    if not coords:
        return None
    min_row = min(r for r, c in coords)
    min_col = min(c for r, c in coords)
    max_row = max(r for r, c in coords)
    max_col = max(c for r, c in coords)
    return min_row, min_col, max_row, max_col

def get_neighbors(grid, r, c):
    """Gets the coordinates of the 8 neighbors of a cell."""
    rows, cols = grid.shape
    neighbors = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbors.append((nr, nc))
    return neighbors

def transform(input_grid):
    """
    Transforms the input grid by filling background pixels within the bounding box 
    of each non-background color if they are adjacent to a pixel of that color.

    1. Initialize the output grid as a copy of the input grid.
    2. Determine the background color (most frequent).
    3. Identify all unique non-background colors.
    4. For each non-background color C:
        a. Find all pixels with color C.
        b. Calculate the bounding box for color C.
        c. Iterate through cells (r, c) within the bounding box.
        d. If input_grid[r, c] is the background color:
            i. Check the 8 neighbors of (r, c) in the input grid.
            ii. If any neighbor has color C, set output_grid[r, c] to C.
    5. Return the modified output grid.
    """
    # Convert input list of lists to numpy array for easier processing
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape
    
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_grid_np)

    # Determine the background color
    background_color = find_background_color(input_grid_np)

    # Identify all unique non-background colors
    unique_colors = np.unique(input_grid_np)
    non_background_colors = [c for c in unique_colors if c != background_color]

    # Process each non-background color
    for color in non_background_colors:
        # Find pixels of the current color
        pixel_coords = find_pixels_of_color(input_grid_np, color)
        
        # Skip if no pixels of this color exist
        if not pixel_coords:
            continue

        # Calculate the bounding box for this color
        bounding_box = calculate_bounding_box(pixel_coords)
        if bounding_box is None:
            continue
        min_row, min_col, max_row, max_col = bounding_box

        # Iterate within the bounding box
        for r in range(min_row, max_row + 1):
            for c in range(min_col, max_col + 1):
                # Check if the current pixel in the *input* grid is the background color
                if input_grid_np[r, c] == background_color:
                    # Get the neighbors of the current pixel
                    neighbors = get_neighbors(input_grid_np, r, c)
                    
                    # Check if any neighbor in the *input* grid has the current color
                    has_color_neighbor = False
                    for nr, nc in neighbors:
                        if input_grid_np[nr, nc] == color:
                            has_color_neighbor = True
                            break
                            
                    # If a neighbor has the color, update the output grid
                    if has_color_neighbor:
                        output_grid[r, c] = color

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()

```
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid by iteratively filling background pixels within the 
bounding box of each non-background color. A background pixel is filled if 
it resides within the specific color's bounding box and is adjacent (including 
diagonally) to at least one pixel of that color (either original or newly filled). 
This process repeats for each color until no more background pixels can be filled 
within their respective bounding boxes.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Use np.unique which is efficient for this
    unique, counts = np.unique(grid, return_counts=True)
    # Return the color (unique value) corresponding to the max count
    return unique[np.argmax(counts)]

def find_pixels_of_color(grid, color):
    """Finds the coordinates of all pixels with the specified color."""
    # np.where returns tuples of row indices and column indices
    rows, cols = np.where(grid == color)
    # zip them into (row, col) pairs
    return list(zip(rows, cols))

def calculate_bounding_box(coords):
    """Calculates the min/max row/col for a list of coordinates."""
    # Handle the case where a color might not be present
    if not coords:
        return None
    # Find min/max row and column from the list of coordinates
    min_row = min(r for r, c in coords)
    min_col = min(c for r, c in coords)
    max_row = max(r for r, c in coords)
    max_col = max(c for r, c in coords)
    return min_row, min_col, max_row, max_col

def get_neighbors(grid_shape, r, c):
    """Gets the coordinates of the 8 neighbors of a cell within grid bounds."""
    rows, cols = grid_shape
    neighbors = []
    # Iterate through the 3x3 neighbourhood centered at (r, c)
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the center cell itself
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            # Check if the neighbor coordinates are within the grid boundaries
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbors.append((nr, nc))
    return neighbors

def transform(input_grid):
    """
    Transforms the input grid by iteratively filling background pixels.

    1. Initialize output_grid as a copy of input_grid.
    2. Determine the background color.
    3. Find all non-background colors.
    4. For each non-background color C:
        a. Find initial pixels of color C.
        b. Calculate the bounding box for C.
        c. Enter a loop:
            i. Find background pixels within the bounding box that are adjacent to a pixel of color C (in the current output_grid state).
            ii. If no such pixels are found, exit the loop for color C.
            iii. Change these found pixels to color C in output_grid.
            iv. Repeat the loop.
    5. Return the final output_grid.
    """
    # Convert input list of lists to numpy array for efficient processing
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape
    
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_grid_np)

    # Determine the background color (most frequent)
    background_color = find_background_color(input_grid_np)

    # Identify all unique non-background colors present in the input
    unique_colors = np.unique(input_grid_np)
    non_background_colors = [c for c in unique_colors if c != background_color]

    # Process each non-background color separately
    for color in non_background_colors:
        # Find all initial coordinates of the current color
        pixel_coords = find_pixels_of_color(input_grid_np, color)
        
        # If this color wasn't present in the input, skip
        if not pixel_coords:
            continue

        # Calculate the bounding box for this color based on initial pixels
        bounding_box = calculate_bounding_box(pixel_coords)
        if bounding_box is None: # Should not happen if pixel_coords is not empty, but good practice
            continue
        min_row, min_col, max_row, max_col = bounding_box

        # Iteratively fill background pixels within the bounding box
        while True:
            pixels_changed_in_pass = False
            # Create a list to store coordinates of pixels to change in this pass
            # This avoids modifying the grid while iterating over it, which can cause issues
            coords_to_change = [] 
            
            # Iterate through each cell within the calculated bounding box
            for r in range(min_row, max_row + 1):
                for c in range(min_col, max_col + 1):
                    # Check if the pixel is currently background color
                    if output_grid[r, c] == background_color:
                        # Get its 8 neighbors' coordinates
                        neighbors = get_neighbors(output_grid.shape, r, c)
                        # Check if any neighbor currently has the target color
                        has_color_neighbor = False
                        for nr, nc in neighbors:
                            if output_grid[nr, nc] == color:
                                has_color_neighbor = True
                                break # Found a neighbor, no need to check others
                        
                        # If a neighbor has the color, mark this pixel for change
                        if has_color_neighbor:
                            coords_to_change.append((r, c))
            
            # If no pixels were marked for change in this pass, the fill is complete for this color
            if not coords_to_change:
                break # Exit the while loop for the current color
            
            # Apply the changes for this pass
            for r, c in coords_to_change:
                output_grid[r, c] = color
            # Since changes were made, set the flag to continue the while loop
            pixels_changed_in_pass = True # This flag isn't strictly needed due to the `if not coords_to_change: break` check, but confirms logic flow.


    # Convert the final numpy array back to a list of lists for the expected output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid by filling specific background pixels. 
For each non-background color C present in the input:
1. Determine the bounding box enclosing all pixels of color C.
2. Iterate through each pixel (r, c) within this bounding box.
3. If the pixel (r, c) in the *input* grid has the background color AND 
   at least one of its 8 neighbors in the *input* grid has color C, 
   then change the color of pixel (r, c) in the output grid to C.
The background color is the most frequent color in the input grid.
All other pixels retain their original color from the input.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Use np.unique which is efficient for this
    unique, counts = np.unique(grid, return_counts=True)
    # Return the color (unique value) corresponding to the max count
    return unique[np.argmax(counts)]

def find_pixels_of_color(grid, color):
    """Finds the coordinates of all pixels with the specified color."""
    # np.where returns tuples of row indices and column indices
    rows, cols = np.where(grid == color)
    # zip them into (row, col) pairs
    return list(zip(rows, cols))

def calculate_bounding_box(coords):
    """Calculates the min/max row/col for a list of coordinates."""
    # Handle the case where a color might not be present or has no pixels
    if not coords:
        return None
    # Find min/max row and column from the list of coordinates
    min_row = min(r for r, c in coords)
    min_col = min(c for r, c in coords)
    max_row = max(r for r, c in coords)
    max_col = max(c for r, c in coords)
    return min_row, min_col, max_row, max_col

def get_neighbor_coords(grid_shape, r, c):
    """Gets the coordinates of the 8 neighbors of a cell within grid bounds."""
    rows, cols = grid_shape
    neighbors = []
    # Iterate through the 3x3 neighbourhood centered at (r, c)
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the center cell itself
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            # Check if the neighbor coordinates are within the grid boundaries
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbors.append((nr, nc))
    return neighbors

def transform(input_grid):
    # Convert input list of lists to numpy array for efficient processing
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape
    
    # Initialize output_grid as a copy of the input grid. Modifications will be made to this copy.
    output_grid = np.copy(input_grid_np)

    # Determine the background color (most frequent)
    background_color = find_background_color(input_grid_np)

    # Identify all unique non-background colors present in the input
    unique_colors = np.unique(input_grid_np)
    non_background_colors = [c for c in unique_colors if c != background_color]

    # Process each non-background color separately
    for color in non_background_colors:
        # Find all coordinates of the current color C in the *input* grid
        pixel_coords = find_pixels_of_color(input_grid_np, color)
        
        # If this color wasn't present in the input, skip
        if not pixel_coords:
            continue

        # Calculate the bounding box for this color C based on its pixels in the input grid
        bounding_box = calculate_bounding_box(pixel_coords)
        if bounding_box is None: 
            continue
        min_row, min_col, max_row, max_col = bounding_box

        # Iterate through each cell (r, c) within the calculated bounding box
        for r in range(min_row, max_row + 1):
            for c in range(min_col, max_col + 1):
                # Check condition 1: Is the pixel (r, c) in the *input* grid the background color?
                if input_grid_np[r, c] == background_color:
                    # Check condition 2: Does pixel (r, c) have at least one neighbor with color C in the *input* grid?
                    neighbor_coords = get_neighbor_coords(input_grid_np.shape, r, c)
                    has_color_neighbor_in_input = False
                    for nr, nc in neighbor_coords:
                        if input_grid_np[nr, nc] == color:
                            has_color_neighbor_in_input = True
                            break # Found a neighbor, no need to check others
                    
                    # If both conditions are met, update the *output* grid
                    if has_color_neighbor_in_input:
                        output_grid[r, c] = color

    # Convert the final numpy array back to a list of lists for the expected output format
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid by filling specific background pixels. 
For each non-background color C present in the input:
1. Determine the bounding box enclosing all pixels of color C.
2. Iterate through each pixel (r, c) within this bounding box.
3. If the pixel (r, c) in the *input* grid has the background color AND 
   at least one of its 8 neighbors in the *input* grid has color C, 
   then change the color of pixel (r, c) in the output grid to C.
The background color is the most frequent color in the input grid.
All other pixels retain their original color from the input.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Use np.unique which is efficient for this
    unique, counts = np.unique(grid, return_counts=True)
    # Return the color (unique value) corresponding to the max count
    return unique[np.argmax(counts)]

def find_pixels_of_color(grid, color):
    """Finds the coordinates of all pixels with the specified color."""
    # np.where returns tuples of row indices and column indices
    rows, cols = np.where(grid == color)
    # zip them into (row, col) pairs
    return list(zip(rows, cols))

def calculate_bounding_box(coords):
    """Calculates the min/max row/col for a list of coordinates."""
    # Handle the case where a color might not be present or has no pixels
    if not coords:
        return None
    # Find min/max row and column from the list of coordinates
    min_row = min(r for r, c in coords)
    min_col = min(c for r, c in coords)
    max_row = max(r for r, c in coords)
    max_col = max(c for r, c in coords)
    return min_row, min_col, max_row, max_col

def get_neighbor_coords(grid_shape, r, c):
    """Gets the coordinates of the 8 neighbors of a cell within grid bounds."""
    rows, cols = grid_shape
    neighbors = []
    # Iterate through the 3x3 neighbourhood centered at (r, c)
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the center cell itself
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            # Check if the neighbor coordinates are within the grid boundaries
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbors.append((nr, nc))
    return neighbors

def transform(input_grid):
    # Convert input list of lists to numpy array for efficient processing
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape
    
    # Initialize output_grid as a copy of the input grid. Modifications will be made to this copy.
    output_grid = np.copy(input_grid_np)

    # Determine the background color (most frequent)
    background_color = find_background_color(input_grid_np)

    # Identify all unique non-background colors present in the input
    unique_colors = np.unique(input_grid_np)
    non_background_colors = [c for c in unique_colors if c != background_color]

    # Process each non-background color separately
    for color in non_background_colors:
        # Find all coordinates of the current color C in the *input* grid
        pixel_coords = find_pixels_of_color(input_grid_np, color)
        
        # If this color wasn't present in the input, skip
        if not pixel_coords:
            continue

        # Calculate the bounding box for this color C based on its pixels in the input grid
        bounding_box = calculate_bounding_box(pixel_coords)
        if bounding_box is None: 
            continue
        min_row, min_col, max_row, max_col = bounding_box

        # Iterate through each cell (r, c) within the calculated bounding box
        for r in range(min_row, max_row + 1):
            for c in range(min_col, max_col + 1):
                # Check condition 1: Is the pixel (r, c) in the *input* grid the background color?
                if input_grid_np[r, c] == background_color:
                    # Check condition 2: Does pixel (r, c) have at least one neighbor with color C in the *input* grid?
                    neighbor_coords = get_neighbor_coords(input_grid_np.shape, r, c)
                    has_color_neighbor_in_input = False
                    for nr, nc in neighbor_coords:
                        if input_grid_np[nr, nc] == color:
                            has_color_neighbor_in_input = True
                            break # Found a neighbor, no need to check others
                    
                    # If both conditions are met, update the *output* grid
                    if has_color_neighbor_in_input:
                        output_grid[r, c] = color

    # Convert the final numpy array back to a list of lists for the expected output format
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 1 1 1 1 1 3 1 3 3
3 3 3 3 1 1 1 1 3 3 3 3 1 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 3 3 3 3 3 4 4 4 4 4 3 4 3
3 3 3 3 3 3 3 3 4 4 4 4 3 4 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 4 3 4 4 4 4 4 4 4 3 3 3 3 3
3 3 3 4 3 3 3 4 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 1 1 3 3 3
3 3 3 3 1 1 1 1 3 3 3 1 1 3 3 3
3 3 3 3 1 1 1 1 3 3 3 1 1 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 1 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 4 4 4 4 4 4 4 3 3
3 3 3 3 3 3 3 4 4 4 4 4 4 4 3 3
3 3 3 3 3 3 3 4 4 4 4 4 4 4 3 3
3 3 3 4 4 3 3 4 4 4 4 4 3 3 3 3
3 3 3 4 4 3 3 4 4 4 4 4 3 3 3 3
3 3 3 4 4 3 3 4 4 4 4 4 3 3 3 3
3 3 3 3 3 3 3 4 4 4 4 4 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Match: False
Pixels Off: 30
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 17.045454545454533

## Example 2:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 17
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 16.346153846153868

## Example 3:
Input:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 8 1 8 1 1 1 1 1
1 1 1 1 8 1 8 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 8 8 1 8 8 8 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 1 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Transformed Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1 8 8 8 1 1 1 1 1
1 1 1 1 8 8 8 1 8 8 8 1 1 1 1 1
1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 8 8 8 8 8 8 8 8 8 8 8 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Match: False
Pixels Off: 35
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 19.886363636363654
*   **Assessment and Strategy:**
    *   The initial code correctly identified the core components: background color, non-background colors, bounding boxes, and the idea of filling based on adjacency. However, it failed because it performed a single pass check based *only* on the original input grid's neighbours.
    *   The results show that the filling process is iterative or expanding. A background pixel within the bounding box should be filled if it becomes adjacent to the target color *at any point* during the filling process for that color, not just based on the initial state.
    *   The strategy is to modify the transformation logic for each non-background color. After identifying the bounding box, we need to repeatedly scan the pixels within the box. In each scan (or iteration), we identify background pixels adjacent to *currently* colored pixels (of the target color) and change them. This process repeats until a scan finds no more pixels to change for that specific color. This ensures the "spreading" or "filling" effect observed in the examples.

*   **Metrics:**
    

*code_execution:*
```python
    import numpy as np
    from collections import Counter

    def find_background_color(grid):
        unique, counts = np.unique(grid, return_counts=True)
        return unique[np.argmax(counts)]

    def find_pixels_of_color(grid, color):
        rows, cols = np.where(grid == color)
        return list(zip(rows, cols))

    def calculate_bounding_box(coords):
        if not coords: return None
        min_row = min(r for r, c in coords)
        min_col = min(c for r, c in coords)
        max_row = max(r for r, c in coords)
        max_col = max(c for r, c in coords)
        return min_row, min_col, max_row, max_col

    # Example 1 Data
    input_1 = np.array([
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 4, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
    ])

    # Example 2 Data
    input_2 = np.array([
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]
    ])

    # Example 3 Data
    input_3 = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ])

    metrics = {}

    for i, input_grid in enumerate([input_1, input_2, input_3], 1):
        bg_color = find_background_color(input_grid)
        unique_colors = np.unique(input_grid)
        non_bg_colors = [c for c in unique_colors if c != bg_color]
        
        bounding_boxes = {}
        for color in non_bg_colors:
            coords = find_pixels_of_color(input_grid, color)
            bounding_boxes[color] = calculate_bounding_box(coords)
            
        metrics[f'example_{i}'] = {
            'background_color': bg_color,
            'non_background_colors': non_bg_colors,
            'bounding_boxes': bounding_boxes
        }

    import json
    print(json.dumps(metrics, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_FAILED
```
Traceback (most recent call last):
  File "<string>", line 108, in <module>
  File "__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "encoder.py", line 202, in encode
    chunks = list(chunks)
             ^^^^^^^^^^^^
  File "encoder.py", line 432, in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 439, in _iterencode
    o = _default(o)
        ^^^^^^^^^^^
  File "encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type int64 is not JSON serializable

```
*   **Assessment and Strategy:** (As stated previously)
    *   The initial code failed due to performing only a single-pass check based on the original input grid's neighbors.
    *   The filling process requires iteration: background pixels within a color's bounding box are filled if they become adjacent to that color *during* the filling process.
    *   The updated strategy involves iteratively scanning within each color's bounding box, changing background pixels adjacent to the target color (in the *current* grid state), and repeating until no more pixels change for that color.

*   **Metrics:**
    

*code_execution:*
```python
    import numpy as np
    from collections import Counter
    import json

    # Helper function to convert numpy types to Python types for JSON serialization
    def convert_types(obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, dict):
            return {k: convert_types(v) for k, v in obj.items()}
        elif isinstance(obj, (list, tuple)):
            return [convert_types(i) for i in obj]
        return obj

    def find_background_color(grid):
        unique, counts = np.unique(grid, return_counts=True)
        return unique[np.argmax(counts)]

    def find_pixels_of_color(grid, color):
        rows, cols = np.where(grid == color)
        return list(zip(rows, cols))

    def calculate_bounding_box(coords):
        if not coords: return None
        min_row = min(r for r, c in coords)
        min_col = min(c for r, c in coords)
        max_row = max(r for r, c in coords)
        max_col = max(c for r, c in coords)
        return min_row, min_col, max_row, max_col

    # Example 1 Data
    input_1 = np.array([
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 4, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
    ])

    # Example 2 Data
    input_2 = np.array([
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]
    ])

    # Example 3 Data
    input_3 = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ])

    metrics = {}

    for i, input_grid in enumerate([input_1, input_2, input_3], 1):
        bg_color = find_background_color(input_grid)
        unique_colors = np.unique(input_grid)
        non_bg_colors = [c for c in unique_colors if c != bg_color]
        
        bounding_boxes = {}
        for color in non_bg_colors:
            coords = find_pixels_of_color(input_grid, color)
            bounding_boxes[color] = calculate_bounding_box(coords)
            
        metrics[f'example_{i}'] = {
            'background_color': bg_color,
            'non_background_colors': non_bg_colors,
            'bounding_boxes': bounding_boxes
        }

    # Convert numpy types before printing
    metrics_converted = convert_types(metrics)
    print(json.dumps(metrics_converted, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_FAILED
```
Traceback (most recent call last):
  File "<string>", line 124, in <module>
  File "__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "encoder.py", line 202, in encode
    chunks = list(chunks)
             ^^^^^^^^^^^^
  File "encoder.py", line 432, in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 377, in _iterencode_dict
    raise TypeError(f'keys must be str, int, float, bool or None, '
TypeError: keys must be str, int, float, bool or None, not int64

```
*   **Assessment and Strategy:** (As stated previously)
    *   The core issue is the lack of iterative filling within each color's bounding box.
    *   The updated strategy involves a loop for each non-background color that repeatedly fills adjacent background pixels within the bounding box until no more changes occur.

*   **Metrics:**
    

*code_execution:*
```python
    import numpy as np
    from collections import Counter
    import json

    # Helper function to convert numpy types to Python types for JSON serialization
    # Now also handles keys in dictionaries
    def convert_types(obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, dict):
            # Convert keys and values
            return {convert_types(k): convert_types(v) for k, v in obj.items()}
        elif isinstance(obj, (list, tuple)):
            # Convert elements in lists/tuples
            # Special handling for bounding box tuples (don't iterate into them)
            if len(obj) == 4 and all(isinstance(x, np.integer) for x in obj):
                 return tuple(int(x) for x in obj)
            return [convert_types(i) for i in obj]
        return obj

    def find_background_color(grid):
        unique, counts = np.unique(grid, return_counts=True)
        return unique[np.argmax(counts)]

    def find_pixels_of_color(grid, color):
        rows, cols = np.where(grid == color)
        return list(zip(rows, cols))

    def calculate_bounding_box(coords):
        if not coords: return None
        min_row = min(r for r, c in coords)
        min_col = min(c for r, c in coords)
        max_row = max(r for r, c in coords)
        max_col = max(c for r, c in coords)
        # Return numpy integers initially, conversion happens later
        return np.int64(min_row), np.int64(min_col), np.int64(max_row), np.int64(max_col)

    # Example 1 Data
    input_1 = np.array([
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 4, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
    ])

    # Example 2 Data
    input_2 = np.array([
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]
    ])

    # Example 3 Data
    input_3 = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ])

    metrics = {}

    for i, input_grid in enumerate([input_1, input_2, input_3], 1):
        bg_color = find_background_color(input_grid)
        unique_colors = np.unique(input_grid)
        non_bg_colors = [c for c in unique_colors if c != bg_color]
        
        bounding_boxes = {}
        for color in non_bg_colors:
            coords = find_pixels_of_color(input_grid, color)
            bounding_boxes[color] = calculate_bounding_box(coords)
            
        metrics[f'example_{i}'] = {
            'background_color': bg_color,
            'non_background_colors': non_bg_colors,
            'bounding_boxes': bounding_boxes # Will be converted below
        }

    # Convert numpy types before printing
    metrics_converted = convert_types(metrics)
    print(json.dumps(metrics_converted, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{
  "example_1": {
    "background_color": 3,
    "non_background_colors": [
      1,
      4
    ],
    "bounding_boxes": {
      "1": [
        2,
        4,
        9,
        12
      ],
      "4": [
        11,
        3,
        17,
        13
      ]
    }
  },
  "example_2": {
    "background_color": 8,
    "non_background_colors": [
      3
    ],
    "bounding_boxes": {
      "3": [
        1,
        3,
        9,
        9
      ]
    }
  },
  "example_3": {
    "background_color": 1,
    "non_background_colors": [
      8
    ],
    "bounding_boxes": {
      "8": [
        2,
        2,
        17,
        12
      ]
    }
  }
}

```
*   **YAML Fact Sheet:**
    
```yaml
    task_description: Iteratively fill background pixels within the bounding box of each non-background color group if they are adjacent (8-way) to a pixel of that color.

    elements:
      - role: background
        property: most frequent color in the input grid.
        example_1: green (3)
        example_2: azure (8)
        example_3: blue (1)
      - role: objects
        property: groups of contiguous or scattered pixels of the same non-background color C.
        example_1: blue (1), yellow (4)
        example_2: green (3)
        example_3: azure (8)
      - role: bounding_box
        property: the smallest rectangle enclosing all pixels of a specific non-background color C in the original input.
        example_1_color_1: (row_min=2, col_min=4, row_max=9, col_max=12)
        example_1_color_4: (row_min=11, col_min=3, row_max=17, col_max=13)
        example_2_color_3: (row_min=1, col_min=3, row_max=9, col_max=9)
        example_3_color_8: (row_min=2, col_min=2, row_max=17, col_max=12)
      - role: adjacency
        property: includes 8 neighbors (cardinal and diagonal).

    transformation:
      - action: initialize_output
        input: input grid
        output: a mutable copy of the input grid (e.g., numpy array).
      - action: identify_background_color
        input: input grid
        output: background color value.
      - action: identify_non_background_colors
        input: input grid
        output: set of color values present, excluding background.
      - action: process_each_non_background_color
        steps:
          - find_initial_pixels: locate all pixels of the current non-background color C in the input grid.
          - calculate_bounding_box: determine the min/max row/column for pixels of color C based on the initial pixels.
          - iterative_fill_loop:
              - condition: loop continues as long as pixels were changed in the previous pass.
              - pass_setup: create a list to store coordinates of pixels to change in this pass.
              - iterate_within_bounding_box: examine each pixel (r, c) within the calculated box.
              - check_pixel_condition:
                  - condition_1: the pixel (r, c) in the *current output grid* has the background color.
                  - condition_2: the pixel (r, c) has at least one neighbor (8-way adjacency) in the *current output grid* with color C.
              - mark_for_update: if both conditions are met, add (r, c) to the list of pixels to change.
              - update_output_grid: after checking all pixels in the box, change the color of all marked pixels in the output grid to C.
              - update_loop_condition: set a flag if any pixels were changed in this pass.
          - repeat_or_next_color: if pixels were changed, repeat the iterative_fill_loop pass; otherwise, proceed to the next non-background color.
      - action: finalize_output
        input: the modified mutable grid.
        output: the final grid in the required format (e.g., list of lists).

    relationship:
      - A background pixel changes to color C if and only if:
        1. It resides within the bounding box defined by the *initial* positions of all pixels of color C in the input.
        2. It is adjacent (8-way) to at least one pixel that *currently* has color C (either from the input or filled in a previous iteration for this color).
      - This filling process for color C repeats until no more background pixels within its bounding box can be filled based on adjacency to existing C-colored pixels.
    ```


*   **Natural Language Program:**
    1.  Create a mutable copy of the input grid (this will become the output grid).
    2.  Determine the background color by finding the most frequent pixel value in the input grid.
    3.  Identify all unique pixel colors present in the input grid, other than the background color.
    4.  For each unique non-background color `C` found:
        a.  Find the coordinates of all pixels in the *original input* grid that have the color `C`.
        b.  If no pixels of color `C` exist, skip to the next color.
        c.  Calculate the minimum bounding box (minimum row, minimum column, maximum row, maximum column) that encloses all found coordinates for color `C` from the *original input*.
        d.  Start an iterative filling process for color `C`:
            i.  Initialize a flag `pixels_changed_this_pass` to `False`.
            ii. Create an empty list `pixels_to_change` to store coordinates `(r, c)` that should be colored `C` in this pass.
            iii. Iterate through every grid cell `(r, c)` within the calculated bounding box (from minimum row to maximum row, and minimum column to maximum column).
            iv. Check the color of the cell `(r, c)` in the *current state* of the output grid. If it is the background color:
                1.  Examine all 8 neighbors (horizontal, vertical, and diagonal) of the cell `(r, c)`.
                2.  Check if any of these neighbors, in the *current state* of the output grid, have the color `C`.
                3.  If at least one neighbor has color `C`, add the coordinates `(r, c)` to the `pixels_to_change` list.
            v.  After iterating through all cells in the bounding box, check if the `pixels_to_change` list is empty.
                1.  If it is *not* empty, set `pixels_changed_this_pass` to `True`. Then, for every coordinate `(r, c)` in the `pixels_to_change` list, update the output grid by setting the color at `(r, c)` to `C`.
                2.  If it *is* empty, it means no more pixels can be filled for color `C` in this pass, so break out of the iterative filling process (step 4d).
            vi. If `pixels_changed_this_pass` is `True`, repeat the iterative filling process starting from step 4.d.i.
    5.  After processing all non-background colors, return the final state of the output grid.
