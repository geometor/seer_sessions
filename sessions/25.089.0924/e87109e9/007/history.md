
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 1 1 1 1 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```


**output:**
```
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
7 7 7 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```

Okay, let's break down this task.

**Perception of Elements:**

1.  **Input Structure:** The input grid is consistently divided into two main sections separated by a horizontal line of gray (5) pixels.
2.  **Top Section ("Keys"):** This section appears to define a set of rules or parameters. It contains small, isolated patterns bordered by gray (5). Each pattern consists of a single non-white pixel adjacent to three white (0) pixels. The non-white colors in these patterns vary across examples (e.g., blue, magenta, yellow, red in train\_1).
3.  **Bottom Section ("Main Grid"):** This is the primary canvas for the transformation. It has a background color (green in train\_1, blue in train\_2, orange in train\_3) and contains various colored objects or shapes. Notably, a 2x2 square of azure (8) pixels is always present somewhere within this section in the input, though its location varies.
4.  **Output Structure:** The output grid corresponds in size to the *bottom section* (main grid) of the input. The top "key" section is absent.
5.  **Transformation:** The core transformation involves changing parts of the main grid to azure (8). The original shapes and background are partially preserved. The azure color seems to spread or be stamped in 2x2 blocks. Crucially, areas containing the specific colors identified in the top "key" section seem resistant to being overwritten by azure. The original 2x2 azure block in the input does not seem to dictate the *location* of the stamping, but rather the *color* used for stamping (azure) and perhaps the *size* (2x2).

**YAML Fact Documentation:**


```yaml
task_context:
  description: Transform the main grid based on color keys defined in a separate top panel.
  input_structure:
    - type: separator
      color: gray (5)
      orientation: horizontal
      location: divides grid into top and bottom sections
    - type: key_panel
      location: top section (above separator)
      content: multiple gray-bordered 1x4 or 4x1 patterns containing one non-white color and three white pixels.
      purpose: defines a set of 'protected' colors.
    - type: main_grid
      location: bottom section (below separator)
      content: background color, various colored shapes, includes a 2x2 azure (8) square.
      purpose: the area to be transformed.
  output_structure:
    - type: grid
      size: matches the input's main_grid size.
      content: modified version of the input's main_grid.

objects:
  - id: key_colors
    source: non-white pixels adjacent to white pixels in the key_panel.
    property: 'protected' - these colors resist overwriting.
  - id: main_grid_pixels
    source: all pixels in the main_grid section of the input.
  - id: stamp_color
    value: azure (8)
  - id: stamp_unit
    shape: 2x2 square

actions:
  - action: extract_keys
    input: key_panel
    output: set of protected key_colors
  - action: copy_grid
    input: main_grid
    output: initial output_grid
  - action: iterate_and_stamp
    target: output_grid
    unit: 2x2 blocks
    condition: check if any pixel within the corresponding 2x2 block in the input main_grid belongs to the set of key_colors.
    effect:
      - if condition is FALSE: overwrite the 2x2 block in the output_grid with the stamp_color (azure).
      - if condition is TRUE: leave the 2x2 block in the output_grid unchanged (preserving original colors).

relationships:
  - type: protection
    subject: pixels in the main_grid matching key_colors
    effect: prevent overwriting by the azure stamp in their containing 2x2 block.
  - type: spatial_grouping
    granularity: 2x2 blocks
    purpose: determines the unit of checking and potential stamping.
```


**Natural Language Program:**

1.  Separate the input grid into two parts: the "key panel" (top section above the solid gray line) and the "main grid" (bottom section below the gray line).
2.  Identify the set of "protected colors" by finding all unique non-white colors that are located next to a white pixel within the gray-bordered patterns in the key panel.
3.  Create a new grid (the output grid) that is initially an exact copy of the input's main grid.
4.  Iterate through every possible 2x2 block of pixels in the input's main grid. Define a block by its top-left corner's row (r) and column (c). The block includes pixels at (r, c), (r+1, c), (r, c+1), and (r+1, c+1).
5.  For each 2x2 block in the input's main grid, check if *any* of its four pixels have a color that is present in the set of "protected colors" identified in step 2.
6.  If *none* of the four pixels in the input 2x2 block match any of the protected colors, then change the corresponding 2x2 block of pixels in the output grid to be entirely azure (8).
7.  If *at least one* pixel in the input 2x2 block *does* match a protected color, make no changes to the corresponding 2x2 block in the output grid (it retains the colors copied in step 3).
8.  After iterating through all possible 2x2 blocks, the resulting output grid is the final result.
```python
import numpy as np

"""
Transformation Rule:

1. Separate the input grid into a "key panel" (top section above the solid gray line) 
   and a "main grid" (bottom section below the gray line).
2. Identify a set of "protected colors" from the key panel. A color is protected if it's 
   a non-white (0), non-gray (5) pixel within the key panel that is adjacent 
   (up, down, left, or right) to at least one white (0) pixel.
3. Create an output grid initialized as a copy of the input's main grid.
4. Iterate through the main grid using a 2x2 sliding window. 
5. For each 2x2 window in the input's main grid, check if *any* of its four pixels 
   contain a color present in the set of protected colors.
6. If *none* of the pixels in the 2x2 window are protected colors, change the 
   corresponding 2x2 block in the output grid to be entirely azure (8).
7. If *at least one* pixel in the 2x2 window is a protected color, leave the 
   corresponding 2x2 block in the output grid unchanged.
8. Return the final output grid.
"""

def _find_separator_row(grid):
    """Finds the row index of the first solid horizontal gray (5) line."""
    for r in range(grid.shape[0]):
        if np.all(grid[r, :] == 5):
            return r
    return -1 # Should not happen based on task structure

def _extract_protected_colors(key_panel):
    """Extracts protected colors from the key panel."""
    protected_colors = set()
    rows, cols = key_panel.shape
    for r in range(rows):
        for c in range(cols):
            color = key_panel[r, c]
            # Ignore background (white 0) and borders (gray 5)
            if color != 0 and color != 5:
                # Check neighbors (4-connectivity)
                has_white_neighbor = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and key_panel[nr, nc] == 0:
                        has_white_neighbor = True
                        break
                if has_white_neighbor:
                    protected_colors.add(color)
    return protected_colors

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    
    # 1. Separate the input grid
    separator_row = _find_separator_row(input_np)
    if separator_row == -1:
        # Handle cases where separator might not exist as expected, 
        # though based on examples it always does.
        # For now, assume the whole grid is the main grid if no separator.
        key_panel = np.array([[]], dtype=int) # Empty key panel
        main_grid = input_np
    else:
        key_panel = input_np[:separator_row, :]
        main_grid = input_np[separator_row + 1:, :]

    # 2. Identify protected colors
    protected_colors = _extract_protected_colors(key_panel)
    
    # 3. Initialize output grid as a copy of the main grid
    output_grid = main_grid.copy()
    rows, cols = main_grid.shape
    stamp_color = 8 # Azure

    # 4. Iterate through the main grid with a 2x2 window
    # Iterate up to rows-1 and cols-1 to define the top-left corner of the 2x2 block
    for r in range(rows - 1):
        for c in range(cols - 1):
            
            # 5. Check if any pixel in the 2x2 window is protected
            is_protected = False
            window = main_grid[r:r+2, c:c+2] # Get the 2x2 slice from the original main_grid
            
            for pixel_color in window.flat: # Iterate through the 4 pixels in the window
                if pixel_color in protected_colors:
                    is_protected = True
                    break # Found a protected color, no need to check further for this window
            
            # 6. If not protected, stamp with azure
            if not is_protected:
                output_grid[r:r+2, c:c+2] = stamp_color # Modify the output_grid
                
            # 7. If protected, do nothing (output_grid retains the copied values)

    # 8. Return the final output grid
    return output_grid.tolist() # Convert back to list of lists if needed

```
```python
import numpy as np

"""
Transformation Rule:

1. Identify the functional horizontal separator line within the input grid. This 
   is the *last* row index consisting entirely of gray (5) pixels.
2. Split the input grid based on the separator row:
   - The "key panel" is the section between row 0 (exclusive, assuming row 0 is a border) 
     and the separator row (exclusive).
   - The "main grid" includes all rows below the separator row.
3. Extract a set of "protected colors" from the key panel. A color is protected if 
   it's not white (0), not gray (5), and is adjacent (4-connectivity) to at least 
   one white (0) pixel within the key panel.
4. Initialize an output grid as an exact copy of the input's main grid.
5. Iterate through the input's main grid using a 2x2 sliding window, defined by its 
   top-left corner (r, c).
6. For each 2x2 window in the input's main grid:
   - Check if *any* of the four pixels within this window contains a color present 
     in the set of protected colors.
   - If *none* of the pixels are protected colors, change the corresponding 2x2 
     block in the output grid to be entirely azure (8).
   - If *at least one* pixel is a protected color, leave the corresponding 2x2 
     block in the output grid unchanged.
7. Return the final output grid.
"""

def _find_separator_row(grid):
    """
    Finds the row index of the last solid horizontal gray (5) line.
    Assumes the first row might also be gray but acts as a border.
    """
    separator_row = -1
    for r in range(grid.shape[0]):
        if np.all(grid[r, :] == 5):
            separator_row = r # Keep track of the latest one found
    # If the only gray line found was row 0, maybe it wasn't a separator?
    # Based on examples, separator is distinct from row 0 border.
    # If separator_row remains 0 after checking all rows, and row 0 was indeed gray,
    # it implies no *functional* separator was found below the top border.
    # However, given the examples, a separator row > 0 always exists.
    # If separator_row is still -1, no gray row found at all.
    return separator_row

def _extract_protected_colors(key_panel):
    """
    Extracts protected colors from the key panel.
    A color is protected if it's non-white(0)/non-gray(5) and adjacent to white(0).
    """
    protected_colors = set()
    rows, cols = key_panel.shape
    if rows == 0 or cols == 0: 
        return protected_colors # Handle empty key panel

    for r in range(rows):
        for c in range(cols):
            color = key_panel[r, c]
            # Ignore background (white 0) and borders (gray 5)
            if color != 0 and color != 5:
                # Check neighbors (4-connectivity) for white pixels
                has_white_neighbor = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    # Check bounds before accessing neighbor
                    if 0 <= nr < rows and 0 <= nc < cols and key_panel[nr, nc] == 0:
                        has_white_neighbor = True
                        break # Found a white neighbor, no need to check others
                if has_white_neighbor:
                    protected_colors.add(color)
    return protected_colors

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    
    # 1. Identify Separator
    separator_row = _find_separator_row(input_np)
    
    # Handle cases where separator might not be found as expected
    if separator_row <= 0: 
         # If separator is row 0 or not found, assume no key panel
         # and the whole grid (or grid minus row 0 border if present) is the main grid.
         # This requires refinement if such cases appear, but based on examples:
         if separator_row == 0 and np.all(input_np[0,:] == 5):
              key_panel = np.array([[]], dtype=int) # No functional key panel
              main_grid = input_np[1:, :]          # Main grid is below row 0 border
         else: # No separator found or it's negative
              key_panel = np.array([[]], dtype=int) 
              main_grid = input_np # Assume whole grid is main grid
    else:
        # 2. Split Grid (assuming row 0 is border, key panel is between row 0 and separator)
        # Key panel is rows from 1 up to (but not including) separator_row
        key_panel = input_np[1:separator_row, :] 
        # Main grid is rows from separator_row + 1 to the end
        main_grid = input_np[separator_row + 1:, :]

    # 3. Extract Protected Colors
    protected_colors = _extract_protected_colors(key_panel)
    
    # 4. Initialize Output
    # Check if main_grid is empty after splitting
    if main_grid.size == 0:
        return [] # Return empty list if main grid is empty
        
    output_grid = main_grid.copy()
    rows, cols = main_grid.shape
    stamp_color = 8 # Azure

    # 5. Iterate and Check (using 2x2 window)
    # Iterate up to rows-2 and cols-2 for the top-left corner of the 2x2 block
    for r in range(rows - 1):
        for c in range(cols - 1):
            
            # Get the 2x2 window from the *original* main_grid
            window = main_grid[r:r+2, c:c+2] 
            
            # 6. Apply Protection Rule
            is_protected = False
            # Check if any pixel color in the window is in the protected set
            for pixel_color in window.flat: 
                if pixel_color in protected_colors:
                    is_protected = True
                    break # Found a protected color, stop checking this window
            
            # If the block is NOT protected, stamp it with azure
            if not is_protected:
                output_grid[r:r+2, c:c+2] = stamp_color # Modify the output_grid
                
            # If protected, the output_grid retains the initially copied values for this block

    # 7. Finalize and Return
    return output_grid.tolist() # Convert back to list of lists
```
```python
import numpy as np

"""
Transformation Rule:

1. Identify the 'separator row' which is the last row in the input grid 
   consisting entirely of gray (5) pixels.
2. Divide the input grid:
   - The 'key panel' consists of the rows between the top row (row 0, assumed 
     to be a gray border) and the separator row (exclusive).
   - The 'main grid' consists of all rows below the separator row.
3. Extract 'explicit key colors' from the key panel: Find all unique colors 
   that are not white (0) and not gray (5), and are adjacent (4-connectivity) 
   to at least one white (0) pixel within the key panel.
4. Determine the 'background color' of the main grid: Find the most frequent 
   color in the main grid. If azure (8) is present, exclude it when 
   determining the most frequent color, unless the grid *only* contains azure 
   or is empty.
5. Create the 'protected colors set' by combining the 'explicit key colors' 
   and the 'background color'. Add azure (8) to this set as well, as the 
   stamp color itself should not be overwritten.
6. Create a new grid (the output grid) that is initially an exact copy of 
   the input's main grid.
7. Iterate through every possible 2x2 block of pixels in the *input's* main 
   grid, defined by its top-left corner (r, c).
8. For each 2x2 block in the input's main grid, check if *any* of its four 
   pixels have a color that is present in the 'protected colors set'.
9. If *none* of the four pixels in the input 2x2 block match any of the 
   protected colors, then change the corresponding 2x2 block of pixels in 
   the *output* grid to be entirely azure (8).
10. If *at least one* pixel in the input 2x2 block *does* match a protected 
    color, make no changes to the corresponding 2x2 block in the output grid.
11. Return the final output grid.
"""

def _find_separator_row(grid):
    """
    Finds the row index of the last solid horizontal gray (5) line.
    Returns -1 if no such line exists.
    """
    separator_row = -1
    for r in range(grid.shape[0]):
        if np.all(grid[r, :] == 5):
            separator_row = r # Keep track of the latest one found
    return separator_row

def _extract_explicit_keys(key_panel):
    """
    Extracts explicitly protected colors from the key panel.
    A color is protected if it's non-white(0)/non-gray(5) and adjacent to white(0).
    """
    protected_colors = set()
    rows, cols = key_panel.shape
    if rows == 0 or cols == 0: 
        return protected_colors # Handle empty key panel

    for r in range(rows):
        for c in range(cols):
            color = key_panel[r, c]
            # Ignore background (white 0) and borders (gray 5)
            if color != 0 and color != 5:
                # Check neighbors (4-connectivity) for white pixels
                has_white_neighbor = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    # Check bounds before accessing neighbor
                    if 0 <= nr < rows and 0 <= nc < cols and key_panel[nr, nc] == 0:
                        has_white_neighbor = True
                        break # Found a white neighbor, no need to check others
                if has_white_neighbor:
                    protected_colors.add(color)
    return protected_colors

def _determine_background_color(grid, stamp_color=8):
    """
    Determines the most frequent color in the grid, excluding the stamp_color
    unless it's the only color present or the grid is mostly stamp_color.
    Returns -1 if grid is empty.
    """
    if grid.size == 0:
        return -1 # No background color for an empty grid

    colors, counts = np.unique(grid, return_counts=True)
    
    if len(colors) == 1:
        return colors[0] # Only one color exists, it's the background

    # Create a mask to exclude the stamp color
    non_stamp_mask = (colors != stamp_color)
    
    # Check if there are any colors other than the stamp color
    if np.any(non_stamp_mask):
        # Find the index of the max count among non-stamp colors
        idx_max_non_stamp = np.argmax(counts[non_stamp_mask])
        # Get the color corresponding to that index
        background_color = colors[non_stamp_mask][idx_max_non_stamp]
    else:
        # Only the stamp color exists in the grid
        background_color = stamp_color
        
    return background_color


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    stamp_color = 8 # Azure
    
    # 1. Identify Separator
    separator_row = _find_separator_row(input_np)
    
    # 2. Split Grid
    # Handle edge cases: no separator, or separator is the first row
    if separator_row <= 0: 
         # Treat row 0 as border if it's gray, otherwise whole grid is main
         if separator_row == 0 and np.all(input_np[0,:] == 5):
              key_panel = np.array([[]], dtype=int) # No functional key panel
              main_grid = input_np[1:, :]          # Main grid is below row 0 border
         else: # No separator found or it's negative
              key_panel = np.array([[]], dtype=int) 
              main_grid = input_np                 # Assume whole grid is main grid
    else:
        # Key panel is between row 0 (exclusive) and separator row (exclusive)
        key_panel = input_np[1:separator_row, :] 
        # Main grid is below separator row (inclusive)
        main_grid = input_np[separator_row + 1:, :]

    # Check if main_grid is empty after splitting
    if main_grid.size == 0:
        return [] # Return empty list if main grid is empty

    # 3. Extract Explicit Keys
    explicit_keys = _extract_explicit_keys(key_panel)
    
    # 4. Determine Background Color
    background_color = _determine_background_color(main_grid, stamp_color)
    
    # 5. Define Protected Colors Set
    protected_colors_set = set(explicit_keys)
    if background_color != -1: # Add background if found
        protected_colors_set.add(background_color)
    # Also protect the stamp color itself, ensuring areas originally azure
    # aren't stamped over if they happen to be in an unprotected block
    # Although, stamping azure with azure has no effect, this clarifies intent.
    # protected_colors_set.add(stamp_color) # Decided against adding stamp color explicitly
                                            # as stamping azure with azure has no visible effect.
                                            # The background rule should handle azure backgrounds.


    # 6. Initialize Output Grid
    output_grid = main_grid.copy()
    rows, cols = main_grid.shape

    # 7. Iterate through main_grid with a 2x2 window
    # Loop bounds ensure the 2x2 window fits within the grid
    for r in range(rows - 1):
        for c in range(cols - 1):
            
            # 8. Get the 2x2 window from the *input* main_grid
            window = main_grid[r:r+2, c:c+2] 
            
            # Check if any pixel color in the window is in the protected set
            is_protected = False
            for pixel_color in window.flat: 
                if pixel_color in protected_colors_set:
                    is_protected = True
                    break # Found a protected color, stop checking this window
            
            # 9. If the block is NOT protected, stamp it with azure
            if not is_protected:
                output_grid[r:r+2, c:c+2] = stamp_color # Modify the output_grid
                
            # 10. If protected, the output_grid retains the initially copied values

    # 11. Finalize and Return
    return output_grid.tolist() # Convert back to list of lists
```

Previous Code:
```python
import numpy as np

"""
Transformation Rule:

1. Identify the 'separator row' which is the last row in the input grid 
   consisting entirely of gray (5) pixels.
2. Divide the input grid:
   - The 'key panel' consists of the rows between the top row (row 0, assumed 
     to be a gray border) and the separator row (exclusive).
   - The 'main grid' consists of all rows below the separator row.
3. Extract 'explicit key colors' from the key panel: Find all unique colors 
   that are not white (0) and not gray (5), and are adjacent (4-connectivity) 
   to at least one white (0) pixel within the key panel.
4. Determine the 'background color' of the main grid: Find the most frequent 
   color in the main grid. If azure (8) is present, exclude it when 
   determining the most frequent color, unless the grid *only* contains azure 
   or is empty.
5. Create the 'protected colors set' by combining the 'explicit key colors' 
   and the 'background color'. Add azure (8) to this set as well, as the 
   stamp color itself should not be overwritten.
6. Create a new grid (the output grid) that is initially an exact copy of 
   the input's main grid.
7. Iterate through every possible 2x2 block of pixels in the *input's* main 
   grid, defined by its top-left corner (r, c).
8. For each 2x2 block in the input's main grid, check if *any* of its four 
   pixels have a color that is present in the 'protected colors set'.
9. If *none* of the four pixels in the input 2x2 block match any of the 
   protected colors, then change the corresponding 2x2 block of pixels in 
   the *output* grid to be entirely azure (8).
10. If *at least one* pixel in the input 2x2 block *does* match a protected 
    color, make no changes to the corresponding 2x2 block in the output grid.
11. Return the final output grid.
"""

def _find_separator_row(grid):
    """
    Finds the row index of the last solid horizontal gray (5) line.
    Returns -1 if no such line exists.
    """
    separator_row = -1
    for r in range(grid.shape[0]):
        if np.all(grid[r, :] == 5):
            separator_row = r # Keep track of the latest one found
    return separator_row

def _extract_explicit_keys(key_panel):
    """
    Extracts explicitly protected colors from the key panel.
    A color is protected if it's non-white(0)/non-gray(5) and adjacent to white(0).
    """
    protected_colors = set()
    rows, cols = key_panel.shape
    if rows == 0 or cols == 0: 
        return protected_colors # Handle empty key panel

    for r in range(rows):
        for c in range(cols):
            color = key_panel[r, c]
            # Ignore background (white 0) and borders (gray 5)
            if color != 0 and color != 5:
                # Check neighbors (4-connectivity) for white pixels
                has_white_neighbor = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    # Check bounds before accessing neighbor
                    if 0 <= nr < rows and 0 <= nc < cols and key_panel[nr, nc] == 0:
                        has_white_neighbor = True
                        break # Found a white neighbor, no need to check others
                if has_white_neighbor:
                    protected_colors.add(color)
    return protected_colors

def _determine_background_color(grid, stamp_color=8):
    """
    Determines the most frequent color in the grid, excluding the stamp_color
    unless it's the only color present or the grid is mostly stamp_color.
    Returns -1 if grid is empty.
    """
    if grid.size == 0:
        return -1 # No background color for an empty grid

    colors, counts = np.unique(grid, return_counts=True)
    
    if len(colors) == 1:
        return colors[0] # Only one color exists, it's the background

    # Create a mask to exclude the stamp color
    non_stamp_mask = (colors != stamp_color)
    
    # Check if there are any colors other than the stamp color
    if np.any(non_stamp_mask):
        # Find the index of the max count among non-stamp colors
        idx_max_non_stamp = np.argmax(counts[non_stamp_mask])
        # Get the color corresponding to that index
        background_color = colors[non_stamp_mask][idx_max_non_stamp]
    else:
        # Only the stamp color exists in the grid
        background_color = stamp_color
        
    return background_color


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    stamp_color = 8 # Azure
    
    # 1. Identify Separator
    separator_row = _find_separator_row(input_np)
    
    # 2. Split Grid
    # Handle edge cases: no separator, or separator is the first row
    if separator_row <= 0: 
         # Treat row 0 as border if it's gray, otherwise whole grid is main
         if separator_row == 0 and np.all(input_np[0,:] == 5):
              key_panel = np.array([[]], dtype=int) # No functional key panel
              main_grid = input_np[1:, :]          # Main grid is below row 0 border
         else: # No separator found or it's negative
              key_panel = np.array([[]], dtype=int) 
              main_grid = input_np                 # Assume whole grid is main grid
    else:
        # Key panel is between row 0 (exclusive) and separator row (exclusive)
        key_panel = input_np[1:separator_row, :] 
        # Main grid is below separator row (inclusive)
        main_grid = input_np[separator_row + 1:, :]

    # Check if main_grid is empty after splitting
    if main_grid.size == 0:
        return [] # Return empty list if main grid is empty

    # 3. Extract Explicit Keys
    explicit_keys = _extract_explicit_keys(key_panel)
    
    # 4. Determine Background Color
    background_color = _determine_background_color(main_grid, stamp_color)
    
    # 5. Define Protected Colors Set
    protected_colors_set = set(explicit_keys)
    if background_color != -1: # Add background if found
        protected_colors_set.add(background_color)
    # Also protect the stamp color itself, ensuring areas originally azure
    # aren't stamped over if they happen to be in an unprotected block
    # Although, stamping azure with azure has no effect, this clarifies intent.
    # protected_colors_set.add(stamp_color) # Decided against adding stamp color explicitly
                                            # as stamping azure with azure has no visible effect.
                                            # The background rule should handle azure backgrounds.


    # 6. Initialize Output Grid
    output_grid = main_grid.copy()
    rows, cols = main_grid.shape

    # 7. Iterate through main_grid with a 2x2 window
    # Loop bounds ensure the 2x2 window fits within the grid
    for r in range(rows - 1):
        for c in range(cols - 1):
            
            # 8. Get the 2x2 window from the *input* main_grid
            window = main_grid[r:r+2, c:c+2] 
            
            # Check if any pixel color in the window is in the protected set
            is_protected = False
            for pixel_color in window.flat: 
                if pixel_color in protected_colors_set:
                    is_protected = True
                    break # Found a protected color, stop checking this window
            
            # 9. If the block is NOT protected, stamp it with azure
            if not is_protected:
                output_grid[r:r+2, c:c+2] = stamp_color # Modify the output_grid
                
            # 10. If protected, the output_grid retains the initially copied values

    # 11. Finalize and Return
    return output_grid.tolist() # Convert back to list of lists
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```
Match: False
Pixels Off: 112
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 49.12280701754386

## Example 2:
Input:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 1 1 1 1 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```
Transformed Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```
Match: False
Pixels Off: 120
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 52.63157894736844

## Example 3:
Input:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```
Expected Output:
```
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
7 7 7 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```
Transformed Output:
```
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```
Match: False
Pixels Off: 134
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 58.7719298245614
**General Assessment:**

The initial code failed because it incorrectly assumed the background color of the main grid should be protected. The comparison between the expected outputs and the transformed outputs clearly shows that areas consisting solely of the background color are indeed being overwritten with azure (8) if they don't overlap with any explicitly protected key colors within a 2x2 block. The core logic of identifying the key panel, main grid, and explicit key colors appears sound, as does the 2x2 stamping mechanism. The error lies specifically in adding the main grid's background color to the set of protected colors.

**Strategy:**

The strategy is to remove the logic for determining and protecting the background color. Protection should only be afforded to the colors explicitly identified in the key panel.

**Metrics and Analysis:**

Let's verify the protected colors identified by the previous code versus the colors that *should* be protected based on the refined understanding (only explicit keys).



*code_execution:*
```python
import numpy as np

def _find_separator_row(grid):
    separator_row = -1
    for r in range(grid.shape[0]):
        if np.all(grid[r, :] == 5):
            separator_row = r
    return separator_row

def _extract_explicit_keys(key_panel):
    protected_colors = set()
    rows, cols = key_panel.shape
    if rows == 0 or cols == 0: return protected_colors
    for r in range(rows):
        for c in range(cols):
            color = key_panel[r, c]
            if color != 0 and color != 5:
                has_white_neighbor = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and key_panel[nr, nc] == 0:
                        has_white_neighbor = True
                        break
                if has_white_neighbor:
                    protected_colors.add(color)
    return protected_colors

def _determine_background_color(grid, stamp_color=8):
    if grid.size == 0: return -1
    colors, counts = np.unique(grid, return_counts=True)
    if len(colors) == 1: return colors[0]
    non_stamp_mask = (colors != stamp_color)
    if np.any(non_stamp_mask):
        idx_max_non_stamp = np.argmax(counts[non_stamp_mask])
        background_color = colors[non_stamp_mask][idx_max_non_stamp]
    else:
        background_color = stamp_color
    return background_color

# --- Inputs (abbreviated for clarity) ---
input_1_list = [
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [5, 1, 0, 0, 0, 5, 5, 6, 0, 0, 0, 5, 5, 4, 0, 0, 0, 5, 5, 2, 0, 0, 0, 5],
    [5, 1, 0, 0, 0, 5, 5, 6, 0, 0, 0, 5, 5, 4, 0, 0, 0, 5, 5, 2, 0, 0, 0, 5],
    [5, 1, 0, 0, 0, 5, 5, 6, 0, 0, 0, 5, 5, 4, 0, 0, 0, 5, 5, 2, 0, 0, 0, 5],
    [5, 1, 0, 0, 0, 5, 5, 6, 0, 0, 0, 5, 5, 4, 0, 0, 0, 5, 5, 2, 0, 0, 0, 5],
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3],
    [1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3]
]
input_2_list = [
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [5, 0, 0, 0, 2, 5, 5, 4, 0, 0, 0, 5, 5, 0, 0, 0, 6, 5, 5, 3, 0, 0, 0, 5],
    [5, 0, 0, 0, 2, 5, 5, 4, 0, 0, 0, 5, 5, 0, 0, 0, 6, 5, 5, 3, 0, 0, 0, 5],
    [5, 0, 0, 0, 2, 5, 5, 4, 0, 0, 0, 5, 5, 0, 0, 0, 6, 5, 5, 3, 0, 0, 0, 5],
    [5, 0, 0, 0, 2, 5, 5, 4, 0, 0, 0, 5, 5, 0, 0, 0, 6, 5, 5, 3, 0, 0, 0, 5],
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1],
    [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
input_3_list = [
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [5, 0, 0, 0, 4, 5, 5, 6, 0, 0, 0, 5, 5, 3, 0, 0, 0, 5, 5, 0, 0, 0, 2, 5],
    [5, 0, 0, 0, 4, 5, 5, 6, 0, 0, 0, 5, 5, 3, 0, 0, 0, 5, 5, 0, 0, 0, 2, 5],
    [5, 0, 0, 0, 4, 5, 5, 6, 0, 0, 0, 5, 5, 3, 0, 0, 0, 5, 5, 0, 0, 0, 2, 5],
    [5, 0, 0, 0, 4, 5, 5, 6, 0, 0, 0, 5, 5, 3, 0, 0, 0, 5, 5, 0, 0, 0, 2, 5],
    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    [7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7],
    [7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7],
    [7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7],
    [7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 6, 6, 6, 6],
    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [2, 2, 2, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7],
    [2, 2, 2, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7],
    [2, 2, 2, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7]
]

inputs = [np.array(input_1_list), np.array(input_2_list), np.array(input_3_list)]
results = []

for i, input_np in enumerate(inputs):
    separator_row = _find_separator_row(input_np)
    if separator_row <= 0:
         if separator_row == 0 and np.all(input_np[0,:] == 5):
              key_panel = np.array([[]], dtype=int) 
              main_grid = input_np[1:, :]          
         else: 
              key_panel = np.array([[]], dtype=int) 
              main_grid = input_np                 
    else:
        key_panel = input_np[1:separator_row, :] 
        main_grid = input_np[separator_row + 1:, :]

    explicit_keys = _extract_explicit_keys(key_panel)
    background = _determine_background_color(main_grid)
    
    # Protected set used by the previous failing code
    previous_protected_set = set(explicit_keys)
    if background != -1:
        previous_protected_set.add(background)
        
    # Protected set based on the refined understanding (only explicit keys)
    refined_protected_set = set(explicit_keys)

    results.append({
        "example": i + 1,
        "explicit_keys": sorted(list(explicit_keys)),
        "determined_background": background,
        "previous_protected_set": sorted(list(previous_protected_set)),
        "refined_protected_set": sorted(list(refined_protected_set)),
    })

print(results)
```

*code_execution_result:*
outcome: OUTCOME_OK
```
[{'example': 1, 'explicit_keys': [np.int64(1), np.int64(2), np.int64(4), np.int64(6)], 'determined_background': np.int64(3), 'previous_protected_set': [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(6)], 'refined_protected_set': [np.int64(1), np.int64(2), np.int64(4), np.int64(6)]}, {'example': 2, 'explicit_keys': [np.int64(2), np.int64(3), np.int64(4), np.int64(6)], 'determined_background': np.int64(1), 'previous_protected_set': [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(6)], 'refined_protected_set': [np.int64(2), np.int64(3), np.int64(4), np.int64(6)]}, {'example': 3, 'explicit_keys': [np.int64(2), np.int64(3), np.int64(4), np.int64(6)], 'determined_background': np.int64(7), 'previous_protected_set': [np.int64(2), np.int64(3), np.int64(4), np.int64(6), np.int64(7)], 'refined_protected_set': [np.int64(2), np.int64(3), np.int64(4), np.int64(6)]}]

```
**Analysis Confirmation:**

The metrics confirm the assessment.

*   **Example 1:** Explicit keys are {1, 2, 4, 6}. Background is 3. The previous code incorrectly protected {1, 2, 3, 4, 6}. The refined approach correctly protects only {1, 2, 4, 6}.
*   **Example 2:** Explicit keys are {2, 3, 4, 6}. Background is 1. The previous code incorrectly protected {1, 2, 3, 4, 6}. The refined approach correctly protects only {2, 3, 4, 6}.
*   **Example 3:** Explicit keys are {2, 3, 4, 6}. Background is 7. The previous code incorrectly protected {2, 3, 4, 6, 7}. The refined approach correctly protects only {2, 3, 4, 6}.

The error pattern is consistent: the background color was added to the protection set, preventing the correct stamping behavior.

**YAML Fact Documentation:**


```yaml
task_context:
  description: Stamp a 2x2 azure pattern onto a main grid, protecting certain areas.
  input_structure:
    - type: border
      color: gray (5)
      location: top row (row 0)
    - type: key_panel
      location: rows between top border (row 0) and separator row.
      content: multiple gray-bordered patterns containing one non-white/non-gray color adjacent to white pixels.
      purpose: defines a set of 'protected' colors.
    - type: separator
      color: gray (5)
      orientation: horizontal line
      location: last full row of gray pixels, separates key_panel from main_grid.
    - type: main_grid
      location: bottom section (below separator row).
      content: various colored shapes and background. Can include azure (8).
      purpose: the area to be transformed.
  output_structure:
    - type: grid
      size: matches the input's main_grid size.
      content: modified version of the input's main_grid.

objects:
  - id: explicit_key_colors
    source: non-white (0), non-gray (5) pixels adjacent (4-connectivity) to white (0) pixels in the key_panel.
    property: 'protected' - pixels with these colors prevent stamping in their 2x2 block.
  - id: main_grid_pixels
    source: all pixels in the main_grid section of the input.
  - id: stamp_color
    value: azure (8)
  - id: stamp_unit
    shape: 2x2 square

actions:
  - action: find_separator
    input: input_grid
    output: row_index of the last full gray row
  - action: extract_grid_sections
    input: input_grid, separator_row_index
    output: key_panel, main_grid
  - action: extract_keys
    input: key_panel
    output: set of protected explicit_key_colors
  - action: copy_grid
    input: main_grid
    output: initial output_grid
  - action: iterate_and_stamp
    target: output_grid
    based_on: input main_grid
    unit: 2x2 blocks (defined by top-left corner)
    condition: check if any pixel within the corresponding 2x2 block in the *input* main_grid has a color present in the set of explicit_key_colors.
    effect:
      - if condition is FALSE: overwrite the 2x2 block in the output_grid with the stamp_color (azure).
      - if condition is TRUE: leave the 2x2 block in the output_grid unchanged (preserving original colors from the input main_grid).

relationships:
  - type: protection
    subject: pixels in the main_grid matching explicit_key_colors
    effect: prevent overwriting by the azure stamp in any 2x2 block containing them.
  - type: spatial_grouping
    granularity: 2x2 blocks
    purpose: determines the unit of checking (in input) and potential stamping (in output).
```


**Natural Language Program:**

1.  Identify the 'separator row' by finding the last row in the input grid that consists entirely of gray (5) pixels.
2.  Separate the input grid into two parts:
    *   The "key panel": Rows starting from row 1 up to (but not including) the separator row.
    *   The "main grid": Rows starting from the row *after* the separator row to the bottom of the grid.
3.  Identify the set of "protected colors" by examining the key panel: Find all unique colors that are *not* white (0) and *not* gray (5), and are directly adjacent (up, down, left, or right) to at least one white (0) pixel within the key panel.
4.  Create a new grid (the output grid) that is initially an exact copy of the input's main grid.
5.  Iterate through every possible 2x2 block of pixels in the *input's* main grid. Define a block by its top-left corner's row (r) and column (c). The block includes pixels at (r, c), (r+1, c), (r, c+1), and (r+1, c+1). The iteration covers all possible top-left corners (r, c) such that the 2x2 block fits entirely within the main grid dimensions.
6.  For each 2x2 block considered in the input's main grid, check if *any* of its four pixels have a color that is present in the set of "protected colors" identified in step 3.
7.  If *none* of the four pixels in the input 2x2 block match any of the protected colors, then change the corresponding 2x2 block of pixels in the *output* grid to be entirely azure (8).
8.  If *at least one* pixel in the input 2x2 block *does* match a protected color, make no changes to the corresponding 2x2 block in the output grid (it retains the colors copied in step 4).
9.  After iterating through all possible 2x2 blocks, the resulting output grid is the final result.
