
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 3 3 3 3 3 3 3 3 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
```


**output:**
```
0 0 0 3 3 2 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 2 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 2 3 3 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 2 3 3 3 3 3 3 3 3 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 3 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 3 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 3 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 2 2 2 2 2
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0
0 0 0 2 3 0 3 3 3 3
0 0 0 3 3 0 3 3 2 3
0 0 0 3 3 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0
3 3 3 3 3 0 0 0 0 0
2 2 2 2 3 0 3 3 3 3
3 3 3 3 3 0 3 3 2 3
0 0 0 3 3 0 0 3 2 3
0 0 0 3 3 0 0 3 2 3
0 0 0 0 0 0 0 3 2 3
0 0 0 0 0 0 0 3 2 3
```

Okay, let's break down this task.

**Perception:**

1.  **Grid Structure:** The input and output are 2D grids of pixels with colors represented by integers (0-9). The grids vary in size.
2.  **Colors Used:** The primary colors involved are white (0, background), green (3), and red (2).
3.  **Objects:** The grids contain rectangular blocks made primarily of green (3) pixels. Some of these green blocks contain exactly one red (2) pixel.
4.  **Transformation Pattern:** The transformation seems triggered by the red pixels. For each red pixel, lines extend outwards horizontally and vertically from its position. These lines fill in the white background pixels.
5.  **Extension Color:** The color used to fill the extending lines depends on the pixel adjacent to the red pixel (in the direction of extension) in the *original* input grid.
    *   If the adjacent pixel (e.g., the one immediately to the left of the red pixel for the leftward extension) is green (3), the extension in that direction uses green (3).
    *   If the adjacent pixel is white (0) (meaning the red pixel is at the edge of the green shape in that direction), the extension in that direction uses red (2).
6.  **Extension Boundary:** The extension stops when it hits a non-white pixel or the edge of the grid. It only modifies pixels that were originally white (0).
7.  **Multiple Red Pixels:** If there are multiple red pixels, the extension process is applied independently for each one. The modifications accumulate on the output grid.

**Facts (YAML):**


```yaml
Task: Extend lines from red markers within green shapes.

Input Grid:
  - Contains a background color: white (0).
  - Contains objects: Primarily rectangular shapes made of green (3) pixels.
  - Contains markers: Some green shapes contain a single red (2) pixel.

Output Grid:
  - Is a modified version of the input grid.
  - Modifications involve drawing lines (extensions).

Transformation:
  - Trigger: Presence of red (2) pixels.
  - Process: For each red pixel at position (row, col):
      - Action: Extend lines horizontally (left/right) and vertically (up/down) from (row, col).
      - Target Pixels: Only modify pixels that are white (0) in the input grid.
      - Extension Color Rule:
          - Check the neighbor of the red pixel in the input grid in the direction of extension (e.g., neighbor (row, col-1) for left extension).
          - If the neighbor is green (3): Fill extending line with green (3).
          - If the neighbor is white (0) or off-grid: Fill extending line with red (2).
      - Termination Condition: Extension stops upon encountering a non-white pixel (in the input grid) or the grid boundary.
  - Overlap: Modifications from multiple red pixels are combined. The process modifies a copy of the input grid, so extensions don't block each other prematurely.

Relationships:
  - The red (2) pixel acts as a starting point for the transformation.
  - The color of the pixels immediately adjacent to the red pixel (in the original grid) dictates the color of the extensions.
  - The extensions interact only with the white (0) background pixels.
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the initial output grid.
2.  Iterate through each cell (row `r`, column `c`) of the input grid to find all red (2) pixels.
3.  For each red pixel found at `(r, c)`:
    *   **Check Left Neighbor:** Determine the color of the input grid cell at `(r, c-1)` (treat off-grid as white (0)).
        *   If the left neighbor color is green (3), set the `fill_color` for left extension to green (3).
        *   Otherwise (if neighbor is white (0) or off-grid), set `fill_color` to red (2).
        *   Extend left from `(r, c-1)`: Move column index `cc` from `c-1` down to `0`. For each `cc`, if the output grid cell `(r, cc)` is white (0), change it to `fill_color`. If `(r, cc)` is not white (0), stop extending left.
    *   **Check Right Neighbor:** Determine the color of the input grid cell at `(r, c+1)` (treat off-grid as white (0)).
        *   If the right neighbor color is green (3), set the `fill_color` for right extension to green (3).
        *   Otherwise, set `fill_color` to red (2).
        *   Extend right from `(r, c+1)`: Move column index `cc` from `c+1` up to the grid width limit. For each `cc`, if the output grid cell `(r, cc)` is white (0), change it to `fill_color`. If `(r, cc)` is not white (0), stop extending right.
    *   **Check Upper Neighbor:** Determine the color of the input grid cell at `(r-1, c)` (treat off-grid as white (0)).
        *   If the upper neighbor color is green (3), set the `fill_color` for upward extension to green (3).
        *   Otherwise, set `fill_color` to red (2).
        *   Extend up from `(r-1, c)`: Move row index `rr` from `r-1` down to `0`. For each `rr`, if the output grid cell `(rr, c)` is white (0), change it to `fill_color`. If `(rr, c)` is not white (0), stop extending up.
    *   **Check Lower Neighbor:** Determine the color of the input grid cell at `(r+1, c)` (treat off-grid as white (0)).
        *   If the lower neighbor color is green (3), set the `fill_color` for downward extension to green (3).
        *   Otherwise, set `fill_color` to red (2).
        *   Extend down from `(r+1, c)`: Move row index `rr` from `r+1` up to the grid height limit. For each `rr`, if the output grid cell `(rr, c)` is white (0), change it to `fill_color`. If `(rr, c)` is not white (0), stop extending down.
4.  After processing all red pixels from the input grid, return the final modified output grid.
```python
import numpy as np

"""
Transformation rule:
1. Find all red (2) pixels in the input grid.
2. For each red pixel at position (r, c):
   a. Extend lines horizontally (left/right) and vertically (up/down) from the red pixel's neighbors.
   b. The extension only modifies pixels that were originally white (0) in the input grid.
   c. The color used for extension in a specific direction is determined by the color of the neighbor of the red pixel in that direction in the *original* input grid:
      - If the neighbor is green (3), the extension color is green (3).
      - If the neighbor is white (0) or the red pixel is at the edge (neighbor is off-grid), the extension color is red (2).
   d. The extension in each direction continues until it hits a non-white pixel (from the original input grid) or the grid boundary.
3. Modifications from all red pixels are combined onto a copy of the input grid.
"""

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    
    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Create a copy to modify for the output
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # Define color constants
    WHITE = 0
    RED = 2
    GREEN = 3

    # Find all red pixels
    red_pixels = np.argwhere(input_np == RED)

    # Helper function to safely get neighbor color
    def get_neighbor_color(grid, r, c):
        if 0 <= r < height and 0 <= c < width:
            return grid[r, c]
        else:
            return WHITE # Treat off-grid as white

    # Process each red pixel
    for r, c in red_pixels:

        # --- Horizontal Extensions ---

        # Left Extension
        left_neighbor_color = get_neighbor_color(input_np, r, c - 1)
        fill_color_left = GREEN if left_neighbor_color == GREEN else RED
        for cc in range(c - 1, -1, -1): # Iterate leftwards from neighbor
            if input_np[r, cc] == WHITE: # Check original grid pixel
                output_np[r, cc] = fill_color_left # Update output grid
            else:
                break # Stop extension if non-white pixel encountered

        # Right Extension
        right_neighbor_color = get_neighbor_color(input_np, r, c + 1)
        fill_color_right = GREEN if right_neighbor_color == GREEN else RED
        for cc in range(c + 1, width): # Iterate rightwards from neighbor
            if input_np[r, cc] == WHITE: # Check original grid pixel
                output_np[r, cc] = fill_color_right # Update output grid
            else:
                break # Stop extension

        # --- Vertical Extensions ---

        # Up Extension
        up_neighbor_color = get_neighbor_color(input_np, r - 1, c)
        fill_color_up = GREEN if up_neighbor_color == GREEN else RED
        for rr in range(r - 1, -1, -1): # Iterate upwards from neighbor
            if input_np[rr, c] == WHITE: # Check original grid pixel
                output_np[rr, c] = fill_color_up # Update output grid
            else:
                break # Stop extension

        # Down Extension
        down_neighbor_color = get_neighbor_color(input_np, r + 1, c)
        fill_color_down = GREEN if down_neighbor_color == GREEN else RED
        for rr in range(r + 1, height): # Iterate downwards from neighbor
            if input_np[rr, c] == WHITE: # Check original grid pixel
                output_np[rr, c] = fill_color_down # Update output grid
            else:
                break # Stop extension

    # Convert the final numpy array back to a list of lists
    output_grid = output_np.tolist()
    return output_grid

```
```python
import numpy as np

"""
Transformation rule:
1. Find all red (2) pixels in the input grid.
2. For each red pixel at position (r, c):
   a. Determine the extension color for each of the four cardinal directions (up, down, left, right) based on the color of the immediate neighbor in that direction in the *original* input grid:
      - If the neighbor is green (3), the extension color is green (3).
      - If the neighbor is white (0) or the red pixel is at the edge (neighbor is off-grid), the extension color is red (2).
   b. Extend lines in each of the four directions starting from the neighbor position.
   c. The extension only modifies pixels in the output grid if the corresponding pixel in the *original* input grid was white (0).
   d. The extension in each direction continues until it hits a pixel that was *not* white (0) in the original input grid, or the grid boundary.
3. Modifications from all red pixels are combined onto a copy of the input grid.
"""

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    
    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Create a copy to modify for the output
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # Define color constants
    WHITE = 0
    RED = 2
    GREEN = 3

    # Find all red pixels
    red_pixels = np.argwhere(input_np == RED)

    # Helper function to safely get neighbor color from the original input grid
    def get_neighbor_color(grid, r, c):
        if 0 <= r < height and 0 <= c < width:
            return grid[r, c]
        else:
            # Treat off-grid neighbors as white for color determination rule
            return WHITE 

    # Process each red pixel found in the input grid
    for r, c in red_pixels:

        # --- Determine Extension Colors based on Neighbors in Input Grid ---
        
        left_neighbor_color = get_neighbor_color(input_np, r, c - 1)
        fill_color_left = GREEN if left_neighbor_color == GREEN else RED

        right_neighbor_color = get_neighbor_color(input_np, r, c + 1)
        fill_color_right = GREEN if right_neighbor_color == GREEN else RED

        up_neighbor_color = get_neighbor_color(input_np, r - 1, c)
        fill_color_up = GREEN if up_neighbor_color == GREEN else RED

        down_neighbor_color = get_neighbor_color(input_np, r + 1, c)
        fill_color_down = GREEN if down_neighbor_color == GREEN else RED

        # --- Perform Extensions, Modifying Output Grid ---

        # Left Extension
        # Start extending from the column left of the red pixel
        for cc in range(c - 1, -1, -1): 
            # Check if the *original* pixel at this location was white
            if input_np[r, cc] == WHITE:
                # Update the *output* grid pixel
                output_np[r, cc] = fill_color_left 
            else:
                # Stop extension in this direction if non-white pixel encountered in original grid
                break 

        # Right Extension
        # Start extending from the column right of the red pixel
        for cc in range(c + 1, width): 
            # Check if the *original* pixel at this location was white
            if input_np[r, cc] == WHITE:
                 # Update the *output* grid pixel
                output_np[r, cc] = fill_color_right
            else:
                 # Stop extension in this direction if non-white pixel encountered in original grid
                break 

        # Up Extension
        # Start extending from the row above the red pixel
        for rr in range(r - 1, -1, -1): 
            # Check if the *original* pixel at this location was white
            if input_np[rr, c] == WHITE:
                 # Update the *output* grid pixel
                output_np[rr, c] = fill_color_up 
            else:
                 # Stop extension in this direction if non-white pixel encountered in original grid
                break 

        # Down Extension
        # Start extending from the row below the red pixel
        for rr in range(r + 1, height):
            # Check if the *original* pixel at this location was white
            if input_np[rr, c] == WHITE:
                 # Update the *output* grid pixel
                output_np[rr, c] = fill_color_down
            else:
                 # Stop extension in this direction if non-white pixel encountered in original grid
                break 

    # Convert the final numpy array back to a list of lists
    output_grid = output_np.tolist()
    return output_grid
```
