
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 8 8 1 1 1 8 8 7 8 8 8 8 8 6 6 8 8
8 8 0 0 0 8 8 8 1 8 8 8 7 7 7 8 8 8 8 6 8 8
8 8 0 0 0 8 8 1 1 1 8 8 7 8 8 8 8 8 6 6 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 0 0 0 3 3 2 2 3 3 3 7 3 3 3 3 3 6 6 3 3
3 3 0 0 0 3 3 2 2 2 3 3 7 7 7 3 3 3 3 6 3 3
3 3 0 0 0 3 3 3 2 3 3 3 7 3 3 3 3 3 6 6 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8
8 3 7 3 3 3 3 1 1 1 3 3 3 6 6 3 3 0 0 0 3 8
8 3 7 7 7 3 3 3 1 3 3 3 3 3 6 3 3 0 0 0 3 8
8 3 7 3 3 3 3 1 1 1 3 3 3 6 6 3 3 0 0 0 3 8
8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 8 8 8 8 1 1 1 8 8 6 6 6 8 8 2 2 8 8 8
8 8 0 0 0 8 8 8 1 8 8 8 6 8 6 8 8 2 2 2 8 8
8 8 0 8 0 8 8 1 1 1 8 8 6 8 6 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 0 3 3 3 3 1 1 1 3 3 6 6 6 3 3 2 2 3 3 3
3 3 0 0 0 3 3 3 1 3 3 3 6 3 6 3 3 2 2 2 3 3
3 3 0 3 0 3 3 1 1 1 3 3 6 3 6 3 3 3 2 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 3 0 3 3 3 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 3 0 0 0 3 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 3 0 3 0 3 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 3 1 1 1 3 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 3 3 1 3 3 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 3 1 1 1 3 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 3 2 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 3 2 2 2 3 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 3 3 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 3 6 6 6 3 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 3 6 3 6 3 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 3 6 3 6 3 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 4 8 4 8 8 2 2 8 8 8 2 2 2 8 8
8 8 8 2 8 8 8 4 8 4 8 8 2 2 2 8 8 2 8 2 8 8
8 8 2 8 2 8 8 4 4 4 8 8 8 2 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 4 8 4 8 8 2 2 8 8 8 2 2 2 8 8
8 8 8 2 8 8 8 4 8 4 8 8 2 2 2 8 8 2 8 2 8 8
8 8 2 8 2 8 8 4 4 4 8 8 8 2 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 2 3 2 3 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 3 3 2 3 3 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 3 2 3 2 3 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 3 4 3 4 3 3 2 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 3 4 3 4 3 3 2 2 2 3 8 5 8 8 8 8 1 1 8 8 8
8 3 4 4 4 3 3 3 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 3 3 3 3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 3 2 2 2 3 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 3 2 3 2 3 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 3 2 2 2 3 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 8 8 2 2 8 8 8 7 8 8 8 8 8 6 6 8 8
8 8 0 0 0 8 8 2 2 2 8 8 7 7 7 8 8 8 8 6 8 8
8 8 0 0 0 8 8 8 2 8 8 8 7 8 8 8 8 8 6 6 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 0 0 0 8 8 2 2 8 8 8 7 8 8 8 8 8 6 6 8 8
8 8 0 0 0 8 8 2 2 2 8 8 7 7 7 8 8 8 8 6 8 8
8 8 0 0 0 8 8 8 2 8 8 8 7 8 8 8 8 8 6 6 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 8 8 8 8 8 3 3 3 3 3 3 3 3 3 3 8
8 3 7 3 3 3 8 1 1 1 8 3 3 6 6 3 3 0 0 0 3 8
8 3 7 7 7 3 8 8 1 8 8 3 3 3 6 3 3 0 0 0 3 8
8 3 7 3 3 3 8 1 1 1 8 3 3 6 6 3 3 0 0 0 3 8
8 3 3 3 3 3 8 8 8 8 8 3 3 3 3 3 3 3 3 3 3 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 3 2 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 3 2 2 2 3 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 3 3 2 3 3 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


## train_5

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 1 8 1 8 8 9 8 9 8 8 8 8 8 8 8
8 8 8 1 8 8 8 1 1 8 8 8 9 9 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 1 8 1 8 8 9 9 9 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 8 9 8 9 8 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 8 9 9 8 8 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 8 9 9 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 8 8 1 8 8 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 8 1 1 1 8 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 8 1 1 8 8 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 8 1 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 1 8 1 8 8 9 8 9 8 8 8 8 8 8 8
8 8 8 1 8 8 8 1 1 8 8 8 9 9 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 1 8 1 8 8 9 9 9 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
8 8 2 8 2 8 8 0 8 8 8 8 8 8 7 8 3 9 3 9 3 8
8 8 8 2 8 8 8 0 0 0 8 8 8 8 7 8 3 9 9 3 3 8
8 8 2 8 2 8 8 0 8 0 8 8 7 7 7 8 3 9 9 9 3 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 7 8 8 8 3 1 1 1 3 8 8 6 6 8 8 0 0 0 8 8
8 8 7 7 7 8 3 3 1 3 3 8 8 8 6 8 8 0 0 0 8 8
8 8 7 8 8 8 3 1 1 1 3 8 8 6 6 8 8 0 0 0 8 8
8 8 8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
8 8 4 8 4 8 8 2 2 8 8 8 5 5 8 8 3 1 3 1 3 8
8 8 4 8 4 8 8 2 2 2 8 8 5 8 8 8 3 1 1 3 3 8
8 8 4 4 4 8 8 8 2 8 8 8 5 5 8 8 3 1 3 1 3 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 3 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 9 8 8 8 8 6 6 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 9 9 9 8 8 6 8 6 8 8 4 4 4 8 8 2 8 2 8 8
8 8 8 8 9 8 8 6 8 6 8 8 8 4 8 8 8 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```

## Perception

1.  **Grid Structure:** The input and output grids are consistently 30 rows by 22 columns. They feature a predominant gray (8) background. Two distinct horizontal lines composed entirely of magenta (6) pixels are present at row index 5 and row index 27, acting as visual separators.
2.  **Objects:** Scattered across the gray background, primarily between the magenta lines and in the area above the first magenta line, are small, distinct shapes made of various colors (white-0, blue-1, red-2, green-3, yellow-4, gray-5, orange-7, maroon-9). These shapes are typically 3x3 or smaller arrangements of pixels.
3.  **Key Colors:** Gray (8) is the background. Magenta (6) forms separators. Green (3) is introduced in the output as a replacement for some gray pixels. Red (2) is also introduced in the output, specifically in the bottom two rows under certain conditions.
4.  **Transformation Areas:** Changes primarily occur in two ways:
    *   Gray pixels immediately surrounding (including diagonally) the colorful shapes change to green (3).
    *   The bottom two rows (rows 28 and 29), which are initially gray (8), are uniformly changed to either green (3) or red (2).
5.  **Invariance:** The magenta separator lines (rows 5 and 27) and the original colorful shapes themselves remain unchanged in the output.

## Facts


```yaml
Grid:
  Properties:
    - Dimensions: 30 rows x 22 columns (consistent across examples)
    - BackgroundColor: Gray (8)
Regions:
  - Name: TopSection
    Location: Rows 0-4
  - Name: Separator1
    Location: Row 5
    Color: Magenta (6)
  - Name: MiddleSection
    Location: Rows 6-26
  - Name: Separator2
    Location: Row 27
    Color: Magenta (6)
  - Name: BottomSection
    Location: Rows 28-29
Objects:
  - Name: Shape
    Properties:
      - Color: Any color except Gray (8) or Magenta (6)
      - Location: Primarily within TopSection and MiddleSection
      - Size: Typically small, often within 3x3 bounding box
      - Composition: Contiguous pixels of the same color
Actions:
  - Name: FindAdjacentGrays
    Input: Input Grid
    Output: Set of coordinates of Gray (8) pixels
    Rule: Identify all Gray (8) pixels that are adjacent (including diagonals, 8-connectivity) to any Shape pixel.
  - Name: ChangeAdjacentToGreen
    Input: Input Grid, Set of coordinates from FindAdjacentGrays
    Output: Modified Grid
    Rule: Change the color of the pixels at the identified coordinates to Green (3).
  - Name: CheckTopSectionChange
    Input: Input Grid, Modified Grid (from ChangeAdjacentToGreen)
    Output: Boolean flag (True if changes occurred in TopSection, False otherwise)
    Rule: Compare the TopSection (rows 0-4) of the Input Grid and the Modified Grid. Return True if any pixel changed color within this section, False otherwise.
  - Name: SetBottomColor
    Input: Modified Grid, Boolean flag (from CheckTopSectionChange)
    Output: Final Output Grid
    Rule:
      - If the boolean flag is True: Change all pixels in the BottomSection (rows 28-29) to Green (3).
      - If the boolean flag is False: Change all pixels in the BottomSection (rows 28-29) to Red (2).
Relationships:
  - Adjacency: Used to find Gray pixels near Shapes (8-directional connectivity).
  - Containment: Shapes are contained within specific Regions (TopSection, MiddleSection). Changes are assessed based on Region (TopSection).
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Create a list to store the coordinates `(row, col)` of gray (8) pixels that need to change color.
3.  Iterate through each pixel `(r, c)` of the input grid.
4.  If the pixel at `(r, c)` is gray (8):
    a.  Check all 8 neighbors (including diagonals) of `(r, c)`.
    b.  If any neighbor exists within the grid boundaries and its color is *not* gray (8) and *not* magenta (6), add the coordinate `(r, c)` to the list of pixels to change.
5.  Keep track if any changes were identified within the top section (rows 0 to 4 inclusive) during step 4b. Let's call this flag `top_section_changed`, initially False. If a coordinate `(r, c)` with `r <= 4` is added to the list in step 4b, set `top_section_changed` to True.
6.  Iterate through the list of coordinates identified in step 4. For each coordinate `(r, c)` in the list, change the color of the pixel at `(r, c)` in the output grid to green (3).
7.  Determine the color for the bottom two rows (rows 28 and 29):
    a.  If `top_section_changed` is True, the target color is green (3).
    b.  If `top_section_changed` is False, the target color is red (2).
8.  Change all pixels in rows 28 and 29 of the output grid to the determined target color.
9.  Return the final output grid.
```python
import numpy as np

def transform(input_grid):
    """
    Transforms the input grid based on the following rules:
    1. Identify all gray (8) pixels that are adjacent (including diagonals) 
       to any pixel that is neither gray (8) nor magenta (6).
    2. Change these identified gray pixels to green (3).
    3. Keep track if any of the pixels changed to green in step 2 are located 
       within the top 5 rows (rows 0-4).
    4. If any changes occurred in the top 5 rows, change all pixels in the 
       bottom two rows (rows 28-29) to green (3).
    5. Otherwise (if no changes occurred in the top 5 rows), change all pixels 
       in the bottom two rows (rows 28-29) to red (2).
    6. All other pixels retain their original color.
    """

    # Convert input list of lists to a numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_np)
    height, width = input_np.shape

    # List to store coordinates of gray pixels to change
    pixels_to_change = []
    # Flag to track if any changes occur in the top section (rows 0-4)
    top_section_changed = False

    # Iterate through each pixel of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current pixel is gray (8)
            if input_np[r, c] == 8:
                # Check all 8 neighbors (including diagonals)
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        # Skip the center pixel itself
                        if dr == 0 and dc == 0:
                            continue
                        
                        # Calculate neighbor coordinates
                        nr, nc = r + dr, c + dc

                        # Check if neighbor is within grid boundaries
                        if 0 <= nr < height and 0 <= nc < width:
                            neighbor_color = input_np[nr, nc]
                            # Check if neighbor is neither gray (8) nor magenta (6)
                            if neighbor_color != 8 and neighbor_color != 6:
                                # If conditions met, mark this gray pixel for change
                                pixels_to_change.append((r, c))
                                # Break inner loops once a triggering neighbor is found
                                break  
                    # Break outer loop if already marked for change
                    else: # This else corresponds to the inner for dc loop (no break)
                        continue
                    break # This break corresponds to the outer for dr loop (inner break occurred)

    # Change the marked gray pixels to green (3) in the output grid
    # Use set to avoid processing duplicate coordinates
    for r, c in set(pixels_to_change):
        output_grid[r, c] = 3
        # Check if this change occurred in the top section
        if r <= 4:
            top_section_changed = True

    # Determine the color for the bottom two rows
    bottom_color = 3 if top_section_changed else 2

    # Check if the grid has at least 30 rows before modifying rows 28 and 29
    if height >= 30:
        # Change the bottom two rows (28 and 29) to the determined color
        output_grid[28:30, :] = bottom_color
        # A more robust way if height might not be exactly 30:
        # output_grid[height-2:height, :] = bottom_color


    # Return the modified grid as a list of lists
    return output_grid.tolist()
```
```python
import numpy as np

def transform(input_grid):
    """
    Transforms the input grid based on the following rules:
    1. Identify all gray (8) pixels that are adjacent (including diagonals, 8-connectivity) 
       to any pixel that is neither gray (8) nor magenta (6) (these non-gray, non-magenta pixels are termed 'ShapePixels').
    2. Change these identified adjacent gray pixels to green (3).
    3. Keep track if any of the pixels changed to green in step 2 are located 
       within the top 5 rows (rows 0-4).
    4. If any changes occurred in the top 5 rows, change all pixels in the 
       bottom two rows (rows 28-29) to green (3).
    5. Otherwise (if no changes occurred in the top 5 rows), change all pixels 
       in the bottom two rows (rows 28-29) to red (2).
    6. All other pixels, including the original ShapePixels and magenta lines, 
       retain their original color unless modified by rule 2 or rules 4/5.
    """

    # Convert input list of lists to a numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_np)
    height, width = input_np.shape

    # Set to store coordinates (row, col) of gray pixels that need to be changed to green
    pixels_to_change = set()
    # Flag to track if any changes will occur in the top section (rows 0-4)
    top_section_changed = False

    # Iterate through each pixel of the input grid to find ShapePixels
    for r in range(height):
        for c in range(width):
            pixel_color = input_np[r, c]
            
            # Check if the current pixel is a ShapePixel (neither gray nor magenta)
            if pixel_color != 8 and pixel_color != 6:
                # If it's a ShapePixel, check its 8 neighbors
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        # Skip the center pixel itself
                        if dr == 0 and dc == 0:
                            continue
                        
                        # Calculate neighbor coordinates
                        nr, nc = r + dr, c + dc

                        # Check if the neighbor is within grid boundaries
                        if 0 <= nr < height and 0 <= nc < width:
                            neighbor_color = input_np[nr, nc]
                            # Check if the neighbor is gray (8)
                            if neighbor_color == 8:
                                # If it's a gray neighbor, mark it for change
                                coord = (nr, nc)
                                if coord not in pixels_to_change:
                                    pixels_to_change.add(coord)
                                    # Check if this gray pixel is in the top section (rows 0-4)
                                    # Set the flag if it is and hasn't been set yet
                                    if nr <= 4:
                                        top_section_changed = True

    # Apply the changes: turn marked gray pixels green
    for r, c in pixels_to_change:
        output_grid[r, c] = 3

    # Determine the color for the bottom two rows based on the flag
    bottom_color = 3 if top_section_changed else 2

    # Apply the color change to the bottom two rows
    # Assuming grid height is always 30 as per examples
    if height >= 30:
        # Rows 28 and 29 correspond to indices height-2 and height-1
        output_grid[height-2:height, :] = bottom_color

    # Return the final modified grid as a list of lists
    return output_grid.tolist()
```
```python
import numpy as np

def transform(input_grid):
    """
    Transforms the input grid based on the following rules:
    1. Identify all gray (8) pixels located *above* the second magenta line 
       (i.e., in rows 0 through 26) that are adjacent (including diagonals, 
       8-connectivity) to any pixel that is neither gray (8) nor magenta (6) 
       (these non-gray, non-magenta pixels are termed 'ShapePixels').
    2. Change these identified adjacent gray pixels to green (3).
    3. Keep track if any of the pixels changed to green in step 2 are located 
       within the top 5 rows (rows 0-4).
    4. If any changes occurred in the top 5 rows, change all pixels in the 
       bottom two rows (rows 28-29) to green (3).
    5. Otherwise (if no changes occurred in the top 5 rows), change all pixels 
       in the bottom two rows (rows 28-29) to red (2).
    6. All other pixels, including the original ShapePixels and magenta lines, 
       retain their original color unless modified by rule 2 or rules 4/5.
    """

    # Convert input list of lists to a numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_np)
    height, width = input_np.shape

    # Set to store coordinates (row, col) of gray pixels that need to be changed to green
    pixels_to_change = set()
    # Flag to track if any changes will occur in the top section (rows 0-4)
    top_section_changed = False
    
    # Define the row limit for searching for gray pixels to change (exclusive)
    # This corresponds to the row index of the second magenta line (row 27)
    search_row_limit = height - 3 if height >= 3 else 0 # Typically 27 if height=30

    # Iterate through each pixel of the input grid ABOVE the second magenta line
    # to find gray pixels adjacent to ShapePixels.
    # This approach iterates through potential gray pixels first.
    for r in range(search_row_limit): # Only check rows 0 to 26
        for c in range(width):
            # Check if the current pixel is gray (8)
            if input_np[r, c] == 8:
                # Check its 8 neighbors
                found_triggering_neighbor = False
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        # Skip the center pixel itself
                        if dr == 0 and dc == 0:
                            continue
                        
                        # Calculate neighbor coordinates
                        nr, nc = r + dr, c + dc

                        # Check if neighbor is within grid boundaries
                        if 0 <= nr < height and 0 <= nc < width:
                            neighbor_color = input_np[nr, nc]
                            # Check if neighbor is a ShapePixel (neither gray nor magenta)
                            if neighbor_color != 8 and neighbor_color != 6:
                                # If it's a gray neighbor adjacent to a ShapePixel, mark it for change
                                coord = (r, c)
                                if coord not in pixels_to_change:
                                     pixels_to_change.add(coord)
                                     # Check if this gray pixel is in the top section (rows 0-4)
                                     if r <= 4:
                                         top_section_changed = True
                                # Break inner loops once a triggering neighbor is found for this gray pixel
                                found_triggering_neighbor = True
                                break 
                    if found_triggering_neighbor:
                        break


    # Apply the changes: turn marked gray pixels green
    for r, c in pixels_to_change:
        output_grid[r, c] = 3

    # Determine the color for the bottom two rows based on the flag
    bottom_color = 3 if top_section_changed else 2

    # Apply the color change to the bottom two rows
    # Assuming grid height is always 30 as per examples
    if height >= 2: # Ensure grid has at least 2 rows
        # Rows 28 and 29 correspond to indices height-2 and height-1
        output_grid[height-2:height, :] = bottom_color

    # Return the final modified grid as a list of lists
    return output_grid.tolist()
```
