
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 0 0 3 3 3 3 3
0 0 2 3 3 3 3 3 3 2 3 0 0 0 2 3 3 2 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 2
0 0 3 2 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 2 0 2 3 3 3 3
0 0 2 3 3 3 3 3 3 3 3 0 2 0 0 3 3 3 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 2 3 3 3 0 2 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 2 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 2 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 3 3
0 1 1 1 3 3 1 2 1 1 1 0 0 0 0 3 1 1 1 3
0 1 2 1 3 3 1 1 1 2 1 0 0 0 2 3 1 2 1 3
0 1 1 1 3 3 1 1 1 1 1 0 0 0 0 3 1 1 1 3
0 0 3 3 3 3 1 2 1 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 1 1
0 0 1 1 1 3 3 3 3 3 3 0 0 0 0 3 3 3 1 2
0 0 1 2 1 3 1 1 1 3 3 0 0 0 1 1 1 3 1 1
0 1 1 1 1 3 1 2 1 3 3 0 0 2 1 2 1 3 3 3
0 1 2 1 3 3 1 1 1 3 3 0 2 0 1 1 1 3 3 3
0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 1 1 1 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 1 2 1 1 1 0 2 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 1 2 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 2 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 2 1 3 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 2 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0
2 0 2 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 2 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 2 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 3 3 3 3 3 3 3 2 0 0 0
0 0 0 0 0 0 0 0 3 3 2 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 3 3 3 2 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 2 3 3 3 3 3 3 3 2 0 0
```


**output:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 1 1 1 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 1 2 1 3 3 1 1 1 3 3 3 0 0 0 0 0
0 0 0 3 1 1 1 3 3 1 2 1 3 1 1 1 0 0 0 0
0 0 0 3 3 3 3 3 3 1 1 1 3 1 2 1 0 0 0 0
2 0 2 1 1 1 3 3 3 3 3 3 3 1 1 1 0 0 0 0
0 0 0 1 2 1 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 1 1 1 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 1 2 1 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 1 1 1 3 3 3 3 3 1 1 1 0 0
0 0 0 0 0 0 2 0 3 1 1 1 3 3 3 1 2 1 0 0
0 0 0 0 0 0 0 0 3 1 2 1 1 3 3 1 1 1 0 0
0 0 0 0 0 0 0 0 3 1 1 2 1 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 1 1 1 1 1 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 1 2 1 3 3 3 3 3 3 2 0 0
```


## train_3

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 2 0 0 0 0 3 3 3 3 3 2 0 0
0 3 3 3 3 0 0 0 0 3 3 3 3 3 3 0 0
0 3 3 3 3 0 0 0 0 3 2 2 3 3 3 0 0
0 2 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 1 1 1 0 0 0 0 0 0 0 1 1 1 0
0 3 3 1 2 1 0 0 0 3 3 3 3 1 2 1 0
0 3 3 1 1 1 0 0 0 1 1 1 1 1 1 1 0
0 3 3 3 3 0 0 0 0 1 2 2 1 3 3 0 0
0 2 0 0 0 0 0 0 0 1 1 1 1 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```

## Perception

The input and output grids are the same size.
The core elements are pixels of different colors: white (0), blue (1), red (2), and green (3). Other colors appear but seem unaffected and uninvolved in the primary transformation.
The transformation involves changing certain green pixels (3) to blue pixels (1).
Red pixels (2) seem to act as triggers or catalysts for this change. They remain unchanged in the output.
The change from green to blue happens in the immediate vicinity of red pixels. Specifically, any green pixel that is one of the 8 neighbors (including diagonals) of a red pixel in the input grid becomes a blue pixel in the output grid.
If a pixel is a neighbor to multiple red pixels, it still just turns blue if it was originally green.
Pixels that are not red and are not green neighbors of a red pixel retain their original color.

## Facts


```yaml
GridProperties:
  - Input and output grids have identical dimensions.
PixelColors:
  - white: 0
  - blue: 1
  - red: 2
  - green: 3
  - yellow: 4
  - gray: 5
  - magenta: 6
  - orange: 7
  - azure: 8
  - maroon: 9
Objects:
  - Red Pixels: Color value 2. These act as triggers.
  - Green Pixels: Color value 3. These are potentially transformed.
  - Blue Pixels: Color value 1. These are the result of the transformation.
  - Other Pixels: All other colors (0, 4-9). These are unaffected by the transformation.
Relationships:
  - Adjacency: The transformation depends on the 8-way adjacency (including diagonals) between green pixels and red pixels.
Actions:
  - Identify: Locate all red pixels (2) in the input grid.
  - Neighborhood Check: For each red pixel, examine its 8 neighboring cells (Moore neighborhood).
  - Conditional Transformation: If a neighboring cell in the input grid contains a green pixel (3), change the color of that corresponding cell in the output grid to blue (1).
  - Preservation: All red pixels (2) remain red (2) in the output grid. All other pixels (not red and not green neighbors of red) retain their original color from the input grid.
```


## Natural Language Program

1.  Create a copy of the input grid to serve as the basis for the output grid.
2.  Iterate through each cell (pixel) of the input grid.
3.  If the current cell contains a red pixel (color 2):
    a.  Identify the coordinates (row, column) of this red pixel.
    b.  Examine the 8 neighboring cells (Moore neighborhood) around this red pixel in the *input* grid.
    c.  For each neighbor:
        i.  Check if the neighbor's coordinates are within the grid boundaries.
        ii. If the neighbor cell in the *input* grid contains a green pixel (color 3), change the color of the corresponding cell in the *output* grid to blue (color 1).
4.  After checking all red pixels and modifying the output grid accordingly, the resulting grid is the final output. (Note: Red pixels themselves and pixels that were not green neighbors of a red pixel remain unchanged from their input values in the output grid copy).
```python
import numpy as np

"""
Transforms an input grid based on the following rule:
1. Create a copy of the input grid to serve as the output grid.
2. Iterate through each cell of the input grid.
3. If a cell contains a red pixel (color 2):
   a. Examine its 8 neighboring cells (Moore neighborhood) in the input grid.
   b. If a neighbor cell contains a green pixel (color 3), change the color 
      of the corresponding cell in the output grid to blue (color 1).
4. All other pixels (including red pixels and non-green neighbors of red pixels) 
   retain their original color in the output grid.
"""

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    # Convert input list of lists to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input_grid
    output_array = np.copy(input_array)
    
    rows, cols = input_array.shape

    # Define the 8 neighboring offsets (Moore neighborhood)
    neighbor_offsets = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Iterate through each cell of the input grid
    for r in range(rows):
        for c in range(cols):
            # Check if the current cell contains a red pixel (color 2)
            if input_array[r, c] == 2:
                # Examine the 8 neighbors of the red pixel
                for dr, dc in neighbor_offsets:
                    nr, nc = r + dr, c + dc
                    
                    # Check if the neighbor coordinates are within the grid boundaries
                    if 0 <= nr < rows and 0 <= nc < cols:
                        # Check if the neighbor cell in the *input* grid is green (color 3)
                        if input_array[nr, nc] == 3:
                            # Change the corresponding cell in the *output* grid to blue (color 1)
                            output_array[nr, nc] = 1

    # Convert the output NumPy array back to a list of lists before returning
    return output_array.tolist()
```
