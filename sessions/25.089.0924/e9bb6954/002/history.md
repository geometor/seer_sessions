
## train_1

**input:**
```
0 0 0 0 0 0 8 7 0 0 0 0 0 0
6 8 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 0 1 0 0 0 0
0 0 2 6 5 0 3 0 0 0 2 2 2 0
0 0 0 0 0 0 0 6 0 0 2 2 2 0
0 0 0 0 0 0 0 7 0 0 2 2 2 0
0 0 0 3 3 3 0 0 0 8 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 3 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 3 0 4 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 6 0 0 1
0 0 0 8 0 8 0 0 0 0 0 0 0 0
0 0 8 0 6 7 0 0 0 0 0 0 0 8
```


**output:**
```
0 0 0 0 3 0 8 7 0 0 0 2 0 0
6 8 0 0 3 0 0 0 0 0 8 2 0 0
0 0 0 0 3 0 3 0 0 0 0 2 0 0
0 0 0 0 3 0 0 6 0 1 0 2 0 0
0 0 2 6 3 0 3 0 0 0 2 2 2 0
2 2 2 2 0 2 2 2 2 2 2 2 2 2
0 0 0 0 3 0 0 7 0 0 2 2 2 0
0 0 0 3 3 3 0 0 0 8 0 2 0 0
3 3 3 3 3 3 3 3 3 3 3 0 3 3
0 3 0 3 3 3 0 0 0 0 0 2 0 0
0 0 0 0 3 0 0 0 0 0 0 2 0 0
0 0 0 0 3 0 0 0 0 0 0 2 3 0
0 0 3 0 3 0 0 0 0 0 0 2 0 0
5 0 0 0 3 0 3 0 4 0 0 2 0 0
0 0 0 0 3 0 0 0 0 0 0 2 0 0
0 0 0 0 3 0 0 0 0 0 6 2 0 1
0 0 0 8 3 8 0 0 0 0 0 2 0 0
0 0 8 0 3 7 0 0 0 0 0 2 0 8
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 9 0
0 0 0 0 0 0 0 0 0 2 0 3 0
0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 0 0 9 0 0 6 0 0 0 0 0
7 0 0 0 3 1 0 0 0 0 0 0 0
0 0 2 0 0 4 4 4 0 0 0 0 0
0 0 0 0 0 4 4 4 0 0 0 0 9
0 0 0 0 0 4 4 4 0 0 0 0 0
9 7 0 0 0 0 0 1 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 6 0 0 0
0 0 0 7 0 0 0 0 0 0 1 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 8 0
```


**output:**
```
0 0 0 0 0 0 4 0 0 0 0 9 0
0 0 0 0 0 0 4 0 0 2 0 3 0
0 0 0 0 0 0 4 0 0 3 0 0 0
0 0 0 0 9 0 4 6 0 0 0 0 0
7 0 0 0 3 1 4 0 0 0 0 0 0
0 0 2 0 0 4 4 4 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 4 4 4 0 0 0 0 0
9 7 0 0 0 0 4 1 0 0 1 0 0
0 0 0 0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 4 0 0 6 0 0 0
0 0 0 7 0 0 4 0 0 0 1 0 0
0 0 0 8 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 4 0 0 0 0 8 0
```


## train_3

**input:**
```
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 7 0 8 8 8 1 3 0 0
0 0 4 0 0 0 0 0 0 4 0 8 8 8 0 0 0 0
1 0 0 7 0 0 0 7 2 0 0 0 0 0 0 0 0 0
8 0 0 0 4 0 0 0 0 0 0 0 0 0 0 3 0 0
0 5 0 0 0 8 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 0 6 6 6 0 0 0 0 0 0 0 0 0 0 4 0
0 0 4 6 6 6 0 0 0 0 0 0 0 0 0 3 0 0
0 0 0 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3
1 3 0 0 2 0 0 0 0 0 0 0 0 0 0 3 3 3
0 0 0 0 0 4 0 0 0 8 0 0 0 0 0 3 3 3
0 0 0 0 0 0 0 0 6 0 0 0 0 4 0 0 0 0
```


**output:**
```
0 0 0 1 6 0 0 0 0 0 0 0 8 0 0 0 3 0
0 0 0 0 6 0 0 0 0 0 0 0 8 0 0 0 3 0
0 0 2 0 6 0 0 0 0 0 0 8 8 8 0 0 3 0
8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8 0 8
0 0 4 0 6 0 0 0 0 4 0 8 8 8 0 0 3 0
1 0 0 7 6 0 0 7 2 0 0 0 8 0 0 0 3 0
8 0 0 0 6 0 0 0 0 0 0 0 8 0 0 3 3 0
0 5 0 0 6 8 0 0 8 0 0 0 8 0 0 0 3 0
0 0 0 0 6 0 0 0 0 0 0 0 8 0 1 0 3 0
0 0 0 6 6 6 0 0 0 0 0 0 8 0 0 0 3 0
6 6 6 6 6 6 6 6 6 6 6 6 0 6 6 6 0 6
0 0 0 6 6 6 0 0 0 0 0 0 8 0 0 0 3 0
0 0 0 0 6 0 0 0 0 0 0 0 8 0 3 0 3 0
0 0 0 0 6 0 0 0 0 0 0 0 8 0 0 0 3 0
0 0 9 0 6 0 0 0 0 0 0 0 8 0 0 3 3 3
3 3 3 3 0 3 3 3 3 3 3 3 0 3 3 3 3 3
0 0 0 0 6 4 0 0 0 8 0 0 8 0 0 3 3 3
0 0 0 0 6 0 0 0 6 0 0 0 8 4 0 0 3 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 0
0 0 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 8 8 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 8 0
0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9
0 0 0 0 0 0 8 0 0 0 0 0 7 7 7 0 2 0
0 5 0 0 0 0 0 0 0 3 0 0 7 7 7 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 7 7 7 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 8 7 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 8 0 9 0 0 0 7 0 0 0 0
0 0 0 0 9 0 0 8 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 8 8 8 0 0 0 0 7 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 0 8 8 8 8
0 0 0 0 0 0 8 8 8 0 0 0 0 7 0 0 8 0
0 0 1 0 0 2 0 8 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 7 0 0 0 9
0 0 0 0 0 0 8 8 0 0 0 0 7 7 7 0 2 0
7 7 7 7 7 7 7 0 7 7 7 7 7 7 7 7 7 7
0 0 0 0 0 0 0 8 0 0 0 0 7 7 7 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 7 2 0 0 0
0 0 0 0 0 4 0 8 0 0 0 0 0 7 0 0 0 0
0 0 0 0 0 0 0 8 0 0 7 0 0 7 0 0 0 4
0 0 0 0 0 0 0 8 0 0 0 0 0 7 0 0 0 0
```

*   **Perception of task elements:**
    *   The input and output grids have the same dimensions.
    *   The input grid contains scattered pixels and distinct objects (contiguous blocks of the same color, excluding white).
    *   The output grid is the input grid modified by adding horizontal and vertical lines.
    *   The colors and positions of these lines seem related to the properties (color, size, position) of the largest object(s) in the input grid.
    *   Specifically, horizontal and vertical lines are drawn through the "center" of the largest objects.
    *   If multiple objects share the largest size, lines are drawn for each of them using their respective colors and centers.
    *   The lines only fill cells that were originally white (color 0) in the input grid; they do not overwrite existing non-white pixels.

*   **YAML facts:**
    
```yaml
    task_description: Modifies the input grid by adding horizontal and vertical lines based on the largest objects found within it.
    elements:
      - type: grid
        properties:
          - dimensions remain constant between input and output.
          - contains background pixels (white, 0).
          - contains objects (contiguous blocks of non-white pixels).
      - type: object
        properties:
          - color (non-white)
          - shape (contiguous pixels)
          - size (number of pixels)
          - location (coordinates)
          - bounding_box (min_row, min_col, max_row, max_col)
          - center (center_row, center_col based on bounding box)
    actions:
      - identify_objects: Find all contiguous blocks of non-white pixels (using 8-way adjacency).
      - calculate_size: Determine the area (pixel count) for each object.
      - find_max_size: Determine the maximum size among all identified objects.
      - filter_largest_objects: Select all objects whose size equals the maximum size.
      - calculate_center: For each largest object, calculate its center row and column based on its bounding box: center_row = floor((min_row + max_row) / 2), center_col = floor((min_col + max_col) / 2).
      - draw_lines: For each largest object:
          - Draw a horizontal line of the object's color across the grid at its center row.
          - Draw a vertical line of the object's color down the grid at its center column.
          - Important constraint: Lines only color cells that are white (0) in the grid. They do not overwrite existing non-white cells from the input or previously drawn lines.
    relationships:
      - The color of the drawn lines matches the color of the corresponding largest object.
      - The position (row/column) of the drawn lines corresponds to the calculated center of the corresponding largest object.
      - The modification (drawing lines) applies only to white background pixels.
    ```


*   **Natural language program:**
    1.  Start with a copy of the input grid.
    2.  Identify all distinct objects in the input grid. An object is a contiguous group of pixels of the same non-white color (using diagonal and cardinal adjacency). Ignore the white background (color 0).
    3.  Calculate the size (number of pixels) of each identified object.
    4.  Find the maximum size among all objects.
    5.  Identify all objects that have this maximum size. There might be one or more such objects.
    6.  For each object identified in step 5:
        a.  Note the object's color.
        b.  Determine the object's bounding box (the smallest rectangle containing all its pixels). Find the minimum row (`min_row`), maximum row (`max_row`), minimum column (`min_col`), and maximum column (`max_col`).
        c.  Calculate the center row index as `floor((min_row + max_row) / 2)`.
        d.  Calculate the center column index as `floor((min_col + max_col) / 2)`.
        e.  Iterate through all columns `c` from 0 to the grid width - 1. If the pixel at `(center_row, c)` in the current grid is white (0), change its color to the object's color.
        f.  Iterate through all rows `r` from 0 to the grid height - 1. If the pixel at `(r, center_col)` in the current grid is white (0), change its color to the object's color.
    7.  The resulting grid after processing all largest objects is the final output.
```python
import numpy as np
from collections import deque

"""
Identifies the largest object(s) in the input grid based on pixel count. 
For each largest object, calculates its center based on its bounding box. 
Draws a horizontal line and a vertical line intersecting at this center, 
using the object's color. These lines only color pixels that are originally 
white (0) in the grid. If multiple objects share the maximum size, lines 
are drawn for all of them.
"""

def find_objects(grid):
    """
    Finds all contiguous objects of non-background colors in the grid.

    Args:
        grid (np.array): The input grid.

    Returns:
        list: A list of dictionaries, where each dictionary represents an 
              object and contains 'color', 'pixels' (list of coordinates), 
              'size', and 'bbox' (min_r, max_r, min_c, max_c).
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    # Define 8 directions for connectivity (neighbors including diagonals)
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), 
                  (1, 1), (1, -1), (-1, 1), (-1, -1)]

    for r in range(height):
        for c in range(width):
            # If the cell is not background (0) and not visited
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                current_object_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, max_r = r, r
                min_c, max_c = c, c

                # Breadth-First Search (BFS) to find all connected pixels of the same color
                while q:
                    row, col = q.popleft()
                    current_object_pixels.append((row, col))
                    
                    # Update bounding box
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check neighbors
                    for dr, dc in directions:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if neighbor is same color and not visited
                        if 0 <= nr < height and 0 <= nc < width and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            
                objects.append({
                    'color': color,
                    'pixels': current_object_pixels,
                    'size': len(current_object_pixels),
                    'bbox': (min_r, max_r, min_c, max_c)
                })
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid based on the largest objects found.

    Args:
        input_grid (list of lists or np.array): The input grid.

    Returns:
        np.array: The transformed grid.
    """
    # Convert to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    height, width = grid.shape

    # Find all objects in the grid
    objects = find_objects(grid)

    # If no objects are found, return the original grid copy
    if not objects:
        return output_grid

    # Find the maximum size among all objects
    max_size = 0
    for obj in objects:
        if obj['size'] > max_size:
            max_size = obj['size']

    # Filter objects to keep only the largest ones
    largest_objects = [obj for obj in objects if obj['size'] == max_size]

    # Process each largest object
    for obj in largest_objects:
        color = obj['color']
        min_r, max_r, min_c, max_c = obj['bbox']
        
        # Calculate center row and column using integer division (floor)
        center_r = (min_r + max_r) // 2
        center_c = (min_c + max_c) // 2
        
        # Draw horizontal line: iterate through columns
        # Only color pixels if they are currently white (0) in the output_grid
        for c in range(width):
            if output_grid[center_r, c] == 0:
                output_grid[center_r, c] = color
                
        # Draw vertical line: iterate through rows
        # Only color pixels if they are currently white (0) in the output_grid
        for r in range(height):
             if output_grid[r, center_c] == 0:
                output_grid[r, center_c] = color

    return output_grid.tolist() # Return as list of lists as per ARC standard
```
