{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Determine the background color: This is the most frequent color in the input grid, excluding red (color 2). If only red exists or no dominant color excluding red, choose a default (e.g., 0) or the most frequent of the remaining colors.\n3.  Iterate through each pixel `(r, c)` of the input grid.\n4.  If the pixel's color `clr` is not red (2) and not the background color:\n    a.  Check its 4 cardinal neighbors (up, down, left, right).\n    b.  For each neighbor `(nr, nc)` that contains a red pixel (color 2):\n        i.   Determine the orientation of the red structure at `(nr, nc)`. Check if the red pixel at `(nr, nc)` has red neighbors horizontally (`(nr, nc-1)` or `(nr, nc+1)`). If yes, classify the red structure locally as \"horizontal\". Otherwise, classify it as \"vertical/point\".\n        ii.  If the red structure is classified as \"horizontal\":\n             *   Calculate the reflected position `(rr, rc)` by reflecting vertically across the row `nr`: `rr = nr + (nr - r)`, `rc = c`.\n        iii. If the red structure is classified as \"vertical/point\":\n             *   Calculate the reflected position `(rr, rc)` by reflecting horizontally across the column `nc`: `rr = r`, `rc = nc + (nc - c)`.\n        iv.  Check if the calculated reflected coordinates `(rr, rc)` are within the grid boundaries.\n        v.   If the reflected coordinates are valid *and* the pixel at `output_grid[rr, rc]` currently holds the background color, update that pixel in the output grid with the original pixel's color `clr`.\n5.  Return the modified output grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, excluding red (2).\"\"\"\n    counts = Counter(grid.flatten())\n    if 2 in counts:\n        del counts[2] # Exclude red\n    \n    if not counts:\n        # Handle cases where grid is all red or empty after removing red\n        # Check if 0 is present, often a default background\n        all_counts = Counter(grid.flatten())\n        if 0 in all_counts: return 0\n        # If no 0, return the most frequent color overall (if grid not empty)\n        if grid.size > 0:\n            return Counter(grid.flatten()).most_common(1)[0][0]\n        return 0 # Default fallback\n\n    # Return the most common color among the remaining ones\n    return counts.most_common(1)[0][0]\n\ndef is_within_bounds(grid_shape, r, c):\n    \"\"\"Checks if coordinates (r, c) are within the grid boundaries.\"\"\"\n    height, width = grid_shape\n    return 0 <= r < height and 0 <= c < width\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on adjacent red pixels,\n    considering the orientation of the red structure.\n    \"\"\"\n    # Ensure input is a numpy array\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    grid_shape = (height, width)\n\n    # 1. Initialize output_grid as a copy\n    output_grid = np.copy(input_grid_np)\n\n    # 2. Determine the background color\n    background_color = find_background_color(input_grid_np)\n\n    # 3. Iterate through each pixel of the input grid\n    for r in range(height):\n        for c in range(width):\n            clr = input_grid_np[r, c]\n\n            # 4. Check if the pixel is neither red nor background\n            if clr != 2 and clr != background_color:\n                # a. Check cardinal neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n\n                    # Check if neighbor is within bounds\n                    if is_within_bounds(grid_shape, nr, nc):\n                        # b. Check if neighbor is red\n                        if input_grid_np[nr, nc] == 2:\n                            \n                            # i. Determine Red Orientation at (nr, nc)\n                            is_horizontal = False\n                            # Check left neighbor\n                            if nc > 0 and input_grid_np[nr, nc - 1] == 2:\n                                is_horizontal = True\n                            # Check right neighbor\n                            if not is_horizontal and nc < width - 1 and input_grid_np[nr, nc + 1] == 2:\n                                is_horizontal = True\n\n                            reflected_pos = None\n                            # ii/iii. Calculate Reflected Position (rr, rc)\n                            if is_horizontal:\n                                # Reflect vertically across row nr\n                                rr = nr + (nr - r)\n                                rc = c\n                                reflected_pos = (rr, rc)\n                            else: # Vertical Line or Single Point\n                                # Reflect horizontally across column nc\n                                rr = r\n                                rc = nc + (nc - c)\n                                reflected_pos = (rr, rc)\n\n                            # iv/v. Check bounds and update output if background\n                            if reflected_pos:\n                                rr, rc = reflected_pos\n                                if is_within_bounds(grid_shape, rr, rc) and output_grid[rr, rc] == background_color:\n                                    output_grid[rr, rc] = clr\n\n    # 6. Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12007,
    "candidates_token_count": 1361,
    "total_token_count": 13368,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 106.837228,
  "retries": 2
}