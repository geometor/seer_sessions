{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Determine the dimensions (height H, width W) of the input grid.\n2.  Identify the 'separator color' by finding the most frequent color (excluding white/0) that forms continuous or near-continuous horizontal and vertical lines across the grid. The examples show Azure (8) and Green (3) as separator colors.\n3.  Determine the dimensions (comp_h, comp_w) of the compartments formed by the separator lines (e.g., 4x4 in examples).\n4.  Select the appropriate 'stamp pattern' based on the identified `separator_color`:\n    *   If `separator_color` is Azure (8), use `Pattern_A = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2), (2, 3), (3, 1)]`.\n    *   If `separator_color` is Green (3), use `Pattern_B = [(1, 0), (1, 1), (1, 3), (2, 1), (2, 2), (3, 2)]`.\n    *   If the compartment size is not 4x4 or the separator color is not 3 or 8, the behavior is undefined by the examples (assume failure/empty output for now).\n5.  Identify the starting coordinates `(r_start, c_start)` for each compartment. Group compartments by their starting row `r_start`.\n6.  Initialize an output grid of the same dimensions as the input, filled with white (0).\n7.  Copy all pixels matching the `separator_color` from the input grid to the output grid.\n8.  Iterate through each unique starting row `r_start` identified for the compartments:\n    a.  Scan all pixels within all compartments belonging to this row `r_start` in the *input* grid.\n    b.  Identify the single 'significant color' present in these scanned pixels. This color is the most frequent one that is *not* white (0), *not* the `separator_color`, and *not* a noise color (Gray/5, Magenta/6). Store this as the 'row color'. If no such color exists, the 'row color' is white (0).\n    c.  For each compartment `(r, c)` starting in this row `r_start`:\n        i.  If the determined 'row color' is not white (0):\n            1.  For each relative coordinate `(dr, dc)` in the selected 'stamp pattern':\n                a.  Calculate the absolute coordinate `(abs_r, abs_c)` = `(r + dr, c + dc)`.\n                b.  If `(abs_r, abs_c)` is within the grid bounds and not a separator location, set the pixel at `(abs_r, abs_c)` in the *output* grid to the 'row color'.\n9.  Return the completed output grid.\n\"\"\"\n\ndef find_separator_and_dimensions(grid):\n    \"\"\"\n    Identifies the separator color, its line indices, and compartment dimensions.\n    More robust version based on analysis.\n    Args:\n        grid (np.array): Input grid.\n    Returns:\n        tuple: (separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w) or None if failed.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Count non-background colors\n    colors, counts = np.unique(grid[grid != 0], return_counts=True)\n    if len(colors) == 0:\n        return None\n\n    # --- Find Separator Color ---\n    potential_separators = {}\n    # Prioritize colors forming full lines\n    for r in range(height):\n        row_colors, row_counts = np.unique(grid[r,:], return_counts=True)\n        for c_val, count in zip(row_colors, row_counts):\n             if c_val != 0 and count == width: potential_separators[c_val] = potential_separators.get(c_val, 0) + height \n    for c in range(width):\n        col_colors, col_counts = np.unique(grid[:,c], return_counts=True)\n        for c_val, count in zip(col_colors, col_counts):\n             if c_val != 0 and count == height: potential_separators[c_val] = potential_separators.get(c_val, 0) + width\n\n    separator_color = -1\n    if potential_separators:\n        separator_color = max(potential_separators, key=potential_separators.get)\n    else: # Fallback if no full lines - check majority lines (more robustly)\n        temp_sep_counts = Counter()\n        for r in range(height):\n             line_colors, line_counts = np.unique(grid[r,:], return_counts=True)\n             for c_val, count in zip(line_colors, line_counts):\n                  if c_val != 0 and count > width * 0.5 : # Heuristic for majority line\n                       temp_sep_counts[c_val]+=1\n        for c in range(width):\n             line_colors, line_counts = np.unique(grid[:,c], return_counts=True)\n             for c_val, count in zip(line_colors, line_counts):\n                  if c_val != 0 and count > height * 0.5 : # Heuristic for majority line\n                       temp_sep_counts[c_val]+=1\n\n        if temp_sep_counts:\n             separator_color = temp_sep_counts.most_common(1)[0][0]\n        else: # Absolute fallback: most frequent non-zero\n             if len(colors) > 0:\n                 separator_color = colors[np.argmax(counts)]\n             else: return None\n\n\n    if separator_color == -1: return None\n\n    # --- Find Separator Indices ---\n    # Use strict definition first, then relax if needed\n    h_sep_indices = [r for r in range(height) if np.all(grid[r, :] == separator_color)]\n    v_sep_indices = [c for c in range(width) if np.all(grid[:, c] == separator_color)]\n\n    # If few/no full lines found, try majority threshold (useful if grid lines are partial)\n    if len(h_sep_indices) < 2 : # Arbitrary threshold, maybe adjust based on grid size?\n        h_sep_indices = [r for r in range(height) if np.count_nonzero(grid[r, :] == separator_color) > width * 0.6]\n    if len(v_sep_indices) < 2 :\n        v_sep_indices = [c for c in range(width) if np.count_nonzero(grid[:, c] == separator_color) > height * 0.6]\n\n    # --- Calculate Compartment Dimensions ---\n    # Use contiguous blocks of non-separator rows/cols\n    row_indices = sorted([i for i in range(height) if i not in h_sep_indices])\n    col_indices = sorted([i for i in range(width) if i not in v_sep_indices])\n\n    comp_h = 0\n    if row_indices:\n        max_h = 0\n        current_h = 0\n        for i in range(len(row_indices)):\n            if i > 0 and row_indices[i] == row_indices[i-1] + 1:\n                current_h += 1\n            else:\n                max_h = max(max_h, current_h)\n                current_h = 0\n        comp_h = max(max_h, current_h) + 1 \n\n    comp_w = 0\n    if col_indices:\n        max_w = 0\n        current_w = 0\n        for i in range(len(col_indices)):\n            if i > 0 and col_indices[i] == col_indices[i-1] + 1:\n                current_w += 1\n            else:\n                 max_w = max(max_w, current_w)\n                 current_w = 0\n        comp_w = max(max_w, current_w) + 1 \n\n    if comp_h <= 0 or comp_w <= 0:\n        # print(f\"Warning: Calculated invalid compartment dimensions H:{comp_h}, W:{comp_w}\")\n        return None # Failed to determine valid dimensions\n\n    return separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w\n\n\ndef get_compartment_locations(height, width, h_sep_indices, v_sep_indices, comp_h, comp_w):\n    \"\"\"\n    Calculates the top-left coordinates of each compartment and groups them by starting row.\n    \"\"\"\n    compartments_by_row = {}\n    row_starts = []\n    current_row = 0\n    while current_row < height:\n        if current_row not in h_sep_indices:\n             row_starts.append(current_row)\n             # Important: step by actual compartment height, not just 1\n             step = comp_h \n             current_row += step\n        else:\n            current_row += 1 # Skip separator row\n\n    col_starts = []\n    current_col = 0\n    while current_col < width:\n        if current_col not in v_sep_indices:\n             col_starts.append(current_col)\n             step = comp_w\n             current_col += step\n        else:\n            current_col += 1 # Skip separator col\n\n    # Generate compartment info            \n    for r_start in row_starts:\n        # Ensure row start is valid\n        if r_start + comp_h > height: continue \n        \n        row_compartments = []\n        for c_start in col_starts:\n             # Ensure col start is valid\n             if c_start + comp_w > width: continue\n             \n             # Check if this compartment overlaps with a separator line\n             is_valid = True\n             # Check horizontal overlap\n             # for r in range(r_start, r_start + comp_h):\n             #      if r in h_sep_indices: is_valid=False; break\n             # if not is_valid: continue\n             # # Check vertical overlap\n             # for c in range(c_start, c_start + comp_w):\n             #      if c in v_sep_indices: is_valid=False; break\n             # if not is_valid: continue\n\n             comp_info = ((r_start, c_start), comp_h, comp_w)\n             row_compartments.append(comp_info)\n\n        if row_compartments:\n             compartments_by_row[r_start] = row_compartments\n\n    return compartments_by_row\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the identified rules:\n    - Find separator and compartments.\n    - Select pattern based on separator color (8 or 3).\n    - Determine row color based on significant input pixels (excluding noise 5, 6).\n    - Stamp the selected pattern with the row color onto the output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np) # Start with white\n\n    # 1. Identify Separator and Compartment Dimensions\n    sep_info = find_separator_and_dimensions(input_np)\n    if sep_info is None:\n        # print(\"Failed to find separator or valid dimensions\")\n        return output_grid.tolist() # Return empty grid on failure\n        \n    separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w = sep_info\n    \n    # 2. Select Stamp Pattern based on separator color and dimensions\n    stamp_pattern_relative = None\n    # --- Define Known Patterns ---\n    patterns = {\n        8: [(0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2), (2, 3), (3, 1)], # Pattern A for separator 8\n        3: [(1, 0), (1, 1), (1, 3), (2, 1), (2, 2), (3, 2)]  # Pattern B for separator 3\n    }\n\n    if comp_h == 4 and comp_w == 4: # Check dimensions match known patterns\n        if separator_color in patterns:\n            stamp_pattern_relative = patterns[separator_color]\n        else:\n            # print(f\"Separator color {separator_color} not recognized for 4x4 compartments.\")\n            return output_grid.tolist() # Unknown separator, return empty\n    else:\n        # print(f\"Compartment size {comp_h}x{comp_w} does not match expected 4x4.\")\n        return output_grid.tolist() # Non-4x4, return empty\n        \n    # 3. Copy Separators to Output\n    # Create masks for separator locations\n    h_mask = np.zeros_like(input_np, dtype=bool)\n    v_mask = np.zeros_like(input_np, dtype=bool)\n    if h_sep_indices:\n        h_mask[h_sep_indices, :] = True\n    if v_sep_indices:\n        v_mask[:, v_sep_indices] = True\n    separator_mask = h_mask | v_mask\n    # Apply only where the input actually has the separator color\n    output_grid[separator_mask & (input_np == separator_color)] = separator_color\n\n    # 4. Get Compartment Locations\n    compartments_by_row = get_compartment_locations(height, width, h_sep_indices, v_sep_indices, comp_h, comp_w)\n    if not compartments_by_row:\n        # print(\"Failed to find compartment locations.\")\n        return output_grid.tolist() # Return grid with only separators if no compartments found\n\n    # 5. Determine Row Colors and Fill Output Grid\n    noise_colors = {0, separator_color, 5, 6} # Include 0 and separator explicitly\n\n    for r_start, comps_in_row in compartments_by_row.items():\n        # a. Find the significant color for this row\n        pixel_colors = []\n        for (r, c), h, w in comps_in_row:\n            # Extract pixels from the INPUT grid for this compartment\n            compartment_slice = input_np[r:min(r + h, height), c:min(c + w, width)]\n            pixel_colors.extend(list(compartment_slice.flatten()))\n\n        # Filter colors to find significant ones\n        valid_colors = [color for color in pixel_colors if color not in noise_colors]\n        \n        significant_color_found = 0 # Default to white/background\n        if valid_colors:\n            color_counts = Counter(valid_colors)\n            if color_counts:\n                # Assume the most frequent valid color is the significant one\n                significant_color_found = color_counts.most_common(1)[0][0]\n        \n        row_color = significant_color_found\n\n        # b. Apply pattern to compartments in this row on the OUTPUT grid\n        if row_color != 0: # Only stamp if a significant color was found\n            for (r, c), h, w in comps_in_row:\n                 # Apply pattern using the selected relative coordinates\n                 for dr, dc in stamp_pattern_relative:\n                     abs_r, abs_c = r + dr, c + dc\n                     # Check bounds and ensure not overwriting a separator\n                     if 0 <= abs_r < height and 0 <= abs_c < width:\n                         # Check if the target location is NOT a separator line\n                         is_sep_loc = (abs_r in h_sep_indices) or (abs_c in v_sep_indices)\n                         if not is_sep_loc: \n                              output_grid[abs_r, abs_c] = row_color\n                         # If it IS a separator location, double-check if input had separator color there\n                         # This handles cases where pattern might touch a sparse separator line\n                         elif input_np[abs_r, abs_c] != separator_color:\n                             output_grid[abs_r, abs_c] = row_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27622,
    "candidates_token_count": 3887,
    "total_token_count": 31509,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.573827,
  "retries": 1
}