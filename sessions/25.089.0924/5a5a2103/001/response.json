{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify the grid dimensions and the 'separator color' which forms continuous horizontal and vertical lines dividing the grid into compartments.\n2.  Determine the dimensions of the compartments (e.g., 4x4 in the examples).\n3.  Create an output grid of the same dimensions, initialized to white (0).\n4.  Copy the separator lines from the input grid to the output grid.\n5.  For each horizontal row of compartments in the input grid:\n    a. Scan all pixels within the compartments belonging to this row.\n    b. Identify the single 'significant color' present. This is the color that is not white (0), not the separator color, and not considered 'noise' (colors 5/gray and 6/magenta seem to be noise in the examples). If multiple such colors exist, this rule might need refinement, but examples suggest a unique significant color per row.\n    c. Store this significant color as the 'row color' for this row of compartments. If no significant color is found, the row color defaults to white (0).\n6.  Define a fixed 'stamp pattern' relative to the top-left corner of a compartment (coordinates [(0,1), (0,2), (1,2), (2,0), (2,1), (2,2), (2,3), (3,1)] for a 4x4 compartment).\n7.  Iterate through each compartment location in the output grid.\n    a. Retrieve the 'row color' determined for the row this compartment belongs to.\n    b. If the row color is not white (0), apply the 'stamp pattern' to the compartment in the output grid using the row color. Fill the remaining pixels within the compartment (that are not part of the pattern and not separators) with white (0).\n8.  Return the completed output grid.\n\"\"\"\n\ndef find_separator_and_dimensions(grid):\n    \"\"\"\n    Identifies the separator color, its line indices, and compartment dimensions.\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        tuple: (separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w) or None if failed.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Count non-background colors\n    colors, counts = np.unique(grid[grid != 0], return_counts=True)\n    if len(colors) == 0:\n        return None # Empty grid essentially\n\n    # Find potential separator color (most frequent non-zero color forming lines)\n    separator_color = -1\n    max_count = 0\n    \n    potential_separators = {}\n    for r in range(height):\n        row_colors, row_counts = np.unique(grid[r,:], return_counts=True)\n        for c_val, count in zip(row_colors, row_counts):\n            if c_val != 0 and count == width: # Full row of this color\n                potential_separators[c_val] = potential_separators.get(c_val, 0) + 1\n    for c in range(width):\n        col_colors, col_counts = np.unique(grid[:,c], return_counts=True)\n        for c_val, count in zip(col_colors, col_counts):\n             if c_val != 0 and count == height: # Full col of this color\n                potential_separators[c_val] = potential_separators.get(c_val, 0) + 1\n                \n    if not potential_separators:\n         # Fallback: Check if most frequent color forms any lines\n         counts_dict = {c: cnt for c, cnt in zip(colors, counts)}\n         sorted_colors = sorted(colors, key=lambda c: counts_dict[c], reverse=True)\n         for pc in sorted_colors:\n             is_separator = False\n             for r in range(height):\n                 if np.all(grid[r,:] == pc): is_separator = True; break\n             if not is_separator:\n                 for c_col in range(width):\n                      if np.all(grid[:,c_col] == pc): is_separator = True; break\n             if is_separator:\n                 separator_color = pc\n                 break\n    else:\n        separator_color = max(potential_separators, key=potential_separators.get)\n\n\n    if separator_color == -1:\n         # Heuristic: often the most frequent non-zero color overall\n        if len(colors)>0:\n            separator_color = colors[np.argmax(counts)]\n        else: return None # cannot determine separator\n\n\n    h_sep_indices = [r for r in range(height) if np.all(grid[r, :] == separator_color)]\n    v_sep_indices = [c for c in range(width) if np.all(grid[:, c] == separator_color)]\n\n    if not h_sep_indices or not v_sep_indices:\n        # Maybe separators don't span the whole grid, check for majority\n        h_sep_indices = [r for r in range(height) if np.count_nonzero(grid[r, :] == separator_color) > width // 2]\n        v_sep_indices = [c for c in range(width) if np.count_nonzero(grid[:, c] == separator_color) > height // 2]\n        if not h_sep_indices or not v_sep_indices:\n             return None # Still cannot find separators\n\n\n    # Calculate compartment dimensions based on separator spacing\n    comp_h = 0\n    if len(h_sep_indices) > 1:\n        comp_h = h_sep_indices[1] - h_sep_indices[0] - 1\n    elif len(h_sep_indices) == 1:\n         comp_h = max(h_sep_indices[0], height - h_sep_indices[0] - 1) # Compartment before or after the single line\n    else: # No horizontal separators? Maybe whole grid is one compartment row\n         comp_h = height\n         \n    comp_w = 0\n    if len(v_sep_indices) > 1:\n        comp_w = v_sep_indices[1] - v_sep_indices[0] - 1\n    elif len(v_sep_indices) == 1:\n        comp_w = max(v_sep_indices[0], width - v_sep_indices[0] - 1)\n    else: # No vertical separators? Maybe whole grid is one compartment column\n         comp_w = width\n\n    # Check for edge case where first/last row/col is data, not separator\n    first_data_row = 0\n    while first_data_row in h_sep_indices and first_data_row < height:\n        first_data_row +=1\n    last_data_row = height - 1\n    while last_data_row in h_sep_indices and last_data_row >= 0:\n        last_data_row -= 1\n        \n    first_data_col = 0\n    while first_data_col in v_sep_indices and first_data_col < width:\n        first_data_col +=1\n    last_data_col = width - 1\n    while last_data_col in v_sep_indices and last_data_col >= 0:\n        last_data_col -= 1\n\n    if first_data_row < height and first_data_col < width : # Check if valid data region exists\n        if not h_sep_indices or h_sep_indices[0] > first_data_row:\n             comp_h = h_sep_indices[0] - first_data_row if h_sep_indices else (last_data_row - first_data_row + 1)\n        if not v_sep_indices or v_sep_indices[0] > first_data_col:\n             comp_w = v_sep_indices[0] - first_data_col if v_sep_indices else (last_data_col - first_data_col + 1)\n\n\n    if comp_h <= 0 or comp_w <= 0:\n       # print(f\"Warning: Calculated invalid compartment dimensions H:{comp_h}, W:{comp_w}\")\n       # Try simple diff if dimensions look wrong\n       if len(h_sep_indices) > 1: comp_h = h_sep_indices[1] - h_sep_indices[0] - 1\n       elif h_sep_indices: comp_h = h_sep_indices[0] # Assume compartment before separator\n       else: comp_h = height\n       \n       if len(v_sep_indices) > 1: comp_w = v_sep_indices[1] - v_sep_indices[0] - 1\n       elif v_sep_indices: comp_w = v_sep_indices[0] # Assume compartment before separator\n       else: comp_w = width\n       \n       if comp_h <= 0 or comp_w <= 0: return None # Give up if still invalid\n\n    return separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w\n\ndef get_compartment_coords(height, width, h_sep_indices, v_sep_indices, comp_h, comp_w):\n    \"\"\"Calculates the top-left coordinates of each compartment.\"\"\"\n    compartments = []\n    # Determine start row/col for compartments\n    start_row = 0\n    if h_sep_indices and h_sep_indices[0] == 0:\n        start_row = h_sep_indices[0] + 1\n    \n    start_col = 0\n    if v_sep_indices and v_sep_indices[0] == 0:\n        start_col = v_sep_indices[0] + 1\n\n    row_step = comp_h + 1\n    col_step = comp_w + 1\n\n    for r in range(start_row, height, row_step):\n        if r in h_sep_indices: continue # Skip separator rows\n        for c in range(start_col, width, col_step):\n            if c in v_sep_indices: continue # Skip separator columns\n            # Basic check if coords are within grid bounds (adjust if needed)\n            if r + comp_h <= height and c + comp_w <= width:\n                 compartments.append(((r, c), comp_h, comp_w))\n            # Handle potential partial compartments at edges if logic requires later\n            # else: maybe add partial compartment info? Ignoring for now based on examples.\n\n\n    # If detection failed, use simpler approach assuming regular grid\n    if not compartments and comp_h > 0 and comp_w > 0:\n         row_indices = [i for i in range(height) if i not in h_sep_indices]\n         col_indices = [i for i in range(width) if i not in v_sep_indices]\n         \n         r=0\n         while r < len(row_indices):\n             c = 0\n             while c < len(col_indices):\n                 compartments.append(((row_indices[r], col_indices[c]), comp_h, comp_w))\n                 c += comp_w\n             r += comp_h\n\n\n    return compartments\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying compartments, determining a color per\n    row of compartments based on significant input content, and stamping a fixed\n    pattern with that color into each compartment of the output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np) # Start with white\n\n    # --- 1. Identify Separator and Compartment Dimensions ---\n    sep_info = find_separator_and_dimensions(input_np)\n    if sep_info is None:\n        # print(\"Failed to find separator or valid dimensions\")\n        # Fallback or error handling needed, maybe return input?\n        # For now, return empty grid as per init\n        return output_grid.tolist() \n        \n    separator_color, h_sep_indices, v_sep_indices, comp_h, comp_w = sep_info\n    \n    # --- 2. Copy Separators to Output ---\n    output_grid[input_np == separator_color] = separator_color\n    \n    # --- 3. Get Compartment Locations ---\n    # compartments = get_compartment_coords(height, width, h_sep_indices, v_sep_indices, comp_h, comp_w)\n    # Reworking compartment finding to be more robust by iterating rows/cols\n    compartments_by_row = {} \n    row_starts = []\n    current_row = 0\n    while current_row < height:\n        if current_row not in h_sep_indices:\n             row_starts.append(current_row)\n             current_row += comp_h\n        else:\n            current_row += 1 # Skip separator row\n\n    col_starts = []\n    current_col = 0\n    while current_col < width:\n        if current_col not in v_sep_indices:\n             col_starts.append(current_col)\n             current_col += comp_w\n        else:\n            current_col += 1 # Skip separator col\n            \n    all_compartments = []\n    for r_start in row_starts:\n        row_compartments = []\n        for c_start in col_starts:\n            comp_info = ((r_start, c_start), comp_h, comp_w)\n            row_compartments.append(comp_info)\n            all_compartments.append(comp_info)\n        if row_compartments:\n             compartments_by_row[r_start] = row_compartments\n             \n\n    # --- 4. Determine Row Colors ---\n    noise_colors = {5, 6} # Gray, Magenta identified as noise from examples\n    row_colors = {} # Map starting row index of compartments to the determined color\n\n    for r_start, comps_in_row in compartments_by_row.items():\n        significant_color_found = 0 # Default to white/background\n        pixel_colors = []\n        for (r, c), h, w in comps_in_row:\n            # Ensure slicing is within bounds\n            r_end = min(r + h, height)\n            c_end = min(c + w, width)\n            if r_end > r and c_end > c : # Check for valid slice\n                compartment_slice = input_np[r:r_end, c:c_end]\n                pixel_colors.extend(list(compartment_slice.flatten()))\n\n        # Filter colors\n        valid_colors = [\n            color for color in pixel_colors \n            if color != 0 and color != separator_color and color not in noise_colors\n        ]\n\n        if valid_colors:\n            # Find the unique significant color (or most frequent if multiple allowed - examples suggest unique)\n            color_counts = Counter(valid_colors)\n            if color_counts:\n                 # Simple: take the most frequent one\n                 # significant_color_found = color_counts.most_common(1)[0][0]\n                 # Stricter: based on examples, seems like only one significant color per row\n                 if len(color_counts) == 1:\n                      significant_color_found = list(color_counts.keys())[0]\n                 else:\n                     # If multiple significant colors, maybe take the most frequent? Or is it an error?\n                     # Let's stick to most frequent for now.\n                     significant_color_found = color_counts.most_common(1)[0][0]\n\n\n        row_colors[r_start] = significant_color_found\n\n    # --- 5. Define Stamp Pattern ---\n    # Assuming 4x4 compartments based on examples. Needs dynamic check if needed.\n    # If comp_h != 4 or comp_w != 4, this pattern is wrong.\n    # Let's assume it's fixed for this task based on examples.\n    if comp_h == 4 and comp_w == 4:\n         stamp_pattern_relative = [\n             (0, 1), (0, 2), (1, 2), (2, 0), \n             (2, 1), (2, 2), (2, 3), (3, 1)\n         ]\n    else:\n        # print(f\"Warning: Compartment size is {comp_h}x{comp_w}, pattern is for 4x4. Output might be incorrect.\")\n        # Define a fallback or default pattern, or maybe scale? Return empty for now.\n        # Returning the grid with just separators if pattern doesn't match size\n         return output_grid.tolist() \n\n    # --- 6. Fill Output Grid with Pattern ---\n    for r_start, determined_color in row_colors.items():\n        if determined_color != 0: # Only stamp if a significant color was found\n            comps_in_row = compartments_by_row[r_start]\n            for (r, c), h, w in comps_in_row:\n                 # Apply pattern if coordinates are valid and size matches\n                 if h == comp_h and w == comp_w:\n                     for dr, dc in stamp_pattern_relative:\n                         abs_r, abs_c = r + dr, c + dc\n                         # Check bounds before writing\n                         if 0 <= abs_r < height and 0 <= abs_c < width:\n                             # Check if it's not overwriting a separator line pixel\n                             if input_np[abs_r, abs_c] != separator_color:\n                                  output_grid[abs_r, abs_c] = determined_color\n                 # Note: Pixels within the compartment not part of the pattern\n                 # remain 0 (white) because we initialized output_grid with zeros\n                 # and only explicitly color the pattern and separator pixels.\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4927,
    "candidates_token_count": 4225,
    "total_token_count": 9152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 52.817035,
  "retries": 1
}