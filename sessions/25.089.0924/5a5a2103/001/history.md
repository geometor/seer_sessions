
## train_1

**input:**
```
0 0 0 0 8 0 5 5 0 8 0 0 0 0
0 2 2 0 8 0 0 5 0 8 0 0 0 0
0 2 2 0 8 5 5 5 5 8 0 0 0 0
0 0 0 0 8 0 5 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
```


**output:**
```
0 2 2 0 8 0 2 2 0 8 0 2 2 0
0 0 2 0 8 0 0 2 0 8 0 0 2 0
2 2 2 2 8 2 2 2 2 8 2 2 2 2
0 2 0 0 8 0 2 0 0 8 0 2 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 3 3 0 8 0 3 3 0 8 0 3 3 0
0 0 3 0 8 0 0 3 0 8 0 0 3 0
3 3 3 3 8 3 3 3 3 8 3 3 3 3
0 3 0 0 8 0 3 0 0 8 0 3 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 1 1 0 8 0 1 1 0 8 0 1 1 0
0 0 1 0 8 0 0 1 0 8 0 0 1 0
1 1 1 1 8 1 1 1 1 8 1 1 1 1
0 1 0 0 8 0 1 0 0 8 0 1 0 0
```


## train_2

**input:**
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 6 6 0 6 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 0 6 6 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 6 0 3 0 0 0 0 3 0 0 0 0
```


**output:**
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
4 4 0 4 3 4 4 0 4 3 4 4 0 4 3 4 4 0 4
0 4 4 0 3 0 4 4 0 3 0 4 4 0 3 0 4 4 0
0 0 4 0 3 0 0 4 0 3 0 0 4 0 3 0 0 4 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
2 2 0 2 3 2 2 0 2 3 2 2 0 2 3 2 2 0 2
0 2 2 0 3 0 2 2 0 3 0 2 2 0 3 0 2 2 0
0 0 2 0 3 0 0 2 0 3 0 0 2 0 3 0 0 2 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
8 8 0 8 3 8 8 0 8 3 8 8 0 8 3 8 8 0 8
0 8 8 0 3 0 8 8 0 3 0 8 8 0 3 0 8 8 0
0 0 8 0 3 0 0 8 0 3 0 0 8 0 3 0 0 8 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
1 1 0 1 3 1 1 0 1 3 1 1 0 1 3 1 1 0 1
0 1 1 0 3 0 1 1 0 3 0 1 1 0 3 0 1 1 0
0 0 1 0 3 0 0 1 0 3 0 0 1 0 3 0 0 1 0
```

Okay, let's analyze the provided examples.

**Perception of Task Elements**

1.  **Grid Structure:** Both input grids feature a distinct grid pattern formed by lines of a single, non-white color. In `train_1`, this separator color is azure (8); in `train_2`, it's green (3). These lines divide the grid into smaller, equally sized square compartments. In both examples, these compartments appear to be 4x4 (ignoring the separator lines themselves).
2.  **Compartment Content (Input):** Within these compartments in the input grids, we find various small shapes or single-color blocks. Some compartments contain 2x2 squares of a specific color (red, green, blue, yellow, azure). Other compartments contain different shapes (like the gray shapes in `train_1` or magenta shapes in `train_2`), while some are empty (all white).
3.  **Compartment Content (Output):** In the output grids, the separator lines remain unchanged. However, the content *within* each compartment is replaced. All compartments in the output contain the *same* pattern of pixels, but the color used for the pattern varies between rows of compartments.
4.  **Color Transformation:**
    *   The separator color persists from input to output.
    *   Certain colors present within input compartments (gray in `train_1`, magenta in `train_2`) disappear in the output.
    *   The color used to draw the pattern within a row of compartments in the output seems determined by the 'significant' non-separator color found within that same row of compartments in the input. For example, in `train_1`, the first row of compartments contains a red (2) square, and all compartments in that row in the output are filled with a red pattern. The gray (5) objects in that row are ignored when determining the fill color. Similarly, in `train_2`, the last row of compartments contains a blue (1) square and some magenta (6) shapes; the output uses blue (1) for the pattern in that row.
5.  **Pattern:** The pattern used to fill the compartments in the output is consistent across all filled compartments in both examples. Relative to the top-left of a 4x4 compartment, the colored pixels are at coordinates: (0,1), (0,2), (1,2), (2,0), (2,1), (2,2), (2,3), (3,1).

**Facts**


```yaml
task_elements:
  - element: grid
    properties:
      - type: input/output pair
      - content: pixels with color values 0-9
      - structure: divided by separator lines
  - element: separator_lines
    properties:
      - role: divide grid into compartments
      - color: consistent within a task (azure/8 in train_1, green/3 in train_2), determined as the most frequent non-white color forming lines
      - orientation: horizontal and vertical
      - persistence: unchanged between input and output
  - element: compartments
    properties:
      - shape: square (e.g., 4x4 excluding separators)
      - location: defined by separator lines
      - content_input: variable (shapes, single colors, noise colors, empty/white)
      - content_output: fixed pattern, variable color
  - element: row_color
    properties:
      - scope: applies to a horizontal row of compartments
      - determination: derived from the single 'significant' non-white, non-separator color present in the input compartments of that row (ignoring 'noise' colors like gray/5 or magenta/6)
      - role: determines the color used for the pattern in the output compartments of that row
  - element: output_pattern
    properties:
      - shape: fixed spatial arrangement of pixels within a compartment
      - coordinates (relative to 4x4 compartment): [(0,1), (0,2), (1,2), (2,0), (2,1), (2,2), (2,3), (3,1)]
      - color: determined by the row_color
      - application: stamped into every compartment in the output grid (excluding separators)

relationships:
  - input grid and output grid have the same dimensions.
  - separator lines define compartments in both input and output.
  - the color used in the output pattern for a specific compartment depends on the row it belongs to and the 'significant' color found in that row in the input.
  - 'Noise' colors (like gray/5, magenta/6) in the input do not influence the output color or pattern.

actions:
  - identify the separator color and lines.
  - identify the compartments defined by the separators.
  - for each row of compartments:
    - find the 'row color' from the input, ignoring separators and noise colors.
  - create the output grid:
    - copy separator lines.
    - for each compartment:
      - determine its row color.
      - apply the fixed output_pattern using the determined row color, replacing original content. Make non-pattern pixels within the compartment white (0).

```


**Natural Language Program**

1.  Determine the dimensions (height H, width W) of the input grid. Create an output grid of the same dimensions, initialized with the background color (white/0).
2.  Identify the 'separator color' by finding the most frequent color (excluding white/0) that forms continuous horizontal and vertical lines across the grid.
3.  Copy all pixels matching the 'separator color' from the input grid to their corresponding positions in the output grid.
4.  Identify the boundaries of the compartments created by the separator lines. Determine the size of these compartments (e.g., 4x4).
5.  Iterate through each horizontal 'row of compartments'. For each row of compartments:
    a.  Scan all the pixels within the compartments belonging to this row in the *input* grid.
    b.  Identify the single 'significant color' present in these scanned pixels. This significant color is the most frequent color found that is *not* white (0) and *not* the separator color, potentially ignoring specific 'noise' colors if present (like gray/5 or magenta/6 based on examples). Store this as the 'row color' for this row of compartments.
6.  Define the fixed 'stamp pattern' as a set of relative coordinates within a compartment (e.g., for a 4x4 compartment: `(0,1), (0,2), (1,2), (2,0), (2,1), (2,2), (2,3), (3,1)`).
7.  Iterate through each compartment location in the grid (identified in step 4).
    a.  Determine which row of compartments the current compartment belongs to.
    b.  Retrieve the 'row color' determined for that row in step 5b.
    c.  For each relative coordinate `(dr, dc)` in the 'stamp pattern':
        i.  Calculate the absolute coordinate `(r, c)` in the output grid by adding `(dr, dc)` to the top-left coordinate of the current compartment.
        ii. Set the pixel at `(r, c)` in the output grid to the 'row color'.
8.  Return the completed output grid.
