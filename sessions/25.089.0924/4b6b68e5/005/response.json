{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies regions fully enclosed by a single connected component of a uniform non-white color.\nFor each such enclosed region:\n1. Finds all \"seed\" pixels within the region. Seeds are pixels whose color is not white (0) and not the color of the enclosing boundary component.\n2. Counts the number of seed pixels (N_seeds).\n3. If N_seeds > 1:\n    a. Determines the most frequent color among the seeds (C_fill). Ties in frequency are broken by choosing the color with the smallest numerical index.\n    b. Changes the color of all pixels within the enclosed region (both original seeds and white pixels) to C_fill in the output grid.\n4. If N_seeds == 1:\n    a. Changes the color of the single seed pixel to white (0) in the output grid.\n5. If N_seeds == 0:\n    a. Leaves the region unchanged in the output grid.\nBoundary component pixels themselves remain unchanged in all cases.\nPixels not part of any identified enclosed region (e.g., exterior pixels, pixels between boundaries) also remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets 4-directionally adjacent valid neighbor coordinates.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_connected_components(grid_np):\n    \"\"\"\n    Finds all connected components of non-white pixels.\n\n    Args:\n        grid_np: Numpy array representing the grid.\n\n    Returns:\n        A list of tuples, where each tuple is (component_pixels_set, component_color).\n    \"\"\"\n    height, width = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    components = []\n    \n    for r in range(height):\n        for c in range(width):\n            color = grid_np[r, c]\n            # Start BFS if non-white and not visited\n            if color != 0 and not visited[r, c]:\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_pixels.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        # Check if neighbor has same color and not visited\n                        if grid_np[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if component_pixels:\n                    components.append((component_pixels, color))\n                    \n    return components\n\ndef find_interior_region(grid_np, component_pixels):\n    \"\"\"\n    Identifies the interior region enclosed by a given component.\n    Uses flood fill from edges, treating the component pixels as walls.\n\n    Args:\n        grid_np: Numpy array representing the grid.\n        component_pixels: A set of (r, c) tuples for the boundary component.\n\n    Returns:\n        A set of (r, c) tuples representing the interior pixels, \n        or an empty set if no interior exists or it touches the edge.\n    \"\"\"\n    height, width = grid_np.shape\n    \n    # Mark component pixels as walls (visited)\n    exterior_visited = np.zeros_like(grid_np, dtype=bool)\n    for r, c in component_pixels:\n        exterior_visited[r, c] = True\n        \n    q = deque()\n    \n    # Add edge pixels to queue if they are not walls (part of the component)\n    for r in range(height):\n        if not exterior_visited[r, 0]: q.append((r, 0)); exterior_visited[r, 0] = True\n        if not exterior_visited[r, width - 1]: q.append((r, width-1)); exterior_visited[r, width-1] = True\n    for c in range(width): # Handle top/bottom edges, avoid double-counting corners\n        if not exterior_visited[0, c]: q.append((0, c)); exterior_visited[0, c] = True\n        if not exterior_visited[height-1, c]: q.append((height-1, c)); exterior_visited[height-1, c] = True\n        \n    # Flood fill from edges to find all exterior pixels\n    while q:\n        r, c = q.popleft()\n        for nr, nc in get_neighbors(r, c, height, width):\n            if not exterior_visited[nr, nc]: # If neighbor is not wall and not visited\n                 exterior_visited[nr, nc] = True\n                 q.append((nr, nc))\n\n    # Identify interior pixels (those not visited by exterior flood and not walls)\n    interior_pixels_coords = set()\n    for r in range(height):\n        for c in range(width):\n            if not exterior_visited[r, c]: # Implies not wall and not exterior\n                interior_pixels_coords.add((r, c))\n                \n    return interior_pixels_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic based on enclosed regions and seed pixels.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Find all connected components of non-white pixels (potential boundaries)\n    boundary_components = find_connected_components(input_grid_np)\n\n    # 2. Iterate through each potential boundary component\n    for component_pixels, boundary_color in boundary_components:\n        \n        # 3. Identify the interior region enclosed by this component\n        interior_region_pixels = find_interior_region(input_grid_np, component_pixels)\n\n        # 4. If an interior region exists (is not empty)\n        if interior_region_pixels:\n            \n            # 5. Identify seed pixels within this interior region\n            seed_pixels = []\n            for r_int, c_int in interior_region_pixels:\n                pixel_color = input_grid_np[r_int, c_int]\n                # Seed is non-white (0) and not the boundary color\n                if pixel_color != 0 and pixel_color != boundary_color:\n                    seed_pixels.append({'color': pixel_color, 'pos': (r_int, c_int)})\n\n            # 6. Count the seeds\n            num_seeds = len(seed_pixels)\n\n            # 7. Apply transformation rules based on seed count\n            if num_seeds > 1:\n                # Find the most frequent seed color (tie-break with lowest index)\n                seed_colors = [s['color'] for s in seed_pixels]\n                color_counts = Counter(seed_colors)\n                max_freq = 0\n                if color_counts: # Ensure not empty list if num_seeds > 1\n                    max_freq = max(color_counts.values())\n                \n                most_frequent_colors = sorted([color for color, count in color_counts.items() if count == max_freq])\n                \n                if most_frequent_colors: # Check if list is not empty\n                     fill_color = most_frequent_colors[0] \n                else: \n                     # This case should ideally not be reached if num_seeds > 1 and seeds have colors\n                     # As a fallback, maybe use boundary color or black(0)? Let's use 0 for now.\n                     fill_color = 0 \n\n                # Flood fill the interior region in the output grid\n                for r_fill, c_fill in interior_region_pixels:\n                    output_grid[r_fill, c_fill] = fill_color\n\n            elif num_seeds == 1:\n                # Change the single seed pixel to white (0) in the output grid\n                seed_pos = seed_pixels[0]['pos']\n                output_grid[seed_pos[0], seed_pos[1]] = 0\n                \n            # else num_seeds == 0, do nothing to the region (it remains as copied initially)\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 31683,
    "candidates_token_count": 2045,
    "total_token_count": 33728,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.201707,
  "retries": 1
}