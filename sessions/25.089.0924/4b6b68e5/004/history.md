
## train_1

**input:**
```
0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 3 0 2 0 0 6 6 6 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0 6 0 3 0 0
0 0 2 2 2 0 3 0 0 0 2 0 0 6 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 6 6 6 6 6
0 0 0 0 2 0 0 0 8 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 0 0 4 0 0 0
0 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 8 0
3 0 0 0 0 0 0 4 8 0 3 0 8 0 4 0 0 0
0 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0
0 0 0 0 0 0 0 4 0 0 0 0 8 0 4 0 0 0
0 0 0 3 0 0 0 4 4 4 4 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 2 2 2 2 2 3 3 3 2 0 0 0 0 0 0 0
0 0 2 3 3 3 3 3 3 3 2 0 0 6 6 6 0 0
0 0 2 3 3 3 3 3 3 3 2 0 0 6 0 0 0 0
0 0 2 2 2 3 3 3 3 3 2 0 0 6 0 0 0 0
0 0 0 0 2 3 3 3 3 3 2 0 0 6 6 6 6 6
0 0 0 0 2 3 3 3 3 3 2 0 0 0 0 0 0 0
0 0 0 0 2 3 3 3 3 3 2 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 8 8 4 0 0 0
0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0
0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0
0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0
0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 8 8 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 5 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 0 8 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 8 0 0 8 2 0 0 0 0 3 3 3 3 0 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0 0 3 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 3 0 8 0 0 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 3 3 3 3 3 3 0
0 0 0 0 1 1 1 0 0 8 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 5 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 5 0 5 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 8 8 8 8 8 2 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 8 8 8 8 8 2 0 0 0 0 0 0 0 0 0
0 0 0 2 8 8 8 8 8 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 2 8 8 8 8 8 2 0 0 0 0 3 3 3 3 0 0 0
0 0 0 2 8 8 8 8 8 2 0 0 0 0 3 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 2 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 3 3 3 3 3 3 0
0 0 0 0 1 1 1 5 5 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 5 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 2 0 0 0 3 0 0 0
0 3 3 3 0 0 0 0 0 0 3 0 0 0
0 3 0 0 0 8 0 0 8 0 3 0 0 0
0 3 0 0 0 0 0 0 0 0 3 0 0 0
0 3 3 3 0 0 0 0 0 0 3 3 0 0
0 0 0 3 0 6 0 0 2 0 0 3 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0
0 0 3 3 0 0 0 0 0 0 0 3 0 0
0 0 3 0 0 0 0 6 0 0 0 3 0 0
0 0 3 0 0 6 0 3 3 3 3 3 0 0
0 0 3 0 0 0 0 3 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 6 6 6 6 6 6 3 0 0 0
0 3 3 3 6 6 6 6 6 6 3 0 0 0
0 3 6 6 6 6 6 6 6 6 3 0 0 0
0 3 6 6 6 6 6 6 6 6 3 0 0 0
0 3 3 3 6 6 6 6 6 6 3 3 0 0
0 0 0 3 6 6 6 6 6 6 6 3 0 0
0 0 0 3 6 6 6 6 6 6 6 3 0 0
0 0 3 3 6 6 6 6 6 6 6 3 0 0
0 0 3 6 6 6 6 6 6 6 6 3 0 0
0 0 3 6 6 6 6 3 3 3 3 3 0 0
0 0 3 6 6 6 6 3 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of Task Elements**

1.  **Input/Output Structure:** Both input and output are grids of colored pixels (integers 0-9). The grid dimensions remain the same.
2.  **Background:** The white (0) pixels forming the main background (connected to the grid edges) remain unchanged.
3.  **Boundaries:** Shapes or regions defined by a contiguous boundary of a single color (e.g., red=2, green=3, blue=1, yellow=4, magenta=6) seem central. These boundary pixels themselves generally remain unchanged in the output.
4.  **Interior Regions:** The transformation happens *inside* these bounded regions. "Inside" refers to pixels (both white and non-white) that are enclosed by the boundary and cannot reach the outer grid edge without crossing the boundary color.
5.  **Seed Pixels:** Within an enclosed region, non-white pixels that are *not* part of the boundary act as "seeds".
6.  **Transformation Logic:** The core logic depends on the *number* and *colors* of these seed pixels within a region enclosed by a single boundary color:
    *   **Multiple Seeds (>1):** If a region contains more than one seed pixel, the entire interior of that region (including interior white pixels and the original seed pixels) is flood-filled with a new color. This fill color is determined by finding the *most frequent* color among the original seed pixels within that region.
    *   **Single Seed (==1):** If a region contains exactly one seed pixel, that seed pixel is removed (changed to white 0). No filling occurs.
    *   **No Seeds (==0):** If a region contains no seed pixels (only interior white pixels), the interior remains unchanged.

**YAML Facts**


```yaml
Grid:
  Properties:
    - dimensions (height, width)
    - pixels (color, position)
Objects:
  - Type: Boundary
    Properties:
      - color (B > 0)
      - pixels (list of connected pixel positions with color B)
      - encloses: Region
  - Type: Region
    Properties:
      - interior_pixels (list of pixel positions inside a boundary)
      - boundary_color (color B of the enclosing boundary)
      - seed_pixels (list of non-white interior pixels)
        Properties:
          - color (C_seed > 0)
          - position
Relationships:
  - Enclosure: Boundary surrounds Region. A pixel is interior if all paths to the grid edge cross the Boundary color.
  - Connectivity: Pixels are connected (4-way adjacency) to form Boundaries or Regions.
  - Frequency: Used to determine the fill color from seed pixel colors.
Actions:
  - Identify_Boundaries: Find connected components of non-white colors.
  - Identify_Enclosed_Regions: For each potential boundary, find the set of interior pixels it fully encloses. Check if the boundary is formed by a single color.
  - Identify_Seeds: Find non-white pixels within an enclosed region.
  - Count_Seeds: Determine the number of seed pixels in a region.
  - Analyze_Seeds:
    - If count > 1: Calculate frequency of seed colors, find the most frequent color (C_fill).
    - If count == 1: Note the seed pixel to be removed.
    - If count == 0: No action needed for the region.
  - Transform_Region:
    - If count > 1: Flood fill the interior_pixels with C_fill.
    - If count == 1: Change the single seed pixel's color to white (0).
```


**Natural Language Program**

1.  Create the output grid as an exact copy of the input grid.
2.  Identify all regions within the grid that are fully enclosed by a boundary consisting of a single, uniform color (let this boundary color be `B`). A region is enclosed if its pixels cannot reach the grid edge without crossing a pixel of color `B`.
3.  For each such enclosed region:
    a.  Identify all "seed" pixels within the region. Seed pixels are those inside the boundary that are *not* white (0) and *not* the boundary color `B`.
    b.  Count the total number of seed pixels found (`N_seeds`).
    c.  **If `N_seeds` is greater than 1:**
        i.  Count the occurrences of each distinct color among the seed pixels.
        ii. Determine the color that appears most frequently among the seeds (let this be `C_fill`). (If there's a tie in frequency, assume a tie-breaking rule, e.g., choose the smallest color index).
        iii. Flood fill the entire interior of the enclosed region in the output grid with `C_fill`. This changes all original interior pixels (both white and seeds) to `C_fill`. The boundary pixels `B` remain unchanged.
    d.  **If `N_seeds` is exactly 1:**
        i.  Locate the single seed pixel in the output grid.
        ii. Change the color of this single seed pixel to white (0).
    e.  **If `N_seeds` is 0:**
        i.  Make no changes to this region in the output grid.
4.  Return the modified output grid.
```python
import numpy as np
from collections import Counter
import collections

"""
Identifies regions enclosed by a single-colored boundary.
For each enclosed region:
1. Finds all "seed" pixels within the region (non-white, non-boundary color).
2. Counts the number of seed pixels (N_seeds).
3. If N_seeds > 1:
    a. Determines the most frequent color among the seeds (C_fill). Ties are broken by choosing the smallest color index.
    b. Flood-fills the entire interior region (including original seeds and white pixels) with C_fill.
4. If N_seeds == 1:
    a. Changes the single seed pixel to white (0).
5. If N_seeds == 0:
    a. Leaves the region unchanged.
Boundary pixels remain unchanged in all cases.
Pixels outside any enclosed region also remain unchanged.
"""

def get_neighbors(r, c, height, width):
    """Gets 4-directionally adjacent neighbors within grid bounds."""
    neighbors = []
    if r > 0: neighbors.append((r - 1, c))
    if r < height - 1: neighbors.append((r + 1, c))
    if c > 0: neighbors.append((r, c - 1))
    if c < width - 1: neighbors.append((r, c + 1))
    return neighbors

def find_connected_components(grid, target_color):
    """Finds all connected components of a specific color."""
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(height):
        for c in range(width):
            if grid[r, c] == target_color and not visited[r, c]:
                component = set()
                q = collections.deque([(r, c)])
                visited[r, c] = True
                component.add((r, c))
                
                while q:
                    row, col = q.popleft()
                    for nr, nc in get_neighbors(row, col, height, width):
                        if grid[nr, nc] == target_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            component.add((nr, nc))
                            q.append((nr, nc))
                components.append(component)
    return components

def transform(input_grid):
    """
    Applies the described transformation to the input grid.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # 1. Identify all boundary pixels (any non-white color)
    boundary_pixels = set()
    boundary_colors = set(input_grid_np[input_grid_np != 0])
    all_boundary_coords = np.argwhere(input_grid_np != 0)
    for r, c in all_boundary_coords:
        boundary_pixels.add((r,c))
        
    # 2. Flood fill from edges to find exterior pixels
    # All pixels reachable from the edge without crossing *any* boundary are exterior.
    exterior_visited = np.zeros_like(input_grid_np, dtype=bool)
    q = collections.deque()

    for r in range(height):
        if (r, 0) not in boundary_pixels and not exterior_visited[r, 0]:
            q.append((r, 0))
            exterior_visited[r, 0] = True
        if (r, width - 1) not in boundary_pixels and not exterior_visited[r, width - 1]:
            q.append((r, width - 1))
            exterior_visited[r, width - 1] = True
    for c in range(width):
        if (0, c) not in boundary_pixels and not exterior_visited[0, c]:
            q.append((0, c))
            exterior_visited[0, c] = True
        if (height - 1, c) not in boundary_pixels and not exterior_visited[height - 1, c]:
             q.append((height - 1, c))
             exterior_visited[height - 1, c] = True
             
    while q:
        r, c = q.popleft()
        for nr, nc in get_neighbors(r, c, height, width):
            if (nr, nc) not in boundary_pixels and not exterior_visited[nr, nc]:
                exterior_visited[nr, nc] = True
                q.append((nr, nc))

    # 3. Identify potential interior pixels
    # These are pixels that are neither boundary nor exterior.
    potential_interior_pixels = []
    for r in range(height):
        for c in range(width):
            if not exterior_visited[r, c] and (r, c) not in boundary_pixels:
                potential_interior_pixels.append((r, c))

    # 4. Group potential interior pixels into connected regions
    interior_visited = np.zeros_like(input_grid_np, dtype=bool)
    interior_regions = []

    for r, c in potential_interior_pixels:
        if not interior_visited[r, c]:
            region = set()
            q = collections.deque([(r, c)])
            interior_visited[r, c] = True
            region.add((r, c))
            
            while q:
                row, col = q.popleft()
                # Check neighbors, including boundary pixels for adjacency check later, 
                # but only add non-boundary, non-exterior pixels to the region queue.
                for nr, nc in get_neighbors(row, col, height, width):
                     # Only expand within potential interior or onto boundaries
                     if not exterior_visited[nr, nc]: 
                         if (nr, nc) not in boundary_pixels and not interior_visited[nr, nc]:
                            interior_visited[nr, nc] = True
                            region.add((nr, nc))
                            q.append((nr, nc))
            
            if region: # Should always be true if started from potential_interior_pixels
                 interior_regions.append(region)

    # 5. Process each interior region
    for region_coords in interior_regions:
        adjacent_boundary_colors = set()
        adjacent_boundary_pixels = set()

        # Find all boundary pixels adjacent to this region
        for r, c in region_coords:
            for nr, nc in get_neighbors(r, c, height, width):
                if (nr, nc) in boundary_pixels:
                    adjacent_boundary_pixels.add((nr, nc))
                    adjacent_boundary_colors.add(input_grid_np[nr, nc])

        # Check if the region is enclosed by a single color boundary
        if len(adjacent_boundary_colors) == 1:
            boundary_color = adjacent_boundary_colors.pop() # Get the single boundary color
            
            # More rigorous check: ensure all adjacent boundary pixels belong to ONE connected component of that color
            # Find components of the boundary color
            boundary_components = find_connected_components(input_grid_np, boundary_color)
            
            enclosing_component = None
            for component in boundary_components:
                # Check if *all* adjacent boundary pixels found belong to this component
                if adjacent_boundary_pixels.issubset(component):
                    # Check if *all* pixels of this component are adjacent to the region or other component pixels
                    # (This helps distinguish nested boundaries from separate ones if complex)
                    # A simpler check for now: if we found a component containing all adjacent boundary pixels.
                     enclosing_component = component
                     break # Found the enclosing component

            if enclosing_component is not None:
                # This region is confirmed enclosed by a single component of boundary_color
                
                # Identify seed pixels within the region
                seed_pixels = []
                for r_int, c_int in region_coords:
                     pixel_color = input_grid_np[r_int, c_int]
                     # Seeds are non-white and not the boundary color
                     if pixel_color != 0 and pixel_color != boundary_color:
                         seed_pixels.append({'color': pixel_color, 'pos': (r_int, c_int)})

                num_seeds = len(seed_pixels)

                if num_seeds > 1:
                    # Count seed colors and find the most frequent
                    seed_colors = [s['color'] for s in seed_pixels]
                    color_counts = Counter(seed_colors)
                    # Find the max frequency
                    max_freq = 0
                    if color_counts:
                         max_freq = max(color_counts.values())
                    
                    # Get all colors with max frequency and choose the smallest index
                    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]
                    fill_color = min(most_frequent_colors) if most_frequent_colors else 0 # Default should not happen if N>1

                    # Flood fill the interior region in the output grid
                    for r_fill, c_fill in region_coords:
                        output_grid[r_fill, c_fill] = fill_color

                elif num_seeds == 1:
                    # Change the single seed pixel to white
                    seed_pos = seed_pixels[0]['pos']
                    output_grid[seed_pos[0], seed_pos[1]] = 0
                
                # else num_seeds == 0, do nothing to the region

    return output_grid.tolist() # Return as list of lists
```
```python
import numpy as np
from collections import Counter, deque

"""
Identifies regions completely enclosed by a single connected boundary component of a uniform color.
For each such enclosed region:
1. Finds all "seed" pixels within the region. Seeds are pixels whose color is not white (0) and not the color of the enclosing boundary.
2. Counts the number of seed pixels (N_seeds).
3. If N_seeds > 1:
    a. Determines the most frequent color among the seeds (C_fill). Ties in frequency are broken by choosing the color with the smallest numerical index.
    b. Flood-fills the entire interior region (including original seeds and white pixels) in the output grid with C_fill.
4. If N_seeds is 0 or 1:
    a. The region remains unchanged in the output grid.
Boundary pixels themselves remain unchanged in all cases.
Pixels not part of any identified enclosed region (e.g., exterior pixels, pixels between boundaries) also remain unchanged.
"""

def get_neighbors(r, c, height, width):
    """Gets 4-directionally adjacent valid neighbor coordinates."""
    neighbors = []
    if r > 0: neighbors.append((r - 1, c))
    if r < height - 1: neighbors.append((r + 1, c))
    if c > 0: neighbors.append((r, c - 1))
    if c < width - 1: neighbors.append((r, c + 1))
    return neighbors

def transform(input_grid):
    """
    Applies the region-based flood fill transformation.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = input_grid_np.shape

    # --- Step 1: Identify all boundary pixels and their connected components ---
    component_map = np.full((height, width), -1, dtype=int) # Maps pixel to component ID
    components = [] # List of sets, each set contains coords of a component
    component_colors = [] # List of colors corresponding to components list
    all_boundary_pixels = set() # Set of all non-white pixel coordinates
    component_id_counter = 0

    for r in range(height):
        for c in range(width):
            color = input_grid_np[r, c]
            if color != 0:
                all_boundary_pixels.add((r, c))
                if component_map[r, c] == -1: # Found start of a new component
                    comp_id = component_id_counter
                    current_component_pixels = set()
                    q = deque([(r, c)])
                    component_map[r, c] = comp_id
                    current_component_pixels.add((r, c))

                    while q:
                        row, col = q.popleft()
                        for nr, nc in get_neighbors(row, col, height, width):
                            if input_grid_np[nr, nc] == color and component_map[nr, nc] == -1:
                                component_map[nr, nc] = comp_id
                                current_component_pixels.add((nr, nc))
                                q.append((nr, nc))
                    
                    components.append(current_component_pixels)
                    component_colors.append(color)
                    component_id_counter += 1

    # --- Step 2: Identify Exterior Pixels ---
    # Pixels reachable from the edge without crossing any boundary pixel
    is_exterior = np.zeros((height, width), dtype=bool)
    q_exterior = deque()

    # Add edge pixels to queue if they are not boundaries
    for r in range(height):
        if (r, 0) not in all_boundary_pixels and not is_exterior[r, 0]:
            is_exterior[r, 0] = True
            q_exterior.append((r, 0))
        if (r, width - 1) not in all_boundary_pixels and not is_exterior[r, width - 1]:
            is_exterior[r, width - 1] = True
            q_exterior.append((r, width - 1))
    for c in range(1, width - 1): # Avoid double-adding corners
        if (0, c) not in all_boundary_pixels and not is_exterior[0, c]:
            is_exterior[0, c] = True
            q_exterior.append((0, c))
        if (height - 1, c) not in all_boundary_pixels and not is_exterior[height - 1, c]:
            is_exterior[height - 1, c] = True
            q_exterior.append((height - 1, c))

    # Flood fill to find all exterior pixels
    while q_exterior:
        r, c = q_exterior.popleft()
        for nr, nc in get_neighbors(r, c, height, width):
            if (nr, nc) not in all_boundary_pixels and not is_exterior[nr, nc]:
                is_exterior[nr, nc] = True
                q_exterior.append((nr, nc))

    # --- Step 3: Find and Process Enclosed Regions ---
    visited_for_regions = np.zeros((height, width), dtype=bool)

    for r in range(height):
        for c in range(width):
            # Potential start of an enclosed region: not boundary, not exterior, not yet processed
            if (r, c) not in all_boundary_pixels and not is_exterior[r, c] and not visited_for_regions[r, c]:
                
                current_region_pixels = set()
                adjacent_boundary_component_ids = set()
                q_region = deque()
                possible_region = True # Flag to check if region touches exterior during BFS

                # Start BFS for the potential region
                q_region.append((r, c))
                visited_for_regions[r, c] = True
                current_region_pixels.add((r, c))

                processed_in_this_bfs = set([(r,c)]) # Track pixels added to queue in this BFS run

                while q_region:
                    rr, cc = q_region.popleft()

                    # Check neighbors
                    for nr, nc in get_neighbors(rr, cc, height, width):
                        neighbor_pos = (nr, nc)
                        
                        if neighbor_pos in all_boundary_pixels:
                            # Found adjacent boundary pixel, record its component ID
                            adjacent_boundary_component_ids.add(component_map[nr, nc])
                        elif not is_exterior[nr, nc]:
                             # If it's an interior/unclassified pixel not yet visited in *this specific* BFS run
                             if neighbor_pos not in processed_in_this_bfs: 
                                visited_for_regions[nr, nc] = True # Mark globally visited
                                current_region_pixels.add(neighbor_pos)
                                q_region.append(neighbor_pos)
                                processed_in_this_bfs.add(neighbor_pos) # Mark visited for this run
                        # else: neighbor is exterior, means this region is not fully enclosed

                # --- Step 4: Analyze the found region ---
                # Check if it was enclosed by exactly one boundary component
                if len(adjacent_boundary_component_ids) == 1:
                    enclosing_comp_id = list(adjacent_boundary_component_ids)[0] # Get the single ID
                    boundary_color = component_colors[enclosing_comp_id]

                    # Identify seed pixels within this confirmed enclosed region
                    seed_pixels = []
                    for pr, pc in current_region_pixels:
                        pixel_color = input_grid_np[pr, pc]
                        if pixel_color != 0 and pixel_color != boundary_color:
                            seed_pixels.append(pixel_color)

                    num_seeds = len(seed_pixels)

                    # Apply transformation rule based on seed count
                    if num_seeds > 1:
                        # Find the most frequent seed color
                        if seed_pixels: # Ensure list is not empty
                             color_counts = Counter(seed_pixels)
                             max_freq = max(color_counts.values())
                             most_frequent_colors = sorted([color for color, count in color_counts.items() if count == max_freq])
                             fill_color = most_frequent_colors[0] # Smallest index tie-breaker

                             # Flood fill the region in the output grid
                             for fr, fc in current_region_pixels:
                                 output_grid[fr, fc] = fill_color
                    # If num_seeds is 0 or 1, do nothing (region remains as copied initially)

    # --- Step 5: Return result ---
    return output_grid.tolist()
```
