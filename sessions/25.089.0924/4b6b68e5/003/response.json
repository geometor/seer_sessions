{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies regions completely enclosed by a single connected boundary component of a uniform color.\nFor each such enclosed region:\n1. Finds all \"seed\" pixels within the region. Seeds are pixels whose color is not white (0) and not the color of the enclosing boundary.\n2. Counts the number of seed pixels (N_seeds).\n3. If N_seeds > 1:\n    a. Determines the most frequent color among the seeds (C_fill). Ties in frequency are broken by choosing the color with the smallest numerical index.\n    b. Flood-fills the entire interior region (including original seeds and white pixels) in the output grid with C_fill.\n4. If N_seeds is 0 or 1:\n    a. The region remains unchanged in the output grid.\nBoundary pixels themselves remain unchanged in all cases.\nPixels not part of any identified enclosed region (e.g., exterior pixels, pixels between boundaries) also remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets 4-directionally adjacent valid neighbor coordinates.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the region-based flood fill transformation.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # --- Step 1: Identify all boundary pixels and their connected components ---\n    component_map = np.full((height, width), -1, dtype=int) # Maps pixel to component ID\n    components = [] # List of sets, each set contains coords of a component\n    component_colors = [] # List of colors corresponding to components list\n    all_boundary_pixels = set() # Set of all non-white pixel coordinates\n    component_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            color = input_grid_np[r, c]\n            if color != 0:\n                all_boundary_pixels.add((r, c))\n                if component_map[r, c] == -1: # Found start of a new component\n                    comp_id = component_id_counter\n                    current_component_pixels = set()\n                    q = deque([(r, c)])\n                    component_map[r, c] = comp_id\n                    current_component_pixels.add((r, c))\n\n                    while q:\n                        row, col = q.popleft()\n                        for nr, nc in get_neighbors(row, col, height, width):\n                            if input_grid_np[nr, nc] == color and component_map[nr, nc] == -1:\n                                component_map[nr, nc] = comp_id\n                                current_component_pixels.add((nr, nc))\n                                q.append((nr, nc))\n                    \n                    components.append(current_component_pixels)\n                    component_colors.append(color)\n                    component_id_counter += 1\n\n    # --- Step 2: Identify Exterior Pixels ---\n    # Pixels reachable from the edge without crossing any boundary pixel\n    is_exterior = np.zeros((height, width), dtype=bool)\n    q_exterior = deque()\n\n    # Add edge pixels to queue if they are not boundaries\n    for r in range(height):\n        if (r, 0) not in all_boundary_pixels and not is_exterior[r, 0]:\n            is_exterior[r, 0] = True\n            q_exterior.append((r, 0))\n        if (r, width - 1) not in all_boundary_pixels and not is_exterior[r, width - 1]:\n            is_exterior[r, width - 1] = True\n            q_exterior.append((r, width - 1))\n    for c in range(1, width - 1): # Avoid double-adding corners\n        if (0, c) not in all_boundary_pixels and not is_exterior[0, c]:\n            is_exterior[0, c] = True\n            q_exterior.append((0, c))\n        if (height - 1, c) not in all_boundary_pixels and not is_exterior[height - 1, c]:\n            is_exterior[height - 1, c] = True\n            q_exterior.append((height - 1, c))\n\n    # Flood fill to find all exterior pixels\n    while q_exterior:\n        r, c = q_exterior.popleft()\n        for nr, nc in get_neighbors(r, c, height, width):\n            if (nr, nc) not in all_boundary_pixels and not is_exterior[nr, nc]:\n                is_exterior[nr, nc] = True\n                q_exterior.append((nr, nc))\n\n    # --- Step 3: Find and Process Enclosed Regions ---\n    visited_for_regions = np.zeros((height, width), dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            # Potential start of an enclosed region: not boundary, not exterior, not yet processed\n            if (r, c) not in all_boundary_pixels and not is_exterior[r, c] and not visited_for_regions[r, c]:\n                \n                current_region_pixels = set()\n                adjacent_boundary_component_ids = set()\n                q_region = deque()\n                possible_region = True # Flag to check if region touches exterior during BFS\n\n                # Start BFS for the potential region\n                q_region.append((r, c))\n                visited_for_regions[r, c] = True\n                current_region_pixels.add((r, c))\n\n                processed_in_this_bfs = set([(r,c)]) # Track pixels added to queue in this BFS run\n\n                while q_region:\n                    rr, cc = q_region.popleft()\n\n                    # Check neighbors\n                    for nr, nc in get_neighbors(rr, cc, height, width):\n                        neighbor_pos = (nr, nc)\n                        \n                        if neighbor_pos in all_boundary_pixels:\n                            # Found adjacent boundary pixel, record its component ID\n                            adjacent_boundary_component_ids.add(component_map[nr, nc])\n                        elif not is_exterior[nr, nc]:\n                             # If it's an interior/unclassified pixel not yet visited in *this specific* BFS run\n                             if neighbor_pos not in processed_in_this_bfs: \n                                visited_for_regions[nr, nc] = True # Mark globally visited\n                                current_region_pixels.add(neighbor_pos)\n                                q_region.append(neighbor_pos)\n                                processed_in_this_bfs.add(neighbor_pos) # Mark visited for this run\n                        # else: neighbor is exterior, means this region is not fully enclosed\n\n                # --- Step 4: Analyze the found region ---\n                # Check if it was enclosed by exactly one boundary component\n                if len(adjacent_boundary_component_ids) == 1:\n                    enclosing_comp_id = list(adjacent_boundary_component_ids)[0] # Get the single ID\n                    boundary_color = component_colors[enclosing_comp_id]\n\n                    # Identify seed pixels within this confirmed enclosed region\n                    seed_pixels = []\n                    for pr, pc in current_region_pixels:\n                        pixel_color = input_grid_np[pr, pc]\n                        if pixel_color != 0 and pixel_color != boundary_color:\n                            seed_pixels.append(pixel_color)\n\n                    num_seeds = len(seed_pixels)\n\n                    # Apply transformation rule based on seed count\n                    if num_seeds > 1:\n                        # Find the most frequent seed color\n                        if seed_pixels: # Ensure list is not empty\n                             color_counts = Counter(seed_pixels)\n                             max_freq = max(color_counts.values())\n                             most_frequent_colors = sorted([color for color, count in color_counts.items() if count == max_freq])\n                             fill_color = most_frequent_colors[0] # Smallest index tie-breaker\n\n                             # Flood fill the region in the output grid\n                             for fr, fc in current_region_pixels:\n                                 output_grid[fr, fc] = fill_color\n                    # If num_seeds is 0 or 1, do nothing (region remains as copied initially)\n\n    # --- Step 5: Return result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19202,
    "candidates_token_count": 2054,
    "total_token_count": 21256,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.029709,
  "retries": 1
}