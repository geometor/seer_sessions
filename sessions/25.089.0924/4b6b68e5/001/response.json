{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport collections\n\n\"\"\"\nIdentifies regions enclosed by a single-colored boundary.\nFor each enclosed region:\n1. Finds all \"seed\" pixels within the region (non-white, non-boundary color).\n2. Counts the number of seed pixels (N_seeds).\n3. If N_seeds > 1:\n    a. Determines the most frequent color among the seeds (C_fill). Ties are broken by choosing the smallest color index.\n    b. Flood-fills the entire interior region (including original seeds and white pixels) with C_fill.\n4. If N_seeds == 1:\n    a. Changes the single seed pixel to white (0).\n5. If N_seeds == 0:\n    a. Leaves the region unchanged.\nBoundary pixels remain unchanged in all cases.\nPixels outside any enclosed region also remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets 4-directionally adjacent neighbors within grid bounds.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_connected_components(grid, target_color):\n    \"\"\"Finds all connected components of a specific color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                component = set()\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                components.append(component)\n    return components\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify all boundary pixels (any non-white color)\n    boundary_pixels = set()\n    boundary_colors = set(input_grid_np[input_grid_np != 0])\n    all_boundary_coords = np.argwhere(input_grid_np != 0)\n    for r, c in all_boundary_coords:\n        boundary_pixels.add((r,c))\n        \n    # 2. Flood fill from edges to find exterior pixels\n    # All pixels reachable from the edge without crossing *any* boundary are exterior.\n    exterior_visited = np.zeros_like(input_grid_np, dtype=bool)\n    q = collections.deque()\n\n    for r in range(height):\n        if (r, 0) not in boundary_pixels and not exterior_visited[r, 0]:\n            q.append((r, 0))\n            exterior_visited[r, 0] = True\n        if (r, width - 1) not in boundary_pixels and not exterior_visited[r, width - 1]:\n            q.append((r, width - 1))\n            exterior_visited[r, width - 1] = True\n    for c in range(width):\n        if (0, c) not in boundary_pixels and not exterior_visited[0, c]:\n            q.append((0, c))\n            exterior_visited[0, c] = True\n        if (height - 1, c) not in boundary_pixels and not exterior_visited[height - 1, c]:\n             q.append((height - 1, c))\n             exterior_visited[height - 1, c] = True\n             \n    while q:\n        r, c = q.popleft()\n        for nr, nc in get_neighbors(r, c, height, width):\n            if (nr, nc) not in boundary_pixels and not exterior_visited[nr, nc]:\n                exterior_visited[nr, nc] = True\n                q.append((nr, nc))\n\n    # 3. Identify potential interior pixels\n    # These are pixels that are neither boundary nor exterior.\n    potential_interior_pixels = []\n    for r in range(height):\n        for c in range(width):\n            if not exterior_visited[r, c] and (r, c) not in boundary_pixels:\n                potential_interior_pixels.append((r, c))\n\n    # 4. Group potential interior pixels into connected regions\n    interior_visited = np.zeros_like(input_grid_np, dtype=bool)\n    interior_regions = []\n\n    for r, c in potential_interior_pixels:\n        if not interior_visited[r, c]:\n            region = set()\n            q = collections.deque([(r, c)])\n            interior_visited[r, c] = True\n            region.add((r, c))\n            \n            while q:\n                row, col = q.popleft()\n                # Check neighbors, including boundary pixels for adjacency check later, \n                # but only add non-boundary, non-exterior pixels to the region queue.\n                for nr, nc in get_neighbors(row, col, height, width):\n                     # Only expand within potential interior or onto boundaries\n                     if not exterior_visited[nr, nc]: \n                         if (nr, nc) not in boundary_pixels and not interior_visited[nr, nc]:\n                            interior_visited[nr, nc] = True\n                            region.add((nr, nc))\n                            q.append((nr, nc))\n            \n            if region: # Should always be true if started from potential_interior_pixels\n                 interior_regions.append(region)\n\n    # 5. Process each interior region\n    for region_coords in interior_regions:\n        adjacent_boundary_colors = set()\n        adjacent_boundary_pixels = set()\n\n        # Find all boundary pixels adjacent to this region\n        for r, c in region_coords:\n            for nr, nc in get_neighbors(r, c, height, width):\n                if (nr, nc) in boundary_pixels:\n                    adjacent_boundary_pixels.add((nr, nc))\n                    adjacent_boundary_colors.add(input_grid_np[nr, nc])\n\n        # Check if the region is enclosed by a single color boundary\n        if len(adjacent_boundary_colors) == 1:\n            boundary_color = adjacent_boundary_colors.pop() # Get the single boundary color\n            \n            # More rigorous check: ensure all adjacent boundary pixels belong to ONE connected component of that color\n            # Find components of the boundary color\n            boundary_components = find_connected_components(input_grid_np, boundary_color)\n            \n            enclosing_component = None\n            for component in boundary_components:\n                # Check if *all* adjacent boundary pixels found belong to this component\n                if adjacent_boundary_pixels.issubset(component):\n                    # Check if *all* pixels of this component are adjacent to the region or other component pixels\n                    # (This helps distinguish nested boundaries from separate ones if complex)\n                    # A simpler check for now: if we found a component containing all adjacent boundary pixels.\n                     enclosing_component = component\n                     break # Found the enclosing component\n\n            if enclosing_component is not None:\n                # This region is confirmed enclosed by a single component of boundary_color\n                \n                # Identify seed pixels within the region\n                seed_pixels = []\n                for r_int, c_int in region_coords:\n                     pixel_color = input_grid_np[r_int, c_int]\n                     # Seeds are non-white and not the boundary color\n                     if pixel_color != 0 and pixel_color != boundary_color:\n                         seed_pixels.append({'color': pixel_color, 'pos': (r_int, c_int)})\n\n                num_seeds = len(seed_pixels)\n\n                if num_seeds > 1:\n                    # Count seed colors and find the most frequent\n                    seed_colors = [s['color'] for s in seed_pixels]\n                    color_counts = Counter(seed_colors)\n                    # Find the max frequency\n                    max_freq = 0\n                    if color_counts:\n                         max_freq = max(color_counts.values())\n                    \n                    # Get all colors with max frequency and choose the smallest index\n                    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]\n                    fill_color = min(most_frequent_colors) if most_frequent_colors else 0 # Default should not happen if N>1\n\n                    # Flood fill the interior region in the output grid\n                    for r_fill, c_fill in region_coords:\n                        output_grid[r_fill, c_fill] = fill_color\n\n                elif num_seeds == 1:\n                    # Change the single seed pixel to white\n                    seed_pos = seed_pixels[0]['pos']\n                    output_grid[seed_pos[0], seed_pos[1]] = 0\n                \n                # else num_seeds == 0, do nothing to the region\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6317,
    "candidates_token_count": 2270,
    "total_token_count": 8587,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 131.166371,
  "retries": 2
}