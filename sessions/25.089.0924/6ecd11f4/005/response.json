{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all distinct contiguous regions (objects) of non-background (non-zero) pixels in the input grid.\n2. Find the object with the largest number of pixels. This is the `large_shape`. Record its color (`filter_color`).\n3. Among the *other* objects, find the one whose bounding box contains more than one distinct non-background color. This is the `key_grid_object`.\n4. Determine the rectangular bounding box (slice) that encloses the `key_grid_object`.\n5. Extract the sub-grid from the input grid defined by this bounding box. This is the `key_grid`.\n6. Define a set of 'target colors' to be replaced with white (0) based on the `filter_color`:\n    - If `filter_color` is blue (1), target colors are {blue (1), red (2), yellow (4), maroon (9)}.\n    - If `filter_color` is green (3), target colors are {blue (1), azure (8), maroon (9)}.\n    - If `filter_color` is azure (8), target colors are {blue (1), green (3), gray (5), orange (7)}.\n    - Otherwise, the target color set is empty.\n7. Create the output grid by making a copy of the `key_grid`.\n8. Iterate through each cell of the output grid. If the cell's color is in the 'target colors' set, change that cell's color to white (0).\n9. Return the modified output grid as a list of lists.\n\"\"\"\n\ndef find_objects_data(grid):\n    \"\"\"\n    Identifies all connected non-background objects in the grid and returns their properties.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains data for one object:\n              'label' (int): The unique label assigned by scipy.ndimage.label.\n              'size' (int): The number of pixels in the object.\n              'color' (int): The color of the object (taken from the first pixel).\n              'slice' (tuple): The slice representing the bounding box.\n              'bbox_shape' (tuple): The shape (height, width) of the bounding box.\n              'num_unique_bbox_non_bg_colors' (int): Count of unique non-background colors within the bounding box.\n    \"\"\"\n    background_color = 0\n    labeled_array, num_features = label(grid != background_color)\n    \n    if num_features == 0:\n        return []\n\n    object_slices = find_objects(labeled_array)\n    object_data = []\n\n    for i in range(1, num_features + 1):\n        mask = labeled_array == i\n        coords = np.argwhere(mask)\n        size = coords.shape[0]\n        obj_slice = object_slices[i-1]\n        bounding_box_grid = grid[obj_slice]\n        \n        # Count unique non-background colors within the bounding box\n        bbox_unique_colors = np.unique(bounding_box_grid)\n        num_bbox_unique_non_bg = len(bbox_unique_colors[bbox_unique_colors != background_color])\n        \n        # Get the color of the object itself (from the first pixel)\n        color = grid[coords[0, 0], coords[0, 1]]\n\n        object_data.append({\n            \"label\": i,\n            \"size\": size,\n            \"color\": color,\n            \"slice\": obj_slice,\n            \"bbox_shape\": bounding_box_grid.shape,\n            \"num_unique_bbox_non_bg_colors\": num_bbox_unique_non_bg\n        })\n        \n    # Sort objects by size, largest first\n    object_data.sort(key=lambda x: x[\"size\"], reverse=True)\n    return object_data\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic: identifies a large single-color object and a multi-color key grid,\n    then filters the key grid based on the large object's color.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    background_color = 0\n\n    # 1. Identify all non-background objects and their properties\n    all_objects = find_objects_data(grid)\n\n    if not all_objects:\n        return [[]] # No objects found\n\n    # 2. Find the largest object and its color\n    large_shape = all_objects[0]\n    filter_color = large_shape['color']\n\n    # 3. Find the key_grid_object among the *other* objects\n    key_grid_object = None\n    for obj in all_objects[1:]: # Skip the largest object\n        # Criterion: Bounding box contains more than one distinct non-background color\n        if obj['num_unique_bbox_non_bg_colors'] > 1:\n            key_grid_object = obj\n            break # Assume only one key grid object per example\n\n    if key_grid_object is None:\n        # Fallback if only one object exists or no object fits the multi-color bbox criteria\n        # Check if the largest object *itself* could be the key grid (if its bbox has multiple colors)\n        # This might happen if the 'large shape' is small or absent, and the key grid is the dominant feature.\n        if large_shape['num_unique_bbox_non_bg_colors'] > 1:\n             key_grid_object = large_shape\n             # If the key grid is the largest, what's the filter color? Maybe default to no filter?\n             filter_color = None # Indicate no specific filter color found from a separate large object\n        else:\n             return [[]] # No suitable key grid object found\n\n    # 4. Get the bounding box slice of the key_grid_object\n    key_grid_slice = key_grid_object['slice']\n    \n    # 5. Extract the key_grid\n    key_grid = grid[key_grid_slice]\n\n    # 6. Define target colors based on filter_color\n    target_colors = set()\n    if filter_color == 1: # Blue\n        target_colors = {1, 2, 4, 9}\n    elif filter_color == 3: # Green\n        target_colors = {1, 8, 9}\n    elif filter_color == 8: # Azure\n        target_colors = {1, 3, 5, 7}\n    # Add more rules here if needed for other filter colors\n\n    # 7. Create output grid as a copy\n    output_grid = key_grid.copy()\n\n    # 8. Iterate and apply filtering\n    rows, cols = output_grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] in target_colors:\n                output_grid[r, c] = background_color\n\n    # 9. Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22367,
    "candidates_token_count": 1663,
    "total_token_count": 24030,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.172133,
  "retries": 1
}