{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, maximum_position\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the largest contiguous non-background (white, 0) object in the input grid. Determine its color (`filter_color`).\n2. Identify the small, isolated rectangular patch of cells containing multiple distinct non-background colors (the `key_grid`).\n3. Define a set of 'target colors' to be replaced with white (0) based on the `filter_color`:\n    - If `filter_color` is blue (1), target colors are {blue (1), red (2), yellow (4), maroon (9)}.\n    - If `filter_color` is green (3), target colors are {blue (1), azure (8), maroon (9)}.\n    - If `filter_color` is azure (8), target colors are {blue (1), green (3), gray (5), orange (7)}.\n    - Otherwise, the target color set is empty.\n4. Create an output grid by copying the `key_grid`.\n5. Iterate through the output grid. If a cell's color is in the 'target colors' set, change its color to white (0).\n6. Return the modified output grid.\n\"\"\"\n\ndef find_largest_non_background_object(grid):\n    \"\"\"Finds the coordinates and color of the largest contiguous non-background object.\"\"\"\n    background_color = 0\n    non_background_mask = grid != background_color\n    \n    # Label connected components\n    labeled_array, num_features = label(non_background_mask)\n    \n    if num_features == 0:\n        return None, None # No non-background objects found\n\n    # Find the size of each component\n    component_sizes = np.bincount(labeled_array.ravel())\n    # component_sizes[0] is the background size, ignore it\n    if len(component_sizes) > 1:\n         # Find the label of the largest component (excluding background)\n        largest_component_label = np.argmax(component_sizes[1:]) + 1\n        \n        # Get the coordinates and color of the largest object\n        coords = np.argwhere(labeled_array == largest_component_label)\n        if coords.size > 0:\n            # Get the color from the original grid using the first coordinate\n            object_color = grid[coords[0, 0], coords[0, 1]]\n            # Get the slice (bounding box) of the largest object\n            obj_slice = find_objects(labeled_array == largest_component_label)[0]\n            return obj_slice, object_color, labeled_array == largest_component_label # Return slice, color, and mask\n    \n    return None, None, None # Should not happen if num_features > 0 and components exist\n\ndef find_key_grid_location(grid, largest_obj_mask):\n    \"\"\"\n    Finds the bounding box of the 'key grid'.\n    Assumes the key grid is composed of the non-background pixels\n    that are NOT part of the largest object.\n    \"\"\"\n    background_color = 0\n    \n    # Create a mask for potential key grid pixels:\n    # Must not be background AND must not be part of the largest object\n    potential_key_pixels_mask = (grid != background_color) & (~largest_obj_mask)\n    \n    coords = np.argwhere(potential_key_pixels_mask)\n    \n    if coords.shape[0] == 0:\n        return None # No key grid pixels found\n\n    # Find the bounding box\n    min_row, min_col = coords.min(axis=0)\n    max_row, max_col = coords.max(axis=0)\n    \n    # Return the slice representing the bounding box\n    return (slice(min_row, max_row + 1), slice(min_col, max_col + 1))\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    background_color = 0\n\n    # 1. Find the largest non-background object and its color\n    largest_obj_slice, filter_color, largest_obj_mask = find_largest_non_background_object(grid)\n\n    if largest_obj_slice is None or filter_color is None:\n        # Handle cases where no large object is found (return empty or original?)\n        # Based on examples, this shouldn't happen. If it did, maybe return an empty grid?\n        # For now, let's assume valid inputs as per examples.\n        # Returning the input might be safer if unsure.\n         print(\"Warning: Could not find a largest non-background object.\")\n         # Let's try finding *any* potential key grid even without a large object mask\n         largest_obj_mask = np.zeros_like(grid, dtype=bool) # Empty mask\n\n\n    # 2. Find the location (slice) of the key grid\n    key_grid_slice = find_key_grid_location(grid, largest_obj_mask)\n\n    if key_grid_slice is None:\n         print(\"Warning: Could not find key grid location.\")\n         return np.array([[]]) # Return empty grid if no key grid found\n\n\n    # Extract the key grid\n    key_grid = grid[key_grid_slice]\n    \n    # 3. Determine the set of target colors based on the filter_color\n    target_colors = set()\n    if filter_color == 1: # Blue\n        target_colors = {1, 2, 4, 9}\n    elif filter_color == 3: # Green\n        target_colors = {1, 8, 9}\n    elif filter_color == 8: # Azure\n        target_colors = {1, 3, 5, 7}\n    # Add more rules here if other filter colors appear in future examples\n\n    # 4. Create the output grid (start as a copy of the key grid)\n    output_grid = key_grid.copy()\n\n    # 5. & 6. Iterate and replace target colors with background color\n    rows, cols = output_grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] in target_colors:\n                output_grid[r, c] = background_color\n\n    return output_grid.tolist() # Return as list of lists as per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5609,
    "candidates_token_count": 1500,
    "total_token_count": 7109,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.413549,
  "retries": 1
}