{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the largest contiguous non-background (white, 0) object in the input grid. Determine its color (`filter_color`) and create a mask (`largest_obj_mask`) indicating its pixels.\n2. Identify all pixels in the input grid that are non-background AND are *not* part of the largest object. These are the `key_grid_pixels`.\n3. Calculate the minimum bounding box enclosing all `key_grid_pixels`.\n4. Extract the subgrid within this bounding box from the original input grid. This is the `key_grid`.\n5. Define a set of 'target colors' to be replaced with white (0) based on the `filter_color`:\n    - If `filter_color` is blue (1), target colors are {blue (1), red (2), yellow (4), maroon (9)}.\n    - If `filter_color` is green (3), target colors are {blue (1), azure (8), maroon (9)}.\n    - If `filter_color` is azure (8), target colors are {blue (1), green (3), gray (5), orange (7)}.\n    - Otherwise, the target color set is empty.\n6. Create an output grid by copying the `key_grid`.\n7. Iterate through the output grid. If a cell's color is in the 'target colors' set, change its color to white (0).\n8. Return the modified output grid as a list of lists.\n\"\"\"\n\ndef find_largest_non_background_object(grid):\n    \"\"\"\n    Finds the color and mask of the largest contiguous non-background object.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (object_color, object_mask) or (None, None) if no object found.\n               object_color (int): The color of the largest object.\n               object_mask (np.array): Boolean mask, True for pixels of the largest object.\n    \"\"\"\n    background_color = 0\n    non_background_mask = grid != background_color\n    \n    # Label connected components\n    labeled_array, num_features = label(non_background_mask)\n    \n    if num_features == 0:\n        return None, None # No non-background objects found\n\n    # Find the size of each component (excluding background label 0)\n    component_sizes = np.bincount(labeled_array.ravel())\n    if len(component_sizes) <= 1: # Only background found\n         return None, None\n         \n    # Find the label of the largest component (ignore background at index 0)\n    largest_component_label = np.argmax(component_sizes[1:]) + 1\n    \n    # Get coordinates of the largest object to find its color\n    coords = np.argwhere(labeled_array == largest_component_label)\n    if coords.size == 0: # Should not happen if component exists\n        return None, None\n        \n    # Get the color from the original grid using the first coordinate\n    object_color = grid[coords[0, 0], coords[0, 1]]\n    \n    # Create the mask for the largest object\n    object_mask = labeled_array == largest_component_label\n    \n    return object_color, object_mask\n\ndef find_key_grid(grid, largest_obj_mask):\n    \"\"\"\n    Finds the subgrid corresponding to the key grid.\n    The key grid is the bounding box of non-background pixels\n    that are NOT part of the largest object mask.\n\n    Args:\n        grid (np.array): The input grid.\n        largest_obj_mask (np.array): Boolean mask for the largest object.\n\n    Returns:\n        np.array: The extracted key grid, or None if not found.\n    \"\"\"\n    background_color = 0\n    \n    # Default to an empty mask if none provided (e.g., no largest object found)\n    if largest_obj_mask is None:\n        largest_obj_mask = np.zeros_like(grid, dtype=bool)\n\n    # Identify potential key pixels: non-background AND not in the largest object\n    potential_key_pixels_mask = (grid != background_color) & (~largest_obj_mask)\n    \n    # Get coordinates of these pixels\n    coords = np.argwhere(potential_key_pixels_mask)\n    \n    if coords.shape[0] == 0:\n        return None # No key grid pixels found\n\n    # Find the bounding box (min/max row and column)\n    min_row, min_col = coords.min(axis=0)\n    max_row, max_col = coords.max(axis=0)\n    \n    # Extract the subgrid using the bounding box slice\n    key_grid_slice = (slice(min_row, max_row + 1), slice(min_col, max_col + 1))\n    key_grid = grid[key_grid_slice]\n    \n    return key_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    background_color = 0\n\n    # 1. Find the largest non-background object and its color/mask\n    filter_color, largest_obj_mask = find_largest_non_background_object(grid)\n\n    # 2. & 3. & 4. Find the key grid (bounding box of other non-background pixels)\n    key_grid = find_key_grid(grid, largest_obj_mask)\n\n    if key_grid is None:\n        # Handle case where no key grid is found (e.g., return empty or specific error grid)\n        # Based on examples, a key grid should always exist if input is valid.\n        # Returning an empty list of lists might be a reasonable default.\n        return [[]] \n        \n    # 5. Determine the set of target colors based on the filter_color\n    target_colors = set()\n    if filter_color == 1: # Blue\n        target_colors = {1, 2, 4, 9}\n    elif filter_color == 3: # Green\n        target_colors = {1, 8, 9}\n    elif filter_color == 8: # Azure\n        target_colors = {1, 3, 5, 7}\n    # Note: If filter_color is None (no large object found), target_colors remains empty,\n    # so the key_grid would be returned unmodified (if found).\n\n    # 6. Create the output grid (start as a copy of the key grid)\n    output_grid = key_grid.copy()\n\n    # 7. Iterate and replace target colors with background color\n    rows, cols = output_grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] in target_colors:\n                output_grid[r, c] = background_color\n\n    # 8. Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23180,
    "candidates_token_count": 1660,
    "total_token_count": 24840,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.881017,
  "retries": 1
}