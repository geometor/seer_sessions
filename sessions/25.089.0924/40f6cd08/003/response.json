{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1. Identify all distinct rectangular objects in the input grid against the white (0) background. An object is a connected component of non-background pixels. A rectangular object is one where the connected component perfectly fills its bounding box.\n2. Distinguish between two types of rectangular objects:\n   - \"Simple Rectangles\": Filled entirely with a single solid color.\n   - \"Pattern Rectangle\": Has an outer frame (1-pixel thick border) of one color and an interior area containing different colors or patterns. Assume there is at most one such Pattern Rectangle per input grid.\n3. If a Pattern Rectangle exists:\n   a. Extract its frame color and its inner pattern (the grid content inside the frame).\n   b. Iterate through all identified Simple Rectangles.\n   c. If a Simple Rectangle's solid color matches the Pattern Rectangle's frame color, and the Simple Rectangle is large enough to have an interior (at least 3x3):\n      i. Copy the inner pattern from the Pattern Rectangle.\n      ii. Place this pattern into the interior area of the Simple Rectangle (the area inside its 1-pixel border).\n      iii. If the Simple Rectangle's interior is smaller than the pattern, crop the pattern (copy only the top-left portion that fits).\n      iv. If the Simple Rectangle's interior is larger, only the top-left portion corresponding to the pattern's size is filled (as suggested by cropping behavior in examples).\n4. Rectangles (Simple or Patterned) that do not meet the matching criteria, as well as the original Pattern Rectangle itself, remain unchanged in the output.\n5. The background remains unchanged.\n6. The output grid has the same dimensions as the input grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef bfs_find_connected(grid, start_coord, visited):\n    \"\"\"\n    Finds all connected non-background (non-zero) pixels starting from\n    start_coord using Breadth-First Search. Marks visited pixels.\n    Returns a list of (row, col) coordinates for the connected component.\n    \"\"\"\n    q = deque([start_coord])\n    coords = set()\n    h, w = grid.shape\n    start_r, start_c = start_coord\n\n    # Check if starting point is valid (non-background and not visited)\n    if not (0 <= start_r < h and 0 <= start_c < w) or \\\n       grid[start_r, start_c] == 0 or \\\n       visited[start_r, start_c]:\n        return [] # Return empty list if start is invalid\n\n    # Mark start as visited and add to coordinates\n    visited[start_r, start_c] = True\n    coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not visited, and if not background\n            if 0 <= nr < h and 0 <= nc < w and \\\n               not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                coords.add((nr, nc))\n                q.append((nr, nc))\n    return list(coords)\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimum bounding box (min_r, min_c, max_r, max_c)\n    for a list/set of coordinates. Returns None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_solid_rectangle(grid, coords, bbox):\n    \"\"\"\n    Checks if a connected component (coords) forms a solid rectangle\n    within its bounding box (bbox), meaning all pixels within the bbox\n    are part of the component and are non-background.\n    \"\"\"\n    if not coords or not bbox:\n        return False\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Check 1: Does the number of coords match the bbox area?\n    if len(coords) != obj_h * obj_w:\n        return False\n\n    # Check 2: Are all pixels within the bbox non-zero and part of the coords set?\n    # This check might be redundant if Check 1 passes and BFS worked correctly,\n    # but it's a safeguard. We primarily rely on Check 1 after BFS.\n    coords_set = set(coords)\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # If a pixel inside the box is background, it's not a solid rect.\n            if grid[r, c] == 0:\n                return False\n            # If a pixel inside the box wasn't found by BFS (shouldn't happen if BFS is correct for solid shapes)\n            if (r,c) not in coords_set:\n                 return False # Should be covered by check 1 generally\n    return True\n\ndef classify_object(grid, coords, bbox):\n    \"\"\"\n    Classifies a connected component, confirmed to be a solid rectangle,\n    as either 'simple' (single color) or 'pattern' (frame + different interior).\n    Returns a dictionary with object info or None if classification fails.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Use the top-left color as the reference\n    ref_color = grid[min_r, min_c]\n\n    # Check if it's a simple rectangle (all pixels match ref_color)\n    is_simple = True\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r, c] != ref_color:\n                is_simple = False\n                break\n        if not is_simple:\n            break\n\n    if is_simple:\n        return {'type': 'simple', 'color': ref_color, 'bbox': bbox}\n\n    # If not simple, check if it's a pattern rectangle (needs frame)\n    # Check requires at least 3x3 size for an interior\n    if obj_h >= 3 and obj_w >= 3:\n        frame_color = grid[min_r, min_c] # Assume frame color is top-left color\n        frame_ok = True\n        # Check top row\n        for c in range(min_c, max_c + 1):\n            if grid[min_r, c] != frame_color: frame_ok = False; break\n        # Check bottom row\n        if frame_ok:\n            for c in range(min_c, max_c + 1):\n                if grid[max_r, c] != frame_color: frame_ok = False; break\n        # Check left column (excluding corners already checked)\n        if frame_ok:\n            for r in range(min_r + 1, max_r):\n                if grid[r, min_c] != frame_color: frame_ok = False; break\n        # Check right column (excluding corners already checked)\n        if frame_ok:\n            for r in range(min_r + 1, max_r):\n                if grid[r, max_c] != frame_color: frame_ok = False; break\n\n        # If frame is consistent, check if the interior has at least one different color\n        interior_differs = False\n        if frame_ok:\n            for r in range(min_r + 1, max_r):\n                for c in range(min_c + 1, max_c):\n                    if grid[r, c] != frame_color:\n                        interior_differs = True\n                        break\n                if interior_differs:\n                    break\n\n        # If frame is consistent and interior differs, classify as pattern\n        if frame_ok and interior_differs:\n            # Extract the inner pattern (area inside the frame)\n            inner_pattern = grid[min_r+1 : max_r, min_c+1 : max_c]\n            return {'type': 'pattern', 'frame_color': frame_color, 'bbox': bbox, 'inner_pattern': inner_pattern.copy()}\n\n    # If it's neither simple nor a valid pattern rectangle based on these criteria\n    return None\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds a unique pattern rectangle and copies its\n    inner pattern into simple rectangles of the same color as the pattern's frame.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = input_grid_np.copy()\n    h, w = input_grid_np.shape\n    # Keep track of visited pixels to avoid processing objects multiple times\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    simple_rects = []\n    pattern_rect = None\n\n    # 1. Find and classify all objects\n    for r in range(h):\n        for c in range(w):\n            # If pixel is non-background and not yet visited, start BFS\n            if input_grid_np[r, c] != 0 and not visited[r, c]:\n                # Find all connected non-background pixels for this object\n                coords = bfs_find_connected(input_grid_np, (r, c), visited)\n\n                if coords:\n                    # Calculate the bounding box for the object\n                    bbox = get_bounding_box(coords)\n\n                    # Check if the object perfectly fills its bounding box (is a solid rectangle)\n                    if is_solid_rectangle(input_grid_np, coords, bbox):\n                        # Classify the rectangle as simple or pattern\n                        obj_info = classify_object(input_grid_np, coords, bbox)\n\n                        if obj_info:\n                            if obj_info['type'] == 'simple':\n                                simple_rects.append(obj_info)\n                            elif obj_info['type'] == 'pattern':\n                                # Assume only one pattern rectangle exists per grid\n                                if pattern_rect is None:\n                                    pattern_rect = obj_info\n                                else:\n                                    # Found multiple pattern rectangles, which contradicts assumption.\n                                    # Sticking to the first one found based on scan order.\n                                    pass\n                    #else:\n                        # Object is not a solid rectangle, ignore it for this task\n\n\n    # 2. Apply transformation if a pattern rectangle was found\n    if pattern_rect is None:\n        # No pattern rectangle found, return the original grid\n        return output_grid.tolist()\n\n    # Get pattern details\n    pattern_frame_color = pattern_rect['frame_color']\n    source_pattern = pattern_rect['inner_pattern']\n    \n    # Check if the pattern has content\n    if source_pattern.size == 0:\n         # The pattern rectangle might be 3x3 or similar, having a frame but no distinct interior pixels to copy.\n         return output_grid.tolist() \n         \n    source_h, source_w = source_pattern.shape\n\n    # 3. Iterate through simple rectangles and apply the pattern if colors match\n    for simple_obj in simple_rects:\n        # Check if the simple rectangle's color matches the pattern's frame color\n        if simple_obj['color'] == pattern_frame_color:\n            min_r, min_c, max_r, max_c = simple_obj['bbox']\n            simple_h = max_r - min_r + 1\n            simple_w = max_c - min_c + 1\n\n            # Check if the simple rectangle is large enough to have an interior (at least 3x3)\n            if simple_h >= 3 and simple_w >= 3:\n                # Calculate target interior top-left corner and dimensions\n                target_top, target_left = min_r + 1, min_c + 1\n                # Interior height and width\n                target_h = simple_h - 2\n                target_w = simple_w - 2\n\n                # Determine the dimensions of the pattern block to copy (cropping if needed)\n                copy_h = min(source_h, target_h)\n                copy_w = min(source_w, target_w)\n\n                # Ensure there are dimensions to copy\n                if copy_h > 0 and copy_w > 0:\n                    # Select the top-left portion of the source pattern to copy\n                    pattern_to_copy = source_pattern[:copy_h, :copy_w]\n\n                    # Place the cropped pattern onto the output grid's interior section\n                    output_grid[target_top : target_top + copy_h, target_left : target_left + copy_w] = pattern_to_copy\n\n    # Convert the final numpy array back to a list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 33746,
    "candidates_token_count": 3181,
    "total_token_count": 36927,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.904405,
  "retries": 1
}