{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies rectangular objects in the input grid. Distinguishes between:\n1. Simple Rectangles: Filled with a single solid color.\n2. Pattern Rectangle: Has a 1-pixel frame of one color and an interior containing at least one pixel of a different color. Assumes at most one Pattern Rectangle exists.\n\nTransformation:\n- Finds the unique Pattern Rectangle.\n- Finds all Simple Rectangles whose solid color matches the Pattern Rectangle's frame color and are at least 3x3.\n- Copies the inner pattern from the Pattern Rectangle into the inner area of each matching Simple Rectangle.\n- If the target Simple Rectangle's inner area is smaller than the source pattern, the pattern is cropped (top-left portion is copied).\n- Other rectangles and the background remain unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef bfs_find_connected(grid, start_coord, visited):\n    \"\"\"\n    Finds all connected non-background (non-zero) pixels starting from\n    start_coord using Breadth-First Search. Marks visited pixels.\n    Returns a set of (row, col) coordinates for the connected component.\n    \"\"\"\n    q = deque([start_coord])\n    coords = set()\n    h, w = grid.shape\n    start_r, start_c = start_coord\n\n    # Check if starting point is valid (non-background and not visited)\n    if not (0 <= start_r < h and 0 <= start_c < w) or \\\n       grid[start_r, start_c] == 0 or \\\n       visited[start_r, start_c]:\n        return set() # Return empty set if start is invalid\n\n    # Mark start as visited and add to coordinates\n    visited[start_r, start_c] = True\n    coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not visited, and if not background\n            if 0 <= nr < h and 0 <= nc < w and \\\n               not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                coords.add((nr, nc))\n                q.append((nr, nc))\n    return coords\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimum bounding box (min_r, min_c, max_r, max_c)\n    for a set of coordinates. Returns None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_solid_rectangle(grid, coords, bbox):\n    \"\"\"\n    Checks if a connected component (coords) perfectly forms a solid rectangle\n    within its bounding box (bbox), meaning all pixels within the bbox\n    are part of the component and are non-background.\n    \"\"\"\n    if not coords or not bbox:\n        return False\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Check 1: Does the number of coords match the bbox area?\n    if len(coords) != obj_h * obj_w:\n        return False\n\n    # Check 2: Are all pixels within the bbox non-zero?\n    # (This check confirms no background holes within the bbox)\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r, c] == 0:\n                return False # Background pixel found inside the bounding box\n    return True\n\ndef classify_rectangle(grid, bbox):\n    \"\"\"\n    Classifies a confirmed solid rectangular region defined by bbox\n    as either 'simple' or 'pattern'.\n    Returns a dictionary with object info or None if classification fails.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Extract the rectangle content\n    rect_slice = grid[min_r:max_r+1, min_c:max_c+1]\n\n    # Use the top-left color as the reference\n    ref_color = rect_slice[0, 0]\n\n    # Check if it's a simple rectangle (all pixels match ref_color)\n    if np.all(rect_slice == ref_color):\n        return {'type': 'simple', 'color': ref_color, 'bbox': bbox}\n\n    # If not simple, check if it's a pattern rectangle (needs frame)\n    # Check requires at least 3x3 size for an interior\n    if obj_h >= 3 and obj_w >= 3:\n        frame_color = rect_slice[0, 0] # Assume frame color is top-left\n        frame_ok = True\n        # Check top row\n        if not np.all(rect_slice[0, :] == frame_color): frame_ok = False\n        # Check bottom row\n        if frame_ok and not np.all(rect_slice[-1, :] == frame_color): frame_ok = False\n        # Check left column\n        if frame_ok and not np.all(rect_slice[:, 0] == frame_color): frame_ok = False\n        # Check right column\n        if frame_ok and not np.all(rect_slice[:, -1] == frame_color): frame_ok = False\n\n        # If frame is consistent, check if the interior has at least one different color\n        interior_differs = False\n        if frame_ok:\n            inner_slice = rect_slice[1:-1, 1:-1]\n            if np.any(inner_slice != frame_color):\n                interior_differs = True\n\n        # If frame is consistent and interior differs, classify as pattern\n        if frame_ok and interior_differs:\n            inner_pattern = inner_slice # Already extracted\n            return {'type': 'pattern', 'frame_color': frame_color, 'bbox': bbox, 'inner_pattern': inner_pattern.copy()}\n\n    # If it's neither simple nor a valid pattern rectangle\n    # This might happen for multi-colored rectangles without a proper frame. Ignore for this task.\n    return None\n\ndef paste_pattern(output_grid, target_bbox, source_pattern):\n    \"\"\"\n    Pastes the source_pattern into the inner area of the target_bbox\n    on the output_grid, cropping the pattern if necessary.\n    Assumes target_bbox corresponds to a rectangle >= 3x3.\n    \"\"\"\n    min_r, min_c, max_r, max_c = target_bbox\n    target_h = max_r - min_r + 1\n    target_w = max_c - min_c + 1\n\n    # Ensure target is large enough (redundant check if called correctly)\n    if target_h < 3 or target_w < 3:\n        return\n\n    # Pattern details\n    if source_pattern.size == 0: return # Nothing to paste\n    source_h, source_w = source_pattern.shape\n\n    # Target interior details\n    target_inner_top, target_inner_left = min_r + 1, min_c + 1\n    target_inner_h = target_h - 2\n    target_inner_w = target_w - 2\n\n    # Determine copy dimensions (cropping)\n    copy_h = min(source_h, target_inner_h)\n    copy_w = min(source_w, target_inner_w)\n\n    # Perform copy if dimensions are valid\n    if copy_h > 0 and copy_w > 0:\n        pattern_to_copy = source_pattern[:copy_h, :copy_w]\n        output_grid[target_inner_top : target_inner_top + copy_h,\n                    target_inner_left : target_inner_left + copy_w] = pattern_to_copy\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds a unique pattern rectangle and copies its\n    inner pattern into simple rectangles of the same color as the pattern's frame.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = input_grid_np.copy()\n    h, w = input_grid_np.shape\n    # Keep track of visited pixels to avoid processing objects multiple times\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    all_objects = []\n\n    # 1. Find and classify all solid rectangular objects\n    for r in range(h):\n        for c in range(w):\n            # If pixel is non-background and not yet visited, start BFS\n            if input_grid_np[r, c] != 0 and not visited[r, c]:\n                # Find all connected non-background pixels for this component\n                coords = bfs_find_connected(input_grid_np, (r, c), visited)\n\n                if coords:\n                    # Calculate the bounding box for the component\n                    bbox = get_bounding_box(coords)\n\n                    # Check if the component perfectly fills its bounding box (is a solid rectangle)\n                    if is_solid_rectangle(input_grid_np, coords, bbox):\n                        # Classify the solid rectangle\n                        obj_info = classify_rectangle(input_grid_np, bbox)\n                        if obj_info:\n                            all_objects.append(obj_info)\n                    # else:\n                    # Component is not a solid rectangle, ignore it\n\n    # 2. Separate simple and pattern objects (assuming only one pattern)\n    simple_rects = []\n    pattern_rect = None\n    for obj in all_objects:\n        if obj['type'] == 'simple':\n            simple_rects.append(obj)\n        elif obj['type'] == 'pattern':\n            if pattern_rect is None: # Store the first pattern rect found\n                pattern_rect = obj\n            # else: Ignore subsequent pattern rects if assumption holds\n\n    # 3. Apply transformation if a pattern rectangle was found\n    if pattern_rect is None:\n        # No pattern rectangle found, return the original grid\n        return output_grid.tolist()\n\n    # Get pattern details\n    pattern_frame_color = pattern_rect['frame_color']\n    source_pattern = pattern_rect['inner_pattern']\n\n    # 4. Iterate through simple rectangles and apply the pattern if colors match and size allows\n    for simple_obj in simple_rects:\n        # Check if the simple rectangle's color matches the pattern's frame color\n        if simple_obj['color'] == pattern_frame_color:\n            min_r, min_c, max_r, max_c = simple_obj['bbox']\n            simple_h = max_r - min_r + 1\n            simple_w = max_c - min_c + 1\n\n            # Check if the simple rectangle is large enough to have an interior (at least 3x3)\n            if simple_h >= 3 and simple_w >= 3:\n                # Paste the pattern (handles cropping internally)\n                paste_pattern(output_grid, simple_obj['bbox'], source_pattern)\n\n    # Convert the final numpy array back to a list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 46501,
    "candidates_token_count": 2814,
    "total_token_count": 49315,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.110759,
  "retries": 1
}