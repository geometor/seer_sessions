{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1. Identify all distinct, solid, rectangular objects in the input grid against the white (0) background. An object is a connected component of non-background pixels. A rectangular object is one where the connected component perfectly fills its bounding box without any background holes.\n2. Distinguish between two types of these rectangular objects:\n   - \"Simple Rectangles\": Filled entirely with a single solid color.\n   - \"Pattern Rectangle\": Has an outer frame (1-pixel thick border) of one color and an interior area containing at least one pixel of a different color. Assume there is at most one such Pattern Rectangle per input grid.\n3. If a Pattern Rectangle exists:\n   a. Extract its frame color and its inner pattern (the grid content inside the 1-pixel frame).\n   b. Iterate through all identified Simple Rectangles.\n   c. If a Simple Rectangle's solid color matches the Pattern Rectangle's frame color, and the Simple Rectangle is large enough to have an interior (at least 3x3 in size):\n      i. Copy the inner pattern from the Pattern Rectangle.\n      ii. Place this pattern into the interior area of the Simple Rectangle (the area inside its 1-pixel border), aligning the top-left corner of the pattern with the top-left corner of the Simple Rectangle's interior.\n      iii. If the Simple Rectangle's interior is smaller than the pattern, crop the pattern (copy only the top-left portion that fits).\n4. Rectangles (Simple or Patterned) that do not meet the matching criteria, as well as the original Pattern Rectangle itself, remain unchanged in the output.\n5. The background remains unchanged.\n6. The output grid has the same dimensions as the input grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef bfs_find_connected(grid, start_coord, visited):\n    \"\"\"\n    Finds all connected non-background (non-zero) pixels starting from\n    start_coord using Breadth-First Search. Marks visited pixels.\n    Returns a set of (row, col) coordinates for the connected component.\n    \"\"\"\n    q = deque([start_coord])\n    coords = set()\n    h, w = grid.shape\n    start_r, start_c = start_coord\n\n    # Check if starting point is valid (non-background and not visited)\n    if not (0 <= start_r < h and 0 <= start_c < w) or \\\n       grid[start_r, start_c] == 0 or \\\n       visited[start_r, start_c]:\n        return set() # Return empty set if start is invalid\n\n    # Mark start as visited and add to coordinates\n    visited[start_r, start_c] = True\n    coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not visited, and if not background\n            if 0 <= nr < h and 0 <= nc < w and \\\n               not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                coords.add((nr, nc))\n                q.append((nr, nc))\n    return coords\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimum bounding box (min_r, min_c, max_r, max_c)\n    for a set of coordinates. Returns None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_solid_rectangle(grid, coords, bbox):\n    \"\"\"\n    Checks if a connected component (coords) perfectly forms a solid rectangle\n    within its bounding box (bbox), meaning all pixels within the bbox\n    are part of the component and are non-background.\n    \"\"\"\n    if not coords or not bbox:\n        return False\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Check 1: Does the number of coords match the bbox area?\n    if len(coords) != obj_h * obj_w:\n        return False\n\n    # Check 2: Are all pixels within the bbox non-zero?\n    # This confirms no background holes within the bbox for the found component\n    # This check might seem redundant if Check 1 passed and BFS worked on a truly solid rectangle,\n    # but ensures we're dealing with a filled rectangle based on the grid values themselves within the box.\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # If a pixel inside the bounding box is background, it's not solid.\n            if grid[r, c] == 0:\n                 # This case should ideally be caught by check 1 if BFS found fewer coords than bbox area.\n                 # Including it adds robustness against weird shapes.\n                return False\n            # Additionally, confirm the pixel was part of the found component (coords).\n            # This ensures the component *is* the rectangle, not just contained within it.\n            if (r, c) not in coords:\n                return False # Should also be caught by check 1.\n    return True\n\ndef classify_rectangle(grid, bbox):\n    \"\"\"\n    Classifies a confirmed solid rectangular region defined by bbox\n    as either 'simple' or 'pattern'.\n    Returns a dictionary with object info or None if classification fails.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    # Extract the rectangle content directly using bbox for efficiency\n    rect_slice = grid[min_r:max_r+1, min_c:max_c+1]\n\n    # Use the top-left color as the reference\n    ref_color = rect_slice[0, 0]\n\n    # Check if it's a simple rectangle (all pixels match ref_color)\n    if np.all(rect_slice == ref_color):\n        return {'type': 'simple', 'color': ref_color, 'bbox': bbox}\n\n    # If not simple, check if it's a pattern rectangle (needs frame)\n    # Check requires at least 3x3 size for an interior\n    if obj_h >= 3 and obj_w >= 3:\n        frame_color = rect_slice[0, 0] # Assume frame color is top-left\n        frame_ok = True\n        # Check top row\n        if not np.all(rect_slice[0, :] == frame_color): frame_ok = False\n        # Check bottom row\n        if frame_ok and not np.all(rect_slice[-1, :] == frame_color): frame_ok = False\n        # Check left column\n        if frame_ok and not np.all(rect_slice[:, 0] == frame_color): frame_ok = False\n        # Check right column\n        if frame_ok and not np.all(rect_slice[:, -1] == frame_color): frame_ok = False\n\n        # If frame is consistent, check if the interior has at least one different color\n        interior_differs = False\n        if frame_ok:\n            inner_slice = rect_slice[1:-1, 1:-1]\n            # Check if any element in the inner slice is different from the frame color\n            if np.any(inner_slice != frame_color):\n                interior_differs = True\n\n        # If frame is consistent and interior differs, classify as pattern\n        if frame_ok and interior_differs:\n            inner_pattern = inner_slice # Already sliced\n            return {'type': 'pattern', 'frame_color': frame_color, 'bbox': bbox, 'inner_pattern': inner_pattern.copy()}\n\n    # If it's neither simple nor a valid pattern rectangle (e.g., multi-colored without proper frame)\n    return None\n\ndef paste_pattern(output_grid, target_bbox, source_pattern):\n    \"\"\"\n    Pastes the source_pattern into the inner area of the target_bbox\n    on the output_grid, cropping the pattern if necessary.\n    Assumes target_bbox corresponds to a rectangle >= 3x3.\n    \"\"\"\n    min_r, min_c, max_r, max_c = target_bbox\n    target_h = max_r - min_r + 1\n    target_w = max_c - min_c + 1\n\n    # Basic check: ensure target is large enough for an interior\n    if target_h < 3 or target_w < 3:\n        return # Cannot paste into something without an interior\n\n    # Pattern details\n    if source_pattern is None or source_pattern.size == 0:\n        return # Nothing to paste\n\n    source_h, source_w = source_pattern.shape\n\n    # Target interior details: top-left corner coordinates and dimensions\n    target_inner_top, target_inner_left = min_r + 1, min_c + 1\n    target_inner_h = target_h - 2\n    target_inner_w = target_w - 2\n\n    # Determine copy dimensions (cropping based on minimum of source/target interior)\n    copy_h = min(source_h, target_inner_h)\n    copy_w = min(source_w, target_inner_w)\n\n    # Perform copy only if there are valid dimensions to copy\n    if copy_h > 0 and copy_w > 0:\n        # Select the top-left portion of the source pattern to copy\n        pattern_to_copy = source_pattern[:copy_h, :copy_w]\n\n        # Place the cropped pattern onto the output grid's interior section\n        output_grid[target_inner_top : target_inner_top + copy_h,\n                    target_inner_left : target_inner_left + copy_w] = pattern_to_copy\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds a unique pattern rectangle and copies its\n    inner pattern into simple rectangles of the same color as the pattern's frame.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input, modified in place\n    output_grid = input_grid_np.copy()\n    h, w = input_grid_np.shape\n    # Keep track of visited pixels to avoid processing objects multiple times\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    all_objects = []\n\n    # Step 1: Find all connected components (potential objects)\n    for r in range(h):\n        for c in range(w):\n            # If pixel is non-background and not yet visited, start a search\n            if input_grid_np[r, c] != 0 and not visited[r, c]:\n                # Find all connected non-background pixels for this component\n                coords = bfs_find_connected(input_grid_np, (r, c), visited)\n\n                if coords: # If a component was found\n                    # Step 2: Check if the component is a solid rectangle\n                    bbox = get_bounding_box(coords)\n                    if is_solid_rectangle(input_grid_np, coords, bbox):\n                        # Step 3: Classify the solid rectangle\n                        obj_info = classify_rectangle(input_grid_np, bbox)\n                        if obj_info:\n                            # Store successfully classified rectangles\n                            all_objects.append(obj_info)\n                    # else: Component is not a solid rectangle, ignore it\n\n\n    # Step 4: Separate simple and pattern objects from the classified list\n    simple_rects = []\n    pattern_rect = None\n    for obj in all_objects:\n        if obj['type'] == 'simple':\n            simple_rects.append(obj)\n        elif obj['type'] == 'pattern':\n            # Assume only one pattern rectangle exists per grid. Store the first one found.\n            if pattern_rect is None:\n                pattern_rect = obj\n            # else: Ignore subsequent pattern rects if assumption holds true\n\n    # Step 5: Apply transformation if a pattern rectangle was found\n    if pattern_rect is None:\n        # No pattern rectangle found, return the original grid (already copied)\n        return output_grid.tolist()\n\n    # Get pattern details from the identified pattern rectangle\n    pattern_frame_color = pattern_rect['frame_color']\n    source_pattern = pattern_rect['inner_pattern']\n\n    # Step 6: Iterate through simple rectangles and apply the pattern if colors match and size allows\n    for simple_obj in simple_rects:\n        # Check if the simple rectangle's color matches the pattern's frame color\n        if simple_obj['color'] == pattern_frame_color:\n            # Get dimensions to check if it can have an interior\n            min_r, min_c, max_r, max_c = simple_obj['bbox']\n            simple_h = max_r - min_r + 1\n            simple_w = max_c - min_c + 1\n\n            # Apply pattern only if the simple rectangle is large enough (>= 3x3)\n            if simple_h >= 3 and simple_w >= 3:\n                # Call the helper function to paste the pattern (handles cropping)\n                paste_pattern(output_grid, simple_obj['bbox'], source_pattern)\n\n    # Convert the final modified numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40036,
    "candidates_token_count": 3297,
    "total_token_count": 43333,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.595401,
  "retries": 1
}