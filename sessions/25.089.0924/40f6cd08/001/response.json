{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1. Identify all distinct rectangular objects in the input grid against the white (0) background.\n2. Distinguish between two types of rectangles:\n   - \"Simple Rectangles\": Filled entirely with a single solid color.\n   - \"Pattern Rectangle\": Has an outer frame (1-pixel thick border) of one color and an interior area containing different colors or patterns. Assume there is at most one such Pattern Rectangle per input grid.\n3. If a Pattern Rectangle exists:\n   a. Extract its frame color and its inner pattern (the grid content inside the frame).\n   b. Iterate through all identified Simple Rectangles.\n   c. If a Simple Rectangle's solid color matches the Pattern Rectangle's frame color, and the Simple Rectangle is large enough to have an interior (at least 3x3):\n      i. Copy the inner pattern from the Pattern Rectangle.\n      ii. Place this pattern into the interior area of the Simple Rectangle (the area inside its 1-pixel border).\n      iii. If the Simple Rectangle's interior is smaller than the pattern, crop the pattern (copy only the top-left portion that fits).\n      iv. If the Simple Rectangle's interior is larger, only the top-left portion corresponding to the pattern's size is filled (though examples primarily show cropping).\n4. Rectangles (Simple or Patterned) that do not meet the matching criteria, as well as the original Pattern Rectangle itself, remain unchanged in the output.\n5. The background remains unchanged.\n6. The output grid has the same dimensions as the input grid.\n\"\"\"\n\ndef bfs_find_connected(grid, start_coord, visited):\n    \"\"\"Finds all connected non-background (non-zero) pixels using BFS.\"\"\"\n    q = deque([start_coord])\n    coords = set()\n    h, w = grid.shape\n\n    # Check if starting point is valid\n    if grid[start_coord] == 0 or visited[start_coord[0], start_coord[1]]:\n        return list(coords)\n\n    # Mark start as visited and add to coords\n    visited[start_coord[0], start_coord[1]] = True\n    coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not visited, and if not background\n            if 0 <= nr < h and 0 <= nc < w and \\\n               not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                coords.add((nr, nc))\n                q.append((nr, nc))\n    return list(coords)\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box of a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef classify_object(grid, coords, bbox):\n    \"\"\"Classifies a connected component as a simple or pattern rectangle.\"\"\"\n    if not coords or not bbox:\n        return None\n\n    min_r, min_c, max_r, max_c = bbox\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n    \n    # 1. Check if the component perfectly fills its bounding box (is rectangular)\n    coords_set = set(coords)\n    if len(coords_set) != obj_h * obj_w:\n         # Check if all pixels within bbox are part of the component (non-zero)\n         all_filled = True\n         for r in range(min_r, max_r + 1):\n             for c in range(min_c, max_c + 1):\n                 if grid[r, c] == 0 or (r, c) not in coords_set:\n                     all_filled = False\n                     break\n             if not all_filled:\n                 break\n         if not all_filled:\n            # Not a solid rectangle shape within the bbox based on connected component\n             return None # Not a rectangle we are interested in\n\n    # 2. Determine the primary color (top-left)\n    obj_color = grid[min_r, min_c]\n\n    # 3. Check if it's a simple rectangle (all pixels same color)\n    is_simple = True\n    for r, c in coords:\n        if grid[r, c] != obj_color:\n            is_simple = False\n            break\n\n    if is_simple:\n        return {'type': 'simple', 'color': obj_color, 'bbox': bbox}\n\n    # 4. If not simple, check if it's a pattern rectangle\n    if obj_h >= 3 and obj_w >= 3:\n        frame_color = grid[min_r, min_c] # Use top-left as potential frame color\n        frame_ok = True\n        # Check top/bottom rows\n        for c in range(min_c, max_c + 1):\n            if grid[min_r, c] != frame_color or grid[max_r, c] != frame_color:\n                frame_ok = False; break\n        # Check left/right columns (excluding corners)\n        if frame_ok:\n            for r in range(min_r + 1, max_r):\n                if grid[r, min_c] != frame_color or grid[r, max_c] != frame_color:\n                    frame_ok = False; break\n\n        # Check if interior has at least one different color\n        interior_differs = False\n        if frame_ok:\n            for r in range(min_r + 1, max_r):\n                for c in range(min_c + 1, max_c):\n                    if grid[r, c] != frame_color:\n                        interior_differs = True; break\n                if interior_differs: break\n\n        if frame_ok and interior_differs:\n            inner_pattern = grid[min_r+1:max_r, min_c+1:max_c]\n            return {'type': 'pattern', 'frame_color': frame_color, 'bbox': bbox, 'inner_pattern': inner_pattern.copy()}\n\n    # If it's neither simple nor a valid pattern rectangle\n    return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds a unique pattern rectangle and copies its\n    inner pattern into simple rectangles of the same color as the pattern's frame.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    output_grid = input_grid.copy()\n    h, w = input_grid.shape\n    visited = np.zeros((h, w), dtype=bool)\n\n    simple_rects = []\n    pattern_rect = None\n\n    # Find and classify all rectangular objects\n    for r in range(h):\n        for c in range(w):\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                # Found a potential start of an object\n                coords = bfs_find_connected(input_grid, (r, c), visited)\n                if coords:\n                    bbox = get_bounding_box(coords)\n                    obj_info = classify_object(input_grid, coords, bbox)\n\n                    if obj_info:\n                        if obj_info['type'] == 'simple':\n                            simple_rects.append(obj_info)\n                        elif obj_info['type'] == 'pattern':\n                            # Assume only one pattern rectangle exists\n                            if pattern_rect is None:\n                                pattern_rect = obj_info\n                            else:\n                                # Handle error: multiple pattern rectangles found?\n                                # For now, just overwrite or ignore subsequent ones.\n                                # Let's stick with the first one found.\n                                pass\n    \n    # If no pattern rectangle found, return the original grid\n    if pattern_rect is None:\n        return output_grid.tolist()\n\n    # Get pattern details\n    pattern_frame_color = pattern_rect['frame_color']\n    source_pattern = pattern_rect['inner_pattern']\n    if source_pattern.size == 0: # Handle case where pattern is empty (e.g., 3x3 pattern rect)\n         return output_grid.tolist() # Nothing to copy\n    source_h, source_w = source_pattern.shape\n\n    # Apply pattern to matching simple rectangles\n    for simple_obj in simple_rects:\n        if simple_obj['color'] == pattern_frame_color:\n            min_r, min_c, max_r, max_c = simple_obj['bbox']\n            simple_h = max_r - min_r + 1\n            simple_w = max_c - min_c + 1\n\n            # Check if the simple rectangle is large enough to have an interior\n            if simple_h >= 3 and simple_w >= 3:\n                # Calculate target interior coordinates and dimensions\n                target_top, target_left = min_r + 1, min_c + 1\n                target_bottom, target_right = max_r - 1, max_c - 1 # Inclusive\n                target_h = target_bottom - target_top + 1\n                target_w = target_right - target_left + 1\n\n                # Determine the dimensions of the pattern to copy (cropping)\n                copy_h = min(source_h, target_h)\n                copy_w = min(source_w, target_w)\n\n                # Check if there's anything to copy\n                if copy_h > 0 and copy_w > 0:\n                    # Select the portion of the source pattern to copy\n                    pattern_to_copy = source_pattern[:copy_h, :copy_w]\n\n                    # Place the pattern onto the output grid's interior\n                    output_grid[target_top : target_top + copy_h, target_left : target_left + copy_w] = pattern_to_copy\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12526,
    "candidates_token_count": 2430,
    "total_token_count": 14956,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.013698,
  "retries": 1
}