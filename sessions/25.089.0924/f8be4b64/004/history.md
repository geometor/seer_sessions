
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 5 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 6 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 4 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 0 3 0 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 3 0 3 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 0 3 0 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 3 0 0 0 0
5 5 5 0 5 5 5 6 5 5 5 5 3 5 3 5 5 5
0 0 0 0 0 0 0 6 0 0 0 0 0 3 4 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 5 4 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 5 4 0 0 0
6 6 6 0 6 6 3 6 3 6 6 6 6 5 4 6 6 6
0 0 0 0 0 0 0 3 0 0 0 0 0 5 4 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 5 4 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 5 3 0 0 0
4 4 4 0 4 4 4 6 4 4 4 4 4 3 4 3 4 4
0 0 0 0 0 0 0 6 0 0 0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 4 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0
0 3 5 3 0 0 0 0 3 0
0 0 3 0 0 0 0 3 6 3
0 0 0 0 0 0 0 0 3 0
0 0 0 0 0 3 0 0 0 0
0 0 0 0 3 8 3 0 0 0
0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 5 0 0 8 0 0 6 0
0 0 3 0 0 8 0 0 6 0
5 3 5 3 5 8 5 5 3 0
0 0 3 6 6 8 6 3 6 3
0 0 5 0 0 8 0 0 3 0
0 0 5 0 0 3 0 0 6 0
8 8 5 8 3 8 3 8 6 8
0 0 5 0 0 3 0 0 6 0
0 0 5 0 0 8 0 0 6 0
0 0 5 0 0 8 0 0 6 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 3 2 3 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 0 0 0
2 2 3 2 3 2 2 2 0 2 2 2 2
0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 3 0 0 0 0
0 0 0 2 0 0 0 3 0 3 0 0 0
0 0 0 2 0 0 0 0 3 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 3 6 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 8 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
2 2 2 2 3 2 3 2 2 2 2 2 2 0 2 2 2 2 2 2 3 0 8 0 0 0 0 0 0 0
0 0 0 0 0 3 6 6 6 6 6 6 6 0 6 6 6 6 6 3 6 3 8 6 6 6 6 6 6 6
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 3 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 3 0 3 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 3 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 3 0 0 0 0 0 0 0
8 8 8 8 8 2 8 8 8 8 8 8 8 0 8 8 8 8 8 8 6 3 8 3 8 8 8 8 8 8
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 3 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 8 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception**

1.  **Input Grid Structure:** The input grids contain a white background (0) and scattered objects. The primary objects of interest appear to be "plus" shapes made of green pixels (3).
2.  **Green Plus Shapes:** These shapes consist of a central pixel surrounded orthogonally by four green pixels. The central pixel itself can be various colors (white, gray, magenta, yellow, red, azure) or sometimes green itself if it's part of a larger green object (though the defining feature seems to be the 4 orthogonal green neighbours relative to *some* center). Let's refine: the core element is a 3x3 area where the center pixel has 4 green neighbors (N, S, E, W). The color of this central pixel (the "core color") is crucial.
3.  **Core Colors and Actions:** The core color determines an action that modifies the grid:
    *   White (0) core: No action.
    *   Gray (5) or Red (2) core: Fill the row and column intersecting at the core pixel with the core color.
    *   Magenta (6) core: Fill the column intersecting at the core pixel with the core color.
    *   Yellow (4) or Azure (8) core: Fill the row intersecting at the core pixel with the core color.
4.  **Transformation:** The transformation involves identifying these green plus structures, determining their core color, and applying the corresponding row/column fill operation.
5.  **Overlaps and Preservation:** The fill operations only change white (0) background pixels. Original non-white pixels from the input grid are preserved. When multiple fill operations affect the same white pixel, a specific priority seems to apply based on the examples: Column fills (magenta) override Row fills (yellow/azure), which override Row/Column fills (gray/red).

**YAML Facts**


```python
import numpy as np

"""
Identifies "plus" shapes made of green pixels (3) in the input grid.
A plus shape is defined by a central pixel having four green neighbors (North, South, East, West).
The color of the central pixel (the "core color") determines a fill operation:
- Red (2) or Gray (5): Fill the background (0) pixels in the intersecting row and column with the core color.
- Magenta (6): Fill the background (0) pixels in the intersecting column with the core color.
- Yellow (4) or Azure (8): Fill the background (0) pixels in the intersecting row with the core color.
- White (0) or any other color: No fill operation.

Fill operations only change white (0) background pixels. Original non-white pixels are preserved.
If multiple fill operations target the same background pixel, a priority is applied:
1. Column fill (Magenta)
2. Row/Column fill (Red, Gray)
3. Row fill (Yellow, Azure)
The fill operation with the highest priority determines the final color of the background pixel.
"""

def find_plus_centers(grid):
    """
    Finds all pixels that are centers of a green plus shape.
    A center is a pixel (r, c) where grid[r-1, c], grid[r+1, c], 
    grid[r, c-1], and grid[r, c+1] are all green (3).
    
    Args:
        grid (np.array): Input grid.

    Returns:
        list: A list of tuples, where each tuple is ((row, col), core_color).
    """
    centers = []
    height, width = grid.shape
    # Iterate through possible center locations (avoiding edges)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            # Check orthogonal neighbors
            if (grid[r - 1, c] == 3 and
                grid[r + 1, c] == 3 and
                grid[r, c - 1] == 3 and
                grid[r, c + 1] == 3):
                core_color = grid[r, c]
                centers.append(((r, c), core_color))
    return centers

def transform(input_grid):
    """
    Transforms the input grid based on green plus shapes and their core colors.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)
    output_grid = grid_np.copy()
    height, width = grid_np.shape

    # Find all green plus centers and their core colors
    plus_centers = find_plus_centers(grid_np)

    # Separate centers by the type of fill operation they trigger
    row_col_fills = [] # Priority 2 (colors 2, 5)
    col_fills = []     # Priority 1 (color 6)
    row_fills = []     # Priority 3 (colors 4, 8)

    for (r, c), core_color in plus_centers:
        if core_color in [2, 5]:
            row_col_fills.append(((r, c), core_color))
        elif core_color == 6:
            col_fills.append(((r, c), core_color))
        elif core_color in [4, 8]:
            row_fills.append(((r, c), core_color))
        # Other core colors (like 0) do nothing

    # Iterate through each pixel to determine its final color
    for r in range(height):
        for c in range(width):
            # Only modify original background pixels
            if grid_np[r, c] == 0:
                # Check for fills based on priority
                
                # Priority 1: Column fills (Magenta)
                col_fill_color = 0
                for (pr, pc), p_color in col_fills:
                    if pc == c:
                        col_fill_color = p_color # Should always be 6
                        break # Found highest priority fill for this pixel
                
                if col_fill_color != 0:
                    output_grid[r, c] = col_fill_color
                    continue # Apply highest priority and move to next pixel

                # Priority 2: Row/Column fills (Red, Gray)
                row_col_fill_color = 0
                # Check potential fills, last one found wins if multiple apply
                for (pr, pc), p_color in row_col_fills:
                    if pr == r or pc == c:
                        row_col_fill_color = p_color 
                
                if row_col_fill_color != 0:
                    output_grid[r, c] = row_col_fill_color
                    continue # Apply this priority and move to next pixel
                    
                # Priority 3: Row fills (Yellow, Azure)
                row_fill_color = 0
                # Check potential fills, last one found wins if multiple apply
                for (pr, pc), p_color in row_fills:
                    if pr == r:
                        row_fill_color = p_color
                        
                if row_fill_color != 0:
                    output_grid[r, c] = row_fill_color
                    # No continue needed, this is the last check

    # Convert back to list of lists
    return output_grid.tolist()

```
```python
import numpy as np

"""
The transformation identifies "plus" shapes made of green pixels (3) in the input grid. 
A plus shape is defined by a central pixel having four green neighbors (North, South, East, West).
The color of this central pixel (the "core color") determines a fill operation on the grid.
These fill operations only affect pixels that were originally background (white, 0). 
Original non-background pixels are preserved.

Fill Operations based on Core Color:
- Azure (8): Fill the corresponding row with Azure.
- Magenta (6): Fill the corresponding column with Magenta.
- Gray (5): Fill the corresponding row AND column with Gray.
- Red (2): Fill the corresponding row AND column with Red.
- Yellow (4): Fill the corresponding row with Yellow.
- Other colors (e.g., 0): No operation.

Priority of Overlapping Fills:
If multiple fill operations target the same original background pixel, the color is determined by the operation with the highest priority, applied in this order:
1. Azure (8)
2. Magenta (6)
3. Gray (5)
4. Red (2)
5. Yellow (4)

Higher priority fills overwrite the effects of lower priority fills on background pixels.
"""

def find_plus_centers(grid):
    """
    Finds all pixels that are centers of a green plus shape.
    A center is a pixel (r, c) where grid[r-1, c], grid[r+1, c], 
    grid[r, c-1], and grid[r, c+1] are all green (3).
    
    Args:
        grid (np.array): Input grid.

    Returns:
        list: A list of tuples, where each tuple is ((row, col), core_color).
    """
    centers = []
    height, width = grid.shape
    # Iterate through possible center locations (avoiding edges)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            # Check orthogonal neighbors
            if (grid[r - 1, c] == 3 and
                grid[r + 1, c] == 3 and
                grid[r, c - 1] == 3 and
                grid[r, c + 1] == 3):
                core_color = grid[r, c]
                centers.append(((r, c), core_color))
    return centers

def transform(input_grid):
    """
    Transforms the input grid based on green plus shapes and their core colors,
    applying fill operations with priority rules.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)
    output_grid = grid_np.copy() # Start with a copy
    height, width = grid_np.shape

    # Find all green plus centers and their core colors
    plus_centers = find_plus_centers(grid_np)

    # Define priority order and associated fill types
    # Priority: 8 > 6 > 5 > 2 > 4
    # Fill Types: R=Row, C=Column, RC=Row/Column
    priority_map = {
        8: 'R', 
        6: 'C', 
        5: 'RC',
        2: 'RC',
        4: 'R'
    }
    priority_order = [8, 6, 5, 2, 4]

    # Apply fills based on priority order
    for core_color in priority_order:
        fill_type = priority_map.get(core_color)
        if not fill_type:
            continue # Skip colors without defined actions

        # Find centers with the current core color
        centers_for_color = [center for center in plus_centers if center[1] == core_color]

        for (r, c), color_val in centers_for_color:
            # Determine target cells based on fill type
            target_cells = []
            if 'R' in fill_type:
                for tc in range(width):
                    target_cells.append((r, tc))
            if 'C' in fill_type:
                for tr in range(height):
                     # Avoid adding the center pixel twice if RC
                    if (tr, c) not in target_cells:
                       target_cells.append((tr, c))
            
            # Apply fill to target cells if they were originally background
            for tr, tc in target_cells:
                 # Check bounds just in case, though target_cells should be within bounds
                 if 0 <= tr < height and 0 <= tc < width:
                    # Check if the original pixel was background (0)
                    if grid_np[tr, tc] == 0:
                        output_grid[tr, tc] = color_val # Apply the fill

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
