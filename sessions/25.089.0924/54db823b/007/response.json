{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies all distinct connected objects composed of \nnon-background colors (green '3' and maroon '9') using orthogonal adjacency. \nFor each object, it calculates the count of maroon pixels (`maroon_count`), \nthe total pixel count (`total_size`), and identifies its top-left pixel coordinate. \n\nIt then selects a single candidate object based on a hierarchical criteria: \n1. Minimum `maroon_count`.\n2. If tied, maximum `total_size`.\n3. If still tied, the object whose top-most, left-most pixel appears first \n   (minimum row index, then minimum column index).\n\nFinally, it checks if the selected candidate object's `total_size` is greater \nthan a threshold (10). If it is, the output grid is generated by copying the \ninput grid and changing all pixels of the selected object to the background \ncolor (white '0'). If the candidate's size is not greater than the threshold, \nor if no objects were found, the output grid is an identical copy of the input grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies all distinct connected objects of non-background pixels in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains:\n        'pixels': A set of (row, col) tuples for the object.\n        'maroon_count': Integer count of maroon (9) pixels.\n        'total_size': Integer count of all pixels.\n        'top_left': Tuple (row, col) of the top-most, left-most pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-background (not 0) and not visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_object_pixels = set()\n                maroon_count = 0\n                # Store pixels to accurately find top-left after BFS\n                pixel_list_for_top_left = [] \n                \n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_pixels.add((curr_r, curr_c))\n                    pixel_list_for_top_left.append((curr_r, curr_c)) # Add to list\n\n                    # Count maroon pixels\n                    if grid[curr_r, curr_c] == 9:\n                        maroon_count += 1\n\n                    # Explore neighbors (orthogonal: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, non-background color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Calculate precise top_left after collecting all pixels\n                # Sorting by row, then col gives the top-left element first\n                pixel_list_for_top_left.sort() \n                true_top_left = pixel_list_for_top_left[0]\n\n                # Store object details after BFS completes for this object\n                objects.append({\n                    'pixels': current_object_pixels,\n                    'maroon_count': maroon_count,\n                    'total_size': len(current_object_pixels),\n                    'top_left': true_top_left # Use the precisely calculated top-left\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # 1. Identify all objects and calculate their properties\n    objects = find_objects(grid)\n    \n    # Handle edge case: If no non-background objects found, return the original grid\n    if not objects:\n        return grid.tolist() \n        \n    # 2. Select Candidate Object based on hierarchical criteria\n    candidate_object = None\n    \n    # Filter by Minimum Maroon Count\n    min_maroon_count = min(obj['maroon_count'] for obj in objects)\n    candidates = [obj for obj in objects if obj['maroon_count'] == min_maroon_count]\n    \n    # If only one candidate after step 2, it's the candidate\n    if len(candidates) == 1:\n        candidate_object = candidates[0]\n    else:\n        # Tie-breaker 1: Filter by Maximum Size (if necessary)\n        max_total_size = max(obj['total_size'] for obj in candidates)\n        candidates = [obj for obj in candidates if obj['total_size'] == max_total_size]\n        \n        # If only one candidate after step 4, it's the candidate\n        if len(candidates) == 1:\n            candidate_object = candidates[0]\n        else:\n            # Tie-breaker 2: Filter by Position (if necessary)\n            # Sort remaining candidates by top_left coordinate (row first, then column)\n            candidates.sort(key=lambda obj: (obj['top_left'][0], obj['top_left'][1]))\n            # The first object after sorting is the candidate\n            candidate_object = candidates[0] \n\n    # 3. Apply Size Threshold to determine if removal should occur\n    MIN_REMOVAL_SIZE_THRESHOLD = 10\n    remove_object = candidate_object['total_size'] > MIN_REMOVAL_SIZE_THRESHOLD\n\n    # 4. Generate Output grid - start with a copy of the input\n    output_grid = grid.copy() \n    \n    # 5. Modify Output grid if removal condition met\n    if remove_object:\n        # Change pixels of the candidate object to white (0)\n        for r, c in candidate_object['pixels']:\n            output_grid[r, c] = 0 \n        \n    # Convert output numpy array back to list of lists for the required format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25567,
    "candidates_token_count": 1540,
    "total_token_count": 27107,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.360002,
  "retries": 1
}