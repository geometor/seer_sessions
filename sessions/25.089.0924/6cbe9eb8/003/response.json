{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify a rectangular, hollow frame in the input grid that is exactly one pixel thick and composed of a single, non-white color. Record the frame's color and the bounding box of the region strictly inside it.\n2.  Determine the set of 'background colors' containing white (0) and all unique pixel colors present in the input grid strictly *outside* the identified frame's bounding box.\n3.  Create a new output grid whose dimensions are sized to fit the inner region identified in step 1, plus a one-pixel border on all sides.\n4.  Fill the one-pixel border of the output grid with the frame's color identified in step 1. Initialize the interior to white (0).\n5.  Iterate through each pixel within the inner region of the input grid.\n6.  For each pixel, check if its color is in the set of 'background colors' identified in step 2.\n7.  If the pixel's color is a background color, keep the corresponding output pixel as white (0).\n8.  Otherwise (if the pixel's color is not a background color), copy the pixel's original color to the corresponding position within the output grid's interior.\n9.  Return the constructed output grid.\n\"\"\"\n\ndef find_frame_coords(grid: np.ndarray) -> Optional[Tuple[int, int, int, int, int]]:\n    \"\"\"\n    Finds a 1-pixel thick, single-color, non-white, hollow rectangular frame.\n    Focuses on checking perimeter count and shape.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (frame_color, outer_min_r, outer_min_c, outer_max_r, outer_max_c)\n        representing the frame's color and the outer bounding box of the frame itself,\n        or None if no such frame is found.\n    \"\"\"\n    rows, cols = grid.shape\n    for color in range(1, 10):  # Iterate through possible frame colors (1-9)\n        coords = np.argwhere(grid == color)\n        if coords.size == 0:\n            continue\n\n        min_r, min_c = coords.min(axis=0)\n        max_r, max_c = coords.max(axis=0)\n\n        # Potential frame dimensions\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        # Frame must be at least 3x3 to be hollow\n        if height < 3 or width < 3:\n            continue\n\n        # Check 1: Count pixels. Should match perimeter length for a hollow rect.\n        # Perimeter count = 2 * height + 2 * width - 4 (accounts for corners)\n        expected_perimeter_pixels = 2 * height + 2 * width - 4\n        if coords.shape[0] != expected_perimeter_pixels:\n             continue # Pixel count doesn't match perimeter\n\n        # Check 2: Shape. Verify all pixels on the perimeter have the correct color.\n        is_perimeter_correct = True\n        try: # Add try-except for boundary checks\n            # Top/Bottom rows\n            if not np.all(grid[min_r, min_c:max_c+1] == color) or \\\n               not np.all(grid[max_r, min_c:max_c+1] == color):\n                is_perimeter_correct = False\n            # Left/Right columns (excluding corners already checked)\n            if is_perimeter_correct and height > 1: # Check columns if height > 1\n                 if not np.all(grid[min_r+1:max_r, min_c] == color) or \\\n                    not np.all(grid[min_r+1:max_r, max_c] == color):\n                     is_perimeter_correct = False\n        except IndexError:\n            is_perimeter_correct = False # Index out of bounds means shape is wrong\n\n        if not is_perimeter_correct:\n            continue # Pixels forming the bounding box don't all match the color\n\n        # Check 3: Hollow. Ensure no pixels *inside* the perimeter have the frame color.\n        if height > 2 and width > 2: # Only check inner slice if it exists\n            inner_slice = grid[min_r + 1 : max_r, min_c + 1 : max_c]\n            if np.any(inner_slice == color):\n                 continue # Frame color found inside the perimeter\n\n        # Check 4: Thickness 1 (Outer check - optional but good sanity check)\n        # Ensure pixels immediately outside the frame are not the frame color\n        outer_thick = False\n        # Check above (if possible)\n        if min_r > 0 and np.any(grid[min_r - 1, min_c:max_c+1] == color): outer_thick = True\n        # Check below (if possible)\n        if not outer_thick and max_r < rows - 1 and np.any(grid[max_r + 1, min_c:max_c+1] == color): outer_thick = True\n        # Check left (if possible)\n        if not outer_thick and min_c > 0 and np.any(grid[min_r:max_r+1, min_c - 1] == color): outer_thick = True\n        # Check right (if possible)\n        if not outer_thick and max_c < cols - 1 and np.any(grid[min_r:max_r+1, max_c + 1] == color): outer_thick = True\n\n        if outer_thick:\n            continue # Frame appears thicker than 1 pixel externally\n\n        # If all checks pass, we found our frame\n        # Return frame color and OUTER bounds\n        return color, min_r, min_c, max_r, max_c\n\n    return None # No frame found\n\n\ndef get_background_colors(grid: np.ndarray, frame_outer_min_r: int, frame_outer_min_c: int, frame_outer_max_r: int, frame_outer_max_c: int) -> Set[int]:\n    \"\"\"\n    Identifies colors outside the frame's outer bounding box.\n\n    Args:\n        grid: The input grid as a numpy array.\n        frame_outer_min_r, frame_outer_min_c, frame_outer_max_r, frame_outer_max_c: Coordinates defining\n            the outer bounding box of the frame itself.\n\n    Returns:\n        A set containing 0 (white) and all unique colors found strictly outside the frame.\n    \"\"\"\n    rows, cols = grid.shape\n    background_colors = set([0]) # Always include white\n\n    # Create a mask that is True *inside* the frame's outer box, False otherwise\n    mask = np.zeros(grid.shape, dtype=bool)\n    # Ensure indices are within grid bounds before slicing\n    r_start = max(0, frame_outer_min_r)\n    r_end = min(rows, frame_outer_max_r + 1)\n    c_start = max(0, frame_outer_min_c)\n    c_end = min(cols, frame_outer_max_c + 1)\n    \n    if r_start < r_end and c_start < c_end:\n        mask[r_start:r_end, c_start:c_end] = True \n\n    # Select pixels where the mask is False (i.e., outside the frame)\n    outside_pixels = grid[~mask]\n    \n    # Get unique colors from the outside pixels\n    if outside_pixels.size > 0:\n        unique_outside = np.unique(outside_pixels)\n        for color in unique_outside:\n            background_colors.add(int(color)) # Add numpy int to set\n\n    return background_colors\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # 1. Find the frame and its outer coordinates\n    frame_info = find_frame_coords(grid_np)\n    if frame_info is None:\n        # If no frame found, return the input grid unmodified as per some ARC task conventions\n        # or handle as an error case (e.g., raise ValueError or return empty list).\n        # Returning input seems safer if unsure about specific task requirements.\n        # print(\"Debug: No frame found.\")\n        return input_grid\n\n    frame_color, frame_outer_min_r, frame_outer_min_c, frame_outer_max_r, frame_outer_max_c = frame_info\n\n    # Define inner region coordinates (1 pixel inside the outer frame)\n    inner_min_r = frame_outer_min_r + 1\n    inner_min_c = frame_outer_min_c + 1\n    inner_max_r = frame_outer_max_r - 1\n    inner_max_c = frame_outer_max_c - 1\n\n    # Check if inner region is valid (should be guaranteed by find_frame checks)\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n         # This case should ideally not happen if find_frame works correctly\n         # print(\"Debug: Invalid inner region derived.\")\n         return input_grid # Return input if something went wrong\n\n    # 2. Identify background colors (strictly outside the frame)\n    background_colors = get_background_colors(grid_np, frame_outer_min_r, frame_outer_min_c, frame_outer_max_r, frame_outer_max_c)\n    # print(f\"Debug: Found Frame Color {frame_color} at ({frame_outer_min_r},{frame_outer_min_c})->({frame_outer_max_r},{frame_outer_max_c})\")\n    # print(f\"Debug: Background Colors Identified: {background_colors}\")\n\n\n    # 3. Create the output grid\n    inner_height = inner_max_r - inner_min_r + 1\n    inner_width = inner_max_c - inner_min_c + 1\n    output_height = inner_height + 2\n    output_width = inner_width + 2\n\n    # Initialize with white (0) - border will be overwritten later\n    output_grid_np = np.zeros((output_height, output_width), dtype=int)\n\n    # 4. Draw the border with frame_color\n    output_grid_np[0, :] = frame_color          # Top row\n    output_grid_np[-1, :] = frame_color         # Bottom row\n    output_grid_np[:, 0] = frame_color          # Left column\n    output_grid_np[:, -1] = frame_color         # Right column\n\n    # 5-8. Iterate through the inner region of the input grid, filter, and place in output\n    for r_in in range(inner_min_r, inner_max_r + 1):\n        for c_in in range(inner_min_c, inner_max_c + 1):\n            # Ensure we don't read out of input bounds (shouldn't happen)\n            if not (0 <= r_in < rows and 0 <= c_in < cols):\n                 continue\n\n            input_pixel_color = grid_np[r_in, c_in]\n\n            # Calculate corresponding output coordinates (offset by 1 for the border)\n            r_out = r_in - inner_min_r + 1\n            c_out = c_in - inner_min_c + 1\n\n            # Ensure we don't write out of output bounds (shouldn't happen)\n            if not (1 <= r_out < output_height - 1 and 1 <= c_out < output_width - 1):\n                 continue\n\n            # Check if the input color is a background color\n            if input_pixel_color in background_colors:\n                # Already initialized to 0, so no action needed, but explicit for clarity\n                output_grid_np[r_out, c_out] = 0 # Set to white\n            else:\n                # Copy the original color if it's not background\n                output_grid_np[r_out, c_out] = input_pixel_color\n\n    # 9. Return the completed grid as a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27278,
    "candidates_token_count": 2949,
    "total_token_count": 30227,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.080397,
  "retries": 1
}