{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all potential \"frames\" in the input grid. A frame is a rectangular, hollow structure, exactly one pixel thick, composed of a single non-white color, validated against its own bounding box.\n2. Select the \"main frame\" from the candidates, typically the one with the largest area. If no frames are found, return the input grid.\n3. Determine the set of \"background colors\" which includes white (0) plus all unique colors found immediately adjacent to the *outside* perimeter of the selected main frame.\n4. Calculate the dimensions of the region strictly inside the main frame.\n5. Create a new output grid sized to fit this inner region plus a 1-pixel border, initialized to white (0).\n6. Draw the border of the output grid using the main frame's color.\n7. Iterate through the inner region of the input grid. For each pixel, if its color is *not* one of the determined background colors, copy it to the corresponding position in the output grid's interior.\n8. Return the completed output grid.\n\"\"\"\n\n\ndef _find_potential_frames(grid: np.ndarray) -> List[Tuple[int, int, int, int, int]]:\n    \"\"\"\n    Finds all potential 1-pixel thick, single-color, non-white, hollow rectangular frames.\n    Validation is based on the bounding box derived from the pixels of that color.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples (frame_color, outer_min_r, outer_min_c, outer_max_r, outer_max_c)\n        for each potential frame found.\n    \"\"\"\n    rows, cols = grid.shape\n    potential_frames = []\n\n    for color in range(1, 10):  # Iterate through possible frame colors (1-9)\n        coords = np.argwhere(grid == color)\n        if coords.size == 0:\n            continue\n\n        min_r, min_c = coords.min(axis=0)\n        max_r, max_c = coords.max(axis=0)\n\n        # Potential frame dimensions\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        # Frame must be at least 3x3 to be hollow\n        if height < 3 or width < 3:\n            continue\n\n        # Check 1: Verify all pixels on the exact perimeter match the color\n        is_perimeter_complete = True\n        try:\n            # Top row\n            if not np.all(grid[min_r, min_c:max_c + 1] == color): is_perimeter_complete = False\n            # Bottom row\n            if is_perimeter_complete and not np.all(grid[max_r, min_c:max_c + 1] == color): is_perimeter_complete = False\n            # Left column (excluding corners)\n            if is_perimeter_complete and height > 2 and not np.all(grid[min_r + 1:max_r, min_c] == color): is_perimeter_complete = False\n            # Right column (excluding corners)\n            if is_perimeter_complete and height > 2 and not np.all(grid[min_r + 1:max_r, max_c] == color): is_perimeter_complete = False\n        except IndexError:\n             is_perimeter_complete = False # Safety check for bounds\n\n        if not is_perimeter_complete:\n             continue # The bounding box perimeter isn't solely the frame color\n\n        # Check 2: Hollow. Ensure no pixels *inside* the perimeter have the frame color.\n        if height > 2 and width > 2:\n            inner_slice = grid[min_r + 1:max_r, min_c + 1:max_c]\n            if np.any(inner_slice == color):\n                continue # Frame color found inside\n\n        # Check 3: Thickness 1 (External check). Ensure no adjacent pixels *outside* the frame have the frame color.\n        is_thick = False\n        # Check row above\n        if not is_thick and min_r > 0 and np.any(grid[min_r - 1, min_c:max_c + 1] == color): is_thick = True\n        # Check row below\n        if not is_thick and max_r < rows - 1 and np.any(grid[max_r + 1, min_c:max_c + 1] == color): is_thick = True\n        # Check column left (full side)\n        if not is_thick and min_c > 0 and np.any(grid[min_r:max_r + 1, min_c - 1] == color): is_thick = True\n        # Check column right (full side)\n        if not is_thick and max_c < cols - 1 and np.any(grid[min_r:max_r + 1, max_c + 1] == color): is_thick = True\n\n        if is_thick:\n            continue # Frame appears thicker than 1 pixel externally\n\n        # If all checks pass, add to potential frames\n        potential_frames.append((color, min_r, min_c, max_r, max_c))\n\n    return potential_frames\n\n\ndef _find_best_frame(grid: np.ndarray) -> Optional[Tuple[int, int, int, int, int]]:\n    \"\"\"\n    Finds the best frame among potential candidates, typically the largest one by area.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        The best frame tuple (color, min_r, min_c, max_r, max_c) or None if no valid frames.\n    \"\"\"\n    potential_frames = _find_potential_frames(grid)\n    if not potential_frames:\n        return None\n\n    # Select the frame with the largest area\n    best_frame = max(potential_frames, key=lambda f: (f[3] - f[1] + 1) * (f[4] - f[2] + 1))\n    return best_frame\n\n\ndef _get_adjacent_outside_colors(grid: np.ndarray, min_r: int, min_c: int, max_r: int, max_c: int) -> Set[int]:\n    \"\"\"\n    Gets unique colors immediately adjacent to the *outside* of a bounding box perimeter.\n\n    Args:\n        grid: The input grid.\n        min_r, min_c, max_r, max_c: Outer bounds of the frame.\n\n    Returns:\n        A set of unique integer colors found adjacent to the outside.\n    \"\"\"\n    rows, cols = grid.shape\n    adjacent_colors = set()\n\n    # Check row above (r = min_r - 1)\n    if min_r > 0:\n        r_check = min_r - 1\n        c_start = max(0, min_c)\n        c_end = min(cols, max_c + 1)\n        if c_start < c_end: # Ensure valid slice range\n             adjacent_colors.update(np.unique(grid[r_check, c_start:c_end]))\n\n    # Check row below (r = max_r + 1)\n    if max_r < rows - 1:\n        r_check = max_r + 1\n        c_start = max(0, min_c)\n        c_end = min(cols, max_c + 1)\n        if c_start < c_end:\n             adjacent_colors.update(np.unique(grid[r_check, c_start:c_end]))\n\n    # Check column left (c = min_c - 1)\n    if min_c > 0:\n        c_check = min_c - 1\n        r_start = max(0, min_r) # Include corners\n        r_end = min(rows, max_r + 1)\n        if r_start < r_end:\n             adjacent_colors.update(np.unique(grid[r_start:r_end, c_check]))\n\n    # Check column right (c = max_c + 1)\n    if max_c < cols - 1:\n        c_check = max_c + 1\n        r_start = max(0, min_r) # Include corners\n        r_end = min(rows, max_r + 1)\n        if r_start < r_end:\n             adjacent_colors.update(np.unique(grid[r_start:r_end, c_check]))\n\n    # Convert numpy types to standard Python ints if necessary for set operations later\n    return {int(c) for c in adjacent_colors}\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule: finds the largest valid frame, determines background\n    colors based on exterior adjacency, filters the inner content, and constructs the output.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # 1. & 2. Identify and Select Main Frame\n    best_frame = _find_best_frame(grid_np)\n\n    # If no frame found, return original grid\n    if best_frame is None:\n        return input_grid\n\n    frame_color, frame_min_r, frame_min_c, frame_max_r, frame_max_c = best_frame\n\n    # 3. Determine Background Colors\n    adjacent_colors = _get_adjacent_outside_colors(grid_np, frame_min_r, frame_min_c, frame_max_r, frame_max_c)\n    background_colors = adjacent_colors.union({0}) # Always include white (0)\n\n    # 4. Calculate Inner Dimensions\n    # Check for valid inner region (should be guaranteed by frame finding checks)\n    if frame_min_r + 1 > frame_max_r - 1 or frame_min_c + 1 > frame_max_c - 1:\n        # This case means frame is not hollow (height/width < 3), which _find_best_frame should prevent.\n        # If it happens somehow, maybe return input or an empty grid? Returning input seems safer.\n        return input_grid\n    inner_min_r = frame_min_r + 1\n    inner_max_r = frame_max_r - 1\n    inner_min_c = frame_min_c + 1\n    inner_max_c = frame_max_c - 1\n\n    inner_height = inner_max_r - inner_min_r + 1\n    inner_width = inner_max_c - inner_min_c + 1\n\n    # 5. Create Output Grid\n    output_height = inner_height + 2\n    output_width = inner_width + 2\n    output_grid_np = np.zeros((output_height, output_width), dtype=int) # Init with white (0)\n\n    # 6. Draw Border\n    output_grid_np[0, :] = frame_color          # Top row\n    output_grid_np[-1, :] = frame_color         # Bottom row\n    output_grid_np[:, 0] = frame_color          # Left column\n    output_grid_np[:, -1] = frame_color         # Right column\n\n    # 7. Process Inner Content\n    for r_in in range(inner_min_r, inner_max_r + 1):\n        for c_in in range(inner_min_c, inner_max_c + 1):\n            input_pixel_color = grid_np[r_in, c_in]\n\n            # Calculate corresponding output coordinates (offset by 1 for the border)\n            r_out = r_in - inner_min_r + 1\n            c_out = c_in - inner_min_c + 1\n\n            # Check if the input color is a background color\n            if input_pixel_color not in background_colors:\n                # Copy the original color if it's not background\n                 output_grid_np[r_out, c_out] = input_pixel_color\n            # Else: leave it as 0 (white), which was the initialization value\n\n    # 8. Return Output\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 29186,
    "candidates_token_count": 2900,
    "total_token_count": 32086,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.563474,
  "retries": 1
}