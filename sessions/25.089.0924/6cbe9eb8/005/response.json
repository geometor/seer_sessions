{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the most prominent rectangular, hollow frame in the input grid that is exactly one pixel thick and composed of a single, non-white color. \"Prominent\" might mean largest perimeter or area. Record the frame's color and its outer bounding box coordinates.\n2.  Determine the set of 'background colors'. This set includes white (0) and all unique colors found immediately adjacent to the *outside* perimeter of the identified frame.\n3.  Create a new output grid. Its dimensions are determined by the size of the region strictly *inside* the identified frame, plus a one-pixel border on all sides.\n4.  Fill the one-pixel border of the output grid with the frame's color identified in step 1. Initialize the interior of the output grid to white (0).\n5.  Iterate through each pixel within the inner region of the input grid (the area inside the frame).\n6.  For each input pixel, check if its color is present in the set of 'background colors' identified in step 2.\n7.  If the input pixel's color *is* a background color, leave the corresponding pixel in the output grid's interior as white (0).\n8.  Otherwise (if the input pixel's color is *not* a background color), copy the input pixel's original color to the corresponding position within the output grid's interior.\n9.  Return the constructed output grid. If no suitable frame is found, return the original input grid.\n\"\"\"\n\ndef _find_potential_frames(grid: np.ndarray) -> List[Tuple[int, int, int, int, int]]:\n    \"\"\"\n    Finds all potential 1-pixel thick, single-color, non-white, hollow rectangular frames.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples (frame_color, outer_min_r, outer_min_c, outer_max_r, outer_max_c)\n        for each potential frame found.\n    \"\"\"\n    rows, cols = grid.shape\n    potential_frames = []\n\n    for color in range(1, 10):  # Iterate through possible frame colors (1-9)\n        coords = np.argwhere(grid == color)\n        if coords.size == 0:\n            continue\n\n        min_r, min_c = coords.min(axis=0)\n        max_r, max_c = coords.max(axis=0)\n\n        # Potential frame dimensions\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        # Frame must be at least 3x3 to be hollow\n        if height < 3 or width < 3:\n            continue\n\n        # Check 1: Verify all pixels on the exact perimeter match the color\n        is_perimeter_complete = True\n        try:\n            # Top row\n            if not np.all(grid[min_r, min_c:max_c + 1] == color): is_perimeter_complete = False\n            # Bottom row\n            if is_perimeter_complete and not np.all(grid[max_r, min_c:max_c + 1] == color): is_perimeter_complete = False\n            # Left column (excluding corners)\n            if is_perimeter_complete and not np.all(grid[min_r + 1:max_r, min_c] == color): is_perimeter_complete = False\n            # Right column (excluding corners)\n            if is_perimeter_complete and not np.all(grid[min_r + 1:max_r, max_c] == color): is_perimeter_complete = False\n        except IndexError:\n             is_perimeter_complete = False # Should not happen if bounds are correct, but safety check\n\n        if not is_perimeter_complete:\n             continue # The bounding box perimeter isn't solely the frame color\n\n        # Check 2: Hollow. Ensure no pixels *inside* the perimeter have the frame color.\n        if height > 2 and width > 2:\n            inner_slice = grid[min_r + 1:max_r, min_c + 1:max_c]\n            if np.any(inner_slice == color):\n                continue # Frame color found inside\n\n        # Check 3: Thickness 1 (External check). Ensure no adjacent pixels *outside* the frame have the frame color.\n        is_thick = False\n        # Check row above\n        if min_r > 0 and np.any(grid[min_r - 1, min_c:max_c + 1] == color): is_thick = True\n        # Check row below\n        if not is_thick and max_r < rows - 1 and np.any(grid[max_r + 1, min_c:max_c + 1] == color): is_thick = True\n        # Check column left\n        if not is_thick and min_c > 0 and np.any(grid[min_r:max_r + 1, min_c - 1] == color): is_thick = True\n        # Check column right\n        if not is_thick and max_c < cols - 1 and np.any(grid[min_r:max_r + 1, max_c + 1] == color): is_thick = True\n\n        if is_thick:\n            continue # Frame appears thicker than 1 pixel\n\n        # If all checks pass, add to potential frames\n        potential_frames.append((color, min_r, min_c, max_r, max_c))\n\n    return potential_frames\n\n\ndef _get_adjacent_outside_colors(grid: np.ndarray, min_r: int, min_c: int, max_r: int, max_c: int) -> Set[int]:\n    \"\"\"Gets unique colors adjacent to the *outside* of a bounding box.\"\"\"\n    rows, cols = grid.shape\n    adjacent_colors = set()\n\n    # Check row above (r = min_r - 1)\n    if min_r > 0:\n        r_check = min_r - 1\n        for c_check in range(max(0, min_c), min(cols, max_c + 1)):\n             adjacent_colors.add(grid[r_check, c_check])\n\n    # Check row below (r = max_r + 1)\n    if max_r < rows - 1:\n        r_check = max_r + 1\n        for c_check in range(max(0, min_c), min(cols, max_c + 1)):\n             adjacent_colors.add(grid[r_check, c_check])\n\n    # Check column left (c = min_c - 1)\n    if min_c > 0:\n        c_check = min_c - 1\n        # Exclude corners already checked by row checks\n        for r_check in range(max(0, min_r + 1), min(rows, max_r)):\n             adjacent_colors.add(grid[r_check, c_check])\n\n    # Check column right (c = max_c + 1)\n    if max_c < cols - 1:\n        c_check = max_c + 1\n        # Exclude corners already checked by row checks\n        for r_check in range(max(0, min_r + 1), min(rows, max_r)):\n             adjacent_colors.add(grid[r_check, c_check])\n\n    return adjacent_colors\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule: extracts content within a frame,\n    filters out background colors (adjacent to frame + white), and adds frame border.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # 1. Find potential frames\n    potential_frames = _find_potential_frames(grid_np)\n\n    # If no frames found, return original grid\n    if not potential_frames:\n        #print(\"Debug: No valid frames found.\")\n        return input_grid\n\n    # Select the best frame (e.g., largest perimeter or area). Let's use area.\n    best_frame = max(potential_frames, key=lambda f: (f[3] - f[1] + 1) * (f[4] - f[2] + 1))\n    frame_color, frame_outer_min_r, frame_outer_min_c, frame_outer_max_r, frame_outer_max_c = best_frame\n    #print(f\"Debug: Selected Frame Color {frame_color} at ({frame_outer_min_r},{frame_outer_min_c})->({frame_outer_max_r},{frame_outer_max_c})\")\n\n\n    # Define inner region coordinates\n    inner_min_r = frame_outer_min_r + 1\n    inner_min_c = frame_outer_min_c + 1\n    inner_max_r = frame_outer_max_r - 1\n    inner_max_c = frame_outer_max_c - 1\n\n    # Check for valid inner region (should be guaranteed by find_frame)\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n         #print(\"Debug: Invalid inner region derived.\")\n         return input_grid # Should not happen\n\n    # 2. Identify background colors (adjacent outside + white)\n    adjacent_colors = _get_adjacent_outside_colors(grid_np, frame_outer_min_r, frame_outer_min_c, frame_outer_max_r, frame_outer_max_c)\n    background_colors = adjacent_colors.union({0}) # Add white\n    #print(f\"Debug: Background Colors Identified: {background_colors}\")\n\n    # 3. Create the output grid dimensions\n    inner_height = inner_max_r - inner_min_r + 1\n    inner_width = inner_max_c - inner_min_c + 1\n    output_height = inner_height + 2\n    output_width = inner_width + 2\n\n    # 4. Initialize output grid and draw border\n    output_grid_np = np.zeros((output_height, output_width), dtype=int) # Init with white (0)\n    output_grid_np[0, :] = frame_color          # Top row\n    output_grid_np[-1, :] = frame_color         # Bottom row\n    output_grid_np[:, 0] = frame_color          # Left column\n    output_grid_np[:, -1] = frame_color         # Right column\n\n    # 5-8. Process the inner region\n    for r_in in range(inner_min_r, inner_max_r + 1):\n        for c_in in range(inner_min_c, inner_max_c + 1):\n            input_pixel_color = grid_np[r_in, c_in]\n\n            # Calculate corresponding output coordinates (offset by 1 for the border)\n            r_out = r_in - inner_min_r + 1\n            c_out = c_in - inner_min_c + 1\n\n            # Check if the input color is a background color\n            if input_pixel_color not in background_colors:\n                # Copy the original color if it's not background\n                 output_grid_np[r_out, c_out] = input_pixel_color\n            # Else: leave it as 0 (white), which was the initialization value\n\n    # 9. Return the completed grid\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25386,
    "candidates_token_count": 2736,
    "total_token_count": 28122,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.97367,
  "retries": 1
}