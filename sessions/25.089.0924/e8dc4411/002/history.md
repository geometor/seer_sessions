
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 3 1 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 1 1 1 1 1 1 1 1 1 1
3 1 3 1 1 1 1 1 1 1 1 1 1 1 1
3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 2 8 2 8 8 8 8 8 8
8 8 8 8 8 8 2 8 2 8 8 8 8 8
8 8 8 8 8 8 8 2 8 2 8 8 8 8
8 8 8 8 8 8 8 8 2 8 2 8 8 8
8 8 8 8 8 8 8 8 8 2 8 2 8 8
8 8 8 8 8 8 8 8 8 8 2 8 2 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

**Perception:**

1.  **Grid Structure:** Each example presents an input grid and a corresponding output grid. The grids have a background color filling most cells.
2.  **Key Elements:** Within each input grid, besides the background, there are typically two other types of elements:
    *   A cluster of white (0) pixels forming a small shape.
    *   A single, isolated pixel of a distinct color (green, red, azure in the examples). This color is different from both the background and white.
3.  **Transformation:** The output grid is largely identical to the input grid, except for the addition of new pixels. These new pixels are the same color as the single, isolated pixel found in the input.
4.  **Pattern of Added Pixels:** The added pixels form a diagonal line or "trail" starting from the position *below* the original isolated pixel and extending downwards towards the bottom edge of the grid.
5.  **Directionality:** The diagonal trail seems to move either down-left or down-right.
    *   In example 1 (green pixel), the trail goes down-left.
    *   In examples 2 and 3 (red and azure pixels), the trail goes down-right.
6.  **Determining Direction:** The direction appears related to the horizontal position of the single colored pixel relative to the white shape.
    *   In example 1, the green pixel is horizontally to the left of the white shape. The trail goes down-left.
    *   In examples 2 and 3, the red and azure pixels are horizontally to the right of the white shape(s). The trails go down-right.
7.  **Stopping Condition:** The trail continues until it reaches the bottom boundary of the grid. It does not seem to interact with or be blocked by the white shape.

**YAML Facts:**


```yaml
Task: Generate a diagonal trail from a specific source pixel.

Input_Features:
  - Grid: 2D array of integers (colors).
  - Background_Color: The most frequent color in the grid.
  - White_Shape:
      - Color: 0 (white)
      - Type: A contiguous or scattered group of pixels.
      - Function: Appears to act as a reference point for direction.
      - Property: Centroid (average row/column of white pixels).
  - Source_Pixel:
      - Color: A single color distinct from the background and white.
      - Type: A single pixel object.
      - Function: Origin point for the generated trail.
      - Property: Position (row, column).

Output_Features:
  - Grid: Modified version of the input grid.
  - Trail:
      - Color: Same as the Source_Pixel color.
      - Shape: Diagonal line segment.
      - Start: Position directly below the Source_Pixel (row + 1).
      - Path: Extends diagonally downwards (either down-left or down-right).
      - End: Terminates upon reaching the bottom edge of the grid.

Relationships:
  - Trail_Direction_Dependency: The diagonal direction (down-left vs. down-right) depends on the horizontal position of the Source_Pixel relative to the centroid of the White_Shape.
    - If Source_Pixel.column < White_Shape.centroid.column, direction is down-left (delta_row=+1, delta_col=-1).
    - If Source_Pixel.column >= White_Shape.centroid.column, direction is down-right (delta_row=+1, delta_col=+1).

Actions:
  - Identify: Locate the Background_Color, White_Shape pixels, and the Source_Pixel.
  - Calculate: Compute the centroid of the White_Shape.
  - Determine: Establish the trail's diagonal direction based on the relative horizontal positions.
  - Generate: Create the trail by iteratively adding pixels of the Source_Pixel color, starting below the Source_Pixel and moving diagonally downwards according to the determined direction, until the grid's bottom boundary is reached.
  - Copy: Preserve all original pixels from the input grid in the output grid.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the background color (the color covering the most pixels).
3.  Find all pixels with color 0 (white). Calculate their average row and column index to determine the centroid of the white shape.
4.  Find the single "source" pixel whose color is neither the background color nor white. Record its color (`source_color`) and its position (`source_row`, `source_col`).
5.  Determine the horizontal step (`delta_col`):
    *   If `source_col` is less than the white shape's centroid column, set `delta_col` to -1 (move left).
    *   Otherwise (if `source_col` is greater than or equal to the centroid column), set `delta_col` to +1 (move right).
6.  Set the vertical step `delta_row` to +1 (always move down).
7.  Initialize the current position for drawing the trail: `current_row = source_row + delta_row`, `current_col = source_col + delta_col`.
8.  Start a loop that continues as long as `current_row` is within the grid's height boundary:
    a.  Check if `current_col` is within the grid's width boundary.
    b.  If both `current_row` and `current_col` are within the grid boundaries, change the color of the pixel at (`current_row`, `current_col`) in the output grid to `source_color`.
    c.  Update the current position: `current_row = current_row + delta_row`, `current_col = current_col + delta_col`.
9.  Return the modified output grid.
```python
import numpy as np
from collections import Counter

def find_most_frequent_color(grid):
    """Finds the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    # Find the color with the maximum count
    most_common = counts.most_common(1)
    if most_common:
        return most_common[0][0]
    return 0 # Default if grid is empty or uniform

def find_pixels_by_color(grid, color):
    """Finds the coordinates of all pixels with the given color."""
    rows, cols = np.where(grid == color)
    return list(zip(rows, cols))

def calculate_centroid(pixels):
    """Calculates the centroid (average row, col) of a list of pixel coordinates."""
    if not pixels:
        return None # Or handle as needed, e.g., return grid center
    avg_row = sum(r for r, c in pixels) / len(pixels)
    avg_col = sum(c for r, c in pixels) / len(pixels)
    return avg_row, avg_col

def find_unique_non_bg_non_white_pixel(grid, background_color):
    """Finds the single pixel that is not the background color and not white (0)."""
    height, width = grid.shape
    source_pixel = None
    for r in range(height):
        for c in range(width):
            color = grid[r, c]
            if color != background_color and color != 0:
                # Assuming there's only one such pixel based on examples
                source_pixel = ((r, c), color)
                break
        if source_pixel:
            break
    return source_pixel # Returns ((row, col), color) or None

def transform(input_grid):
    """
    Generates a diagonal trail extending downwards from a specific source pixel.
    The trail's color matches the source pixel.
    The trail direction (down-left or down-right) is determined by the source 
    pixel's horizontal position relative to the centroid of the white (0) pixels.
    If the source pixel is left of the white centroid, the trail goes down-left.
    Otherwise (right of or aligned with the centroid), it goes down-right.
    The trail stops when it hits the bottom edge of the grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # 1. Identify the background color
    background_color = find_most_frequent_color(output_grid)

    # 2. Find white pixels and calculate centroid
    white_pixels = find_pixels_by_color(output_grid, 0)
    white_centroid = calculate_centroid(white_pixels)
    
    # Handle case where there are no white pixels (use grid center as fallback?)
    # For now, assume white pixels exist based on examples. If not, white_centroid will be None.

    # 3. Find the source pixel (not background, not white)
    source_info = find_unique_non_bg_non_white_pixel(output_grid, background_color)

    # If no source pixel or no white pixels found, return the original grid
    if not source_info or white_centroid is None:
        print("Warning: Could not find source pixel or white pixels. Returning original grid.")
        return output_grid 

    (source_row, source_col), source_color = source_info
    white_centroid_row, white_centroid_col = white_centroid

    # 4. Determine the trail direction
    delta_row = 1  # Always moves down
    if source_col < white_centroid_col:
        delta_col = -1 # Move down-left
    else:
        delta_col = 1  # Move down-right

    # 5. Generate the trail
    current_row = source_row + delta_row
    current_col = source_col + delta_col

    while 0 <= current_row < height:
        # Check column bounds before drawing
        if 0 <= current_col < width:
            output_grid[current_row, current_col] = source_color
        
        # Update position for the next step
        current_row += delta_row
        current_col += delta_col
        
        # Optional: Break if column goes out of bounds (though loop condition handles row)
        if not (0 <= current_col < width):
             break # Added for clarity, loop condition on row handles termination eventually

    return output_grid
```
