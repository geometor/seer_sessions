{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies non-background colored objects touching the border of the input grid.\nCounts the number of border objects for each color.\nDetermines the 'moving color' as the one with the highest count of border objects.\nInitializes an output grid with the background color.\nRedraws stationary objects (non-border objects OR border objects of non-moving colors) in their original positions.\nRedraws moving objects (border objects of the 'moving color') shifted one step diagonally inwards towards the center.\n\"\"\"\n\n# Helper function to find connected components (objects) using Breadth-First Search\ndef find_objects(grid, colors_to_find=None):\n    \"\"\"\n    Finds connected components (objects) of specified colors in the grid using 4-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): A set of colors to find objects for. \n                                         If None, finds objects of all colors. Defaults to None.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    target_colors = set(colors_to_find) if colors_to_find is not None else None\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Skip visited cells, background cells (if implicitly defined by target_colors), \n            # or colors not specifically targeted\n            if visited[r, c] or (target_colors is not None and color not in target_colors):\n                continue\n            \n            # Check if this color should be part of an object\n            # If target_colors is defined, it must be in the set.\n            # If target_colors is None, we find objects of *any* color (usually we pre-filter).\n            # In this task's context, we call this with non_background_colors, so this check is sufficient.\n\n            # Start BFS for a new object\n            q = [(r, c)]\n            visited[r, c] = True\n            current_object_coords = set([(r, c)])\n            \n            queue_idx = 0\n            while queue_idx < len(q):\n                row, col = q[queue_idx]\n                queue_idx += 1\n                \n                # Check 4 neighbors (up, down, left, right)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    # Check bounds and if neighbor is same color and not visited\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n                        current_object_coords.add((nr, nc))\n            \n            # Add the found object if it consists of at least one pixel\n            if current_object_coords:\n                 objects.append({'color': color, 'coords': current_object_coords})\n\n    return objects\n\n# Helper function to check if an object touches the border\ndef is_border_object(obj_coords, grid_shape):\n    \"\"\"\n    Checks if any coordinate of the object touches the grid border.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n        grid_shape (tuple): A tuple (height, width) of the grid.\n\n    Returns:\n        bool: True if the object touches the border, False otherwise.\n    \"\"\"\n    height, width = grid_shape\n    for r, c in obj_coords:\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            return True\n    return False\n\n# Helper function to determine the corner an object primarily occupies\ndef get_object_corner(obj_coords, grid_shape):\n    \"\"\"\n    Determines the corner an object is closest to based on its coordinates.\n    Uses the location of the majority of its bounding box relative to the center.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n        grid_shape (tuple): A tuple (height, width) of the grid.\n\n    Returns:\n        str: One of 'top-left', 'top-right', 'bottom-left', 'bottom-right'.\n    \"\"\"\n    height, width = grid_shape\n    center_r, center_c = (height - 1) / 2.0, (width - 1) / 2.0\n    \n    # Calculate bounding box\n    min_r = min(r for r, c in obj_coords)\n    max_r = max(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    max_c = max(c for r, c in obj_coords)\n\n    # Determine vertical position based on bounding box center\n    bbox_center_r = (min_r + max_r) / 2.0\n    is_top = bbox_center_r < center_r\n\n    # Determine horizontal position based on bounding box center\n    bbox_center_c = (min_c + max_c) / 2.0\n    is_left = bbox_center_c < center_c\n    \n    if is_top and is_left:\n        return 'top-left'\n    elif is_top and not is_left:\n        return 'top-right'\n    elif not is_top and is_left:\n        return 'bottom-left'\n    else: # not is_top and not is_left\n        return 'bottom-right'\n\n# Helper function to find the background color (most frequent color)\ndef find_background_color(grid):\n    \"\"\"\n    Finds the most frequent color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        int: The color value that appears most often. Defaults to 0 if grid is empty.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background for an empty grid\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the task rules:\n    Identifies border objects, determines the color with the most border objects ('moving_color'),\n    and moves objects of that color one step diagonally inwards, leaving others stationary.\n    \"\"\"\n    \n    input_grid_np = np.array(input_grid, dtype=int)\n    if input_grid_np.size == 0:\n        return [] # Handle empty input grid\n        \n    height, width = input_grid_np.shape\n    grid_shape = (height, width)\n\n    # 1. Determine background color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Find all non-background colors present in the grid\n    unique_colors = np.unique(input_grid_np)\n    non_background_colors = {c for c in unique_colors if c != background_color}\n\n    # If there are no non-background colors, return the input grid (or a copy)\n    if not non_background_colors:\n        return input_grid # Or input_grid_np.tolist() if a copy is desired\n\n    # 3. Find all objects composed of non-background colors\n    all_objects = find_objects(input_grid_np, non_background_colors)\n\n    # 4. Identify border objects and count them by color\n    border_objects = []\n    border_object_color_counts = Counter()\n    for obj in all_objects:\n        # Ensure the object color is actually non-background before checking border status\n        # (find_objects should only return these based on non_background_colors filter, but double-check)\n        if obj['color'] in non_background_colors and is_border_object(obj['coords'], grid_shape):\n            border_objects.append(obj)\n            border_object_color_counts[obj['color']] += 1\n\n    # 5. Determine the moving color (color with the most border objects)\n    moving_color = -1 # Use -1 to indicate no moving color found yet\n    max_count = 0\n    if border_object_color_counts:\n         # Find the maximum count\n         max_count = border_object_color_counts.most_common(1)[0][1]\n         # Find all colors that have this maximum count\n         colors_with_max_count = [color for color, count in border_object_color_counts.items() if count == max_count]\n         \n         # If there's at least one color with the max count, choose one.\n         # Simple tie-breaking: choose the numerically smallest color value among the winners.\n         if colors_with_max_count:\n             moving_color = min(colors_with_max_count) \n        \n    # 6. Initialize output grid filled entirely with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 7. Process all found non-background objects\n    for obj in all_objects:\n        obj_color = obj['color']\n        obj_coords = obj['coords']\n        \n        # Determine if this object should move: must be a border object AND its color must be the moving color\n        is_border = is_border_object(obj_coords, grid_shape) # Re-check needed if we didn't store this earlier\n        is_moving = is_border and (obj_color == moving_color)\n\n        if is_moving:\n            # This object moves diagonally inwards.\n            # Determine corner to know the direction of movement.\n            corner = get_object_corner(obj_coords, grid_shape)\n            dr, dc = 0, 0 # delta row, delta column for movement\n            if corner == 'top-left':\n                dr, dc = 1, 1       # Move down-right\n            elif corner == 'top-right':\n                dr, dc = 1, -1      # Move down-left\n            elif corner == 'bottom-left':\n                dr, dc = -1, 1      # Move up-right\n            elif corner == 'bottom-right':\n                dr, dc = -1, -1     # Move up-left\n            \n            # Apply shift to each pixel of the object and draw in the output grid\n            for r, c in obj_coords:\n                nr, nc = r + dr, c + dc\n                # Draw the pixel at the new location, checking grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    output_grid[nr, nc] = obj_color\n                # Pixels moving off-grid are simply lost\n\n        else: \n            # This object is stationary (either not a border object, or not the moving color).\n            # Draw it at its original position in the output grid.\n            for r, c in obj_coords:\n                 # Check bounds (mostly for safety, should always be within bounds here)\n                 if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = obj_color\n\n    # 8. Convert the final numpy grid back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6796,
            "end_index": 6971,
            "uri": "https://github.com/linjuuu/papricacare",
            "license_": ""
          },
          {
            "start_index": 18971,
            "end_index": 19146,
            "uri": "https://github.com/linjuuu/papricacare",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6040,
    "candidates_token_count": 2740,
    "total_token_count": 8780,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.104332,
  "retries": 1
}