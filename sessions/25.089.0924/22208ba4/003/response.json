{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nSelectively move border objects towards the center based on color frequency at the borders.\nThe transformation identifies the background color (most frequent). \nIt then finds all distinct objects of non-background colors. \nFor each object, it determines if it touches the border and calculates its dimensions (height/width).\nIt counts the number of border objects for each color.\nThe 'moving color' is the non-background color with the highest count of border objects (lowest numerical value breaks ties).\nAn output grid is initialized with the background color.\nStationary objects (non-border objects or border objects of non-moving colors) are redrawn in their original positions.\nMoving objects (border objects of the 'moving color') are shifted diagonally inwards by a distance equal to their dimension (height/width), determined by their corner proximity.\n\"\"\"\n\n# Helper function to find connected components (objects) using Breadth-First Search\ndef find_objects(grid, colors_to_find=None):\n    \"\"\"\n    Finds connected components (objects) of specified colors in the grid using 4-way connectivity.\n    Also calculates object dimensions and top-left coordinate.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): A set of colors to find objects for. \n                                         If None, finds objects of all non-zero colors. Defaults to None.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'coords', 'height', 'width', 'top_left'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    target_colors = set(colors_to_find) if colors_to_find is not None else None\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Skip visited cells or cells not matching target colors (if specified)\n            if visited[r, c] or (target_colors is not None and color not in target_colors):\n                continue\n\n            # Skip background implicitly if target_colors are non-background\n            # If target_colors is None, default behaviour should skip 0 if considered background universally.\n            # For this task, we explicitly pass non_background_colors, so this check is good.\n\n            # Start BFS for a new object\n            q = [(r, c)]\n            visited[r, c] = True\n            current_object_coords = set([(r, c)])\n            queue_idx = 0\n            while queue_idx < len(q):\n                row, col = q[queue_idx]\n                queue_idx += 1\n                # Check 4 neighbors (up, down, left, right)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    # Check bounds and if neighbor is same color and not visited\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n                        current_object_coords.add((nr, nc))\n            \n            # Add the found object if it consists of at least one pixel\n            if current_object_coords:\n                 # Calculate bounding box to get dimensions and top-left\n                 min_r = min(r_ for r_, c_ in current_object_coords)\n                 max_r = max(r_ for r_, c_ in current_object_coords)\n                 min_c = min(c_ for r_, c_ in current_object_coords)\n                 max_c = max(c_ for r_, c_ in current_object_coords)\n                 obj_height = max_r - min_r + 1\n                 obj_width = max_c - min_c + 1\n                 objects.append({\n                     'color': int(color), # Ensure standard int\n                     'coords': current_object_coords,\n                     'height': int(obj_height), # Ensure standard int\n                     'width': int(obj_width), # Ensure standard int\n                     'top_left': (int(min_r), int(min_c)) # Ensure standard int\n                 })\n    return objects\n\n# Helper function to check if an object touches the border\ndef is_border_object(obj_coords, grid_shape):\n    \"\"\"\n    Checks if any coordinate of the object touches the grid border.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n        grid_shape (tuple): A tuple (height, width) of the grid.\n\n    Returns:\n        bool: True if the object touches the border, False otherwise.\n    \"\"\"\n    height, width = grid_shape\n    for r, c in obj_coords:\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            return True\n    return False\n\n# Helper function to determine the corner an object primarily occupies\ndef get_object_corner(obj_coords, grid_shape):\n    \"\"\"\n    Determines the corner an object is closest to based on its coordinates.\n    Uses the location of the bounding box center relative to the grid center.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n        grid_shape (tuple): A tuple (height, width) of the grid.\n\n    Returns:\n        str: One of 'top-left', 'top-right', 'bottom-left', 'bottom-right'.\n    \"\"\"\n    height, width = grid_shape\n    center_r, center_c = (height - 1) / 2.0, (width - 1) / 2.0\n    \n    # Calculate bounding box\n    min_r = min(r for r, c in obj_coords)\n    max_r = max(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    max_c = max(c for r, c in obj_coords)\n\n    # Determine vertical position based on bounding box center\n    bbox_center_r = (min_r + max_r) / 2.0\n    is_top = bbox_center_r < center_r\n\n    # Determine horizontal position based on bounding box center\n    bbox_center_c = (min_c + max_c) / 2.0\n    is_left = bbox_center_c < center_c\n    \n    if is_top and is_left:\n        return 'top-left'\n    elif is_top and not is_left:\n        return 'top-right'\n    elif not is_top and is_left:\n        return 'bottom-left'\n    else: # not is_top and not is_left\n        return 'bottom-right'\n\n# Helper function to find the background color (most frequent color)\ndef find_background_color(grid):\n    \"\"\"\n    Finds the most frequent color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        int: The color value that appears most often. Defaults to 0 if grid is empty.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background for an empty grid\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return int(background_color) # Ensure standard int\n\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    if input_grid_np.size == 0:\n        return [] # Handle empty input grid\n        \n    height, width = input_grid_np.shape\n    grid_shape = (height, width)\n\n    # 1. Determine background color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Find all non-background colors present in the grid\n    unique_colors = np.unique(input_grid_np)\n    non_background_colors = {int(c) for c in unique_colors if c != background_color}\n\n    # If there are no non-background colors, return the input grid as is\n    if not non_background_colors:\n        return input_grid # Return original list format\n\n    # 3. Find all objects composed of non-background colors\n    all_objects = find_objects(input_grid_np, non_background_colors)\n\n    # 4. Identify border objects and count them by color\n    border_object_color_counts = Counter()\n    object_is_border_map = {} # Store border status for quick lookup later\n    for i, obj in enumerate(all_objects):\n        obj_id = i # Use index as a simple ID\n        is_border = is_border_object(obj['coords'], grid_shape)\n        object_is_border_map[obj_id] = is_border\n        if is_border:\n            border_object_color_counts[obj['color']] += 1\n\n    # 5. Determine the moving color\n    moving_color = -1 # Use -1 to indicate no moving color found yet\n    if border_object_color_counts:\n         # Find the maximum count\n         max_count = max(border_object_color_counts.values())\n         # Find all colors that have this maximum count\n         colors_with_max_count = [color for color, count in border_object_color_counts.items() if count == max_count]\n         # Tie-breaking: choose the numerically smallest color value\n         moving_color = min(colors_with_max_count) \n        \n    # 6. Initialize output grid filled entirely with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 7. Process all found non-background objects to draw onto the output grid\n    for i, obj in enumerate(all_objects):\n        obj_id = i\n        obj_color = obj['color']\n        obj_coords = obj['coords']\n        obj_dim = obj['height'] # Assume square, use height as dimension for shift\n        \n        # Determine if this object should move\n        is_border = object_is_border_map[obj_id]\n        is_moving = is_border and (obj_color == moving_color)\n\n        if is_moving:\n            # Calculate shift based on corner and dimension\n            corner = get_object_corner(obj_coords, grid_shape)\n            dr, dc = 0, 0 # delta row, delta column for movement\n            if corner == 'top-left':\n                dr, dc = obj_dim, obj_dim       # Move down-right\n            elif corner == 'top-right':\n                dr, dc = obj_dim, -obj_dim      # Move down-left\n            elif corner == 'bottom-left':\n                dr, dc = -obj_dim, obj_dim      # Move up-right\n            elif corner == 'bottom-right':\n                dr, dc = -obj_dim, -obj_dim     # Move up-left\n            \n            # Apply shift to each pixel of the object and draw in the output grid\n            for r, c in obj_coords:\n                nr, nc = r + dr, c + dc\n                # Draw the pixel at the new location, checking grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    output_grid[nr, nc] = obj_color\n                # Pixels moving off-grid are implicitly handled by not drawing them\n\n        else: \n            # Stationary object: Draw it at its original position\n            for r, c in obj_coords:\n                 # Check bounds (mostly for safety, should always be within bounds here)\n                 if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = obj_color\n\n    # 8. Convert the final numpy grid back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 8059,
            "end_index": 8234,
            "uri": "https://github.com/linjuuu/papricacare",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 29882,
    "candidates_token_count": 2860,
    "total_token_count": 32742,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.482204,
  "retries": 1
}