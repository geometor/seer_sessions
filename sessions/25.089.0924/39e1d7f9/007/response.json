{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Grid Structure:**\n    *   Find the background color (assumed to be 0).\n    *   Find the single color forming full horizontal and vertical grid lines (grid_color).\n    *   Determine the row and column indices of these grid lines.\n    *   Calculate the height (block_h) and width (block_w) of the rectangular blocks contained within the cells defined by the grid lines (typically cell dimension - 1).\n\n2.  **Find Global Maximum Content Color:**\n    *   Scan the entire input grid.\n    *   Identify all solid rectangular blocks of size block_h x block_w that are neither the background color (0) nor the grid_color. These are \"content blocks\".\n    *   Find the maximum numerical color value among all these content blocks across the entire grid. Store this as max_color.\n    *   If no content blocks are found anywhere, return the input grid unchanged.\n\n3.  **Process Cells and Apply Transformation:**\n    *   Create a copy of the input grid to serve as the output grid.\n    *   Iterate through each cell defined by the grid lines.\n    *   **For each cell:**\n        *   Check if the cell contains at least one solid content block (size block_h x block_w, color not 0 or grid_color).\n        *   **If the cell contains content:**\n            *   Iterate through all possible block positions (top-left corner r, c) within that specific cell's boundaries.\n            *   If the block at input_grid[r:r+block_h, c:c+block_w] consists entirely of the background color (0):\n                *   Fill the corresponding area in the output_grid (output_grid[r:r+block_h, c:c+block_w]) with the globally determined max_color.\n        *   **If the cell does not contain content:** Leave the corresponding area in the output grid unchanged from the input.\n\n4.  **Return Output:** Return the modified output grid.\n\"\"\"\n\n# Helper function to find grid parameters\ndef find_grid_params(grid):\n    \"\"\"\n    Finds the grid line color, row/col indices including implicit borders, and block dimensions.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A tuple (grid_color, extended_rows, extended_cols, block_h, block_w)\n        or None if no valid grid structure is found.\n        extended_rows/cols include implicit borders -1 and h/w.\n    \"\"\"\n    h, w = grid.shape\n    grid_color = -1\n    \n    potential_grid_colors = {}\n    # Count uniform non-background rows\n    for r in range(h):\n        unique_colors, counts = np.unique(grid[r, :], return_counts=True)\n        # Check if the row is uniform and not background\n        if len(unique_colors) == 1 and unique_colors[0] != 0 and counts[0] == w:\n            color = unique_colors[0]\n            potential_grid_colors[color] = potential_grid_colors.get(color, {'rows': 0, 'cols': 0})\n            potential_grid_colors[color]['rows'] += 1\n            \n    # Count uniform non-background columns\n    for c in range(w):\n        unique_colors, counts = np.unique(grid[:, c], return_counts=True)\n         # Check if the col is uniform and not background\n        if len(unique_colors) == 1 and unique_colors[0] != 0 and counts[0] == h:\n            color = unique_colors[0]\n            potential_grid_colors[color] = potential_grid_colors.get(color, {'rows': 0, 'cols': 0})\n            potential_grid_colors[color]['cols'] += 1\n\n    # The grid color must form both rows and columns\n    valid_grid_colors = [color for color, counts in potential_grid_colors.items() if counts['rows'] > 0 and counts['cols'] > 0]\n\n    if not valid_grid_colors:\n        # No valid grid structure with lines found\n        return None \n\n    # Select grid color (most frequent line color if multiple valid)\n    grid_color = max(valid_grid_colors, key=lambda c: potential_grid_colors[c]['rows'] + potential_grid_colors[c]['cols'])\n\n    # Get indices of actual grid lines using the determined grid_color\n    row_indices = [r for r in range(h) if np.all(grid[r, :] == grid_color)]\n    col_indices = [c for c in range(w) if np.all(grid[:, c] == grid_color)]\n\n    # If somehow we picked a color but it doesn't form full lines (shouldn't happen with above logic), error out\n    if not row_indices or not col_indices:\n        return None\n\n    # Add implicit borders (-1 and h/w) for easier cell iteration\n    extended_rows = sorted(list(set([-1] + row_indices + [h])))\n    extended_cols = sorted(list(set([-1] + col_indices + [w])))\n\n    # Calculate block dimensions based on the *difference* between consecutive grid lines\n    # Assume uniform spacing based on the first gap found\n    block_h = 0\n    if len(extended_rows) > 1:\n         # Calculate differences between all consecutive lines\n         row_diffs = np.diff(extended_rows)\n         if len(row_diffs)>0:\n            block_h = row_diffs[0] - 1 # Use first gap, assume uniformity\n\n    block_w = 0\n    if len(extended_cols) > 1:\n        col_diffs = np.diff(extended_cols)\n        if len(col_diffs)>0:\n            block_w = col_diffs[0] - 1 # Use first gap, assume uniformity\n\n    # Handle grids that might just be lines (block dim 0) or malformed\n    if block_h <= 0 or block_w <= 0:\n        return None # Invalid block dimensions derived\n\n    return grid_color, extended_rows, extended_cols, block_h, block_w\n\n\n# Helper function to find the maximum color of content blocks\ndef find_max_content_color(grid, grid_color, block_h, block_w):\n    \"\"\"\n    Finds the maximum color value among solid content blocks anywhere in the grid.\n\n    Args:\n        grid: The input numpy array.\n        grid_color: The color of the grid lines.\n        block_h: Height of the blocks within cells.\n        block_w: Width of the blocks within cells.\n\n    Returns:\n        The maximum content color found (int), or -1 if none exist.\n    \"\"\"\n    max_color = -1\n    h, w = grid.shape\n\n    # Iterate through all possible top-left corners for a block\n    for r in range(h - block_h + 1):\n        for c in range(w - block_w + 1):\n            # Extract potential block slice\n            block = grid[r:r + block_h, c:c + block_w]\n            \n            # Check if it's a solid block (all pixels the same color)\n            unique_colors = np.unique(block)\n            if len(unique_colors) == 1:\n                color = unique_colors[0]\n                # Check if it's a content block (not background 0, not grid line color)\n                if color != 0 and color != grid_color:\n                    # Update max_color if this block's color is higher\n                    max_color = max(max_color, color)\n                    \n    return max_color\n\n# Helper function to check if a cell contains any content block\ndef cell_contains_content(grid, grid_color, cell_r_start, cell_r_end, cell_c_start, cell_c_end, block_h, block_w):\n    \"\"\"\n    Checks if the specified cell region in the grid contains at least one solid content block.\n\n    Args:\n        grid: The input numpy array.\n        grid_color: The color of the grid lines.\n        cell_r_start, cell_r_end: Row boundaries of the cell (exclusive of grid lines).\n        cell_c_start, cell_c_end: Column boundaries of the cell (exclusive of grid lines).\n        block_h, block_w: Dimensions of the blocks to check for.\n\n    Returns:\n        True if at least one content block is found within the cell, False otherwise.\n    \"\"\"\n    # Iterate through potential block top-left corners *within the cell's boundaries*\n    for r in range(cell_r_start, cell_r_end - block_h + 1):\n        # Boundary check (upper row boundary)\n        if r + block_h > cell_r_end: continue \n        for c in range(cell_c_start, cell_c_end - block_w + 1):\n            # Boundary check (right column boundary)\n            if c + block_w > cell_c_end: continue \n                \n            # Extract block from the grid using global coordinates r, c\n            block = grid[r:r + block_h, c:c + block_w]\n            \n            # Ensure block shape is correct (mostly redundant due to loop limits, but safe)\n            if block.shape != (block_h, block_w): continue \n\n            # Check if it's a solid block\n            unique_colors = np.unique(block)\n            if len(unique_colors) == 1:\n                color = unique_colors[0]\n                # Is it a content block (not background 0, not grid color)?\n                if color != 0 and color != grid_color:\n                    return True # Found content, no need to search further in this cell\n                    \n    return False # No content blocks were found in this cell after checking all positions\n\n# Main transformation function\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Finds the global max content color, then for each\n    grid cell that contains *any* content block, replaces all background blocks (color 0)\n    within that cell with the global max content color.\n    \"\"\"\n    h, w = input_grid.shape\n    \n    # 1. Identify Grid Parameters\n    # Find grid color, line locations, and block dimensions\n    grid_params = find_grid_params(input_grid)\n    if grid_params is None:\n        # If grid structure (lines, block size) isn't found or is invalid, return input copy\n        return np.copy(input_grid) \n        \n    grid_color, row_indices, col_indices, block_h, block_w = grid_params\n\n    # Final check on derived block dimensions against grid size\n    if block_h <= 0 or block_w <= 0 or block_h > h or block_w > w :\n         return np.copy(input_grid)\n\n    # 2. Find Global Maximum Content Color\n    # Scan the entire grid for the highest color value present in any content block\n    max_color = find_max_content_color(input_grid, grid_color, block_h, block_w)\n\n    # If no content blocks were found anywhere in the grid, return the original grid copy\n    if max_color == -1:\n        return np.copy(input_grid)\n\n    # 3. Process Cells and Apply Transformation\n    # Create the output grid as a copy of the input to modify\n    output_grid = np.copy(input_grid) \n\n    # Iterate through each cell defined by the grid line indices\n    for r_idx in range(len(row_indices) - 1):\n        for c_idx in range(len(col_indices) - 1):\n            # Define the boundaries of the current cell (exclusive of the grid lines)\n            # Coordinates are global within the input_grid\n            cell_r_start = row_indices[r_idx] + 1\n            cell_r_end = row_indices[r_idx + 1]\n            cell_c_start = col_indices[c_idx] + 1\n            cell_c_end = col_indices[c_idx + 1]\n\n            # Skip processing if the calculated cell dimensions are invalid (e.g., adjacent grid lines)\n            if cell_r_start >= cell_r_end or cell_c_start >= cell_c_end:\n                continue\n                \n            # Check if the current cell contains at least one content block\n            has_content = cell_contains_content(input_grid, grid_color, \n                                                 cell_r_start, cell_r_end, \n                                                 cell_c_start, cell_c_end, \n                                                 block_h, block_w)\n\n            # If the cell contains content, proceed to replace its background blocks\n            if has_content:\n                # Iterate through all possible block top-left corners (r, c) *within this cell*\n                for r in range(cell_r_start, cell_r_end - block_h + 1):\n                    # Boundary check (should not exceed cell_r_end)\n                    if r + block_h > cell_r_end: continue\n                    for c in range(cell_c_start, cell_c_end - block_w + 1):\n                        # Boundary check (should not exceed cell_c_end)\n                        if c + block_w > cell_c_end: continue\n                        \n                        # Check if the block at this position (r, c) in the *original* input grid is a background block\n                        original_block = input_grid[r:r + block_h, c:c + block_w]\n\n                        # Verify shape and check if all pixels in the block are the background color (0)\n                        if original_block.shape == (block_h, block_w) and np.all(original_block == 0):\n                            # If it's a background block, replace it in the *output* grid with the global max_color\n                            output_grid[r:r + block_h, c:c + block_w] = max_color\n                            \n    # 4. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 44453,
    "candidates_token_count": 3324,
    "total_token_count": 47777,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.286588,
  "retries": 1
}