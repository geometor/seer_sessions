{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Grid Structure:** Determine the background color (assumed to be 0), the grid line color (the color forming full horizontal and vertical lines), and the dimensions of the cells defined by these lines. Calculate the dimensions (height `bh`, width `bw`) of the blocks contained within these cells (cell dimensions minus 1).\n2.  **Find Maximum Content Color:** Scan the entire input grid for all solid rectangular blocks of size `bh` x `bw` that are neither the background color (0) nor the grid line color. Find the maximum numerical color value among these \"content blocks\". Store this as `max_color`. If no content blocks are found, the grid remains unchanged.\n3.  **Process Cells:** Iterate through each cell defined by the grid lines.\n4.  **Conditional Replacement:** For each cell:\n    a. Check if the cell contains *any* content blocks (solid blocks of size bh x bw, not background or grid color).\n    b. If it does, find all background blocks (solid blocks of color 0 with dimensions `bh` x `bw`) within that same cell.\n    c. Replace each found background block with a solid block of `max_color` of the same dimensions (`bh` x `bw`).\n    d. If the cell does not contain any content blocks, leave it unchanged.\n5.  **Output:** The final grid includes the original grid lines, original content blocks, and the newly colored blocks where background blocks were replaced.\n\"\"\"\n\ndef find_grid_params(grid):\n    \"\"\"\n    Finds the grid line color, row/col indices, and block dimensions.\n    \"\"\"\n    h, w = grid.shape\n    grid_color = -1\n    row_indices = []\n    col_indices = []\n\n    # Find potential grid colors by looking for uniform rows/cols (excluding background 0)\n    potential_grid_colors = {}\n    for r in range(h):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            potential_grid_colors[color] = potential_grid_colors.get(color, 0) + 1\n    for c in range(w):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            potential_grid_colors[color] = potential_grid_colors.get(color, 0) + 1\n            \n    # The grid color is likely the most frequent one forming lines\n    if not potential_grid_colors:\n         # print(\"No uniform non-background lines found.\")\n         # Maybe the grid is very small or has no lines?\n         # If there's only one non-background color, maybe that's it?\n         non_bg_colors = np.unique(grid[grid != 0])\n         if len(non_bg_colors) == 1:\n             grid_color = non_bg_colors[0]\n             # Assume no grid lines, treat as single cell\n             return grid_color, [-1, h], [-1, w], h, w\n         else:\n             # Cannot determine grid structure\n             return None # Indicate failure\n\n    # Determine grid_color based on frequency or other heuristics if needed\n    grid_color = max(potential_grid_colors, key=potential_grid_colors.get)\n    \n    # Find actual grid lines using the determined grid_color\n    row_indices = [r for r in range(h) if np.all(grid[r, :] == grid_color)]\n    col_indices = [c for c in range(w) if np.all(grid[:, c] == grid_color)]\n\n    if not row_indices or not col_indices:\n         # print(f\"Warning: Found potential grid color {grid_color} but no complete lines.\")\n         # Handle cases like single line grids or T-junctions? For now, treat as one cell if lines incomplete\n         return grid_color, [-1, h], [-1, w], h, w # Fallback\n\n    # Add implicit borders for cell iteration\n    extended_rows = sorted(list(set([-1] + row_indices + [h])))\n    extended_cols = sorted(list(set([-1] + col_indices + [w])))\n\n    # Calculate block dimensions based on the first cell gap\n    if len(extended_rows) > 1:\n        block_h = extended_rows[1] - extended_rows[0] - 1\n    else:\n        block_h = h # No horizontal lines other than border\n\n    if len(extended_cols) > 1:\n        block_w = extended_cols[1] - extended_cols[0] - 1\n    else:\n        block_w = w # No vertical lines other than border\n\n    # Ensure block dimensions are at least 1\n    block_h = max(1, block_h)\n    block_w = max(1, block_w)\n\n    # print(f\"Grid Params: color={grid_color}, block_h={block_h}, block_w={block_w}\")\n    # print(f\"Row Indices: {extended_rows}\")\n    # print(f\"Col Indices: {extended_cols}\")\n\n    return grid_color, extended_rows, extended_cols, block_h, block_w\n\n\ndef find_max_content_color(grid, grid_color, block_h, block_w, row_indices, col_indices):\n    \"\"\"\n    Finds the maximum color value among solid content blocks.\n    \"\"\"\n    max_color = -1\n    h, w = grid.shape\n\n    # Iterate through cells defined by grid lines\n    for r_idx in range(len(row_indices) - 1):\n        for c_idx in range(len(col_indices) - 1):\n            cell_r_start = row_indices[r_idx] + 1\n            cell_r_end = row_indices[r_idx + 1]\n            cell_c_start = col_indices[c_idx] + 1\n            cell_c_end = col_indices[c_idx + 1]\n\n            # Check for invalid cell dimensions\n            if cell_r_start >= cell_r_end or cell_c_start >= cell_c_end:\n                continue\n\n            # Iterate through potential block top-left corners within the cell\n            # Step size should match block size + grid line width (1) if blocks don't overlap\n            # However, examples show blocks can be adjacent, so step by 1\n            for r in range(cell_r_start, cell_r_end - block_h + 1):\n                for c in range(cell_c_start, cell_c_end - block_w + 1):\n                    # Extract potential block\n                    if r + block_h > h or c + block_w > w: continue # Bounds check\n                    block = grid[r:r + block_h, c:c + block_w]\n\n                    # Verify dimensions again (important for edge cells)\n                    if block.shape != (block_h, block_w):\n                        continue\n\n                    # Check if it's a solid block\n                    unique_colors = np.unique(block)\n                    if len(unique_colors) == 1:\n                        color = unique_colors[0]\n                        # Check if it's a content block (not background, not grid line)\n                        if color != 0 and color != grid_color:\n                            max_color = max(max_color, color)\n                            # print(f\"Found content block color {color} at ({r},{c}). Current max_color={max_color}\")\n\n\n    # print(f\"Final Max Content Color: {max_color}\")\n    return max_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the identified rule.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1. Identify Grid Parameters\n    grid_params = find_grid_params(input_grid)\n    if grid_params is None:\n        # print(\"Failed to determine grid parameters. Returning input.\")\n        return output_grid # Return copy if grid structure unclear\n    grid_color, row_indices, col_indices, block_h, block_w = grid_params\n\n    # Basic sanity check for block dimensions derived\n    if block_h <= 0 or block_w <= 0 or block_h > h or block_w > w :\n         # print(f\"Warning: Invalid block dimensions calculated ({block_h}x{block_w}). Returning input.\")\n         return output_grid\n\n    # 2. Find Maximum Content Color\n    max_color = find_max_content_color(input_grid, grid_color, block_h, block_w, row_indices, col_indices)\n\n    # If no content blocks are found, no transformation is needed\n    if max_color == -1:\n        # print(\"No content blocks found. Returning input.\")\n        return output_grid\n\n    # 3. & 4. Process Each Cell and Apply Transformation\n    # Iterate through cells defined by grid lines\n    for r_idx in range(len(row_indices) - 1):\n        for c_idx in range(len(col_indices) - 1):\n            # Define cell boundaries (excluding grid lines)\n            cell_r_start = row_indices[r_idx] + 1\n            cell_r_end = row_indices[r_idx + 1]\n            cell_c_start = col_indices[c_idx] + 1\n            cell_c_end = col_indices[c_idx + 1]\n\n            # Check for invalid cell dimensions\n            if cell_r_start >= cell_r_end or cell_c_start >= cell_c_end:\n                continue\n\n            # Check if this cell contains *any* content block\n            cell_has_content = False\n            # Iterate through potential blocks within the cell to check for *any* solid content block\n            for r_cell in range(cell_r_start, cell_r_end - block_h + 1):\n                for c_cell in range(cell_c_start, cell_c_end - block_w + 1):\n                    if r_cell + block_h > h or c_cell + block_w > w: continue # Bounds check\n                    block = input_grid[r_cell:r_cell + block_h, c_cell:c_cell + block_w]\n\n                    if block.shape != (block_h, block_w): continue\n\n                    unique_colors = np.unique(block)\n                    if len(unique_colors) == 1:\n                        color = unique_colors[0]\n                        if color != 0 and color != grid_color:\n                            cell_has_content = True\n                            # print(f\"Cell ({r_idx},{c_idx}) HAS content (found block color {color} at ({r_cell},{c_cell})).\")\n                            break # Found content, no need to check further blocks in this cell\n                if cell_has_content:\n                    break\n            \n            #if not cell_has_content:\n                #print(f\"Cell ({r_idx},{c_idx}) has NO content.\")\n\n            # If cell contains content, replace background blocks within it using the global max_color\n            if cell_has_content:\n                # Iterate through potential block top-left corners *within this cell* again\n                for r in range(cell_r_start, cell_r_end - block_h + 1):\n                    for c in range(cell_c_start, cell_c_end - block_w + 1):\n                         if r + block_h > h or c + block_w > w: continue # Bounds check\n                         # Check if the block at this position in the *original* grid is a background block\n                         original_block = input_grid[r:r + block_h, c:c + block_w]\n\n                         if original_block.shape == (block_h, block_w) and np.all(original_block == 0):\n                             # Replace this block in the output grid\n                             # print(f\"Replacing background block at ({r},{c}) in cell ({r_idx},{c_idx}) with color {max_color}.\")\n                             output_grid[r:r + block_h, c:c + block_w] = max_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 29925,
    "candidates_token_count": 2940,
    "total_token_count": 32865,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.888619,
  "retries": 1
}