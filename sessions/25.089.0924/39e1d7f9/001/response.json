{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Grid Structure:** Determine the background color (0), the grid line color (the color forming full horizontal and vertical lines), and the dimensions of the cells defined by these lines. Calculate the dimensions (height `bh`, width `bw`) of the blocks contained within these cells (cell dimensions minus 1).\n2.  **Find Maximum Content Color:** Scan the entire input grid for all solid rectangular blocks of size `bh` x `bw` that are neither the background color (0) nor the grid line color. Find the maximum numerical color value among these \"content blocks\". Store this as `max_color`. If no content blocks are found, the grid remains unchanged.\n3.  **Process Cells:** Iterate through each cell defined by the grid lines.\n4.  **Conditional Replacement:** For each cell:\n    a. Check if the cell contains *any* content blocks.\n    b. If it does, find all background blocks (solid blocks of color 0 with dimensions `bh` x `bw`) within that same cell.\n    c. Replace each found background block with a solid block of `max_color` of the same dimensions (`bh` x `bw`).\n    d. If the cell does not contain any content blocks, leave it unchanged.\n5.  **Output:** The final grid includes the original grid lines, original content blocks, and the newly colored blocks where background blocks were replaced.\n\"\"\"\n\ndef find_grid_params(grid):\n    \"\"\"\n    Finds the grid line color, row/col spacing, and block dimensions.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A tuple (grid_color, row_indices, col_indices, block_h, block_w)\n        or None if no grid structure is found.\n    \"\"\"\n    h, w = grid.shape\n    grid_color = -1\n    row_indices = []\n    col_indices = []\n\n    # Find horizontal grid lines and their color\n    for r in range(h):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            if grid_color == -1:\n                grid_color = unique_colors[0]\n            if unique_colors[0] == grid_color:\n                 row_indices.append(r)\n\n    # Find vertical grid lines (must match horizontal grid color)\n    if grid_color != -1:\n        for c in range(w):\n             unique_colors = np.unique(grid[:, c])\n             if len(unique_colors) == 1 and unique_colors[0] == grid_color:\n                 col_indices.append(c)\n\n    if not row_indices or not col_indices or grid_color == -1:\n        # Handle cases where grid might be just a single cell or malformed\n         # Try finding grid color by checking if any non-zero color appears in > 50% of rows/cols\n        potential_colors = {}\n        for c in range(1,10):\n             potential_colors[c] = {'row':0, 'col':0}\n\n        for r in range(h):\n             unique_colors, counts = np.unique(grid[r, :], return_counts=True)\n             for color, count in zip(unique_colors, counts):\n                 if color != 0 and count == w:\n                     potential_colors[color]['row'] += 1\n        for c in range(w):\n            unique_colors, counts = np.unique(grid[:, c], return_counts=True)\n            for color, count in zip(unique_colors, counts):\n                if color != 0 and count == h:\n                    potential_colors[color]['col'] += 1\n\n        best_color = -1\n        for color, counts in potential_colors.items():\n            if counts['row'] > h // 2 or counts['col'] > w // 2:\n                 grid_color = color\n                 break\n\n        if grid_color != -1:\n            row_indices = [r for r in range(h) if np.all(grid[r, :] == grid_color)]\n            col_indices = [c for c in range(w) if np.all(grid[:, c] == grid_color)]\n\n    if not row_indices or not col_indices or grid_color == -1:\n         print(\"Warning: Could not determine grid structure definitively.\")\n         # Default assumption if no grid lines: entire grid is one cell\n         return grid_color, [-1, h], [-1, w], h, w # Treat borders as implicit grid lines\n\n    # Calculate spacing and block dimensions\n    # Assume uniform spacing\n    row_spacing = np.diff(row_indices)\n    col_spacing = np.diff(col_indices)\n\n    if len(row_spacing) > 0 and np.all(row_spacing == row_spacing[0]):\n        block_h = row_spacing[0] - 1\n    elif len(row_indices) > 0: # Only one line or inconsistent spacing, guess from first gap\n        block_h = row_indices[0] if row_indices[0] > 0 else h - row_indices[-1] -1 if row_indices[-1] < h - 1 else 1\n        if len(row_indices) > 1 : # try avg\n             block_h = int(round(np.mean(row_spacing) -1 )) if len(row_spacing)>0 else block_h\n    else: # No horizontal lines detected other than maybe borders\n        block_h = h\n\n    if len(col_spacing) > 0 and np.all(col_spacing == col_spacing[0]):\n        block_w = col_spacing[0] - 1\n    elif len(col_indices) > 0: # Only one line or inconsistent spacing, guess from first gap\n        block_w = col_indices[0] if col_indices[0] > 0 else w - col_indices[-1] -1 if col_indices[-1] < w - 1 else 1\n        if len(col_indices) > 1:\n             block_w = int(round(np.mean(col_spacing)-1)) if len(col_spacing) > 0 else block_w\n    else: # No vertical lines detected other than maybe borders\n        block_w = w\n\n    # Add implicit borders for cell iteration\n    extended_rows = sorted(list(set([-1] + row_indices + [h])))\n    extended_cols = sorted(list(set([-1] + col_indices + [w])))\n\n\n    # Ensure block dimensions are at least 1\n    block_h = max(1, block_h)\n    block_w = max(1, block_w)\n\n\n    return grid_color, extended_rows, extended_cols, block_h, block_w\n\ndef find_max_content_color(grid, grid_color, block_h, block_w, row_indices, col_indices):\n    \"\"\"\n    Finds the maximum color value among content blocks.\n\n    Args:\n        grid: The input numpy array.\n        grid_color: The color of the grid lines.\n        block_h: Height of the blocks within cells.\n        block_w: Width of the blocks within cells.\n        row_indices: List of row indices of horizontal grid lines (including borders -1, h).\n        col_indices: List of col indices of vertical grid lines (including borders -1, w).\n\n    Returns:\n        The maximum content color found, or -1 if none exist.\n    \"\"\"\n    max_color = -1\n    h, w = grid.shape\n\n    for r_idx in range(len(row_indices) - 1):\n        for c_idx in range(len(col_indices) - 1):\n            cell_r_start = row_indices[r_idx] + 1\n            cell_r_end = row_indices[r_idx + 1]\n            cell_c_start = col_indices[c_idx] + 1\n            cell_c_end = col_indices[c_idx + 1]\n\n            # Iterate through potential block top-left corners within the cell\n            for r in range(cell_r_start, cell_r_end - block_h + 1):\n                 for c in range(cell_c_start, cell_c_end - block_w + 1):\n                    block = grid[r:r + block_h, c:c + block_w]\n                    if block.shape != (block_h, block_w): continue # Skip incomplete blocks at edges\n\n                    unique_colors = np.unique(block)\n                    # Check if it's a solid block, not background, and not grid color\n                    if len(unique_colors) == 1:\n                         color = unique_colors[0]\n                         if color != 0 and color != grid_color:\n                             max_color = max(max_color, color)\n                    # # Alternative check: Does it contain *any* non-background, non-grid color?\n                    # elif np.any((block != 0) & (block != grid_color)):\n                    #      content_colors = block[(block != 0) & (block != grid_color)]\n                    #      if len(content_colors)>0:\n                    #           max_color = max(max_color, np.max(content_colors))\n\n\n    return max_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding cells containing content blocks\n    and replacing background blocks within those cells with the maximum\n    content color found anywhere in the grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1. Identify Grid Parameters\n    grid_params = find_grid_params(input_grid)\n    if grid_params is None:\n        print(\"Could not find grid parameters.\")\n        return output_grid # Return copy if grid structure unclear\n\n    grid_color, row_indices, col_indices, block_h, block_w = grid_params\n    \n    if block_h <= 0 or block_w <= 0:\n         print(f\"Warning: Invalid block dimensions calculated ({block_h}x{block_w}). Aborting.\")\n         return output_grid\n\n    # 2. Find Maximum Content Color\n    max_color = find_max_content_color(input_grid, grid_color, block_h, block_w, row_indices, col_indices)\n\n    # If no content blocks are found, no transformation is needed\n    if max_color == -1:\n        return output_grid\n\n    # 3. & 4. Process Each Cell and Apply Transformation\n    for r_idx in range(len(row_indices) - 1):\n        for c_idx in range(len(col_indices) - 1):\n            # Define cell boundaries (excluding grid lines)\n            cell_r_start = row_indices[r_idx] + 1\n            cell_r_end = row_indices[r_idx + 1]\n            cell_c_start = col_indices[c_idx] + 1\n            cell_c_end = col_indices[c_idx + 1]\n\n            # Check if cell is valid\n            if cell_r_start >= cell_r_end or cell_c_start >= cell_c_end:\n                continue\n\n            cell_content = input_grid[cell_r_start:cell_r_end, cell_c_start:cell_c_end]\n\n            # Check if this cell contains any content block\n            cell_has_content = False\n            # Iterate through potential blocks within the cell to check for content\n            for r_cell in range(0, cell_content.shape[0] - block_h + 1):\n                 for c_cell in range(0, cell_content.shape[1] - block_w + 1):\n                      block = cell_content[r_cell:r_cell + block_h, c_cell:c_cell + block_w]\n                      if block.shape != (block_h, block_w): continue\n                      unique_colors = np.unique(block)\n                      if len(unique_colors) == 1:\n                           color = unique_colors[0]\n                           if color != 0 and color != grid_color:\n                                cell_has_content = True\n                                break # Found content, no need to check further blocks in this cell\n                      # # Alternative: Check for *any* content pixel\n                      # elif np.any((block != 0) & (block != grid_color)):\n                      #       cell_has_content = True\n                      #       break\n                 if cell_has_content:\n                      break\n\n\n            # If cell contains content, replace background blocks within it\n            if cell_has_content:\n                # Iterate through potential block top-left corners in the original grid coordinates\n                for r in range(cell_r_start, cell_r_end - block_h + 1, 1): # Step by 1 initially, should refine later if blocks are spaced\n                    for c in range(cell_c_start, cell_c_end - block_w + 1, 1):\n                        # Check if the block at this position in the *original* grid is a background block\n                        original_block = input_grid[r:r + block_h, c:c + block_w]\n\n                        if original_block.shape == (block_h, block_w) and np.all(original_block == 0):\n                             # Replace this block in the output grid\n                             output_grid[r:r + block_h, c:c + block_w] = max_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10739,
    "candidates_token_count": 3191,
    "total_token_count": 13930,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 124.388977,
  "retries": 2
}