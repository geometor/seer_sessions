{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the bounding box defined by yellow (4) pixels in the input grid.\nCreate an output grid based on the bounding box size.\nCopy the content strictly inside the input bounding box to the interior of the output grid (offset by 1 row and 1 column).\nFind the most frequent non-background color present *outside* the bounding box in the input grid.\nIdentify distinct objects within the copied content in the output grid.\nFor each object, create copies shifted two columns to the left and two columns to the right, using the determined most frequent outside color. These shifted copies only overwrite background (0) pixels in the output grid.\nSet the four corners of the output grid to yellow (4).\n\"\"\"\n\ndef find_bounding_box(grid, color_value):\n    \"\"\"Finds the min/max row/col for pixels of a specific color.\"\"\"\n    coordinates = np.argwhere(grid == color_value)\n    if coordinates.size == 0:\n        return None # Indicate not found\n    min_row = np.min(coordinates[:, 0])\n    min_col = np.min(coordinates[:, 1])\n    max_row = np.max(coordinates[:, 0])\n    max_col = np.max(coordinates[:, 1])\n    return min_row, min_col, max_row, max_col\n\ndef get_most_frequent_outside_color(grid, min_r, min_c, max_r, max_c):\n    \"\"\"\n    Finds the most frequent non-background color outside the bounding box.\n    Returns the color value or 0 if no non-background colors are outside.\n    \"\"\"\n    outside_colors = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is outside the bounding box\n            is_outside = r < min_r or r > max_r or c < min_c or c > max_c\n            if is_outside and grid[r, c] != 0: # Exclude background\n                outside_colors.append(grid[r, c])\n\n    if not outside_colors:\n        return 0 # Default or fallback color if none found\n\n    # Count frequencies\n    color_counts = Counter(outside_colors)\n\n    # Find the max frequency\n    max_freq = 0\n    for color, count in color_counts.items():\n        if count > max_freq:\n            max_freq = count\n\n    # Find all colors with the max frequency\n    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n    # Tie-breaking: return the smallest color index\n    return min(most_frequent_colors)\n\n\ndef find_objects_in_region(grid, start_row, end_row, start_col, end_col):\n    \"\"\"\n    Finds contiguous objects of the same color within a specified region.\n    Returns a list of objects, where each object is a tuple: (color, set_of_coordinates).\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(start_row, end_row):\n        for c in range(start_col, end_col):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    # Check if still within the specified search region\n                    if not (start_row <= row < end_row and start_col <= col < end_col):\n                        continue # Should not happen if starting point is valid, but good check\n\n                    obj_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, region, color match, and not visited\n                        if (start_row <= nr < end_row and\n                            start_col <= nc < end_col and\n                            grid[nr, nc] == color and\n                            not visited[nr, nc]):\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                     objects.append((color, obj_coords))\n                     \n    return objects\n\n\ndef transform(input_grid):\n    input_np = np.array(input_grid, dtype=int)\n    rows_in, cols_in = input_np.shape\n\n    # 1. Find bounding box using yellow pixels\n    bbox = find_bounding_box(input_np, 4)\n    if bbox is None:\n         # If no yellow markers, maybe return original grid or handle error\n         return input_grid \n    min_r, min_c, max_r, max_c = bbox\n\n    # 2. Calculate output grid dimensions\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Ensure valid dimensions\n    if height <= 0 or width <= 0:\n        return [] # Or raise error\n\n    # 3. Create output grid initialized with 0s\n    output_np = np.zeros((height, width), dtype=int)\n\n    # 4. Copy inner content if the box is large enough\n    inner_content_exists = (max_r > min_r + 1) and (max_c > min_c + 1)\n    if inner_content_exists:\n        inner_content = input_np[min_r + 1 : max_r, min_c + 1 : max_c]\n        inner_h, inner_w = inner_content.shape\n        # Place content starting at [1, 1] in the output grid\n        if inner_h > 0 and inner_w > 0:\n            output_np[1 : 1 + inner_h, 1 : 1 + inner_w] = inner_content\n\n    # 5 & 6. Find the most frequent color outside the bounding box\n    shift_color = get_most_frequent_outside_color(input_np, min_r, min_c, max_r, max_c)\n    \n    # 7. Find objects within the copied inner content area of the output grid\n    # The search region in output_np is [1, height-1) x [1, width-1)\n    objects = find_objects_in_region(output_np, 1, height - 1, 1, width - 1)\n\n    # 8. For each object, attempt left and right shifts using shift_color\n    for _, coords in objects:\n        if not coords: continue\n        # Find top-left corner of the object's bounding box for relative calculations\n        obj_min_r = min(r for r, c in coords)\n        obj_min_c = min(c for r, c in coords)\n\n        # Iterate through each pixel of the object\n        for r, c in coords:\n            rel_r = r - obj_min_r\n            rel_c = c - obj_min_c\n\n            # Calculate shift target coordinates\n            targets = [\n                (obj_min_r + rel_r, obj_min_c + rel_c + 2), # Right shift\n                (obj_min_r + rel_r, obj_min_c + rel_c - 2)  # Left shift\n            ]\n\n            for tr, tc in targets:\n                # Check if target is within output bounds\n                if 0 <= tr < height and 0 <= tc < width:\n                    # Check if target pixel is currently background (0)\n                    if output_np[tr, tc] == 0:\n                        output_np[tr, tc] = shift_color\n\n    # 9. Set the four corners to yellow (4)\n    output_np[0, 0] = 4\n    if width > 1:\n        output_np[0, width - 1] = 4\n    if height > 1:\n        output_np[height - 1, 0] = 4\n    if height > 1 and width > 1:\n        output_np[height - 1, width - 1] = 4\n        \n    # Convert back to list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18526,
    "candidates_token_count": 2009,
    "total_token_count": 20535,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 106.8106,
  "retries": 2
}