{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1. Identify the bounding box defined by yellow (4) pixels in the input grid.\n2. Determine the output grid size based on the bounding box dimensions.\n3. Find the most frequent non-background color present *outside* the bounding box in the input grid (shift_color). Ties are broken by the smallest color index.\n4. Create the output grid, initially filled with the background color (0).\n5. Copy the content strictly *inside* the input bounding box to the interior of the output grid (offset by 1 row and 1 column).\n6. Identify distinct, contiguous objects (same-colored, non-background pixels) within the copied content area of the output grid.\n7. For each pixel of each identified object, calculate potential shifted positions two columns to the left and two columns to the right.\n8. If a shifted position is within the output grid bounds and currently contains the background color (0), mark it to be colored with the shift_color.\n9. Color all marked shifted positions with the shift_color.\n10. Set the four corner pixels of the output grid to yellow (4).\n\"\"\"\n\ndef find_bounding_box(grid, color_value):\n    \"\"\"Finds the min/max row/col for pixels of a specific color.\"\"\"\n    coordinates = np.argwhere(grid == color_value)\n    if coordinates.size == 0:\n        return None # Indicate not found\n    min_row = np.min(coordinates[:, 0])\n    min_col = np.min(coordinates[:, 1])\n    max_row = np.max(coordinates[:, 0])\n    max_col = np.max(coordinates[:, 1])\n    return min_row, min_col, max_row, max_col\n\ndef get_most_frequent_outside_color(grid, min_r, min_c, max_r, max_c):\n    \"\"\"\n    Finds the most frequent non-background (non-0) color outside the bounding box.\n    Handles ties by returning the smallest color index.\n    Returns 0 if no non-background colors are found outside.\n    \"\"\"\n    outside_colors = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is outside the bounding box\n            is_outside = r < min_r or r > max_r or c < min_c or c > max_c\n            if is_outside and grid[r, c] != 0: # Exclude background\n                outside_colors.append(grid[r, c])\n\n    if not outside_colors:\n        return 0 # Default or fallback color if none found\n\n    # Count frequencies\n    color_counts = Counter(outside_colors)\n\n    # Find the max frequency\n    max_freq = 0\n    # Use items() which is generally preferred over iteritems() in Python 3\n    for color, count in color_counts.items():\n        if count > max_freq:\n            max_freq = count\n\n    # Find all colors with the max frequency\n    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n    # Tie-breaking: return the smallest color index\n    return min(most_frequent_colors) if most_frequent_colors else 0\n\n\ndef find_objects_in_region(grid, start_row, end_row, start_col, end_col):\n    \"\"\"\n    Finds contiguous objects (4-connectivity) of the same color within a specified region.\n    Returns a list of objects, where each object is a tuple: (color, set_of_coordinates).\n    Skips background color (0).\n    \"\"\"\n    objects = []\n    if start_row >= end_row or start_col >= end_col: # Handle empty region\n        return objects\n        \n    # Ensure region boundaries are within grid dimensions\n    max_r_grid, max_c_grid = grid.shape\n    actual_end_row = min(end_row, max_r_grid)\n    actual_end_col = min(end_col, max_c_grid)\n    \n    # Create visited mask only for the relevant region to save memory/time\n    visited = np.zeros((actual_end_row - start_row, actual_end_col - start_col), dtype=bool)\n\n    for r_rel in range(actual_end_row - start_row):\n        for c_rel in range(actual_end_col - start_col):\n            r_abs, c_abs = r_rel + start_row, c_rel + start_col\n            # Check if pixel is non-background and not visited *within the region's visited mask*\n            if grid[r_abs, c_abs] != 0 and not visited[r_rel, c_rel]:\n                color = grid[r_abs, c_abs]\n                obj_coords = set()\n                q = [(r_abs, c_abs)] # Queue stores absolute coordinates\n                visited[r_rel, c_rel] = True\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check grid bounds, region bounds, color match, and not visited\n                        if (start_row <= nr < actual_end_row and\n                            start_col <= nc < actual_end_col):\n                            \n                            nr_rel, nc_rel = nr - start_row, nc - start_col # Convert to relative for visited check\n                            \n                            if (grid[nr, nc] == color and\n                                not visited[nr_rel, nc_rel]):\n                                \n                                visited[nr_rel, nc_rel] = True\n                                q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append((color, obj_coords))\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting content within a yellow bounding box,\n    copying it to an output grid, adding shifted \"echoes\" of the content using\n    the most frequent outside color, and placing yellow markers at the corners.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows_in, cols_in = input_np.shape\n\n    # 1. Find bounding box using yellow pixels\n    bbox = find_bounding_box(input_np, 4)\n    if bbox is None:\n         # If no yellow markers, pattern doesn't match, return original grid or empty?\n         # Based on examples, they always exist. Let's return an empty grid matching expected style.\n         return [] \n    min_r, min_c, max_r, max_c = bbox\n\n    # 2. Calculate output grid dimensions\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Ensure valid dimensions\n    if height <= 0 or width <= 0:\n        # Should not happen if bbox found, but safety check.\n        return [] \n\n    # 3. Create output grid initialized with 0s\n    output_np = np.zeros((height, width), dtype=int)\n\n    # 4. Find the most frequent color outside the bounding box\n    shift_color = get_most_frequent_outside_color(input_np, min_r, min_c, max_r, max_c)\n\n    # 5. Copy inner content if the box is large enough\n    # Inner content region in input: rows min_r+1 to max_r-1, cols min_c+1 to max_c-1\n    # Target region in output: rows 1 to height-2, cols 1 to width-2\n    inner_content_exists = (max_r > min_r + 1) and (max_c > min_c + 1)\n    inner_h, inner_w = 0, 0\n    if inner_content_exists:\n        inner_content = input_np[min_r + 1 : max_r, min_c + 1 : max_c]\n        inner_h, inner_w = inner_content.shape\n        # Place content starting at [1, 1] in the output grid\n        if inner_h > 0 and inner_w > 0:\n            # Ensure target region doesn't exceed output bounds (it shouldn't by definition)\n             output_np[1 : 1 + inner_h, 1 : 1 + inner_w] = inner_content\n\n    # 6. Identify objects within the copied inner content area of the output grid\n    # The search region in output_np is [1, 1+inner_h) x [1, 1+inner_w)\n    # Note: end indices are exclusive for slicing/range but inclusive for find_objects_in_region\n    objects = find_objects_in_region(output_np, 1, 1 + inner_h, 1, 1 + inner_w)\n\n    # 7. & 8. Determine positions for shifted pixels\n    pixels_to_color = {} # Use dict {(r, c): color} to handle potential overlaps (last write wins, which is fine here)\n    \n    if shift_color != 0: # Only shift if a valid shift color was found\n        for _, coords in objects:\n            if not coords: continue\n            \n            for r, c in coords:\n                # Calculate shift target coordinates\n                targets = [\n                    (r, c + 2), # Right shift\n                    (r, c - 2)  # Left shift\n                ]\n\n                for tr, tc in targets:\n                    # Check if target is within output bounds\n                    if 0 <= tr < height and 0 <= tc < width:\n                        # Check if target pixel is currently background (0)\n                        # Also ensure the target is not one of the corners we'll set later\n                        is_corner = (tr == 0 and tc == 0) or \\\n                                    (tr == 0 and tc == width - 1) or \\\n                                    (tr == height - 1 and tc == 0) or \\\n                                    (tr == height - 1 and tc == width - 1)\n                                    \n                        if output_np[tr, tc] == 0 and not is_corner:\n                             # Store the target coordinate and the color to paint it\n                             pixels_to_color[(tr, tc)] = shift_color\n\n\n    # 9. Apply the shifts by coloring the marked pixels\n    for (r, c), color in pixels_to_color.items():\n        output_np[r, c] = color\n\n    # 10. Set the four corners to yellow (4)\n    output_np[0, 0] = 4\n    if width > 1:\n        output_np[0, width - 1] = 4\n    if height > 1:\n        output_np[height - 1, 0] = 4\n    if height > 1 and width > 1:\n        output_np[height - 1, width - 1] = 4\n        \n    # Convert back to list of lists for the required output format\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19178,
    "candidates_token_count": 2661,
    "total_token_count": 21839,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.107483,
  "retries": 1
}