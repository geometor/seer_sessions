
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
4 0 0 0 0 0 4
0 2 2 3 3 0 0
0 2 2 3 3 0 0
0 3 3 8 8 0 0
0 3 3 8 8 0 0
0 0 0 0 0 0 0
4 0 0 0 0 0 4
```


## train_2

**input:**
```
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 3 3 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 0 0 0 0 0 0 2 2 0 0 0
0 3 3 0 0 0 0 0 0 2 2 0 0 0
0 1 1 1 1 0 0 1 1 1 1 0 0 0
0 1 1 1 1 0 0 1 1 1 1 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 0 0 0 4
```


## train_3

**input:**
```
0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 1 1 1 1 1 1 0
0 2 2 2 1 1 1 1 1 1 0
0 2 2 2 1 1 1 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 4
```

**Perception**

1.  **Input/Output Structure:** Each task pair consists of an input grid and a smaller output grid. Both grids contain colored pixels (represented by integers 0-9) on a white (0) background.
2.  **Key Element - Yellow Pixels (4):** Yellow pixels appear in the input grids, typically marking the corners of a rectangular region. These yellow pixels are consistently present in the corners of the output grid.
3.  **Transformation:** The core transformation involves extracting a subgrid from the input and placing it into the output grid.
4.  **Bounding Box:** The yellow pixels in the input define a bounding box. The top-left corner of the box is determined by the minimum row and column of the yellow pixels, and the bottom-right corner by the maximum row and column.
5.  **Content Extraction:** The content *strictly inside* this bounding box (i.e., excluding the rows and columns containing the yellow boundary pixels) is extracted from the input grid.
6.  **Output Construction:**
    *   The output grid's dimensions are determined by the bounding box size (max_row - min_row + 1) x (max_col - min_col + 1).
    *   The extracted content is placed into the output grid, offset by one row and one column from the top-left (i.e., starting at output grid coordinates [1, 1]).
    *   The four corner cells of the output grid are set to yellow (4).
    *   The rest of the output grid (the border rows/columns, excluding corners) remains white (0), unless filled by the copied content.

**YAML Facts**


```yaml
elements:
  - object: grid
    type: 2D array of integers (0-9)
    role: input/output container
  - object: pixel
    attributes:
      - color: integer (0-9) corresponding to specific colors
      - position: (row, column)
  - object: yellow_pixels
    color: 4
    role: delimiter
    description: Define the corners of a bounding box in the input grid. Always appear at the corners of the output grid.
  - object: bounding_box
    defined_by: yellow_pixels
    properties:
      - min_row: minimum row index of yellow pixels
      - min_col: minimum column index of yellow pixels
      - max_row: maximum row index of yellow pixels
      - max_col: maximum column index of yellow pixels
      - height: max_row - min_row + 1
      - width: max_col - min_col + 1
    role: defines the region of interest in the input and the size of the output.
  - object: inner_content
    location: Input grid region strictly inside the bounding_box (rows from min_row + 1 to max_row - 1, columns from min_col + 1 to max_col - 1)
    description: The pixels and their arrangement within the bounding box, excluding the boundary itself.
    role: content to be transferred to the output grid.
actions:
  - name: identify_bounding_box
    input: input grid
    output: bounding_box coordinates (min_row, min_col, max_row, max_col)
    steps:
      - find all pixels with color yellow (4)
      - determine minimum and maximum row and column indices
  - name: calculate_output_size
    input: bounding_box coordinates
    output: output grid dimensions (height, width)
    calculation: (max_row - min_row + 1, max_col - min_col + 1)
  - name: create_output_grid
    input: output grid dimensions
    output: new grid initialized with white (0)
  - name: extract_inner_content
    input: input grid, bounding_box coordinates
    output: subgrid containing pixels from input[min_row + 1 : max_row, min_col + 1 : max_col]
  - name: place_content_in_output
    input: output grid, extracted inner_content
    target_location: output grid starting at [1, 1]
    action: copy inner_content to the specified location in the output grid
  - name: set_output_corners
    input: output grid
    action: set pixels at [0, 0], [0, width-1], [height-1, 0], [height-1, width-1] to yellow (4)
relationships:
  - input yellow pixels determine the output grid size.
  - input yellow pixels determine the region from which content is extracted.
  - input content within the bounding box (excluding the boundary) maps directly to the output grid content (offset by [1, 1]).
  - output grid corners are always yellow (4).
```


**Natural Language Program**

1.  Identify all pixels with the color yellow (4) in the input grid.
2.  Determine the minimum row (`min_row`), minimum column (`min_col`), maximum row (`max_row`), and maximum column (`max_col`) among the coordinates of these yellow pixels. This defines the bounding box.
3.  Calculate the dimensions of the output grid: `height = max_row - min_row + 1`, `width = max_col - min_col + 1`.
4.  Create a new grid (the output grid) of size `height` x `width`, initialized entirely with the background color white (0).
5.  Iterate through the input grid for rows `r` from `min_row + 1` to `max_row - 1` and for columns `c` from `min_col + 1` to `max_col - 1`.
6.  For each pixel at input grid coordinate (`r`, `c`), copy its color value to the output grid at coordinate (`r - min_row`, `c - min_col`).
7.  Set the color of the four corner pixels in the output grid to yellow (4):
    *   Output grid [0, 0] = 4
    *   Output grid [0, `width` - 1] = 4
    *   Output grid [`height` - 1, 0] = 4
    *   Output grid [`height` - 1, `width` - 1] = 4
8.  Return the completed output grid.
```python
import numpy as np

"""
1. Identify all pixels with the color yellow (4) in the input grid.
2. Determine the minimum row (`min_row`), minimum column (`min_col`), maximum row (`max_row`), and maximum column (`max_col`) among the coordinates of these yellow pixels. This defines the bounding box.
3. Calculate the dimensions of the output grid: `height = max_row - min_row + 1`, `width = max_col - min_col + 1`.
4. Create a new grid (the output grid) of size `height` x `width`, initialized entirely with the background color white (0).
5. Iterate through the input grid for rows `r` from `min_row + 1` to `max_row - 1` and for columns `c` from `min_col + 1` to `max_col - 1`.
6. For each pixel at input grid coordinate (`r`, `c`), copy its color value to the output grid at coordinate (`r - min_row`, `c - min_col`).
7. Set the color of the four corner pixels in the output grid to yellow (4):
    * Output grid [0, 0] = 4
    * Output grid [0, `width` - 1] = 4
    * Output grid [`height` - 1, 0] = 4
    * Output grid [`height` - 1, `width` - 1] = 4
8. Return the completed output grid.
"""

def find_pixel_coordinates(grid, color_value):
    """Finds all coordinates (row, col) of pixels with a specific color."""
    coordinates = np.argwhere(grid == color_value)
    # argwhere returns row, col pairs
    return coordinates

def transform(input_grid):
    """
    Extracts the content within a bounding box defined by yellow pixels (4) 
    from the input grid and places it into a new output grid, keeping the 
    yellow pixels at the corners of the output.
    """
    input_np = np.array(input_grid, dtype=int)
    
    # 1. Identify all pixels with the color yellow (4)
    yellow_coords = find_pixel_coordinates(input_np, 4)

    if yellow_coords.size == 0:
        # Handle case where no yellow pixels are found (return empty or original?)
        # Based on examples, yellow pixels are always present.
        # If this occurs, it might indicate an unexpected input format.
        # For now, let's return an empty grid of the same size or raise an error.
        # Returning input might be safer if the pattern doesn't match.
         return input_grid # Or raise ValueError("No yellow markers found")

    # 2. Determine the bounding box coordinates
    min_row = np.min(yellow_coords[:, 0])
    min_col = np.min(yellow_coords[:, 1])
    max_row = np.max(yellow_coords[:, 0])
    max_col = np.max(yellow_coords[:, 1])

    # 3. Calculate the dimensions of the output grid
    height = max_row - min_row + 1
    width = max_col - min_col + 1

    # 4. Create a new output grid initialized with white (0)
    output_np = np.zeros((height, width), dtype=int)

    # 5 & 6. Extract inner content and place it in the output grid
    # Ensure there is inner content to copy (check if box is larger than 1x1)
    if height > 1 and width > 1:
        inner_content = input_np[min_row + 1 : max_row, min_col + 1 : max_col]
        # Calculate the shape of the destination area in the output grid
        dest_rows, dest_cols = inner_content.shape
        # Place the content starting at [1, 1] in the output grid
        if dest_rows > 0 and dest_cols > 0:
             output_np[1 : 1 + dest_rows, 1 : 1 + dest_cols] = inner_content


    # 7. Set the four corner pixels in the output grid to yellow (4)
    output_np[0, 0] = 4
    output_np[0, width - 1] = 4
    output_np[height - 1, 0] = 4
    output_np[height - 1, width - 1] = 4
    
    # Convert numpy array back to list of lists for the required output format
    output_grid = output_np.tolist()

    # 8. Return the completed output grid
    return output_grid
```
```python
import numpy as np
from collections import Counter

"""
Identify the bounding box defined by yellow (4) pixels in the input grid.
Create an output grid based on the bounding box size.
Copy the content strictly inside the input bounding box to the interior of the output grid (offset by 1 row and 1 column).
Find the most frequent non-background color present *outside* the bounding box in the input grid.
Identify distinct objects within the copied content in the output grid.
For each object, create copies shifted two columns to the left and two columns to the right, using the determined most frequent outside color. These shifted copies only overwrite background (0) pixels in the output grid.
Set the four corners of the output grid to yellow (4).
"""

def find_bounding_box(grid, color_value):
    """Finds the min/max row/col for pixels of a specific color."""
    coordinates = np.argwhere(grid == color_value)
    if coordinates.size == 0:
        return None # Indicate not found
    min_row = np.min(coordinates[:, 0])
    min_col = np.min(coordinates[:, 1])
    max_row = np.max(coordinates[:, 0])
    max_col = np.max(coordinates[:, 1])
    return min_row, min_col, max_row, max_col

def get_most_frequent_outside_color(grid, min_r, min_c, max_r, max_c):
    """
    Finds the most frequent non-background color outside the bounding box.
    Returns the color value or 0 if no non-background colors are outside.
    """
    outside_colors = []
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            # Check if the pixel is outside the bounding box
            is_outside = r < min_r or r > max_r or c < min_c or c > max_c
            if is_outside and grid[r, c] != 0: # Exclude background
                outside_colors.append(grid[r, c])

    if not outside_colors:
        return 0 # Default or fallback color if none found

    # Count frequencies
    color_counts = Counter(outside_colors)

    # Find the max frequency
    max_freq = 0
    for color, count in color_counts.items():
        if count > max_freq:
            max_freq = count

    # Find all colors with the max frequency
    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]

    # Tie-breaking: return the smallest color index
    return min(most_frequent_colors)


def find_objects_in_region(grid, start_row, end_row, start_col, end_col):
    """
    Finds contiguous objects of the same color within a specified region.
    Returns a list of objects, where each object is a tuple: (color, set_of_coordinates).
    """
    objects = []
    visited = np.zeros_like(grid, dtype=bool)
    rows, cols = grid.shape

    for r in range(start_row, end_row):
        for c in range(start_col, end_col):
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_coords = set()
                q = [(r, c)]
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    # Check if still within the specified search region
                    if not (start_row <= row < end_row and start_col <= col < end_col):
                        continue # Should not happen if starting point is valid, but good check

                    obj_coords.add((row, col))

                    # Check neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds, region, color match, and not visited
                        if (start_row <= nr < end_row and
                            start_col <= nc < end_col and
                            grid[nr, nc] == color and
                            not visited[nr, nc]):
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            
                if obj_coords:
                     objects.append((color, obj_coords))
                     
    return objects


def transform(input_grid):
    input_np = np.array(input_grid, dtype=int)
    rows_in, cols_in = input_np.shape

    # 1. Find bounding box using yellow pixels
    bbox = find_bounding_box(input_np, 4)
    if bbox is None:
         # If no yellow markers, maybe return original grid or handle error
         return input_grid 
    min_r, min_c, max_r, max_c = bbox

    # 2. Calculate output grid dimensions
    height = max_r - min_r + 1
    width = max_c - min_c + 1

    # Ensure valid dimensions
    if height <= 0 or width <= 0:
        return [] # Or raise error

    # 3. Create output grid initialized with 0s
    output_np = np.zeros((height, width), dtype=int)

    # 4. Copy inner content if the box is large enough
    inner_content_exists = (max_r > min_r + 1) and (max_c > min_c + 1)
    if inner_content_exists:
        inner_content = input_np[min_r + 1 : max_r, min_c + 1 : max_c]
        inner_h, inner_w = inner_content.shape
        # Place content starting at [1, 1] in the output grid
        if inner_h > 0 and inner_w > 0:
            output_np[1 : 1 + inner_h, 1 : 1 + inner_w] = inner_content

    # 5 & 6. Find the most frequent color outside the bounding box
    shift_color = get_most_frequent_outside_color(input_np, min_r, min_c, max_r, max_c)
    
    # 7. Find objects within the copied inner content area of the output grid
    # The search region in output_np is [1, height-1) x [1, width-1)
    objects = find_objects_in_region(output_np, 1, height - 1, 1, width - 1)

    # 8. For each object, attempt left and right shifts using shift_color
    for _, coords in objects:
        if not coords: continue
        # Find top-left corner of the object's bounding box for relative calculations
        obj_min_r = min(r for r, c in coords)
        obj_min_c = min(c for r, c in coords)

        # Iterate through each pixel of the object
        for r, c in coords:
            rel_r = r - obj_min_r
            rel_c = c - obj_min_c

            # Calculate shift target coordinates
            targets = [
                (obj_min_r + rel_r, obj_min_c + rel_c + 2), # Right shift
                (obj_min_r + rel_r, obj_min_c + rel_c - 2)  # Left shift
            ]

            for tr, tc in targets:
                # Check if target is within output bounds
                if 0 <= tr < height and 0 <= tc < width:
                    # Check if target pixel is currently background (0)
                    if output_np[tr, tc] == 0:
                        output_np[tr, tc] = shift_color

    # 9. Set the four corners to yellow (4)
    output_np[0, 0] = 4
    if width > 1:
        output_np[0, width - 1] = 4
    if height > 1:
        output_np[height - 1, 0] = 4
    if height > 1 and width > 1:
        output_np[height - 1, width - 1] = 4
        
    # Convert back to list of lists
    output_grid = output_np.tolist()

    return output_grid
```
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:
1. Identify the bounding box defined by yellow (4) pixels in the input grid.
2. Determine the output grid size based on the bounding box dimensions.
3. Find the most frequent non-background color present *outside* the bounding box in the input grid (shift_color). Ties are broken by the smallest color index.
4. Create the output grid, initially filled with the background color (0).
5. Copy the content strictly *inside* the input bounding box to the interior of the output grid (offset by 1 row and 1 column).
6. Identify distinct, contiguous objects (same-colored, non-background pixels) within the copied content area of the output grid.
7. For each pixel of each identified object, calculate potential shifted positions two columns to the left and two columns to the right.
8. If a shifted position is within the output grid bounds and currently contains the background color (0), mark it to be colored with the shift_color.
9. Color all marked shifted positions with the shift_color.
10. Set the four corner pixels of the output grid to yellow (4).
"""

def find_bounding_box(grid, color_value):
    """Finds the min/max row/col for pixels of a specific color."""
    coordinates = np.argwhere(grid == color_value)
    if coordinates.size == 0:
        return None # Indicate not found
    min_row = np.min(coordinates[:, 0])
    min_col = np.min(coordinates[:, 1])
    max_row = np.max(coordinates[:, 0])
    max_col = np.max(coordinates[:, 1])
    return min_row, min_col, max_row, max_col

def get_most_frequent_outside_color(grid, min_r, min_c, max_r, max_c):
    """
    Finds the most frequent non-background (non-0) color outside the bounding box.
    Handles ties by returning the smallest color index.
    Returns 0 if no non-background colors are found outside.
    """
    outside_colors = []
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            # Check if the pixel is outside the bounding box
            is_outside = r < min_r or r > max_r or c < min_c or c > max_c
            if is_outside and grid[r, c] != 0: # Exclude background
                outside_colors.append(grid[r, c])

    if not outside_colors:
        return 0 # Default or fallback color if none found

    # Count frequencies
    color_counts = Counter(outside_colors)

    # Find the max frequency
    max_freq = 0
    # Use items() which is generally preferred over iteritems() in Python 3
    for color, count in color_counts.items():
        if count > max_freq:
            max_freq = count

    # Find all colors with the max frequency
    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]

    # Tie-breaking: return the smallest color index
    return min(most_frequent_colors) if most_frequent_colors else 0


def find_objects_in_region(grid, start_row, end_row, start_col, end_col):
    """
    Finds contiguous objects (4-connectivity) of the same color within a specified region.
    Returns a list of objects, where each object is a tuple: (color, set_of_coordinates).
    Skips background color (0).
    """
    objects = []
    if start_row >= end_row or start_col >= end_col: # Handle empty region
        return objects
        
    # Ensure region boundaries are within grid dimensions
    max_r_grid, max_c_grid = grid.shape
    actual_end_row = min(end_row, max_r_grid)
    actual_end_col = min(end_col, max_c_grid)
    
    # Create visited mask only for the relevant region to save memory/time
    visited = np.zeros((actual_end_row - start_row, actual_end_col - start_col), dtype=bool)

    for r_rel in range(actual_end_row - start_row):
        for c_rel in range(actual_end_col - start_col):
            r_abs, c_abs = r_rel + start_row, c_rel + start_col
            # Check if pixel is non-background and not visited *within the region's visited mask*
            if grid[r_abs, c_abs] != 0 and not visited[r_rel, c_rel]:
                color = grid[r_abs, c_abs]
                obj_coords = set()
                q = [(r_abs, c_abs)] # Queue stores absolute coordinates
                visited[r_rel, c_rel] = True

                while q:
                    row, col = q.pop(0)
                    obj_coords.add((row, col))

                    # Check neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check grid bounds, region bounds, color match, and not visited
                        if (start_row <= nr < actual_end_row and
                            start_col <= nc < actual_end_col):
                            
                            nr_rel, nc_rel = nr - start_row, nc - start_col # Convert to relative for visited check
                            
                            if (grid[nr, nc] == color and
                                not visited[nr_rel, nc_rel]):
                                
                                visited[nr_rel, nc_rel] = True
                                q.append((nr, nc))

                if obj_coords:
                    objects.append((color, obj_coords))

    return objects


def transform(input_grid):
    """
    Transforms the input grid by extracting content within a yellow bounding box,
    copying it to an output grid, adding shifted "echoes" of the content using
    the most frequent outside color, and placing yellow markers at the corners.
    """
    input_np = np.array(input_grid, dtype=int)
    rows_in, cols_in = input_np.shape

    # 1. Find bounding box using yellow pixels
    bbox = find_bounding_box(input_np, 4)
    if bbox is None:
         # If no yellow markers, pattern doesn't match, return original grid or empty?
         # Based on examples, they always exist. Let's return an empty grid matching expected style.
         return [] 
    min_r, min_c, max_r, max_c = bbox

    # 2. Calculate output grid dimensions
    height = max_r - min_r + 1
    width = max_c - min_c + 1

    # Ensure valid dimensions
    if height <= 0 or width <= 0:
        # Should not happen if bbox found, but safety check.
        return [] 

    # 3. Create output grid initialized with 0s
    output_np = np.zeros((height, width), dtype=int)

    # 4. Find the most frequent color outside the bounding box
    shift_color = get_most_frequent_outside_color(input_np, min_r, min_c, max_r, max_c)

    # 5. Copy inner content if the box is large enough
    # Inner content region in input: rows min_r+1 to max_r-1, cols min_c+1 to max_c-1
    # Target region in output: rows 1 to height-2, cols 1 to width-2
    inner_content_exists = (max_r > min_r + 1) and (max_c > min_c + 1)
    inner_h, inner_w = 0, 0
    if inner_content_exists:
        inner_content = input_np[min_r + 1 : max_r, min_c + 1 : max_c]
        inner_h, inner_w = inner_content.shape
        # Place content starting at [1, 1] in the output grid
        if inner_h > 0 and inner_w > 0:
            # Ensure target region doesn't exceed output bounds (it shouldn't by definition)
             output_np[1 : 1 + inner_h, 1 : 1 + inner_w] = inner_content

    # 6. Identify objects within the copied inner content area of the output grid
    # The search region in output_np is [1, 1+inner_h) x [1, 1+inner_w)
    # Note: end indices are exclusive for slicing/range but inclusive for find_objects_in_region
    objects = find_objects_in_region(output_np, 1, 1 + inner_h, 1, 1 + inner_w)

    # 7. & 8. Determine positions for shifted pixels
    pixels_to_color = {} # Use dict {(r, c): color} to handle potential overlaps (last write wins, which is fine here)
    
    if shift_color != 0: # Only shift if a valid shift color was found
        for _, coords in objects:
            if not coords: continue
            
            for r, c in coords:
                # Calculate shift target coordinates
                targets = [
                    (r, c + 2), # Right shift
                    (r, c - 2)  # Left shift
                ]

                for tr, tc in targets:
                    # Check if target is within output bounds
                    if 0 <= tr < height and 0 <= tc < width:
                        # Check if target pixel is currently background (0)
                        # Also ensure the target is not one of the corners we'll set later
                        is_corner = (tr == 0 and tc == 0) or \
                                    (tr == 0 and tc == width - 1) or \
                                    (tr == height - 1 and tc == 0) or \
                                    (tr == height - 1 and tc == width - 1)
                                    
                        if output_np[tr, tc] == 0 and not is_corner:
                             # Store the target coordinate and the color to paint it
                             pixels_to_color[(tr, tc)] = shift_color


    # 9. Apply the shifts by coloring the marked pixels
    for (r, c), color in pixels_to_color.items():
        output_np[r, c] = color

    # 10. Set the four corners to yellow (4)
    output_np[0, 0] = 4
    if width > 1:
        output_np[0, width - 1] = 4
    if height > 1:
        output_np[height - 1, 0] = 4
    if height > 1 and width > 1:
        output_np[height - 1, width - 1] = 4
        
    # Convert back to list of lists for the required output format
    output_grid = output_np.tolist()

    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:
1. Identify the bounding box defined by yellow (4) pixels in the input grid.
2. Determine the output grid size based on the bounding box dimensions.
3. Find the most frequent non-background color present *outside* the bounding box in the input grid (shift_color). Ties are broken by the smallest color index.
4. Create the output grid, initially filled with the background color (0).
5. Copy the content strictly *inside* the input bounding box to the interior of the output grid (offset by 1 row and 1 column).
6. Identify distinct, contiguous objects (same-colored, non-background pixels) within the copied content area of the output grid.
7. For each pixel of each identified object, calculate potential shifted positions two columns to the left and two columns to the right.
8. If a shifted position is within the output grid bounds and currently contains the background color (0), mark it to be colored with the shift_color.
9. Color all marked shifted positions with the shift_color.
10. Set the four corner pixels of the output grid to yellow (4).
"""

def find_bounding_box(grid, color_value):
    """Finds the min/max row/col for pixels of a specific color."""
    coordinates = np.argwhere(grid == color_value)
    if coordinates.size == 0:
        return None # Indicate not found
    min_row = np.min(coordinates[:, 0])
    min_col = np.min(coordinates[:, 1])
    max_row = np.max(coordinates[:, 0])
    max_col = np.max(coordinates[:, 1])
    return min_row, min_col, max_row, max_col

def get_most_frequent_outside_color(grid, min_r, min_c, max_r, max_c):
    """
    Finds the most frequent non-background (non-0) color outside the bounding box.
    Handles ties by returning the smallest color index.
    Returns 0 if no non-background colors are found outside.
    """
    outside_colors = []
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            # Check if the pixel is outside the bounding box
            is_outside = r < min_r or r > max_r or c < min_c or c > max_c
            if is_outside and grid[r, c] != 0: # Exclude background
                outside_colors.append(grid[r, c])

    if not outside_colors:
        return 0 # Default or fallback color if none found

    # Count frequencies
    color_counts = Counter(outside_colors)

    # Find the max frequency
    max_freq = 0
    # Use items() which is generally preferred over iteritems() in Python 3
    for color, count in color_counts.items():
        if count > max_freq:
            max_freq = count

    # Find all colors with the max frequency
    most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]

    # Tie-breaking: return the smallest color index
    return min(most_frequent_colors) if most_frequent_colors else 0


def find_objects_in_region(grid, start_row, end_row, start_col, end_col):
    """
    Finds contiguous objects (4-connectivity) of the same color within a specified region.
    Returns a list of objects, where each object is a tuple: (color, set_of_coordinates).
    Skips background color (0).
    """
    objects = []
    if start_row >= end_row or start_col >= end_col: # Handle empty region
        return objects
        
    # Ensure region boundaries are within grid dimensions
    max_r_grid, max_c_grid = grid.shape
    actual_end_row = min(end_row, max_r_grid)
    actual_end_col = min(end_col, max_c_grid)
    
    # Create visited mask only for the relevant region to save memory/time
    visited = np.zeros((actual_end_row - start_row, actual_end_col - start_col), dtype=bool)

    for r_rel in range(actual_end_row - start_row):
        for c_rel in range(actual_end_col - start_col):
            r_abs, c_abs = r_rel + start_row, c_rel + start_col
            # Check if pixel is non-background and not visited *within the region's visited mask*
            if grid[r_abs, c_abs] != 0 and not visited[r_rel, c_rel]:
                color = grid[r_abs, c_abs]
                obj_coords = set()
                q = [(r_abs, c_abs)] # Queue stores absolute coordinates
                visited[r_rel, c_rel] = True

                while q:
                    row, col = q.pop(0)
                    obj_coords.add((row, col))

                    # Check neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check grid bounds, region bounds, color match, and not visited
                        if (start_row <= nr < actual_end_row and
                            start_col <= nc < actual_end_col):
                            
                            nr_rel, nc_rel = nr - start_row, nc - start_col # Convert to relative for visited check
                            
                            if (grid[nr, nc] == color and
                                not visited[nr_rel, nc_rel]):
                                
                                visited[nr_rel, nc_rel] = True
                                q.append((nr, nc))

                if obj_coords:
                    objects.append((color, obj_coords))

    return objects


def transform(input_grid):
    """
    Transforms the input grid by extracting content within a yellow bounding box,
    copying it to an output grid, adding shifted "echoes" of the content using
    the most frequent outside color, and placing yellow markers at the corners.
    """
    input_np = np.array(input_grid, dtype=int)
    rows_in, cols_in = input_np.shape

    # 1. Find bounding box using yellow pixels
    bbox = find_bounding_box(input_np, 4)
    if bbox is None:
         # If no yellow markers, pattern doesn't match, return original grid or empty?
         # Based on examples, they always exist. Let's return an empty grid matching expected style.
         return [] 
    min_r, min_c, max_r, max_c = bbox

    # 2. Calculate output grid dimensions
    height = max_r - min_r + 1
    width = max_c - min_c + 1

    # Ensure valid dimensions
    if height <= 0 or width <= 0:
        # Should not happen if bbox found, but safety check.
        return [] 

    # 3. Create output grid initialized with 0s
    output_np = np.zeros((height, width), dtype=int)

    # 4. Find the most frequent color outside the bounding box
    shift_color = get_most_frequent_outside_color(input_np, min_r, min_c, max_r, max_c)

    # 5. Copy inner content if the box is large enough
    # Inner content region in input: rows min_r+1 to max_r-1, cols min_c+1 to max_c-1
    # Target region in output: rows 1 to height-2, cols 1 to width-2
    inner_content_exists = (max_r > min_r + 1) and (max_c > min_c + 1)
    inner_h, inner_w = 0, 0
    if inner_content_exists:
        inner_content = input_np[min_r + 1 : max_r, min_c + 1 : max_c]
        inner_h, inner_w = inner_content.shape
        # Place content starting at [1, 1] in the output grid
        if inner_h > 0 and inner_w > 0:
            # Ensure target region doesn't exceed output bounds (it shouldn't by definition)
             output_np[1 : 1 + inner_h, 1 : 1 + inner_w] = inner_content

    # 6. Identify objects within the copied inner content area of the output grid
    # The search region in output_np is [1, 1+inner_h) x [1, 1+inner_w)
    # Note: end indices are exclusive for slicing/range but inclusive for find_objects_in_region
    objects = find_objects_in_region(output_np, 1, 1 + inner_h, 1, 1 + inner_w)

    # 7. & 8. Determine positions for shifted pixels
    pixels_to_color = {} # Use dict {(r, c): color} to handle potential overlaps (last write wins, which is fine here)
    
    if shift_color != 0: # Only shift if a valid shift color was found
        for _, coords in objects:
            if not coords: continue
            
            for r, c in coords:
                # Calculate shift target coordinates
                targets = [
                    (r, c + 2), # Right shift
                    (r, c - 2)  # Left shift
                ]

                for tr, tc in targets:
                    # Check if target is within output bounds
                    if 0 <= tr < height and 0 <= tc < width:
                        # Check if target pixel is currently background (0)
                        # Also ensure the target is not one of the corners we'll set later
                        is_corner = (tr == 0 and tc == 0) or \
                                    (tr == 0 and tc == width - 1) or \
                                    (tr == height - 1 and tc == 0) or \
                                    (tr == height - 1 and tc == width - 1)
                                    
                        if output_np[tr, tc] == 0 and not is_corner:
                             # Store the target coordinate and the color to paint it
                             pixels_to_color[(tr, tc)] = shift_color


    # 9. Apply the shifts by coloring the marked pixels
    for (r, c), color in pixels_to_color.items():
        output_np[r, c] = color

    # 10. Set the four corners to yellow (4)
    output_np[0, 0] = 4
    if width > 1:
        output_np[0, width - 1] = 4
    if height > 1:
        output_np[height - 1, 0] = 4
    if height > 1 and width > 1:
        output_np[height - 1, width - 1] = 4
        
    # Convert back to list of lists for the required output format
    output_grid = output_np.tolist()

    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
4 0 0 0 0 0 4
0 2 2 3 3 0 0
0 2 2 3 3 0 0
0 3 3 8 8 0 0
0 3 3 8 8 0 0
0 0 0 0 0 0 0
4 0 0 0 0 0 4
```
Transformed Output:
```
4 0 0 0 0 0 4
3 2 2 3 3 0 0
3 2 2 3 3 0 0
0 3 3 8 8 3 3
0 3 3 8 8 3 3
0 0 0 0 0 0 0
4 0 0 0 0 0 4
```
Match: False
Pixels Off: 6
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 24.48979591836735

## Example 2:
Input:
```
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 3 3 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
4 0 0 0 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 0 0 0 0 0 0 2 2 0 0 0
0 3 3 0 0 0 0 0 0 2 2 0 0 0
0 1 1 1 1 0 0 1 1 1 1 0 0 0
0 1 1 1 1 0 0 1 1 1 1 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 0 0 0 4
```
Transformed Output:
```
4 0 0 0 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 3 3 1 1 0 0 1 1 2 2 1 1 0
1 3 3 1 1 0 0 1 1 2 2 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 0 0 0 4
```
Match: False
Pixels Off: 30
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 47.61904761904762

## Example 3:
Input:
```
0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 2 2 2 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
4 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 1 1 1 1 1 1 0
0 2 2 2 1 1 1 1 1 1 0
0 2 2 2 1 1 1 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 3 3 3 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 4
```
Transformed Output:
```
4 0 0 0 0 0 0 0 0 0 4
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
1 2 2 2 1 1 1 1 1 1 1
1 2 2 2 1 1 1 1 1 1 1
1 2 2 2 1 1 1 1 1 1 1
0 0 1 1 3 3 3 1 1 0 0
0 0 1 1 3 3 3 1 1 0 0
0 0 1 1 3 3 3 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 4
```
Match: False
Pixels Off: 15
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 24.79338842975207
**General Assessment**

The initial analysis correctly identified the bounding box defined by yellow pixels and the basic copy operation of the inner content. However, it misinterpreted the secondary transformation applied to the copied content. The initial code attempted a simple horizontal shift of objects using the most frequent color found outside the bounding box. The comparison with expected outputs revealed this was incorrect.

The errors indicate a more complex interaction is happening. Instead of shifting, a "filling" or "connecting" process occurs within the copied content's area. The color used for this process needs careful determination: it appears to be the color that is present *outside* the input bounding box but *not inside* it, if such a unique color exists. If no such unique color exists, it defaults to the most frequent color found outside the bounding box (using the lowest color index as a tie-breaker). The filling operation targets the background pixels within the bounding box of all non-background content copied into the output grid.

**Strategy**

1.  Refine the method for determining the "connecting color".
2.  Implement the logic to find the bounding box of the *copied content* within the output grid.
3.  Implement the filling logic: iterate within this content bounding box and replace background pixels (0) with the determined connecting color.
4.  Re-verify this revised logic against all training examples.

**Metrics**

The previous code failed qualitatively on all three examples, producing incorrect patterns rather than just misplaced pixels.

*   **Example 1:** Incorrectly added green pixels via shifting; failed to add the required green pixels connecting the red and azure shapes.
*   **Example 2:** Incorrectly added blue pixels via shifting; failed to create the correct filled blue regions connecting the shapes.
*   **Example 3:** Incorrectly added blue pixels via shifting; failed to create the correct filled blue regions connecting the shapes.

The core issue was the misinterpretation of the transformation applied *after* the initial copy.

**YAML Facts**


```yaml
elements:
  - object: grid
    type: 2D array of integers (0-9)
    role: input/output container
  - object: pixel
    attributes:
      - color: integer (0-9) corresponding to specific colors
      - position: (row, column)
  - object: yellow_pixels
    color: 4
    role: delimiter
    description: Define the corners of a primary bounding box in the input grid. Always appear at the corners of the output grid.
  - object: primary_bounding_box
    defined_by: yellow_pixels in the input grid
    properties: [min_row, min_col, max_row, max_col]
    role: defines the region for content extraction and the output grid size.
  - object: inner_content
    location: Input grid region strictly inside the primary_bounding_box (rows from min_row + 1 to max_row - 1, cols from min_col + 1 to max_col - 1)
    role: content to be initially transferred to the output grid.
  - object: outside_colors
    source: Pixels in the input grid located outside the primary_bounding_box.
    attribute: non-background colors (value != 0).
  - object: inside_colors
    source: Pixels in the input grid located strictly inside the primary_bounding_box.
    attribute: non-background colors (value != 0).
  - object: connecting_color
    determination:
      - rule_1: Identify colors present in outside_colors but not in inside_colors. If exactly one such unique color exists, use it.
      - rule_2: If rule_1 does not yield a unique color, find the most frequent color(s) in outside_colors. If there's a tie, use the color with the smallest numerical index.
      - rule_3: If no non-background outside_colors exist, this color is effectively null (or 0), and no filling occurs.
    role: The color used to fill background areas in the output grid.
  - object: copied_content_area
    location: Output grid region where inner_content was placed (typically rows 1 to height-2, cols 1 to width-2).
  - object: content_bounding_box
    defined_by: The minimum and maximum row/column of all non-background pixels within the copied_content_area in the output grid.
    role: Defines the rectangular region where background filling occurs.
actions:
  - name: identify_primary_bounding_box
    input: input grid
    output: primary_bounding_box coordinates
  - name: calculate_output_size
    input: primary_bounding_box coordinates
    output: output grid dimensions (height, width)
  - name: create_output_grid
    input: output grid dimensions
    output: new grid initialized with white (0)
  - name: determine_connecting_color
    input: input grid, primary_bounding_box coordinates
    output: connecting_color value
    steps:
      - find non-background colors inside the box
      - find non-background colors outside the box
      - check for unique outside-only color
      - if none, find most frequent outside color (with tie-breaking)
  - name: copy_inner_content
    input: input grid, output grid, primary_bounding_box coordinates
    action: copy input[min_row + 1 : max_row, min_col + 1 : max_col] to output[1 : height - 1, 1 : width - 1]
  - name: identify_content_bounding_box
    input: output grid (after copy)
    output: content_bounding_box coordinates (relative to output grid)
    steps:
      - find all non-background pixels in the copied_content_area
      - determine min/max row/col of these pixels
  - name: fill_background_in_content_box
    input: output grid, content_bounding_box, connecting_color
    action: Iterate through pixels (r, c) within the content_bounding_box. If output[r, c] is 0, set output[r, c] = connecting_color.
    condition: Only perform if connecting_color > 0.
  - name: set_output_corners
    input: output grid
    action: set corner pixels to yellow (4)
relationships:
  - input yellow pixels determine output size and initial content source.
  - colors outside vs inside the input box determine the connecting_color.
  - the extents of the copied content determine the region for background filling.
  - background pixels within the content's bounding box are filled with the connecting_color.
```


**Natural Language Program**

1.  Identify all yellow (4) pixels in the input grid. Determine their minimum and maximum row and column indices (`min_row`, `min_col`, `max_row`, `max_col`) to define the primary bounding box.
2.  Calculate the output grid dimensions: `height = max_row - min_row + 1`, `width = max_col - min_col + 1`.
3.  Create a new output grid of size `height` x
