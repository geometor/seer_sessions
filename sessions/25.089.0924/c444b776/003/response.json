{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify a unique horizontal or vertical line composed entirely of yellow pixels (4) \nthat acts as a separator. This separator line is characterized by having \n\"foreground pixels\" (defined as pixels that are neither white (0) nor yellow (4)) \nstrictly on one side of it (either above/below for horizontal, or left/right \nfor vertical). Reflect the pattern formed by these foreground pixels (along with \nany white or yellow pixels within the source region) across the separator line \ninto the target region, overwriting the original content of the target region. \nThe separator line itself remains unchanged.\n\"\"\"\n\ndef has_foreground(region, foreground_colors):\n    \"\"\"\n    Checks if a given grid region contains any foreground pixels.\n    Foreground pixels are those not in the foreground_colors set.\n    Args:\n        region (np.ndarray): The region of the grid to check.\n        foreground_colors (set): A set of colors considered background/separator.\n    Returns:\n        bool: True if foreground pixels are present, False otherwise.\n    \"\"\"\n    if region.size == 0: # Handle empty regions (e.g., above row 0)\n        return False\n    # Check if any pixel in the region is NOT in the foreground_colors set\n    return np.any(~np.isin(region, list(foreground_colors)))\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by reflecting a pattern across a unique yellow separator line.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n    yellow = 4\n    white = 0\n    background_separator_colors = {white, yellow}\n\n    # --- 1. Find potential horizontal and vertical separators ---\n    h_separator_indices = [r for r in range(rows) if np.all(grid[r, :] == yellow)]\n    v_separator_indices = [c for c in range(cols) if np.all(grid[:, c] == yellow)]\n\n    # --- 2. Identify the unique primary separator ---\n    separator_info = None # Will store ('horizontal'/'vertical', index, 'above'/'below'/'left'/'right')\n\n    # Check horizontal candidates\n    for r in h_separator_indices:\n        region_above = grid[:r, :]\n        region_below = grid[r+1:, :]\n        \n        pattern_above = has_foreground(region_above, background_separator_colors)\n        pattern_below = has_foreground(region_below, background_separator_colors)\n\n        # If pattern exists exclusively on one side, this is the separator\n        if pattern_above and not pattern_below:\n            separator_info = ('horizontal', r, 'above')\n            break\n        if not pattern_above and pattern_below:\n            separator_info = ('horizontal', r, 'below')\n            break\n    \n    # If no horizontal separator found, check vertical candidates\n    if separator_info is None:\n        for c in v_separator_indices:\n            region_left = grid[:, :c]\n            region_right = grid[:, c+1:]\n\n            pattern_left = has_foreground(region_left, background_separator_colors)\n            pattern_right = has_foreground(region_right, background_separator_colors)\n\n            # If pattern exists exclusively on one side, this is the separator\n            if pattern_left and not pattern_right:\n                separator_info = ('vertical', c, 'left')\n                break\n            if not pattern_left and pattern_right:\n                 separator_info = ('vertical', c, 'right')\n                 break\n\n    # --- 3. Perform reflection if a valid separator was found ---\n    if separator_info:\n        orientation, index, pattern_side = separator_info\n\n        if orientation == 'horizontal':\n            R = index\n            if pattern_side == 'above':\n                # Reflect region above (0 to R-1) to region below (R+1 onwards)\n                for r in range(R):\n                    for c in range(cols):\n                        target_r = 2 * R - r\n                        if 0 <= target_r < rows:\n                            output_grid[target_r, c] = grid[r, c]\n            else: # pattern_side == 'below'\n                # Reflect region below (R+1 to end) to region above (0 to R-1)\n                 for r in range(R + 1, rows):\n                    for c in range(cols):\n                        target_r = 2 * R - r\n                        if 0 <= target_r < rows:\n                             output_grid[target_r, c] = grid[r, c]\n\n        elif orientation == 'vertical':\n            C = index\n            if pattern_side == 'left':\n                 # Reflect region left (0 to C-1) to region right (C+1 onwards)\n                 for r in range(rows):\n                    for c in range(C):\n                        target_c = 2 * C - c\n                        if 0 <= target_c < cols:\n                            output_grid[r, target_c] = grid[r, c]\n            else: # pattern_side == 'right'\n                 # Reflect region right (C+1 to end) to region left (0 to C-1)\n                for r in range(rows):\n                     for c in range(C + 1, cols):\n                         target_c = 2 * C - c\n                         if 0 <= target_c < cols:\n                             output_grid[r, target_c] = grid[r, c]\n\n    # --- 4. Return the result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16651,
    "candidates_token_count": 1360,
    "total_token_count": 18011,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.477627,
  "retries": 1
}