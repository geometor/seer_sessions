{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a unique horizontal or vertical line composed entirely of yellow \npixels (4) that acts as a separator. This separator line is uniquely characterized \nby being adjacent to a region composed entirely of white pixels (0). \nThe task is to reflect the content of the other adjacent region (the pattern \nregion) across this separator line into the white region, overwriting its \ninitial content. The separator line itself and the original pattern region \nremain unchanged.\n\"\"\"\n\ndef _find_yellow_lines(grid):\n    \"\"\"Finds complete horizontal and vertical lines of yellow pixels.\"\"\"\n    rows, cols = grid.shape\n    yellow = 4\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == yellow)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == yellow)]\n    return h_lines, v_lines\n\ndef _is_region_all_white(grid, orientation, index, side):\n    \"\"\"Checks if a specified region is entirely white (0).\"\"\"\n    rows, cols = grid.shape\n    white = 0\n    region = None\n\n    # Define the region slice based on orientation, index, and side\n    if orientation == 'horizontal':\n        if side == 'above':\n            if index == 0: return True # Region above row 0 is conceptually empty/white\n            region = grid[:index, :]\n        elif side == 'below':\n            if index >= rows - 1: return True # Region below last row is conceptually empty/white\n            region = grid[index+1:, :]\n    elif orientation == 'vertical':\n        if side == 'left':\n            if index == 0: return True # Region left of col 0 is conceptually empty/white\n            region = grid[:, :index]\n        elif side == 'right':\n            if index >= cols - 1: return True # Region right of last col is conceptually empty/white\n            region = grid[:, index+1:]\n\n    # If the region slice is invalid or empty, treat it as all white\n    if region is None or region.size == 0:\n        return True \n\n    # Check if all elements in the extracted region are white\n    return np.all(region == white)\n\ndef _identify_separator(grid, h_lines, v_lines):\n    \"\"\"\n    Identifies the unique separator line based on adjacency to an all-white region.\n    Returns:\n        tuple: (orientation, index, pattern_side) or None if not found.\n               pattern_side indicates the side *containing* the pattern.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check horizontal candidates first\n    for r in h_lines:\n        is_below_white = _is_region_all_white(grid, 'horizontal', r, 'below')\n        is_above_white = _is_region_all_white(grid, 'horizontal', r, 'above')\n\n        # Unique separator found if exactly one side is all white\n        if is_below_white and not is_above_white:\n            return ('horizontal', r, 'above') # Pattern is above, empty below\n        if is_above_white and not is_below_white:\n            return ('horizontal', r, 'below') # Pattern is below, empty above\n    \n    # If no horizontal separator found, check vertical candidates\n    for c in v_lines:\n        is_right_white = _is_region_all_white(grid, 'vertical', c, 'right')\n        is_left_white = _is_region_all_white(grid, 'vertical', c, 'left')\n\n        # Unique separator found if exactly one side is all white\n        if is_right_white and not is_left_white:\n            return ('vertical', c, 'left') # Pattern is left, empty right\n        if is_left_white and not is_right_white:\n             return ('vertical', c, 'right') # Pattern is right, empty left\n\n    return None # No unique separator found\n\ndef _reflect_pattern(grid, output_grid, separator_info):\n    \"\"\"Performs the reflection based on the identified separator.\"\"\"\n    orientation, index, pattern_side = separator_info\n    rows, cols = grid.shape\n\n    if orientation == 'horizontal':\n        R = index\n        if pattern_side == 'above':\n            # Iterate through source region (above line R)\n            for r_src in range(R):\n                for c_src in range(cols):\n                    # Calculate target coordinates (below line R)\n                    r_tgt = 2 * R - r_src\n                    # Check bounds and copy pixel\n                    if 0 <= r_tgt < rows:\n                        output_grid[r_tgt, c_src] = grid[r_src, c_src] \n        else: # pattern_side == 'below'\n            # Iterate through source region (below line R)\n            for r_src in range(R + 1, rows):\n                for c_src in range(cols):\n                    # Calculate target coordinates (above line R)\n                    r_tgt = 2 * R - r_src\n                    # Check bounds and copy pixel\n                    if 0 <= r_tgt < rows:\n                         output_grid[r_tgt, c_src] = grid[r_src, c_src]\n\n    elif orientation == 'vertical':\n        C = index\n        if pattern_side == 'left':\n            # Iterate through source region (left of line C)\n             for r_src in range(rows):\n                for c_src in range(C):\n                    # Calculate target coordinates (right of line C)\n                    c_tgt = 2 * C - c_src\n                    # Check bounds and copy pixel\n                    if 0 <= c_tgt < cols:\n                        output_grid[r_src, c_tgt] = grid[r_src, c_src]\n        else: # pattern_side == 'right'\n            # Iterate through source region (right of line C)\n            for r_src in range(rows):\n                 for c_src in range(C + 1, cols):\n                     # Calculate target coordinates (left of line C)\n                     c_tgt = 2 * C - c_src\n                     # Check bounds and copy pixel\n                     if 0 <= c_tgt < cols:\n                         output_grid[r_src, c_tgt] = grid[r_src, c_src]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by reflecting a pattern across a unique yellow \n    separator line identified by its adjacency to an all-white region.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert to numpy array for easier processing\n    grid = np.array(input_grid)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(grid)\n    \n    # 1. Find potential separator lines (all yellow rows/cols)\n    h_lines, v_lines = _find_yellow_lines(grid)\n\n    # 2. Identify the unique separator line and the side containing the pattern\n    separator_info = _identify_separator(grid, h_lines, v_lines)\n\n    # 3. Perform reflection if a valid separator was found\n    if separator_info:\n        _reflect_pattern(grid, output_grid, separator_info)\n\n    # 4. Convert the result back to list of lists format and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20017,
    "candidates_token_count": 1761,
    "total_token_count": 21778,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.466997,
  "retries": 1
}