
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Separator Identification:** Both examples feature a prominent, continuous line of yellow pixels (color 4). In `train_1`, this line is horizontal, located at row 9. In `train_2`, it's vertical, located at column 9. This yellow line acts as a separator, dividing the grid.
2.  **Region Definition:** The yellow line divides the grid into two main regions (excluding the line itself).
3.  **Content Asymmetry:** In the input grids, one region contains a pattern of various colored pixels against a white background, while the other region is entirely white (color 0).
4.  **Transformation - Copy/Reflection:** The transformation involves copying the contents of the patterned region into the white region. This effectively creates a reflection of the pattern across the yellow separator line.
5.  **Preservation:** The yellow separator line itself and the original patterned region remain unchanged in the output grid.
6.  **Orientation:** The orientation of the copy/reflection depends on the orientation of the yellow line (horizontal line leads to vertical reflection, vertical line leads to horizontal reflection).

**Facts**


```yaml
- task: Find and reflect a pattern across a yellow separator line.
- objects:
    - grid: The input 2D array of pixels.
    - separator_line: A continuous line (horizontal or vertical) of yellow pixels (color 4).
    - pattern_region: The area on one side of the separator_line containing non-white pixels.
    - empty_region: The area on the other side of the separator_line, initially containing only white pixels (color 0).
- properties:
    - separator_line:
        - color: yellow (4)
        - orientation: horizontal or vertical
        - location: specific row index (if horizontal) or column index (if vertical)
    - pattern_region: Contains the source pattern.
    - empty_region: Initially filled with the background color (white, 0).
- relationships:
    - separator_line: Divides the grid into pattern_region and empty_region.
    - pattern_region: Source for the transformation.
    - empty_region: Target area for the transformation.
- actions:
    - Locate the separator_line.
    - Determine its orientation and location.
    - Identify the pattern_region and the empty_region based on the separator_line.
    - Copy the pixel values from the pattern_region into the corresponding positions within the empty_region, mirroring across the separator_line.
    - Preserve the original pattern_region and the separator_line in the output.
```


**Natural Language Program**

1.  Scan the input grid to find a continuous, single-pixel-thick line composed entirely of yellow pixels (color 4). This line will be either horizontal or vertical.
2.  Determine the orientation (horizontal or vertical) and the index (row or column) of this yellow separator line.
3.  Identify the two regions created by this line. One region will contain various colored pixels (the "pattern region"), and the other will be filled with white pixels (the "empty region").
4.  Create the output grid as a copy of the input grid.
5.  If the separator line is horizontal at row `R`:
    *   Determine if the pattern region is above (rows 0 to `R-1`) or below (rows `R+1` to end) the line.
    *   If the pattern is above, copy the pixels from rows 0 to `R-1` into rows `R+1` to `2*R`.
    *   If the pattern is below, copy the pixels from rows `R+1` to end into rows 0 to `R-1`. *(Self-correction: The examples only show patterns above/left and empty below/right. Assume the copy always happens from the non-empty side to the empty side relative to the line)*.
    *   For each row `r` in the pattern region, and each column `c`, copy the pixel value `input[r][c]` to the corresponding mirrored position `output[R + (R - r)][c]` (if pattern above) or `output[R - (r - R)][c]` (if pattern below) - Simplified: copy `input[r][c]` to `output[2*R - r][c]`.
6.  If the separator line is vertical at column `C`:
    *   Determine if the pattern region is to the left (columns 0 to `C-1`) or right (columns `C+1` to end) of the line.
    *   Assume the pattern is on the left and the empty region is on the right based on the example.
    *   For each row `r` and each column `c` in the pattern region (columns 0 to `C-1`), copy the pixel value `input[r][c]` to the corresponding mirrored position `output[r][C + (C - c)]` - Simplified: copy `input[r][c]` to `output[r][2*C - c]`.
7.  Ensure the yellow separator line and the original pattern region remain unchanged in the output grid. The output grid now contains the original pattern, the separator line, and the reflected pattern in the previously empty region.
```python
import numpy as np

"""
Identify a continuous, single-pixel-thick line of yellow pixels (color 4) 
acting as a separator, which can be either horizontal or vertical. 
Determine the orientation and location (row or column index) of this line. 
The grid is divided into two regions by this line. One region contains a 
pattern (non-white pixels), and the other is initially empty (white pixels). 
Copy the pattern from its region into the empty region, reflecting it across 
the separator line. The original pattern and the separator line remain unchanged.
If the line is horizontal at row R, pixels from row r are copied to row 2*R - r.
If the line is vertical at column C, pixels from column c are copied to column 2*C - c.
The examples suggest the pattern is always above a horizontal line or to the 
left of a vertical line, and the reflection fills the area below or to the right, respectively.
"""

def transform(input_grid):
    """
    Transforms the input grid by reflecting the pattern across a yellow separator line.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed output grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    grid = np.array(input_grid)
    output_grid = np.copy(grid)
    rows, cols = grid.shape
    yellow = 4

    separator_orientation = None
    separator_index = -1

    # 1. Find horizontal separator
    # Iterate through rows to check if the entire row is yellow
    for r in range(rows):
        if np.all(grid[r, :] == yellow):
            # Check if it's a single line (not a block) - optional but good practice
            is_single_line = True
            if r > 0 and np.all(grid[r-1, :] == yellow):
                is_single_line = False
            if r < rows - 1 and np.all(grid[r+1, :] == yellow):
                is_single_line = False
            
            if is_single_line: # Found a valid horizontal separator
                separator_orientation = 'horizontal'
                separator_index = r
                break # Assume only one separator line in the grid

    # 2. Find vertical separator if horizontal not found
    if separator_orientation is None:
        # Iterate through columns to check if the entire column is yellow
        for c in range(cols):
            if np.all(grid[:, c] == yellow):
                 # Check if it's a single line (not a block) - optional
                is_single_line = True
                if c > 0 and np.all(grid[:, c-1] == yellow):
                    is_single_line = False
                if c < cols - 1 and np.all(grid[:, c+1] == yellow):
                    is_single_line = False

                if is_single_line: # Found a valid vertical separator
                    separator_orientation = 'vertical'
                    separator_index = c
                    break # Assume only one separator line

    # 3. Apply reflection based on the found separator
    if separator_orientation == 'horizontal':
        R = separator_index
        # Determine pattern region (assume above if non-zero pixels exist there)
        pattern_above = np.any(grid[:R, :] != 0) 

        if pattern_above:
            # Reflect pattern from above (rows 0 to R-1) to below (rows R+1 onwards)
            for r in range(R):
                for c in range(cols):
                    mirrored_r = 2 * R - r
                    # Ensure the mirrored row is within the grid bounds
                    if 0 <= mirrored_r < rows:
                        output_grid[mirrored_r, c] = grid[r, c]
        else: # Assume pattern is below
             # Reflect pattern from below (rows R+1 to end) to above (rows 0 to R-1)
             for r in range(R + 1, rows):
                 for c in range(cols):
                    mirrored_r = 2 * R - r
                    # Ensure the mirrored row is within the grid bounds
                    if 0 <= mirrored_r < rows:
                         output_grid[mirrored_r, c] = grid[r, c]


    elif separator_orientation == 'vertical':
        C = separator_index
        # Determine pattern region (assume left if non-zero pixels exist there)
        pattern_left = np.any(grid[:, :C] != 0)

        if pattern_left:
            # Reflect pattern from left (cols 0 to C-1) to right (cols C+1 onwards)
            for r in range(rows):
                for c in range(C):
                    mirrored_c = 2 * C - c
                    # Ensure the mirrored column is within the grid bounds
                    if 0 <= mirrored_c < cols:
                        output_grid[r, mirrored_c] = grid[r, c]
        else: # Assume pattern is right
             # Reflect pattern from right (cols C+1 to end) to left (cols 0 to C-1)
            for r in range(rows):
                for c in range(C + 1, cols):
                    mirrored_c = 2 * C - c
                     # Ensure the mirrored column is within the grid bounds
                    if 0 <= mirrored_c < cols:
                        output_grid[r, mirrored_c] = grid[r, c]


    # 4. Return the modified grid
    # Convert back to list of lists if necessary, depending on expected output format
    # For ARC tasks, numpy array is usually fine internally, but final output might need conversion
    return output_grid.tolist() # Convert back to list of lists format
```
```python
import numpy as np

"""
Identify a unique horizontal or vertical line composed entirely of yellow pixels (4) 
that acts as a separator. This separator line is characterized by having 
"foreground pixels" (defined as pixels that are neither white (0) nor yellow (4)) 
strictly on one side of it (either above/below for horizontal, or left/right 
for vertical). Reflect the pattern formed by these foreground pixels (along with 
any white or yellow pixels within the source region) across the separator line 
into the target region, overwriting the original content of the target region. 
The separator line itself remains unchanged.
"""

def has_foreground(region, foreground_colors):
    """
    Checks if a given grid region contains any foreground pixels.
    Foreground pixels are those not in the foreground_colors set.
    Args:
        region (np.ndarray): The region of the grid to check.
        foreground_colors (set): A set of colors considered background/separator.
    Returns:
        bool: True if foreground pixels are present, False otherwise.
    """
    if region.size == 0: # Handle empty regions (e.g., above row 0)
        return False
    # Check if any pixel in the region is NOT in the foreground_colors set
    return np.any(~np.isin(region, list(foreground_colors)))

def transform(input_grid):
    """
    Transforms the input grid by reflecting a pattern across a unique yellow separator line.

    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    grid = np.array(input_grid)
    output_grid = np.copy(grid)
    rows, cols = grid.shape
    yellow = 4
    white = 0
    background_separator_colors = {white, yellow}

    # --- 1. Find potential horizontal and vertical separators ---
    h_separator_indices = [r for r in range(rows) if np.all(grid[r, :] == yellow)]
    v_separator_indices = [c for c in range(cols) if np.all(grid[:, c] == yellow)]

    # --- 2. Identify the unique primary separator ---
    separator_info = None # Will store ('horizontal'/'vertical', index, 'above'/'below'/'left'/'right')

    # Check horizontal candidates
    for r in h_separator_indices:
        region_above = grid[:r, :]
        region_below = grid[r+1:, :]
        
        pattern_above = has_foreground(region_above, background_separator_colors)
        pattern_below = has_foreground(region_below, background_separator_colors)

        # If pattern exists exclusively on one side, this is the separator
        if pattern_above and not pattern_below:
            separator_info = ('horizontal', r, 'above')
            break
        if not pattern_above and pattern_below:
            separator_info = ('horizontal', r, 'below')
            break
    
    # If no horizontal separator found, check vertical candidates
    if separator_info is None:
        for c in v_separator_indices:
            region_left = grid[:, :c]
            region_right = grid[:, c+1:]

            pattern_left = has_foreground(region_left, background_separator_colors)
            pattern_right = has_foreground(region_right, background_separator_colors)

            # If pattern exists exclusively on one side, this is the separator
            if pattern_left and not pattern_right:
                separator_info = ('vertical', c, 'left')
                break
            if not pattern_left and pattern_right:
                 separator_info = ('vertical', c, 'right')
                 break

    # --- 3. Perform reflection if a valid separator was found ---
    if separator_info:
        orientation, index, pattern_side = separator_info

        if orientation == 'horizontal':
            R = index
            if pattern_side == 'above':
                # Reflect region above (0 to R-1) to region below (R+1 onwards)
                for r in range(R):
                    for c in range(cols):
                        target_r = 2 * R - r
                        if 0 <= target_r < rows:
                            output_grid[target_r, c] = grid[r, c]
            else: # pattern_side == 'below'
                # Reflect region below (R+1 to end) to region above (0 to R-1)
                 for r in range(R + 1, rows):
                    for c in range(cols):
                        target_r = 2 * R - r
                        if 0 <= target_r < rows:
                             output_grid[target_r, c] = grid[r, c]

        elif orientation == 'vertical':
            C = index
            if pattern_side == 'left':
                 # Reflect region left (0 to C-1) to region right (C+1 onwards)
                 for r in range(rows):
                    for c in range(C):
                        target_c = 2 * C - c
                        if 0 <= target_c < cols:
                            output_grid[r, target_c] = grid[r, c]
            else: # pattern_side == 'right'
                 # Reflect region right (C+1 to end) to region left (0 to C-1)
                for r in range(rows):
                     for c in range(C + 1, cols):
                         target_c = 2 * C - c
                         if 0 <= target_c < cols:
                             output_grid[r, target_c] = grid[r, c]

    # --- 4. Return the result ---
    return output_grid.tolist()
```
```python
import numpy as np

"""
Identifies a unique horizontal or vertical line composed entirely of yellow 
pixels (4) that acts as a separator. This separator line is uniquely characterized 
by being adjacent to a region composed entirely of white pixels (0). 
The task is to reflect the content of the other adjacent region (the pattern 
region) across this separator line into the white region, overwriting its 
initial content. The separator line itself and the original pattern region 
remain unchanged.
"""

def _find_yellow_lines(grid):
    """Finds complete horizontal and vertical lines of yellow pixels."""
    rows, cols = grid.shape
    yellow = 4
    h_lines = [r for r in range(rows) if np.all(grid[r, :] == yellow)]
    v_lines = [c for c in range(cols) if np.all(grid[:, c] == yellow)]
    return h_lines, v_lines

def _is_region_all_white(grid, orientation, index, side):
    """Checks if a specified region is entirely white (0)."""
    rows, cols = grid.shape
    white = 0
    region = None

    if orientation == 'horizontal':
        if side == 'above':
            if index == 0: return True # Region above row 0 is considered empty/white
            region = grid[:index, :]
        elif side == 'below':
            if index == rows - 1: return True # Region below last row is considered empty/white
            region = grid[index+1:, :]
    elif orientation == 'vertical':
        if side == 'left':
            if index == 0: return True # Region left of col 0 is considered empty/white
            region = grid[:, :index]
        elif side == 'right':
            if index == cols - 1: return True # Region right of last col is considered empty/white
            region = grid[:, index+1:]

    if region is None or region.size == 0:
        return True # Empty regions are considered all white

    return np.all(region == white)

def transform(input_grid):
    """
    Transforms the input grid by reflecting a pattern across a unique yellow 
    separator line identified by its adjacency to an all-white region.

    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    grid = np.array(input_grid)
    output_grid = np.copy(grid)
    rows, cols = grid.shape
    white = 0

    # 1. Find potential separator lines
    h_lines, v_lines = _find_yellow_lines(grid)

    separator_info = None # Stores ('horizontal'/'vertical', index, 'pattern_side')

    # 2. Identify the unique separator by checking for adjacent all-white regions
    # Check horizontal candidates first
    for r in h_lines:
        is_below_white = _is_region_all_white(grid, 'horizontal', r, 'below')
        is_above_white = _is_region_all_white(grid, 'horizontal', r, 'above')

        if is_below_white and not is_above_white:
            separator_info = ('horizontal', r, 'above') # Pattern is above
            break
        if is_above_white and not is_below_white:
            separator_info = ('horizontal', r, 'below') # Pattern is below
            break
    
    # If no horizontal separator found, check vertical candidates
    if separator_info is None:
        for c in v_lines:
            is_right_white = _is_region_all_white(grid, 'vertical', c, 'right')
            is_left_white = _is_region_all_white(grid, 'vertical', c, 'left')

            if is_right_white and not is_left_white:
                separator_info = ('vertical', c, 'left') # Pattern is left
                break
            if is_left_white and not is_right_white:
                 separator_info = ('vertical', c, 'right') # Pattern is right
                 break

    # 3. Perform reflection if a valid separator was found
    if separator_info:
        orientation, index, pattern_side = separator_info

        if orientation == 'horizontal':
            R = index
            if pattern_side == 'above':
                # Reflect region above (0 to R-1) into region below (R+1 onwards)
                for r_src in range(R):
                    for c_src in range(cols):
                        r_tgt = 2 * R - r_src
                        if 0 <= r_tgt < rows:
                            # Copy pixel from original grid to output grid
                            output_grid[r_tgt, c_src] = grid[r_src, c_src] 
            else: # pattern_side == 'below'
                # Reflect region below (R+1 to end) into region above (0 to R-1)
                 for r_src in range(R + 1, rows):
                    for c_src in range(cols):
                        r_tgt = 2 * R - r_src
                        if 0 <= r_tgt < rows:
                             # Copy pixel from original grid to output grid
                             output_grid[r_tgt, c_src] = grid[r_src, c_src]

        elif orientation == 'vertical':
            C = index
            if pattern_side == 'left':
                 # Reflect region left (0 to C-1) into region right (C+1 onwards)
                 for r_src in range(rows):
                    for c_src in range(C):
                        c_tgt = 2 * C - c_src
                        if 0 <= c_tgt < cols:
                            # Copy pixel from original grid to output grid
                            output_grid[r_src, c_tgt] = grid[r_src, c_src]
            else: # pattern_side == 'right'
                 # Reflect region right (C+1 to end) into region left (0 to C-1)
                for r_src in range(rows):
                     for c_src in range(C + 1, cols):
                         c_tgt = 2 * C - c_src
                         if 0 <= c_tgt < cols:
                             # Copy pixel from original grid to output grid
                             output_grid[r_src, c_tgt] = grid[r_src, c_src]

    # 4. Return the result as a list of lists
    return output_grid.tolist()
```
