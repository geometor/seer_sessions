{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a unique horizontal or vertical line composed entirely of yellow \npixels (4) that acts as a separator. This separator line is uniquely characterized \nby being adjacent to a region composed entirely of white pixels (0). \nThe task is to reflect the content of the other adjacent region (the pattern \nregion) across this separator line into the white region, overwriting its \ninitial content. The separator line itself and the original pattern region \nremain unchanged.\n\"\"\"\n\ndef _find_yellow_lines(grid):\n    \"\"\"Finds complete horizontal and vertical lines of yellow pixels.\"\"\"\n    rows, cols = grid.shape\n    yellow = 4\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == yellow)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == yellow)]\n    return h_lines, v_lines\n\ndef _is_region_all_white(grid, orientation, index, side):\n    \"\"\"Checks if a specified region is entirely white (0).\"\"\"\n    rows, cols = grid.shape\n    white = 0\n    region = None\n\n    if orientation == 'horizontal':\n        if side == 'above':\n            if index == 0: return True # Region above row 0 is considered empty/white\n            region = grid[:index, :]\n        elif side == 'below':\n            if index == rows - 1: return True # Region below last row is considered empty/white\n            region = grid[index+1:, :]\n    elif orientation == 'vertical':\n        if side == 'left':\n            if index == 0: return True # Region left of col 0 is considered empty/white\n            region = grid[:, :index]\n        elif side == 'right':\n            if index == cols - 1: return True # Region right of last col is considered empty/white\n            region = grid[:, index+1:]\n\n    if region is None or region.size == 0:\n        return True # Empty regions are considered all white\n\n    return np.all(region == white)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by reflecting a pattern across a unique yellow \n    separator line identified by its adjacency to an all-white region.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n    white = 0\n\n    # 1. Find potential separator lines\n    h_lines, v_lines = _find_yellow_lines(grid)\n\n    separator_info = None # Stores ('horizontal'/'vertical', index, 'pattern_side')\n\n    # 2. Identify the unique separator by checking for adjacent all-white regions\n    # Check horizontal candidates first\n    for r in h_lines:\n        is_below_white = _is_region_all_white(grid, 'horizontal', r, 'below')\n        is_above_white = _is_region_all_white(grid, 'horizontal', r, 'above')\n\n        if is_below_white and not is_above_white:\n            separator_info = ('horizontal', r, 'above') # Pattern is above\n            break\n        if is_above_white and not is_below_white:\n            separator_info = ('horizontal', r, 'below') # Pattern is below\n            break\n    \n    # If no horizontal separator found, check vertical candidates\n    if separator_info is None:\n        for c in v_lines:\n            is_right_white = _is_region_all_white(grid, 'vertical', c, 'right')\n            is_left_white = _is_region_all_white(grid, 'vertical', c, 'left')\n\n            if is_right_white and not is_left_white:\n                separator_info = ('vertical', c, 'left') # Pattern is left\n                break\n            if is_left_white and not is_right_white:\n                 separator_info = ('vertical', c, 'right') # Pattern is right\n                 break\n\n    # 3. Perform reflection if a valid separator was found\n    if separator_info:\n        orientation, index, pattern_side = separator_info\n\n        if orientation == 'horizontal':\n            R = index\n            if pattern_side == 'above':\n                # Reflect region above (0 to R-1) into region below (R+1 onwards)\n                for r_src in range(R):\n                    for c_src in range(cols):\n                        r_tgt = 2 * R - r_src\n                        if 0 <= r_tgt < rows:\n                            # Copy pixel from original grid to output grid\n                            output_grid[r_tgt, c_src] = grid[r_src, c_src] \n            else: # pattern_side == 'below'\n                # Reflect region below (R+1 to end) into region above (0 to R-1)\n                 for r_src in range(R + 1, rows):\n                    for c_src in range(cols):\n                        r_tgt = 2 * R - r_src\n                        if 0 <= r_tgt < rows:\n                             # Copy pixel from original grid to output grid\n                             output_grid[r_tgt, c_src] = grid[r_src, c_src]\n\n        elif orientation == 'vertical':\n            C = index\n            if pattern_side == 'left':\n                 # Reflect region left (0 to C-1) into region right (C+1 onwards)\n                 for r_src in range(rows):\n                    for c_src in range(C):\n                        c_tgt = 2 * C - c_src\n                        if 0 <= c_tgt < cols:\n                            # Copy pixel from original grid to output grid\n                            output_grid[r_src, c_tgt] = grid[r_src, c_src]\n            else: # pattern_side == 'right'\n                 # Reflect region right (C+1 to end) into region left (0 to C-1)\n                for r_src in range(rows):\n                     for c_src in range(C + 1, cols):\n                         c_tgt = 2 * C - c_src\n                         if 0 <= c_tgt < cols:\n                             # Copy pixel from original grid to output grid\n                             output_grid[r_src, c_tgt] = grid[r_src, c_src]\n\n    # 4. Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20479,
    "candidates_token_count": 1552,
    "total_token_count": 22031,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.229301,
  "retries": 1
}