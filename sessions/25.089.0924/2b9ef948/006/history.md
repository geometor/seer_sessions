
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 7 4 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 4 7 7 7 7 7 7
4 7 7 7 7 7 7 7 7 7 7 7 4 7 7 7 7 7 7 7
7 4 7 7 7 7 7 7 7 7 7 4 7 7 7 7 7 7 7 7
7 7 4 7 7 7 7 7 7 7 4 7 7 7 7 7 7 7 7 7
7 7 7 4 7 7 7 7 7 4 7 7 7 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 4 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 4 4 4 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 4 7 4 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 4 4 4 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 4 7 7 7 7 7 7 7 7 7 7 7
7 7 7 4 7 7 7 7 7 4 7 7 7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 3 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3
3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3
3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 4 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 4 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 4 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 4 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 4 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 4 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 4 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3
3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3
3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3
3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 8 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8
8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8
8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 4 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 4 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8
8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8
4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
```

Okay, let's break down the task based on the provided examples.

**Perception:**

1.  **Input Grid Structure:** The input grids are generally sparse, containing mostly the white background (0). There are consistently two distinct visual structures present.
2.  **Structure 1 (Yellow Square):** A 3x3 square pattern is always present. This square consists of 8 yellow (4) pixels forming a border around a single central pixel. The central pixel's color varies between examples (orange (7) in train\_1, green (3) in train\_2, azure (8) in train\_3) but is never yellow (4) or white (0).
3.  **Structure 2 (Gray Shape):** A shape composed primarily of gray (5) pixels exists elsewhere in the grid. This shape varies (L-shape, line) and often has one adjacent or nearby pixel whose color matches the central pixel of the yellow square. There might also be other isolated pixels (like the yellow (4) near the gray line in train\_3).
4.  **Output Grid Structure:** The output grid has the same dimensions as the input. It is almost entirely filled with a single color. This fill color corresponds exactly to the color of the central pixel found within the 3x3 yellow square in the input.
5.  **Transformation:**
    *   The primary transformation involves identifying the central color of the 3x3 yellow square and using it as a background fill for the output.
    *   The 8 yellow (4) pixels that formed the border of the square in the input are preserved in their original locations in the output, overlaying the background fill.
    *   All other elements from the input grid, including the gray (5) shapes, the associated colored pixel near the gray shape, and any other isolated pixels (even other yellow ones, like in train\_3), are completely removed or replaced by the background fill color in the output.

**Facts (YAML):**


```yaml
Input_Elements:
  - Type: Background
    Color: white (0)
  - Type: Pattern
    Name: YellowSquare
    Shape: 3x3
    Composition:
      - Pixels: 8
        Color: yellow (4)
        Arrangement: Border
      - Pixel: 1
        Color: Variable (non-yellow, non-white)
        Arrangement: Center
    Present_In_Examples: [train_1, train_2, train_3]
  - Type: Pattern
    Name: GrayShape
    Shape: Variable (L-shape, line)
    Composition:
      - Pixels: Multiple
        Color: gray (5)
      - Pixel: 1 (Optional/Associated)
        Color: Matches YellowSquare center color
        Arrangement: Adjacent/Nearby
    Present_In_Examples: [train_1, train_2, train_3]
  - Type: Pixel (Occasional)
    Color: Variable (e.g., yellow (4) in train_3)
    Location: Separate from YellowSquare

Output_Elements:
  - Type: Background
    Color: Corresponds to the central color of the input YellowSquare
    Extent: Full grid dimensions
  - Type: Pattern (Overlay)
    Name: YellowBorder
    Shape: 3x3 (implicit, from preserved pixels)
    Composition:
      - Pixels: 8
        Color: yellow (4)
    Location: Same coordinates as the yellow pixels of the input YellowSquare

Transformation_Actions:
  - Action: Identify
    Target: YellowSquare pattern in input
  - Action: Extract
    Source: Center pixel of YellowSquare
    Attribute: Color (Result: BackgroundFillColor)
  - Action: Create
    Object: Output grid
    Properties: Same dimensions as input
  - Action: Fill
    Target: Output grid
    Color: BackgroundFillColor
  - Action: Preserve/Overlay
    Source: 8 yellow (4) border pixels of input YellowSquare
    Target: Corresponding locations in output grid
  - Action: Discard/Ignore
    Target: All other input pixels (gray shape, associated pixel, background, other isolated pixels)

Relationships:
  - The output background color is determined solely by the central pixel color of the input YellowSquare.
  - The positions of the 8 yellow pixels from the input YellowSquare are maintained in the output.
  - The GrayShape and its associated elements appear irrelevant to the output generation, except perhaps as distractors or confirming the uniqueness of the YellowSquare pattern.
```


**Natural Language Program:**

1.  Initialize the output grid with the same dimensions as the input grid.
2.  Scan the input grid to locate a 3x3 pattern composed of 8 yellow (4) pixels surrounding a single, non-yellow, non-white central pixel.
3.  Identify the color of this central pixel; this will be the `background_color`.
4.  Identify the coordinates of the 8 yellow (4) pixels forming the border of this 3x3 pattern; store these as `preserved_yellow_coordinates`.
5.  Fill the entire output grid with the `background_color`.
6.  Iterate through the `preserved_yellow_coordinates`. For each coordinate (row, column) in the list, set the pixel at (row, column) in the output grid to yellow (4).
7.  Return the completed output grid.
```python
import numpy as np

"""
Transformation Rule:
1. Locate a 3x3 pattern in the input grid consisting of 8 yellow (4) pixels forming a border around a single, non-yellow, non-white central pixel.
2. Determine the color of this central pixel. This color becomes the background fill color for the output grid.
3. Initialize the output grid with the same dimensions as the input grid, completely filled with the determined background color.
4. Identify the coordinates of the 8 yellow (4) pixels that formed the border in the input grid's 3x3 pattern.
5. Set the pixels at these specific coordinates in the output grid back to yellow (4), overlaying the background fill.
6. All other elements from the input grid are ignored.
"""

def find_yellow_square(grid):
    """
    Scans the grid to find the 3x3 yellow square pattern.

    Args:
        grid (np.array): The input grid.

    Returns:
        tuple: (top_left_row, top_left_col, center_color) if found,
               otherwise None.
    """
    rows, cols = grid.shape
    for r in range(rows - 2):
        for c in range(cols - 2):
            # Extract the 3x3 subgrid
            subgrid = grid[r:r+3, c:c+3]

            # Check center pixel color (must not be yellow or white)
            center_color = subgrid[1, 1]
            if center_color == 4 or center_color == 0:
                continue

            # Check if border pixels are yellow (4)
            is_yellow_border = True
            for i in range(3):
                for j in range(3):
                    if i == 1 and j == 1: # Skip center
                        continue
                    if subgrid[i, j] != 4:
                        is_yellow_border = False
                        break
                if not is_yellow_border:
                    break

            if is_yellow_border:
                # Pattern found
                return r, c, center_color
    return None # Pattern not found

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Find the characteristic 3x3 yellow square
    result = find_yellow_square(input_grid)

    if result is None:
        # Should not happen based on examples, but handle defensively
        # Return a copy or raise an error? Let's return a copy for now.
        print("Warning: Yellow square pattern not found.")
        return np.copy(input_grid)

    top_r, top_c, background_color = result

    # Initialize the output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # Restore the 8 yellow border pixels from the input pattern
    # Define the relative coordinates of the border pixels within the 3x3 square
    border_relative_coords = [
        (0, 0), (0, 1), (0, 2),
        (1, 0),         (1, 2),
        (2, 0), (2, 1), (2, 2)
    ]

    # Set the corresponding pixels in the output grid to yellow
    for dr, dc in border_relative_coords:
        output_grid[top_r + dr, top_c + dc] = 4 # Yellow color

    return output_grid
```
```python
import numpy as np

"""
Transformation Rule:
1. Locate a 3x3 pattern in the input grid consisting of 8 yellow (4) pixels forming a border around a single, non-yellow, non-white central pixel.
2. Determine the color of this central pixel. This color becomes the background fill color for the output grid.
3. Identify the coordinates of *all* yellow (4) pixels present anywhere in the input grid.
4. Initialize the output grid with the same dimensions as the input grid, completely filled with the determined background color.
5. Iterate through the coordinates of all identified yellow pixels from the input. Set the pixels at these specific coordinates in the output grid back to yellow (4), overlaying the background fill.
6. All other non-yellow elements from the input grid are ignored.
"""

def find_yellow_square_center_color(grid):
    """
    Scans the grid to find the 3x3 yellow square pattern and return its center color.

    Args:
        grid (np.array): The input grid.

    Returns:
        int: The color of the center pixel if the pattern is found,
             otherwise None.
    """
    rows, cols = grid.shape
    for r in range(rows - 2):
        for c in range(cols - 2):
            # Extract the 3x3 subgrid
            subgrid = grid[r:r+3, c:c+3]

            # Check center pixel color (must not be yellow or white)
            center_color = subgrid[1, 1]
            if center_color == 4 or center_color == 0:
                continue

            # Check if border pixels are yellow (4)
            is_yellow_border = True
            for i in range(3):
                for j in range(3):
                    if i == 1 and j == 1: # Skip center
                        continue
                    if subgrid[i, j] != 4:
                        is_yellow_border = False
                        break
                if not is_yellow_border:
                    break

            if is_yellow_border:
                # Pattern found
                return center_color
    return None # Pattern not found

def find_all_pixels_of_color(grid, color):
    """
    Finds all coordinates of pixels with a specific color.

    Args:
        grid (np.array): The input grid.
        color (int): The color to find.

    Returns:
        list: A list of (row, col) tuples for pixels matching the color.
    """
    coords = np.where(grid == color)
    return list(zip(coords[0], coords[1]))


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # 1 & 2: Find the 3x3 square and determine the background color
    background_color = find_yellow_square_center_color(input_grid)

    if background_color is None:
        # Handle cases where the pattern isn't found (shouldn't occur based on examples)
        print("Warning: Characteristic 3x3 yellow square pattern not found.")
        # Return a default or copy? Let's return a copy.
        return np.copy(input_grid)

    # 3: Identify the coordinates of all yellow pixels in the input
    yellow_coords = find_all_pixels_of_color(input_grid, 4) # 4 is yellow

    # 4: Initialize the output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # 5: Overlay all original yellow pixels onto the output grid
    for r, c in yellow_coords:
        output_grid[r, c] = 4 # Set to yellow

    # 6: Implicitly done by initializing with background and only overlaying yellow.
    return output_grid
```
```python
import numpy as np

"""
Transformation Rule:
1. Identify the background color: Scan the input grid for a unique 3x3 pattern 
   consisting of 8 yellow (4) border pixels surrounding a single non-yellow, 
   non-white central pixel. The color of this central pixel determines the 
   background color for the output grid.
2. Identify the marker pixel: Find the coordinates of all yellow (4) pixels 
   in the input grid. One of these yellow pixels will not be part of the 
   border of the 3x3 square identified in step 1. This is the 'marker pixel'.
3. Initialize the output grid: Create a new grid with the same dimensions as 
   the input grid, completely filled with the background color found in step 1.
4. Draw diagonals: Determine the two diagonal lines (slope +1 and slope -1) 
   that pass through the marker pixel identified in step 2. 
5. Color diagonals: Set the color of all pixels lying on these two diagonals 
   in the output grid to yellow (4).
6. Return the final output grid. The original 3x3 square's location (beyond 
   determining the background color) and all other input patterns (like gray shapes) 
   are ignored in the final output construction.
"""

def find_yellow_square_details(grid):
    """
    Scans the grid to find the 3x3 yellow square pattern.

    Args:
        grid (np.array): The input grid.

    Returns:
        tuple: (top_left_row, top_left_col, center_color) if found,
               otherwise None. Returns coordinates of the top-left corner
               of the 3x3 square and the color of the center pixel.
    """
    rows, cols = grid.shape
    for r in range(rows - 2):
        for c in range(cols - 2):
            # Extract the 3x3 subgrid
            subgrid = grid[r:r+3, c:c+3]

            # Check center pixel color (must not be yellow (4) or white (0))
            center_color = subgrid[1, 1]
            if center_color == 4 or center_color == 0:
                continue

            # Check if border pixels are yellow (4)
            is_yellow_border = True
            for i in range(3):
                for j in range(3):
                    if i == 1 and j == 1: # Skip center
                        continue
                    if subgrid[i, j] != 4:
                        is_yellow_border = False
                        break
                if not is_yellow_border:
                    break

            if is_yellow_border:
                # Pattern found
                return r, c, center_color
    return None # Pattern not found

def find_all_pixels_of_color(grid, color):
    """
    Finds all coordinates of pixels with a specific color.

    Args:
        grid (np.array): The input grid.
        color (int): The color to find.

    Returns:
        list: A list of (row, col) tuples for pixels matching the color.
    """
    coords = np.where(grid == color)
    return list(zip(coords[0], coords[1]))

def find_marker_pixel(all_yellow_coords, square_r, square_c):
    """
    Identifies the marker yellow pixel (the one not part of the square border).

    Args:
        all_yellow_coords (list): List of (r, c) tuples for all yellow pixels.
        square_r (int): Top row index of the 3x3 square.
        square_c (int): Left column index of the 3x3 square.

    Returns:
        tuple: (row, col) of the marker pixel, or None if not found.
    """
    for r, c in all_yellow_coords:
        # Check if the coordinate is outside the 3x3 square's bounds
        is_outside_square = (
            r < square_r or r >= square_r + 3 or
            c < square_c or c >= square_c + 3
        )
        # Check if it's not the center pixel if it were inside (though the center isn't yellow)
        # This check is redundant if the square finding is correct, but safe.
        is_not_center = not (r == square_r + 1 and c == square_c + 1)

        if is_outside_square and is_not_center:
             # This must be the marker pixel, assuming only one exists outside the border
             # Or more accurately: it's a yellow pixel *not* belonging to the 8 border cells
            is_border = False
            for i in range(3):
                for j in range(3):
                    if i == 1 and j == 1: continue # skip center
                    if r == square_r + i and c == square_c + j:
                        is_border = True
                        break
                if is_border: break
            
            if not is_border: # If it wasn't any of the 8 border cells
                 return r, c
                 
    # Fallback / Error case: Maybe there are multiple yellow pixels outside?
    # Or only the border yellow pixels exist? Let's refine the condition.
    # We need the yellow pixel that is NOT one of the 8 border pixels.
    border_coords = set()
    for i in range(3):
        for j in range(3):
            if i == 1 and j == 1: continue
            border_coords.add((square_r + i, square_c + j))
            
    for r, c in all_yellow_coords:
        if (r, c) not in border_coords:
            return r, c
            
    return None # Should not happen based on examples


def transform(input_grid):
    """
    Applies the transformation based on background color from a 3x3 square
    and diagonals drawn from a separate marker yellow pixel.
    """
    # 1. Find the 3x3 square to get background color and its location
    square_details = find_yellow_square_details(input_grid)
    if square_details is None:
        print("Error: Characteristic 3x3 yellow square pattern not found.")
        # Return a copy or raise error based on expected behavior
        return np.copy(input_grid) 
    square_r, square_c, background_color = square_details

    # 2. Find all yellow pixels and identify the marker pixel
    all_yellow_coords = find_all_pixels_of_color(input_grid, 4) # 4 is yellow
    marker_coord = find_marker_pixel(all_yellow_coords, square_r, square_c)

    if marker_coord is None:
        print("Error: Marker yellow pixel not found.")
        # Return a copy or raise error
        return np.copy(input_grid)
    marker_row, marker_col = marker_coord

    # 3. Initialize the output grid
    output_grid = np.full_like(input_grid, background_color)
    rows, cols = output_grid.shape

    # 4. Determine diagonal invariants
    diag1_invariant = marker_row - marker_col # y = x + k => y - x = k
    diag2_invariant = marker_row + marker_col # y = -x + k => y + x = k

    # 5. Draw diagonals by coloring pixels yellow
    for r in range(rows):
        for c in range(cols):
            if (r - c == diag1_invariant) or (r + c == diag2_invariant):
                output_grid[r, c] = 4 # Yellow color

    # 6. Return the final grid
    return output_grid
```
