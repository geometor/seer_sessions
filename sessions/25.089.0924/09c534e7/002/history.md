
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 1 3 1 1 0 0 0 0 0 0 0 0 1 1 4 1 0 0
0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 0
0 0 1 1 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0
0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 0 0
0 0 1 1 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 0
0 0 0 0 0 1 1 2 1 1 1 1 1 1 0 0 0 0 0 0
1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 1 3 3 1 0 0 0 0 0 0 0 0 1 4 4 1 0 0
0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 4 4 1 0 0
0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 0
0 0 1 3 3 3 3 1 0 1 1 1 0 0 0 1 1 1 0 0
0 0 1 3 3 3 3 1 1 1 3 1 0 0 0 1 4 1 0 0
0 0 1 1 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 0
0 0 0 0 0 1 2 2 1 1 1 1 2 1 0 0 0 0 0 0
1 1 1 0 0 1 2 2 1 0 0 1 1 1 0 0 0 0 0 0
1 2 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
1 2 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 2 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1
0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1
0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 1 0 1 1 1 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 1 1 1 1 1 0 0 0 0
0 0 0 1 0 0 0 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 1 1 1 0 0 0 0
0 0 1 1 1 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 3 1 1 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 2 2 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 2 2 2 1 0 0 0 0 0 1 2 2 1 0 0 0 0
0 0 0 0 0 1 2 1 1 1 1 1 1 2 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 2 2 2 1 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 2 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1
0 0 0 0 0 1 1 1 0 0 1 2 2 2 2 2 2 2 1 1 1 1 2 2 1 1 1 1 2 1
0 0 0 0 0 1 2 1 1 1 1 2 2 2 2 2 2 2 1 0 0 1 2 2 1 0 0 1 1 1
0 0 0 0 0 1 1 1 0 0 1 2 2 2 2 2 2 2 1 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 0 1 3 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 3 1 0 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 0 0 1 0 0 0 0 1 2 2 1 0 1 1 1 0 1 1 1 0 0 0 0
0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 2 1 0 1 3 1 1 1 3 1 0 0 0 0
0 0 0 1 0 0 0 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 1 1 1 0 0 0 0
0 0 1 1 1 0 0 1 3 3 3 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 1 3 1 1 1 1 3 3 3 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 1 1 1 0 0 1 3 3 3 1 0 0 1 1 1 1 1 1 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 1 3 3 3 1 1 1 1 3 3 3 3 1 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 3 3 3 3 1 1 1 1 1 3 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 3 3 3 3 1 0 0 0 1 3 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 0 0
0 0 0 1 4 1 1 1 1 1 1 1 1 0 0 1 1 1
0 0 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1
0 0 0 0 0 1 0 0 0 1 1 1 1 0 0 1 1 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 1 1 1 0 1 1 1 0 0
0 0 0 1 1 1 1 0 0 1 3 1 1 1 1 1 0 0
0 0 0 1 1 1 1 0 0 1 1 1 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 1 0 0
0 0 1 1 1 1 0 0 1 1 1 1 0 0 1 0 0 0
0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0
0 0 1 1 6 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 0 0
0 0 0 1 4 4 1 1 1 1 4 4 1 0 0 1 1 1
0 0 0 1 1 1 1 0 0 1 4 4 1 1 1 1 4 1
0 0 0 0 0 1 0 0 0 1 1 1 1 0 0 1 1 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 1 1 1 0 1 1 1 0 0
0 0 0 1 4 4 1 0 0 1 3 1 1 1 3 1 0 0
0 0 0 1 1 1 1 0 0 1 1 1 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 6 1 0 0
0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 1 0 0
0 0 1 1 1 1 0 0 1 6 6 1 0 0 1 0 0 0
0 0 1 6 6 1 0 0 1 6 6 1 0 1 1 1 0 0
0 0 1 6 6 1 1 1 1 6 6 1 1 1 6 1 0 0
0 0 1 1 1 1 0 0 1 6 6 1 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0
```

**Perception of the Task**

1.  **Input/Output Structure:** Both input and output are grids of colored pixels (represented by integers 0-9).
2.  **Key Objects:** The primary objects are contiguous shapes made of blue (1) pixels, often enclosing other colored pixels. The background is white (0).
3.  **Internal Pixels:** Within some blue shapes, there are single pixels of other colors (green-3, yellow-4, red-2, magenta-6 in the examples). These act as "seed" pixels.
4.  **Transformation:** The core transformation is a "fill" operation originating from these seed pixels.
5.  **Fill Behavior:**
    *   The fill uses the color of the seed pixel.
    *   It spreads outwards from the seed pixel to adjacent (up, down, left, right) blue (1) pixels.
    *   The fill is contained entirely within the boundary of the original blue shape that enclosed the seed. It does not color the white background or pixels outside the original blue area.
    *   Blue shapes that do not contain a seed pixel remain unchanged.
    *   The original seed pixel retains its color and position.
    *   The blue pixels forming the outermost boundary of the shape generally remain blue, unless the fill reaches them from the inside. Essentially, the fill replaces the *internal* blue area connected to the seed.

**YAML Facts**


```yaml
task_description: Fill enclosed blue areas based on an internal seed color.

elements:
  - element: grid
    description: A 2D array of pixels representing colors 0-9.
  - element: background
    properties:
      color: white (0)
      role: Surrounds shapes, constrains fill.
  - element: shape
    properties:
      color: blue (1)
      form: Contiguous area of pixels.
      role: Defines a boundary or container. May enclose a seed pixel.
  - element: seed_pixel
    properties:
      color: non-blue (1) and non-white (0) (e.g., red-2, green-3, yellow-4, magenta-6)
      location: Situated within a blue shape.
      quantity: Appears to be at most one per blue shape in examples.
      role: Initiates and determines the color of the fill operation.
  - element: filled_area
    properties:
      color: Same as the seed_pixel color.
      location: Replaces the blue pixels within the shape that are reachable from the seed_pixel.
      derivation: Result of the fill action.

actions:
  - action: identify_shapes
    description: Locate all contiguous blue (1) shapes in the input grid.
  - action: find_seed
    description: For each blue shape, check if it contains exactly one non-blue, non-white pixel. If found, identify its color and location.
  - action: flood_fill
    description: For shapes containing a seed, perform a fill operation.
    details:
      start_point: Location of the seed_pixel.
      fill_color: Color of the seed_pixel.
      target_color: blue (1).
      boundary: Pixels that are not blue (1) in the original input grid act as boundaries.
      connectivity: 4-directional adjacency (up, down, left, right).
      effect: Changes the color of reachable blue (1) pixels within the shape to the fill_color.

relationships:
  - relationship: containment
    subject: seed_pixel
    object: shape (blue)
    description: A seed pixel must be located inside a blue shape.
  - relationship: constraint
    subject: shape (blue boundary) / background (white)
    object: flood_fill action
    description: The fill action is constrained by the boundaries of the original blue shape and does not extend into the white background or other shapes.
  - relationship: determination
    subject: seed_pixel color
    object: filled_area color
    description: The color of the seed pixel determines the color used for the fill.
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Iterate through each pixel `(r, c)` of the input grid.
3.  If the pixel `input[r, c]` has a color `C` that is *not* blue (1) and *not* white (0), consider it a potential seed pixel.
4.  Verify if this pixel `(r, c)` is truly a seed within a blue shape (this check is implicitly handled by the flood fill's behavior; if it's not adjacent to any blue pixels, the fill won't start).
5.  If a potential seed pixel `(r, c)` with color `C` is found:
    a.  Initialize a queue for the flood fill process and add the starting coordinate `(r, c)`.
    b.  Initialize a set or auxiliary grid to keep track of visited coordinates during *this specific fill operation* to prevent infinite loops, adding `(r, c)` to it.
    c.  While the queue is not empty:
        i.  Dequeue a coordinate `(curr_r, curr_c)`.
        ii. Check its 4-directional neighbors `(nr, nc)` (up, down, left, right).
        iii. For each neighbor `(nr, nc)`:
            *   Ensure `(nr, nc)` is within the grid boundaries.
            *   Check if the neighbor pixel in the *original input grid* `input[nr, nc]` is blue (1).
            *   Check if the neighbor coordinate `(nr, nc)` has *not* been visited *during this specific fill operation*.
            *   If all conditions are met (in bounds, originally blue, not visited):
                *   Change the color of the corresponding pixel in the *output grid* to the seed color `C`: `output[nr, nc] = C`.
                *
```python
import numpy as np
from collections import deque

"""
Transformation Rule:

1. Identify 'seed' pixels in the input grid. A seed pixel is any pixel that is neither blue (1) nor white (0).
2. For each seed pixel found at location (r, c) with color C:
3. Perform a flood fill operation starting from the blue (1) neighbors of the seed pixel.
4. The flood fill uses the seed's color C.
5. The fill spreads to adjacent (up, down, left, right) blue (1) pixels within the same contiguous blue region as the initial blue neighbors.
6. The fill stops at boundaries defined by non-blue pixels in the original input grid.
7. The original seed pixel retains its color. Pixels outside the filled blue regions remain unchanged.
8. The process is repeated for all seed pixels found in the input grid. The output grid reflects all completed fill operations.
"""

def transform(input_grid):
    """
    Applies a flood fill transformation to the input grid based on seed pixels.

    Args:
        input_grid (np.ndarray): A 2D NumPy array representing the input grid.

    Returns:
        np.ndarray: A 2D NumPy array representing the transformed output grid.
    """
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape
    
    # Keep track of visited cells across different fill operations to avoid refilling
    # This prevents a later fill from overriding an earlier one if seeds are adjacent
    # Note: We only mark cells *after* they are filled with a *new* color.
    # Blue cells that are checked but not filled are not marked here.
    globally_filled = np.zeros_like(input_grid, dtype=bool)

    # Find all potential seed pixels first
    seeds = []
    for r in range(rows):
        for c in range(cols):
            color = input_grid[r, c]
            if color != 0 and color != 1:
                seeds.append(((r, c), color))

    # Process each seed
    for seed_coord, seed_color in seeds:
        r_seed, c_seed = seed_coord
        
        # Initialize queue and visited set for this specific flood fill
        q = deque()
        visited_this_fill = set()

        # Find initial blue neighbors of the seed to start the fill
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r_seed + dr, c_seed + dc

            # Check boundaries
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is blue in the original grid
                # and hasn't been filled by a *previous* seed's operation
                if input_grid[nr, nc] == 1 and not globally_filled[nr, nc]:
                    # Check if not already visited *in this specific fill*
                    if (nr, nc) not in visited_this_fill:
                        output_grid[nr, nc] = seed_color # Fill the neighbor
                        globally_filled[nr, nc] = True   # Mark as globally filled
                        q.append((nr, nc))               # Add to queue for expansion
                        visited_this_fill.add((nr, nc))  # Mark as visited for this fill

        # Perform the flood fill (BFS) starting from the initial neighbors
        while q:
            curr_r, curr_c = q.popleft()

            # Explore neighbors of the current blue cell
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                next_r, next_c = curr_r + dr, curr_c + dc

                # Check boundaries
                if 0 <= next_r < rows and 0 <= next_c < cols:
                    # Check if the neighbor is blue in the original grid
                    # and hasn't been filled by a *previous* seed's operation
                    if input_grid[next_r, next_c] == 1 and not globally_filled[next_r, next_c]:
                         # Check if not already visited *in this specific fill*
                        if (next_r, next_c) not in visited_this_fill:
                             output_grid[next_r, next_c] = seed_color # Fill the neighbor
                             globally_filled[next_r, next_c] = True   # Mark as globally filled
                             q.append((next_r, next_c))               # Add to queue
                             visited_this_fill.add((next_r, next_c))  # Mark as visited for this fill

    return output_grid
```
