{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nTransforms an input grid based on two rules applied sequentially:\n\n1.  **Identify Colors:** Determine the background color (most frequent in the input grid) and the foreground color (the other color present).\n2.  **Cleanup Isolated Pixels:** Create a working copy of the input grid. Iterate through the *original* input grid. For each pixel with the foreground color, check its four cardinal neighbors (up, down, left, right). If *none* of the cardinal neighbors in the *original* grid have the foreground color, change the corresponding pixel in the *working copy* to the background color.\n3.  **Fill Horizontal Gaps:** Iterate through each row of the grid resulting from the cleanup step. Find any sequence of one or more background pixels that are immediately preceded and followed by foreground pixels on the same row. Change all background pixels within such sequences to the foreground color.\n4.  **Output:** Return the final modified grid.\n\"\"\"\n\ndef _get_colors(grid):\n    \"\"\"Identifies the background (most frequent) and foreground colors.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assume background is the most frequent color\n    background_color = counts.most_common(1)[0][0]\n    foreground_color = None\n    # Find the first color that is not the background\n    for color_count in counts.most_common():\n        color = color_count[0]\n        if color != background_color:\n            foreground_color = color\n            break\n    # Handle grids with only one color \n    if foreground_color is None:\n        # Treat the single color as both background and foreground for consistency,\n        # though gap filling won't occur.\n        foreground_color = background_color \n    return background_color, foreground_color\n\ndef _is_isolated(grid, r, c, fg_color):\n    \"\"\"Checks if the foreground pixel at (r, c) is isolated cardinally.\"\"\"\n    rows, cols = grid.shape\n    # Check neighbors (up, down, left, right)\n    # Ensure neighbor coordinates are within grid bounds\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == fg_color:\n            return False # Found a foreground neighbor\n    return True # No foreground neighbors found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules: \n    1. Cleanup isolated pixels based on original input state.\n    2. Fill all horizontal gaps between foreground pixels in the cleaned grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # 1. Identify Colors\n    background_color, foreground_color = _get_colors(input_np)\n    \n    # 2. Create a working copy for cleanup\n    # We need to read from input_np and write to cleaned_grid\n    cleaned_grid = input_np.copy()\n    \n    # 3. Cleanup Isolated Pixels\n    # Iterate through the *original* grid to determine isolation\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == foreground_color:\n                # Check isolation based on the original grid state\n                if _is_isolated(input_np, r, c, foreground_color):\n                    # Modify the *working copy*\n                    cleaned_grid[r, c] = background_color\n                    \n    # 4. Fill Horizontal Gaps\n    # Modify the cleaned_grid directly now. We can call it output_grid.\n    output_grid = cleaned_grid # No need for another copy if modifying in place\n    for r in range(rows):\n        # Use a pointer `c` to scan the row\n        c = 0\n        while c < cols:\n            # Look for the start of a potential pattern: FG pixel\n            if output_grid[r, c] == foreground_color:\n                start_fg_col = c\n                # Look ahead for the pattern: FG, then >=1 BG, then FG\n                next_c = c + 1\n                gap_start_col = -1\n                \n                # Scan for background pixels immediately after the start FG\n                while next_c < cols and output_grid[r, next_c] == background_color:\n                    if gap_start_col == -1:\n                         gap_start_col = next_c # Mark the start of the background sequence\n                    next_c += 1\n                    \n                # Check if we found at least one BG and then an FG pixel\n                if gap_start_col != -1 and next_c < cols and output_grid[r, next_c] == foreground_color:\n                    # Found the pattern: FG ... BG ... FG\n                    end_fg_col = next_c\n                    # Fill the gap (from gap_start_col up to, but not including, end_fg_col)\n                    output_grid[r, gap_start_col : end_fg_col] = foreground_color\n                    # Advance the main scan pointer past the filled gap and the end FG pixel\n                    c = end_fg_col \n                else:\n                    # Pattern not completed, move the main pointer past the start FG\n                    c = start_fg_col + 1\n            else:\n                # Not a foreground pixel, just advance the pointer\n                c += 1\n\n    # 5. Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17843,
    "candidates_token_count": 1290,
    "total_token_count": 19133,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.067719,
  "retries": 1
}