
## train_1

**input:**
```
0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 2 2 2 2 2 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 0 2 2 2 0 0 0 0 2 2 2 2
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0 0 2 2 2 2
0 0 2 2 0 0 0 0 0 2 2 2 0 0 0 0 2 2 2 2
0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 1 0 2 2 2 0 0 0 0 2 2 2 2
0 0 0 0 0 0 1 0 0 2 2 2 0 0 0 0 2 2 2 2
0 0 2 2 0 0 1 0 0 2 2 2 0 0 0 0 2 2 2 2
0 0 2 2 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 2 2 2 2 2 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 2 2 2 2 0 0 0 0 0 2 2 2 2 0 0 0 0 1
0 0 2 2 2 2 0 0 0 0 0 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 2 2 2 2 0 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 0 1 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 2 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 2 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 2 2 2 0 0 1 0 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 0 0 0 0
1 0 2 2 2 0 0 2 2 2 0 0 0 1
0 0 2 2 2 0 0 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 0 0 2 2 2 2 2 2 0 0 0 0
2 2 0 0 2 2 2 2 2 2 0 0 0 0
0 0 0 0 2 2 2 2 2 2 0 2 2 2
0 0 0 0 2 2 2 2 2 2 0 2 2 2
0 0 0 0 2 2 2 2 2 2 0 2 2 2
0 0 0 0 0 0 0 0 0 0 0 2 2 2
0 2 2 2 2 2 0 0 0 0 0 2 2 2
0 2 2 2 2 2 0 1 0 0 0 0 0 0
```


**output:**
```
0 0 1 1 1 0 0 1 0 0 0 0 0 0
0 0 1 1 1 0 0 1 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0
2 2 0 0 1 1 1 1 1 1 0 0 0 0
2 2 0 0 1 1 1 1 1 1 0 0 0 0
0 0 0 0 1 1 1 1 1 1 0 2 2 2
0 0 0 0 1 1 1 1 1 1 0 2 2 2
0 0 0 0 1 1 1 1 1 1 0 2 2 2
0 0 0 0 0 0 0 1 0 0 0 2 2 2
0 2 2 2 2 2 0 1 0 0 0 2 2 2
0 2 2 2 2 2 0 1 0 0 0 0 0 0
```

*   **Perception:** The input and output grids have the same dimensions. The grids contain pixels of three colors: white (0), blue (1), and red (2). The positions of the blue pixels (1) in the input seem crucial. In the output grid, the pixels located in the same rows or columns as the input blue pixels are changed to blue (1). All other pixels retain their original color from the input grid.

*   **Facts:**
    
```yaml
    grid_properties:
      - dimensions_match: Input and output grids have the same height and width.
      - colors_present: white (0), blue (1), red (2).
    objects:
      - type: pixel
        properties:
          - color: Integer value 0-9 (specifically 0, 1, 2 observed).
          - location: Defined by row and column index.
      - type: row
        properties:
          - index: Integer identifying the row.
          - contains_blue_pixel: Boolean, true if any pixel in the row has color 1 in the input.
      - type: column
        properties:
          - index: Integer identifying the column.
          - contains_blue_pixel: Boolean, true if any pixel in the column has color 1 in the input.
    relationships:
      - A pixel belongs to one row and one column.
      - The presence of a blue pixel (1) in a row or column in the input grid influences the color of all pixels in that corresponding row or column in the output grid.
    actions:
      - identify: Locate all pixels with color blue (1) in the input grid.
      - determine_affected_regions: Find all unique row indices and column indices that contain at least one blue pixel.
      - transform: Create the output grid by:
          - For each pixel location (row, col):
            - If the row index is among the identified affected rows OR the column index is among the identified affected columns:
              - Set the output pixel color to blue (1).
            - Else:
              - Set the output pixel color to the same color as the input pixel at that location.

    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the coordinates (row and column indices) of all blue pixels (color 1) in the input grid.
    3.  Collect all unique row indices from these coordinates.
    4.  Collect all unique column indices from these coordinates.
    5.  Iterate through each pixel position (row `r`, column `c`) of the grid.
    6.  If the row index `r` is in the collection of unique row indices identified in step 3, change the color of the pixel at (`r`, `c`) in the output grid to blue (1).
    7.  If the column index `c` is in the collection of unique column indices identified in step 4, change the color of the pixel at (`r`, `c`) in the output grid to blue (1).
    8.  Pixels whose row and column indices are not identified in steps 3 and 4 retain their original color from the input grid (this is handled by the initialization in step 1 and the conditional changes in steps 6 & 7).
```python
import numpy as np

def find_pixels_by_color(grid, color):
    """Finds the coordinates of all pixels with a specific color."""
    rows, cols = np.where(grid == color)
    return set(zip(rows, cols))

def transform(input_grid):
    """
    Transforms the input grid based on the locations of blue pixels (1).

    Identifies all pixels with color blue (1) in the input grid. Determines the
    set of unique row indices and column indices containing these blue pixels.
    Creates an output grid of the same dimensions as the input. For each pixel
    location (row, col), if its row index is in the set of affected rows OR
    its column index is in the set of affected columns, set the corresponding
    output pixel's color to blue (1). Otherwise, copy the color from the
    input grid at that location.
    """
    # Convert input grid to a numpy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input grid
    output_array = np.copy(input_array)
    height, width = input_array.shape

    # Find coordinates of all blue pixels (color 1)
    blue_pixels_coords = find_pixels_by_color(input_array, 1)

    # Collect unique row and column indices containing blue pixels
    affected_rows = set(r for r, c in blue_pixels_coords)
    affected_cols = set(c for r, c in blue_pixels_coords)

    # Iterate through each pixel of the grid
    for r in range(height):
        for c in range(width):
            # If the current row or column contained a blue pixel in the input
            if r in affected_rows or c in affected_cols:
                # Change the corresponding output pixel to blue (1)
                output_array[r, c] = 1
            # Otherwise, the pixel retains its original color (already copied)

    # Convert the numpy array back to a list of lists
    return output_array.tolist()

```
```python
import numpy as np
from collections import deque

def find_pixels_by_color(grid, color):
    """Finds the coordinates of all pixels with a specific color."""
    rows, cols = np.where(grid == color)
    return set(zip(rows, cols))

def find_contiguous_objects(grid, color):
    """
    Finds all contiguous objects of a given color in the grid.
    Uses Breadth-First Search (BFS) for 4-connectivity.
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(height):
        for c in range(width):
            # If the pixel is the target color and not yet visited
            if grid[r, c] == color and not visited[r, c]:
                current_object = set()
                q = deque([(r, c)])
                visited[r, c] = True
                current_object.add((r, c))

                while q:
                    row, col = q.popleft()

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc

                        # Check bounds
                        if 0 <= nr < height and 0 <= nc < width:
                            # If neighbor is same color and not visited
                            if grid[nr, nc] == color and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                                current_object.add((nr, nc))
                
                if current_object:
                    objects.append(current_object)
                    
    return objects

def transform(input_grid):
    """
    Transforms the input grid based on the locations of blue pixels (1) and red pixels (2).
    
    1. Identifies rows (R) and columns (C) containing at least one blue pixel (1).
    2. Finds all contiguous objects of red pixels (2).
    3. Initializes the output grid as a copy of the input.
    4. For each red object: if any of its pixels fall into an affected row (R) or column (C),
       the entire red object is changed to blue (1) in the output.
    5. For each pixel location (r, c): if its column (c) is an affected column (C) and
       the input pixel was white (0), the output pixel is changed to blue (1).
    """
    # Convert input to numpy array for efficient operations
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array)
    height, width = input_array.shape

    # 1. Find affected rows (R) and columns (C) from blue pixels (1)
    blue_pixels_coords = find_pixels_by_color(input_array, 1)
    affected_rows = set(r for r, c in blue_pixels_coords)
    affected_cols = set(c for r, c in blue_pixels_coords)

    # 2. Find all contiguous red (2) objects
    red_objects = find_contiguous_objects(input_array, 2)

    # 4. Process red objects
    for red_object in red_objects:
        intersects_affected_zone = False
        for r_obj, c_obj in red_object:
            if r_obj in affected_rows or c_obj in affected_cols:
                intersects_affected_zone = True
                break # No need to check further pixels in this object
        
        # If the object intersects the affected zone, change all its pixels to blue (1)
        if intersects_affected_zone:
            for r_obj, c_obj in red_object:
                output_array[r_obj, c_obj] = 1

    # 5. Process white (0) pixels in affected columns
    for r in range(height):
        for c in range(width):
            # Check if the column is affected AND the original pixel was white (0)
            if c in affected_cols and input_array[r, c] == 0:
                # Note: We only modify output_array here. If a red object was turned 
                # blue in step 4, this step won't overwrite it back to 0. If the
                # pixel was originally blue (1) or red (2) that wasn't changed in step 4,
                # this condition (input_array[r,c] == 0) prevents changing it.
                output_array[r, c] = 1
                
    # Convert the result back to a list of lists
    return output_array.tolist()
```
