{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple, Optional\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1.  Identify the single vertical segment composed of connected maroon (9) pixels in the input grid. Let its length be `L`.\n2.  Create a copy of the input grid.\n3.  In the copied grid, replace the identified maroon segment with the background color (orange, 7).\n4.  Calculate the required output maroon length: `L_output = L + 1`.\n5.  Identify all distinct vertical segments composed of connected azure (8) pixels in the *original* input grid.\n6.  Filter these azure segments, keeping only those whose length is greater than or equal to `L_output`.\n7.  If no azure segments meet the length requirement, return the grid with only the input maroon segment removed.\n8.  From the filtered list, find the minimum length present (`L_min_azure`).\n9.  Further filter the list, keeping only segments whose length is exactly `L_min_azure`.\n10. From this final list, select the one with the smallest column index (leftmost). Let its starting row be `R_target` and column be `C_target`.\n11. In the copied grid, change the color of the pixels from `(R_target, C_target)` down to `(R_target + L_output - 1, C_target)` to maroon (9).\n12. Return the modified grid.\n\"\"\"\n\ndef find_vertical_segments(grid: np.ndarray, color: int) -> List[Dict]:\n    \"\"\"\n    Finds all contiguous vertical segments of a given color in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        color: The integer value of the color to find segments for.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a segment\n        and contains 'length', 'row' (start row), and 'col'.\n        Returns an empty list if no segments are found.\n    \"\"\"\n    segments = []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool) # Keep track of visited cells within segments\n\n    for c in range(cols):\n        for r in range(rows):\n            # Check if the cell has the target color and hasn't been visited as part of a segment yet\n            if grid[r, c] == color and not visited[r, c]:\n                # Found the start of a potential segment\n                segment_len = 0\n                current_r = r\n                # Extend downwards as long as the color matches and within bounds\n                while current_r < rows and grid[current_r, c] == color:\n                    visited[current_r, c] = True\n                    segment_len += 1\n                    current_r += 1\n\n                # Store the found segment details\n                if segment_len > 0:\n                    segments.append({'length': segment_len, 'row': r, 'col': c})\n    return segments\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Define colors\n    background_color = 7\n    maroon = 9\n    azure = 8\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Find the input maroon segment\n    maroon_segments = find_vertical_segments(input_grid, maroon)\n\n    # Assume there is exactly one maroon segment based on examples.\n    # If not found (edge case), return the original grid copy.\n    if not maroon_segments:\n        return output_grid\n    \n    input_maroon_segment = maroon_segments[0]\n    maroon_len = input_maroon_segment['length']\n    maroon_start_row = input_maroon_segment['row']\n    maroon_col = input_maroon_segment['col']\n\n    # 3. Replace the input maroon segment with the background color\n    output_grid[maroon_start_row : maroon_start_row + maroon_len, maroon_col] = background_color\n\n    # 4. Calculate the required output maroon length\n    l_output = maroon_len + 1\n\n    # 5. Identify all azure segments in the original grid\n    azure_segments = find_vertical_segments(input_grid, azure)\n\n    # If no azure segments exist at all, return the grid after removing maroon\n    if not azure_segments:\n        return output_grid\n\n    # 6. Filter azure segments: length >= L_output\n    valid_azure_segments = [seg for seg in azure_segments if seg['length'] >= l_output]\n\n    # 7. If no segments meet the length requirement, return the grid\n    if not valid_azure_segments:\n        return output_grid\n\n    # 8. Find the minimum length among the valid segments\n    min_valid_length = min(seg['length'] for seg in valid_azure_segments)\n\n    # 9. Filter again: keep only segments with the minimum valid length\n    shortest_valid_segments = [seg for seg in valid_azure_segments if seg['length'] == min_valid_length]\n\n    # 10. Select the leftmost segment among the shortest valid ones\n    target_azure_segment = min(shortest_valid_segments, key=lambda seg: seg['col'])\n\n    target_start_row = target_azure_segment['row']\n    target_col = target_azure_segment['col']\n\n    # 11. Replace the top L_output pixels of the target segment with maroon\n    # Ensure we don't write past the grid boundary (slicing handles this).\n    # Ensure we don't write more pixels than the target segment has (use min).\n    # Although step 6 guarantees target_azure_segment['length'] >= l_output,\n    # using min is safer programming practice.\n    num_pixels_to_change = min(l_output, target_azure_segment['length'])\n    end_row = target_start_row + num_pixels_to_change\n    \n    output_grid[target_start_row : end_row, target_col] = maroon\n\n    # 12. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21794,
    "candidates_token_count": 1455,
    "total_token_count": 23249,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.432604,
  "retries": 1
}