
## train_1

**input:**
```
7 7 7 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 9 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 9 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 8 7 7 7 7 7 8 7 7 7
7 7 7 7 7 7 8 7 7 7 7 7 8 7 8 7
7 7 7 7 7 7 8 7 7 7 7 7 7 7 8 7
7 8 7 7 7 7 7 7 7 7 7 7 7 7 8 7
7 8 7 7 8 7 7 7 7 7 7 7 8 7 8 7
7 7 7 7 8 7 7 7 7 7 7 7 8 7 8 7
7 7 7 7 7 7 7 8 7 7 7 7 7 7 8 7
7 7 7 7 8 7 7 8 7 7 7 7 7 7 8 7
7 7 7 7 8 7 7 7 7 7 7 7 7 7 8 7
```


**output:**
```
7 7 7 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 9 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 9 7 7 7 8 7 7 7 7 7 7 7 7 7
7 7 9 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 8 7 7 7 8 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 8 7 7 7 7 7 8 7 7 7
7 7 7 7 7 7 8 7 7 7 7 7 8 7 8 7
7 7 7 7 7 7 8 7 7 7 7 7 7 7 8 7
7 8 7 7 7 7 7 7 7 7 7 7 7 7 8 7
7 8 7 7 8 7 7 7 7 7 7 7 8 7 8 7
7 7 7 7 8 7 7 7 7 7 7 7 8 7 8 7
7 7 7 7 7 7 7 8 7 7 7 7 7 7 8 7
7 7 7 7 8 7 7 8 7 7 7 7 7 7 8 7
7 7 7 7 8 7 7 7 7 7 7 7 7 7 8 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 8
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 7
7 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 8 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 8 7 8 7 7 7 7 7 7
7 7 7 7 8 7 7 8 7 8 7 8 7 7 8 7
7 8 7 7 8 7 7 7 7 8 7 8 7 7 8 7
7 8 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 8 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 9 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 8 7 7 8 7 7 7 7 7 7 7 7 8 7 8
7 7 7 7 8 7 7 7 7 7 7 8 7 8 7 8
7 7 7 7 8 7 7 7 7 7 7 8 7 7 7 7
7 7 7 7 8 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 8
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 7
7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 9 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 8 7 8 7 7 7 7 7 7
7 7 7 7 8 7 7 8 7 8 7 8 7 7 8 7
7 8 7 7 8 7 7 7 7 8 7 8 7 7 8 7
7 8 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 8 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 8 7 7
7 8 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 8 7 7 8 7 7 7 7 7 7 7 7 8 7 8
7 7 7 7 8 7 7 7 7 7 7 8 7 8 7 8
7 7 7 7 8 7 7 7 7 7 7 8 7 7 7 7
7 7 7 7 8 7 7 7 7 7 7 7 7 7 7 7
```


## train_3

**input:**
```
7 7 8 7 7 7 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 8 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 8 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 7 7 7 7 8 7 7 7 7 8 7
7 7 7 7 7 7 7 7 7 9 7 7 7 7 8 7
7 7 7 7 7 7 8 7 7 9 7 8 7 7 8 7
7 8 7 7 7 7 8 7 7 9 7 8 7 7 8 7
7 8 7 7 7 7 7 7 7 9 7 7 7 7 8 7
7 7 7 7 7 8 7 8 7 7 7 7 8 7 8 7
7 7 7 7 7 8 7 8 7 7 7 7 8 7 8 7
7 8 7 8 7 7 7 7 7 7 7 7 7 7 7 7
7 8 7 8 7 7 7 7 7 7 7 7 7 7 7 7
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 7
7 8 7 7 7 7 7 7 8 7 7 8 7 7 7 7
7 8 7 7 7 8 7 7 8 7 7 7 7 7 7 7
7 8 7 7 7 8 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 8 7 7 7 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 8 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 8 7 7 7 8 7 7 7 7 8 7
7 7 8 7 7 7 7 7 7 8 7 7 7 7 8 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7
7 7 7 7 7 7 8 7 7 8 7 8 7 7 9 7
7 8 7 7 7 7 8 7 7 8 7 8 7 7 9 7
7 8 7 7 7 7 7 7 7 8 7 7 7 7 9 7
7 7 7 7 7 8 7 8 7 7 7 7 8 7 9 7
7 7 7 7 7 8 7 8 7 7 7 7 8 7 9 7
7 8 7 8 7 7 7 7 7 7 7 7 7 7 7 7
7 8 7 8 7 7 7 7 7 7 7 7 7 7 7 7
7 8 7 7 7 7 7 7 7 7 7 8 7 7 7 7
7 8 7 7 7 7 7 7 8 7 7 8 7 7 7 7
7 8 7 7 7 8 7 7 8 7 7 7 7 7 7 7
7 8 7 7 7 8 7 7 7 7 7 7 7 7 7 7
```

*   **Perception of Elements:**
    *   The grids contain a background color (orange, 7).
    *   Scattered foreground pixels are mostly azure (8) and occasionally maroon (9).
    *   The azure (8) pixels often form distinct vertical line segments (contiguous blocks of azure pixels in a single column).
    *   The maroon (9) pixels in the input always form a single contiguous vertical block (potentially just one pixel).
    *   The transformation involves removing the input maroon block and creating a new maroon block by replacing some azure pixels from one of the vertical azure line segments.

*   **YAML Fact Documentation:**

    
```python
import numpy as np
from typing import List, Dict, Tuple

def find_vertical_segments(grid: np.ndarray, color: int) -> List[Dict]:
    """
    Finds all contiguous vertical segments of a given color in the grid.

    Args:
        grid: The input numpy array representing the grid.
        color: The integer value of the color to find segments for.

    Returns:
        A list of dictionaries, where each dictionary represents a segment
        and contains 'length', 'row' (start row), and 'col'.
        Returns an empty list if no segments are found.
    """
    segments = []
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool) # Keep track of visited cells within segments

    for c in range(cols):
        for r in range(rows):
            # Check if the cell has the target color and hasn't been visited as part of a segment yet
            if grid[r, c] == color and not visited[r, c]:
                # Found the start of a potential segment
                segment_len = 0
                current_r = r
                # Extend downwards as long as the color matches and within bounds
                while current_r < rows and grid[current_r, c] == color:
                    visited[current_r, c] = True
                    segment_len += 1
                    current_r += 1
                
                # Store the found segment details
                if segment_len > 0:
                    segments.append({'length': segment_len, 'row': r, 'col': c})
    return segments


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid based on the following rules:
    1. Find the vertical segment of maroon pixels (9) in the input grid.
    2. Determine its length L.
    3. Replace this maroon segment with the background color (orange, 7).
    4. Find all vertical segments of azure pixels (8) in the input grid.
    5. Identify the longest azure segment(s).
    6. If there are multiple longest segments, choose the leftmost one (smallest column index).
    7. Replace the top L pixels of the chosen azure segment with maroon pixels (9).

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    
    output_grid = np.copy(input_grid)
    background_color = 7
    maroon = 9
    azure = 8

    # 1. Find the vertical maroon segment
    maroon_segments = find_vertical_segments(input_grid, maroon)
    
    # Assume there is exactly one maroon segment based on examples
    if not maroon_segments:
        # Handle edge case: No maroon segment found (return input unchanged)
        return output_grid 
        
    maroon_segment = maroon_segments[0] # Assuming only one exists
    maroon_len = maroon_segment['length']
    maroon_start_row = maroon_segment['row']
    maroon_col = maroon_segment['col']

    # 3. Replace the maroon segment with the background color
    output_grid[maroon_start_row : maroon_start_row + maroon_len, maroon_col] = background_color

    # 4. Find all vertical azure segments
    azure_segments = find_vertical_segments(input_grid, azure)

    if not azure_segments:
        # Handle edge case: No azure segments found (return grid after removing maroon)
        return output_grid

    # 5. Identify the longest azure segment(s)
    max_azure_len = 0
    for seg in azure_segments:
        if seg['length'] > max_azure_len:
            max_azure_len = seg['length']
            
    longest_azure_segments = [seg for seg in azure_segments if seg['length'] == max_azure_len]

    # 6. If multiple longest, choose the leftmost one
    target_azure_segment = min(longest_azure_segments, key=lambda seg: seg['col'])
    
    target_start_row = target_azure_segment['row']
    target_col = target_azure_segment['col']
    # Target length isn't directly used, but we use maroon_len

    # 7. Replace the top L pixels of the chosen azure segment with maroon
    # Ensure we don't try to write past the bottom of the grid, though slicing handles this.
    # Also ensure we don't write more pixels than the target segment has, 
    # although the problem implies L <= target_length. Slicing handles this too.
    num_pixels_to_change = min(maroon_len, target_azure_segment['length']) # Use min just in case L > target_len
    
    # Change the color in the output grid
    output_grid[target_start_row : target_start_row + num_pixels_to_change, target_col] = maroon

    return output_grid
```
