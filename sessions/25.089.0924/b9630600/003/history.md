
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 0 0 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 3 0
3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 3 0
3 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 0 0 0 0 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 3 0 0 0 0 0 0 3 3 3 3 3 0 0 0 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 3 3 3 3 0 0 0 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 0 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 0 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

**Perception:**

1.  **Grid Structure:** All examples use a 30x30 grid.
2.  **Colors:** The primary colors involved are white (0) and green (3). White forms the background, and green forms various shapes.
3.  **Objects:** The green pixels form distinct objects, primarily hollow shapes resembling letters (like C, G, H, E) or simple rectangles. These shapes act as boundaries.
4.  **Transformation:** The core transformation seems to involve filling enclosed areas. Comparing input and output grids, the green shapes themselves remain unchanged. However, the contiguous white areas *inside* these green boundaries are filled with green in the output.
5.  **Enclosure:** The filling only occurs for white areas that are completely surrounded by green pixels. White areas connected to the grid boundary or outside the green shapes are left untouched. Adjacency seems to be based on horizontal and vertical neighbors (4-connectivity).

**Facts:**


```yaml
Color_Background: white (0)
Color_Object: green (3)
Objects:
  - type: Region
    color: green
    property: Forms closed boundaries or shapes.
  - type: Region
    color: white
    property: Can be enclosed by green regions or connected to the grid boundary.
Action:
  - name: Fill_Region
    target_color: white (0)
    condition: The white region must be completely enclosed by a green region (no path of white pixels to the grid boundary using 4-way adjacency).
    result_color: green (3)
Relationship:
  - type: Enclosure
    enclosing_object_color: green
    enclosed_object_color: white
    connectivity: 4-way adjacency (horizontal/vertical)
Grid_Properties:
  - size: 30x30 (consistent across examples)
  - modification: Only enclosed white pixels change color; green pixels remain unchanged.
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the initial output grid.
2.  Identify all contiguous regions of white pixels in the input grid.
3.  For each distinct white region:
    a.  Determine if this region is fully enclosed by green pixels. This means checking if any pixel within the white region touches the boundary of the grid. A simple way is to perform a search (like flood fill or BFS) starting from any pixel in the region, traversing only white pixels (using 4-way adjacency). If the search can reach any pixel on the grid's border (row 0, last row, column 0, or last column), the region is *not* enclosed.
    b.  If the white region is determined to be fully enclosed (i.e., the search could not reach the grid boundary), then change the color of all pixels belonging to this specific white region in the *output grid* to green.
4.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions of white pixels (0) in the input grid.
For each white region, determines if it is fully enclosed by green pixels (3), 
meaning it does not touch the grid boundary (top, bottom, left, or right edge).
If a white region is fully enclosed, fills that region with green (3) in the output grid.
Green pixels from the input remain unchanged. White pixels not enclosed also remain unchanged.
Adjacency is considered using 4 neighbors (up, down, left, right).
"""

def transform(input_grid):
    """
    Fills enclosed white regions with green.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Start with a copy of the input
    height, width = grid.shape
    
    # Keep track of visited white pixels to avoid redundant searches
    visited = np.zeros((height, width), dtype=bool)

    # Iterate through each cell of the grid
    for r in range(height):
        for c in range(width):
            # If we find an unvisited white pixel, start a search (BFS) for its region
            if grid[r, c] == 0 and not visited[r, c]:
                
                # Initialize data structures for BFS
                q = deque([(r, c)])
                region_pixels = []
                touches_boundary = False
                visited[r, c] = True

                # Perform BFS to find all connected white pixels in the region
                while q:
                    curr_r, curr_c = q.popleft()
                    region_pixels.append((curr_r, curr_c))

                    # Check if this pixel is on the boundary
                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:
                        touches_boundary = True
                        # Optimization: If boundary is touched, we know the region isn't enclosed. 
                        # We still need to finish BFS to mark all region pixels as visited, 
                        # but we don't need to track boundary status further for this region.
                        # However, for simplicity, we'll just let the flag be set and continue.

                    # Explore 4-way neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc

                        # Check if neighbor is within bounds
                        if 0 <= nr < height and 0 <= nc < width:
                            # If neighbor is white and not visited
                            if grid[nr, nc] == 0 and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))

                # After exploring the entire region, check if it touched the boundary
                if not touches_boundary:
                    # If it didn't touch the boundary, it's enclosed. Fill it with green.
                    for pr, pc in region_pixels:
                        output_grid[pr, pc] = 3 # Green color

    return output_grid.tolist() # Convert back to list of lists if required by the environment
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions of white pixels (0) in the input grid.
For each white region, determines if it is fully enclosed by green pixels (3), 
meaning it does not touch the grid boundary (top, bottom, left, or right edge).
If a white region is fully enclosed, fills that region with green (3) in the output grid.
Green pixels from the input remain unchanged. White pixels not enclosed also remain unchanged.
Adjacency is considered using 4 neighbors (up, down, left, right).
"""

def transform(input_grid):
    """
    Fills enclosed white regions with green.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Start with a copy of the input
    height, width = grid.shape
    
    # Keep track of visited white pixels to avoid redundant searches
    visited = np.zeros((height, width), dtype=bool)

    # Iterate through each cell of the grid
    for r in range(height):
        for c in range(width):
            # If we find an unvisited white pixel, start a search (BFS) for its region
            if grid[r, c] == 0 and not visited[r, c]:
                
                # Initialize data structures for BFS
                q = deque([(r, c)])
                region_pixels = []
                touches_boundary = False
                visited[r, c] = True

                # Perform BFS to find all connected white pixels in the region
                while q:
                    curr_r, curr_c = q.popleft()
                    region_pixels.append((curr_r, curr_c))

                    # Check if this pixel is on the boundary
                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:
                        touches_boundary = True
                        # Optimization: If boundary is touched, we know the region isn't enclosed. 
                        # We still need to finish BFS to mark all region pixels as visited, 
                        # but we don't need to track boundary status further for this region.
                        # However, for simplicity, we'll just let the flag be set and continue.

                    # Explore 4-way neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc

                        # Check if neighbor is within bounds
                        if 0 <= nr < height and 0 <= nc < width:
                            # If neighbor is white and not visited
                            if grid[nr, nc] == 0 and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))

                # After exploring the entire region, check if it touched the boundary
                if not touches_boundary:
                    # If it didn't touch the boundary, it's enclosed. Fill it with green.
                    for pr, pc in region_pixels:
                        output_grid[pr, pc] = 3 # Green color

    return output_grid.tolist() # Convert back to list of lists if required by the environment
```
Results for code_00.py:
Train Set Error: Timeout: Code execution exceeded 10 seconds
**Assessment:**

The initial analysis correctly identified the core task: filling enclosed white regions with green. The provided code implements this using a standard approach: iterating through the grid, finding unvisited white pixels, and performing a search (BFS) from each to identify its connected region and check for boundary contact. The timeout suggests this approach is too slow for the 30x30 grid size and the complexity of the regions within the ARC environment's time limits.

The strategy to resolve the timeout is to invert the search logic. Instead of searching each white region individually to see if it *reaches* the boundary, we can perform a single search *starting from* all white pixels on the boundary. Any white pixel reachable from the boundary is considered "outside". Any white pixel *not* reached by this search must be enclosed. This typically involves only one major graph traversal, making it more efficient.

**Metrics:**

All training examples use 30x30 grids. The only colors present are white (0) and green (3). Green pixels form boundaries, and the transformation involves changing *some* white pixels to green. The green boundary pixels remain unchanged in all examples.


