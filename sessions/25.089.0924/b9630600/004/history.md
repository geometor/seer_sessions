
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 3 0
3 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 0 0 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 3 0
3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 3 0
3 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 3 0 0 0 3 3 3 0
3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 3 3 0 0 0 0 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 0 0 3 0 0 0 0 3 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 3 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 3 0 0 0 0 0 0 3 3 3 3 3 0 0 0 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 3 0 0 0 0 0 0 3 3 3 3 3 0 0 0 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 3 3 3 3 3 3 3 3 0 0 0 3 3 0 3 3 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 3 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 0 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 3 3 3 3 3 0
0 0 0 0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 3 3 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

**Perception:**

1.  **Grid Structure:** All examples use a 30x30 grid.
2.  **Colors:** The primary colors involved are white (0) and green (3). White forms the background, and green forms various shapes.
3.  **Objects:** The green pixels form distinct objects, primarily hollow shapes resembling letters (like C, G, H, E) or simple rectangles. These shapes act as boundaries.
4.  **Transformation:** The core transformation seems to involve filling enclosed areas. Comparing input and output grids, the green shapes themselves remain unchanged. However, the contiguous white areas *inside* these green boundaries are filled with green in the output.
5.  **Enclosure:** The filling only occurs for white areas that are completely surrounded by green pixels. White areas connected to the grid boundary or outside the green shapes are left untouched. Adjacency seems to be based on horizontal and vertical neighbors (4-connectivity).

**Facts:**


```yaml
Color_Background: white (0)
Color_Object: green (3)
Objects:
  - type: Region
    color: green
    property: Forms closed boundaries or shapes.
  - type: Region
    color: white
    property: Can be enclosed by green regions or connected to the grid boundary.
Action:
  - name: Fill_Region
    target_color: white (0)
    condition: The white region must be completely enclosed by a green region (no path of white pixels to the grid boundary using 4-way adjacency).
    result_color: green (3)
Relationship:
  - type: Enclosure
    enclosing_object_color: green
    enclosed_object_color: white
    connectivity: 4-way adjacency (horizontal/vertical)
Grid_Properties:
  - size: 30x30 (consistent across examples)
  - modification: Only enclosed white pixels change color; green pixels remain unchanged.
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the initial output grid.
2.  Identify all contiguous regions of white pixels in the input grid.
3.  For each distinct white region:
    a.  Determine if this region is fully enclosed by green pixels. This means checking if any pixel within the white region touches the boundary of the grid. A simple way is to perform a search (like flood fill or BFS) starting from any pixel in the region, traversing only white pixels (using 4-way adjacency). If the search can reach any pixel on the grid's border (row 0, last row, column 0, or last column), the region is *not* enclosed.
    b.  If the white region is determined to be fully enclosed (i.e., the search could not reach the grid boundary), then change the color of all pixels belonging to this specific white region in the *output grid* to green.
4.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions of white pixels (0) in the input grid.
For each white region, determines if it is fully enclosed by green pixels (3), 
meaning it does not touch the grid boundary (top, bottom, left, or right edge).
If a white region is fully enclosed, fills that region with green (3) in the output grid.
Green pixels from the input remain unchanged. White pixels not enclosed also remain unchanged.
Adjacency is considered using 4 neighbors (up, down, left, right).
"""

def transform(input_grid):
    """
    Fills enclosed white regions with green.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Start with a copy of the input
    height, width = grid.shape
    
    # Keep track of visited white pixels to avoid redundant searches
    visited = np.zeros((height, width), dtype=bool)

    # Iterate through each cell of the grid
    for r in range(height):
        for c in range(width):
            # If we find an unvisited white pixel, start a search (BFS) for its region
            if grid[r, c] == 0 and not visited[r, c]:
                
                # Initialize data structures for BFS
                q = deque([(r, c)])
                region_pixels = []
                touches_boundary = False
                visited[r, c] = True

                # Perform BFS to find all connected white pixels in the region
                while q:
                    curr_r, curr_c = q.popleft()
                    region_pixels.append((curr_r, curr_c))

                    # Check if this pixel is on the boundary
                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:
                        touches_boundary = True
                        # Optimization: If boundary is touched, we know the region isn't enclosed. 
                        # We still need to finish BFS to mark all region pixels as visited, 
                        # but we don't need to track boundary status further for this region.
                        # However, for simplicity, we'll just let the flag be set and continue.

                    # Explore 4-way neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc

                        # Check if neighbor is within bounds
                        if 0 <= nr < height and 0 <= nc < width:
                            # If neighbor is white and not visited
                            if grid[nr, nc] == 0 and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))

                # After exploring the entire region, check if it touched the boundary
                if not touches_boundary:
                    # If it didn't touch the boundary, it's enclosed. Fill it with green.
                    for pr, pc in region_pixels:
                        output_grid[pr, pc] = 3 # Green color

    return output_grid.tolist() # Convert back to list of lists if required by the environment
```
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions of white pixels (0) that are fully enclosed by green pixels (3).
A region is considered enclosed if none of its pixels touch the grid boundary (top, bottom, left, or right edge)
through a path of connected white pixels (using 4-way adjacency).
Fills these enclosed white regions with green (3) in the output grid.
Green pixels from the input remain unchanged. White pixels connected to the boundary also remain unchanged.
"""

def transform(input_grid):
    """
    Fills white regions enclosed by green pixels with green.

    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    # Convert input list of lists to numpy array for efficient operations
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Start with a copy of the input
    height, width = grid.shape
    
    # Keep track of white pixels reachable from the boundary
    reachable_from_boundary = np.zeros((height, width), dtype=bool)
    q = deque()

    # Seed the BFS queue with all white pixels on the boundary
    for r in range(height):
        if grid[r, 0] == 0 and not reachable_from_boundary[r, 0]:
            q.append((r, 0))
            reachable_from_boundary[r, 0] = True
        if grid[r, width - 1] == 0 and not reachable_from_boundary[r, width - 1]:
            q.append((r, width - 1))
            reachable_from_boundary[r, width - 1] = True
            
    for c in range(width): # Avoid double-adding corners
        if grid[0, c] == 0 and not reachable_from_boundary[0, c]:
            q.append((0, c))
            reachable_from_boundary[0, c] = True
        if grid[height - 1, c] == 0 and not reachable_from_boundary[height - 1, c]:
            q.append((height - 1, c))
            reachable_from_boundary[height - 1, c] = True

    # Perform BFS starting from the boundary white pixels
    while q:
        curr_r, curr_c = q.popleft()

        # Explore 4-way neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = curr_r + dr, curr_c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # If neighbor is white and not yet marked as reachable
                if grid[nr, nc] == 0 and not reachable_from_boundary[nr, nc]:
                    reachable_from_boundary[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid and fill enclosed white pixels
    for r in range(height):
        for c in range(width):
            # If a pixel is white (0) but was not reached by the BFS from the boundary, it's enclosed.
            if grid[r, c] == 0 and not reachable_from_boundary[r, c]:
                output_grid[r, c] = 3 # Fill with green

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
