
## train_1

**input:**
```
7 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 8
1 8 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 4 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 3 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 4 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 7 7 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 8 8 8 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 3 3 3 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 7 7 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 2 8 4 4 4 4 4 4 4 4
4 3 4 4 4 4 4 4 4 4 2 4 1 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 2 5 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 2 8 8 8 8 8 8 8 8 8
4 3 3 3 3 3 3 3 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 4 4 4 4 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 3 3 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 3 4 4 3 4 3 4 2 8 8 8 8 8 8 8 8 8
4 3 4 3 4 4 3 4 3 4 2 2 2 2 2 2 2 2 2 2
4 3 4 3 4 4 3 4 3 4 2 5 5 5 5 5 5 5 5 5
4 3 4 3 4 4 3 4 3 4 2 5 0 0 0 0 0 0 0 5
4 3 4 3 4 4 3 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 4 3 3 3 3 4 3 4 2 5 0 1 5 5 5 1 0 5
4 3 4 4 4 4 4 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 3 3 3 3 3 3 3 4 2 5 0 0 0 0 0 0 0 5
4 4 4 4 4 4 4 4 4 4 2 5 5 5 5 5 5 5 5 5
```

*   **Perception:**
    *   The input and output grids have the same dimensions (20x20 in both examples).
    *   Both input grids contain prominent Red (2) lines acting as dividers or boundaries. The shape and position of these Red lines are preserved exactly in the output grids.
    *   The input grids have a dominant background color (Blue=1 in train\_1, Yellow=4 in train\_2).
    *   Scattered within the input grids are other colored pixels (non-background, non-Red). These seem to act as "seeds" or "sources".
    *   The output grids show areas filled with colors derived from these source pixels. The Red lines act as barriers to the filling process.
    *   The grid appears to be divided into distinct regions by the Red lines and the grid edges.
    *   Within each region, the filling seems to be based on the source pixels located within that region in the input grid.
    *   The filling mechanism resembles a Voronoi diagram or a "closest source" fill. Each pixel within a region takes the color of the "closest" source pixel from the input, using Manhattan distance.
    *   In case of ties (a pixel being equidistant from multiple source pixels), a tie-breaking rule seems to apply, likely based on the position of the source pixels (e.g., top-most, then left-most source wins).

*   **Facts:**
    
```yaml
    task_type: fill_regions
    grid_properties:
      - dimensions_preserved: True
      - boundary_color: 2 # Red
    elements:
      - role: boundary
        color: 2 # Red
        description: Fixed lines that divide the grid into regions and block filling.
      - role: background
        description: The most frequent color in the input, excluding the boundary color. Fills regions with no source pixels.
        properties:
          - color: 1 # Blue (in train_1)
          - color: 4 # Yellow (in train_2)
      - role: source_pixel
        description: Non-background, non-boundary pixels in the input grid. Determine the fill color for regions.
        properties:
          - location: specific coordinates (r, c)
          - color: various (e.g., 7, 8, 4, 3, 5, 0, 1)
    actions:
      - identify_regions:
          inputs: [input_grid, boundary_color]
          outputs: list_of_regions
          description: Find connected areas of non-boundary pixels, separated by boundary pixels and grid edges.
      - find_sources_in_region:
          inputs: [region_coordinates, input_grid, background_color, boundary_color]
          outputs: list_of_source_pixels [(r, c, color)]
          description: Locate all source pixels within a given region.
      - fill_region:
          inputs: [region_coordinates, source_pixels, output_grid]
          outputs: modified_output_grid
          description: For each pixel in the region, determine the closest source pixel using Manhattan distance, apply tie-breaking (min row, then min col), and assign its color to the output grid pixel.
    relationships:
      - distance_metric: Manhattan distance (|r1-r2| + |c1-c2|) used to determine closest source pixel.
      - tie_breaking: If multiple source pixels are equidistant, the one with the minimum row index wins. If rows are tied, the one with the minimum column index wins.
      - region_containment: Source pixels only influence the fill color within the region they belong to.
      - boundary_blocking: The fill process does not cross pixels with the boundary color.
    ```


*   **Natural Language Program:**
    1.  Identify the boundary color, which is Red (2).
    2.  Identify the background color by finding the most frequent color in the input grid, excluding the boundary color (Red).
    3.  Create the output grid as an exact copy of the input grid. This preserves the Red boundaries and sets the initial state for regions without source pixels.
    4.  Identify all distinct connected regions in the grid that do not contain the boundary color (Red). Use a method like Breadth-First Search (BFS) or Flood Fill starting from non-Red pixels, treating Red pixels as impassable walls. Keep track of the coordinates belonging to each region.
    5.  For each identified region:
        a.  Find all "source pixels" within this region by examining the *input* grid. A source pixel is any pixel within the region's coordinates whose color is neither the background color nor the boundary color (Red). Store the coordinates and color of each source pixel found for this region.
        b.  If one or more source pixels were found for the current region:
            i.  Iterate through every pixel coordinate `(r, c)` belonging to this region.
            ii. For the current pixel `(r, c)`, calculate the Manhattan distance (`|r - sr| + |c - sc|`) to every source pixel `(sr, sc)` associated with this region.
            iii. Find the minimum Manhattan distance calculated.
            iv. Identify all source pixels that are exactly at this minimum distance from `(r, c)`.
            v.  If there is only one source pixel at the minimum distance, select that source pixel.
            vi. If there are multiple source pixels at the minimum distance (a tie), select the one among them that has the smallest row index (`sr`). If there is still a tie (multiple sources at the minimum distance share the same smallest row index), select the one among those with the smallest column index (`sc`).
            vii.Set the color of the pixel at `(r, c)` in the *output* grid to the color of the selected source pixel.
    6.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule:

1.  Identify the boundary color (Red=2) and the background color (the most frequent color in the input excluding Red=2).
2.  Create the output grid as a copy of the input grid.
3.  Find distinct connected regions of non-boundary pixels in the input grid using BFS, treating boundary pixels as walls.
4.  For each region:
    a.  Identify all "source pixels" within the region in the *input* grid. A source pixel is neither the background color nor the boundary color.
    b.  If the region contains source pixels:
        i.  For each pixel within the region's coordinates in the *output* grid:
            - Calculate the Manhattan distance to all source pixels belonging to this region.
            - Find the minimum distance.
            - Identify all source pixels at this minimum distance.
            - Apply tie-breaking: select the source pixel with the minimum row index, then the minimum column index among those tied for minimum distance.
            - Set the output grid pixel's color to the color of the selected source pixel.
    c.  If the region contains no source pixels, its pixels in the output grid remain unchanged from the initial copy.
5.  Return the modified output grid.
"""

def get_background_color(grid, boundary_color=2):
    """Finds the most frequent color in the grid, excluding the boundary color."""
    colors, counts = np.unique(grid, return_counts=True)
    max_count = 0
    background = 0 # Default background
    # Find the most frequent non-boundary color
    found_non_boundary = False
    sorted_indices = np.argsort(-counts) # Sort counts descending

    for idx in sorted_indices:
        color = colors[idx]
        if color != boundary_color:
             background = color
             found_non_boundary = True
             break
             
    # If only boundary color exists, pick 0 as default, although this case might not matter
    # based on the logic as no regions would be processed. If other colors exist but only
    # boundary and sources, pick the most frequent source as background? No, the prompt
    # implied a dominant background. Let's stick to the most frequent non-boundary.
    # If no non-boundary color exists, the concept of background might be irrelevant.
    # Let's assume a background always exists if there are non-boundary pixels.
    # If the grid contains only boundary cells, this function might return 0 or the boundary color itself.
    # Check the first non-boundary color found.
    if not found_non_boundary and len(colors) > 0:
         # Handle cases where only boundary color exists or something unexpected
         # Pick the smallest color value as a fallback if needed, or 0.
         non_boundary_colors = colors[colors != boundary_color]
         if len(non_boundary_colors) > 0:
             background = np.min(non_boundary_colors) # Fallback strategy
         else:
             background = 0 # Default if truly only boundary color

    return background

def manhattan_distance(p1, p2):
    """Calculates Manhattan distance between two points (r1, c1) and (r2, c2)."""
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def transform(input_grid):
    """
    Applies the described region-filling transformation based on closest source pixels.
    """
    input_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_np)
    rows, cols = input_np.shape
    boundary_color = 2
    background_color = get_background_color(input_np, boundary_color)
    visited = np.zeros_like(input_np, dtype=bool)

    # Iterate through each cell to find the start of a new region
    for r in range(rows):
        for c in range(cols):
            # If the cell is not a boundary and hasn't been visited yet, start BFS
            if input_np[r, c] != boundary_color and not visited[r, c]:
                region_coords = []
                region_sources = []
                q = deque([(r, c)])
                visited[r, c] = True

                # Perform BFS to find all cells in the current connected region
                while q:
                    curr_r, curr_c = q.popleft()
                    region_coords.append((curr_r, curr_c))

                    # Check if the current cell is a source pixel
                    pixel_color = input_np[curr_r, curr_c]
                    if pixel_color != background_color and pixel_color != boundary_color:
                        region_sources.append((curr_r, curr_c, pixel_color))

                    # Explore neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc

                        # Check bounds and if neighbor is valid (not boundary, not visited)
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           input_np[nr, nc] != boundary_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # After finding all cells and sources for the region, fill it if sources exist
                if region_sources:
                    for reg_r, reg_c in region_coords:
                        min_dist = float('inf')
                        closest_sources = []

                        # Calculate distance to all sources in this region
                        for src_r, src_c, src_color in region_sources:
                            dist = manhattan_distance((reg_r, reg_c), (src_r, src_c))
                            if dist < min_dist:
                                min_dist = dist
                                closest_sources = [(src_r, src_c, src_color)]
                            elif dist == min_dist:
                                closest_sources.append((src_r, src_c, src_color))

                        # Apply tie-breaking rule (min row, then min col)
                        if closest_sources:
                            closest_sources.sort(key=lambda x: (x[0], x[1])) # Sort by row, then col
                            winning_source_color = closest_sources[0][2]
                            output_grid[reg_r, reg_c] = winning_source_color
                # If region_sources is empty, the output_grid pixels retain their original input value (copied initially)

    return output_grid.tolist() # Return as list of lists
```
