{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport operator\n\n\"\"\"\nIdentifies all distinct, single-color objects in the input grid. Classifies \nobjects into 'simple hollow rectangles' (at least 3x3, pixels exactly form the \nbounding box perimeter, interior is all white) and 'other objects'. \nSelects one 'other object' as the pattern source based on the largest pixel \ncount (ties broken by top-most, then left-most bounding box corner). Extracts the \npattern from the interior of the pattern source's bounding box. Selects the two \n'simple hollow rectangles' with the largest bounding box area (ties broken by \ntop-most, then left-most corner). Tiles the extracted pattern into the interior \nof the selected target rectangles, using the color of each target rectangle's \nframe for the non-background parts of the pattern. Outputs the modified grid.\n\"\"\"\n\ndef find_object_pixels(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds all connected pixels (4-connectivity) of the same color starting \n    from (start_row, start_col) that haven't been visited yet.\n    Updates the visited set.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): Starting row index.\n        start_col (int): Starting column index.\n        visited (set): Set of (row, col) tuples already visited or part of another object.\n\n    Returns:\n        tuple: (object_pixels, color, bbox, pixel_count)\n            - object_pixels (set): Set of (row, col) tuples for the object.\n            - color (int): The color index of the object.\n            - bbox (tuple): (min_row, min_col, max_row, max_col).\n            - pixel_count (int): Number of pixels in the object.\n        Returns (None, -1, None, 0) if the starting pixel is invalid (background or visited).\n    \"\"\"\n    rows, cols = grid.shape\n    color = grid[start_row, start_col]\n    \n    # Check if starting pixel is already visited or is background (color 0)\n    if color == 0 or (start_row, start_col) in visited:\n        return None, -1, None, 0\n\n    q = deque([(start_row, start_col)])\n    object_pixels = set()\n    pixel_count = 0\n    min_r, min_c = start_row, start_col\n    max_r, max_c = start_row, start_col\n    \n    visited.add((start_row, start_col)) # Mark start as visited immediately\n\n    while q:\n        r, c = q.popleft()\n        \n        # Add to object and update bounds\n        object_pixels.add((r, c))\n        pixel_count += 1\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n        \n        # Add valid, unvisited neighbors of the same color to the queue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == color and (nr, nc) not in visited:\n                 visited.add((nr, nc)) # Mark neighbor as visited when adding to queue\n                 q.append((nr, nc))\n                 \n    bbox = (min_r, min_c, max_r, max_c)\n    return object_pixels, color, bbox, pixel_count\n\ndef is_simple_hollow_rectangle(grid, object_pixels, bbox):\n    \"\"\"\n    Checks if a set of object pixels forms a simple hollow rectangle:\n    1. Pixels form the exact perimeter of a rectangle.\n    2. All interior pixels are white (0).\n    3. Minimum size is 3x3.\n\n    Args:\n        grid (np.array): The input grid.\n        object_pixels (set): Set of (row, col) for the object.\n        bbox (tuple): (min_row, min_col, max_row, max_col) of the object.\n\n    Returns:\n        tuple: (is_hollow (bool), area (int) if hollow else 0).\n    \"\"\"\n    if not object_pixels: return False, 0\n    min_row, min_col, max_row, max_col = bbox\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Check 1: Minimum size 3x3\n    if height < 3 or width < 3: return False, 0\n\n    # Check 2: All object pixels must be exactly on the bounding box perimeter\n    expected_perimeter_pixels = set()\n    # Top and bottom rows\n    for c in range(min_col, max_col + 1):\n        expected_perimeter_pixels.add((min_row, c))\n        expected_perimeter_pixels.add((max_row, c))\n    # Left and right columns (excluding corners already added)\n    for r in range(min_row + 1, max_row):\n        expected_perimeter_pixels.add((r, min_col))\n        expected_perimeter_pixels.add((r, max_col))\n        \n    # Compare the actual object pixels with the expected perimeter pixels\n    if object_pixels != expected_perimeter_pixels:\n        return False, 0 \n\n    # Check 3: All interior pixels must be white (0)\n    for r in range(min_row + 1, max_row):\n        for c in range(min_col + 1, max_col):\n            # Boundary check (should not be needed if perimeter is correct but safe)\n            if not (0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]):\n                return False, 0 # Should not happen\n            if grid[r, c] != 0:\n                return False, 0 # Non-white pixel found inside\n\n    # If all checks pass, it's a simple hollow rectangle\n    area = height * width\n    return True, area\n\ndef extract_pattern_grid(grid, source_bbox):\n    \"\"\"\n    Extracts the 2D pattern from the interior of the source object's bounding box.\n\n    Args:\n        grid (np.array): The input grid.\n        source_bbox (tuple): (min_row, min_col, max_row, max_col) of the source object.\n\n    Returns:\n        np.array: A numpy array representing the pattern, or None if no interior exists.\n    \"\"\"\n    min_r, min_c, max_r, max_c = source_bbox\n    pattern_h = max_r - min_r - 1\n    pattern_w = max_c - min_c - 1\n\n    if pattern_h <= 0 or pattern_w <= 0:\n        return None # No interior to extract pattern from\n\n    pattern = grid[min_r + 1 : max_r, min_c + 1 : max_c]\n    return pattern\n\ndef tile_fill_interior(output_grid, target_bbox, target_color, pattern_grid):\n    \"\"\"\n    Fills the interior of the target rectangle by tiling the pattern grid.\n    Modifies output_grid in place. Non-background pixels in the pattern\n    are replaced with the target_color.\n\n    Args:\n        output_grid (np.array): The grid to be modified.\n        target_bbox (tuple): (min_row, min_col, max_row, max_col) of the target rectangle.\n        target_color (int): The color of the target rectangle's frame.\n        pattern_grid (np.array): The pattern to tile.\n    \"\"\"\n    if pattern_grid is None or pattern_grid.size == 0:\n        return # Cannot fill if pattern is invalid or empty\n\n    min_r, min_c, max_r, max_c = target_bbox\n    pattern_h, pattern_w = pattern_grid.shape\n\n    # Iterate through the interior cells of the target rectangle\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            # Calculate corresponding pattern coordinates using modulo for tiling\n            rel_r = r - (min_r + 1)\n            rel_c = c - (min_c + 1)\n            p_r = rel_r % pattern_h\n            p_c = rel_c % pattern_w\n\n            # Check the color in the pattern grid\n            pattern_pixel_color = pattern_grid[p_r, p_c]\n\n            # If the pattern pixel is not background (0), fill with target color\n            # Ensure we don't write outside the grid (safety check)\n            if pattern_pixel_color != 0 and \\\n               0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                output_grid[r, c] = target_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: identifies objects, selects a pattern source based\n    on pixel count, selects two target hollow rectangles based on area, extracts\n    the pattern from the source's interior, and tiles it into the targets' interiors\n    using the target's frame color.\n    \n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array and initialize output grid\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n    visited = set()\n    \n    all_objects = []\n\n    # 1. Identify and Classify All Objects\n    for r in range(rows):\n        for c in range(cols):\n            pixels, color, bbox, pixel_count = find_object_pixels(input_grid_np, r, c, visited)\n            \n            if pixels: # If a valid object was found\n                # Check if it's a simple hollow rectangle\n                is_hollow, area = is_simple_hollow_rectangle(input_grid_np, pixels, bbox)\n                # Store object information\n                all_objects.append({\n                    'pixels': pixels, # Not strictly needed later, but good for debug\n                    'color': color,\n                    'bbox': bbox,\n                    'pixel_count': pixel_count,\n                    'is_hollow': is_hollow,\n                    'area': area # Area is bounding box area, only > 0 if hollow\n                })\n\n    # Separate into hollow rectangles and potential pattern sources ('other')\n    hollow_rects = [o for o in all_objects if o['is_hollow']]\n    other_objects = [o for o in all_objects if not o['is_hollow']]\n\n    # 2. Select Pattern Source Object\n    pattern_source_object = None\n    if other_objects:\n        # Sort by pixel_count (desc), then min_row (asc), then min_col (asc)\n        other_objects.sort(key=lambda x: (-x['pixel_count'], x['bbox'][0], x['bbox'][1]))\n        pattern_source_object = other_objects[0] # Select the top one\n\n    # 3. Extract Pattern Grid from Source Interior\n    pattern_grid = None\n    if pattern_source_object:\n        pattern_grid = extract_pattern_grid(input_grid_np, pattern_source_object['bbox'])\n\n    # 4. Select Target Rectangles\n    target_rectangles = []\n    if hollow_rects:\n        # Sort by area (desc), then min_row (asc), then min_col (asc)\n        hollow_rects.sort(key=lambda x: (-x['area'], x['bbox'][0], x['bbox'][1]))\n        target_rectangles = hollow_rects[:2] # Select the top two largest areas\n\n    # 5. Tile Fill Interiors of Target Rectangles\n    # Only proceed if a valid pattern was extracted\n    if pattern_grid is not None and pattern_grid.size > 0: \n        for target in target_rectangles:\n            tile_fill_interior(output_grid, \n                                target['bbox'], \n                                target['color'], \n                                pattern_grid)\n\n    # Convert final grid back to list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23403,
    "candidates_token_count": 2989,
    "total_token_count": 26392,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.076635,
  "retries": 1
}