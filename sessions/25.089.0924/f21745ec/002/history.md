
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 2 2 2 2 2
0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 2 0 0 0 2
0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 2 0 0 0 2
0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 2 0 0 0 2
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 2 0 0 0 2
0 4 4 4 4 4 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2
0 4 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 4 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 4 4 4 4 4 0 0 0 0 0 5 0 5 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 5 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 0 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 0 0 5 0 0 0 0 0
0 0 0 7 7 7 7 7 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 0 3 0 3 0 0 0 0 2 2 2 2 2
0 0 0 0 0 0 0 3 3 3 0 3 0 0 0 0 2 0 2 0 2
0 0 0 0 0 0 0 3 0 3 3 3 0 0 0 0 2 2 2 0 2
0 0 0 0 0 0 0 3 3 0 0 3 0 0 0 0 2 0 2 2 2
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 2 2 0 0 2
0 4 4 4 4 4 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2
0 4 0 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 0 0 4 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 4 4 4 4 4 0 0 0 0 0 5 0 5 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 5 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 0 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 8 8 0 0 6 6 6 6 6 6 6 6
0 8 0 8 8 0 0 0 8 0 0 6 0 0 0 0 0 0 6
0 8 8 8 0 8 8 0 8 0 0 6 0 0 0 0 0 0 6
0 8 0 0 8 8 0 8 8 0 0 6 0 0 0 0 0 0 6
0 8 0 0 0 0 8 0 8 0 0 6 0 0 0 0 0 0 6
0 8 8 8 8 8 8 8 8 0 0 6 0 0 0 0 0 0 6
0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 5 5 5 5 5 0
0 0 0 4 0 0 0 0 0 0 4 0 0 5 0 0 0 5 0
0 0 0 4 0 0 0 0 0 0 4 0 0 5 0 0 0 5 0
0 0 0 4 0 0 0 0 0 0 4 0 0 5 0 0 0 5 0
0 0 0 4 0 0 0 0 0 0 4 0 0 5 5 5 5 5 0
0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 8 8 0 0 6 6 6 6 6 6 6 6
0 8 0 8 8 0 0 0 8 0 0 6 0 0 0 0 0 6 6
0 8 8 8 0 8 8 0 8 0 0 6 0 6 6 0 0 0 6
0 8 0 0 8 8 0 8 8 0 0 6 6 6 0 6 6 0 6
0 8 0 0 0 0 8 0 8 0 0 6 0 0 6 6 0 6 6
0 8 8 8 8 8 8 8 8 0 0 6 0 0 0 0 6 0 6
0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 4 4 0 0 0 0 0 0 0 0
0 0 0 4 0 4 4 0 0 0 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 4 4 0 4 0 0 0 0 0 0 0 0
0 0 0 4 0 0 4 4 0 4 4 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 3 3 3 3 0 0
0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 3 0 0 3 0 0
0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 3 0 0 3 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 0 0 8 0 8 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0
8 8 8 8 8 8 8 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 7 7 7 7 7 7 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 7 0 0 0 0 7 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 7 0 0 0 0 7 0 0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 7 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 0 0 0 8 0 8 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0
8 8 8 8 8 8 8 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:**
    The input grids contain multiple distinct, non-overlapping objects composed of single, non-white colors, placed on a white background. Some of these objects form hollow rectangular frames. The transformation identifies these specific hollow rectangular frames and fills their interior (the white pixels enclosed by the frame) with the same color as the frame itself. Objects that are not complete hollow rectangles (e.g., U-shapes, solid shapes, lines, or shapes with internal structures other than just white) are left unchanged. The background remains white.

*   **Facts:**
    
```yaml
    task_type: object_transformation
    objects:
      - type: background
        properties:
          color: white
          value: 0
          role: static_canvas
      - type: shape
        properties:
          color: non-white (blue, red, green, yellow, gray, magenta, orange, azure)
          value: 1-9
          connectivity: contiguous block of same-colored pixels
          form: variable (rectangles, lines, U-shapes, complex patterns)
    relationships:
      - type: spatial
        description: Shapes are placed on the background. Shapes do not overlap.
      - type: containment
        description: Some shapes form closed rectangular frames that enclose an area of white pixels.
    actions:
      - name: identify_hollow_rectangles
        input: shapes
        output: set of shapes that are complete, hollow rectangular frames
        criteria:
          - Closed perimeter of a single non-white color.
          - Rectangular shape.
          - Interior composed entirely of white pixels.
      - name: fill_interior
        input: identified hollow rectangles
        output: modified grid
        process: For each identified rectangle, change the color of all white pixels strictly inside its perimeter to the color of the rectangle's frame.
    transformation_scope: Applies only to pixels inside identified hollow rectangles. Other pixels remain unchanged.
    ```


*   **Natural Language Program:**
    1.  Scan the input grid to identify distinct objects (contiguous blocks of the same non-white color).
    2.  For each identified object:
        a.  Determine if it forms a perfect rectangular frame:
            i.  Check if it has a uniform thickness (likely 1 pixel thick based on examples).
            ii. Check if all pixels forming the object constitute the perimeter of a rectangle.
            iii. Check if all pixels immediately inside this perimeter are white (value 0).
        b.  If the object is confirmed to be a complete, hollow rectangular frame:
            i.  Note the color of the frame.
            ii. Identify the bounding box of the frame.
            iii. Change the color of all white pixels located strictly within this bounding box to the color of the frame.
    3.  Leave all other objects and background pixels unchanged.
    4.  Output the modified grid.
```python
import numpy as np
from collections import deque

"""
Identifies distinct, single-color, hollow rectangular frames within the input grid 
and fills their white interiors with the color of the frame. All other pixels 
and objects remain unchanged.

A hollow rectangular frame is defined as:
1. A contiguous object of a single non-white color.
2. Its pixels perfectly form the perimeter of a rectangle.
3. All pixels strictly inside this perimeter are white (color 0).
4. The rectangle must have a minimum height and width of 3 pixels to enclose an interior.
"""

def find_object_pixels(grid, start_row, start_col, visited):
    """Finds all connected pixels of the same color using BFS."""
    rows, cols = grid.shape
    q = deque([(start_row, start_col)])
    color = grid[start_row, start_col]
    object_pixels = set()
    
    while q:
        r, c = q.popleft()
        
        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited or grid[r, c] != color:
            continue
            
        visited.add((r, c))
        object_pixels.add((r, c))
        
        # Add neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) not in visited:
                 q.append((nr, nc))
                 
    return object_pixels

def is_hollow_rectangle(grid, object_pixels):
    """
    Checks if a set of object pixels forms a hollow rectangle.
    Returns (is_hollow, min_row, max_row, min_col, max_col, color)
    """
    if not object_pixels:
        return False, -1, -1, -1, -1, -1

    rows = [r for r, c in object_pixels]
    cols = [c for r, c in object_pixels]
    
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    
    height = max_row - min_row + 1
    width = max_col - min_col + 1
    
    # Must be at least 3x3 to have an interior
    if height < 3 or width < 3:
        return False, -1, -1, -1, -1, -1

    # Get the color from one of the pixels
    first_pixel = next(iter(object_pixels))
    color = grid[first_pixel[0], first_pixel[1]]
    
    # Check 1: All object pixels must be on the bounding box perimeter
    for r, c in object_pixels:
        if not (r == min_row or r == max_row or c == min_col or c == max_col):
            return False, -1, -1, -1, -1, -1 # Pixel inside the boundary

    # Check 2: All expected perimeter pixels must be present and have the correct color
    expected_perimeter_pixels = set()
    # Top and bottom rows
    for c in range(min_col, max_col + 1):
        expected_perimeter_pixels.add((min_row, c))
        expected_perimeter_pixels.add((max_row, c))
    # Left and right columns (excluding corners already added)
    for r in range(min_row + 1, max_row):
        expected_perimeter_pixels.add((r, min_col))
        expected_perimeter_pixels.add((r, max_col))

    if object_pixels != expected_perimeter_pixels:
        return False, -1, -1, -1, -1, -1 # Missing perimeter pixel or extra pixel

    # Check 3: All interior pixels must be white (0)
    for r in range(min_row + 1, max_row):
        for c in range(min_col + 1, max_col):
            if grid[r, c] != 0:
                return False, -1, -1, -1, -1, -1 # Non-white pixel found inside

    # If all checks pass, it's a hollow rectangle
    return True, min_row, max_row, min_col, max_col, color


def fill_rectangle(output_grid, min_row, max_row, min_col, max_col, color):
    """Fills the interior of the specified rectangle with the given color."""
    for r in range(min_row + 1, max_row):
        for c in range(min_col + 1, max_col):
            output_grid[r, c] = color


def transform(input_grid):
    """
    Identifies hollow rectangles in the input grid and fills their interiors
    with the color of the rectangle's frame.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = input_grid_np.copy()
    rows, cols = input_grid_np.shape
    visited = set() # Keep track of pixels already assigned to an object

    # Iterate through each pixel to find potential objects
    for r in range(rows):
        for c in range(cols):
            # If pixel is non-white and hasn't been visited yet
            if input_grid_np[r, c] != 0 and (r, c) not in visited:
                # Find all connected pixels of the same color
                object_pixels = find_object_pixels(input_grid_np, r, c, visited)
                
                # Check if this object is a hollow rectangle
                is_hollow, min_r, max_r, min_c, max_c, frame_color = is_hollow_rectangle(input_grid_np, object_pixels)
                
                # If it is, fill its interior in the output grid
                if is_hollow:
                    fill_rectangle(output_grid, min_r, max_r, min_c, max_c, frame_color)

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
