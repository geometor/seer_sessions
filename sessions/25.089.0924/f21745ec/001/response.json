{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct, single-color, hollow rectangular frames within the input grid \nand fills their white interiors with the color of the frame. All other pixels \nand objects remain unchanged.\n\nA hollow rectangular frame is defined as:\n1. A contiguous object of a single non-white color.\n2. Its pixels perfectly form the perimeter of a rectangle.\n3. All pixels strictly inside this perimeter are white (color 0).\n4. The rectangle must have a minimum height and width of 3 pixels to enclose an interior.\n\"\"\"\n\ndef find_object_pixels(grid, start_row, start_col, visited):\n    \"\"\"Finds all connected pixels of the same color using BFS.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_row, start_col)])\n    color = grid[start_row, start_col]\n    object_pixels = set()\n    \n    while q:\n        r, c = q.popleft()\n        \n        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited or grid[r, c] != color:\n            continue\n            \n        visited.add((r, c))\n        object_pixels.add((r, c))\n        \n        # Add neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) not in visited:\n                 q.append((nr, nc))\n                 \n    return object_pixels\n\ndef is_hollow_rectangle(grid, object_pixels):\n    \"\"\"\n    Checks if a set of object pixels forms a hollow rectangle.\n    Returns (is_hollow, min_row, max_row, min_col, max_col, color)\n    \"\"\"\n    if not object_pixels:\n        return False, -1, -1, -1, -1, -1\n\n    rows = [r for r, c in object_pixels]\n    cols = [c for r, c in object_pixels]\n    \n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Must be at least 3x3 to have an interior\n    if height < 3 or width < 3:\n        return False, -1, -1, -1, -1, -1\n\n    # Get the color from one of the pixels\n    first_pixel = next(iter(object_pixels))\n    color = grid[first_pixel[0], first_pixel[1]]\n    \n    # Check 1: All object pixels must be on the bounding box perimeter\n    for r, c in object_pixels:\n        if not (r == min_row or r == max_row or c == min_col or c == max_col):\n            return False, -1, -1, -1, -1, -1 # Pixel inside the boundary\n\n    # Check 2: All expected perimeter pixels must be present and have the correct color\n    expected_perimeter_pixels = set()\n    # Top and bottom rows\n    for c in range(min_col, max_col + 1):\n        expected_perimeter_pixels.add((min_row, c))\n        expected_perimeter_pixels.add((max_row, c))\n    # Left and right columns (excluding corners already added)\n    for r in range(min_row + 1, max_row):\n        expected_perimeter_pixels.add((r, min_col))\n        expected_perimeter_pixels.add((r, max_col))\n\n    if object_pixels != expected_perimeter_pixels:\n        return False, -1, -1, -1, -1, -1 # Missing perimeter pixel or extra pixel\n\n    # Check 3: All interior pixels must be white (0)\n    for r in range(min_row + 1, max_row):\n        for c in range(min_col + 1, max_col):\n            if grid[r, c] != 0:\n                return False, -1, -1, -1, -1, -1 # Non-white pixel found inside\n\n    # If all checks pass, it's a hollow rectangle\n    return True, min_row, max_row, min_col, max_col, color\n\n\ndef fill_rectangle(output_grid, min_row, max_row, min_col, max_col, color):\n    \"\"\"Fills the interior of the specified rectangle with the given color.\"\"\"\n    for r in range(min_row + 1, max_row):\n        for c in range(min_col + 1, max_col):\n            output_grid[r, c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies hollow rectangles in the input grid and fills their interiors\n    with the color of the rectangle's frame.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n    visited = set() # Keep track of pixels already assigned to an object\n\n    # Iterate through each pixel to find potential objects\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-white and hasn't been visited yet\n            if input_grid_np[r, c] != 0 and (r, c) not in visited:\n                # Find all connected pixels of the same color\n                object_pixels = find_object_pixels(input_grid_np, r, c, visited)\n                \n                # Check if this object is a hollow rectangle\n                is_hollow, min_r, max_r, min_c, max_c, frame_color = is_hollow_rectangle(input_grid_np, object_pixels)\n                \n                # If it is, fill its interior in the output grid\n                if is_hollow:\n                    fill_rectangle(output_grid, min_r, max_r, min_c, max_c, frame_color)\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6891,
    "candidates_token_count": 1506,
    "total_token_count": 8397,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.911537,
  "retries": 1
}