{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport operator\n\n\"\"\"\nIdentifies all distinct, single-color objects in the input grid. Classifies \nobjects into 'simple hollow rectangles' (at least 3x3, pixels exactly form the \nbounding box perimeter, interior is all white) and 'other objects'. \nSelects one 'other object' as the pattern source based on the largest pixel \ncount (ties broken by top-most, then left-most bounding box corner). Extracts the \npattern from the interior of the pattern source's bounding box. Selects the two \n'simple hollow rectangles' with the largest bounding box area (ties broken by \ntop-most, then left-most corner). Tiles the extracted pattern into the interior \nof the selected target rectangles, using the color of each target rectangle's \nframe. Outputs the modified grid.\n\"\"\"\n\ndef find_object_pixels(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds all connected pixels (4-connectivity) of the same color starting \n    from (start_row, start_col) that haven't been visited yet.\n    Updates the visited set.\n    Returns:\n        - object_pixels (set): Set of (row, col) tuples for the object.\n        - color (int): The color index of the object.\n        - bbox (tuple): (min_row, min_col, max_row, max_col).\n        - pixel_count (int): Number of pixels in the object.\n    Returns (None, -1, None, 0) if the starting pixel is invalid (background or visited).\n    \"\"\"\n    rows, cols = grid.shape\n    color = grid[start_row, start_col]\n    \n    # Check if starting pixel is already visited or is background\n    if color == 0 or (start_row, start_col) in visited:\n        return None, -1, None, 0\n\n    q = deque([(start_row, start_col)])\n    object_pixels = set()\n    pixel_count = 0\n    min_r, min_c = start_row, start_col\n    max_r, max_c = start_row, start_col\n    \n    visited.add((start_row, start_col)) # Mark start as visited immediately\n\n    while q:\n        r, c = q.popleft()\n        \n        # Add to object and update bounds\n        object_pixels.add((r, c))\n        pixel_count += 1\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n        \n        # Add valid, unvisited neighbors of the same color to the queue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == color and (nr, nc) not in visited:\n                 visited.add((nr, nc)) # Mark neighbor as visited when adding to queue\n                 q.append((nr, nc))\n                 \n    bbox = (min_r, min_c, max_r, max_c)\n    return object_pixels, color, bbox, pixel_count\n\ndef is_simple_hollow_rectangle(grid, object_pixels, bbox):\n    \"\"\"\n    Checks if a set of object pixels forms a simple hollow rectangle.\n    Returns (is_hollow (bool), area (int) if hollow else 0).\n    \"\"\"\n    if not object_pixels: return False, 0\n    min_row, min_col, max_row, max_col = bbox\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Check 1: Minimum size 3x3\n    if height < 3 or width < 3: return False, 0\n\n    # Check 2: All object pixels must be exactly on the bounding box perimeter\n    expected_perimeter_pixels = set()\n    # Top and bottom rows\n    for c in range(min_col, max_col + 1):\n        expected_perimeter_pixels.add((min_row, c))\n        expected_perimeter_pixels.add((max_row, c))\n    # Left and right columns (excluding corners already added)\n    for r in range(min_row + 1, max_row):\n        expected_perimeter_pixels.add((r, min_col))\n        expected_perimeter_pixels.add((r, max_col))\n        \n    # Compare the actual object pixels with the expected perimeter pixels\n    if object_pixels != expected_perimeter_pixels:\n        return False, 0 \n\n    # Check 3: All interior pixels must be white (0)\n    for r in range(min_row + 1, max_row):\n        for c in range(min_col + 1, max_col):\n            if grid[r, c] != 0:\n                return False, 0 # Non-white pixel found inside\n\n    # If all checks pass, it's a simple hollow rectangle\n    area = height * width\n    return True, area\n\ndef extract_pattern_grid(grid, source_bbox):\n    \"\"\"\n    Extracts the 2D pattern from the interior of the source object's bounding box.\n    Returns a numpy array representing the pattern, or None if no interior exists.\n    \"\"\"\n    min_r, min_c, max_r, max_c = source_bbox\n    pattern_h = max_r - min_r - 1\n    pattern_w = max_c - min_c - 1\n\n    if pattern_h <= 0 or pattern_w <= 0:\n        return None # No interior to extract pattern from\n\n    pattern = grid[min_r + 1 : max_r, min_c + 1 : max_c]\n    return pattern\n\ndef tile_fill_interior(output_grid, target_bbox, target_color, pattern_grid):\n    \"\"\"\n    Fills the interior of the target rectangle by tiling the pattern grid.\n    Modifies output_grid in place.\n    \"\"\"\n    if pattern_grid is None or pattern_grid.size == 0:\n        return # Cannot fill if pattern is invalid or empty\n\n    min_r, min_c, max_r, max_c = target_bbox\n    pattern_h, pattern_w = pattern_grid.shape\n\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            # Calculate corresponding pattern coordinates using modulo\n            rel_r = r - (min_r + 1)\n            rel_c = c - (min_c + 1)\n            p_r = rel_r % pattern_h\n            p_c = rel_c % pattern_w\n\n            # Check the color in the pattern grid\n            pattern_pixel_color = pattern_grid[p_r, p_c]\n\n            # If the pattern pixel is not background (0), fill with target color\n            if pattern_pixel_color != 0:\n                output_grid[r, c] = target_color\n\n\ndef transform(input_grid):\n    # Convert input to numpy array and initialize output grid\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n    visited = set()\n    \n    all_objects = []\n\n    # 1. Identify and Classify Objects\n    for r in range(rows):\n        for c in range(cols):\n            pixels, color, bbox, pixel_count = find_object_pixels(input_grid_np, r, c, visited)\n            \n            if pixels: # If a valid object was found\n                is_hollow, area = is_simple_hollow_rectangle(input_grid_np, pixels, bbox)\n                all_objects.append({\n                    'pixels': pixels,\n                    'color': color,\n                    'bbox': bbox,\n                    'pixel_count': pixel_count,\n                    'is_hollow': is_hollow,\n                    'area': area if is_hollow else 0 # Store area only if hollow\n                })\n\n    # Separate into hollow rectangles and potential pattern sources\n    hollow_rects = [o for o in all_objects if o['is_hollow']]\n    other_objects = [o for o in all_objects if not o['is_hollow']]\n\n    # 2. Select Pattern Source\n    pattern_source_object = None\n    if other_objects:\n        # Sort by pixel_count (desc), min_row (asc), min_col (asc)\n        other_objects.sort(key=lambda x: (-x['pixel_count'], x['bbox'][0], x['bbox'][1]))\n        pattern_source_object = other_objects[0]\n\n    # 3. Extract Pattern\n    pattern_grid = None\n    if pattern_source_object:\n        pattern_grid = extract_pattern_grid(input_grid_np, pattern_source_object['bbox'])\n\n    # 4. Select Target Rectangles\n    target_rectangles = []\n    if hollow_rects:\n        # Sort by area (desc), min_row (asc), min_col (asc)\n        hollow_rects.sort(key=lambda x: (-x['area'], x['bbox'][0], x['bbox'][1]))\n        target_rectangles = hollow_rects[:2] # Select top two\n\n    # 5. Tile Fill Interiors\n    if pattern_grid is not None and pattern_grid.size > 0: # Check if pattern is valid\n        for target in target_rectangles:\n            tile_fill_interior(output_grid, target['bbox'], target['color'], pattern_grid)\n\n    # Convert back to list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27684,
    "candidates_token_count": 2355,
    "total_token_count": 30039,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.872576,
  "retries": 1
}