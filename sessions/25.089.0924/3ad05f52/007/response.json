{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nPerform a constrained flood fill operation on the input grid.\n1. Identify the unique 'fill color' which is not white (0) or azure (8).\n2. Identify all pixels with this 'fill color' in the input grid; these are the 'seed points'.\n3. Identify all white (0) pixels connected to the grid border without crossing any non-white pixels (including azure 8). Mark these as 'exterior white'.\n4. Starting from the seed points, perform a 4-way flood fill on the grid.\n5. The fill operation changes white (0) pixels to the 'fill color' *only if* the white pixel is *not* marked as 'exterior white'.\n6. The fill stops at the grid boundaries, at pixels with the azure (8) color (or any other non-white pixel), and at 'exterior white' pixels.\n7. The output grid is the input grid after the constrained flood fill operation.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a constrained flood fill transformation based on a unique seed color\n    bounded by azure (8), ensuring the fill does not leak into exterior white areas.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # --- Find the unique fill color and seed points ---\n    fill_color = -1\n    unique_colors = np.unique(input_grid)\n\n    # Iterate through unique colors to find the one that's not background (0) or boundary (8)\n    for color in unique_colors:\n        if color != 0 and color != 8:\n            fill_color = color\n            break # Assume only one such color based on problem description\n\n    # If no specific fill color found (grid might be only 0s and 8s, or just 0s), return original\n    if fill_color == -1:\n        return output_grid\n\n    # Find all initial locations of the fill color in the input grid\n    seed_points_coords = np.where(input_grid == fill_color)\n    seed_points = list(zip(seed_points_coords[0], seed_points_coords[1]))\n\n    # If no seed points found for the determined fill_color, return original\n    if not seed_points:\n         return output_grid\n\n    # --- Identify Exterior White Pixels ---\n    is_exterior = np.zeros((height, width), dtype=bool)\n    exterior_queue = deque()\n\n    # Check border cells and add starting points for the exterior BFS\n    for r in range(height):\n        for c in [0, width - 1]:\n            # If a border cell is white (0) and not already marked\n            if input_grid[r, c] == 0 and not is_exterior[r, c]:\n                is_exterior[r, c] = True\n                exterior_queue.append((r, c))\n    for c in range(1, width - 1): # Avoid double-checking corners\n        for r in [0, height - 1]:\n            if input_grid[r, c] == 0 and not is_exterior[r, c]:\n                is_exterior[r, c] = True\n                exterior_queue.append((r, c))\n\n    # BFS to find all white pixels connected to the border\n    while exterior_queue:\n        r, c = exterior_queue.popleft()\n        # Explore 4-way neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # If neighbor is white in the *original input* and not yet marked as exterior\n                if input_grid[nr, nc] == 0 and not is_exterior[nr, nc]:\n                    is_exterior[nr, nc] = True\n                    exterior_queue.append((nr, nc))\n\n    # --- Perform Constrained Flood Fill (using BFS) ---\n    fill_queue = deque(seed_points)\n    # Initialize visited set. Crucially, include all seed points AND all exterior white points.\n    # This prevents the fill from starting in or spreading into the exterior region.\n    visited = set(seed_points)\n    exterior_coords = np.where(is_exterior)\n    visited.update(zip(exterior_coords[0], exterior_coords[1]))\n\n\n    while fill_queue:\n        r, c = fill_queue.popleft()\n\n        # Explore 4-way neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid boundaries\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor hasn't been visited yet (this implicitly handles boundaries like 8 and exterior white cells)\n                if (nr, nc) not in visited:\n                    # Check if the neighbor is a fillable area (white color 0 in the *output grid*)\n                    # We only need to check if it's 0, because the 'visited' check already\n                    # filters out boundaries(8), exterior white, and already filled cells.\n                    if output_grid[nr, nc] == 0:\n                         # Fill the pixel\n                        output_grid[nr, nc] = fill_color\n                        # Mark as visited\n                        visited.add((nr, nc))\n                        # Add to queue for further exploration\n                        fill_queue.append((nr, nc))\n                    else:\n                        # If it's not white (0), it must be a boundary (8) or some other non-fillable color.\n                        # Mark it as visited anyway to avoid checking it again from another path.\n                         visited.add((nr, nc))\n\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27084,
    "candidates_token_count": 1438,
    "total_token_count": 28522,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.927072,
  "retries": 1
}