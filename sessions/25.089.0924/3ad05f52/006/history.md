
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0
0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 6 6 6 8 0 0 0
0 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 8 0 0 0
0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 6 6 6 8 0 0 0
0 0 8 8 8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0
0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 0 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 8 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 0 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 8 0 0 0 8 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0
0 0 8 0 0 0 8 6 6 6 8 6 6 6 8 6 6 6 8 6 6 6 8 0 0 0
0 0 8 0 0 0 8 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 8 0 0 0
0 0 8 0 0 0 8 6 6 6 8 6 6 6 8 6 6 6 8 6 6 6 8 0 0 0
0 0 8 8 8 8 8 8 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0
0 0 0 0 0 0 8 6 6 6 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 6 6 6 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 6 6 6 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 6 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 6 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 6 6 6 8 6 6 6 8 6 6 6 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 6 6 6 6 6 6 6 6 6 6 6 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 6 6 6 8 6 6 6 8 6 6 6 8 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 6 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 8 6 6 6 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 6 6 6 6 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 6 6 6 8 6 6 6 8 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 0 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 0 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 0 8 8 0 0 0 0 0 0 8 8 0 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 0 8 8 0 0 0 0 0 0 8 8 0 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 0 8 8 8 8 8 8 0 0 0 0 0 0 8 8 0 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 4
0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 4
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 4
0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
```


**output:**
```
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 4 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 4 4 4 8 4 4 4 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 4 4 4 4 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 4 4 4 8 4 4 4 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 4 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 4 4 4 8 0 0 0 0 0 0 8 4 4 4 8 0
0 0 0 8 0 0 0 8 4 4 4 8 4 4 4 4 4 4 4 4 4 4 8 0
0 0 0 8 0 0 0 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 8 8 8 8 8 4 8 8 4 4 4 4 4 4 8 8 4 8 8 8
0 0 0 8 0 0 0 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 0 0 0 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 0 0 0 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 8 8 8 8 8 4 8 8 4 4 4 4 4 4 8 8 4 8 8 8
0 0 0 8 4 4 4 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 4 4 4 4 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 4 4 4 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 0
0 0 0 8 8 4 8 8 8 8 8 8 4 4 4 4 4 4 8 8 4 8 8 8
0 0 0 8 4 4 4 8 4 4 4 8 4 4 4 4 4 4 8 4 4 4 8 4
0 0 0 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4 4
0 0 0 8 4 4 4 8 4 4 4 8 0 0 0 0 0 0 8 4 4 4 8 4
0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8
0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 0 0 0 8 0 0 0 8 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 0 8 8 8 0 0 0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 8 0 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 3 3 3 8 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 0 8 8 8 0 0 0 0 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 3 3 3 3 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 3 3 3 3 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 3 3 3 3 3 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 3 3 3 3 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 3 3 3 3 8 3 3 3 3 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 3 8 8 8 0 0 0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 0 0 0 0 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 3 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 8 8 3 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 8 3 3 3 8 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 3 8 8 8 3 3 3 3 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 8 3 3 3 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 3 3 3 3 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 3 3 3 3 3 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 0 0 8 3 3 3 3 3 8 0 0 0 0 8 0 0 0 8 0 0 0 0
0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The task involves identifying enclosed regions defined by azure (8) pixels and performing a flood fill operation within these regions. The color used for filling and the starting points (seeds) for the fill are determined by the unique non-white (0), non-azure (8) color present in the input grid.

*   **YAML Facts:**
    
```yaml
    task_type: flood_fill
    elements:
      - object: background
        color: white (0)
        role: default_empty_space
      - object: boundary
        color: azure (8)
        role: defines_regions_limits_fill
      - object: fillable_area
        color: white (0)
        location: adjacent_to_seeds_and_within_boundaries
        role: target_for_filling
      - object: seed_and_fill_color
        color: dynamic (magenta(6)/yellow(4)/green(3) in examples)
        role: determines_fill_color_and_provides_start_points
        identification: the_unique_color_that_is_not_white_or_azure
    action:
      type: flood_fill
      parameters:
        - start_points: pixels_of_seed_and_fill_color_in_input
        - target_color: white (0)
        - fill_color: color_of_seed_and_fill_color
        - boundary_color: azure (8)
      connectivity: 4-way_adjacency (up, down, left, right)
      constraint: fill_does_not_cross_boundary_color_or_grid_edges
    output_grid_generation:
      process: apply_flood_fill_to_input_grid
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Scan the input grid to find the unique color that is not white (0) and not azure (8). This color is the 'fill color'.
    3.  Identify all pixels in the input grid that have the 'fill color'. These locations are the 'seed points'.
    4.  Create a queue or stack and add all 'seed points' to it. Maintain a set of visited locations to avoid redundant processing, initially containing the seed points.
    5.  While the queue/stack is not empty:
        a.  Dequeue/pop a location (row, col).
        b.  For each of its 4-way adjacent neighbors (up, down, left, right):
            i.  Check if the neighbor is within the grid boundaries.
            ii. Check if the neighbor has not been visited yet.
            iii. Check if the neighbor's color in the *output grid* is white (0).
            iv. If all checks pass:
                1. Change the neighbor's color in the output grid to the 'fill color'.
                2. Mark the neighbor as visited.
                3. Enqueue/push the neighbor's location.
    6.  Return the modified output grid.
```python
"""
Perform a flood fill operation on the input grid.
1. Identify the unique 'fill color' which is not white (0) or azure (8).
2. Identify all pixels with this 'fill color' in the input grid; these are the 'seed points'.
3. Starting from the seed points, perform a 4-way flood fill on the grid.
4. The fill operation changes white (0) pixels to the 'fill color'.
5. The fill stops at the grid boundaries and at pixels with the azure (8) color.
6. The output grid is the input grid after the flood fill operation.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Applies a flood fill transformation based on a unique seed color bounded by azure.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed grid.
    """
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # --- Find the unique fill color and seed points ---
    fill_color = -1
    seed_points = []
    unique_colors = np.unique(input_grid)

    for color in unique_colors:
        if color != 0 and color != 8:
            fill_color = color
            break # Assume only one such color based on problem description

    if fill_color == -1:
        # No fill color found, return the original grid
        return output_grid

    # Find all initial locations of the fill color
    seed_points = list(zip(*np.where(input_grid == fill_color)))

    if not seed_points:
         # No seed points found, return the original grid
        return output_grid

    # --- Perform Flood Fill (using BFS) ---
    queue = deque(seed_points)
    visited = set(seed_points) # Keep track of visited cells to avoid cycles and redundant work

    while queue:
        r, c = queue.popleft()

        # Explore 4-way neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor hasn't been visited
                if (nr, nc) not in visited:
                     # Check if the neighbor is a fillable area (white color 0 in the *output* grid)
                     # We check the output_grid because it's being modified during the fill.
                     # Boundary color 8 implicitly stops the fill as it's not 0.
                    if output_grid[nr, nc] == 0:
                        # Change color in the output grid
                        output_grid[nr, nc] = fill_color
                        # Mark as visited
                        visited.add((nr, nc))
                        # Add to queue for further exploration
                        queue.append((nr, nc))
                    else:
                        # If it's not white (0), it's either a boundary (8) or already filled (fill_color)
                        # or some other color we shouldn't touch. Mark it as visited so we don't check it again
                        # from another path, especially important if it's the boundary color.
                        visited.add((nr, nc))


    return output_grid
```
```python
"""
Perform a constrained flood fill operation on the input grid.
1. Identify the unique 'fill color' which is not white (0) or azure (8).
2. Identify all pixels with this 'fill color' in the input grid; these are the 'seed points'.
3. Identify all white (0) pixels connected to the grid border without crossing any non-white pixels. Mark these as 'exterior white'.
4. Starting from the seed points, perform a 4-way flood fill on the grid.
5. The fill operation changes white (0) pixels to the 'fill color' *only if* the white pixel is *not* marked as 'exterior white'.
6. The fill stops at the grid boundaries, at pixels with the azure (8) color, and at 'exterior white' pixels.
7. The output grid is the input grid after the constrained flood fill operation.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # --- Find the unique fill color and seed points ---
    fill_color = -1
    seed_points = []
    unique_colors = np.unique(input_grid)

    for color in unique_colors:
        if color != 0 and color != 8: # 0 is white (background), 8 is azure (boundary)
            fill_color = color
            break # Assume only one such color based on problem description

    # If no specific fill color found (grid might be only 0s and 8s), return original
    if fill_color == -1:
        return output_grid

    # Find all initial locations of the fill color
    seed_points = list(zip(*np.where(input_grid == fill_color)))

    # If no seed points found, return original
    if not seed_points:
        return output_grid

    # --- Identify Exterior White Pixels ---
    is_exterior = np.zeros((height, width), dtype=bool)
    exterior_queue = deque()

    # Check border cells
    for r in range(height):
        for c in [0, width - 1]:
             if input_grid[r, c] == 0 and not is_exterior[r, c]:
                is_exterior[r, c] = True
                exterior_queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
             if input_grid[r, c] == 0 and not is_exterior[r, c]:
                is_exterior[r, c] = True
                exterior_queue.append((r, c))

    # BFS for exterior white pixels
    while exterior_queue:
        r, c = exterior_queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if input_grid[nr, nc] == 0 and not is_exterior[nr, nc]:
                    is_exterior[nr, nc] = True
                    exterior_queue.append((nr, nc))

    # --- Perform Constrained Flood Fill (using BFS) ---
    fill_queue = deque(seed_points)
    # Initialize visited with seed points AND all exterior white points
    # We don't want the main fill to process exterior points at all.
    visited = set(seed_points)
    visited.update(zip(*np.where(is_exterior)))

    while fill_queue:
        r, c = fill_queue.popleft()

        # Explore 4-way neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor hasn't been visited yet
                if (nr, nc) not in visited:
                    # Check if the neighbor is a fillable area:
                    # Must be white (0) in the *output grid* (which starts as input)
                    # AND must NOT be an exterior white cell.
                    if output_grid[nr, nc] == 0 and not is_exterior[nr, nc]:
                        # Change color in the output grid
                        output_grid[nr, nc] = fill_color
                        # Mark as visited
                        visited.add((nr, nc))
                        # Add to queue for further exploration
                        fill_queue.append((nr, nc))
                    else:
                        # If it's not a fillable white cell (e.g., boundary 8, already filled, exterior white)
                        # mark it as visited so we don't check it again from another path.
                        visited.add((nr, nc))


    return output_grid
```
```python
import numpy as np
from collections import deque

"""
Perform a flood fill operation on the input grid.
1. Identify the unique 'fill color' which is not white (0) or azure (8).
2. Identify all pixels with this 'fill color' in the input grid; these are the 'seed points'.
3. Starting from the seed points, perform a 4-way flood fill on the grid.
4. The fill operation changes white (0) pixels to the 'fill color'.
5. The fill stops at the grid boundaries and at pixels with the azure (8) color (or any color other than white).
6. The output grid is the input grid after the flood fill operation.
"""

def transform(input_grid):
    """
    Applies a flood fill transformation based on a unique seed color bounded by azure.

    Args:
        input_grid (np.ndarray): A 2D numpy array representing the input grid.

    Returns:
        np.ndarray: A 2D numpy array representing the transformed grid.
    """
    # Initialize output_grid as a copy of the input grid
    output_grid = np.copy(input_grid)
    height, width = output_grid.shape

    # --- Find the unique fill color and seed points ---
    fill_color = -1
    seed_points = []
    unique_colors = np.unique(input_grid)

    # Iterate through unique colors to find the one that's not background (0) or boundary (8)
    for color in unique_colors:
        if color != 0 and color != 8:
            fill_color = color
            break # Assume only one such color based on problem description

    # If no specific fill color found (grid might be only 0s and 8s, or just 0s), return original
    if fill_color == -1:
        return output_grid

    # Find all initial locations of the fill color in the input grid
    seed_points_coords = np.where(input_grid == fill_color)
    seed_points = list(zip(seed_points_coords[0], seed_points_coords[1]))

    # If no seed points found for the determined fill_color, return original
    if not seed_points:
         return output_grid

    # --- Perform Flood Fill (using BFS) ---
    queue = deque(seed_points)
    visited = set(seed_points) # Keep track of visited cells to avoid cycles and redundant work

    while queue:
        r, c = queue.popleft()

        # Explore 4-way neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within grid boundaries
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor hasn't been visited yet
                if (nr, nc) not in visited:
                     # Check if the neighbor is a fillable area (white color 0 in the *output grid*)
                     # We check the output_grid because it's being modified during the fill.
                     # The boundary color 8 (and any other non-zero color) implicitly stops the fill
                     # because it won't satisfy 'output_grid[nr, nc] == 0'.
                    if output_grid[nr, nc] == 0:
                        # Change color in the output grid
                        output_grid[nr, nc] = fill_color
                        # Mark as visited
                        visited.add((nr, nc))
                        # Add to queue for further exploration
                        queue.append((nr, nc))
                    else:
                        # If it's not white (0), it's either a boundary (8) or already filled (fill_color)
                        # or some other color we shouldn't touch. Mark it as visited so we don't check it again
                        # from another path. This prevents unnecessary checks and potential issues if
                        # the fill could somehow bypass a boundary otherwise.
                        visited.add((nr, nc))

    # Return the modified grid
    return output_grid
```
