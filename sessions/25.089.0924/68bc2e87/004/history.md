
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
8 3 8 6 8 3 8 8 8 8 8 8 8 8 8 8 8 8 6
8 3 8 6 8 3 8 4 4 4 4 8 5 5 5 8 8 8 6
8 3 8 6 8 3 8 4 8 8 4 8 5 8 5 8 8 8 6
8 3 8 6 8 3 8 4 8 2 2 2 5 2 5 2 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 5 8 5 8 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 5 5 5 8 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 8 8 8 8 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 8 8 8 8 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 8 8 8 8 2 8 6
8 3 8 6 8 3 8 4 8 2 4 8 8 8 8 8 2 8 6
8 3 8 6 6 6 6 4 6 2 4 6 6 6 6 6 2 6 6
8 3 8 8 8 3 8 4 8 2 2 2 2 2 2 2 2 8 8
8 3 3 3 3 3 8 4 4 4 4 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
3
6
4
2
5
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8
8 7 8 8 8 8 8 8 8 7 8 8 8 8 8 8 8 8 8
8 7 8 8 3 3 3 3 3 7 3 3 3 3 3 3 8 8 8
8 7 8 8 3 8 8 8 8 7 8 8 8 8 8 3 8 8 8
8 7 8 8 3 8 8 6 6 6 6 6 8 8 8 3 8 8 8
8 7 7 7 7 7 7 6 7 7 8 6 8 8 8 3 8 8 8
8 8 8 8 3 8 8 6 8 8 8 6 8 8 8 3 8 8 8
8 8 2 2 3 2 2 6 2 2 2 6 2 2 2 3 2 8 8
8 8 2 8 3 8 8 6 8 8 8 6 8 8 8 3 2 8 8
8 8 2 8 3 8 8 6 6 6 9 9 9 8 8 3 2 8 8
8 8 2 8 3 8 8 8 8 8 9 9 9 8 8 3 2 8 8
8 8 2 8 3 8 8 8 8 8 8 8 8 8 8 3 2 8 8
8 8 2 8 3 3 3 3 3 3 3 3 3 3 3 3 2 8 8
8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
2
3
7
6
9
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 8
8 8 8 3 8 8 8 8 8 8 8 8 8 8 8 3 8 8 8
8 8 8 3 8 8 8 4 4 4 4 4 8 8 8 3 8 8 8
8 2 2 3 2 2 2 4 2 2 2 4 2 2 2 3 2 8 8
8 2 8 3 8 8 8 4 8 8 8 4 8 8 8 3 2 8 8
8 2 8 3 8 6 6 4 6 6 6 4 6 6 8 3 2 8 8
8 2 8 3 8 6 8 4 4 4 4 4 8 6 8 3 2 8 8
8 2 8 3 8 6 8 8 8 8 8 8 8 6 8 3 2 8 8
8 2 2 3 2 6 2 2 2 2 2 2 2 6 2 3 2 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 8 6 8 8 8 8 8 8 8 6 8 3 8 8 8
8 8 8 3 3 6 3 3 3 3 3 3 3 6 3 3 8 8 8
8 8 8 8 8 6 6 6 6 6 6 6 6 6 8 8 8 8 8
```


**output:**
```
2
3
6
4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 1 8 8 2 8 1 8 8 8 8 8 8 8 8 2 8 8
8 8 1 8 8 2 8 1 8 8 8 8 8 8 8 8 2 8 8
8 8 1 1 1 2 1 1 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 2 8 8 8 4 4 4 4 4 8 8 2 8 8
8 8 8 8 8 2 8 8 8 4 8 8 8 4 8 8 2 8 8
8 8 8 8 8 2 2 2 2 4 2 2 2 4 2 2 2 8 8
8 8 8 8 8 8 8 8 8 4 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 4 8 6 6 6 6 8 8 8 8
8 8 8 8 8 8 8 8 8 4 8 6 8 4 6 8 8 8 8
8 8 8 8 8 8 8 8 8 4 4 6 4 4 6 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 6 8 8 6 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 6 6 6 6 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
1
2
4
6
```

*   **Perception:** The input is a grid containing several nested, frame-like shapes made of different colors, all enclosed within an outermost azure (8) border. The shapes are contiguous blocks of a single color (other than azure or white). The output is a vertical list of colors. The task seems to require identifying the colors of these nested shapes and listing them in order from the outermost shape to the innermost shape.

*   **Facts:**
    
```yaml
    elements:
      - type: grid
        description: Input grid containing pixels of different colors (0-9).
        properties:
          size: Variable height and width (up to 30x30).
          border: Typically surrounded by an azure (8) border.
          content: Contains nested, frame-like objects made of single colors (non-azure, non-white).
      - type: object
        description: A contiguous block of pixels of the same color, excluding azure (8) and white (0).
        properties:
          color: A single digit from 1-7 or 9.
          shape: Generally forms a hollow rectangle or frame, but can be irregular.
          nesting: Objects are nested within each other, forming layers.
      - type: list
        description: Output list containing color values.
        properties:
          orientation: Vertical (single column).
          content: Sequence of colors corresponding to the nested objects.
          order: From outermost object color to innermost object color.

    relationships:
      - type: nesting
        description: Colored objects are nested one inside the other.
        relationship: object_1 encloses object_2, object_2 encloses object_3, etc.
      - type: adjacency
        description: The outermost colored object is adjacent (shares an edge or corner) to the azure (8) border. Subsequent inner objects are adjacent to the previously identified outer object.

    transformation:
      - action: identify_layers
        description: Sequentially identify the colored objects starting from the one adjacent to the azure border and moving inwards.
      - action: extract_color
        description: Get the color of each identified object layer.
      - action: order_colors
        description: Arrange the extracted colors based on the nesting order (outermost to innermost).
      - action: format_output
        description: Present the ordered colors as a single-column grid.

    ```


*   **Natural Language Program:**
    1.  Initialize an empty list to store the colors of the nested layers.
    2.  Create a working copy of the input grid. Define the initial "outside" region as all azure (8) pixels in the grid.
    3.  Start a loop that continues as long as new layers can be identified:
        a.  Scan the `working_grid` to find any non-azure (8), non-white (0) pixel that is adjacent (horizontally, vertically, or diagonally) to any pixel currently designated as "outside".
        b.  If no such pixel is found, exit the loop.
        c.  If found, let the color of this pixel be `C`. Identify the complete contiguous object `O` consisting of pixels of color `C` connected to the found pixel.
        d.  Add the color `C` to the list of nested colors.
        e.  Update the `working_grid` by changing all pixels belonging to object `O` to azure (8), effectively merging this object into the "outside" region for the next iteration.
    4.  Return the collected list of nested colors, formatted as a single-column grid.
```python
import numpy as np
from collections import deque

"""
Identifies nested, frame-like objects of non-azure (8) and non-white (0) colors within an input grid. 
The identification starts from the outermost object adjacent to the initial azure (8) pixels 
(typically the border) and proceeds inwards. The colors of these identified objects are collected 
in order from outermost to innermost. The final output is a single-column grid containing these colors.

Workflow:
1. Initialize an empty list to store the colors of the nested layers.
2. Create a working copy of the input grid.
3. Repeatedly find the next outermost layer:
    a. Scan the grid for a non-azure, non-white pixel adjacent (including diagonals) to an azure pixel.
    b. If no such pixel is found, stop.
    c. If found, record its color. This is the color of the current layer.
    d. Perform a flood fill (BFS) starting from the found pixel to identify all connected pixels of the same color.
    e. Change the color of all pixels belonging to this layer to azure (8) in the working grid. This merges the layer into the "outside" region for the next iteration.
4. Convert the collected list of colors into a single-column NumPy array.
5. Return the resulting array.
"""

def transform(input_grid):
    """
    Transforms the input grid by finding nested colored layers and outputting their colors in order.

    Args:
        input_grid (list of lists): The input grid represented as a list of lists of integers.

    Returns:
        numpy.ndarray: A 2D NumPy array representing the output grid (single column).
    """
    working_grid = np.array(input_grid, dtype=int)
    height, width = working_grid.shape
    nested_colors = []

    while True:
        found_layer = False
        layer_color = -1
        start_pixel = None

        # 1. Find a pixel of the next layer adjacent to the current "outside" (azure pixels)
        for r in range(height):
            for c in range(width):
                current_color = working_grid[r, c]
                # Ignore background (azure) and white pixels
                if current_color != 8 and current_color != 0:
                    # Check 8 neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue # Skip self
                            nr, nc = r + dr, c + dc
                            # Check if neighbor is within bounds
                            if 0 <= nr < height and 0 <= nc < width:
                                # If neighbor is azure (part of the outside)
                                if working_grid[nr, nc] == 8:
                                    layer_color = current_color
                                    start_pixel = (r, c)
                                    found_layer = True
                                    break # Found adjacency, stop checking neighbors
                        if found_layer: break # Stop checking columns for this row
                    if found_layer: break # Stop checking rows
            if found_layer: break # Stop iterating through grid completely

        # 2. If no more layers found adjacent to the outside, exit the loop
        if not found_layer:
            break

        # 3. Add the found layer's color to the list
        nested_colors.append(layer_color)

        # 4. Flood fill the identified layer, changing its color to azure (8)
        #    This merges the layer into the "outside" for the next iteration.
        queue = deque([start_pixel])
        visited_layer = {start_pixel} # Keep track of pixels added to queue for this layer
        working_grid[start_pixel[0], start_pixel[1]] = 8 # Change color immediately

        while queue:
            curr_r, curr_c = queue.popleft()

            # Explore 8 neighbors
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = curr_r + dr, curr_c + dc

                    # Check bounds, if neighbor has the layer_color, and hasn't been visited *in this layer's fill*
                    if 0 <= nr < height and 0 <= nc < width and \
                       working_grid[nr, nc] == layer_color and \
                       (nr, nc) not in visited_layer:
                        
                        working_grid[nr, nc] = 8 # Change color to azure
                        visited_layer.add((nr, nc))
                        queue.append((nr, nc))

    # 5. Format the output as a single-column grid
    if not nested_colors:
        # Handle case where no layers are found (e.g., empty grid or only azure/white)
        output_grid = np.empty((0, 1), dtype=int)
    else:
        output_grid = np.array(nested_colors, dtype=int).reshape(-1, 1)

    return output_grid
```
```python
import numpy as np
from collections import deque

"""
Identifies nested layers of colors in a grid and outputs the colors in order from outermost to innermost.

The transformation works by repeatedly finding the layer of color directly adjacent to the current "outside" region,
which initially consists of all azure (8) pixels. It uses a Breadth-First Search (BFS) approach starting from the
current "outside" pixels.

1. Initialize the "outside" region with all azure (8) pixels.
2. Perform a BFS starting from the current "outside" pixels.
3. Identify the first non-azure (8), non-white (0) pixel encountered during the BFS. The color of this pixel
   is the color of the next layer.
4. Record this layer color.
5. Find all connected pixels belonging to this layer (same color) using a flood fill (secondary BFS).
6. "Absorb" this layer into the "outside" region by changing the color of all its pixels to azure (8) in a
   working copy of the grid.
7. Add the pixels of the absorbed layer to the set of pixels to start the *next* BFS from.
8. Repeat steps 2-7 until no more non-azure, non-white pixels are found adjacent to the "outside" region.
9. Output the recorded layer colors as a single-column grid.
"""

def find_object_pixels(grid, start_r, start_c, target_color):
    """
    Finds all connected pixels of a target_color starting from (start_r, start_c) using BFS.
    Considers 8-way adjacency (including diagonals).

    Args:
        grid (np.ndarray): The grid to search within.
        start_r (int): Starting row.
        start_c (int): Starting column.
        target_color (int): The color of the object to find.

    Returns:
        set: A set of (row, col) tuples representing the pixels of the object.
    """
    height, width = grid.shape
    object_pixels = set()
    queue = deque([(start_r, start_c)])
    visited_local = set([(start_r, start_c)])

    while queue:
        r, c = queue.popleft()
        object_pixels.add((r, c))

        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                pixel = (nr, nc)

                if 0 <= nr < height and 0 <= nc < width and \
                   grid[nr, nc] == target_color and \
                   pixel not in visited_local:
                    visited_local.add(pixel)
                    queue.append(pixel)

    return object_pixels


def transform(input_grid):
    """
    Transforms the input grid by finding nested colored layers and outputting their colors in order.

    Args:
        input_grid (list of lists): The input grid represented as a list of lists of integers.

    Returns:
        numpy.ndarray: A 2D NumPy array representing the output grid (single column).
    """
    working_grid = np.array(input_grid, dtype=int)
    height, width = working_grid.shape
    nested_colors = []
    
    # master_visited tracks all pixels that are part of the 'outside' (azure) or already processed layers
    master_visited = set() 
    
    # queue stores pixels to start the BFS expansion from (initially all azure pixels)
    queue = deque()

    # Initialize queue and visited set with all azure pixels
    for r in range(height):
        for c in range(width):
            if working_grid[r, c] == 8:
                if (r, c) not in master_visited:
                    queue.append((r, c))
                    master_visited.add((r, c))

    # Main loop: process one layer per iteration
    while True:
        # next_layer_candidates stores the first pixel found for each color adjacent to the current 'outside'
        # We only need one candidate to identify the next layer's color and start the flood fill
        next_layer_candidate = None # tuple: (color, (r, c))
        
        # current_expansion_queue holds pixels from the current 'outside' boundary for this BFS level
        current_expansion_queue = queue 
        queue = deque() # Prepare queue for the *next* iteration (will be filled with absorbed layer pixels)
        
        processed_in_bfs_level = set() # Track pixels added to queue in this BFS level to prevent duplicates within the level

        if not current_expansion_queue:
            # If no pixels to expand from, we are done
            break

        # Perform BFS expanding from the current 'outside' region
        while current_expansion_queue:
            r, c = current_expansion_queue.popleft()

            # Check 8 neighbors
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = r + dr, c + dc
                    pixel = (nr, nc)

                    if 0 <= nr < height and 0 <= nc < width and pixel not in master_visited:
                        color = working_grid[nr, nc]

                        if color == 8: 
                            # Still expanding the azure 'outside', add to the next iteration's queue if not already added
                             if pixel not in processed_in_bfs_level:
                                queue.append(pixel) 
                                master_visited.add(pixel)
                                processed_in_bfs_level.add(pixel)
                        elif color != 0: 
                            # Found a non-azure, non-white pixel - potential layer candidate
                            if next_layer_candidate is None:
                                next_layer_candidate = (color, pixel)
                            # Mark as visited immediately to avoid reprocessing in this BFS level,
                            # but it will be properly processed if chosen as the layer
                            master_visited.add(pixel) 
                            processed_in_bfs_level.add(pixel) # Track adding to master_visited here
                        else: # color == 0 (white)
                             # Treat white like azure for expansion, add to visited but not typically to queue unless needed
                             master_visited.add(pixel)
                             processed_in_bfs_level.add(pixel)


        # Check if a layer candidate was found in this BFS level
        if next_layer_candidate is None:
            # No non-azure/non-white pixels found adjacent to the current outside
            # If the next queue is also empty, we're truly done
            if not queue:
                break
            # Otherwise, continue to the next iteration with the expanded azure queue
            continue 

        # A layer was found
        layer_color, start_pixel = next_layer_candidate
        nested_colors.append(layer_color)

        # Find all pixels of this layer object
        object_pixels = find_object_pixels(working_grid, start_pixel[0], start_pixel[1], layer_color)

        # Absorb the object: change color in working grid, ensure all its pixels are in master_visited,
        # and add them all to the queue for the next iteration's BFS expansion.
        for r_obj, c_obj in object_pixels:
            working_grid[r_obj, c_obj] = 8 # Change color
            if (r_obj, c_obj) not in master_visited:
                 # This check might be redundant if find_object_pixels only returns pixels of layer_color
                 # and the start_pixel was already added to master_visited, but safe to keep.
                 master_visited.add((r_obj, c_obj))
            # Add all object pixels to the queue for the *next* expansion phase
            if (r_obj, c_obj) not in processed_in_bfs_level: # Avoid adding duplicates to the next queue
                 queue.append((r_obj, c_obj))
                 processed_in_bfs_level.add((r_obj, c_obj)) # Mark as added for *this* overall iteration


    # Format the output
    if not nested_colors:
        output_grid = np.empty((0, 1), dtype=int)
    else:
        output_grid = np.array(nested_colors, dtype=int).reshape(-1, 1)

    return output_grid
```
