
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 2 3 2 3 2 3 2 3
8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8
8 8 8 8 8 8 8 8 8 1 1 1 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 1 8 8 8 8 8 2 8 8 8
8 8 8 1 1 1 2 3 2 3 4 3 2 3
8 8 8 8 1 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8
8 8 8 8 8 8 8 8 8 1 1 1 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 1 1 8 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 8 1 1 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 4 2 8 8 8
8 8 1 1 8 8 8 8 4 2 8 8 8
8 1 1 1 1 8 8 8 4 2 8 8 8
8 1 1 1 1 8 8 8 4 2 8 8 8
8 1 1 1 1 8 8 8 4 2 8 8 8
8 8 1 1 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 4 2 8 8 8
8 8 2 3 8 8 8 8 1 1 8 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 1 1 1 1 8 8
8 8 2 3 8 8 8 8 1 1 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
8 8 2 3 8 8 8 8 8 8 8 8 8
```

## Perception

The task involves transforming an input grid based on specific patterns and relationships between objects within the grid. The input grids consistently feature an azure (8) background, two distinct blue (1) shapes (often different from each other), and one or more other small structures or single pixels near the blue shapes.

The core transformation focuses on the "lower" of the two blue shapes. Specific non-blue, non-background pixels located immediately adjacent to the top of this lower blue shape act as "source colors". These source pixels are removed in the output.

A new vertical line is generated in the output grid. The characteristics of this line (location, height, color pattern) are determined by the properties of the source colors and the lower blue shape:
1.  **Location (Column):** The column index of the new line corresponds to the column of a specific source pixel (typically the one with the lowest row index, and then lowest column index if rows are tied).
2.  **Height:** The height of the new line is determined by the row index of the highest point of the lower blue shape. The line starts from row 0 and extends downwards for this height.
3.  **Color Pattern:** The new line consists of an alternating sequence of the two source colors. The order of alternation (which color starts the sequence) depends on the relative positions (row and column) of the source pixels in the input.
4.  **Other Elements:** The upper blue shape and any other distinct structures (like the vertical red/green lines seen in the examples) remain unchanged in the output grid.

## Facts


```yaml
background_color: azure (8)

objects:
  - type: blue_shape
    count: 2
    attributes:
      - color: blue (1)
      - role:
          - one acts as an upper reference (unchanged)
          - one acts as a lower reference (determines transformation parameters)
  - type: source_pixel
    count: 2 (typically)
    attributes:
      - color: non-blue (1), non-azure (8) (e.g., red(2), yellow(4))
      - location: immediately adjacent (usually above) the top-most pixel(s) of the lower blue_shape
      - role: define the colors and starting order for the generated_line; are removed in the output
  - type: generated_line
    count: 1 (in output only)
    attributes:
      - orientation: vertical
      - location_column: determined by the position of source_pixels
      - location_row_start: 0
      - height: determined by the row index of the top-most pixel(s) of the lower blue_shape
      - color_pattern: alternating sequence of the two source_pixel colors
  - type: other_structure (optional)
    count: variable (e.g., vertical red/green line)
    attributes:
      - color: variable
      - shape: variable
      - role: context / distractor (unchanged in output)

relationships:
  - adjacency: source_pixels are located immediately adjacent (typically above) the lower blue_shape.
  - derivation:
      - generated_line's column is derived from the column of a specific source_pixel.
      - generated_line's height is derived from the row index of the top of the lower blue_shape.
      - generated_line's alternating color pattern is derived from the colors and relative positions of the source_pixels.

actions:
  - identify: locate the two blue_shapes.
  - identify: determine which blue_shape is the lower one.
  - find: locate the non-blue, non-background source_pixels adjacent to the top of the lower blue_shape.
  - determine: based on source_pixel positions, find the target column for the generated_line.
  - determine: based on source_pixel positions, find the starting color and the alternating pattern.
  - determine: based on the top row index of the lower blue_shape, find the height for the generated_line.
  - remove: delete the source_pixels from the grid.
  - generate: create the new vertical generated_line at the determined column, starting from row 0, with the calculated height and alternating color pattern.
  - copy: preserve all other elements (background, upper blue_shape, other structures) from the input to the output.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all distinct blue (1) objects in the input grid.
3.  Determine which blue object is the "lower" one (e.g., the one whose lowest pixel has the highest row index, or whose highest pixel has the highest row index if needed for tie-breaking).
4.  Find the pixel(s) belonging to the lower blue object that have the minimum row index (these are the top-most pixels). Record this minimum row index (`top_row_index`).
5.  Identify all "source pixels": these are non-blue (1) and non-azure (8) pixels directly adjacent (sharing an edge or corner) to any of the top-most pixels of the lower blue object, specifically checking positions above, above-left, and above-right of the top-most blue pixels. Store these source pixels with their colors and coordinates (row, column).
6.  Remove the identified source pixels from the output grid (change their color to the background color, azure 8).
7.  Determine the target column (`target_col`) for the new vertical line: Among the identified source pixels, find the one(s) with the minimum row index. If there's a tie in row index, select the one with the minimum column index. The column index of this selected pixel is `target_col`.
8.  Determine the color sequence for the new line:
    a.  Identify the two distinct colors of the source pixels.
    b.  Determine the starting color (`color1`):
        i.  If the source pixels are in different rows, `color1` is the color of the source pixel with the *maximum* row index.
        ii. If the source pixels are in the same row, `color1` is the color of the source pixel with the *minimum* column index.
    c.  The second color (`color2`) is the other source pixel color.
9.  Determine the height (`height`) of the new vertical line: `height = top_row_index`.
10. Generate the new vertical line in the output grid: Iterate from `row = 0` up to `row = height - 1`. For each `row`:
    a.  If `row` is even, set the pixel at (`row`, `target_col`) to `color1`.
    b.  If `row` is odd, set the pixel at (`row`, `target_col`) to `color2`.
11. Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identify the two blue (1) objects. Determine the lower blue object. Find the non-blue (1), non-azure (8) pixels immediately adjacent (above, above-left, above-right) to the top-most pixel(s) of the lower blue object; these are the source pixels. Remove the source pixels. Determine the target column for a new vertical line based on the source pixel with the minimum row, then minimum column. Determine the two alternating colors for the line based on the relative positions of the source pixels (color of max row pixel starts, or min col pixel if rows are tied). Determine the height of the line as the row index of the top-most pixel(s) of the lower blue object. Generate the vertical line in the output grid at the target column, starting from row 0 up to the calculated height, using the alternating color sequence. Keep all other pixels unchanged.
"""

def find_objects(grid, color):
    """Finds all connected objects of a given color."""
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    for r in range(height):
        for c in range(width):
            if grid[r, c] == color and not visited[r, c]:
                obj_pixels = set()
                q = deque([(r, c)])
                visited[r, c] = True
                while q:
                    row, col = q.popleft()
                    obj_pixels.add((row, col))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                if obj_pixels:
                    objects.append(obj_pixels)
    return objects

def get_object_bounds(obj_pixels):
    """Calculates the bounding box (min_row, max_row, min_col, max_col) for an object."""
    if not obj_pixels:
        return None
    rows = [r for r, c in obj_pixels]
    cols = [c for r, c in obj_pixels]
    return min(rows), max(rows), min(cols), max(cols)

def transform(input_grid):
    """
    Transforms the input grid based on the identified rules.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    background_color = 8
    blue_color = 1

    # 1. Find blue objects
    blue_objects = find_objects(input_grid, blue_color)

    if len(blue_objects) != 2:
        # Handle cases where there aren't exactly two blue objects if necessary
        # For this specific task, examples suggest exactly two.
        return output_grid # Or raise an error

    # 2. Determine the lower blue object
    bounds1 = get_object_bounds(blue_objects[0])
    bounds2 = get_object_bounds(blue_objects[1])

    # Lower object has the largest max_row
    if bounds1[1] > bounds2[1]:
        lower_blue_obj = blue_objects[0]
    elif bounds2[1] > bounds1[1]:
        lower_blue_obj = blue_objects[1]
    else:
        # Tie-break using min_row (object starting lower down)
        if bounds1[0] > bounds2[0]:
             lower_blue_obj = blue_objects[0]
        else:
             lower_blue_obj = blue_objects[1] # Default to second if still tied


    # 3. Find the top-most pixels of the lower blue object
    min_row_lower = min(r for r, c in lower_blue_obj)
    top_pixels_lower = {(r, c) for r, c in lower_blue_obj if r == min_row_lower}

    # 4. Identify source pixels adjacent to the top-most blue pixels
    source_pixels = [] # Store as (color, row, col)
    checked_coords = set()
    for r_blue, c_blue in top_pixels_lower:
        # Check potential adjacent positions: above, above-left, above-right
        for dr, dc in [(-1, 0), (-1, -1), (-1, 1)]:
            nr, nc = r_blue + dr, c_blue + dc
            coord = (nr, nc)
            if 0 <= nr < height and 0 <= nc < width and coord not in checked_coords:
                pixel_color = input_grid[nr, nc]
                if pixel_color != blue_color and pixel_color != background_color:
                    source_pixels.append({'color': pixel_color, 'row': nr, 'col': nc})
                checked_coords.add(coord) # Avoid adding the same pixel multiple times

    if len(source_pixels) != 2:
         # Assuming based on examples there are always 2 source pixels
         # Add error handling if needed
         return output_grid


    # 5. Remove source pixels from the output grid
    for sp in source_pixels:
        output_grid[sp['row'], sp['col']] = background_color

    # 6. Determine target column
    # Sort by row ascending, then column ascending
    source_pixels.sort(key=lambda p: (p['row'], p['col']))
    target_col = source_pixels[0]['col'] # Pixel with min row, then min col

    # 7. Determine color sequence (color1 starts)
    sp1 = source_pixels[0]
    sp2 = source_pixels[1]

    # Determine which original pixel corresponds to sp1 and sp2 for ordering
    original_pixel1 = next(p for p in source_pixels if p['row'] == sp1['row'] and p['col'] == sp1['col'])
    original_pixel2 = next(p for p in source_pixels if p['row'] == sp2['row'] and p['col'] == sp2['col'])


    if original_pixel1['row'] != original_pixel2['row']:
        # Different rows: start color is from the pixel with the maximum row index
        if original_pixel1['row'] > original_pixel2['row']:
             color1 = original_pixel1['color']
             color2 = original_pixel2['color']
        else:
             color1 = original_pixel2['color']
             color2 = original_pixel1['color']
    else:
        # Same row: start color is from the pixel with the minimum column index
        if original_pixel1['col'] < original_pixel2['col']:
            color1 = original_pixel1['color']
            color2 = original_pixel2['color']
        else:
            color1 = original_pixel2['color']
            color2 = original_pixel1['color']


    # 8. Determine height of the new line
    height_line = min_row_lower # Line goes up to (but not including) this row

    # 9. Generate the new vertical line
    for r in range(height_line):
        if r % 2 == 0: # Even row
            output_grid[r, target_col] = color1
        else: # Odd row
            output_grid[r, target_col] = color2

    return output_grid
```
