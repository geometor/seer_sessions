
## train_1

**input:**
```
0 0 3 0 0 5 3 3 0 3 0 5 0 0 0 0 0
0 0 0 0 3 3 0 0 0 0 3 5 0 0 0 0 0
0 0 0 0 3 5 0 0 0 0 3 5 0 0 0 0 0
0 0 0 0 0 5 0 0 3 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 3 0 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 3 5 5 5 5 5
3 3 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 3 0 3 3 0 5 0 0 0 0 0
0 0 0 0 3 5 0 0 0 0 0 5 0 0 0 3 0
3 3 0 3 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 3 0 5 0 0 0 3 0
5 5 3 5 3 5 5 5 5 3 5 5 5 5 5 5 3
0 0 0 3 3 5 0 3 3 0 0 5 0 0 0 3 3
0 0 0 0 0 5 0 3 0 0 0 5 0 0 0 0 3
3 0 0 0 0 3 0 0 3 0 0 3 0 0 0 3 0
3 0 0 0 0 5 0 0 0 0 3 5 0 0 0 3 3
3 0 0 0 0 3 0 0 3 0 0 5 0 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
3 0 0 0 0 5 0 0 0 3 0 5 0 0 0 0 0
3 0 3 0 0 5 0 0 0 0 0 5 3 0 3 0 3
3 0 0 0 0 5 3 0 0 0 0 5 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
5 5 5 5 5 3 5 5 5 5 5 3 5 5 5 5 5
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
5 5 5 5 5 3 5 5 5 5 5 3 5 5 5 5 5
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
5 5 5 5 5 3 5 5 5 5 5 3 5 5 5 5 5
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 2 5 0 0 2 0 5 0 0 0
2 0 0 0 5 0 2 0 0 5 0 0 0
0 0 0 0 2 0 2 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
2 5 5 5 5 5 5 5 2 5 5 5 5
0 2 0 0 5 0 2 0 0 5 0 0 0
0 0 2 0 5 0 0 2 0 5 0 2 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
5 5 5 5 5 5 5 5 5 5 2 5 5
0 0 0 0 5 0 0 0 0 5 0 0 0
0 2 0 0 5 0 2 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 2
0 0 0 0 5 0 0 0 0 5 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 2 0 0
```


**output:**
```
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
5 5 5 5 2 5 5 5 5 2 5 5 5
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
5 5 5 5 2 5 5 5 5 2 5 5 5
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
5 5 5 5 2 5 5 5 5 2 5 5 5
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 0 5 0 0 0 0 5 0 0 0
```


## train_3

**input:**
```
0 0 0 4 0 0 0 5 0 0 0 5 0 0 0 5 4 0 0 5 0 4 0 5
0 4 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 4 4 0 0 0 4 0 0 0 5 0 0 4 5 0 0 0 5 0 0 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 4
0 0 0 5 0 4 4 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5
0 0 0 5 0 0 0 5 4 0 4 4 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
4 0 0 5 0 0 0 4 0 0 0 5 0 0 0 4 0 0 0 5 4 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 4 0 5
0 0 0 5 4 0 0 5 0 0 0 5 4 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 4 0 0 5 0 0 0 5 0 0 4 5 0 0 0 5 0 0 0 5
5 5 5 5 5 5 5 5 5 4 5 5 5 5 4 5 5 5 5 5 5 5 5 5
0 0 0 4 0 0 0 5 0 0 0 5 0 0 0 5 0 4 0 4 0 0 0 5
0 0 0 5 0 4 0 5 4 0 0 4 0 0 4 5 0 0 0 5 0 0 0 5
0 0 0 5 0 4 0 5 4 4 0 5 0 0 0 5 0 4 0 5 0 0 0 5
5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 0 0 5 0 0 0 5 0 0 0 4 0 4 0 4 4 0 0 5 0 0 0 5
```


**output:**
```
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4 5 5 5 4
0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5 0 0 0 5
```

*   **Perception:**
    The task involves transforming an input grid based on the interaction between gray lines and another single color. Each input grid contains a background of white (0), prominent horizontal and vertical lines of gray (5) pixels, and scattered pixels of a single other color (green (3) in example 1, red (2) in example 2, yellow (4) in example 3). The output grid retains the gray lines but replaces the scattered colored pixels with white (0). Crucially, the points where the horizontal and vertical gray lines intersected in the input grid are changed to the specific color that was scattered in the input grid.

*   **YAML:**
    
```yaml
    ---
    Observations:
      - Input and output grids have the same dimensions.
      - The input grid contains white (0) pixels, gray (5) pixels forming horizontal and vertical lines, and pixels of one other color (let's call it 'target_color').
        - Example 1: target_color is green (3).
        - Example 2: target_color is red (2).
        - Example 3: target_color is yellow (4).
      - The output grid primarily consists of white (0) pixels and the gray (5) lines from the input.
      - Pixels that were the 'target_color' in the input are turned white (0) in the output, unless they are at an intersection point.
      - Pixels that were gray (5) in the input remain gray (5) in the output, unless they are at an intersection point.
      - Pixels that were white (0) in the input remain white (0) in the output.
    Objects:
      - Horizontal gray lines: Contiguous sequences of gray (5) pixels along rows.
      - Vertical gray lines: Contiguous sequences of gray (5) pixels along columns.
      - Target color pixels: Scattered pixels of a single color other than gray (5) or white (0).
      - Intersection points: Pixels where a horizontal gray line and a vertical gray line meet.
    Relationships:
      - Gray lines define a grid structure within the main grid.
      - Intersection points are defined by the crossing of horizontal and vertical gray lines.
    Actions:
      - Identify the single 'target_color' present besides gray (5) and white (0).
      - Preserve the structure of the horizontal and vertical gray (5) lines from the input to the output.
      - Replace all 'target_color' pixels from the input with white (0) in the output.
      - Replace the gray (5) pixels at the intersection points with the 'target_color' in the output.
    ```


*   **Natural Language Program:**
    1.  Identify the single color present in the input grid that is not white (0) or gray (5). Call this the `target_color`.
    2.  Create a new grid with the same dimensions as the input grid, initially filled with white (0).
    3.  Iterate through each cell of the input grid. If a cell contains a gray (5) pixel:
        a.  Check if this gray pixel belongs to both a fully gray horizontal line and a fully gray vertical line within the input grid (i.e., it's an intersection point).
        b.  If it is an intersection point, set the corresponding cell in the new grid to the `target_color`.
        c.  If it is *not* an intersection point but is still gray (5) in the input, set the corresponding cell in the new grid to gray (5).
    4.  The new grid is the output.
```python
import numpy as np
from typing import Set, List, Tuple

"""
Transformation Rule:
1. Identify the unique color ('target_color') present in the input grid that is neither white (0) nor gray (5).
2. Identify rows that exclusively contain gray (5) pixels and 'target_color' pixels. These are the 'structural rows'.
3. Identify columns that exclusively contain gray (5) pixels and 'target_color' pixels. These are the 'structural columns'.
4. Initialize the output grid with the same dimensions as the input, filled with white (0).
5. Copy all gray (5) pixels from their original positions in the input grid to the output grid.
6. For every intersection point defined by a 'structural row' index `r` and a 'structural column' index `c`, set the pixel at `(r, c)` in the output grid to the 'target_color'. This overwrites any gray pixel previously placed at these intersection coordinates.
"""

def find_target_color(grid: np.ndarray) -> int:
    """Finds the unique color in the grid that is not white (0) or gray (5)."""
    unique_colors = np.unique(grid)
    target_color = -1  # Default value if not found
    for color in unique_colors:
        if color != 0 and color != 5:
            if target_color == -1:
                target_color = color
            else:
                # This case implies more than one non-background/non-structure color,
                # which shouldn't happen based on the examples.
                # Handle as an error or according to specific problem constraints if needed.
                pass # For now, assume only one target color exists per example
    if target_color == -1:
        # Handle case where no target color is found (e.g. input is only white/gray)
        # Based on examples, a target color should always exist.
        # We might return a default or raise an error depending on expected behavior.
        # Let's assume it always exists for valid inputs based on task description.
        # We could pick an arbitrary color, but it's better to rely on finding one.
         raise ValueError("No target color (non-0, non-5) found in the input grid.")
    return target_color

def get_structural_indices(grid: np.ndarray, target_color: int, axis: int) -> List[int]:
    """
    Finds the indices of rows (axis=0) or columns (axis=1)
    that contain only gray (5) and the target_color.
    """
    structural_indices = []
    num_elements = grid.shape[axis]
    num_orthogonal_elements = grid.shape[1 - axis]

    for i in range(num_elements):
        is_structural = True
        contains_gray_or_target = False
        if axis == 0: # Check row i
            line = grid[i, :]
        else: # Check column i
            line = grid[:, i]

        for pixel in line:
            if pixel == 5 or pixel == target_color:
                contains_gray_or_target = True
            else: # Contains other colors (like white 0)
                 is_structural = False
                 break # No need to check further in this line

        # A line is structural if it consists *only* of 5 and target_color
        # and is not empty (which contains_gray_or_target checks implicitly).
        # It must contain *at least one* 5 or target_color pixel.
        if is_structural and contains_gray_or_target:
            structural_indices.append(i)

    return structural_indices


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rule to the input grid.
    Identifies a target color, structural gray lines (potentially interrupted by the target color),
    and places the target color at the intersections of these lines in the output grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape

    # 1. Identify the target_color
    try:
        target_color = find_target_color(input_array)
    except ValueError as e:
        print(f"Error: {e}. Returning input grid or a default.")
        # Decide on fallback behavior - return input, empty, or specific pattern
        return input_array # Example fallback: return input unchanged

    # 2. & 3. Identify structural rows and columns
    # A row/column is structural if it *only* contains gray (5) and the target_color
    structural_rows = []
    for r in range(height):
        row_colors = np.unique(input_array[r, :])
        is_structural = True
        contains_structure_colors = False
        for color in row_colors:
            if color == 5 or color == target_color:
                contains_structure_colors = True
            else: # Contains a color other than 5 or target_color (e.g., 0)
                is_structural = False
                break
        if is_structural and contains_structure_colors: # Must contain at least one 5 or target_color
             structural_rows.append(r)


    structural_cols = []
    for c in range(width):
        col_colors = np.unique(input_array[:, c])
        is_structural = True
        contains_structure_colors = False
        for color in col_colors:
             if color == 5 or color == target_color:
                 contains_structure_colors = True
             else: # Contains a color other than 5 or target_color (e.g., 0)
                 is_structural = False
                 break
        if is_structural and contains_structure_colors: # Must contain at least one 5 or target_color
             structural_cols.append(c)


    # 4. Initialize the output grid with white (0)
    output_grid = np.zeros_like(input_array) # Fills with 0 (white)

    # 5. Copy gray (5) pixels from input to output
    gray_mask = (input_array == 5)
    output_grid[gray_mask] = 5

    # 6. Place target_color at intersections of structural lines
    for r in structural_rows:
        for c in structural_cols:
             # Check if the point (r,c) is actually within grid bounds, though it should be by definition
            if 0 <= r < height and 0 <= c < width:
                 output_grid[r, c] = target_color

    return output_grid.tolist() # Convert back to list of lists if required by framework

```
