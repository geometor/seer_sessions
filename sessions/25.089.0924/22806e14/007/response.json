{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  Identifies the background color (assumed to be 7) and the two unique non-background colors (Color A, Color B).\n2.  Finds all connected objects for both Color A and Color B.\n3.  For each object, determines its bounding box and calculates its height and width.\n4.  Counts how many objects of Color A have both odd height and odd width (`countA`).\n5.  Counts how many objects of Color B have both odd height and odd width (`countB`).\n6.  Determines a 'target_color' and a 'replacement_color' based on the comparison of `countA` and `countB`:\n    - If `countA > countB`, target = A, replacement = B.\n    - If `countB > countA`, target = B, replacement = A.\n    - If `countA == countB`, target = max(A, B), replacement = min(A, B).\n7.  Modifies an output grid (initially a copy of the input):\n    - For each object of the `target_color`, if its bounding box has odd height and odd width, its exact center pixel is changed to the `replacement_color`.\n    - All other pixels retain their original color from the input grid.\n8.  Returns the modified grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of the pixels belonging to one object. Returns an empty list\n              if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited pixel of the target color\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                queue = deque([(r, c)])\n                visited[r, c] = True\n                while queue:\n                    row, col = queue.popleft()\n                    obj_pixels.add((row, col))\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is the same color and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            queue.append((nr, nc))\n                # Add the found object's pixels to the list if it's not empty\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"\n    Calculates the bounding box for a set of object pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples representing an object.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if the set is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n    # Find the min/max row and column from the pixel coordinates\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_dimensions(bounding_box):\n    \"\"\"\n    Calculates the height and width from a bounding box tuple.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (height, width). Returns (0, 0) if bounding_box is None.\n    \"\"\"\n    if bounding_box is None:\n        return 0, 0\n    min_r, min_c, max_r, max_c = bounding_box\n    # Height and width are inclusive ranges\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef is_odd_dimension(dims):\n    \"\"\"\n    Checks if both height and width are positive odd numbers.\n\n    Args:\n        dims (tuple): (height, width).\n\n    Returns:\n        bool: True if both height and width are positive and odd, False otherwise.\n    \"\"\"\n    height, width = dims\n    # Dimensions must be positive and odd\n    return height > 0 and width > 0 and height % 2 != 0 and width % 2 != 0\n\ndef get_center(bounding_box):\n    \"\"\"\n    Calculates the center coordinates for a bounding box.\n    Assumes the dimensions are odd when called in the main logic.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (center_row, center_col).\n    \"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    height, width = get_dimensions(bounding_box)\n    # Integer division finds the middle index for odd dimensions\n    center_r = min_r + height // 2\n    center_c = min_c + width // 2\n    return center_r, center_c\n\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    \n    # Define background color (assumed to be 7 based on examples)\n    bg_color = 7\n\n    # Identify the unique colors present and filter out the background color\n    unique_colors = np.unique(input_grid_np)\n    non_bg_colors = [c for c in unique_colors if c != bg_color]\n    \n    # Check if exactly two non-background colors are present, as required by the rule\n    if len(non_bg_colors) != 2:\n        # If not, return the original grid (transformation is undefined)\n        return input_grid \n\n    color_a, color_b = non_bg_colors[0], non_bg_colors[1]\n\n    # --- Analyze Objects for Each Color ---\n    # Store properties: (set of pixels, has odd/odd dimensions, bounding box)\n    objects_a_props = [] \n    objects_a = find_objects(input_grid_np, color_a)\n    count_odd_a = 0\n    for obj_pixels in objects_a:\n        bbox = get_bounding_box(obj_pixels)\n        dims = get_dimensions(bbox)\n        is_odd = is_odd_dimension(dims)\n        objects_a_props.append((obj_pixels, is_odd, bbox))\n        if is_odd:\n            count_odd_a += 1 # Increment count if dimensions are odd/odd\n\n    objects_b_props = []\n    objects_b = find_objects(input_grid_np, color_b)\n    count_odd_b = 0\n    for obj_pixels in objects_b:\n        bbox = get_bounding_box(obj_pixels)\n        dims = get_dimensions(bbox)\n        is_odd = is_odd_dimension(dims)\n        objects_b_props.append((obj_pixels, is_odd, bbox))\n        if is_odd:\n            count_odd_b += 1 # Increment count if dimensions are odd/odd\n\n    # --- Determine Target and Replacement Colors based on counts ---\n    if count_odd_a > count_odd_b:\n        target_color = color_a\n        replacement_color = color_b\n        target_objects_props = objects_a_props # Assign properties list for the target color\n    elif count_odd_b > count_odd_a:\n        target_color = color_b\n        replacement_color = color_a\n        target_objects_props = objects_b_props # Assign properties list for the target color\n    else: # Counts are equal, use numerical value as tie-breaker\n        target_color = max(color_a, color_b)\n        replacement_color = min(color_a, color_b)\n        # Assign the correct properties list based on the tie-breaker result\n        if target_color == color_a:\n             target_objects_props = objects_a_props\n        else:\n             target_objects_props = objects_b_props\n\n    # --- Apply Transformation: Modify Center Pixel ---\n    # Iterate through the properties of objects belonging to the target color\n    for obj_pixels, is_odd, bbox in target_objects_props:\n        # Check if the object has odd/odd dimensions\n        if is_odd:\n            # Calculate the center coordinates of its bounding box\n            center_r, center_c = get_center(bbox)\n            # Modify the pixel at the center coordinates in the output grid\n            # No need to check original color, as we only modify target objects\n            # and the output grid starts as a copy.\n            output_grid[center_r, center_c] = replacement_color\n            \n    # Convert the final numpy array back to a list of lists for the expected format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19788,
    "candidates_token_count": 2288,
    "total_token_count": 22076,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.035662,
  "retries": 1
}