{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  Identifies the background color (assumed to be 7) and the two unique non-background colors (Color A, Color B).\n2.  Finds all connected objects for both Color A and Color B.\n3.  For each object, determines its bounding box and whether both height and width are odd.\n4.  Counts the number of objects with odd height and odd width for each color (countA, countB).\n5.  Determines a 'target_color' and a 'replacement_color':\n    - If countA > countB, target = A, replacement = B.\n    - If countB > countA, target = B, replacement = A.\n    - If countA == countB, target = max(A, B), replacement = min(A, B).\n6.  Modifies an output grid (initially a copy of the input):\n    - Rule 1 (Object Removal): All pixels belonging to any object of the replacement_color are changed to the background color.\n    - Rule 2 (Center Modification): For each object of the target_color, if its bounding box has odd height and odd width, its center pixel is changed to the replacement_color.\n7.  Returns the modified grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of the pixels belonging to one object. Returns an empty list\n              if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                queue = deque([(r, c)])\n                visited[r, c] = True\n                while queue:\n                    row, col = queue.popleft()\n                    obj_pixels.add((row, col))\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            queue.append((nr, nc))\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"\n    Calculates the bounding box for a set of object pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if the set is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_dimensions(bounding_box):\n    \"\"\"\n    Calculates the height and width from a bounding box.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (height, width). Returns (0, 0) if bounding_box is None.\n    \"\"\"\n    if bounding_box is None:\n        return 0, 0\n    min_r, min_c, max_r, max_c = bounding_box\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef is_odd_dimension(dims):\n    \"\"\"\n    Checks if both height and width are positive odd numbers.\n\n    Args:\n        dims (tuple): (height, width).\n\n    Returns:\n        bool: True if both height and width are positive and odd, False otherwise.\n    \"\"\"\n    height, width = dims\n    return height > 0 and width > 0 and height % 2 != 0 and width % 2 != 0\n\ndef get_center(bounding_box):\n    \"\"\"\n    Calculates the center coordinates for a bounding box.\n    Assumes the dimensions are odd when called in the main logic requiring center.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (center_row, center_col).\n    \"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    height, width = get_dimensions(bounding_box)\n    # Integer division naturally finds the middle index for odd dimensions\n    center_r = min_r + height // 2\n    center_c = min_c + width // 2\n    return center_r, center_c\n\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    \n    # Define background color (assumed from examples)\n    bg_color = 7\n\n    # Identify the unique colors present and the non-background colors\n    unique_colors = np.unique(input_grid_np)\n    non_bg_colors = [c for c in unique_colors if c != bg_color]\n    \n    # Check if exactly two non-background colors are present, as expected\n    if len(non_bg_colors) != 2:\n        # If not, return the original grid (no transformation defined)\n        return input_grid \n\n    color_a, color_b = non_bg_colors[0], non_bg_colors[1]\n\n    # --- Object Analysis ---\n    objects_a_props = [] # Store tuples: (pixel_set, is_odd_odd, bbox)\n    objects_a = find_objects(input_grid_np, color_a)\n    count_odd_a = 0\n    for obj_pixels in objects_a:\n        bbox = get_bounding_box(obj_pixels)\n        dims = get_dimensions(bbox)\n        is_odd = is_odd_dimension(dims)\n        objects_a_props.append((obj_pixels, is_odd, bbox))\n        if is_odd:\n            count_odd_a += 1\n\n    objects_b_props = [] # Store tuples: (pixel_set, is_odd_odd, bbox)\n    objects_b = find_objects(input_grid_np, color_b)\n    count_odd_b = 0\n    for obj_pixels in objects_b:\n        bbox = get_bounding_box(obj_pixels)\n        dims = get_dimensions(bbox)\n        is_odd = is_odd_dimension(dims)\n        objects_b_props.append((obj_pixels, is_odd, bbox))\n        if is_odd:\n            count_odd_b += 1\n\n    # --- Determine Target and Replacement Colors ---\n    if count_odd_a > count_odd_b:\n        target_color = color_a\n        replacement_color = color_b\n        target_objects_props = objects_a_props\n        replacement_objects_props = objects_b_props\n    elif count_odd_b > count_odd_a:\n        target_color = color_b\n        replacement_color = color_a\n        target_objects_props = objects_b_props\n        replacement_objects_props = objects_a_props\n    else: # Counts are equal, use numerical value as tie-breaker\n        target_color = max(color_a, color_b)\n        replacement_color = min(color_a, color_b)\n        if target_color == color_a:\n             target_objects_props = objects_a_props\n             replacement_objects_props = objects_b_props\n        else:\n             target_objects_props = objects_b_props\n             replacement_objects_props = objects_a_props\n\n    # --- Apply Transformations ---\n\n    # Rule 1: Remove all objects of the replacement_color\n    for obj_pixels, _, _ in replacement_objects_props:\n        for r, c in obj_pixels:\n            output_grid[r, c] = bg_color\n\n    # Rule 2: Modify center pixel of odd-dimensioned target_color objects\n    for obj_pixels, is_odd, bbox in target_objects_props:\n        # Check if the object has odd/odd dimensions\n        if is_odd:\n            # Calculate the center coordinates\n            center_r, center_c = get_center(bbox)\n            # Check if the center pixel was originally the target color \n            # (it might have been overwritten if replacement object removal affected it, though unlikely)\n            # More importantly, ensure we are modifying a pixel that is still part of the object\n            # conceptually, even if Rule 1 already modified the grid.\n            # We modify the output grid directly.\n            if (center_r, center_c) in obj_pixels: # Ensure center is part of the original object pixels\n                 output_grid[center_r, center_c] = replacement_color\n            # Note: If the center pixel was originally target_color but got changed to bg_color\n            # by Rule 1 (e.g., if target and replacement objects touch weirdly), this logic\n            # might need refinement. However, based on examples, objects seem distinct enough\n            # that this simplified modification should work. The key is that the modification\n            # location is determined by the *original* object's shape.\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21225,
    "candidates_token_count": 2393,
    "total_token_count": 23618,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.237501,
  "retries": 1
}