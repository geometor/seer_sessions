
## train_1

**input:**
```
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 8 8 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 8 1 2 1 2 2 2
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 8 1 2 1 2 2 2
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
```


**output:**
```
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 8 8 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 8 1 2 2 2 1 2 2 2 1 8 1 8 1 2 2 2
2 2 2 1 2 1 8 1 2 2 2 1 2 2 2 1 8 1 8 1 2 2 2
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 8 8 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 2 1 2 1 0 1 8 8 0 1 0 0 2 1 0 1 0 1 2 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 2 1 2 1 2 2 2 1 2 2 2 1 2 1 2 1 2 2 2
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
0 0 2 1 2 1 0 1 2 2 0 1 0 0 2 1 0 1 0 1 2 0 0
```


## train_2

**input:**
```
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 8 8 8 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
```


**output:**
```
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 8 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
1 1 1 2 8 8 8 2 1 1 1 2 1 1 1 2 8 8 8 2 1
0 0 1 2 0 8 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
0 0 1 2 0 1 0 2 1 0 0 2 0 0 1 2 0 1 0 2 1
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 1 2 0 8 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
1 1 1 2 8 8 8 2 1 1 1 2 1 1 1 2 8 8 8 2 1
0 0 1 2 0 8 0 2 1 0 0 2 0 0 1 2 0 8 0 2 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1
```


## train_3

**input:**
```
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
1 1 1 1 2 2 1 1 1 2 1 1 1 1 2 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 1 8 1 1 1 2 1 1 2 2 2 1 2
2 2 2 1 8 1 8 1 2 1 2 1 2 2 2 1 2
0 0 1 1 1 8 0 1 1 2 0 1 0 0 2 1 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 2 1 1 1 2 1 1 1 1 2 1 1
8 8 8 1 2 1 2 1 2 1 2 1 2 2 2 1 2
0 0 1 1 1 2 0 1 1 2 0 1 0 0 2 1 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
2 2 2 1 2 2 2 1 2 2 2 1 2 2 2 1 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
```


**output:**
```
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
1 1 1 1 2 2 1 1 1 2 1 1 1 1 2 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 1 1 8 1 1 1 8 1 1 2 2 2 1 2
2 2 2 1 8 1 8 1 8 1 8 1 2 2 2 1 2
0 0 1 1 1 8 0 1 1 8 0 1 0 0 2 1 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 8 1 1 1 8 1 1 1 1 2 1 1
8 8 8 1 8 1 8 1 8 1 8 1 2 2 2 1 2
0 0 1 1 1 8 0 1 1 8 0 1 0 0 2 1 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
8 8 8 1 2 2 2 1 2 2 2 1 2 2 2 1 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 2 2 0 1 1 2 0 1 0 0 2 1 0
```

*   **Perception:**
    The task involves modifying an input grid based on the proximity of certain colors to the color azure (8). The core operation appears to be a horizontal "spread" or "infection" effect originating from azure pixels. The overall structure and most pixels of the grid remain unchanged; only pixels adjacent horizontally to azure pixels are potentially modified. The colors targeted for change are red (2) and blue (1). If a red or blue pixel is directly to the left or right of an azure pixel in the input grid, it becomes azure in the output grid. All other pixels, including the original azure pixels, retain their initial color. The transformation rule is applied simultaneously based on the state of the input grid.

*   **Facts:**
    
```yaml
    task_type: grid_transformation
    element_focus: pixel_color
    transformation_type: conditional_color_change
    reference_color: azure (8)
    target_colors: [red (2), blue (1)]
    condition: horizontal_adjacency
    adjacency_rule: A target color pixel changes to the reference color if it is horizontally adjacent (left or right) to a reference color pixel in the input grid.
    scope: local (pixel-level based on immediate neighbors)
    frame_of_reference: input_grid (changes are determined solely based on the input state)
    unchanged_elements:
      - Pixels not matching target colors (red, blue).
      - Pixels matching target colors but not horizontally adjacent to the reference color (azure).
      - Pixels of the reference color (azure).
      - Pixels of any color that are only vertically or diagonally adjacent to the reference color.
    output_grid_relation: The output grid is a modified copy of the input grid.
    ```


*   **Natural Language Program:**
    1.  Create the output grid as a copy of the input grid.
    2.  Iterate through each cell `(row, col)` of the input grid.
    3.  Get the color `C` of the cell `(row, col)` in the input grid.
    4.  If `C` is red (2) or blue (1):
        a.  Check the color of the left neighbor `(row, col-1)` in the input grid (if it exists within the grid boundaries).
        b.  Check the color of the right neighbor `(row, col+1)` in the input grid (if it exists within the grid boundaries).
        c.  If either the left neighbor *or* the right neighbor in the *input* grid has the color azure (8), then change the color of the cell `(row, col)` in the *output* grid to azure (8).
    5.  Leave all other cells in the output grid unchanged from their corresponding input grid color.
    6.  Return the modified output grid.
