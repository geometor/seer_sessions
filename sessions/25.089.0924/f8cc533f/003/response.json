{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (the most frequent color in the grid).\n2. Create a copy of the input grid to serve as the output grid.\n3. Find all connected components (regions) of pixels that have the background color, using 4-connectivity (up, down, left, right).\n4. For each background color component:\n    a. Determine the set of all neighboring pixels (pixels adjacent via 4-connectivity to any pixel in the component, but not part of the component itself).\n    b. Check if the component touches the grid boundary (any pixel in the first/last row or first/last column).\n    c. Collect the colors of all non-background neighboring pixels.\n    d. If the component does *not* touch the grid boundary AND all its non-background neighbors have the *same* single color 'C', then fill all pixels belonging to this component in the output grid with color 'C'.\n5. Pixels not belonging to such fillable background components retain their original color.\n6. Return the modified output grid.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_background_components(grid, bg_color):\n    \"\"\"\n    Finds all connected components of the background color using BFS.\n    Returns a list of sets, where each set contains the (r, c) coordinates of a component.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If it's a background pixel and not yet visited, start a BFS\n            if grid[r, c] == bg_color and not visited[r, c]:\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds and if it's a background pixel and not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == bg_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                \n                components.append(component)\n                \n    return components\n\ndef analyze_component(grid, component):\n    \"\"\"\n    Analyzes a background component to find its neighbors and boundary status.\n    Returns:\n        - touches_boundary (bool): True if the component touches the grid edge.\n        - neighbor_colors (set): A set of colors of non-background neighbors.\n    \"\"\"\n    height, width = grid.shape\n    touches_boundary = False\n    neighbor_pixels = set() # Store (r, c) of neighbors to avoid recounting colors\n    \n    for r, c in component:\n        # Check if the pixel is on the boundary\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            touches_boundary = True\n            # We can potentially stop checking boundary status early, \n            # but we still need all neighbors, so continue iteration.\n\n        # Check neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # If the neighbor is not part of the current component\n                if (nr, nc) not in component:\n                     neighbor_pixels.add((nr, nc))\n\n    # Collect the colors of the unique neighboring pixels\n    neighbor_colors = set()\n    for r_n, c_n in neighbor_pixels:\n        neighbor_colors.add(grid[r_n,c_n])\n\n    return touches_boundary, neighbor_colors\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills connected background regions if they are fully enclosed by a single color.\n    \"\"\"\n    # Convert list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n\n    # Identify the background color\n    bg_color = get_background_color(input_grid_np)\n\n    # Find all connected components of the background color\n    background_components = find_background_components(input_grid_np, bg_color)\n\n    # Analyze each background component\n    for component in background_components:\n        # Get boundary status and neighbor colors\n        touches_boundary, neighbor_colors = analyze_component(input_grid_np, component)\n\n        # Remove background color from neighbor colors if present (shouldn't happen with correct component finding, but safe)\n        neighbor_colors.discard(bg_color) \n\n        # Check conditions for filling: not touching boundary and exactly one neighbor color\n        if not touches_boundary and len(neighbor_colors) == 1:\n            # Get the single neighbor color\n            fill_color = neighbor_colors.pop() \n            # Fill the component in the output grid\n            for r, c in component:\n                output_grid[r, c] = fill_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12138,
    "candidates_token_count": 1377,
    "total_token_count": 13515,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.349241,
  "retries": 1
}