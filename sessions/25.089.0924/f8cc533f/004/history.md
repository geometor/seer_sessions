
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 3 3 3 3 3 4 4 3 3 3 3
3 3 3 3 8 3 8 3 3 3 3 4 4 3 3 3 3 3 3
3 3 3 8 3 3 3 8 3 3 3 4 3 3 3 4 3 3 3
3 3 3 8 8 3 8 8 3 3 3 4 4 3 4 4 3 3 3
3 3 3 3 8 3 8 3 3 3 3 3 4 4 4 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 2 3 3 3 3 3 3 1 3 1 3 3 3 3
3 2 3 3 3 2 3 3 3 3 3 1 1 3 1 1 3 3 3
3 2 3 3 2 2 3 3 3 3 3 1 3 3 3 1 3 3 3
3 3 2 2 2 3 3 3 3 3 3 1 1 3 1 1 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 1 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 8 3 3 3 3 3 4 4 4 3 3 3 3
3 3 3 8 8 3 8 8 3 3 3 4 4 3 4 4 3 3 3
3 3 3 8 3 3 3 8 3 3 3 4 3 3 3 4 3 3 3
3 3 3 8 8 3 8 8 3 3 3 4 4 3 4 4 3 3 3
3 3 3 3 8 8 8 3 3 3 3 3 4 4 4 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 2 2 3 3 3 3 3 3 1 1 1 3 3 3 3
3 2 3 3 3 2 3 3 3 3 3 1 1 3 1 1 3 3 3
3 2 2 3 2 2 3 3 3 3 3 1 3 3 3 1 3 3 3
3 3 2 2 2 3 3 3 3 3 3 1 1 3 1 1 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 4 2 2 2 2 2
2 2 1 2 2 2 2 2 2 4 4 4 4 4 2 2 2 2 2
2 1 1 1 1 2 1 2 2 2 4 2 2 4 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 2 2
2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 2 2
2 2 1 2 2 1 2 2 2 4 4 4 4 4 4 2 2 2 2
2 1 1 1 1 1 1 2 2 2 4 2 2 4 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
2 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
2 2 1 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 3 4 4 4 4 4 4 4 4 4 8 4 8 4
4 4 3 3 4 3 3 4 4 4 4 4 4 4 8 8 4 8 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 3 3 4 3 3 4 4 2 4 2 4 4 8 8 4 4 4
4 4 4 3 4 3 4 4 2 2 4 2 4 4 4 8 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 2 2 4 4 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 4 2 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 3 4 3 4 4 4 4 4 4 4 4 4 8 4 8 4
4 4 3 3 4 3 3 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 3 3 4 3 3 4 4 2 4 2 4 4 8 8 4 8 8
4 4 4 3 4 3 4 4 2 2 4 2 2 4 4 8 4 8 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 2 2 4 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 2 4 2 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

*   **Perception:** The input grids contain a uniform background color and several objects composed of other distinct colors. These objects appear as hollow rectangular frames. The transformation involves filling the interior (the hollow part) of each rectangular frame with the color of the frame itself. The background color and the frame pixels remain unchanged.

*   **YAML Facts:**
    
```yaml
    background_color:
      description: The single color that occupies the majority of the grid cells in the input.
      value: Varies per example (green, red, yellow).
      unchanged: Yes
    objects:
      description: Contiguous groups of pixels with the same color, distinct from the background color.
      properties:
        - color: A single color per object (azure, yellow, red, blue, green).
        - shape: Hollow rectangles (frames).
    transformation:
      action: Fill interior
      target: Hollow rectangular objects
      details: The pixels inside the rectangular frame, which initially match the background color, are changed to the color of the frame.
      condition: The filling only occurs if a pixel is surrounded (directly or indirectly along cardinal axes) by pixels of the *same* non-background color on all four sides (top, bottom, left, right).
    ```


*   **Natural Language Program:**
    1.  Identify the background color, which is the most frequent color in the input grid.
    2.  Create a copy of the input grid to serve as the output grid.
    3.  Iterate through each pixel of the input grid that has the background color.
    4.  For each background pixel, check if it is enclosed within a hollow rectangular frame of a single non-background color. This check can be performed by verifying if there exists a path consisting solely of pixels of a single non-background color 'C' from the current background pixel position outwards in the up, down, left, and right directions, eventually reaching pixels of color 'C' in all four directions.
    5.  If a background pixel is found to be enclosed by a frame of color 'C' according to the check in step 4, change the color of the corresponding pixel in the output grid to color 'C'.
    6.  Pixels that are not part of the background or are background pixels not enclosed by a frame retain their original color in the output grid.
    7.  Return the modified output grid.
```python
import numpy as np

"""
Transformation rule:
1. Identify the background color (the most frequent color in the grid).
2. Create a copy of the input grid.
3. Iterate through each pixel in the grid.
4. If a pixel has the background color, check if it is enclosed by a single non-background color in all four cardinal directions (up, down, left, right).
5. To check for enclosure:
   - Look upwards from the pixel: Find the first non-background pixel. Record its color. If the grid boundary is hit first, it's not enclosed.
   - Look downwards: Find the first non-background pixel. Record its color. If the grid boundary is hit first, it's not enclosed.
   - Look leftwards: Find the first non-background pixel. Record its color. If the grid boundary is hit first, it's not enclosed.
   - Look rightwards: Find the first non-background pixel. Record its color. If the grid boundary is hit first, it's not enclosed.
6. If all four directions hit a non-background pixel, and all four non-background pixels found have the *same* color, then the original background pixel is considered enclosed.
7. If a background pixel is enclosed by color 'C', change its color to 'C' in the copied grid.
8. Pixels that were not background pixels, or background pixels that were not enclosed, remain unchanged.
9. Return the modified copied grid.
"""

def get_background_color(grid):
    """Finds the most frequent color in the grid."""
    colors, counts = np.unique(grid, return_counts=True)
    return colors[np.argmax(counts)]

def check_enclosed(grid, r, c, bg_color, height, width):
    """
    Checks if the background pixel at (r, c) is enclosed by a single non-background color.
    Returns (True, frame_color) if enclosed, (False, None) otherwise.
    """
    frame_color = -1 # Use -1 to indicate no frame color found yet

    # Check Up
    found_up = False
    for i in range(r - 1, -1, -1):
        if grid[i, c] != bg_color:
            frame_color = grid[i, c]
            found_up = True
            break
    if not found_up:
        return False, None

    # Check Down
    found_down = False
    for i in range(r + 1, height):
        if grid[i, c] != bg_color:
            if grid[i, c] != frame_color: return False, None # Different color
            found_down = True
            break
    if not found_down:
        return False, None

    # Check Left
    found_left = False
    for j in range(c - 1, -1, -1):
        if grid[r, j] != bg_color:
            if grid[r, j] != frame_color: return False, None # Different color
            found_left = True
            break
    if not found_left:
        return False, None

    # Check Right
    found_right = False
    for j in range(c + 1, width):
        if grid[r, j] != bg_color:
            if grid[r, j] != frame_color: return False, None # Different color
            found_right = True
            break
    if not found_right:
        return False, None

    # If all checks passed and found the same frame color
    return True, frame_color


def transform(input_grid):
    """
    Fills the interior of hollow rectangular frames with the color of the frame.
    """
    # Convert list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid_np)
    height, width = output_grid.shape

    # Identify the background color
    bg_color = get_background_color(input_grid_np)

    # Iterate through each pixel potentially inside a frame
    for r in range(height):
        for c in range(width):
            # Check only pixels that currently have the background color
            if input_grid_np[r, c] == bg_color:
                # Check if this background pixel is enclosed
                is_enclosed, frame_color = check_enclosed(input_grid_np, r, c, bg_color, height, width)
                
                # If enclosed, fill the pixel with the frame color
                if is_enclosed:
                    output_grid[r, c] = frame_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import deque

"""
Transformation Rule:
1. Identify the background color (the most frequent color in the grid).
2. Create a copy of the input grid to serve as the output grid.
3. Find all connected components (regions) of pixels that have the background color, using 4-connectivity (up, down, left, right).
4. For each background color component:
    a. Determine the set of all neighboring pixels (pixels adjacent via 4-connectivity to any pixel in the component, but not part of the component itself).
    b. Check if the component touches the grid boundary (any pixel in the first/last row or first/last column).
    c. Collect the colors of all non-background neighboring pixels.
    d. If the component does *not* touch the grid boundary AND all its non-background neighbors have the *same* single color 'C', then fill all pixels belonging to this component in the output grid with color 'C'.
5. Pixels not belonging to such fillable background components retain their original color.
6. Return the modified output grid.
"""

def get_background_color(grid):
    """Finds the most frequent color in the grid."""
    colors, counts = np.unique(grid, return_counts=True)
    return colors[np.argmax(counts)]

def find_background_components(grid, bg_color):
    """
    Finds all connected components of the background color using BFS.
    Returns a list of sets, where each set contains the (r, c) coordinates of a component.
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(height):
        for c in range(width):
            # If it's a background pixel and not yet visited, start a BFS
            if grid[r, c] == bg_color and not visited[r, c]:
                component = set()
                q = deque([(r, c)])
                visited[r, c] = True
                component.add((r, c))

                while q:
                    row, col = q.popleft()

                    # Check neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc

                        # Check bounds and if it's a background pixel and not visited
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == bg_color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            component.add((nr, nc))
                            q.append((nr, nc))
                
                components.append(component)
                
    return components

def analyze_component(grid, component):
    """
    Analyzes a background component to find its neighbors and boundary status.
    Returns:
        - touches_boundary (bool): True if the component touches the grid edge.
        - neighbor_colors (set): A set of colors of non-background neighbors.
    """
    height, width = grid.shape
    touches_boundary = False
    neighbor_pixels = set() # Store (r, c) of neighbors to avoid recounting colors
    
    for r, c in component:
        # Check if the pixel is on the boundary
        if r == 0 or r == height - 1 or c == 0 or c == width - 1:
            touches_boundary = True
            # We can potentially stop checking boundary status early, 
            # but we still need all neighbors, so continue iteration.

        # Check neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                # If the neighbor is not part of the current component
                if (nr, nc) not in component:
                     neighbor_pixels.add((nr, nc))

    # Collect the colors of the unique neighboring pixels
    neighbor_colors = set()
    for r_n, c_n in neighbor_pixels:
        neighbor_colors.add(grid[r_n,c_n])

    return touches_boundary, neighbor_colors


def transform(input_grid):
    """
    Fills connected background regions if they are fully enclosed by a single color.
    """
    # Convert list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid_np)
    height, width = output_grid.shape

    # Identify the background color
    bg_color = get_background_color(input_grid_np)

    # Find all connected components of the background color
    background_components = find_background_components(input_grid_np, bg_color)

    # Analyze each background component
    for component in background_components:
        # Get boundary status and neighbor colors
        touches_boundary, neighbor_colors = analyze_component(input_grid_np, component)

        # Remove background color from neighbor colors if present (shouldn't happen with correct component finding, but safe)
        neighbor_colors.discard(bg_color) 

        # Check conditions for filling: not touching boundary and exactly one neighbor color
        if not touches_boundary and len(neighbor_colors) == 1:
            # Get the single neighbor color
            fill_color = neighbor_colors.pop() 
            # Fill the component in the output grid
            for r, c in component:
                output_grid[r, c] = fill_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
