{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation rule based on object detection, color mapping, shape transformation, and coordinate transposition with color-dependent placement adjustments.\n\n1.  Identify all connected components (objects) of non-background colors in the input grid. The background color is orange (7).\n2.  Create an output grid initialized with the background color.\n3.  For each identified input object:\n    a. Determine its color (`C_in`) and the top-left corner of its bounding box (`r_min`, `c_min`).\n    b. Determine the output color (`C_out`) based on `C_in` using a predefined mapping (e.g., Red->Blue, Blue->Red, Gray->Gray, Maroon->Maroon, etc.).\n    c. Determine the target output shape (`S_out`) based on `C_in` (e.g., Pixel, Line, Plus, L-shape, Scatter).\n    d. Calculate the transposed reference point: `P_t = (c_min, r_min)`.\n    e. Calculate the output reference point `P_out` by applying a color-dependent transformation/offset `T(C_in)` to `P_t`. \n        - For Maroon (9): `P_out = (P_t.row + 3, P_t.col + 3)`.\n        - For other colors, the rule is complex or currently undetermined. As a placeholder, we might use the transposed position directly or apply a default offset, acknowledging this is likely incorrect. For Gray (5), the rule seems inconsistent in the examples. Let's use `P_out = (P_t.row - 3, P_t.col - 3)` based on one example pixel, but this is speculative. For others, default to `P_out = P_t`.\n    f. Generate the pixel coordinates for the output shape `S_out` relative to `P_out`.\n        - For Maroon (9): A horizontal line of length 5 starting at `P_out`.\n        - For Gray (5): A single pixel at `P_out`.\n        - For other colors, the exact output shape generation is complex. As a placeholder, we might try drawing the *transposed* original shape relative to `P_out`, acknowledging this is incorrect for cases like Red->Plus or Blue->L.\n    g. Draw the generated output shape pixels with the `C_out` color onto the output grid, ensuring coordinates are within bounds.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds connected components (objects) of the same non-background color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary containing:\n              'color': The color of the object.\n              'pixels': A set of (row, col) tuples for the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    objects = []\n    visited = np.zeros(grid.shape, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef draw_pixel(grid, r, c, color):\n    \"\"\" Safely draws a pixel onto the grid. \"\"\"\n    rows, cols = grid.shape\n    if 0 <= r < rows and 0 <= c < cols:\n        grid[r, c] = color\n\ndef draw_horizontal_line(grid, r, c, length, color):\n    \"\"\" Safely draws a horizontal line starting at (r, c). \"\"\"\n    for i in range(length):\n        draw_pixel(grid, r, c + i, color)\n        \ndef draw_transposed_object(grid, obj_pixels, r_out_ref, c_out_ref, r_in_ref, c_in_ref, color):\n    \"\"\" \n    Placeholder: Draws the object transposed relative to the output ref point.\n    Calculates relative positions from input ref, transposes them, applies to output ref.\n    \"\"\"\n    for r_in, c_in in obj_pixels:\n        rel_r = r_in - r_in_ref\n        rel_c = c_in - c_in_ref\n        # Transpose relative coordinates\n        draw_pixel(grid, r_out_ref + rel_c, c_out_ref + rel_r, color)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    background_color = 7\n    output_grid = np.full(input_grid.shape, background_color, dtype=int)\n    rows, cols = input_grid.shape\n\n    # 1. Find all input objects\n    objects = find_objects(input_grid, background_color)\n\n    # 2. Process each object\n    for obj in objects:\n        c_in = obj['color']\n        pixels_in = obj['pixels']\n        r_min, c_min, _, _ = obj['bbox']\n\n        # a. Determine output color\n        if c_in == 2: c_out = 1\n        elif c_in == 1: c_out = 2\n        else: c_out = c_in # 5->5, 9->9, 8->8, 4->4\n\n        # b. Calculate transposed reference point (using top-left)\n        r_t, c_t = c_min, r_min\n\n        # c. Calculate output reference point based on input color (T(C_in))\n        # These rules are hypotheses based on limited examples and known inconsistencies\n        if c_in == 9: # Maroon (Ex 2) - Seems consistent\n            r_out, c_out_ref = r_t + 3, c_t + 3\n        elif c_in == 5: # Gray (Ex 2) - Inconsistent, using rule from one pixel\n             r_out, c_out_ref = r_t - 3, c_t - 3\n        # Placeholder for other colors - use transposed coordinate directly\n        # This is definitely wrong for Ex 1 (Red/Blue) and Ex 3 (Yellow/Azure) placement\n        else: \n             r_out, c_out_ref = r_t, c_t\n\n\n        # d. Draw the output shape relative to the output reference point\n        # These shape rules are also hypotheses/placeholders\n        if c_in == 9: # Maroon -> Horizontal Line Length 5\n            draw_horizontal_line(output_grid, r_out, c_out_ref, 5, c_out)\n        elif c_in == 5: # Gray -> Single Pixel\n            draw_pixel(output_grid, r_out, c_out_ref, c_out)\n        # Placeholder for other shapes: Draw the transposed original shape\n        # This is definitely wrong for Red->Plus, Blue->L, Yellow->Scatter\n        else:\n             draw_transposed_object(output_grid, pixels_in, r_out, c_out_ref, r_min, c_min, c_out)\n             \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17576,
    "candidates_token_count": 2014,
    "total_token_count": 19590,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.739983,
  "retries": 1
}