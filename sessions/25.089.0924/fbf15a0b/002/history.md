
## train_1

**input:**
```
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
5 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1 8 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 5
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 5
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
8 7 8 7 8 7 8 7 8 8
8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 3 8 3 8 8 8 3 8 3 8 8 8 3 8 3 8 3 8
8 8 3 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_4

**input:**
```
5 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 4 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 4 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 4 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 4 8 4 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's break down the task based on the provided examples.

**Perception of Elements:**

1.  **Input Grid Structure:** The input grids vary in size (height and width). They primarily consist of an azure (8) background.
2.  **Pattern Pixels:** Each input grid contains repeating patterns of a specific color (blue (1), orange (7), green (3), or yellow (4)) interspersed with the azure background color, usually along rows.
3.  **Marker Pixels:** Crucially, every input grid contains exactly two gray (5) pixels. These gray pixels appear to act as markers or signals.
4.  **Marker Alignment:** The two gray pixels in each input are always aligned either vertically (sharing the same column index) or horizontally (sharing the same row index). Their specific row/column index varies. In the vertical cases observed, they are in either the first or the last column. In the horizontal case observed, they are in the first row.
5.  **Output Grid Structure:** The output grid is always a subgrid (a crop) of the input grid. It retains the pattern pixels and background from the cropped area but excludes the gray marker pixels.
6.  **Transformation = Cropping:** The core transformation is a cropping operation applied to the input grid. The size and position of the crop are determined by the location and alignment of the two gray marker pixels.

**YAML Facts:**


```yaml
task_description: Crop the input grid based on the location and alignment of two gray marker pixels.
elements:
  - object: grid
    role: input_output
    properties:
      - type: 2D array of integers 0-9
      - background_color: azure (8)
      - contains_patterns: yes
      - contains_markers: yes, exactly two gray (5) pixels

  - object: marker_pixels
    role: signaling
    properties:
      - count: 2
      - color: gray (5)
      - alignment: either vertically (same column) or horizontally (same row)
      - location: variable, but observed in first/last column or first row

actions:
  - action: locate_markers
    input: input grid
    output: coordinates (r1, c1), (r2, c2) of the two gray pixels

  - action: determine_alignment
    input: marker coordinates
    output: axis ('vertical' or 'horizontal') and shared index (column or row)

  - action: calculate_crop_parameters
    input: input grid dimensions, marker alignment, marker location
    output: start_row, end_row, start_col, end_col for the crop

  - action: crop_grid
    input: input grid, crop parameters
    output: output grid (subgrid of input)

relationships:
  - type: dependency
    from: crop_parameters
    to: marker_alignment, marker_location, input_dimensions
  - rule: vertical_alignment
    condition: markers share the same column `c`
    effect:
      - output height is half of input height (`H_out = H_in // 2`)
      - rows to remove from top depends on `c`: 2 if `c` is first col (0), 1 if `c` is last col
      - output columns span the full input width
  - rule: horizontal_alignment
    condition: markers share the same row `r`
    effect:
      - output width is half of input width (`W_out = W_in // 2`)
      - columns to remove from left depends on `r`: 2 if `r` is first row (0) (based on single example)
      - output rows span the full input height
```


**Natural Language Program:**

1.  Identify the locations (row and column indices) of the two gray (5) pixels within the input grid.
2.  Check if the two gray pixels share the same column index (vertical alignment) or the same row index (horizontal alignment).
3.  **If vertically aligned** (sharing column `c`):
    a.  Calculate the target output height as half the input height (using integer division).
    b.  Determine the number of rows to remove from the top of the input grid: remove 2 rows if the shared column `c` is the first column (index 0); remove 1 row if the shared column `c` is the last column.
    c.  The output grid consists of the rows starting immediately after the removed rows, continuing for the calculated output height, and includes all columns from the input grid.
4.  **If horizontally aligned** (sharing row `r`):
    a.  Calculate the target output width as half the input width (using integer division).
    b.  Determine the number of columns to remove from the left of the input grid: remove 2 columns if the shared row `r` is the first row (index 0). (Note: behavior for other rows is inferred from the single horizontal example).
    c.  The output grid consists of the columns starting immediately after the removed columns, continuing for the calculated output width, and includes all rows from the input grid.
5.  Return the resulting cropped subgrid as the output.
```python
import numpy as np

"""
Identify the locations of the two gray (5) marker pixels in the input grid.
Determine if the markers are aligned vertically (same column) or horizontally (same row).

If vertically aligned in column 'c':
  - Calculate the output height as half the input height (integer division).
  - If 'c' is the first column (index 0), remove the top 2 rows.
  - If 'c' is the last column, remove the top 1 row.
  - The output is the subgrid starting after the removed rows, with the calculated height, spanning all columns.

If horizontally aligned in row 'r':
  - Calculate the output width as half the input width (integer division).
  - If 'r' is the first row (index 0), remove the leftmost 2 columns. (Based on available examples)
  - The output is the subgrid starting after the removed columns, with the calculated width, spanning all rows.

Return the resulting cropped subgrid.
"""

def find_markers(grid_np, marker_color=5):
    """Finds the coordinates of the two marker pixels."""
    coords = np.argwhere(grid_np == marker_color)
    if len(coords) != 2:
        # This case shouldn't happen based on the problem description,
        # but good to handle defensively.
        raise ValueError(f"Expected exactly 2 marker pixels (color {marker_color}), found {len(coords)}")
    return tuple(coords[0]), tuple(coords[1])

def transform(input_grid):
    """
    Crops the input grid based on the location and alignment of two gray marker pixels.
    """
    # Convert input list of lists to numpy array for easier slicing
    input_np = np.array(input_grid, dtype=int)
    h, w = input_np.shape

    # 1. Identify the locations of the two gray (5) pixels
    (r1, c1), (r2, c2) = find_markers(input_np, 5)

    output_np = None

    # 2. Check alignment and apply cropping logic
    if c1 == c2:  # Vertical alignment
        # a. Calculate target output height
        output_height = h // 2
        shared_col = c1
        start_row = 0

        # b. Determine rows to remove from top
        if shared_col == 0: # Markers in the first column
            start_row = 2
        elif shared_col == w - 1: # Markers in the last column
             start_row = 1
        else:
            # Undefined behavior based on examples, assume default or raise error
            # Let's assume start_row 1 for any other vertical case for now,
            # but this might need refinement if new examples appear.
             start_row = 1 # Placeholder assumption

        # c. Crop the grid
        output_np = input_np[start_row : start_row + output_height, :]

    elif r1 == r2:  # Horizontal alignment
        # a. Calculate target output width
        output_width = w // 2
        shared_row = r1
        start_col = 0

        # b. Determine columns to remove from left
        if shared_row == 0: # Markers in the first row
            start_col = 2
        # Based on only one horizontal example, we only have the r=0 case.
        # Need more examples to generalize behavior for markers in other rows.
        # Let's assume start_col 1 for other horizontal cases for now.
        # elif shared_row == h - 1: # Hypothetical last row case
        #     start_col = 1 # Placeholder assumption
        else:
             start_col = 1 # Placeholder assumption

        # c. Crop the grid
        output_np = input_np[:, start_col : start_col + output_width]

    else:
        # Markers are not aligned vertically or horizontally.
        # This case is not covered by the examples.
        # Returning the input unchanged or raising an error might be options.
        # Let's raise an error for clarity.
        raise ValueError("Marker pixels are not aligned vertically or horizontally.")

    # Convert the resulting numpy array back to a list of lists
    output_grid = output_np.tolist()

    return output_grid
```
