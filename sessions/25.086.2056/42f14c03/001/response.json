{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1. Determine the background color by finding the most frequent pixel color in the input grid.\n2. Identify all distinct objects (contiguous blocks of the same non-background color) in the input grid.\n3. For each object, determine its bounding box, shape (relative pixel coordinates), and whether its bounding box contains any background pixels not part of the object itself ('contains_background').\n4. Count the frequency of each unique object shape in the input grid.\n5. Select objects to keep if they either 'contain_background' or their shape appears more than once (frequency > 1).\n6. Identify the single kept object that 'contains_background'; its color becomes the 'fill_color' for the output grid.\n7. Calculate the minimal bounding box enclosing all kept objects.\n8. Create the output grid with the dimensions of the minimal bounding box, initialized with the 'fill_color'.\n9. Draw the kept objects onto the output grid at their relative positions within the minimal bounding box, overwriting the 'fill_color'.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all connected objects of non-background colors in the grid.\n    Uses Breadth-First Search (BFS).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                objects.append({\n                    'color': color,\n                    'pixels': frozenset(obj_pixels), # Use frozenset for hashability\n                    'bounding_box': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_relative_shape(pixels, min_r, min_c):\n    \"\"\"\n    Calculates the shape of an object relative to its top-left corner.\n    Returns a hashable representation (sorted tuple of relative coordinates).\n    \"\"\"\n    relative_pixels = sorted([(r - min_r, c - min_c) for r, c in pixels])\n    return tuple(relative_pixels)\n\ndef check_contains_background(grid, obj, background_color):\n    \"\"\"\n    Checks if the object's bounding box contains background pixels\n    that are not part of the object itself.\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bounding_box']\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if (r, c) not in obj['pixels'] and grid[r, c] == background_color:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Determine background color\n    background_color = Counter(input_grid.flatten()).most_common(1)[0][0]\n\n    # 2. Identify all objects\n    objects = find_objects(input_grid, background_color)\n\n    if not objects:\n        # Handle case with no non-background objects (though unlikely in ARC)\n        return np.array([[background_color]]) \n\n    # 3. & 4. Calculate properties (shape, contains_background) and shape frequency\n    shape_counts = defaultdict(int)\n    for obj in objects:\n        min_r, min_c, _, _ = obj['bounding_box']\n        obj['shape'] = get_relative_shape(obj['pixels'], min_r, min_c)\n        obj['contains_background'] = check_contains_background(input_grid, obj, background_color)\n        shape_counts[obj['shape']] += 1\n\n    for obj in objects:\n        obj['shape_frequency'] = shape_counts[obj['shape']]\n\n    # 5. Select kept objects\n    kept_objects = []\n    for obj in objects:\n        if obj['contains_background'] or obj['shape_frequency'] > 1:\n            kept_objects.append(obj)\n\n    if not kept_objects:\n         # Handle case where no objects are kept (unlikely based on examples)\n         # Returning a minimal grid with background might be a fallback,\n         # but let's follow the logic assuming kept objects exist per examples.\n         # Based on example 1, if only one object qualifies, it's the fill object.\n         # Let's assume at least one object is kept.\n         # If this assumption fails on test cases, we might need to adjust.\n         print(\"Warning: No objects were kept.\")\n         # Defaulting to a 1x1 grid of background might be safest if truly empty.\n         return np.array([[background_color]])\n\n\n    # 6. Find fill object and color\n    fill_object = None\n    for obj in kept_objects:\n        if obj['contains_background']:\n            if fill_object is not None:\n                # Error: More than one object contains background\n                # This contradicts the assumption based on examples.\n                # Let's proceed with the first one found for now.\n                print(\"Warning: Multiple objects contain background. Using the first one found.\")\n            fill_object = obj\n            #break # Assuming only one such object based on examples.\n    \n    if fill_object is None:\n        # Error: No kept object contains background.\n        # This also contradicts the assumption. What should the fill be?\n        # Maybe default to the general background? Or the color of the first kept object?\n        # Let's default to the input background color as a fallback.\n        print(\"Warning: No kept object contains background. Using input background as fill.\")\n        fill_color = background_color\n    else:\n        fill_color = fill_object['color']\n\n\n    # 7. Calculate minimal bounding box for kept objects\n    if not kept_objects: # Should not happen if previous checks are robust, but defensive coding\n         return np.array([[fill_color]]) # Return 1x1 grid with fill color\n\n    min_r_out = min(obj['bounding_box'][0] for obj in kept_objects)\n    min_c_out = min(obj['bounding_box'][1] for obj in kept_objects)\n    max_r_out = max(obj['bounding_box'][2] for obj in kept_objects)\n    max_c_out = max(obj['bounding_box'][3] for obj in kept_objects)\n\n    out_height = max_r_out - min_r_out + 1\n    out_width = max_c_out - min_c_out + 1\n\n    # 8. Create output grid initialized with fill_color\n    output_grid = np.full((out_height, out_width), fill_color, dtype=input_grid.dtype)\n\n    # 9. Place kept objects onto the output grid\n    for obj in kept_objects:\n        obj_color = obj['color']\n        for r, c in obj['pixels']:\n            out_r = r - min_r_out\n            out_c = c - min_c_out\n            # Check bounds just in case, though theoretically unnecessary if BB is correct\n            if 0 <= out_r < out_height and 0 <= out_c < out_width:\n                 output_grid[out_r, out_c] = obj_color\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3684,
    "candidates_token_count": 2036,
    "total_token_count": 5720,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.16732,
  "retries": null
}