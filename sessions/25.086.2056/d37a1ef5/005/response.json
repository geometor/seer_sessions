{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a rectangular frame made of red (2) pixels.\nDetermines the region strictly inside this frame (the interior).\nPerforms a flood fill starting from white (0) pixels within the interior that are adjacent to the red frame boundary.\nThe fill propagates only through other white (0) pixels within the interior, using 4-directional adjacency.\nGray (5) pixels (and any other non-white pixels) within the interior act as barriers, stopping the flood fill.\nAll white pixels reached by the flood fill are changed to red (2).\nAll other pixels (the red frame, pixels outside the frame, gray pixels inside, unreached white pixels inside) remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# Constants for colors\nWHITE = 0\nRED = 2\nGRAY = 5 # Implicitly acts as a barrier, along with any non-WHITE pixel\n\ndef _find_frame_bounds(grid):\n    \"\"\"\n    Finds the min/max row/col of red pixels potentially defining the frame.\n    Returns (min_row, max_row, min_col, max_col) or None if no red pixels.\n    \"\"\"\n    red_pixels = np.argwhere(grid == RED)\n    if red_pixels.size == 0:\n        return None\n    min_row = np.min(red_pixels[:, 0])\n    max_row = np.max(red_pixels[:, 0])\n    min_col = np.min(red_pixels[:, 1])\n    max_col = np.max(red_pixels[:, 1])\n    \n    # Basic validation: Check if all edge pixels within bounds are red\n    # This assumes a solid rectangular frame. More complex frame detection might be needed\n    # if frames can be incomplete or have gaps, but based on examples, this seems sufficient.\n    for r in range(min_row, max_row + 1):\n        if grid[r, min_col] != RED or grid[r, max_col] != RED:\n            # This might indicate noise or multiple red shapes, not a simple frame.\n            # For this task's examples, we assume a solid frame exists if red pixels are found.\n            pass # Proceeding with found bounds, assuming simple frame context\n    for c in range(min_col, max_col + 1):\n        if grid[min_row, c] != RED or grid[max_row, c] != RED:\n            pass # Proceeding with found bounds\n\n    return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the area inside a red rectangular frame with red, replacing only white\n    pixels reachable from the frame boundary via other white pixels (flood fill),\n    avoiding gray pixels.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed grid.\n    \"\"\"\n    # Convert input grid to a NumPy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Identify the Frame boundaries\n    frame_bounds = _find_frame_bounds(grid)\n\n    # If no frame is found, return the original grid\n    if frame_bounds is None:\n        return output_grid.tolist()\n\n    min_row_frame, max_row_frame, min_col_frame, max_col_frame = frame_bounds\n\n    # 2. Define the Interior boundaries (inclusive)\n    min_row_interior = min_row_frame + 1\n    max_row_interior = max_row_frame - 1\n    min_col_interior = min_col_frame + 1\n    max_col_interior = max_col_frame - 1\n\n    # Check if interior exists (frame might be too thin or invalid)\n    if min_row_interior > max_row_interior or min_col_interior > max_col_interior:\n        return output_grid.tolist() # No interior space to fill\n\n    # 3. Initialize Flood Fill structures\n    queue = deque()\n    visited = set() # Keep track of visited interior white cells to avoid cycles and re-processing\n\n    # 4. Identify Seed Pixels for Flood Fill\n    # Seeds are white pixels *inside* the interior that are adjacent to the frame\n    for r in range(min_row_interior, max_row_interior + 1):\n        for c in range(min_col_interior, max_col_interior + 1):\n            if grid[r, c] == WHITE:\n                # Check adjacency to the frame (pixels just outside the interior)\n                is_seed = False\n                # Check top frame boundary\n                if r == min_row_interior and grid[r - 1, c] == RED: is_seed = True\n                # Check bottom frame boundary\n                if not is_seed and r == max_row_interior and grid[r + 1, c] == RED: is_seed = True\n                # Check left frame boundary\n                if not is_seed and c == min_col_interior and grid[r, c - 1] == RED: is_seed = True\n                # Check right frame boundary\n                if not is_seed and c == max_col_interior and grid[r, c + 1] == RED: is_seed = True\n\n                if is_seed and (r, c) not in visited:\n                    queue.append((r, c))\n                    visited.add((r, c))\n\n    # 5. Perform Flood Fill\n    while queue:\n        r, c = queue.popleft()\n\n        # Change the color of the current reachable white pixel to red\n        output_grid[r, c] = RED\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within the interior bounds\n            if min_row_interior <= nr <= max_row_interior and \\\n               min_col_interior <= nc <= max_col_interior:\n                \n                # Check if the neighbor is white in the *original* grid\n                # and has not been visited yet\n                if grid[nr, nc] == WHITE and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n\n    # 6. Return Output\n    # Convert the final NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6744,
    "candidates_token_count": 1550,
    "total_token_count": 8294,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.361894,
  "retries": null
}