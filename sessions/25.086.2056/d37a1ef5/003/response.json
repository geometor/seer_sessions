{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a rectangular frame made of red (2) pixels.\nDetermines the region strictly inside this frame (the interior).\nIterates through all white (0) pixels within this interior region.\nA white pixel is changed to red (2) if and only if there is an unobstructed path (containing no gray (5) pixels) from at least one of the four interior boundaries (top, bottom, left, right) to that pixel, moving only horizontally or vertically within the interior.\nGray (5) pixels act as blockers.\nAll other pixels (the red frame, pixels outside the frame, gray pixels inside the frame, and any other non-white pixels inside) remain unchanged.\n\"\"\"\n\n# Constants for colors\nWHITE = 0\nRED = 2\nGRAY = 5\n\ndef _find_frame_bounds(grid):\n    \"\"\"Finds the min/max row/col of red pixels defining the frame.\"\"\"\n    red_pixels = np.argwhere(grid == RED)\n    if red_pixels.size == 0:\n        return None\n    min_row = np.min(red_pixels[:, 0])\n    max_row = np.max(red_pixels[:, 0])\n    min_col = np.min(red_pixels[:, 1])\n    max_col = np.max(red_pixels[:, 1])\n    return min_row, max_row, min_col, max_col\n\ndef _is_reachable_from_left(grid, r, c, min_col_interior):\n    \"\"\"Checks if pixel (r, c) is reachable from the left interior boundary.\"\"\"\n    # Check the path from the left boundary (min_col_interior) up to (but not including) c\n    for k in range(min_col_interior, c):\n        if grid[r, k] == GRAY:\n            return False\n    return True\n\ndef _is_reachable_from_right(grid, r, c, max_col_interior):\n    \"\"\"Checks if pixel (r, c) is reachable from the right interior boundary.\"\"\"\n    # Check the path from the right boundary (max_col_interior) down to (but not including) c\n    for k in range(c + 1, max_col_interior + 1):\n        if grid[r, k] == GRAY:\n            return False\n    return True\n\ndef _is_reachable_from_top(grid, r, c, min_row_interior):\n    \"\"\"Checks if pixel (r, c) is reachable from the top interior boundary.\"\"\"\n    # Check the path from the top boundary (min_row_interior) up to (but not including) r\n    for k in range(min_row_interior, r):\n        if grid[k, c] == GRAY:\n            return False\n    return True\n\ndef _is_reachable_from_bottom(grid, r, c, max_row_interior):\n    \"\"\"Checks if pixel (r, c) is reachable from the bottom interior boundary.\"\"\"\n    # Check the path from the bottom boundary (max_row_interior) down to (but not including) r\n    for k in range(r + 1, max_row_interior + 1):\n        if grid[k, c] == GRAY:\n            return False\n    return True\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the area inside a red rectangular frame with red, replacing only white\n    pixels that are reachable from the frame boundary without crossing gray pixels.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed grid.\n    \"\"\"\n    # Convert input grid to a NumPy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify\n    output_grid = grid.copy()\n    \n    # 1. Identify the Frame boundaries\n    frame_bounds = _find_frame_bounds(grid)\n    \n    # If no frame is found, return the original grid\n    if frame_bounds is None:\n        return output_grid.tolist()\n        \n    min_row_frame, max_row_frame, min_col_frame, max_col_frame = frame_bounds\n\n    # 2. Define the Interior boundaries (inclusive)\n    min_row_interior = min_row_frame + 1\n    max_row_interior = max_row_frame - 1\n    min_col_interior = min_col_frame + 1\n    max_col_interior = max_col_frame - 1\n\n    # Check if interior exists (frame might be too thin)\n    if min_row_interior > max_row_interior or min_col_interior > max_col_interior:\n        return output_grid.tolist() # No interior space to fill\n\n    # 3. Iterate through each pixel within the calculated interior region\n    for r in range(min_row_interior, max_row_interior + 1):\n        for c in range(min_col_interior, max_col_interior + 1):\n            \n            # 4. Check if the current pixel in the original grid is white (0)\n            if grid[r, c] == WHITE:\n                \n                # 5. Determine reachability from boundaries without hitting gray obstacles\n                reachable_left = _is_reachable_from_left(grid, r, c, min_col_interior)\n                reachable_right = _is_reachable_from_right(grid, r, c, max_col_interior)\n                reachable_top = _is_reachable_from_top(grid, r, c, min_row_interior)\n                reachable_bottom = _is_reachable_from_bottom(grid, r, c, max_row_interior)\n                \n                # 6. If reachable from at least one direction, change to red\n                if reachable_left or reachable_right or reachable_top or reachable_bottom:\n                    output_grid[r, c] = RED\n            \n            # Pixels that are not white (e.g., gray obstacles) or white pixels\n            # that are not reachable remain unchanged because output_grid\n            # started as a copy of the input grid.\n\n    # Convert the final NumPy array back to a list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6146,
    "candidates_token_count": 1450,
    "total_token_count": 7596,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 91.13273,
  "retries": null
}