{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nIdentifies all distinct connected objects (groups of contiguous pixels of the same color, excluding background 0) in the input grid.\nFor each object, determines its color and calculates the area of its bounding box.\nFilters the list of objects: For each color present, keeps only the single object of that color with the largest bounding box area.\nFrom this filtered list, identifies the 'container' object as the one with the overall largest bounding box area (smallest color index tie-breaker).\nDetermines the square output grid size (N) as the maximum of the container object's bounding box height and width.\nInitializes an N x N output grid with the background color (0).\nCreates a sequence of layer colors: container color first, followed by the colors of the remaining filtered ('content') objects, sorted by descending bounding box area (ascending color index tie-breaker).\nDraws concentric square frames (layers) onto the output grid using the color sequence, starting from the outermost frame (size NxN) and working inwards (N-2 x N-2, N-4 x N-4, etc.), until the center is filled or the color sequence is exhausted.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components (objects) of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int) and 'pixels' (set of (r, c) tuples).\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if it's a non-background pixel and not visited\n            if color != background_color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n\n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        dict: A dictionary containing 'min_row', 'max_row', 'min_col', 'max_col',\n              'height', 'width', and 'area'. Returns None if obj_pixels is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n\n    min_row = min(rows)\n    max_row = max(rows)\n    min_col = min(cols)\n    max_col = max(cols)\n\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    area = height * width\n\n    return {\n        'min_row': min_row, 'max_row': max_row,\n        'min_col': min_col, 'max_col': max_col,\n        'height': height, 'width': width, 'area': area\n    }\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by drawing concentric layers based on filtered object properties.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    background_color = 0\n\n    # 1. Identify all distinct connected objects\n    all_objects_raw = find_objects(input_np)\n\n    if not all_objects_raw:\n        # Handle case with no colored objects. Return a 1x1 background grid.\n        return [[background_color]]\n\n    # 2. Calculate bounding boxes for all objects\n    all_object_details = []\n    for i, obj in enumerate(all_objects_raw):\n        bbox = get_bounding_box(obj['pixels'])\n        if bbox:\n            # Add a unique ID based on detection order for stable tie-breaking if needed later,\n            # though primary tie-breaking is color index.\n            all_object_details.append({'id': i, 'color': obj['color'], **bbox})\n\n    # 3. Filter objects: Keep only the one with the largest BB area for each color\n    grouped_by_color = defaultdict(list)\n    for obj in all_object_details:\n        grouped_by_color[obj['color']].append(obj)\n\n    filtered_objects = []\n    for color, objs_of_color in grouped_by_color.items():\n        # Find the object with the maximum area within this color group.\n        # Tie-breaking within the same color (if areas are equal) isn't explicitly defined by\n        # the examples, but choosing the first encountered (lowest 'id') is a stable approach.\n        # However, the problem description's tie-breaking (min color index) applies *between*\n        # different colors when comparing for container/content sorting.\n        largest_obj_for_color = max(objs_of_color, key=lambda x: x['area'])\n        filtered_objects.append(largest_obj_for_color)\n\n    if not filtered_objects:\n         # This case should not happen if all_objects_raw was not empty\n         return [[background_color]]\n\n    # 4. Identify Container Object (largest BB area, smallest color index tie-breaker)\n    # The sort key uses a tuple: (area, -color). Larger area is better.\n    # For equal areas, smaller color index is better (hence -color makes smaller colors have larger negative values).\n    container_obj = max(filtered_objects, key=lambda x: (x['area'], -x['color']))\n\n    # 5. Determine Output Size (max dimension of container's BB)\n    output_size = max(container_obj['height'], container_obj['width'])\n\n    # 6. Identify and Sort Content Objects\n    content_objects = [obj for obj in filtered_objects if obj['id'] != container_obj['id']]\n    # Sort descending by area, then ascending by color index (smaller color index first)\n    content_objects.sort(key=lambda x: (x['area'], -x['color']), reverse=True)\n\n    # 7. Create Layer Color Sequence\n    layer_colors = [container_obj['color']] + [obj['color'] for obj in content_objects]\n\n    # 8. Initialize Output Grid\n    output_grid = np.full((output_size, output_size), background_color, dtype=int)\n\n    # 9. Draw Concentric Layers\n    current_size = output_size\n    top_row, left_col = 0, 0\n\n    for color in layer_colors:\n        # Stop if the drawing area has shrunk to nothing or below\n        if current_size <= 0:\n            break\n\n        # Define the bounds for the current layer's frame\n        bottom_row = top_row + current_size - 1\n        right_col = left_col + current_size - 1\n\n        # Ensure bounds are within the grid (should always be true if logic is correct)\n        if top_row > bottom_row or left_col > right_col:\n            break # Safety break\n\n        # Draw the frame for the current layer\n        if current_size == 1:\n            # Special case for 1x1 center\n             output_grid[top_row, left_col] = color\n        else:\n            # Top row\n            output_grid[top_row, left_col:right_col + 1] = color\n            # Bottom row\n            output_grid[bottom_row, left_col:right_col + 1] = color\n            # Left column (excluding corners already set by row drawing)\n            output_grid[top_row + 1:bottom_row, left_col] = color\n            # Right column (excluding corners already set by row drawing)\n            output_grid[top_row + 1:bottom_row, right_col] = color\n\n        # Shrink parameters for the next inner layer\n        current_size -= 2\n        top_row += 1\n        left_col += 1\n\n    # 10. Return Output as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10684,
    "candidates_token_count": 2181,
    "total_token_count": 12865,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.355819,
  "retries": null
}