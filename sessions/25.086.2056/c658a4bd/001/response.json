{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all colored objects (connected components of non-background pixels) in the input grid.\nFor each object, calculates its bounding box area.\nSelects the object with the largest bounding box area as the \"container\".\nDetermines the output grid size as the maximum dimension (height or width) of the container's bounding box.\nSorts the remaining objects (\"content\") by their bounding box area in descending order.\nCreates the output grid by drawing concentric square layers, starting with the container color on the outside, followed by the colors of the sorted content objects inwards.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components (objects) of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int) and 'pixels' (set of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if it's a colored pixel and not visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n                    \n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        obj_pixels (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        dict: A dictionary containing 'min_row', 'max_row', 'min_col', 'max_col',\n              'height', 'width', and 'area'. Returns None if obj_pixels is empty.\n    \"\"\"\n    if not obj_pixels:\n        return None\n        \n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    \n    min_row = min(rows)\n    max_row = max(rows)\n    min_col = min(cols)\n    max_col = max(cols)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    area = height * width\n    \n    return {\n        'min_row': min_row, 'max_row': max_row, \n        'min_col': min_col, 'max_col': max_col,\n        'height': height, 'width': width, 'area': area\n    }\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on object bounding boxes and layering.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify Objects\n    objects = find_objects(input_np)\n    \n    if not objects:\n        # Handle case with no colored objects - return empty or original?\n        # Based on task structure, probably won't happen, but returning 1x1 white for safety.\n        return [[0]] \n\n    # 2. Calculate Bounding Boxes for all objects\n    object_details = []\n    for obj in objects:\n        bbox = get_bounding_box(obj['pixels'])\n        if bbox:\n            object_details.append({'color': obj['color'], **bbox})\n\n    if not object_details:\n         return [[0]] # Should not happen if find_objects found objects\n\n    # 3. Identify Container Object (largest BB area)\n    # Tie-breaking: Use smallest color index if areas are equal.\n    container_obj = max(object_details, key=lambda x: (x['area'], -x['color']))\n    \n    # 4. Determine Output Size\n    output_size = max(container_obj['height'], container_obj['width'])\n    \n    # 5. Identify and Sort Content Objects\n    content_objects = [obj for obj in object_details if obj != container_obj]\n    # Sort descending by area, then ascending by color index (smaller color index first)\n    content_objects.sort(key=lambda x: (x['area'], -x['color']), reverse=True)\n    \n    # 6. Initialize Output Grid (using a value like -1 might help debug if pixels aren't filled)\n    # Let's initialize with 0 (background) as the final grid likely keeps 0 if layers don't cover everything.\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n\n    # 7. Draw Layers\n    layer_colors = [container_obj['color']] + [obj['color'] for obj in content_objects]\n    \n    current_size = output_size\n    top_row, left_col = 0, 0\n    \n    for color in layer_colors:\n        # Stop if the drawing area has shrunk to nothing\n        if current_size <= 0:\n            break\n            \n        # Define the bounds for the current layer\n        bottom_row = top_row + current_size - 1\n        right_col = left_col + current_size - 1\n        \n        # Draw the frame for the current layer\n        if current_size == 1:\n            # Special case for 1x1 center\n             output_grid[top_row, left_col] = color\n        else:\n            # Top row\n            output_grid[top_row, left_col:right_col + 1] = color\n            # Bottom row\n            output_grid[bottom_row, left_col:right_col + 1] = color\n            # Left column (excluding corners already set)\n            output_grid[top_row + 1:bottom_row, left_col] = color\n            # Right column (excluding corners already set)\n            output_grid[top_row + 1:bottom_row, right_col] = color\n\n        # Update parameters for the next inner layer\n        current_size -= 2\n        top_row += 1\n        left_col += 1\n        \n    # 8. Return Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4454,
    "candidates_token_count": 1703,
    "total_token_count": 6157,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.525979,
  "retries": null
}