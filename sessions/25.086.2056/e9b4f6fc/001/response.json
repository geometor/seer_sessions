{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the largest contiguous non-background object in the input grid.\nDetermine its bounding box.\nFind all pairs of orthogonally adjacent non-background colors outside this bounding box.\nThese pairs define a color transformation map: if color A is adjacent to color B, then color B maps to color A.\nExtract the subgrid corresponding to the largest object's bounding box.\nApply the color transformation map to every pixel within this extracted subgrid.\nPixels whose colors are not in the 'B' side of the map retain their original color.\nThe transformed subgrid is the output.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of objects. Each object is a dictionary containing:\n              'color': The color of the object.\n              'coords': A set of (row, col) tuples representing the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col) for the bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != ignore_color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef find_largest_object(grid, ignore_color=0):\n    \"\"\"\n    Finds the largest contiguous non-background object in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The background color to ignore.\n\n    Returns:\n        dict or None: The largest object dictionary, or None if no objects found.\n                      Includes 'color', 'coords', and 'bbox'.\n    \"\"\"\n    objects = find_objects(grid, ignore_color=ignore_color)\n    if not objects:\n        return None\n    \n    largest_obj = max(objects, key=lambda obj: len(obj['coords']))\n    return largest_obj\n\ndef find_external_adjacency_map(grid, bbox, ignore_color=0):\n    \"\"\"\n    Finds adjacent non-background color pairs outside the given bounding box.\n    Creates a map where if A is adjacent to B, B maps to A.\n\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c) of the main object.\n        ignore_color (int): The background color.\n\n    Returns:\n        dict: A dictionary mapping color_B -> color_A.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c, max_r, max_c = bbox\n    color_map = {}\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is outside the bounding box\n            is_outside = not (min_r <= r <= max_r and min_c <= c <= max_c)\n            \n            if is_outside and grid[r, c] != ignore_color:\n                color_B = grid[r, c]\n                # Check orthogonal neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    \n                    # Check if neighbor is within bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if neighbor is also outside bbox and not background\n                        neighbor_is_outside = not (min_r <= nr <= max_r and min_c <= nc <= max_c)\n                        color_A = grid[nr, nc]\n                        \n                        if neighbor_is_outside and color_A != ignore_color:\n                             # Found an adjacent pair (A, B) outside bbox\n                             # Rule: B maps to A\n                             # If B is already mapped, we assume the examples don't have conflicts\n                             # or the first one found is sufficient. Based on examples, conflicts seem unlikely.\n                             if color_B not in color_map:\n                                color_map[color_B] = color_A\n                             # Optional: If conflicts need specific handling, add logic here.\n                             # E.g., if color_map[color_B] != color_A: print(\"Conflict detected!\")\n                             \n                             # Since we iterate through B and check neighbors A,\n                             # we might double-count pairs in reverse.\n                             # The map {B:A} handles this implicitly if A!=B.\n                             # If A==B, it doesn't matter.\n    return color_map\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on external color adjacencies applied to the largest object.\n\n    Args:\n        input_grid (np.array): The input grid as a NumPy array.\n\n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    # Find the largest non-background object and its bounding box\n    largest_object = find_largest_object(input_grid, ignore_color=0)\n    if largest_object is None:\n        # Handle case with no non-background objects if necessary\n        # Depending on ARC task constraints, maybe return empty or original grid?\n        # For this task, assume there's always a main object.\n        return np.array([[]]) # Or raise error\n\n    bbox = largest_object['bbox']\n    min_r, min_c, max_r, max_c = bbox\n\n    # Find the color transformation map from adjacencies outside the bbox\n    color_map = find_external_adjacency_map(input_grid, bbox, ignore_color=0)\n\n    # Extract the subgrid corresponding to the bounding box\n    subgrid = input_grid[min_r : max_r + 1, min_c : max_c + 1]\n\n    # Create the output grid by copying the subgrid\n    output_grid = np.copy(subgrid)\n    output_rows, output_cols = output_grid.shape\n\n    # Apply the color map to the output grid\n    for r in range(output_rows):\n        for c in range(output_cols):\n            current_color = output_grid[r, c]\n            if current_color in color_map:\n                output_grid[r, c] = color_map[current_color]\n            # Colors not in the map's keys remain unchanged\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4294,
    "candidates_token_count": 1839,
    "total_token_count": 6133,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 160.862323,
  "retries": null
}