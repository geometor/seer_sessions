{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport bisect\n\n\"\"\"\nRecolors azure (8) regions based on mapping vertical color lines to zones defined by the unique start columns of azure segments.\n\n1.  Initialize an output grid of the same dimensions as the input grid, filled with white (0).\n2.  Find all full-height vertical lines of a single, non-white (0), non-azure (8) color on the left. Sort them left-to-right by column index. Let N be the count of these lines.\n3.  Find all horizontal segments of contiguous azure (8) pixels.\n4.  Collect the unique starting column indices from these azure segments and sort them. Let M be the count of unique start columns.\n5.  If N > 0 and N equals M, proceed. Otherwise, return the white grid.\n6.  For each pixel (r, c) in the input grid:\n    a.  If the pixel is azure (8):\n        i.  Find the index `k` of the largest unique start column value that is less than or equal to `c`.\n        ii. Get the color `C` from the k-th vertical line (using the same index `k`).\n        iii. Set `OutputGrid[r, c]` to color `C`.\n7.  Return the output grid.\n\"\"\"\n\ndef find_vertical_lines(input_grid):\n    \"\"\"\n    Finds full-height vertical lines of a single non-white(0), non-azure(8) color.\n    Returns a list of dicts {'color': c, 'col_index': i}, sorted by col_index.\n    \"\"\"\n    height, width = input_grid.shape\n    lines = []\n    if height == 0: # Handle empty grid case\n        return lines\n\n    for c in range(width):\n        col = input_grid[:, c]\n        first_color = col[0]\n        # Check if the first pixel is a potential line color and if the column is non-empty\n        if height > 0 and first_color != 0 and first_color != 8:\n            is_line = True\n            # Check if all pixels in the column match the first pixel's color\n            for r in range(1, height):\n                if col[r] != first_color:\n                    is_line = False\n                    break\n            if is_line:\n                lines.append({'color': first_color, 'col_index': c})\n        # Optimization: If we encounter an azure pixel, we can assume lines won't appear further right based on examples\n        # although this isn't strictly necessary based on the logic. Let's stick to the simpler rule first.\n        # if height > 0 and 8 in col:\n        #      break # Assuming lines are always fully to the left of any azure pixel\n\n    # Sort lines by column index (already processed in order, but explicit sort is safer)\n    lines.sort(key=lambda x: x['col_index'])\n    return lines\n\ndef find_azure_segments(input_grid):\n    \"\"\"\n    Finds all maximal contiguous horizontal segments of azure (8) pixels.\n    Returns a list of tuples: (row_index, start_col, end_col).\n    \"\"\"\n    height, width = input_grid.shape\n    segments = []\n    for r in range(height):\n        c = 0\n        while c < width:\n            # Find the start of an azure segment\n            if input_grid[r, c] == 8:\n                start_col = c\n                # Find the end of the segment\n                while c + 1 < width and input_grid[r, c + 1] == 8:\n                    c += 1\n                end_col = c\n                segments.append((r, start_col, end_col))\n            c += 1\n    return segments\n\ndef get_unique_sorted_start_cols(segments):\n    \"\"\"\n    Extracts unique start column indices from segments and sorts them.\n    Returns a sorted list of unique start column indices.\n    \"\"\"\n    if not segments:\n        return []\n    start_cols = set(s[1] for s in segments)\n    return sorted(list(start_cols))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring azure pixels based on vertical color lines\n    and zones defined by unique azure segment start columns.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=np.int64)\n    height, width = input_grid_np.shape\n    \n    # 1. Initialize output_grid with white (0)\n    output_grid = np.zeros_like(input_grid_np)\n\n    # 2. Identify & Sort Color Lines\n    vertical_lines = find_vertical_lines(input_grid_np)\n    N = len(vertical_lines)\n\n    # 3. Identify Azure Horizontal Segments\n    azure_segments = find_azure_segments(input_grid_np)\n\n    # 4. Get Unique Sorted Azure Start Columns\n    unique_start_cols = get_unique_sorted_start_cols(azure_segments)\n    M = len(unique_start_cols)\n\n    # 5. Condition Check: N > 0 and N == M\n    if N > 0 and N == M:\n        # 6. Coloring based on zones\n        for r in range(height):\n            for c in range(width):\n                # a. Check if pixel is azure\n                if input_grid_np[r, c] == 8:\n                    # i. Find the index k of the largest start column <= c\n                    # `bisect_right` finds the insertion point for c in unique_start_cols.\n                    # Subtracting 1 gives the index of the rightmost element <= c.\n                    k = bisect.bisect_right(unique_start_cols, c) - 1\n                    \n                    # Ensure k is a valid index (should be if c came from an azure segment)\n                    if 0 <= k < N:\n                         # ii. Get the color C from the k-th vertical line\n                         line_color = vertical_lines[k]['color']\n                         # iii. Set output pixel color\n                         output_grid[r, c] = line_color\n                    # else: This case implies c is less than the smallest start_col,\n                    # which shouldn't happen for an azure pixel if M > 0.\n                    # Or k >= N which shouldn't happen if N == M.\n                    # If it does, pixel remains white (0).\n\n    # 7. Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6492,
    "candidates_token_count": 1531,
    "total_token_count": 8023,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.85747,
  "retries": null
}