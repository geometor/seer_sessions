{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1. Identifies a \"Central Structure,\" which is a contiguous horizontal sequence of non-white pixels in the first row (row 0).\n2. Identifies \"Peripheral Pixels,\" which are all other non-white pixels in the grid (rows > 0).\n3. Associates each Peripheral Pixel with a column in the Central Structure based on matching colors.\n4. Replicates the Central Structure pattern vertically downwards into rows above the topmost Peripheral Pixel.\n5. Draws horizontal lines connecting each Peripheral Pixel to its associated column in the Central Structure.\n6. Draws vertical lines downwards from each column of the Central Structure. The line extends to the row of the lowest Peripheral Pixel associated with that column's color. If no Peripheral Pixel is associated with a column's color, the vertical line extends to the bottom of the grid.\n\"\"\"\n\ndef find_central_structure(grid):\n    \"\"\"\n    Finds the contiguous horizontal block of non-white pixels in the first row.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (start_col, end_col, structure_map)\n               start_col: Starting column index of the structure.\n               end_col: Ending column index of the structure (inclusive).\n               structure_map: Dictionary mapping column index to color {col: color}.\n               Returns (None, None, None) if no structure is found.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0:\n        return None, None, None\n\n    row0 = grid[0, :]\n    non_white_indices = np.where(row0 != 0)[0]\n\n    if len(non_white_indices) == 0:\n        return None, None, None\n\n    start_col = non_white_indices[0]\n    end_col = non_white_indices[0]\n    structure_map = {}\n\n    # Check for contiguity\n    for i in range(len(non_white_indices) - 1):\n        if non_white_indices[i+1] != non_white_indices[i] + 1:\n             # If non-contiguous non-white cells are found in row 0,\n             # the definition might be ambiguous. Based on examples,\n             # we assume the first contiguous block is the structure.\n             # Or potentially just the segment between the first and last non-zero.\n             # Let's assume the first contiguous block for now.\n             end_col = non_white_indices[i]\n             break\n    else:\n        # If the loop finishes without breaking, the structure is fully contiguous\n        end_col = non_white_indices[-1]\n\n    # Build the map for the identified structure range\n    for c in range(start_col, end_col + 1):\n        color = grid[0, c]\n        if color != 0: # Should always be true within this range based on logic\n             structure_map[c] = color\n        # If there are zeros within the start/end range, the definition might need refinement.\n        # Based on examples, the structure seems solid non-zero.\n\n    if not structure_map: # If only zeros were found between start and end (unlikely)\n        return None, None, None\n\n    return start_col, end_col, structure_map\n\ndef find_peripheral_pixels(grid):\n    \"\"\"\n    Finds all non-white pixels not in the first row.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples [(row, col, color), ...].\n    \"\"\"\n    rows, cols = grid.shape\n    peripheral_pixels = []\n    for r in range(1, rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0:\n                peripheral_pixels.append((r, c, color))\n    return peripheral_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    output_grid = np.copy(input_grid_np)\n\n    # 1. Identify the Central Structure\n    start_col, end_col, structure_map = find_central_structure(input_grid_np)\n\n    if start_col is None:\n        # No central structure found, return the original grid?\n        # Based on examples, a structure always exists.\n        return input_grid # Or raise an error, depending on expected behavior\n\n    # Create reverse map for color to target column\n    color_to_target_col = {color: c for c, color in structure_map.items()}\n\n    # 2. Identify Peripheral Pixels\n    peripheral_pixels = find_peripheral_pixels(input_grid_np)\n\n    # 3. Determine Target Column for each Peripheral Pixel & find min_p_row\n    min_p_row = rows # Default to grid height if no peripherals\n    peripherals_with_targets = []\n    if peripheral_pixels:\n        min_p_row = min(p[0] for p in peripheral_pixels)\n        for r, c, color in peripheral_pixels:\n            target_col = color_to_target_col.get(color)\n            if target_col is not None:\n                 peripherals_with_targets.append({'row': r, 'col': c, 'color': color, 'target_col': target_col})\n            # else: handle case where peripheral color not in structure (ignore for now)\n\n\n    # 4. Replicate the Central Structure vertically\n    for r_rep in range(1, min_p_row):\n        for c_struct in range(start_col, end_col + 1):\n             output_grid[r_rep, c_struct] = structure_map[c_struct]\n\n    # 5 & 6. Draw Horizontal and Vertical Lines\n    max_row_for_column = {c: -1 for c in structure_map.keys()}\n\n    # 5a. Process peripherals: draw horizontal lines and update max rows\n    for p in peripherals_with_targets:\n        p_row, p_col, p_color, c_target = p['row'], p['col'], p['color'], p['target_col']\n\n        # Draw horizontal line segment\n        if p_col < c_target:\n            for c_fill in range(p_col + 1, c_target): # Fill between pixel and target col\n                 output_grid[p_row, c_fill] = p_color\n        elif p_col > c_target:\n            for c_fill in range(c_target + 1, p_col): # Fill between target col and pixel\n                 output_grid[p_row, c_fill] = p_color\n\n        # Update max row for the target column\n        max_row_for_column[c_target] = max(max_row_for_column[c_target], p_row)\n\n    # 6a. Draw vertical lines based on max rows or grid height\n    for c_struct in range(start_col, end_col + 1):\n        struct_color = structure_map[c_struct]\n        \n        # Determine end row for the vertical line\n        r_end = max_row_for_column.get(c_struct, -1) # Use .get() in case a structure col had no associated peripherals\n        if r_end == -1: # No peripheral pixel targeted this column\n            r_end = rows - 1 # Extend to the bottom\n            \n        # Draw vertical line segment downwards from row 1\n        # Note: Row 0 is already set, replication handles rows 1 to min_p_row-1\n        # This loop potentially redraws over replicated parts, which is fine.\n        # It also fills below the lowest peripheral pixel row if needed.\n        for r_fill in range(1, r_end + 1):\n            # We only fill if the target row is below any potential replication\n            # No, the logic should just fill down to r_end. Replication happens first.\n            output_grid[r_fill, c_struct] = struct_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4920,
    "candidates_token_count": 1918,
    "total_token_count": 6838,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.704647,
  "retries": null
}