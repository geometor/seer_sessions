
## train_1

**input:**
```
0 0 0 0 5 3 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 5 3 8 0 0 0 0 0
0 0 0 0 5 3 8 0 0 0 0 0
0 0 0 0 5 3 8 0 0 0 0 0
0 0 0 0 5 3 8 0 0 0 0 0
5 5 5 5 5 3 8 0 0 0 0 0
0 0 0 0 0 3 8 8 8 8 8 8
0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0
3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 6 5 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 6 5 3 0 0 0 0 0 0 0
0 0 0 0 0 6 5 3 0 0 0 0 0 0 0
0 0 0 0 0 6 5 3 3 3 3 3 3 3 3
0 0 0 0 0 6 5 0 0 0 0 0 0 0 0
6 6 6 6 6 6 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 4 6 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 6
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 4 6 2 0 0 0 0 0
0 0 0 4 6 2 0 0 0 0 0
0 0 0 4 6 2 0 0 0 0 0
0 0 0 4 6 2 0 0 0 0 0
4 4 4 4 6 2 2 2 2 2 2
0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 6 6 6 6 6 6 6
0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the input-output pairs to understand the transformation.

**Perception of Elements:**

1.  **Input Structure:** The input grids contain a background of white pixels (0) and a few scattered non-white pixels.
2.  **Key Feature:** In each input, there is a contiguous horizontal sequence of non-white pixels located in the top row (row 0). This sequence appears to be a central element or "structure".
3.  **Other Elements:** Besides the top-row structure, there are other isolated non-white pixels located elsewhere in the grid. Let's call these "peripheral pixels".
4.  **Output Structure:** The output grids retain all the original non-white pixels from the input. Additionally, new horizontal and vertical lines of color are drawn, connecting the peripheral pixels to the columns of the central structure. The central structure itself is also extended downwards.

**Detailed Analysis & Transformation Steps:**

1.  **Identify Central Structure:** Locate the horizontal block of adjacent non-white pixels in row 0. Note its start column, end column, and the color in each cell.
2.  **Identify Peripheral Pixels:** Locate all other non-white pixels in the grid. Note their color and position (row, column).
3.  **Establish Connection Logic:**
    *   Each peripheral pixel seems to be associated with a specific column within the central structure based on color. A peripheral pixel of color `C` at `(r, c)` connects to the column `c_target` in the row 0 structure that also contains color `C`.
4.  **Draw Horizontal Lines:** For each peripheral pixel at `(r, c)` with color `C` and its target column `c_target`:
    *   If the pixel is to the left (`c < c_target`), draw a horizontal line of color `C` from `(r, c+1)` to `(r, c_target - 1)`.
    *   If the pixel is to the right (`c > c_target`), draw a horizontal line of color `C` from `(r, c_target + 1)` to `(r, c - 1)`.
5.  **Draw Vertical Lines:** For each column `c_i` within the central structure (row 0) containing color `C_i`:
    *   Find all peripheral pixels whose color is `C_i`.
    *   If such peripheral pixels exist, find the one with the maximum row index, let it be `r_max`. Draw a vertical line of color `C_i` downwards from `(0, c_i)` to `(r_max, c_i)`.
    *   If *no* peripheral pixel has the color `C_i`, draw a vertical line of color `C_i` downwards from `(0, c_i)` to the last row of the grid (`(grid_height - 1, c_i)`).
6.  **Replicate Central Structure:**
    *   Find the minimum row index (`r_min`) among all peripheral pixels.
    *   Copy the entire central structure (the segment from row 0) vertically downwards into all rows from 1 up to (but not including) `r_min`.

**Facts YAML:**


```yaml
Task: Draw connecting lines based on color correspondence between peripheral pixels and a central structure.

Elements:
  - Type: Grid
    Properties: 2D array of integer colors (0-9).
  - Type: Object
    Name: Central Structure
    Description: A contiguous horizontal sequence of non-white pixels in the first row (row 0).
    Properties:
      - start_column: Integer
      - end_column: Integer
      - colors: List of colors corresponding to columns.
  - Type: Object
    Name: Peripheral Pixel
    Description: Any non-white pixel not part of the Central Structure.
    Properties:
      - row: Integer
      - column: Integer
      - color: Integer
      - target_column: Integer (column index in Central Structure with the same color)

Relationships:
  - Peripheral Pixels are linked to the Central Structure based on matching color.
  - The vertical extent of replication for the Central Structure depends on the minimum row of any Peripheral Pixel.
  - The vertical extent of lines drawn downwards from the Central Structure depends on the maximum row of corresponding Peripheral Pixels (or grid height if none exist).

Actions:
  - Identify: Locate Central Structure and Peripheral Pixels.
  - Associate: Determine the target_column for each Peripheral Pixel.
  - Draw Horizontal Line: Fill pixels horizontally between a Peripheral Pixel and its target column (excluding the target column itself).
  - Draw Vertical Line: Fill pixels vertically from a Central Structure column down to the row of its associated Peripheral Pixel (or grid bottom).
  - Replicate: Copy the Central Structure pattern vertically downwards to fill rows above the topmost Peripheral Pixel.
  - Combine: The output is the union of original pixels and drawn lines/replications.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the "Central Structure": Find the contiguous sequence of non-white pixels in row 0. Record its starting column index (`c_start`), ending column index (`c_end`), and the color at each column `c` within this range (`structure_colors[c]`).
3.  Identify all "Peripheral Pixels": Find all non-white pixels located in rows greater than 0. For each peripheral pixel, record its row (`p_row`), column (`p_col`), and color (`p_color`).
4.  Determine the "Target Column" for each Peripheral Pixel: For each peripheral pixel `P` with color `p_color`, find the column index `c_target` within the Central Structure range (`c_start` to `c_end`) such that `structure_colors[c_target]` equals `p_color`. Store this association.
5.  Find the minimum peripheral row (`min_p_row`): Determine the smallest `p_row` among all identified Peripheral Pixels. If there are no peripheral pixels, set `min_p_row` to the grid height.
6.  Replicate the Central Structure: For each row `r` from 1 up to `min_p_row - 1`, and for each column `c` from `c_start` to `c_end`, set the output grid cell `(r, c)` to `structure_colors[c]`.
7.  Draw Horizontal and Vertical Lines:
    a.  Create a map to store the maximum row reached for each column in the central structure (`max_row_for_column`). Initialize all values to -1.
    b.  For each Peripheral Pixel `P` at `(p_row, p_col)` with color `p_color` and its determined `c_target`:
        i.  Draw the horizontal segment:
            - If `p_col < c_target`, fill cells `(p_row, c)` with `p_color` for `c` from `p_col + 1` to `c_target - 1`.
            - If `p_col > c_target`, fill cells `(p_row, c)` with `p_color` for `c` from `c_target + 1` to `p_col - 1`.
        ii. Update the maximum row for the target column: Set `max_row_for_column[c_target]` = max(`max_row_for_column[c_target]`, `p_row`).
    c.  Draw the vertical segments:
        i.  For each column `c` from `c_start` to `c_end`:
            - Let `structure_color = structure_colors[c]`.
            - Determine the end row `r_end`: If `max_row_for_column[c]` is greater than -1, `r_end = max_row_for_column[c]`. Otherwise (if no peripheral pixel targeted this column), `r_end = grid_height - 1`.
            - Fill cells `(r, c)` with `structure_color` for `r` from 1 up to `r_end`. Ensure the original structure pixel at (0, c) is also present (it should be from step 1).
8.  The final state of the output grid is the result.
