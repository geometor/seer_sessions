{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all separate, connected groups (objects) of the single non-white color \nin the input grid using orthogonal adjacency (up, down, left, right). \nFilters these objects, keeping only those with a size (pixel count) greater than 1. \nFor each remaining object, further removes any pixel that has exactly one neighbor \nbelonging to the same object, unless the object consists of only two pixels \n(in which case both pixels are kept). \nCreates an output grid containing only the filtered and pruned pixels, \npreserving their original color and position against a white background.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a list of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and (r, c) not in visited:\n                current_object_coords = []\n                queue = deque([(r, c)])\n                visited.add((r, c))\n\n                # Start BFS from this pixel\n                while queue:\n                    curr_r, curr_c = queue.popleft()\n                    current_object_coords.append((curr_r, curr_c))\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                queue.append((nr, nc))\n                \n                # Add the found object (list of coordinates) to our list of objects\n                if current_object_coords:\n                    objects.append(current_object_coords)\n                    \n    return objects\n\ndef count_internal_neighbors(coord, object_coords_set):\n    \"\"\"\n    Counts how many orthogonal neighbors of a coordinate belong to the same object set.\n\n    Args:\n        coord (tuple): The (row, col) of the pixel to check.\n        object_coords_set (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        int: The number of neighbors within the object.\n    \"\"\"\n    r, c = coord\n    count = 0\n    # Check neighbors (up, down, left, right)\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        # Check if neighbor is part of the same object set\n        if (nr, nc) in object_coords_set:\n            count += 1\n    return count\n\ndef transform(input_grid):\n    \"\"\"\n    Filters and prunes objects in the input grid based on size and connectivity.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the output grid.\n    \"\"\"\n    height, width = input_grid.shape\n    # Initialize output_grid with background color (white=0)\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the non-background color used for objects\n    object_color = None\n    unique_colors = np.unique(input_grid)\n    for color in unique_colors:\n        if color != 0: # Assuming 0 is always the background\n            object_color = color\n            break\n            \n    # If no object color found (grid is all white), return the empty grid\n    if object_color is None:\n        return output_grid\n\n    # Find all connected objects of that color\n    all_objects = find_objects(input_grid, object_color)\n\n    # If no objects are found, return the empty grid\n    if not all_objects:\n        return output_grid\n        \n    # --- Step 1: Filter objects by size > 1 ---\n    large_objects = [obj for obj in all_objects if len(obj) > 1]\n\n    # --- Step 2: Prune pixels with only one internal neighbor ---\n    final_pixels_to_draw = set()\n    for obj_coords in large_objects:\n        obj_coords_set = set(obj_coords) # Use set for efficient lookups\n        obj_size = len(obj_coords_set)\n        \n        # Handle the special case for 2-pixel objects directly\n        if obj_size == 2:\n            final_pixels_to_draw.update(obj_coords_set)\n            continue # Move to the next object\n\n        # For objects larger than 2 pixels, check each pixel's neighbors\n        current_object_pixels_to_keep = set()\n        for r, c in obj_coords:\n            # Count neighbors that are also part of the current object\n            internal_neighbors = count_internal_neighbors((r, c), obj_coords_set)\n            \n            # Keep the pixel if it has more than one neighbor within the object\n            if internal_neighbors > 1:\n                 current_object_pixels_to_keep.add((r, c))\n\n        # Add the processed pixels for this object to the final set\n        final_pixels_to_draw.update(current_object_pixels_to_keep)\n\n    # --- Step 3: Draw the final pixels onto the output grid ---\n    for r, c in final_pixels_to_draw:\n        # Ensure coordinates are within bounds (should be, but good practice)\n        if 0 <= r < height and 0 <= c < width:\n            output_grid[r, c] = object_color\n                \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5300,
    "candidates_token_count": 1480,
    "total_token_count": 6780,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 176.817899,
  "retries": null
}