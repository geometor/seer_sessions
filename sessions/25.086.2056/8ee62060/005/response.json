{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a repeating pattern, typically originating from the top-leftmost \nnon-background pixel, assuming the pattern is contained within a small, fixed \nbounding box (e.g., 2x2) relative to an anchor point. Finds all occurrences \n(instances) of this pattern in the input grid. Sorts the anchor points of \nthese instances based on their position (row, then column). Creates an output \ngrid of the same size, initially filled with the background color (0). Places \nthe identified pattern onto the output grid at the original anchor locations, \nbut effectively reverses the sequence of the patterns along their original path.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_first_pattern_anchor(grid):\n    \"\"\"\n    Finds the coordinates (row, col) of the top-leftmost non-background pixel.\n    Returns None if the grid is all background.\n    \"\"\"\n    non_background_pixels = np.argwhere(grid != 0)\n    if non_background_pixels.size == 0:\n        return None  # No non-background pixels found\n    # Sort by row, then column, and take the first one\n    # np.argwhere returns [row, col], sorted finds the minimum row, then minimum col for that row\n    min_row_indices = non_background_pixels[non_background_pixels[:, 0] == non_background_pixels[:, 0].min()]\n    first_anchor_coords = min_row_indices[min_row_indices[:, 1].argmin()]\n    return tuple(first_anchor_coords)\n\ndef determine_pattern_structure(grid, anchor_r, anchor_c, pattern_size=(2, 2)):\n    \"\"\"\n    Determines the pattern structure based on non-background pixels within a \n    fixed-size box relative to the anchor. Also determines the actual minimum\n    bounding box height and width containing the non-background pixels.\n    Returns a tuple: (pattern_dict, pattern_h, pattern_w)\n    - pattern_dict: {(dr, dc): color} for non-background pixels.\n    - pattern_h: Minimum height of the bounding box containing the pattern.\n    - pattern_w: Minimum width of the bounding box containing the pattern.\n    \"\"\"\n    pattern = {}\n    height, width = grid.shape\n    box_h, box_w = pattern_size # The initial search box size (e.g., 2x2)\n    \n    min_r, max_r = -1, -1\n    min_c, max_c = -1, -1\n    \n    for dr in range(box_h):\n        for dc in range(box_w):\n            r, c = anchor_r + dr, anchor_c + dc\n            # Check bounds relative to the input grid\n            if 0 <= r < height and 0 <= c < width:\n                color = grid[r, c]\n                if color != 0: # Only include non-background pixels\n                    pattern[(dr, dc)] = color\n                    # Track actual bounds based on non-zero pixels found\n                    if min_r == -1: # First non-zero pixel\n                        min_r, max_r = dr, dr\n                        min_c, max_c = dc, dc\n                    else:\n                        min_r = min(min_r, dr)\n                        max_r = max(max_r, dr)\n                        min_c = min(min_c, dc)\n                        max_c = max(max_c, dc)\n\n    # Calculate actual height and width based on content\n    # Important: Ensure these are relative to (0,0) of the pattern box, not min_r/min_c\n    if not pattern:\n        pattern_h = 0\n        pattern_w = 0\n    else:\n        # The height/width needs to accommodate the max offset + 1\n        pattern_h = max_r + 1\n        pattern_w = max_c + 1\n        \n    # Re-evaluate using fixed pattern_size for consistency if needed?\n    # The examples seem to rely on a fixed 2x2 structure including background 0s\n    # Let's stick to the provided pattern_size for the bounding box check later.\n    pattern_h_fixed, pattern_w_fixed = pattern_size\n\n    # Return the pattern dict, and the *fixed* size for matching purposes\n    return pattern, pattern_h_fixed, pattern_w_fixed\n\n\ndef find_all_pattern_instances(grid, pattern, pattern_h, pattern_w):\n    \"\"\"\n    Finds all locations (anchor points r, c) in the grid where the pattern matches.\n    A match requires:\n    1. All colored pixels in the pattern dict match the grid at (r+dr, c+dc).\n    2. All positions (dr, dc) within the pattern's bounding box (pattern_h x pattern_w)\n       that are NOT in the pattern dict must be background (0) in the grid at (r+dr, c+dc).\n    Returns a list of (r, c) tuples.\n    \"\"\"\n    if not pattern or pattern_h == 0 or pattern_w == 0:\n        return [] # Cannot find instances of an empty pattern\n\n    height, width = grid.shape\n    anchors = []\n    \n    # Iterate through possible top-left anchor points (r, c)\n    # The loops bounds ensure that the pattern box (pattern_h x pattern_w) fits within the grid\n    for r in range(height - pattern_h + 1):\n        for c in range(width - pattern_w + 1):\n            match = True\n            \n            # 1. Check if pattern's colored pixels match the grid\n            for (dr, dc), expected_color in pattern.items():\n                # Check if this relative coordinate is within the bounding box being checked\n                # This should always be true if pattern was derived correctly, but safer to check\n                if 0 <= dr < pattern_h and 0 <= dc < pattern_w:\n                    current_color = grid[r + dr, c + dc]\n                    if current_color != expected_color:\n                        match = False\n                        break\n                else:\n                    # This case implies an issue with pattern definition or pattern_h/w\n                    match = False\n                    break \n            if not match:\n                continue\n\n            # 2. Check if non-pattern pixels within the bounding box are background\n            for dr_check in range(pattern_h):\n                 for dc_check in range(pattern_w):\n                     # If this relative position is NOT a colored part of the pattern\n                     if (dr_check, dc_check) not in pattern:\n                          # Check if the corresponding grid cell is background (0)\n                          if grid[r + dr_check, c + dc_check] != 0:\n                              match = False\n                              break\n                 if not match:\n                     break # Break outer check loop if mismatch found\n\n            # If both checks passed, it's a valid instance\n            if match:\n                anchors.append((r, c))\n                \n    return anchors\n\ndef draw_pattern(output_grid, anchor, pattern):\n    \"\"\"\n    Draws the pattern (colored pixels) onto the output grid at the specified anchor.\n    Assumes output_grid is large enough. Modifies output_grid in place.\n    \"\"\"\n    height, width = output_grid.shape\n    anchor_r, anchor_c = anchor\n    for (dr, dc), color in pattern.items():\n        target_r, target_c = anchor_r + dr, anchor_c + dc\n        # Check bounds before drawing\n        if 0 <= target_r < height and 0 <= target_c < width:\n            output_grid[target_r, target_c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    # Convert input list of lists to a NumPy array\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 1. Find the anchor of the first pattern instance (top-leftmost non-zero)\n    first_anchor = find_first_pattern_anchor(input_np)\n    \n    # If the grid is empty (all background), return the empty output grid\n    if first_anchor is None:\n        return output_grid.tolist() \n\n    # 2. Determine the structure of the pattern using a fixed 2x2 bounding box\n    #    This also returns the box dimensions (h=2, w=2) used for matching.\n    pattern, pattern_h, pattern_w = determine_pattern_structure(\n        input_np, first_anchor[0], first_anchor[1], pattern_size=(2, 2)\n    )\n\n    # If pattern determination failed unexpectedly (e.g., first anchor invalid)\n    if not pattern:\n         # This case is unlikely if first_anchor was found, but handle defensively\n         return output_grid.tolist()\n\n    # 3. Find all instances (anchors) of this pattern in the input grid\n    input_anchors = find_all_pattern_instances(input_np, pattern, pattern_h, pattern_w)\n    \n    # If no instances were found (not even the first one, which would be odd), return empty grid\n    if not input_anchors:\n         return output_grid.tolist()\n\n    # 4. Sort the identified input anchor points by position (row, then column)\n    #    This establishes the original sequence along the diagonal.\n    sorted_input_anchors = sorted(input_anchors, key=lambda p: (p[0], p[1]))\n\n    # 5. Determine the target anchor positions by reversing the sorted list\n    #    The pattern originally at sorted_input_anchors[i] will move to target_anchors[i].\n    target_anchors = sorted_input_anchors[::-1] # Reversed list\n\n    # 6. Draw the pattern at each target anchor position in the output grid\n    #    Iterate through the target positions and draw the single defined pattern at each.\n    for anchor in target_anchors:\n        draw_pattern(output_grid, anchor, pattern)\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13248,
    "candidates_token_count": 2400,
    "total_token_count": 15648,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.954177,
  "retries": null
}