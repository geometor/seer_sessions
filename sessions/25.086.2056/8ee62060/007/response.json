{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReverses the sequence of repeating 2x2 patterns found along a path in the \ngrid.\n\nThe transformation involves the following steps:\n1. Identify the top-leftmost non-background pixel and define a 2x2 pattern \n   block starting from this pixel.\n2. Find all occurrences (instances) of this exact 2x2 pattern in the input \n   grid.\n3. Sort the locations (anchor points) of these instances by row, then column, \n   to determine their original sequence.\n4. Create a new grid and place the pattern instances onto it, but in the \n   reverse order of their original sequence. The first pattern instance moves \n   to the last instance's location, the second to the second-to-last, and so on.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_first_pattern_anchor(grid):\n    \"\"\"\n    Finds the coordinates (row, col) of the top-leftmost non-background pixel.\n    Returns None if the grid is all background.\n    \"\"\"\n    non_background_pixels = np.argwhere(grid != 0)\n    if non_background_pixels.size == 0:\n        return None  # No non-background pixels found\n    # Sort by row, then column, and take the first one\n    min_row_indices = non_background_pixels[non_background_pixels[:, 0] == non_background_pixels[:, 0].min()]\n    first_anchor_coords = min_row_indices[min_row_indices[:, 1].argmin()]\n    return tuple(first_anchor_coords)\n\ndef determine_pattern_structure(grid, anchor_r, anchor_c, pattern_size=(2, 2)):\n    \"\"\"\n    Determines the pattern structure based on pixels within a fixed-size box \n    relative to the anchor. Captures all pixels (including background 0s) \n    within this box.\n    Returns a tuple: (pattern_dict, pattern_h, pattern_w)\n    - pattern_dict: {(dr, dc): color} for all pixels in the box.\n    - pattern_h: Height of the box (fixed).\n    - pattern_w: Width of the box (fixed).\n    \"\"\"\n    pattern = {}\n    height, width = grid.shape\n    box_h, box_w = pattern_size \n    \n    for dr in range(box_h):\n        for dc in range(box_w):\n            r, c = anchor_r + dr, anchor_c + dc\n            # Check bounds relative to the input grid\n            if 0 <= r < height and 0 <= c < width:\n                color = grid[r, c]\n                pattern[(dr, dc)] = color\n            else:\n                # If the anchor is near the edge and the box goes out of bounds,\n                # we might store a special value or skip. For this task, \n                # valid patterns seem fully contained. Let's assume the box fits.\n                # Store a value that won't match grid values, e.g. -1, if needed.\n                # Or, rely on find_all_pattern_instances to handle boundaries.\n                # Let's stick to only including in-bounds pixels for pattern definition.\n                pass \n\n    # Return the pattern dict containing all cells in the 2x2 box, \n    # and the fixed size used for matching.\n    return pattern, box_h, box_w\n\n\ndef find_all_pattern_instances(grid, pattern, pattern_h, pattern_w):\n    \"\"\"\n    Finds all locations (anchor points r, c) in the grid where the pattern \n    matches exactly over the pattern_h x pattern_w area.\n    Returns a list of (r, c) tuples.\n    \"\"\"\n    if not pattern or pattern_h == 0 or pattern_w == 0:\n        return [] # Cannot find instances of an empty pattern\n\n    height, width = grid.shape\n    anchors = []\n    \n    # Iterate through possible top-left anchor points (r, c)\n    for r in range(height - pattern_h + 1):\n        for c in range(width - pattern_w + 1):\n            match = True\n            # Check if the grid matches the pattern dict over the h x w box\n            for dr in range(pattern_h):\n                for dc in range(pattern_w):\n                    relative_pos = (dr, dc)\n                    expected_color = pattern.get(relative_pos) \n                    \n                    # This case handles if pattern definition omitted out-of-bounds cells\n                    if expected_color is None: \n                        # If pattern definition didn't include this cell (e.g., edge case),\n                        # it cannot be a match unless find_all logic changes.\n                        # Assuming pattern dict fully represents the 2x2 box.\n                        pass # This should ideally not happen with current determine_pattern\n\n                    current_color = grid[r + dr, c + dc]\n                    \n                    # Compare grid color with the expected color from the pattern\n                    if current_color != expected_color:\n                        match = False\n                        break\n                if not match:\n                    break # Break inner loops if mismatch found\n            \n            # If all cells in the box matched the pattern\n            if match:\n                anchors.append((r, c))\n                \n    return anchors\n\ndef draw_pattern(output_grid, anchor, pattern):\n    \"\"\"\n    Draws the pattern (all pixels from the pattern dict) onto the output grid \n    at the specified anchor. Assumes output_grid is large enough. \n    Modifies output_grid in place.\n    \"\"\"\n    height, width = output_grid.shape\n    anchor_r, anchor_c = anchor\n    for (dr, dc), color in pattern.items():\n        target_r, target_c = anchor_r + dr, anchor_c + dc\n        # Check bounds before drawing\n        if 0 <= target_r < height and 0 <= target_c < width:\n            output_grid[target_r, target_c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    # Convert input list of lists to a NumPy array\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # 1. Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 2. Find the anchor of the first pattern instance (top-leftmost non-zero)\n    first_anchor = find_first_pattern_anchor(input_np)\n    \n    # If the grid is empty (all background), return the empty output grid\n    if first_anchor is None:\n        return output_grid.tolist() \n\n    # 3. Determine the structure of the 2x2 pattern block\n    pattern, pattern_h, pattern_w = determine_pattern_structure(\n        input_np, first_anchor[0], first_anchor[1], pattern_size=(2, 2)\n    )\n\n    # If pattern determination failed (e.g., anchor was somehow invalid)\n    if not pattern:\n         return output_grid.tolist()\n\n    # 4. Find all instances (anchors) of this pattern in the input grid\n    input_anchors = find_all_pattern_instances(input_np, pattern, pattern_h, pattern_w)\n    \n    # If no instances were found, return empty grid\n    if not input_anchors:\n         return output_grid.tolist()\n\n    # 5. Sort the identified input anchor points by position (row, then column)\n    sorted_input_anchors = sorted(input_anchors, key=lambda p: (p[0], p[1]))\n\n    # 6. Determine the target anchor positions by reversing the sorted list\n    # The pattern originally at sorted_input_anchors[i] will move to the \n    # position originally occupied by the pattern at sorted_input_anchors[N-1-i].\n    num_anchors = len(sorted_input_anchors)\n    target_anchors_in_reversed_order = sorted_input_anchors[::-1] \n\n    # 7. Draw the pattern at each corresponding target anchor position\n    # Iterate through the original sequence order (implicitly via index i)\n    # and map each pattern to its new reversed position.\n    for i in range(num_anchors):\n        # Get the anchor point where the pattern should be drawn in the output\n        target_anchor = target_anchors_in_reversed_order[i] \n        # Draw the single defined pattern at this target location\n        draw_pattern(output_grid, target_anchor, pattern)\n\n    # 8. Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10106,
    "candidates_token_count": 2036,
    "total_token_count": 12142,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.693182,
  "retries": null
}