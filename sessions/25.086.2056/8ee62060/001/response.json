{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify repeating non-background objects arranged along a diagonal line in the\ninput grid. Determine the sequence of these objects along the diagonal. Create\nan output grid of the same size, initially filled with the background color (0).\nPlace the objects onto the output grid such that their order along the diagonal\nis reversed compared to the input. The shape and colors of the objects remain\nunchanged.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-background pixels (objects).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]: A list where each\n        element represents an object. Each element is a tuple containing:\n        - The anchor point (top-left corner, min_row, min_col) of the object's bounding box.\n        - A list of pixel coordinates [(row, col), ...] belonging to the object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-background and not visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # If neighbor is non-background and not visited\n                                if grid[nr, nc] != 0 and not visited[nr, nc]:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                \n                # Store the object with its anchor (top-left) and pixels\n                anchor = (min_r, min_c)\n                objects.append((anchor, component_pixels))\n                \n    return objects\n\ndef get_object_shape(anchor, pixels, grid):\n    \"\"\"\n    Calculates the shape of an object relative to its anchor point.\n\n    Args:\n        anchor (Tuple[int, int]): The (row, col) of the object's anchor (top-left).\n        pixels (List[Tuple[int, int]]): List of (row, col) coordinates of the object's pixels.\n        grid (np.ndarray): The input grid to get pixel colors.\n\n    Returns:\n        List[Tuple[int, int, int]]: A list of (relative_row, relative_col, color)\n        tuples defining the object's shape.\n    \"\"\"\n    anchor_r, anchor_c = anchor\n    shape = []\n    for r, c in pixels:\n        rel_r = r - anchor_r\n        rel_c = c - anchor_c\n        color = grid[r, c]\n        shape.append((rel_r, rel_c, color))\n    # Sort for consistency, although not strictly necessary if comparison handles sets\n    shape.sort() \n    return shape\n\ndef draw_object(output_grid, anchor, shape):\n    \"\"\"\n    Draws the object shape onto the output grid at the specified anchor position.\n\n    Args:\n        output_grid (np.ndarray): The grid to draw on (modified in place).\n        anchor (Tuple[int, int]): The (row, col) where the object's anchor should be placed.\n        shape (List[Tuple[int, int, int]]): The object shape defined by\n                                             (rel_r, rel_c, color).\n    \"\"\"\n    height, width = output_grid.shape\n    anchor_r, anchor_c = anchor\n    for rel_r, rel_c, color in shape:\n        target_r, target_c = anchor_r + rel_r, anchor_c + rel_c\n        # Check bounds before drawing\n        if 0 <= target_r < height and 0 <= target_c < width:\n            output_grid[target_r, target_c] = color\n        # else: Optional: handle cases where object might partially go off-grid if needed\n\ndef transform(input_grid):\n    \"\"\"\n    Reverses the order of repeating objects found along a diagonal path.\n\n    Args:\n        input_grid (np.ndarray): The input grid with objects.\n\n    Returns:\n        np.ndarray: The output grid with object order reversed.\n    \"\"\"\n    # Find all non-background objects and their anchor points\n    objects_data = find_objects(np.array(input_grid))\n\n    # If no objects are found, return a grid filled with background color\n    if not objects_data:\n        return np.zeros_like(input_grid)\n\n    # Assume all objects have the same shape. Get the shape from the first object found.\n    first_object_anchor, first_object_pixels = objects_data[0]\n    unique_object_shape = get_object_shape(first_object_anchor, first_object_pixels, np.array(input_grid))\n    \n    # Extract just the anchor points\n    anchors = [data[0] for data in objects_data]\n\n    # Sort anchors based on their position along the diagonal\n    # Sorting by (row, col) naturally orders points along diagonals progressing downwards\n    sorted_anchors = sorted(anchors, key=lambda p: (p[0], p[1]))\n\n    # The target positions for the output are the original positions but in reversed order\n    target_anchors = sorted_anchors[::-1] # Creates a reversed copy\n\n    # Initialize the output grid with the background color\n    output_grid = np.zeros_like(input_grid)\n\n    # Draw the unique object shape at each target anchor position\n    # The number of target anchors will match the number of original objects\n    for anchor_pos in target_anchors:\n        draw_object(output_grid, anchor_pos, unique_object_shape)\n\n    return output_grid.tolist() # Convert back to list of lists if needed by the environment\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3684,
    "candidates_token_count": 1581,
    "total_token_count": 5265,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.468793,
  "retries": null
}