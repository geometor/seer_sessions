{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Get Input Dimensions: Determine the height (`H`) and width (`W`) of the input grid.\n2.  Identify Input Frame Color: Read the color value at `input_grid[1, 0]`. Store this as `Input Frame Color`.\n3.  Define Content Area: Specify the boundaries for the content area: rows 2 to `H-2` (inclusive) and columns 1 to `W-2` (inclusive).\n4.  Count Content Colors: Iterate through each pixel within the input grid's `Content Area`. Count the occurrences of each color, *excluding* white (0) and the `Input Frame Color`.\n5.  Determine Output Fill Color: Find the color with the highest frequency count from Step 4. Store this as `Output Fill Color`.\n6.  Initialize Output Grid: Create a new grid of the same dimensions (`H` x `W`) as the input grid, filled entirely with white (0).\n7.  Copy Top Row: Copy the first row (index 0) from the input grid to the output grid.\n8.  Construct Output Frame:\n    *   Fill the entire second row (index 1) of the output grid with the `Output Fill Color`.\n    *   Fill the first column (index 0) from row 1 down (rows 1 to `H-1`) with the `Output Fill Color`.\n    *   Fill the last column (index `W-1`) from row 1 down (rows 1 to `H-1`) with the `Output Fill Color`.\n    *   Fill the last row (index `H-1`) from column 1 to `W-2` (inclusive) with the `Output Fill Color`.\n9.  Identify Seed Points: Find all coordinates `(r, c)` within the input grid's `Content Area` (rows 2 to `H-2`, cols 1 to `W-2`) where the pixel color equals the `Output Fill Color`. Store these as `Seed Points`.\n10. Place Seeds in Output: For each `(r, c)` in `Seed Points`, set the corresponding pixel `output_grid[r, c]` to the `Output Fill Color`. (The rest of the output `Content Area` remains white from Step 6).\n11. Perform Constrained Flood Fill:\n    *   Initialize a queue with all `Seed Points`.\n    *   Initialize a set `visited` with all `Seed Points`.\n    *   While the queue is not empty:\n        *   Dequeue a coordinate `(r, c)`.\n        *   For each 4-way adjacent neighbor `(nr, nc)` of `(r, c)`:\n            *   Check if `(nr, nc)` is within the `Content Area` boundaries (rows 2 to `H-2`, cols 1 to `W-2`).\n            *   Check if `(nr, nc)` has not been visited.\n            *   Check if the target pixel in the output grid `output_grid[nr, nc]` is currently white (0).\n            *   Check if the corresponding pixel in the *input* grid `input_grid[nr, nc]` is also white (0).\n            *   If all conditions are true:\n                *   Set `output_grid[nr, nc]` to the `Output Fill Color`.\n                *   Mark `(nr, nc)` as visited.\n                *   Enqueue `(nr, nc)`.\n12. Return Output Grid: The final `output_grid` is the result.\n\"\"\"\n\ndef _find_most_frequent_inner_color(input_grid, frame_color, inner_bounds):\n    \"\"\"\n    Counts colors in the defined inner area, excluding white (0)\n    and the frame_color, and returns the most frequent one.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n        frame_color (int): The color of the input frame (row 1).\n        inner_bounds (dict): Dictionary with 'row_start', 'row_end', 'col_start', 'col_end'.\n\n    Returns:\n        int: The most frequent color, or 0 if none found.\n    \"\"\"\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n\n    # Check if the inner area is valid\n    if r_start > r_end or c_start > c_end:\n        return 0 # No valid inner area\n\n    inner_area = input_grid[r_start : r_end + 1, c_start : c_end + 1]\n\n    color_counts = Counter()\n    for r in range(inner_area.shape[0]):\n        for c in range(inner_area.shape[1]):\n            color = inner_area[r, c]\n            if color != 0 and color != frame_color:\n                color_counts[color] += 1\n\n    if not color_counts:\n        return 0 # Return 0 if no applicable colors found\n\n    # Find the color with the maximum count.\n    # If there's a tie, max() returns the first one encountered with the max value.\n    most_frequent_color = max(color_counts, key=color_counts.get)\n    return most_frequent_color\n\ndef _flood_fill(output_grid, input_grid, start_coords, fill_color, inner_bounds):\n    \"\"\"\n    Performs a 4-way flood fill on the output_grid's inner area.\n    Starts from start_coords, fills only cells that are white (0) in output_grid\n    AND were also white (0) in input_grid.\n    Modifies the output_grid in place.\n\n    Args:\n        output_grid (np.ndarray): The grid to be filled (modified in place).\n        input_grid (np.ndarray): The original input grid for checking white space.\n        start_coords (list): A list of (row, col) tuples to start the fill from.\n        fill_color (int): The color to fill with.\n        inner_bounds (dict): Dictionary with 'row_start', 'row_end', 'col_start', 'col_end'.\n    \"\"\"\n    if not start_coords:\n        return # No seeds to start from\n\n    q = deque(start_coords)\n    visited = set(start_coords) # Keep track of initial seeds and filled cells\n\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbours (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries (inner content area)\n            if r_start <= nr <= r_end and c_start <= nc <= c_end:\n                # Check if the neighbor hasn't been visited\n                if (nr, nc) not in visited:\n                    # Check if the neighbor is white (0) in the output grid\n                    # AND the corresponding cell was white (0) in the input grid\n                    if output_grid[nr, nc] == 0 and input_grid[nr, nc] == 0:\n                        output_grid[nr, nc] = fill_color\n                        visited.add((nr, nc))\n                        q.append((nr, nc))\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule derived from the examples.\n    \"\"\"\n    input_np = np.array(input_grid_list, dtype=int)\n    H, W = input_np.shape\n\n    # 1. Get Input Dimensions (already have H, W)\n\n    # 2. Identify Input Frame Color (from row index 1)\n    # Handle potential edge case of 1-row grid (though constraints say >= 1x1)\n    input_frame_color = 0\n    if H > 1:\n        input_frame_color = input_np[1, 0]\n\n    # 3. Define Content Area boundaries (inclusive indices)\n    inner_bounds = {\n        'row_start': 2, 'row_end': H - 2,\n        'col_start': 1, 'col_end': W - 2\n    }\n\n    # 4. & 5. Analyze inner area and determine Output Fill Color\n    output_fill_color = _find_most_frequent_inner_color(input_np, input_frame_color, inner_bounds)\n\n    # 6. Initialize Output Grid with white (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 7. Copy the first row\n    if H > 0:\n        output_grid[0, :] = input_np[0, :]\n\n    # Check if dimensions allow for a frame and content area\n    if H < 3 or W < 3:\n        # If grid is too small for the defined frame/content structure,\n        # the behavior is undefined by examples. Returning the partially\n        # constructed grid (e.g., only top row copied) or the zero grid might be options.\n        # Let's return the grid with just the top row copied for now.\n        # A more robust solution might need specific rules for small grids.\n         if H > 0: output_grid[0, :] = input_np[0, :]\n         # Maybe fill the rest with the calculated fill color? Or leave as 0?\n         # Filling with output_fill_color seems plausible if frame concept collapses.\n         if H > 1: output_grid[1:, :] = output_fill_color\n         return output_grid.tolist()\n\n\n    # 8. Construct Output Frame\n    # Fill row 1\n    output_grid[1, :] = output_fill_color\n    # Fill col 0 (from row 1 down)\n    output_grid[1:H, 0] = output_fill_color\n    # Fill col W-1 (from row 1 down)\n    output_grid[1:H, W - 1] = output_fill_color\n    # Fill row H-1 (between cols 1 and W-2)\n    output_grid[H - 1, 1 : W - 1] = output_fill_color\n\n    # 9. Identify Seed Points in the input's inner area\n    seed_coords = []\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n    for r in range(r_start, r_end + 1):\n        for c in range(c_start, c_end + 1):\n            if input_np[r, c] == output_fill_color:\n                seed_coords.append((r, c))\n\n    # 10. Place Seeds in the output grid (within the inner area)\n    # Note: Output grid inner area is currently 0 (white) except for frame parts\n    for r, c in seed_coords:\n         # Double check bounds just in case, though seed_coords generation should be correct\n        if r_start <= r <= r_end and c_start <= c <= c_end:\n            output_grid[r, c] = output_fill_color\n\n    # 11. Perform constrained flood fill on the output grid's inner area\n    _flood_fill(output_grid, input_np, seed_coords, output_fill_color, inner_bounds)\n\n    # 12. Return the completed output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9735,
    "candidates_token_count": 2760,
    "total_token_count": 12495,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.42893,
  "retries": null
}