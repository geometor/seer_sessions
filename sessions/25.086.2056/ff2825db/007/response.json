{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Get Input Dimensions: Determine the height (`H`) and width (`W`) of the input grid.\n2.  Identify Input Frame Color: Read the color value at `input_grid[1, 0]`. Store this as `Input Frame Color`. Handle cases where H < 2.\n3.  Define Content Area: Specify the boundaries for the content area: rows 2 to `H-2` (inclusive) and columns 1 to `W-2` (inclusive). Handle cases where H < 3 or W < 3.\n4.  Count Content Colors: Iterate through each pixel within the input grid's `Content Area`. Count the occurrences of each color, *excluding* white (0) and the `Input Frame Color`.\n5.  Determine Output Fill Color: Find the color with the highest frequency count from Step 4. If no applicable colors are found, default to white (0). Store this as `Output Fill Color`.\n6.  Initialize Output Grid: Create a new grid of the same dimensions (`H` x `W`) as the input grid, filled entirely with white (0).\n7.  Copy Top Row: If `H > 0`, copy the first row (index 0) from the input grid to the output grid.\n8.  Construct Output Frame: If `H >= 2` and `W >= 2`:\n    *   Fill the entire second row (index 1) of the output grid with the `Output Fill Color`.\n    *   Fill the first column (index 0) from row 1 down (rows 1 to `H-1`) with the `Output Fill Color`.\n    *   Fill the last column (index `W-1`) from row 1 down (rows 1 to `H-1`) with the `Output Fill Color`.\n    *   Fill the last row (index `H-1`) from column 1 to `W-2` (inclusive) with the `Output Fill Color`.\n9.  Identify Seed Points: If `H >= 3` and `W >= 3`, find all coordinates `(r, c)` within the input grid's `Content Area` (rows 2 to `H-2`, cols 1 to `W-2`) where the pixel color `input_grid[r, c]` equals the `Output Fill Color`. Store these as `Seed Points`.\n10. Place Seeds in Output: For each `(r, c)` in `Seed Points`, set the corresponding pixel `output_grid[r, c]` to the `Output Fill Color`.\n11. Perform Constrained Flood Fill: If `H >= 3` and `W >= 3`:\n    *   Initialize a queue with all `Seed Points`.\n    *   Initialize a set `visited` with all `Seed Points`.\n    *   While the queue is not empty:\n        *   Dequeue a coordinate `(r, c)`.\n        *   For each 4-way adjacent neighbor `(nr, nc)` of `(r, c)`:\n            *   Check if `(nr, nc)` is within the `Content Area` boundaries (rows 2 to `H-2`, cols 1 to `W-2`).\n            *   Check if `(nr, nc)` has not been visited.\n            *   Check if the target pixel in the output grid `output_grid[nr, nc]` is currently white (0).\n            *   Check if the corresponding pixel in the *input* grid `input_grid[nr, nc]` is either white (0) OR the `Output Fill Color`.\n            *   If *all* conditions are true:\n                *   Set `output_grid[nr, nc]` to the `Output Fill Color`.\n                *   Mark `(nr, nc)` as visited.\n                *   Enqueue `(nr, nc)`.\n12. Handle Small Grids: If `H < 3` or `W < 3`, skip steps 9-11. The grid after step 8 is the result (or a simplified version if H/W are very small). A specific rule applied fills rows > 0 with the output_fill_color if H < 3 or W < 3.\n13. Return Output Grid: The final `output_grid` is the result.\n\"\"\"\n\n\ndef _find_most_frequent_inner_color(input_grid, frame_color, inner_bounds):\n    \"\"\"\n    Counts colors in the defined inner area, excluding white (0)\n    and the frame_color, and returns the most frequent one.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n        frame_color (int): The color of the input frame (row 1).\n        inner_bounds (dict): Dictionary with 'row_start', 'row_end', 'col_start', 'col_end'.\n\n    Returns:\n        int: The most frequent color, or 0 if none found or area invalid.\n    \"\"\"\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n\n    # Check if the inner area is valid dimension-wise\n    if r_start > r_end or c_start > c_end or r_start < 0 or c_start < 0 or r_end >= input_grid.shape[0] or c_end >= input_grid.shape[1]:\n        return 0 # No valid inner area\n\n    inner_area = input_grid[r_start : r_end + 1, c_start : c_end + 1]\n\n    color_counts = Counter()\n    for r in range(inner_area.shape[0]):\n        for c in range(inner_area.shape[1]):\n            color = inner_area[r, c]\n            if color != 0 and color != frame_color:\n                color_counts[color] += 1\n\n    if not color_counts:\n        return 0 # Return 0 if no applicable colors found\n\n    # Find the color with the maximum count.\n    # If there's a tie, max() returns the first one encountered with the max value based on dict iteration order.\n    # To make it deterministic (e.g., lowest color index wins tie), we could sort:\n    # max_count = max(color_counts.values())\n    # tied_colors = sorted([color for color, count in color_counts.items() if count == max_count])\n    # most_frequent_color = tied_colors[0]\n    # However, let's stick with the simpler max() for now.\n    most_frequent_color = max(color_counts, key=color_counts.get)\n    return most_frequent_color\n\ndef _flood_fill(output_grid, input_grid, start_coords, fill_color, inner_bounds):\n    \"\"\"\n    Performs a 4-way flood fill on the output_grid's inner area.\n    Starts from start_coords, fills only cells that are white (0) in output_grid\n    AND were either white (0) OR the fill_color in the input_grid.\n    Modifies the output_grid in place.\n\n    Args:\n        output_grid (np.ndarray): The grid to be filled (modified in place).\n        input_grid (np.ndarray): The original input grid for checking constraints.\n        start_coords (list): A list of (row, col) tuples to start the fill from.\n        fill_color (int): The color to fill with.\n        inner_bounds (dict): Dictionary with 'row_start', 'row_end', 'col_start', 'col_end'.\n    \"\"\"\n    if not start_coords:\n        return # No seeds to start from\n\n    q = deque(start_coords)\n    # Initialize visited with start_coords ONLY IF they are within bounds\n    # (they should be by construction, but safer to check)\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n    visited = set(coord for coord in start_coords if r_start <= coord[0] <= r_end and c_start <= coord[1] <= c_end)\n\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbours (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries (inner content area)\n            if r_start <= nr <= r_end and c_start <= nc <= c_end:\n                # Check if the neighbor hasn't been visited\n                if (nr, nc) not in visited:\n                    # Check if the neighbor is currently white (0) in the output grid\n                    # AND the corresponding cell in the INPUT grid was either white(0) or the fill_color\n                    if output_grid[nr, nc] == 0 and (input_grid[nr, nc] == 0 or input_grid[nr, nc] == fill_color):\n                        output_grid[nr, nc] = fill_color\n                        visited.add((nr, nc))\n                        q.append((nr, nc))\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation based on identifying a dominant color in the content area\n    and redrawing a frame and filling the content area constrained by other colors.\n    \"\"\"\n    input_np = np.array(input_grid_list, dtype=int)\n    H, W = input_np.shape\n\n    # 1. Get Input Dimensions (H, W)\n\n    # 2. Identify Input Frame Color (from row index 1)\n    input_frame_color = 0 # Default if grid is too small\n    if H > 1 and W > 0: # Need at least 2 rows and 1 col to access [1, 0]\n        input_frame_color = input_np[1, 0]\n\n    # 3. Define Content Area boundaries (inclusive indices)\n    # These are only relevant if H>=3 and W>=3\n    inner_bounds = {\n        'row_start': 2, 'row_end': H - 2,\n        'col_start': 1, 'col_end': W - 2\n    }\n\n    # 4. & 5. Analyze inner area and determine Output Fill Color\n    # Only calculate if the inner area is potentially valid (H>=3, W>=3)\n    output_fill_color = 0\n    if H >= 3 and W >= 3:\n         output_fill_color = _find_most_frequent_inner_color(input_np, input_frame_color, inner_bounds)\n    # If no dominant color found or grid too small, default is 0 (white).\n    # However, the frame construction below needs *a* color. If inner area invalid,\n    # perhaps output_fill_color should default to input_frame_color or another rule?\n    # Let's stick to the most frequent logic for now, it defaults to 0 if empty/invalid.\n    # The examples suggest a fill color is always found if H>=3, W>=3.\n\n    # 6. Initialize Output Grid with white (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 7. Copy the first row\n    if H > 0:\n        output_grid[0, :] = input_np[0, :]\n\n    # Handle small grids specifically first\n    if H < 3 or W < 3:\n        # Simplified behavior for small grids: Copy top row, fill rest with output_fill_color.\n        # Note: output_fill_color might be 0 if calculated above, which means fill with white.\n        # This seems reasonable as there's no proper content area to analyze.\n        if H > 1:\n            # Fill rows 1 to H-1. If output_fill_color is 0, this keeps them white.\n            output_grid[1:H, :] = output_fill_color\n        return output_grid.tolist()\n\n    # Proceed with standard frame/content logic for grids >= 3x3\n\n    # 8. Construct Output Frame using output_fill_color\n    if H >= 2 and W >= 2: # Redundant check given H>=3,W>=3 above, but safe\n        # Fill row 1\n        output_grid[1, :] = output_fill_color\n        # Fill col 0 (from row 1 down)\n        output_grid[1:H, 0] = output_fill_color\n        # Fill col W-1 (from row 1 down)\n        output_grid[1:H, W - 1] = output_fill_color\n        # Fill row H-1 (between cols 1 and W-2 inclusive)\n        if W > 1 : # Ensure we don't try to slice [1:0] if W=1 (though caught by W<3)\n             output_grid[H - 1, 1 : W - 1] = output_fill_color\n\n    # 9. Identify Seed Points in the input's inner area\n    seed_coords = []\n    r_start, r_end = inner_bounds['row_start'], inner_bounds['row_end']\n    c_start, c_end = inner_bounds['col_start'], inner_bounds['col_end']\n    # Iterate only if bounds are valid (which they are if H>=3, W>=3)\n    for r in range(r_start, r_end + 1):\n        for c in range(c_start, c_end + 1):\n            if input_np[r, c] == output_fill_color:\n                seed_coords.append((r, c))\n\n    # 10. Place Seeds in the output grid (within the inner area)\n    # Note: Output grid inner area is currently 0 (white)\n    for r, c in seed_coords:\n         # Check bounds again just in case, though seed_coords generation should be correct\n        if r_start <= r <= r_end and c_start <= c <= c_end:\n            output_grid[r, c] = output_fill_color\n\n    # 11. Perform constrained flood fill on the output grid's inner area\n    _flood_fill(output_grid, input_np, seed_coords, output_fill_color, inner_bounds)\n\n    # 13. Return the completed output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8042,
    "candidates_token_count": 3392,
    "total_token_count": 11434,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.433343,
  "retries": null
}