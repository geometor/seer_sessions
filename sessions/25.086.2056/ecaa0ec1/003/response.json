{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThis transformation rule operates on a grid containing a unique 3x3 pattern of blue (1) and azure (8) pixels, and potentially several scattered yellow (4) pixels, against a white (0) background.\n\n1.  **Identify the Pattern:** Locate the unique 3x3 subgrid composed entirely of blue (1) and azure (8) pixels. Note its top-left coordinates.\n2.  **Analyze Pattern Content:** Count the number of blue pixels (`count_blue`) and azure pixels (`count_azure`) within this 3x3 pattern.\n3.  **Rotate the Pattern:**\n    *   If `count_blue` is greater than `count_azure`, rotate the 3x3 pattern 90 degrees counter-clockwise in place.\n    *   Otherwise (if `count_azure` is greater than or equal to `count_blue`), rotate the 3x3 pattern 180 degrees in place.\n4.  **Consolidate Yellow Markers (if present):**\n    a. Find the coordinates (row, column) of all yellow (4) pixels in the original input grid.\n    b. If yellow pixels exist:\n        i. Calculate the median row (`median_row`) and median column (`median_col`) from the list of yellow pixel coordinates.\n        ii. Find the center coordinates (row `center_r`, column `center_c`) of the 3x3 blue/azure pattern (which is its top-left row + 1, top-left column + 1).\n        iii. Determine the final target coordinates (`target_r`, `target_c`) by applying a specific rounding rule to the median coordinates:\n            - For `median_row`: If it ends in .5, round it towards `center_r` (up if `center_r > median_row`, down if `center_r < median_row`). Otherwise, apply standard rounding (e.g., `int(round(x))`). Assign the result to `target_r`.\n            - For `median_col`: If it ends in .5, round it towards `center_c` (up if `center_c > median_col`, down if `center_c < median_col`). Otherwise, apply standard rounding (e.g., `int(round(x))`). Assign the result to `target_c`.\n        iv. Remove all original yellow pixels from the grid (change their color to white (0)).\n        v. Place a single new yellow pixel at the calculated (`target_r`, `target_c`).\n5.  **Output:** The resulting grid, containing the rotated pattern and the single consolidated yellow pixel (if any were present initially), is the final output.\n\"\"\"\n\n\ndef find_pattern_location(grid_np):\n    \"\"\"Finds the top-left corner of the 3x3 pattern of blue/azure pixels.\"\"\"\n    height, width = grid_np.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid_np[r:r+3, c:c+3]\n            # Check if the subgrid contains only 1s and 8s and is not uniform\n            if np.all(np.isin(subgrid, [1, 8])) and len(np.unique(subgrid)) > 1:\n                 return r, c\n    return None # Should not happen based on task description but good practice\n\n\ndef custom_round(median_val, center_val):\n    \"\"\"Applies the custom rounding rule for medians ending in .5.\"\"\"\n    if median_val % 1 == 0.5:\n        if center_val > median_val:\n            # Round towards center (up)\n            return math.ceil(median_val)\n        else: # center_val < median_val (center_val cannot equal median_val if median_val ends in .5)\n             # Round towards center (down)\n            return math.floor(median_val)\n    else:\n        # Standard rounding for non-.5 cases (round half up)\n        return int(round(median_val))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation: conditionally rotates a 3x3 pattern\n    and consolidates yellow pixels based on median and custom rounding.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n\n    # --- 1. Identify Pattern ---\n    pattern_loc = find_pattern_location(input_grid_np)\n    pattern_center_r, pattern_center_c = -1, -1 # Initialize pattern center\n\n    if pattern_loc:\n        pattern_r, pattern_c = pattern_loc\n        pattern_center_r = pattern_r + 1\n        pattern_center_c = pattern_c + 1\n\n        # Extract the 3x3 pattern\n        pattern = input_grid_np[pattern_r:pattern_r+3, pattern_c:pattern_c+3]\n\n        # --- 2. Analyze Pattern Content ---\n        count_blue = np.count_nonzero(pattern == 1)\n        count_azure = np.count_nonzero(pattern == 8)\n\n        # --- 3. Rotate the Pattern ---\n        if count_blue > count_azure:\n            # Rotate 90 degrees counter-clockwise\n            rotated_pattern = np.rot90(pattern, k=1)\n        else: # count_azure >= count_blue\n            # Rotate 180 degrees\n            rotated_pattern = np.rot90(pattern, k=2)\n\n        # Place the rotated pattern back into the output grid\n        output_grid[pattern_r:pattern_r+3, pattern_c:pattern_c+3] = rotated_pattern\n    else:\n        # Handle case where pattern is not found (though examples suggest it's always present)\n        print(\"Warning: 3x3 blue/azure pattern not found.\")\n        # Continue without rotation, but yellow consolidation might fail if it relies on center\n\n    # --- 4. Consolidate Yellow Markers (if present) ---\n    yellow_pixels = np.where(input_grid_np == 4)\n    yellow_rows, yellow_cols = yellow_pixels\n\n    if len(yellow_rows) > 0:\n        # a. Found yellow pixels coordinates\n\n        # b.i Calculate Median Coordinates\n        median_row = np.median(yellow_rows)\n        median_col = np.median(yellow_cols)\n\n        # Check if pattern was found before trying to use its center\n        if pattern_loc:\n            # b.ii Find Pattern Center (already done above)\n\n            # b.iii Apply Custom Rounding Rule\n            target_r = custom_round(median_row, pattern_center_r)\n            target_c = custom_round(median_col, pattern_center_c)\n\n            # Ensure target coordinates are within grid bounds (safety check)\n            target_r = max(0, min(height - 1, target_r))\n            target_c = max(0, min(width - 1, target_c))\n\n            # b.iv Remove all original yellow pixels\n            # Important: Do this *after* finding the pattern and calculating target location\n            # to avoid erasing the target if it overlaps an original yellow pixel.\n            output_grid[yellow_rows, yellow_cols] = 0\n\n            # b.v Place a single new yellow pixel at the target location\n            output_grid[target_r, target_c] = 4\n        else:\n            # Fallback if pattern wasn't found - cannot use custom rounding\n            # Use standard rounding and remove/place yellow pixels\n            target_r = int(round(median_row))\n            target_c = int(round(median_col))\n            target_r = max(0, min(height - 1, target_r))\n            target_c = max(0, min(width - 1, target_c))\n            output_grid[yellow_rows, yellow_cols] = 0\n            output_grid[target_r, target_c] = 4\n            print(\"Warning: Yellow pixels consolidated using standard rounding due to missing pattern.\")\n\n\n    # --- 5. Final Output ---\n    # Convert back to list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8410,
    "candidates_token_count": 1942,
    "total_token_count": 10352,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.222844,
  "retries": null
}