{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThis transformation rule operates on a grid containing a 3x3 pattern of blue (1) and azure (8) pixels, and several scattered yellow (4) pixels, against a white (0) background.\n\n1.  **Pattern Rotation:** Identify the unique 3x3 subgrid composed solely of blue (1) and azure (8) pixels. Rotate this 3x3 pattern 90 degrees clockwise in place.\n2.  **Yellow Pixel Consolidation:**\n    a. Find the coordinates of all yellow (4) pixels in the input grid.\n    b. Calculate the median row and median column index of these yellow pixels.\n    c. Determine the coordinates of the center pixel of the 3x3 blue/azure pattern.\n    d. Apply a specific rounding rule if the median row or column index ends in .5: Round the coordinate towards the corresponding coordinate (row or column) of the pattern's center. For example, if the median row is 3.5 and the pattern center row is 5, round the median row up to 4. If the median row is 3.5 and the pattern center row is 2, round the median row down to 3.\n    e. Remove all original yellow pixels from the grid (replace them with white (0)).\n    f. Place a single new yellow pixel at the final calculated (and possibly rounded) median coordinate.\n3.  **Output:** The grid with the rotated pattern and the consolidated yellow pixel is the output. If no yellow pixels are present in the input, only the pattern rotation occurs.\n\"\"\"\n\n\ndef find_pattern_location(grid_np):\n    \"\"\"Finds the top-left corner of the 3x3 pattern of blue/azure pixels.\"\"\"\n    height, width = grid_np.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid_np[r:r+3, c:c+3]\n            # Check if the subgrid contains only 1s and 8s\n            if np.all(np.isin(subgrid, [1, 8])):\n                # Optional: Add a check to ensure it's not all 1s or all 8s, if needed\n                # if np.any(subgrid == 1) and np.any(subgrid == 8):\n                return r, c\n    return None # Should not happen based on task description\n\n\ndef custom_round(median_val, center_val):\n    \"\"\"Applies the custom rounding rule for medians ending in .5.\"\"\"\n    if median_val % 1 == 0.5:\n        if center_val > median_val:\n            return math.ceil(median_val)\n        else: # center_val < median_val (center_val cannot equal median_val if median_val ends in .5)\n            return math.floor(median_val)\n    else:\n        # Standard rounding for non-.5 cases (or just truncate/floor if preferred, median usually implies specific handling)\n        # Using standard rounding for simplicity here, np.median handles the standard case\n        return int(round(median_val))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation: rotates a 3x3 pattern and consolidates yellow pixels.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n\n    # --- 1. Identify and Rotate Pattern ---\n    pattern_loc = find_pattern_location(input_grid_np)\n    if pattern_loc:\n        pattern_r, pattern_c = pattern_loc\n        # Extract the 3x3 pattern\n        pattern = input_grid_np[pattern_r:pattern_r+3, pattern_c:pattern_c+3]\n        # Rotate the pattern 90 degrees clockwise\n        rotated_pattern = np.rot90(pattern, k=-1)\n        # Place the rotated pattern back into the output grid\n        output_grid[pattern_r:pattern_r+3, pattern_c:pattern_c+3] = rotated_pattern\n    else:\n        # Handle case where pattern is not found, though examples suggest it's always present\n        print(\"Warning: 3x3 blue/azure pattern not found.\")\n        return output_grid.tolist() # Return unchanged grid or handle error\n\n    # --- 2. Identify and Consolidate Yellow Pixels ---\n    yellow_pixels = np.where(input_grid_np == 4)\n    yellow_rows, yellow_cols = yellow_pixels\n\n    if len(yellow_rows) > 0:\n        # a. Found yellow pixels coordinates\n        \n        # b. Calculate Median Coordinates\n        median_row = np.median(yellow_rows)\n        median_col = np.median(yellow_cols)\n\n        # c. Determine Pattern Center (if pattern was found)\n        if pattern_loc:\n            center_r = pattern_r + 1\n            center_c = pattern_c + 1\n\n            # d. Apply Rounding\n            target_r = custom_round(median_row, center_r)\n            target_c = custom_round(median_col, center_c)\n            \n            # Ensure target coordinates are within grid bounds (safety check)\n            target_r = max(0, min(height - 1, target_r))\n            target_c = max(0, min(width - 1, target_c))\n\n        else: # Fallback if pattern wasn't found - use simple rounding/floor\n             target_r = int(round(median_row))\n             target_c = int(round(median_col))\n             # Ensure target coordinates are within grid bounds\n             target_r = max(0, min(height - 1, target_r))\n             target_c = max(0, min(width - 1, target_c))\n\n\n        # e. Remove all original yellow pixels\n        output_grid[yellow_rows, yellow_cols] = 0\n\n        # f. Place a single new yellow pixel at the target location\n        output_grid[target_r, target_c] = 4\n\n    # --- 3. Final Output ---\n    # Convert back to list of lists format\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4183,
    "candidates_token_count": 1479,
    "total_token_count": 5662,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.956185,
  "retries": null
}