{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms a grid containing a unique 3x3 pattern of blue (1) and azure (8) pixels, and potentially scattered yellow (4) pixels, against a white (0) background.\n\n1.  **Find Pattern:** Locate the unique 3x3 subgrid composed entirely of blue (1) and azure (8) pixels. Record its top-left coordinates (`pattern_r`, `pattern_c`).\n2.  **Analyze Pattern:**\n    a. Extract the 3x3 pattern.\n    b. Count the total number of blue pixels (`count_blue`) and azure pixels (`count_azure`).\n    c. Identify the four corner pixels (top-left, top-right, bottom-left, bottom-right).\n    d. Count how many corner pixels are blue (`count_corner_blue`).\n3.  **Rotate Pattern:** Modify the pattern *in place* within an output grid copy based on counts:\n    a. If `count_azure > count_blue`: Rotate the pattern 180 degrees.\n    b. If `count_blue > count_azure`:\n        i.  If `count_corner_blue` is 4: Rotate 90 degrees clockwise.\n        ii. If `count_corner_blue` is 3: Rotate 90 degrees counter-clockwise.\n        iii. If `count_corner_blue` is 2: Rotate 180 degrees.\n    (Other counts for `corner_blue` when `count_blue > count_azure` are not expected based on examples).\n4.  **Consolidate Yellow Markers (if present):**\n    a. Find coordinates of all yellow (4) pixels in the original input grid.\n    b. If yellow pixels exist:\n        i. Calculate median row (`median_row`) and column (`median_col`).\n        ii. Determine pattern center (`center_r`, `center_c`).\n        iii. Calculate target coordinates (`target_r`, `target_c`) using custom rounding for medians ending in .5 (round towards pattern center), standard rounding otherwise.\n        iv. In the output grid, remove all original yellow pixels (set to white 0).\n        v. In the output grid, place a single yellow pixel at (`target_r`, `target_c`).\n5.  **Output:** Return the modified grid.\n\"\"\"\n\ndef find_pattern_location(grid_np):\n    \"\"\"Finds the top-left corner of the 3x3 pattern of blue(1)/azure(8) pixels.\"\"\"\n    height, width = grid_np.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid_np[r:r+3, c:c+3]\n            # Check if the subgrid contains only 1s and 8s and is not uniform\n            # and is exactly 3x3\n            if subgrid.shape == (3, 3) and \\\n               np.all(np.isin(subgrid, [1, 8])) and \\\n               len(np.unique(subgrid)) > 1:\n                 return r, c\n    return None # Should not happen based on task description but good practice\n\ndef analyze_pattern_corners(pattern):\n    \"\"\"Counts the number of blue pixels in the corners of a 3x3 pattern.\"\"\"\n    corners = [pattern[0, 0], pattern[0, 2], pattern[2, 0], pattern[2, 2]]\n    count_corner_blue = sum(1 for pixel in corners if pixel == 1)\n    return count_corner_blue\n\ndef custom_round(median_val, center_val):\n    \"\"\"Applies the custom rounding rule for medians ending in .5.\"\"\"\n    if median_val % 1 == 0.5:\n        # If median is exactly halfway, round towards the center coordinate\n        if center_val > median_val:\n            return math.ceil(median_val)\n        elif center_val < median_val:\n             return math.floor(median_val)\n        else: # center_val == median_val - should not happen if median ends in .5\n             # but if it does, standard rounding is fine.\n             return int(round(median_val))\n    else:\n        # Standard rounding for non-.5 cases (round half up)\n        return int(round(median_val))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: rotates a 3x3 pattern based on corner counts\n    and consolidates yellow pixels using median and custom rounding.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n\n    # --- 1. Find Pattern ---\n    pattern_loc = find_pattern_location(input_grid_np)\n    pattern_center_r, pattern_center_c = -1, -1 # Initialize pattern center\n\n    if pattern_loc:\n        pattern_r, pattern_c = pattern_loc\n        pattern_center_r = pattern_r + 1\n        pattern_center_c = pattern_c + 1\n\n        # --- 2. Analyze Pattern ---\n        pattern = input_grid_np[pattern_r:pattern_r+3, pattern_c:pattern_c+3]\n        count_blue = np.count_nonzero(pattern == 1)\n        count_azure = np.count_nonzero(pattern == 8)\n        count_corner_blue = analyze_pattern_corners(pattern)\n\n        # --- 3. Rotate Pattern ---\n        rotated_pattern = pattern # Default to no rotation if conditions aren't met\n        if count_azure > count_blue:\n            # Rotate 180 degrees\n            rotated_pattern = np.rot90(pattern, k=2)\n        elif count_blue > count_azure:\n            if count_corner_blue == 4:\n                # Rotate 90 degrees clockwise\n                rotated_pattern = np.rot90(pattern, k=3) # k=3 is 270 CCW = 90 CW\n            elif count_corner_blue == 3:\n                 # Rotate 90 degrees counter-clockwise\n                rotated_pattern = np.rot90(pattern, k=1)\n            elif count_corner_blue == 2:\n                 # Rotate 180 degrees\n                rotated_pattern = np.rot90(pattern, k=2)\n            # else: No rotation defined for other corner counts if B > A\n\n        # Place the rotated pattern back into the output grid\n        output_grid[pattern_r:pattern_r+3, pattern_c:pattern_c+3] = rotated_pattern\n    else:\n        # Handle case where pattern is not found (though examples suggest it's always present)\n        print(\"Warning: 3x3 blue/azure pattern not found.\")\n        # Continue without rotation, yellow consolidation might use standard rounding if pattern center unknown\n\n    # --- 4. Consolidate Yellow Markers (if present) ---\n    yellow_pixels = np.where(input_grid_np == 4)\n    yellow_rows, yellow_cols = yellow_pixels\n\n    if len(yellow_rows) > 0:\n        # a. Found yellow pixels coordinates\n\n        # b.i Calculate Median Coordinates\n        median_row = np.median(yellow_rows)\n        median_col = np.median(yellow_cols)\n\n        # Check if pattern was found before trying to use its center for custom rounding\n        if pattern_loc:\n            # b.ii Find Pattern Center (already done above)\n\n            # b.iii Apply Custom Rounding Rule\n            target_r = custom_round(median_row, pattern_center_r)\n            target_c = custom_round(median_col, pattern_center_c)\n        else:\n            # Fallback if pattern wasn't found - cannot use custom rounding relative to center\n            # Use standard rounding\n            target_r = int(round(median_row))\n            target_c = int(round(median_col))\n            print(\"Warning: Yellow pixels consolidated using standard rounding due to missing pattern.\")\n\n        # Ensure target coordinates are within grid bounds (safety check)\n        target_r = max(0, min(height - 1, target_r))\n        target_c = max(0, min(width - 1, target_c))\n\n        # b.iv Remove all original yellow pixels from the output grid\n        output_grid[yellow_rows, yellow_cols] = 0\n\n        # b.v Place a single new yellow pixel at the target location in the output grid\n        output_grid[target_r, target_c] = 4\n    # Else: No yellow pixels found, do nothing.\n\n    # --- 5. Final Output ---\n    # Convert back to list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12168,
    "candidates_token_count": 2070,
    "total_token_count": 14238,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.73616,
  "retries": null
}