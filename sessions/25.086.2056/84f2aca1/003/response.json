{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\n\n\"\"\"\nIdentifies contiguous non-white objects (8-way connectivity) and their enclosed white regions (holes, 4-way connectivity). Fills holes based on the number and size:\n- If an object encloses exactly one hole:\n  - Fill with gray (5) if the hole size is 1 pixel.\n  - Fill with orange (7) if the hole size is greater than 1 pixel.\n- If an object encloses exactly two holes:\n  - Fill both holes with orange (7).\nWhite regions touching the grid border are considered background and are not filled.\n\"\"\"\n\ndef find_neighbors(grid_shape, coords, connectivity=8):\n    \"\"\"\n    Finds valid neighbor coordinates for a set of coordinates within the grid boundaries.\n\n    Args:\n        grid_shape (tuple): The (rows, cols) shape of the grid.\n        coords (set): A set of (row, col) tuples representing the coordinates of interest.\n        connectivity (int): 8 for 8-way (including diagonals), 4 for 4-way.\n\n    Returns:\n        set: A set of (row, col) tuples representing neighbor coordinates.\n    \"\"\"\n    neighbors = set()\n    rows, cols = grid_shape\n    if connectivity == 4:\n        offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        offsets = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n\n    for r, c in coords:\n        for dr, dc in offsets:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within the grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Fills enclosed white regions (holes) within colored shapes based on the number and size of holes.\n    - 1 hole, size 1: fill with gray (5)\n    - 1 hole, size > 1: fill with orange (7)\n    - 2 holes: fill with orange (7)\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Define connectivity structures\n    struct_obj = generate_binary_structure(2, 2)  # 8-way connectivity for objects\n    struct_hole = generate_binary_structure(2, 1) # 4-way connectivity for holes\n\n    # 1. Identify all colored objects (non-zero pixels) using 8-way connectivity\n    colored_mask = input_grid != 0\n    obj_labels, num_objs = label(colored_mask, structure=struct_obj)\n\n    # 2. Identify all white regions (zero pixels) using 4-way connectivity\n    white_mask = input_grid == 0\n    hole_labels, num_holes_total = label(white_mask, structure=struct_hole)\n\n    # 3. Determine the labels of the background white region(s)\n    # Any white region touching the border is considered background.\n    border_labels = set()\n    if rows > 0 and cols > 0: # Ensure grid is not empty\n        border_labels.update(hole_labels[0, :])      # Top row\n        border_labels.update(hole_labels[-1, :])     # Bottom row\n        border_labels.update(hole_labels[:, 0])      # Left column\n        border_labels.update(hole_labels[:, -1])     # Right column\n    # Filter out 0 (which represents non-white areas in hole_labels)\n    background_label_set = {lbl for lbl in border_labels if lbl != 0}\n\n    # 4. Iterate through each unique colored object\n    obj_indices = np.unique(obj_labels)\n    obj_indices = obj_indices[obj_indices != 0] # Exclude background label 0\n\n    for obj_id in obj_indices:\n        # Get coordinates of the current object\n        obj_coords_tuple = np.where(obj_labels == obj_id)\n        obj_coords_set = set(zip(obj_coords_tuple[0], obj_coords_tuple[1]))\n\n        # Find all 8-way neighbors of the object's pixels\n        neighbor_coords = find_neighbors((rows, cols), obj_coords_set, connectivity=8)\n\n        # Identify adjacent white region labels that are *not* part of the object itself\n        adjacent_hole_labels = set()\n        for r, c in neighbor_coords:\n            if (r, c) not in obj_coords_set: # Ensure neighbor is not part of the object\n                 hole_label_at_coord = hole_labels[r, c]\n                 # Check if it's a valid labeled white region (label > 0)\n                 if hole_label_at_coord != 0:\n                     adjacent_hole_labels.add(hole_label_at_coord)\n\n        # Filter out the background labels to get only enclosed holes\n        enclosed_hole_labels = adjacent_hole_labels - background_label_set\n        num_enclosed_holes = len(enclosed_hole_labels)\n\n        # 5. Apply fill logic based on the number and size of enclosed holes\n        if num_enclosed_holes == 1:\n            hole_id = list(enclosed_hole_labels)[0]\n            hole_coords = np.where(hole_labels == hole_id)\n            hole_size = len(hole_coords[0]) # Count number of pixels in the hole\n\n            fill_color = -1 # Default: no fill\n            if hole_size == 1:\n                fill_color = 5 # Gray for size 1\n            elif hole_size > 1:\n                fill_color = 7 # Orange for size > 1\n\n            if fill_color != -1:\n                output_grid[hole_coords] = fill_color\n\n        elif num_enclosed_holes == 2:\n            fill_color = 7 # Orange for two holes\n            for hole_id in enclosed_hole_labels:\n                hole_coords = np.where(hole_labels == hole_id)\n                output_grid[hole_coords] = fill_color\n        \n        # Implicit: If num_enclosed_holes is 0 or > 2, do nothing.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11269,
    "candidates_token_count": 1564,
    "total_token_count": 12833,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.312167,
  "retries": null
}