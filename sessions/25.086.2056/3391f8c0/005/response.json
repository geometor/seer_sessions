{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransformation Rule:\n1. Initialize an output grid with the same dimensions as the input grid, filled with the background color (white, 0).\n2. Identify the two unique non-background colors present in the input grid. Call them `color_A` and `color_B`.\n3. Define a connectivity structure that includes diagonal neighbors (8-connectivity).\n4. Find all distinct, contiguous objects composed of `color_A` using the defined connectivity.\n5. Find all distinct, contiguous objects composed of `color_B` using the defined connectivity.\n6. From the first `color_A` object found, extract its shape pattern (the set of relative coordinates of its pixels from its top-left corner). Call this `shape_A`. If no `color_A` objects exist, `shape_A` is empty.\n7. From the first `color_B` object found, extract its shape pattern. Call this `shape_B`. If no `color_B` objects exist, `shape_B` is empty.\n8. Determine the list of top-left corner coordinates for all objects originally composed of `color_A`. Call this list `locations_A`.\n9. Determine the list of top-left corner coordinates for all objects originally composed of `color_B`. Call this list `locations_B`.\n10. For each coordinate (`r`, `c`) in `locations_A`:\n    * Draw `shape_B` onto the output grid, using `color_B`, anchoring its pattern at (`r`, `c`). Ensure drawing stays within grid bounds.\n11. For each coordinate (`r`, `c`) in `locations_B`:\n    * Draw `shape_A` onto the output grid, using `color_A`, anchoring its pattern at (`r`, `c`). Ensure drawing stays within grid bounds.\n12. Return the final output grid.\n\"\"\"\n\ndef get_objects_and_shape(grid_np, color, connectivity_structure):\n    \"\"\"\n    Finds objects of a specific color, their locations, and the shape of the first object.\n\n    Args:\n        grid_np: The input numpy grid.\n        color: The color of the objects to find.\n        connectivity_structure: The structure defining pixel connectivity for label().\n\n    Returns:\n        A tuple: (list_of_locations, shape_pattern)\n        list_of_locations: List of (row, col) tuples for the top-left corner of each object.\n        shape_pattern: List of (dr, dc) relative coordinates defining the shape,\n                       or None if no objects of this color are found.\n    \"\"\"\n    # Create a binary mask where the target color is present\n    mask = (grid_np == color)\n    \n    # Label connected components (objects) in the mask\n    labeled_grid, num_labels = label(mask, structure=connectivity_structure)\n    \n    if num_labels == 0:\n        return [], None  # No objects found\n\n    # Find the bounding boxes (slices) for each labeled object\n    object_slices = find_objects(labeled_grid)\n\n    locations = []\n    shape_pattern = None\n\n    for i, slc in enumerate(object_slices):\n        # Location is the top-left corner of the slice\n        top_left = (slc[0].start, slc[1].start)\n        locations.append(top_left)\n\n        # Extract the shape pattern from the first object found (label 1)\n        if i == 0: # find_objects returns slices ordered by label number starting from 1\n             # Get the portion of the original grid corresponding to the object's bounding box\n            object_bounding_box = grid_np[slc]\n             # Create a mask for the specific object within its bounding box\n            object_mask_in_bbox = (object_bounding_box == color) & (labeled_grid[slc] == (i + 1))\n             # Find the relative coordinates of the object's pixels within its bounding box\n            relative_coords = np.argwhere(object_mask_in_bbox)\n            if relative_coords.size > 0:\n                # Store shape as list of [dr, dc] tuples/lists\n                shape_pattern = relative_coords.tolist()\n            else:\n                 # This case should ideally not happen if find_objects found something,\n                 # but handle it defensively.\n                 shape_pattern = [[0, 0]] # Default to a single pixel if extraction fails\n\n    # Ensure shape_pattern is not None if objects were found but pattern extraction failed\n    if locations and shape_pattern is None:\n         shape_pattern = [[0, 0]] # Fallback shape\n\n    return locations, shape_pattern\n\ndef draw_shape(output_grid, anchor_r, anchor_c, shape_pattern, color):\n    \"\"\"\n    Draws a shape onto the output grid at a given anchor point.\n\n    Args:\n        output_grid: The numpy array representing the output grid.\n        anchor_r: The row coordinate of the anchor point (top-left).\n        anchor_c: The column coordinate of the anchor point (top-left).\n        shape_pattern: List of [dr, dc] relative coordinates defining the shape.\n        color: The color to draw the shape with.\n    \"\"\"\n    if shape_pattern is None:\n        return # Nothing to draw if shape is None\n\n    grid_height, grid_width = output_grid.shape\n    for dr, dc in shape_pattern:\n        r, c = anchor_r + dr, anchor_c + dc\n        # Check bounds before drawing\n        if 0 <= r < grid_height and 0 <= c < grid_width:\n            output_grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Swaps the locations of shapes defined by the two non-background colors.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n    \n    # Define 8-connectivity (includes diagonals)\n    connectivity_structure = np.ones((3, 3), dtype=bool)\n\n    # Find the unique non-background colors\n    unique_colors = np.unique(input_np)\n    non_bg_colors = unique_colors[unique_colors != 0]\n\n    # Ensure exactly two non-background colors exist\n    if len(non_bg_colors) != 2:\n        # If not exactly two, return the original grid (or handle as error)\n        # Based on analysis, valid examples always have two.\n        return input_grid\n\n    color_A, color_B = non_bg_colors[0], non_bg_colors[1]\n\n    # Get locations and shape for color A\n    locations_A, shape_A = get_objects_and_shape(input_np, color_A, connectivity_structure)\n\n    # Get locations and shape for color B\n    locations_B, shape_B = get_objects_and_shape(input_np, color_B, connectivity_structure)\n\n    # Draw Shape B at Color A's original locations\n    for r, c in locations_A:\n        draw_shape(output_np, r, c, shape_B, color_B)\n\n    # Draw Shape A at Color B's original locations\n    for r, c in locations_B:\n        draw_shape(output_np, r, c, shape_A, color_A)\n\n    # Convert the result back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10305,
    "candidates_token_count": 1786,
    "total_token_count": 12091,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.853229,
  "retries": null
}