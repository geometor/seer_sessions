{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReflects non-background, non-axis pixels across a single, complete line (axis) of a non-background color. The output grid starts as a copy of the input, and the reflected pixels are added (overwriting) at their corresponding reflected locations.\n\nThe transformation identifies a single complete horizontal or vertical line (axis) within the input grid that consists of a single, non-background color. This line acts as the axis of reflection. The background color is identified as orange (7). The output grid is initialized as an exact copy of the input grid. The transformation then iterates through all pixels in the input grid. If a pixel's color is not the background color (7) and the pixel is not located on the identified axis, its position is mathematically reflected across the axis. If the calculated reflected position is within the grid bounds, the color of the original pixel is placed at that reflected position in the output grid, overwriting whatever color was previously there (including background pixels or pixels from the initial copy). Pixels on the axis, background pixels, and the original non-background/non-axis pixels remain as they were in the initial copy. Pixels whose reflections fall outside the grid bounds are ignored.\n\"\"\"\n\ndef find_axis(grid, background_color):\n    \"\"\"\n    Finds a complete horizontal or vertical line of a single non-background color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The integer value representing the background color.\n\n    Returns:\n        tuple: ('h', row_index) if a horizontal axis is found,\n               ('v', col_index) if a vertical axis is found,\n               (None, None) if no axis is found.\n    \"\"\"\n    height, width = grid.shape\n\n    # Check for horizontal axis\n    for r in range(height):\n        first_pixel_color = grid[r, 0]\n        # Check if the first pixel is not background and the entire row has the same color\n        if first_pixel_color != background_color and np.all(grid[r, :] == first_pixel_color):\n            # Ensure it's a complete line\n            if grid[r, :].size == width:\n                 return 'h', r\n\n    # Check for vertical axis\n    for c in range(width):\n        first_pixel_color = grid[0, c]\n        # Check if the first pixel is not background and the entire column has the same color\n        if first_pixel_color != background_color and np.all(grid[:, c] == first_pixel_color):\n             # Ensure it's a complete line\n             if grid[:, c].size == height:\n                return 'v', c\n\n    return None, None # No axis found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # Define background color\n    background_color = 7\n\n    # Find the axis of symmetry using the helper function\n    axis_type, axis_index = find_axis(input_np, background_color)\n\n    # If no axis is found (as a safeguard, though examples imply one always exists)\n    if axis_type is None:\n        return input_grid # Return original grid as list of lists\n\n    # Iterate through each pixel of the *input* grid\n    for r in range(height):\n        for c in range(width):\n            # Get the color from the original input grid\n            color = input_np[r, c]\n\n            # 1. Skip background pixels\n            if color == background_color:\n                continue\n\n            # 2. Determine if the current pixel is on the axis\n            is_on_axis = False\n            if axis_type == 'h' and r == axis_index:\n                is_on_axis = True\n            elif axis_type == 'v' and c == axis_index:\n                is_on_axis = True\n\n            # 3. Skip pixels on the axis itself\n            if is_on_axis:\n                continue\n\n            # 4. If pixel is not background and not on axis, calculate its reflection\n            r_reflected, c_reflected = -1, -1 # Initialize with invalid values\n\n            if axis_type == 'h':\n                # Reflect vertically across the horizontal axis\n                r_reflected = 2 * axis_index - r\n                c_reflected = c\n            elif axis_type == 'v':\n                # Reflect horizontally across the vertical axis\n                r_reflected = r\n                c_reflected = 2 * axis_index - c\n\n            # 5. Check if the reflected coordinates are within the grid bounds\n            if 0 <= r_reflected < height and 0 <= c_reflected < width:\n                # 6. Update the *output grid* at the reflected position\n                #    with the original pixel's color. This overwrites the\n                #    destination cell in the output grid.\n                output_grid[r_reflected, c_reflected] = color\n            # Else: If reflection is outside bounds, do nothing.\n\n    # Convert the final numpy array back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6721,
    "candidates_token_count": 1268,
    "total_token_count": 7989,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 12.781775,
  "retries": null
}