{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis module transforms an input grid based on the following rules:\n1. Identify the largest contiguous rectangular area of gray (5) pixels.\n2. Identify four single non-white (0), non-gray (5) pixels located outside the gray rectangle, one conceptually near each corner (top-left, top-right, bottom-left, bottom-right).\n3. Create an output grid of the same dimensions as the input, initially filled with white (0).\n4. Divide the area corresponding to the original gray rectangle in the output grid into four equal quadrants.\n5. Fill each quadrant with the color of the corresponding corner pixel identified in step 2.\n   - Top-left quadrant gets the color of the pixel found above and to the left of the gray rectangle.\n   - Top-right quadrant gets the color of the pixel found above and to the right.\n   - Bottom-left quadrant gets the color of the pixel found below and to the left.\n   - Bottom-right quadrant gets the color of the pixel found below and to the right.\n\"\"\"\n\nimport numpy as np\nfrom typing import Tuple, Dict, Optional, List\n\ndef find_largest_gray_rectangle(grid: np.ndarray) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of the largest contiguous rectangular area of gray (5) pixels.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col) representing the bounding box\n        of the largest gray rectangle found, or None if no gray pixels are found\n        or the largest gray area is not rectangular.\n    \"\"\"\n    height, width = grid.shape\n    max_size = 0\n    best_bounds = None\n    visited = np.zeros_like(grid, dtype=bool)\n    gray_color = 5\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a gray pixel that hasn't been visited yet, start a search\n            if grid[r, c] == gray_color and not visited[r, c]:\n                component_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Breadth-First Search to find all connected gray pixels\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    component_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == gray_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Check if the found component forms a solid rectangle\n                current_height = max_r - min_r + 1\n                current_width = max_c - min_c + 1\n                current_size = current_height * current_width\n                \n                is_solid_rectangle = True\n                if len(component_pixels) != current_size:\n                     # The number of pixels in the component doesn't match the bounding box area\n                     is_solid_rectangle = False\n                else:\n                    # Verify all pixels within the bounds are gray and part of the component\n                    for rr in range(min_r, max_r + 1):\n                        for cc in range(min_c, max_c + 1):\n                            if grid[rr, cc] != gray_color or (rr, cc) not in component_pixels:\n                                is_solid_rectangle = False\n                                break\n                        if not is_solid_rectangle:\n                            break\n                            \n                # Update best bounds if this rectangle is larger\n                if is_solid_rectangle and current_size > max_size:\n                    max_size = current_size\n                    best_bounds = (min_r, min_c, max_r, max_c)\n\n    return best_bounds\n\ndef find_corner_pixels(grid: np.ndarray, rect_bounds: Tuple[int, int, int, int]) -> Optional[Dict[str, int]]:\n    \"\"\"\n    Finds the four corner indicator pixels and their colors relative to the gray rectangle.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        rect_bounds: The bounding box (min_r, min_c, max_r, max_c) of the gray rectangle.\n\n    Returns:\n        A dictionary mapping corner identifiers ('TL', 'TR', 'BL', 'BR') to their colors,\n        or None if exactly four corner pixels are not found in the expected positions.\n    \"\"\"\n    height, width = grid.shape\n    min_row, min_col, max_row, max_col = rect_bounds\n    corner_colors = {}\n    background_color = 0\n    gray_color = 5\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Ignore background and gray pixels\n            if color == background_color or color == gray_color:\n                continue\n            \n            # Check if pixel is outside the gray rectangle bounds\n            is_outside = r < min_row or r > max_row or c < min_col or c > max_col\n            if not is_outside:\n                 continue # ignore pixels inside the rect bounds\n\n            # Classify the pixel based on its relative position to the rectangle\n            if r < min_row and c < min_col:\n                # Potential Top-Left\n                if 'TL' in corner_colors: return None # Found multiple TL pixels\n                corner_colors['TL'] = color\n            elif r < min_row and c > max_col:\n                # Potential Top-Right\n                if 'TR' in corner_colors: return None # Found multiple TR pixels\n                corner_colors['TR'] = color\n            elif r > max_row and c < min_col:\n                # Potential Bottom-Left\n                if 'BL' in corner_colors: return None # Found multiple BL pixels\n                corner_colors['BL'] = color\n            elif r > max_row and c > max_col:\n                # Potential Bottom-Right\n                if 'BR' in corner_colors: return None # Found multiple BR pixels\n                corner_colors['BR'] = color\n            # else: # Pixel is outside but not in a corner region relative to the rect\n                 # Based on problem description, we expect exactly 4 such pixels in corners\n                 # pass # Ignore these pixels if they exist\n\n    # Check if exactly one pixel was found for each corner\n    if len(corner_colors) == 4 and all(k in corner_colors for k in ['TL', 'TR', 'BL', 'BR']):\n        return corner_colors\n    else:\n        # Did not find exactly four corner pixels in the correct relative positions\n        return None\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by replacing a central gray rectangle with four quadrants\n    colored according to corner indicator pixels.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid with background color (white = 0)\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the largest gray rectangle\n    rect_bounds = find_largest_gray_rectangle(input_np)\n    if rect_bounds is None:\n        # Error condition: No suitable gray rectangle found.\n        # Based on examples, this shouldn't happen. Return empty grid or raise error.\n        print(\"Error: Could not find the gray rectangle.\")\n        return output_np.tolist() # Return empty grid\n\n    min_row, min_col, max_row, max_col = rect_bounds\n\n    # 2. Find the four corner indicator pixels and their colors\n    corner_colors = find_corner_pixels(input_np, rect_bounds)\n    if corner_colors is None:\n        # Error condition: Could not find exactly four corner pixels.\n        print(\"Error: Could not find exactly four corner indicator pixels.\")\n        return output_np.tolist() # Return empty grid\n\n    # 3. Calculate rectangle dimensions and midpoints for quadrants\n    rect_height = max_row - min_row + 1\n    rect_width = max_col - min_col + 1\n    \n    # Ensure rectangle dimensions are even as implied by examples for perfect split\n    if rect_height % 2 != 0 or rect_width % 2 != 0:\n        print(f\"Warning: Gray rectangle dimensions ({rect_height}x{rect_width}) are not even.\")\n        # Proceeding with integer division for midpoints\n\n    mid_row = min_row + rect_height // 2\n    mid_col = min_col + rect_width // 2\n\n    # 4. Fill the quadrants in the output grid\n    try:\n        # Top-Left Quadrant (Color: TL)\n        output_np[min_row:mid_row, min_col:mid_col] = corner_colors['TL']\n        \n        # Top-Right Quadrant (Color: TR)\n        # Numpy slicing is exclusive of the end index, so use max_col + 1\n        output_np[min_row:mid_row, mid_col:max_col + 1] = corner_colors['TR']\n        \n        # Bottom-Left Quadrant (Color: BL)\n        # Numpy slicing is exclusive of the end index, so use max_row + 1\n        output_np[mid_row:max_row + 1, min_col:mid_col] = corner_colors['BL']\n        \n        # Bottom-Right Quadrant (Color: BR)\n        # Numpy slicing is exclusive of the end index, so use max_row + 1 and max_col + 1\n        output_np[mid_row:max_row + 1, mid_col:max_col + 1] = corner_colors['BR']\n    except KeyError as e:\n         print(f\"Error: Missing corner color for {e}\")\n         return output_np.tolist() # Return empty grid if a color is missing\n    except IndexError as e:\n         print(f\"Error: Indexing error during quadrant filling: {e}\")\n         return output_np.tolist() # Return empty grid\n\n    # 5. Convert the resulting numpy array back to a list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3678,
    "candidates_token_count": 2599,
    "total_token_count": 6277,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.271094,
  "retries": null
}