{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a horizontal pattern (motif) in the input grid formed by non-background (non-white/0) pixels. \nThis motif is defined by the rows containing any non-background pixels.\nThe output grid is generated by vertically tiling this extracted motif, starting from the top row and repeating downwards until the entire output grid (which has the same dimensions as the input) is filled.\n\"\"\"\n\nimport numpy as np\n\ndef find_non_background_rows(grid_np, background_color=0):\n    \"\"\"\n    Finds the minimum and maximum row indices containing non-background pixels.\n\n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n        background_color (int): The value representing the background color.\n\n    Returns:\n        tuple: (min_row, max_row) indices, or (None, None) if no non-background pixels found.\n    \"\"\"\n    # Find rows that contain at least one pixel different from the background color\n    non_background_rows = np.where(np.any(grid_np != background_color, axis=1))[0]\n    \n    if len(non_background_rows) == 0:\n        # Handle the case where the grid might be entirely background or empty\n        return None, None \n        \n    min_row = np.min(non_background_rows)\n    max_row = np.max(non_background_rows)\n    return min_row, max_row\n\ndef extract_motif(grid_np, min_row, max_row):\n    \"\"\"\n    Extracts the motif slice (rows from min_row to max_row) from the grid.\n    Based on the examples, the motif spans the full width of the grid within these rows.\n\n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n        min_row (int): The starting row index of the motif.\n        max_row (int): The ending row index of the motif.\n\n    Returns:\n        np.array: The extracted motif.\n    \"\"\"\n    if min_row is None or max_row is None:\n        # Return an empty array if no valid rows were found\n        return np.array([[]], dtype=int) \n        \n    # Slice the grid to get the rows defining the motif\n    motif = grid_np[min_row : max_row + 1, :]\n    return motif\n\ndef tile_vertically(motif, output_height, output_width):\n    \"\"\"\n    Creates a new grid by vertically tiling the provided motif.\n\n    Args:\n        motif (np.array): The pattern to tile.\n        output_height (int): The desired height of the output grid.\n        output_width (int): The desired width of the output grid.\n\n    Returns:\n        np.array: The resulting grid tiled with the motif.\n    \"\"\"\n    motif_height = motif.shape[0]\n    \n    # Handle cases with empty motif or zero height\n    if motif_height == 0 or motif.size == 0:\n        # Return a grid filled with a default color, like background (0)\n        return np.zeros((output_height, output_width), dtype=int)\n\n    # Initialize the output grid\n    # Ensure it matches the motif's width, assuming output_width matches input's\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # Fill the output grid by repeating the motif rows\n    for r in range(output_height):\n        # Calculate the corresponding row index in the motif using modulo\n        source_row_index = r % motif_height\n        # Copy the motif row to the output grid row\n        # Ensure motif width matches output_width, otherwise this might error or broadcast unexpectedly.\n        # Based on examples, motif width == grid width, so this should be fine.\n        if motif.shape[1] == output_width:\n             output_grid[r, :] = motif[source_row_index, :]\n        else:\n             # Handle potential width mismatch if necessary, though not expected from examples\n             # For now, assume widths match\n             print(f\"Warning: Motif width {motif.shape[1]} does not match output width {output_width}. Tiling might be incorrect.\")\n             # Simple approach: Tile using the motif's width, potentially leaving parts of output grid empty/zero\n             copy_width = min(motif.shape[1], output_width)\n             output_grid[r, :copy_width] = motif[source_row_index, :copy_width]\n\n\n    return output_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting a horizontal pattern (motif) \n    and tiling it vertically to fill the output grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    input_height, input_width = input_grid_np.shape\n\n    # Define the background color (assumed to be 0 based on examples)\n    background_color = 0\n\n    # 1. Identify the rows containing the non-background pattern\n    min_row, max_row = find_non_background_rows(input_grid_np, background_color)\n\n    # Handle case where no pattern is found (e.g., all background)\n    if min_row is None:\n        # Return a grid of zeros with the same dimensions\n        return np.zeros_like(input_grid_np).tolist() \n\n    # 2. Extract the motif from the identified rows\n    motif = extract_motif(input_grid_np, min_row, max_row)\n\n    # 3. Create the output grid by tiling the motif vertically\n    output_grid_np = tile_vertically(motif, input_height, input_width)\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3787,
    "candidates_token_count": 1413,
    "total_token_count": 5200,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.06209,
  "retries": null
}