{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRecolor blue (1) objects based on an ordered palette of other colors present in the grid.\n\n1.  **Identify Palette Colors**: Scan the input grid row by row, from top to bottom, and within each row, from left to right. Record the unique colors encountered that are neither white (0) nor blue (1). Maintain the order in which these colors are first encountered. This ordered list is the `palette`. Let M be the number of colors in the `palette`.\n2.  **Identify Blue Objects**: Find all distinct contiguous objects composed of blue (1) pixels, considering pixels connected horizontally, vertically, or diagonally as part of the same object.\n3.  **Order Blue Objects**: Determine the top-leftmost pixel for each blue object. Sort the blue objects based on these coordinates (first by row index, then by column index). This creates an ordered list of blue objects `B`. Let N be the number of blue objects.\n4.  **Check Applicability**: If no blue objects are found (N=0) or no palette colors are found (M=0), return the input grid unchanged.\n5.  **Initialize Output Grid**: Create a copy of the input grid to serve as the output grid.\n6.  **Recolor First Blue Object**: Recolor all pixels of the first blue object (`B[0]`) in the output grid using the first palette color (`palette[0]`).\n7.  **Recolor Subsequent Blue Objects (if N > 1)**:\n    a.  **Recolor Last Blue Object**:\n        *   If the number of blue objects equals the number of palette colors (N == M), recolor the last blue object (`B[N-1]`) using the last palette color (`palette[M-1]`).\n        *   Otherwise (if N != M), recolor the last blue object (`B[N-1]`) using the first palette color (`palette[0]`).\n    b.  **Recolor Intermediate Blue Objects (if N > 2)**:\n        *   If there is only one palette color (M == 1), recolor all intermediate blue objects (`B[1]` through `B[N-2]`) using the first (and only) palette color (`palette[0]`).\n        *   If there is more than one palette color (M > 1), recolor all intermediate blue objects (`B[1]` through `B[N-2]`) using the second palette color (`palette[1]`).\n8.  **Return Output**: Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, target_colors):\n    \"\"\"\n    Finds contiguous objects of specified colors in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_colors (set): A set of colors to find objects for.\n\n    Returns:\n        list: A list of objects, where each object is a set of (row, col) tuples.\n              The list is sorted by the top-leftmost coordinate of each object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    # Iterate through the grid to find starting points of objects\n    for r in range(rows):\n        for c in range(cols):\n            # If a pixel has a target color and hasn't been visited yet, start a BFS\n            if grid[r, c] in target_colors and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Track the top-leftmost coordinate\n\n                # Breadth-First Search to find all connected pixels of the same object\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Keep track of the top-leftmost coordinate for sorting later\n                    if row < min_r:\n                        min_r, min_c = row, col\n                    elif row == min_r and col < min_c:\n                        min_c = col\n\n                    # Explore 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if the neighbor is a valid part of the object\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] in target_colors and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store the object's coordinates and its top-left coordinate\n                objects.append({'coords': obj_coords, 'top_left': (min_r, min_c)})\n\n    # Sort objects based on their top-left coordinate (row, then column)\n    objects.sort(key=lambda obj: obj['top_left'])\n    \n    # Return just the coordinate sets in the sorted order\n    return [obj['coords'] for obj in objects]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring blue objects based on palette colors.\n    \n    Args:\n        input_grid (np.array): The input 2D array.\n\n    Returns:\n        np.array: The transformed 2D array.\n    \"\"\"\n    # 1. Identify and order palette colors (non-white 0, non-blue 1)\n    rows, cols = input_grid.shape\n    palette_first_coords = {} # Dictionary to store first encountered coordinate for each palette color\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            if color != 0 and color != 1:\n                if color not in palette_first_coords:\n                    palette_first_coords[color] = (r, c)\n    \n    # Sort the found palette colors by their first appearance coordinates\n    sorted_palette_items = sorted(palette_first_coords.items(), key=lambda item: item[1])\n    palette_colors_ordered = [color for color, coords in sorted_palette_items]\n    num_palette_colors = len(palette_colors_ordered) # M\n\n    # 2. & 3. Identify and order blue objects\n    blue_objects = find_objects(input_grid, {1}) # Find objects with color 1 (blue)\n    num_blue_objects = len(blue_objects) # N\n\n    # 4. Check Applicability: If no blue objects or no palette colors, return original grid\n    if num_blue_objects == 0 or num_palette_colors == 0:\n        return np.copy(input_grid) \n\n    # 5. Initialize Output Grid\n    output_grid = np.copy(input_grid)\n\n    # 6. Recolor First Blue Object (B[0]) with first palette color (P[0])\n    first_object_coords = blue_objects[0]\n    first_palette_color = palette_colors_ordered[0]\n    for r, c in first_object_coords:\n        output_grid[r, c] = first_palette_color\n\n    # 7. Recolor Subsequent Blue Objects (only if N > 1)\n    if num_blue_objects > 1:\n        # 7a. Recolor Last Blue Object (B[N-1])\n        last_object_coords = blue_objects[-1]\n        last_object_target_color = -1 # Placeholder\n\n        # Condition: N == M vs N != M\n        if num_blue_objects == num_palette_colors:\n            # If N == M, use the last palette color P[M-1]\n            last_object_target_color = palette_colors_ordered[-1] \n        else: # N != M\n            # If N != M, use the first palette color P[0]\n            last_object_target_color = palette_colors_ordered[0] \n\n        # Apply the determined color to the last object\n        for r, c in last_object_coords:\n            output_grid[r, c] = last_object_target_color\n\n        # 7b. Recolor Intermediate Blue Objects (B[1] to B[N-2]) (only if N > 2)\n        if num_blue_objects > 2:\n            intermediate_target_color = -1 # Placeholder\n\n            # Condition: M == 1 vs M > 1\n            if num_palette_colors == 1:\n                # If only one palette color (M=1), use it (P[0])\n                intermediate_target_color = palette_colors_ordered[0]\n            else: # M > 1\n                # If multiple palette colors, use the second one (P[1])\n                intermediate_target_color = palette_colors_ordered[1] \n\n            # Apply the determined color to all intermediate objects\n            # Loop from the second object (index 1) up to (but not including) the last object (index N-1)\n            for i in range(1, num_blue_objects - 1):\n                intermediate_obj_coords = blue_objects[i]\n                for r, c in intermediate_obj_coords:\n                    output_grid[r, c] = intermediate_target_color\n\n    # 8. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 3459,
            "end_index": 3791,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8146,
    "candidates_token_count": 2185,
    "total_token_count": 10331,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.755083,
  "retries": null
}