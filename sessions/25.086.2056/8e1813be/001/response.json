{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all unique colors in the input grid, excluding white (0) and gray (5).\nOrder these relevant colors based on their first appearance in the input grid (top-to-bottom, then left-to-right).\nDetermine the overall orientation of the shapes formed by these relevant colors. If all shapes have height >= width, the orientation is 'Vertical'; otherwise, it's 'Horizontal'.\nCreate a square output grid where the side length N is the number of unique relevant colors.\nIf the orientation is 'Vertical', fill the j-th column of the output grid with the j-th color from the ordered list.\nIf the orientation is 'Horizontal', fill the i-th row of the output grid with the i-th color from the ordered list.\n\"\"\"\n\ndef find_objects(grid, colors_to_find):\n    \"\"\"\n    Finds all connected components (objects) of the specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of integer colors to search for.\n\n    Returns:\n        list: A list of objects, where each object is a set of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the current cell contains a relevant color and hasn't been visited\n            if color in colors_to_find and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)]) # Use deque for efficient BFS queue\n                visited[r, c] = True\n                \n                # Breadth-First Search to find all connected cells of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found object (set of coordinates) to the list if not empty\n                if obj_coords:\n                    objects.append(obj_coords)\n                    \n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box of an object represented by a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_object_dimensions(obj_coords):\n    \"\"\"\n    Calculates the height and width of an object based on its bounding box.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        tuple: (height, width). Returns (0, 0) if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return 0, 0\n        \n    bbox = get_bounding_box(obj_coords)\n    if bbox is None:\n        return 0, 0\n        \n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified colors, their order, \n    object orientation, and constructs the output grid accordingly.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Identify relevant colors (non-white, non-gray) and find their first appearance\n    relevant_colors_first_pos = {} # color -> (min_row, min_col)\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Ignore background (0) and gray (5)\n            if color != 0 and color != 5:\n                # Record the first position (top-leftmost) where each relevant color appears\n                if color not in relevant_colors_first_pos:\n                    relevant_colors_first_pos[color] = (r, c)\n\n    # If no relevant colors are found, return an empty grid or handle appropriately\n    if not relevant_colors_first_pos:\n        # Based on examples, an empty output seems unlikely, but returning [] is safe.\n        # A 0x0 grid isn't standard, maybe return [[0]] or based on problem constraints.\n        # Let's assume N >= 1 based on examples and return empty list if no colors.\n        return [] \n\n    # 2. Sort the relevant colors based on their first appearance (row first, then column)\n    sorted_colors = sorted(relevant_colors_first_pos.keys(), \n                           key=lambda color: relevant_colors_first_pos[color])\n    n = len(sorted_colors) # Size of the output grid side\n\n    # 3. Find all objects formed by the relevant colors\n    relevant_color_set = set(relevant_colors_first_pos.keys())\n    all_objects = find_objects(grid, relevant_color_set)\n\n    # 4. Determine the overall orientation\n    # Assume vertical orientation unless a horizontally oriented object is found\n    is_vertical_orientation = True\n    if not all_objects:\n         # If colors exist but form no connected objects (e.g., single pixels), default to Horizontal\n         is_vertical_orientation = False\n    else:\n        for obj_coords in all_objects:\n            obj_height, obj_width = get_object_dimensions(obj_coords)\n            # If any object is wider than it is tall, the overall orientation is Horizontal\n            if obj_height < obj_width:\n                is_vertical_orientation = False\n                break # No need to check further\n\n    # 5. Construct the N x N output grid\n    output_grid = np.zeros((n, n), dtype=int)\n\n    # 6. Populate the output grid based on the determined orientation and sorted colors\n    for idx, color in enumerate(sorted_colors):\n        if is_vertical_orientation:\n            # Fill the entire column 'idx' with the current color\n            output_grid[:, idx] = color \n        else:\n            # Fill the entire row 'idx' with the current color\n            output_grid[idx, :] = color \n\n    # Convert the numpy array back to a list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3555,
    "candidates_token_count": 1720,
    "total_token_count": 5275,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.895798,
  "retries": null
}