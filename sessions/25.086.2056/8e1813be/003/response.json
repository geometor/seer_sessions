{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify all unique colors in the input grid, excluding white (0) and gray (5).\nRecord the first appearance (top-to-bottom, left-to-right) coordinate for each relevant color.\nCount the number of unique relevant colors, N.\nFind all connected objects formed by these relevant colors.\nDetermine the overall orientation: 'Vertical' if all objects have height >= width, 'Horizontal' otherwise.\nCreate an N x N output grid.\nSort the relevant colors based on their first appearance coordinate:\n- If orientation is 'Horizontal', sort primarily by row, secondarily by column.\n- If orientation is 'Vertical', sort primarily by column, secondarily by row.\nPopulate the output grid:\n- If orientation is 'Horizontal', fill the i-th row with the i-th sorted color.\n- If orientation is 'Vertical', fill the j-th column with the j-th sorted color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, colors_to_find):\n    \"\"\"\n    Finds all connected components (objects) of the specified colors in the grid.\n    Uses 4-directional connectivity (von Neumann neighborhood).\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of integer colors to search for.\n\n    Returns:\n        list: A list of objects, where each object is a set of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the current cell contains a relevant color and hasn't been visited\n            if color in colors_to_find and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)]) # Use deque for efficient BFS queue\n                visited[r, c] = True\n\n                # Breadth-First Search to find all connected cells of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Add the found object (set of coordinates) to the list if not empty\n                if obj_coords:\n                    objects.append(obj_coords)\n\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box of an object represented by a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_object_dimensions(obj_coords):\n    \"\"\"\n    Calculates the height and width of an object based on its bounding box.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        tuple: (height, width). Returns (0, 0) if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return 0, 0\n\n    bbox = get_bounding_box(obj_coords)\n    if bbox is None:\n        return 0, 0\n\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified colors, their order,\n    object orientation, and constructs the output grid accordingly.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Identify relevant colors (non-white, non-gray) and find their first appearance\n    relevant_colors_first_pos = {} # color -> (min_row, min_col)\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Ignore background (0) and gray (5)\n            if color != 0 and color != 5:\n                # Record the first position (top-leftmost) where each relevant color appears\n                if color not in relevant_colors_first_pos:\n                    relevant_colors_first_pos[color] = (r, c)\n\n    # If no relevant colors are found, return an empty grid or handle appropriately.\n    # Based on examples, N should be >= 1. Returning empty list if no colors found.\n    if not relevant_colors_first_pos:\n        return []\n\n    # 2. Count relevant colors (N)\n    n = len(relevant_colors_first_pos) # Size of the output grid side\n\n    # 3. Find all objects formed by the relevant colors\n    relevant_color_set = set(relevant_colors_first_pos.keys())\n    all_objects = find_objects(grid, relevant_color_set)\n\n    # 4. Determine the overall orientation\n    # Assume vertical orientation unless a horizontally oriented object is found\n    is_vertical_orientation = True\n    if not all_objects:\n         # If colors exist but form no connected objects (e.g., single pixels),\n         # treat them as 1x1 objects. Since height >= width (1 >= 1), default remains Vertical.\n         # However, let's reconsider this based on example failure. If isolated pixels, treat as horizontal?\n         # Example 1 has clear vertical objects. Examples 2 & 3 have clear horizontal ones.\n         # Let's stick to the rule: if ANY object has height < width, it's Horizontal.\n         pass # Default is vertical, only change if condition met below\n\n    for obj_coords in all_objects:\n        obj_height, obj_width = get_object_dimensions(obj_coords)\n        # If any object is wider than it is tall, the overall orientation is Horizontal\n        if obj_height < obj_width:\n            is_vertical_orientation = False\n            break # No need to check further\n\n    # 5. Sort the relevant colors based on orientation and first appearance\n    if is_vertical_orientation:\n        # Sort by column first, then row for Vertical orientation\n        sorted_colors = sorted(relevant_colors_first_pos.keys(),\n                               key=lambda color: (relevant_colors_first_pos[color][1], relevant_colors_first_pos[color][0]))\n    else:\n        # Sort by row first, then column for Horizontal orientation\n        sorted_colors = sorted(relevant_colors_first_pos.keys(),\n                               key=lambda color: relevant_colors_first_pos[color]) # default sort by (row, col) tuple\n\n\n    # 6. Construct the N x N output grid, initialized to white (0)\n    output_grid = np.zeros((n, n), dtype=int)\n\n    # 7. Populate the output grid based on the determined orientation and sorted colors\n    for idx, color in enumerate(sorted_colors):\n        if is_vertical_orientation:\n            # Fill the entire column 'idx' with the current color\n            output_grid[:, idx] = color\n        else:\n            # Fill the entire row 'idx' with the current color\n            output_grid[idx, :] = color\n\n    # Convert the numpy array back to a list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9301,
    "candidates_token_count": 1911,
    "total_token_count": 11212,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.937907,
  "retries": null
}