{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid containing exactly two non-white pixels (aligned horizontally or vertically) into an output grid featuring two 5x5 plus-shaped patterns.\n\nThe transformation rule is as follows:\n1. Locate the two non-white pixels in the input grid. Sort them by row, then column, to get P1 = ((r1, c1), color1) and P2 = ((r2, c2), color2).\n2. Determine the alignment (horizontal if r1 == r2, vertical if c1 == c2).\n3. Calculate the midpoint along the axis of alignment:\n    - Horizontal: mid_c = (c1 + c2) / 2.0\n    - Vertical: mid_r = (r1 + r2) / 2.0\n4. Calculate the center coordinate (center1_r, center1_c) for the first shape (color1):\n    - Horizontal: center1_r = r1, center1_c = c1 + floor((floor(mid_c) - c1) / 2)\n    - Vertical: center1_r = r1 + floor((floor(mid_r) - r1) / 2), center1_c = c1\n5. Calculate the center coordinate (center2_r, center2_c) for the second shape (color2):\n    - Horizontal: center2_r = r2, center2_c = c2 - floor((c2 - ceil(mid_c)) / 2)\n    - Vertical: center2_r = r2 - floor((r2 - ceil(mid_r)) / 2), center2_c = c2\n6. Draw two 5x5 plus shapes (+) on an initially white grid of the same dimensions as the input. Shape 1 uses color1 centered at (center1_r, center1_c), and Shape 2 uses color2 centered at (center2_r, center2_c). The plus shape consists of the center pixel and the pixels at distances 1 and 2 along the horizontal and vertical axes from the center.\n\"\"\"\n\n# Helper function to find the two non-white pixels\ndef find_non_white_pixels(grid):\n    \"\"\"\n    Finds the coordinates and colors of the two non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing two elements, each a tuple of ((row, col), color).\n               Returns (None, None) if exactly two non-white pixels are not found.\n               The pixels are sorted by row index, then column index.\n    \"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append(((r, c), grid[r, c]))\n\n    if len(pixels) != 2:\n        print(f\"Warning: Expected 2 non-white pixels, found {len(pixels)}\")\n        return None, None\n\n    # Sort by row, then column to ensure consistent order\n    pixels.sort(key=lambda x: x[0])\n    return pixels[0], pixels[1]\n\n# Helper function to draw a 5x5 plus shape\ndef draw_plus_shape(grid, center_r, center_c, color):\n    \"\"\"\n    Draws a 5x5 plus shape (+) onto the grid centered at (center_r, center_c).\n\n    Args:\n        grid (np.array): The grid to draw on (mutable).\n        center_r (int): The row index of the center of the shape.\n        center_c (int): The column index of the center of the shape.\n        color (int): The color to use for drawing the shape.\n    \"\"\"\n    rows, cols = grid.shape\n    # Relative coordinates for the 9 pixels forming the 5x5 plus shape\n    shape_coords_relative = [\n        (0, 0), (0, 1), (0, -1), (0, 2), (0, -2),\n        (1, 0), (-1, 0), (2, 0), (-2, 0)\n    ]\n    for dr, dc in shape_coords_relative:\n        r, c = center_r + dr, center_c + dc\n        # Check grid boundaries before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Initialize output grid with background color (white, 0)\n    output_grid = np.zeros_like(input_np)\n\n    # Find the two non-white pixels and their colors, sorted by position\n    pixel1, pixel2 = find_non_white_pixels(input_np)\n\n    # If exactly two pixels weren't found, return the empty grid\n    if pixel1 is None or pixel2 is None:\n       return output_grid.tolist()\n\n    # Extract coordinates and colors\n    (r1, c1), color1 = pixel1\n    (r2, c2), color2 = pixel2\n\n    # Initialize center coordinates\n    center1_r, center1_c = -1, -1 # Center for shape derived from pixel1\n    center2_r, center2_c = -1, -1 # Center for shape derived from pixel2\n\n    # Determine orientation and calculate the two center points using the refined logic\n    if r1 == r2:  # Horizontal alignment\n        mid_c = (c1 + c2) / 2.0 # Calculate midpoint column\n        center1_r = r1\n        # Calculate center column for shape 1\n        center1_c = c1 + math.floor((math.floor(mid_c) - c1) / 2)\n        center2_r = r2\n        # Calculate center column for shape 2\n        center2_c = c2 - math.floor((c2 - math.ceil(mid_c)) / 2)\n\n    elif c1 == c2:  # Vertical alignment\n        mid_r = (r1 + r2) / 2.0 # Calculate midpoint row\n        # Calculate center row for shape 1\n        center1_r = r1 + math.floor((math.floor(mid_r) - r1) / 2)\n        center1_c = c1\n        # Calculate center row for shape 2\n        center2_r = r2 - math.floor((r2 - math.ceil(mid_r)) / 2)\n        center2_c = c2\n    else:\n        # This case is not expected based on the training examples\n        print(\"Error: Input pixels are not aligned horizontally or vertically.\")\n        return output_grid.tolist() # Return empty grid if alignment is invalid\n\n    # Draw the first plus shape using color1 centered at the calculated (center1_r, center1_c)\n    draw_plus_shape(output_grid, center1_r, center1_c, color1)\n\n    # Draw the second plus shape using color2 centered at the calculated (center2_r, center2_c)\n    draw_plus_shape(output_grid, center2_r, center2_c, color2)\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8542,
    "candidates_token_count": 1729,
    "total_token_count": 10271,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 13.294599,
  "retries": null
}