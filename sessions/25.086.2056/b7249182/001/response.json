{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid containing exactly two non-white pixels into an output grid featuring two 5x5 plus-shaped patterns.\n\nThe transformation rule is as follows:\n1. Locate the two non-white pixels in the input grid. Let their coordinates be (r1, c1) and (r2, c2), and their colors be color1 and color2, respectively. Assume these pixels are always aligned either horizontally (r1 == r2) or vertically (c1 == c2). The pixels are processed in a consistent order (e.g., sorted by row, then column).\n2. Determine the midpoint between these two pixels.\n3. Calculate two center points for the output shapes based on the midpoint and alignment:\n    - If horizontally aligned: The centers are (r1, floor((c1+c2)/2)) and (r1, ceil((c1+c2)/2)).\n    - If vertically aligned: The centers are (floor((r1+r2)/2), c1) and (ceil((r1+r2)/2), c1).\n4. The shape corresponding to the first pixel (in sorted order) is centered at the 'floor' coordinate, and the shape corresponding to the second pixel is centered at the 'ceil' coordinate.\n5. Draw two 5x5 plus shapes (+) on an initially white grid of the same dimensions as the input. Each shape uses the color of its corresponding input pixel and is centered at its calculated center point. The plus shape consists of a central pixel and the two pixels immediately adjacent horizontally and vertically, plus the two pixels next adjacent horizontally and vertically (i.e., a 5-pixel horizontal line and a 5-pixel vertical line intersecting at the center).\n\"\"\"\n\ndef find_non_white_pixels(grid):\n    \"\"\"\n    Finds the coordinates and colors of the two non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing two elements, each a tuple of ((row, col), color).\n               Returns (None, None) if exactly two non-white pixels are not found.\n               The pixels are sorted by row index, then column index.\n    \"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append(((r, c), grid[r, c]))\n\n    if len(pixels) != 2:\n        print(f\"Warning: Expected 2 non-white pixels, found {len(pixels)}\")\n        return None, None\n\n    # Sort by row, then column to ensure consistent order\n    pixels.sort(key=lambda x: x[0])\n    return pixels[0], pixels[1]\n\ndef draw_plus_shape(grid, center_r, center_c, color):\n    \"\"\"\n    Draws a 5x5 plus shape (+) onto the grid centered at (center_r, center_c).\n\n    Args:\n        grid (np.array): The grid to draw on (mutable).\n        center_r (int): The row index of the center of the shape.\n        center_c (int): The column index of the center of the shape.\n        color (int): The color to use for drawing the shape.\n    \"\"\"\n    rows, cols = grid.shape\n    # Relative coordinates for the 9 pixels forming the 5x5 plus shape\n    # Center (0,0)\n    # Horizontal arm: (0,-1), (0,-2), (0,1), (0,2)\n    # Vertical arm: (-1,0), (-2,0), (1,0), (2,0)\n    shape_coords_relative = [\n        (0, 0), (0, 1), (0, -1), (0, 2), (0, -2),\n        (1, 0), (-1, 0), (2, 0), (-2, 0)\n    ]\n    for dr, dc in shape_coords_relative:\n        r, c = center_r + dr, center_c + dc\n        # Check grid boundaries before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Initialize output grid with background color (white, 0)\n    output_grid = np.zeros_like(input_np)\n\n    # Find the two non-white pixels and their colors, sorted by position\n    pixel1, pixel2 = find_non_white_pixels(input_np)\n\n    # If exactly two pixels weren't found, return the empty grid\n    if pixel1 is None or pixel2 is None:\n       return output_grid.tolist()\n\n    (r1, c1), color1 = pixel1\n    (r2, c2), color2 = pixel2\n\n    center1_r, center1_c = -1, -1 # Center for shape derived from pixel1\n    center2_r, center2_c = -1, -1 # Center for shape derived from pixel2\n\n    # Determine orientation and calculate the two center points\n    if r1 == r2:  # Horizontal alignment\n        mid_c = (c1 + c2) / 2.0 # Use float division\n        center1_r = r1\n        center2_r = r1\n        # Pixel1 (sorted first) maps to floor, Pixel2 maps to ceil\n        center1_c = math.floor(mid_c)\n        center2_c = math.ceil(mid_c)\n    elif c1 == c2:  # Vertical alignment\n        mid_r = (r1 + r2) / 2.0 # Use float division\n        center1_c = c1\n        center2_c = c1\n        # Pixel1 (sorted first) maps to floor, Pixel2 maps to ceil\n        center1_r = math.floor(mid_r)\n        center2_r = math.ceil(mid_r)\n    else:\n        # This case is not expected based on the training examples\n        print(\"Error: Input pixels are not aligned horizontally or vertically.\")\n        return output_grid.tolist() # Return empty grid\n\n    # Draw the first plus shape using color1 centered at (center1_r, center1_c)\n    draw_plus_shape(output_grid, center1_r, center1_c, color1)\n\n    # Draw the second plus shape using color2 centered at (center2_r, center2_c)\n    draw_plus_shape(output_grid, center2_r, center2_c, color2)\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4654,
    "candidates_token_count": 1646,
    "total_token_count": 6300,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.377923,
  "retries": null
}