{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms a grid containing exactly two non-white pixels (aligned horizontally or vertically) into a grid with two 13-pixel diamond shapes.\n\nThe transformation rule is as follows:\n1. Initialize an output grid of the same dimensions as the input grid, filled with white (0).\n2. Locate the two non-white pixels in the input grid. Sort them by row, then column, to get P1 = ((r1, c1), color1) and P2 = ((r2, c2), color2).\n3. Determine the alignment (horizontal if r1 == r2, vertical if c1 == c2).\n4. Calculate the distance between the points along the axis of alignment (dist = c2 - c1 or dist = r2 - r1).\n5. Calculate the inward movement amount: move = (dist - 3) // 2.\n6. Calculate the center coordinate (center1_r, center1_c) for the first shape (color1):\n    - Horizontal: center1_r = r1, center1_c = c1 + move\n    - Vertical: center1_r = r1 + move, center1_c = c1\n7. Calculate the center coordinate (center2_r, center2_c) for the second shape (color2):\n    - Horizontal: center2_r = r2, center2_c = c2 - move\n    - Vertical: center2_r = r2 - move, center2_c = c2\n8. Define the 13-pixel \"diamond\" shape using relative coordinates from a center point (cr, cc): [(-2,0), (-1,-1),(-1,0),(-1,1), (0,-2),(0,-1),(0,0),(0,1),(0,2), (1,-1),(1,0),(1,1), (2,0)].\n9. Draw the first diamond shape on the output grid using color1, centered at (center1_r, center1_c).\n10. Draw the second diamond shape on the output grid using color2, centered at (center2_r, center2_c). Handle boundary clipping.\n11. Return the modified output grid.\n\"\"\"\n\n# Helper function to find the two non-white pixels\ndef find_non_white_pixels(grid):\n    \"\"\"\n    Finds the coordinates and colors of the two non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing two elements, each a tuple of ((row, col), color).\n               Returns (None, None) if exactly two non-white pixels are not found.\n               The pixels are sorted by row index, then column index.\n    \"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append(((r, c), grid[r, c]))\n\n    if len(pixels) != 2:\n        # This shouldn't happen based on task description but good practice to check\n        print(f\"Warning: Expected 2 non-white pixels, found {len(pixels)}\")\n        return None, None\n\n    # Sort by row, then column to ensure consistent order P1, P2\n    pixels.sort(key=lambda x: x[0])\n    return pixels[0], pixels[1]\n\n# Helper function to draw a 13-pixel diamond shape\ndef draw_diamond_shape(grid, center_r, center_c, color):\n    \"\"\"\n    Draws a 13-pixel diamond shape onto the grid centered at (center_r, center_c).\n    The shape is a 5x5 square minus the four corner pixels.\n\n    Args:\n        grid (np.array): The grid to draw on (mutable).\n        center_r (int): The row index of the center of the shape.\n        center_c (int): The column index of the center of the shape.\n        color (int): The color to use for drawing the shape.\n    \"\"\"\n    rows, cols = grid.shape\n    # Relative coordinates for the 13 pixels forming the diamond shape\n    shape_coords_relative = [\n        (-2, 0),\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -2), (0, -1), (0, 0), (0, 1), (0, 2),\n        (1, -1), (1, 0), (1, 1),\n        (2, 0)\n    ]\n    for dr, dc in shape_coords_relative:\n        r, c = center_r + dr, center_c + dc\n        # Check grid boundaries before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Step 1: Initialize output grid with background color (white, 0)\n    output_grid = np.zeros_like(input_np)\n\n    # Step 2: Find the two non-white pixels and their colors, sorted by position\n    pixel1, pixel2 = find_non_white_pixels(input_np)\n\n    # If exactly two pixels weren't found, return the empty grid\n    if pixel1 is None or pixel2 is None:\n       return output_grid.tolist()\n\n    # Extract coordinates and colors\n    (r1, c1), color1 = pixel1\n    (r2, c2), color2 = pixel2\n\n    # Initialize center coordinates (defaults not strictly needed but good practice)\n    center1_r, center1_c = -1, -1 # Center for shape derived from pixel1\n    center2_r, center2_c = -1, -1 # Center for shape derived from pixel2\n\n    # Steps 3-7: Determine orientation, calculate distance, movement, and center points\n    if r1 == r2:  # Horizontal alignment (Step 3)\n        dist = c2 - c1 # Step 4\n        move = (dist - 3) // 2 # Step 5 (Corrected formula)\n        center1_r = r1 # Step 6\n        center1_c = c1 + move # Step 6\n        center2_r = r2 # Step 7\n        center2_c = c2 - move # Step 7\n\n    elif c1 == c2:  # Vertical alignment (Step 3)\n        dist = r2 - r1 # Step 4\n        move = (dist - 3) // 2 # Step 5 (Corrected formula)\n        center1_r = r1 + move # Step 6\n        center1_c = c1 # Step 6\n        center2_r = r2 - move # Step 7\n        center2_c = c2 # Step 7\n    else:\n        # This case is not expected based on the training examples\n        print(\"Error: Input pixels are not aligned horizontally or vertically.\")\n        return output_grid.tolist() # Return empty grid if alignment is invalid\n\n    # Step 8 is implicit in draw_diamond_shape definition\n\n    # Step 9: Draw the first diamond shape\n    draw_diamond_shape(output_grid, center1_r, center1_c, color1)\n\n    # Step 10: Draw the second diamond shape\n    draw_diamond_shape(output_grid, center2_r, center2_c, color2)\n\n    # Step 11: Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7764,
    "candidates_token_count": 1793,
    "total_token_count": 9557,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.348499,
  "retries": null
}