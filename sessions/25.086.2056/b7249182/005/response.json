{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid containing exactly two non-white pixels (aligned horizontally or vertically) into an output grid featuring two 5x5 plus-shaped patterns.\n\nThe transformation rule is as follows:\n1. Locate the two non-white pixels in the input grid. Sort them by row, then column, to get P1 = ((r1, c1), color1) and P2 = ((r2, c2), color2).\n2. Determine the alignment (horizontal if r1 == r2, vertical if c1 == c2).\n3. Calculate the distance between the points along the axis of alignment (dist = c2 - c1 or dist = r2 - r1).\n4. Calculate the inward movement amount: move = floor(dist / 4).\n5. Calculate the center coordinate (center1_r, center1_c) for the first shape (color1):\n    - Horizontal: center1_r = r1, center1_c = c1 + move\n    - Vertical: center1_r = r1 + move, center1_c = c1\n6. Calculate the center coordinate (center2_r, center2_c) for the second shape (color2):\n    - Horizontal: center2_r = r2, center2_c = c2 - move\n    - Vertical: center2_r = r2 - move, center2_c = c2\n7. Draw two 5x5 plus shapes (+) on an initially white grid of the same dimensions as the input. Shape 1 uses color1 centered at (center1_r, center1_c), and Shape 2 uses color2 centered at (center2_r, center2_c). The plus shape consists of the center pixel and the pixels at distances 1 and 2 along the horizontal and vertical axes from the center.\n\"\"\"\n\n# Helper function to find the two non-white pixels\ndef find_non_white_pixels(grid):\n    \"\"\"\n    Finds the coordinates and colors of the two non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing two elements, each a tuple of ((row, col), color).\n               Returns (None, None) if exactly two non-white pixels are not found.\n               The pixels are sorted by row index, then column index.\n    \"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append(((r, c), grid[r, c]))\n\n    if len(pixels) != 2:\n        # This shouldn't happen based on task description but good practice to check\n        print(f\"Warning: Expected 2 non-white pixels, found {len(pixels)}\")\n        return None, None\n\n    # Sort by row, then column to ensure consistent order P1, P2\n    pixels.sort(key=lambda x: x[0])\n    return pixels[0], pixels[1]\n\n# Helper function to draw a 5x5 plus shape\ndef draw_plus_shape(grid, center_r, center_c, color):\n    \"\"\"\n    Draws a 5x5 plus shape (+) onto the grid centered at (center_r, center_c).\n    The shape includes the center and points +/- 1 and +/- 2 along rows/cols.\n\n    Args:\n        grid (np.array): The grid to draw on (mutable).\n        center_r (int): The row index of the center of the shape.\n        center_c (int): The column index of the center of the shape.\n        color (int): The color to use for drawing the shape.\n    \"\"\"\n    rows, cols = grid.shape\n    # Relative coordinates for the 9 pixels forming the 5x5 plus shape\n    shape_coords_relative = [\n        (0, 0), (0, 1), (0, -1), (0, 2), (0, -2),\n        (1, 0), (-1, 0), (2, 0), (-2, 0)\n    ]\n    for dr, dc in shape_coords_relative:\n        r, c = center_r + dr, center_c + dc\n        # Check grid boundaries before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Initialize output grid with background color (white, 0)\n    output_grid = np.zeros_like(input_np)\n\n    # Step 1: Find the two non-white pixels and their colors, sorted by position\n    pixel1, pixel2 = find_non_white_pixels(input_np)\n\n    # If exactly two pixels weren't found, return the empty grid\n    if pixel1 is None or pixel2 is None:\n       return output_grid.tolist()\n\n    # Extract coordinates and colors\n    (r1, c1), color1 = pixel1\n    (r2, c2), color2 = pixel2\n\n    # Initialize center coordinates\n    center1_r, center1_c = -1, -1 # Center for shape derived from pixel1\n    center2_r, center2_c = -1, -1 # Center for shape derived from pixel2\n\n    # Steps 2-6: Determine orientation, calculate distance, movement, and center points\n    if r1 == r2:  # Horizontal alignment\n        dist = c2 - c1 # Step 3\n        move = math.floor(dist / 4) # Step 4\n        center1_r = r1 # Step 5\n        center1_c = c1 + move # Step 5\n        center2_r = r2 # Step 6\n        center2_c = c2 - move # Step 6\n\n    elif c1 == c2:  # Vertical alignment\n        dist = r2 - r1 # Step 3\n        move = math.floor(dist / 4) # Step 4\n        center1_r = r1 + move # Step 5\n        center1_c = c1 # Step 5\n        center2_r = r2 - move # Step 6\n        center2_c = c2 # Step 6\n    else:\n        # This case is not expected based on the training examples\n        print(\"Error: Input pixels are not aligned horizontally or vertically.\")\n        return output_grid.tolist() # Return empty grid if alignment is invalid\n\n    # Step 7: Draw the two plus shapes\n    # Draw the first plus shape using color1 centered at the calculated (center1_r, center1_c)\n    draw_plus_shape(output_grid, center1_r, center1_c, color1)\n\n    # Draw the second plus shape using color2 centered at the calculated (center2_r, center2_c)\n    draw_plus_shape(output_grid, center2_r, center2_c, color2)\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5724,
    "candidates_token_count": 1666,
    "total_token_count": 7390,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.586498,
  "retries": null
}