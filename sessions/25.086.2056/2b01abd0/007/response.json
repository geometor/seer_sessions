{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReflects objects across a central blue line (axis), swapping specific color \npairs (Red<->Green, Yellow<->Azure, Gray<->Magenta) only on the reflected \npixels. The original object pixels remain unchanged unless overwritten by a \nreflection.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Find the single blue axis line (color 1), its orientation (horizontal/vertical), \n   and index. If no single axis is found, return the copy.\n3. Define color swap pairs: Red(2)<->Green(3), Yellow(4)<->Azure(8), \n   Gray(5)<->Magenta(6). Other colors map to themselves.\n4. Iterate through each pixel of the *input* grid.\n5. If a pixel is an \"object pixel\" (not background 0, not axis 1):\n   a. Calculate its reflection coordinate across the axis.\n   b. Determine the swapped color based on the defined pairs.\n   c. If the reflection coordinate is within grid bounds, update the *output grid* \n      at that *reflected* coordinate with the *swapped* color.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_blue_axis(grid):\n    \"\"\"\n    Finds the blue line axis (row/col index) and its orientation ('horizontal'/'vertical').\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        tuple: (orientation, index) where orientation is 'horizontal' or 'vertical',\n               and index is the row or column index of the axis. Returns (None, None) \n               if no single blue line axis is found.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check for horizontal line (all elements in a row are 1)\n    horizontal_lines = [r for r in range(rows) if np.all(grid[r, :] == 1)]\n    \n    # Check for vertical line (all elements in a column are 1)\n    vertical_lines = [c for c in range(cols) if np.all(grid[:, c] == 1)]\n\n    # Check validity based on examples: exactly one line, not both\n    is_single_horizontal = len(horizontal_lines) == 1 and len(vertical_lines) == 0\n    is_single_vertical = len(vertical_lines) == 1 and len(horizontal_lines) == 0\n\n    if is_single_horizontal:\n        return 'horizontal', horizontal_lines[0]\n    elif is_single_vertical:\n        return 'vertical', vertical_lines[0]\n    else:\n        # No single line found or both found, inconsistent with examples\n        return None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies reflection across a blue axis and color swap only to reflected pixels.\n    \n    Args:\n        input_grid (np.array): The input grid as a NumPy array.\n        \n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    \n    # 1. Initialize output_grid as a copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Find the blue axis\n    orientation, index = find_blue_axis(input_grid)\n\n    # If no single blue line is found per the examples' pattern, return the original grid copy\n    if orientation is None:\n        # print(\"Warning: No single horizontal or vertical blue axis found.\") # Optional warning\n        return output_grid # Return the unchanged copy\n\n    # 3. Define the color swap map \n    color_swap_map = {\n        2: 3, 3: 2,  # Red <-> Green\n        4: 8, 8: 4,  # Yellow <-> Azure\n        5: 6, 6: 5   # Gray <-> Magenta\n    }\n    # Include identity mapping for colors not in pairs (0, 1, 7, 9)\n    # Although not strictly necessary for the swap logic here, it's good practice\n    for i in range(10):\n        if i not in color_swap_map:\n             color_swap_map[i] = i # Maps color to itself if not in a swap pair\n\n    # 4. Iterate through each pixel of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            original_color = input_grid[r, c]\n            \n            # 5. Check if it's an object pixel (not background 0, not axis 1)\n            if original_color != 0 and original_color != 1:\n                \n                # 5a. Calculate reflected coordinates\n                nr, nc = -1, -1\n                if orientation == 'horizontal':\n                    axis_row_idx = index\n                    nr = axis_row_idx + (axis_row_idx - r)\n                    nc = c\n                elif orientation == 'vertical':\n                    axis_col_idx = index\n                    nr = r\n                    nc = axis_col_idx + (axis_col_idx - c)\n\n                # 5b. Determine the swapped color based on the original color\n                swapped_color = color_swap_map.get(original_color, original_color) # Use .get for safety\n\n                # 5c. Check if the reflection coordinate is within grid bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Update the output grid *only* at the reflected coordinate \n                    # with the *swapped* color.\n                    output_grid[nr, nc] = swapped_color\n                # Else: Reflection is outside the grid, do nothing. The original pixel\n                # remains in the output_grid from the initial copy unless overwritten\n                # by *another* pixel's valid reflection.\n\n    # 6. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10862,
    "candidates_token_count": 1364,
    "total_token_count": 12226,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 13.217507,
  "retries": null
}