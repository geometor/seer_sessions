{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReflects objects across a central blue line (axis), swaps specific color pairs, \nand then either removes the original objects (if the axis is horizontal) or \nswaps the colors of the original objects in place (if the axis is vertical).\n\n1. Initialize the output grid as a copy of the input grid.\n2. Find the single blue axis line (color 1), its orientation (horizontal/vertical), and index.\n3. Define color swap pairs: Red(2)<->Green(3), Yellow(4)<->Azure(8), Gray(5)<->Magenta(6).\n4. Identify and store the coordinates and original colors of all non-background (0), non-axis (1) pixels.\n5. Iterate through the identified original object pixels:\n   a. Calculate the reflection coordinate across the axis.\n   b. Determine the swapped color based on the defined pairs.\n   c. If the reflection coordinate is within grid bounds, update the output grid at that coordinate with the swapped color.\n6. Check the axis orientation:\n   a. If horizontal: Iterate through the stored original object pixel coordinates and set the corresponding locations in the output grid to the background color (0).\n   b. If vertical: Iterate through the stored original object pixels. For each, determine its swapped color and update the output grid at the *original* coordinate with this swapped color.\n7. Return the modified output grid.\n\"\"\"\n\ndef find_blue_axis(grid):\n    \"\"\"\n    Finds the blue line axis (row/col index) and its orientation ('horizontal'/'vertical').\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        tuple: (orientation, index) where orientation is 'horizontal' or 'vertical',\n               and index is the row or column index of the axis. Returns (None, None) \n               if no single blue line axis is found.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check for horizontal line (all elements in a row are 1)\n    horizontal_lines = [r for r in range(rows) if np.all(grid[r, :] == 1)]\n    \n    # Check for vertical line (all elements in a column are 1)\n    vertical_lines = [c for c in range(cols) if np.all(grid[:, c] == 1)]\n\n    # Check validity based on examples: exactly one line, not both\n    is_single_horizontal = len(horizontal_lines) == 1 and len(vertical_lines) == 0\n    is_single_vertical = len(vertical_lines) == 1 and len(horizontal_lines) == 0\n\n    if is_single_horizontal:\n        return 'horizontal', horizontal_lines[0]\n    elif is_single_vertical:\n        return 'vertical', vertical_lines[0]\n    else:\n        # No single line found or both found, inconsistent with examples\n        return None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection, color swap, and conditional original object handling.\n    \n    Args:\n        input_grid (np.array): The input grid as a NumPy array.\n        \n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    \n    # 1. Initialize output_grid as a copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Find the blue axis\n    orientation, index = find_blue_axis(input_grid)\n\n    # If no single blue line is found per the examples' pattern, return the original grid copy\n    if orientation is None:\n        # print(\"Warning: No single horizontal or vertical blue axis found.\")\n        return output_grid\n\n    # 3. Define the color swap map \n    color_swap_map = {\n        2: 3, 3: 2,  # Red <-> Green\n        4: 8, 8: 4,  # Yellow <-> Azure\n        5: 6, 6: 5   # Gray <-> Magenta\n    }\n    # Include identity mapping for colors not in pairs (or default behavior)\n    for i in range(10):\n        if i not in color_swap_map:\n             color_swap_map[i] = i # Maps color to itself if not in a swap pair\n\n    # 4. Identify and store original object pixels (coord + color)\n    original_object_pixels = [] \n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            # Skip background (0) and axis (1) pixels\n            if color != 0 and color != 1:\n                original_object_pixels.append({'r': r, 'c': c, 'color': color})\n\n    # 5. Perform reflection and place swapped colors\n    for pixel_info in original_object_pixels:\n        r, c, color = pixel_info['r'], pixel_info['c'], pixel_info['color']\n        \n        # Calculate reflected coordinates\n        nr, nc = -1, -1\n        if orientation == 'horizontal':\n            axis_row_idx = index\n            nr = axis_row_idx + (axis_row_idx - r)\n            nc = c\n        elif orientation == 'vertical':\n            axis_col_idx = index\n            nr = r\n            nc = axis_col_idx + (axis_col_idx - c)\n\n        # Get swapped color\n        swapped_color = color_swap_map.get(color, color) # Use .get for safety, though map includes all 0-9 now\n\n        # Place the swapped color onto the output grid IF the reflected coordinate is within bounds\n        if 0 <= nr < rows and 0 <= nc < cols:\n            output_grid[nr, nc] = swapped_color\n        # Else: Reflection is outside the grid, do nothing.\n\n    # 6. Handle original pixels based on axis orientation\n    if orientation == 'horizontal':\n        # a. Remove original objects by setting them to background color\n        for pixel_info in original_object_pixels:\n            r, c = pixel_info['r'], pixel_info['c']\n            # Check coordinate validity just in case, though should always be valid\n            if 0 <= r < rows and 0 <= c < cols:\n                 output_grid[r, c] = 0 # Set to background color (white)\n                 \n    elif orientation == 'vertical':\n        # b. Swap colors of the original objects in place\n        for pixel_info in original_object_pixels:\n            r, c, color = pixel_info['r'], pixel_info['c'], pixel_info['color']\n            swapped_color = color_swap_map.get(color, color)\n            # Check coordinate validity just in case\n            if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = swapped_color\n\n    # 7. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7351,
    "candidates_token_count": 1617,
    "total_token_count": 8968,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.4561,
  "retries": null
}