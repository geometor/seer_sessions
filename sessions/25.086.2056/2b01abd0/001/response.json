{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReflects objects across a central blue line, swapping specific color pairs,\nand conditionally removing the original object based on the line's orientation.\n\n1. Identify the blue line (axis) and its orientation (horizontal/vertical).\n2. Define color swap pairs: Red(2)<->Green(3), Yellow(4)<->Azure(8), Gray(5)<->Magenta(6).\n3. Initialize the output grid as a copy of the input.\n4. Iterate through each pixel of the input grid.\n5. If a pixel is part of an object (not background-0 or axis-1):\n   a. Calculate its reflection coordinate across the blue axis.\n   b. Determine the swapped color based on the defined pairs.\n   c. Place the swapped color at the reflected coordinate in the output grid, if within bounds.\n   d. Record the location of this original object pixel.\n6. If the axis is horizontal:\n   a. Determine which side of the axis (above or below) contained the original objects.\n   b. Iterate through the recorded original object pixel locations.\n   c. If an original object pixel was on the identified side, set its location in the output grid to background color (0).\n7. If the axis is vertical, the original objects remain alongside the reflection (no removal step).\n8. Return the modified output grid.\n\"\"\"\n\ndef find_blue_axis(grid):\n    \"\"\"\n    Finds the blue line axis (row/col index) and its orientation ('horizontal'/'vertical').\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        tuple: (orientation, index) where orientation is 'horizontal' or 'vertical',\n               and index is the row or column index of the axis. Returns (None, None) \n               if no single blue line axis is found.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check for horizontal line (all elements in a row are 1)\n    for r in range(rows):\n        if np.all(grid[r, :] == 1):\n            # Verify it's the only horizontal line\n            is_only_line = True\n            for r_check in range(rows):\n                if r_check != r and np.all(grid[r_check, :] == 1):\n                    is_only_line = False\n                    break\n            if is_only_line:\n                 # Also ensure no vertical line exists simultaneously\n                 for c_check in range(cols):\n                     if np.all(grid[:, c_check] == 1):\n                         is_only_line = False\n                         break\n            if is_only_line:\n                return 'horizontal', r\n            else: # Found multiple lines or crossing lines, invalid state based on examples\n                return None, None\n            \n    # Check for vertical line (all elements in a column are 1)\n    for c in range(cols):\n        if np.all(grid[:, c] == 1):\n             # Verify it's the only vertical line (and no horizontal line exists)\n            is_only_line = True\n            for c_check in range(cols):\n                if c_check != c and np.all(grid[:, c_check] == 1):\n                    is_only_line = False\n                    break\n            # No need to re-check for horizontal lines here, would have been caught above\n            if is_only_line:\n                return 'vertical', c\n            else: # Found multiple lines, invalid state based on examples\n                return None, None\n                \n            \n    # Return None if no single blue axis is found\n    return None, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection, color swap, and conditional removal transformation.\n    \n    Args:\n        input_grid (np.array): The input grid as a NumPy array.\n        \n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    \n    # Initialize output_grid as a copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Find the blue axis\n    orientation, index = find_blue_axis(input_grid)\n\n    # If no single blue line is found per the examples' pattern, return the original grid\n    if orientation is None:\n        # This case suggests an input structure different from the training examples\n        print(\"Warning: No single horizontal or vertical blue axis found.\")\n        return output_grid\n\n    # Define the color swap map based on observed pairs\n    color_swap_map = {\n        2: 3, 3: 2,  # Red <-> Green\n        4: 8, 8: 4,  # Yellow <-> Azure\n        5: 6, 6: 5   # Gray <-> Magenta\n    }\n\n    # Store original object pixel coordinates and their rows/columns for potential removal\n    original_object_pixels = [] \n    # Keep track of rows/columns occupied by original objects relative to the axis\n    original_object_rows = set() \n    \n    # --- Step 1: Reflect pixels, Swap colors, and Record original object locations ---\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n\n            # Skip background (0) and axis (1) pixels\n            if color == 0 or color == 1:\n                continue\n                \n            # This pixel is part of an original object. Record its location.\n            original_object_pixels.append((r, c))\n            # Store the row index if relevant for horizontal removal logic\n            if orientation == 'horizontal': \n                 original_object_rows.add(r)\n\n            # Calculate reflected coordinates based on axis orientation and index\n            nr, nc = -1, -1\n            if orientation == 'horizontal':\n                axis_row_idx = index\n                # Reflect vertically across the horizontal line\n                nr = axis_row_idx + (axis_row_idx - r)\n                nc = c\n            elif orientation == 'vertical':\n                axis_col_idx = index\n                # Reflect horizontally across the vertical line\n                nr = r\n                nc = axis_col_idx + (axis_col_idx - c)\n\n            # Get swapped color, default to original color if not in the swap map\n            swapped_color = color_swap_map.get(color, color)\n\n            # Place the swapped color onto the output grid IF the reflected coordinate is within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = swapped_color\n            # Else: The reflection falls outside the grid; it's simply not drawn.\n\n    # --- Step 2: Conditional Removal (Only applies if the axis was horizontal) ---\n    if orientation == 'horizontal':\n        axis_row_idx = index\n        \n        # Determine if the original objects were located primarily above or below the axis.\n        # Based on examples, objects are entirely on one side.\n        rows_above_axis = {r for r in original_object_rows if r < axis_row_idx}\n        rows_below_axis = {r for r in original_object_rows if r > axis_row_idx}\n\n        # Decide which side needs to be cleared based on where the original objects were.\n        clear_above = False\n        clear_below = False\n        # If objects were found above the axis AND none were found below\n        if len(rows_above_axis) > 0 and len(rows_below_axis) == 0:\n            clear_above = True\n        # If objects were found below the axis AND none were found above\n        elif len(rows_below_axis) > 0 and len(rows_above_axis) == 0:\n            clear_below = True\n        # Handle potential edge cases or deviations from examples (e.g., objects on both sides)\n        # For now, strictly following examples where objects are on one side. If ambiguous, do nothing.\n\n        # Iterate through the list of pixels that belonged to the original objects\n        for r, c in original_object_pixels:\n            # If we determined the objects were above, and this pixel is above, clear it.\n            if clear_above and r < axis_row_idx:\n                 output_grid[r, c] = 0 # Set to background color (white)\n            # If we determined the objects were below, and this pixel is below, clear it.\n            elif clear_below and r > axis_row_idx:\n                 output_grid[r, c] = 0 # Set to background color (white)\n\n    # If the orientation was 'vertical', no removal step is performed; the original objects persist.\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3951,
    "candidates_token_count": 1997,
    "total_token_count": 5948,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.128605,
  "retries": null
}