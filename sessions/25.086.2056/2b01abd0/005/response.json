{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nReflects objects across a central blue line (axis), swaps specific color pairs \n(Red<->Green, Yellow<->Azure, Gray<->Magenta) on both the original object \npixels and their reflections.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Find the single blue axis line (color 1), its orientation (horizontal/vertical), and index. If no single axis is found, return the copy.\n3. Define color swap pairs: Red(2)<->Green(3), Yellow(4)<->Azure(8), Gray(5)<->Magenta(6). Other colors map to themselves.\n4. Identify and store the coordinates and original colors of all non-background (0), non-axis (1) pixels (\"object pixels\").\n5. Iterate through the identified original object pixels:\n   a. Determine the swapped color based on the defined pairs.\n   b. Update the output grid at the *original* pixel's coordinate with the swapped color.\n   c. Calculate the reflection coordinate across the axis.\n   d. If the reflection coordinate is within grid bounds, update the output grid at that coordinate with the *same* swapped color.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_blue_axis(grid):\n    \"\"\"\n    Finds the blue line axis (row/col index) and its orientation ('horizontal'/'vertical').\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        tuple: (orientation, index) where orientation is 'horizontal' or 'vertical',\n               and index is the row or column index of the axis. Returns (None, None) \n               if no single blue line axis is found.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check for horizontal line (all elements in a row are 1)\n    horizontal_lines = [r for r in range(rows) if np.all(grid[r, :] == 1)]\n    \n    # Check for vertical line (all elements in a column are 1)\n    vertical_lines = [c for c in range(cols) if np.all(grid[:, c] == 1)]\n\n    # Check validity based on examples: exactly one line, not both\n    is_single_horizontal = len(horizontal_lines) == 1 and len(vertical_lines) == 0\n    is_single_vertical = len(vertical_lines) == 1 and len(horizontal_lines) == 0\n\n    if is_single_horizontal:\n        return 'horizontal', horizontal_lines[0]\n    elif is_single_vertical:\n        return 'vertical', vertical_lines[0]\n    else:\n        # No single line found or both found, inconsistent with examples\n        return None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection and color swap to both original and reflected pixels.\n    \n    Args:\n        input_grid (np.array): The input grid as a NumPy array.\n        \n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    \n    # 1. Initialize output_grid as a copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Find the blue axis\n    orientation, index = find_blue_axis(input_grid)\n\n    # If no single blue line is found per the examples' pattern, return the original grid copy\n    if orientation is None:\n        # print(\"Warning: No single horizontal or vertical blue axis found.\") # Optional warning\n        return output_grid\n\n    # 3. Define the color swap map \n    color_swap_map = {\n        2: 3, 3: 2,  # Red <-> Green\n        4: 8, 8: 4,  # Yellow <-> Azure\n        5: 6, 6: 5   # Gray <-> Magenta\n    }\n    # Include identity mapping for colors not in pairs (0, 1, 7, 9)\n    for i in range(10):\n        if i not in color_swap_map:\n             color_swap_map[i] = i # Maps color to itself if not in a swap pair\n\n    # 4. Identify and store original object pixels (coord + color)\n    original_object_pixels = [] \n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            # Skip background (0) and axis (1) pixels\n            if color != 0 and color != 1:\n                original_object_pixels.append({'r': r, 'c': c, 'color': color})\n\n    # 5. Iterate through object pixels, swap colors, update original and reflected positions\n    for pixel_info in original_object_pixels:\n        r, c, color = pixel_info['r'], pixel_info['c'], pixel_info['color']\n        \n        # 5a. Determine the swapped color\n        swapped_color = color_swap_map.get(color, color) # Use .get for safety\n\n        # 5b. Update the output grid at the original pixel's coordinate\n        # Check coordinate validity just in case, although it should always be valid here\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = swapped_color\n        \n        # 5c. Calculate reflected coordinates\n        nr, nc = -1, -1\n        if orientation == 'horizontal':\n            axis_row_idx = index\n            nr = axis_row_idx + (axis_row_idx - r)\n            nc = c\n        elif orientation == 'vertical':\n            axis_col_idx = index\n            nr = r\n            nc = axis_col_idx + (axis_col_idx - c)\n\n        # 5d. Check if the reflection coordinate is within grid bounds\n        # 5e. If valid, update the output grid at the reflected coordinate\n        if 0 <= nr < rows and 0 <= nc < cols:\n            output_grid[nr, nc] = swapped_color\n        # Else: Reflection is outside the grid, do nothing further for this pixel's reflection.\n\n    # 6. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9425,
    "candidates_token_count": 1445,
    "total_token_count": 10870,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 11.869936,
  "retries": null
}