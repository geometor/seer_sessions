
## train_1

**input:**
```
0 4 0 0 0 0 0 0 4 0
0 0 0 0 0 0 3 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3
0 0 0 5 5 5 5 0 0 0
3 0 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0
0 4 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 6
0 3 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 9 0 0 0 0 0 0 0 4
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 9 0 0
4 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 2
0 0 9 0 0 0 0 0 0 0
2 0 0 0 0 0 0 4 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
8 0 4 0 0 0 3 0 4 0
0 0 0 0 0 0 0 0 0 0
3 0 0 0 5 0 0 8 0 0
0 0 4 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 4
0 8 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 8 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 8 0 0 3 0 0 4 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 6 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
7 0 0 0 0 6 0 0 0 0
0 0 9 0 0 0 0 7 0 0
0 0 0 0 5 0 0 0 0 0
6 0 0 5 5 5 0 6 0 9
0 0 5 5 5 5 5 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 0 5 0 0 0 6 0
9 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 9 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 6 6 6 0 0 0 0
0 0 6 6 6 6 6 0 0 0
0 0 0 6 6 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

## Perception

1.  **Input Grid Structure:** The input grids contain a background of white pixels (0), one larger contiguous object composed of gray pixels (5), and several scattered single pixels of various other colors (1-4, 6-9).
2.  **Output Grid Structure:** The output grids contain only a single object against a white background (0). This object has the exact same shape and position as the gray object in the corresponding input grid.
3.  **Color Transformation:** The color of the object in the output grid is different from gray. It appears to be derived from one of the scattered, non-gray, non-white pixels present in the input grid.
4.  **Identifying the Rule:** The core task seems to be identifying which of the scattered pixels determines the color of the output object, and then replacing the gray object with that color, removing everything else.
5.  **Hypothesis - Proximity:** The color chosen for the output object appears to be the color of the scattered pixel that is *closest* to the gray object.
6.  **Distance Metric:** Manhattan distance (sum of absolute differences in row and column coordinates) seems appropriate for grid-based tasks. The distance should be calculated from the scattered pixel to the *nearest* pixel of the gray object.
7.  **Tie-breaking:** In cases where multiple scattered pixels of different colors are equidistant (minimum distance) from the gray object, the pixel with the higher numerical color value seems to be chosen (as seen in `train_2` where Maroon (9) was chosen over Red (2), both having a minimum Manhattan distance of 2).

## Facts


```yaml
- task_type: object_transformation
- description: Replace a specific object (gray) with a color determined by proximity analysis of other objects.
- objects:
    - type: background
      color: white (0)
      properties: occupies most of the grid.
    - type: target_object
      color: gray (5)
      properties: 
        - contiguous shape (can be horizontal bar, square, vertical bar, rectangle, or more complex).
        - unique instance in the grid.
    - type: color_source_pixels
      color: non-white (1-4, 6-9)
      properties:
        - appear as single, scattered pixels.
        - potentially multiple instances of various colors.
- relationships:
    - spatial_proximity: The key relationship is the Manhattan distance between each `color_source_pixel` and the `target_object`. The distance is the minimum Manhattan distance from the `color_source_pixel` to *any* pixel within the `target_object`.
- actions:
    - identify: Locate the `target_object` (gray pixels).
    - identify: Locate all `color_source_pixels`.
    - calculate_distance: For each `color_source_pixel`, find its minimum Manhattan distance to the `target_object`.
    - find_minimum: Determine the smallest distance calculated.
    - filter: Identify all `color_source_pixels` having this minimum distance.
    - select_color (tie-breaking): From the filtered pixels, choose the color with the highest numerical value. This is the `replacement_color`.
    - transform: Create a new grid of the same size, initially all white.
    - replace: Copy the shape and position of the input `target_object` onto the new grid, using the `replacement_color`.
- output: The transformed grid containing only the recolored object on a white background.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid, filled entirely with the background color (white, 0).
2.  Identify all pixels in the input grid that have the color gray (5). These constitute the `target_object`. Store their coordinates.
3.  Identify all pixels in the input grid that have colors other than gray (5) and white (0). These are the `color_source_pixels`. Store their coordinates and colors.
4.  If no `target_object` or no `color_source_pixels` are found, return the all-white grid.
5.  For each `color_source_pixel`:
    a.  Calculate the Manhattan distance from this pixel to every pixel in the `target_object`.
    b.  Determine the minimum of these distances. This is the `min_distance_to_target` for this `color_source_pixel`.
    c.  Store this minimum distance along with the pixel's color and original coordinates.
6.  Find the overall minimum value among all calculated `min_distance_to_target` values across all `color_source_pixels`. Let this be `overall_min_distance`.
7.  Identify all `color_source_pixels` whose `min_distance_to_target` equals the `overall_min_distance`.
8.  From this set of closest pixels, select the one whose color has the highest numerical value. This color is the `replacement_color`.
9.  Iterate through the coordinates of the `target_object` identified in step 2. For each coordinate, set the corresponding pixel in the output grid to the `replacement_color`.
10. Return the modified output grid.
