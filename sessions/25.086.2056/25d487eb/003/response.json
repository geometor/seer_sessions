{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all contiguous objects of non-background (non-zero) color.\n2. Find the largest object ('container'). Record its color ('C_container').\n3. Find a single-pixel object ('source') with a different color ('C_source') that is cardinally adjacent to the container object. Assume exactly one such source exists. Record its position ('r_src', 'c_src').\n4. Calculate distances from the source pixel along the four cardinal directions. The distance in a direction is the count of consecutive pixels with color 'C_container' starting from the source's neighbor in that direction, stopping when a non-'C_container' pixel or the grid boundary is encountered.\n5. Determine the direction(s) with the minimum distance.\n6. The projection direction is the opposite of the minimum distance direction. (Assuming a single minimum direction based on examples).\n7. Starting from the pixel adjacent to the source in the projection direction, paint pixels with 'C_source' along this direction until the grid boundary is reached, overwriting existing colors.\n8. The modified grid is the output.\n\"\"\"\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to treat as background (default 0).\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains {'color': int, 'coords': set_of_tuples, 'size': int}.\n              Excludes background objects.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                # Skip background color\n                if color == background_color:\n                    visited[r,c] = True\n                    continue\n                \n                # Start BFS for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    # Check cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                            \n                # Store the found object\n                if obj_coords:\n                    objects.append({'color': color, 'coords': obj_coords, 'size': len(obj_coords)})\n                    \n    return objects\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"\n    Get coordinates of cardinal neighbors for a given cell.\n\n    Args:\n        r (int): Row index of the cell.\n        c (int): Column index of the cell.\n        height (int): Grid height.\n        width (int): Grid width.\n\n    Returns:\n        list: A list of (row, col) tuples for valid neighbors.\n    \"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Identify Objects\n    objects = find_objects(grid)\n    if not objects:\n        return output_grid.tolist() # Return copy if no non-background objects\n\n    # 2. Identify Container (largest object)\n    objects.sort(key=lambda x: x['size'], reverse=True)\n    container = objects[0]\n    container_color = container['color']\n\n    # 3. Identify Source (single pixel, different color, adjacent to container)\n    source_pixel = None\n    for obj in objects:\n        # Check if it's a single pixel object and not the container color\n        if obj['size'] == 1 and obj['color'] != container_color:\n            # Get the position of this single pixel\n            r_src, c_src = list(obj['coords'])[0] \n            # Get its neighbors\n            neighbors = get_neighbors(r_src, c_src, height, width)\n            # Check if any neighbor has the container color\n            is_adjacent_to_container = any(grid[nr, nc] == container_color for nr, nc in neighbors)\n            \n            if is_adjacent_to_container:\n                source_pixel = {'color': obj['color'], 'pos': (r_src, c_src)}\n                break # Assume exactly one such source as per analysis\n\n    # If no valid source pixel found according to the rules, return original grid\n    if not source_pixel:\n        return output_grid.tolist() \n\n    source_color = source_pixel['color']\n    source_r, source_c = source_pixel['pos']\n\n    # 4. Calculate Distances (count consecutive container-colored cells from source)\n    distances = {'up': 0, 'down': 0, 'left': 0, 'right': 0}\n    \n    # Calculate UP distance\n    r = source_r - 1\n    while r >= 0 and grid[r, source_c] == container_color:\n        distances['up'] += 1\n        r -= 1\n        \n    # Calculate DOWN distance\n    r = source_r + 1\n    while r < height and grid[r, source_c] == container_color:\n        distances['down'] += 1\n        r += 1\n\n    # Calculate LEFT distance\n    c = source_c - 1\n    while c >= 0 and grid[source_r, c] == container_color:\n        distances['left'] += 1\n        c -= 1\n        \n    # Calculate RIGHT distance\n    c = source_c + 1\n    while c < width and grid[source_r, c] == container_color:\n        distances['right'] += 1\n        c += 1\n\n    # 5. Determine Projection Direction (opposite of minimum distance direction)\n    min_dist = float('inf')\n    min_dir = None\n    # Iterate in a fixed order to handle potential ties deterministically (first found wins)\n    for direction in ['up', 'down', 'left', 'right']:\n        if distances[direction] < min_dist:\n            min_dist = distances[direction]\n            min_dir = direction\n\n    # This case should ideally not be reached if a source was found\n    if min_dir is None: \n         return output_grid.tolist() \n\n    opposite_dirs = {'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left'}\n    projection_dir = opposite_dirs[min_dir]\n\n    # 6. Perform Projection\n    dr, dc = 0, 0\n    if projection_dir == 'up': dr = -1\n    elif projection_dir == 'down': dr = 1\n    elif projection_dir == 'left': dc = -1\n    elif projection_dir == 'right': dc = 1\n\n    # Start projection from the cell *adjacent* to the source in the projection direction\n    curr_r, curr_c = source_r + dr, source_c + dc \n    \n    # Continue projection until the grid boundary is reached\n    while 0 <= curr_r < height and 0 <= curr_c < width:\n        output_grid[curr_r, curr_c] = source_color\n        # Move to the next cell in the projection direction\n        curr_r += dr\n        curr_c += dc\n\n    # 7. Output: Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10951,
    "candidates_token_count": 2027,
    "total_token_count": 12978,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.990789,
  "retries": null
}