{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all contiguous objects of non-background (non-zero) color.\n2. Find the largest object ('container'). Record its color ('C_container') and coordinates.\n3. Find a single-pixel object ('source') with a different color ('C_source') that is cardinally adjacent to the container object. Assume exactly one such source exists. Record its position ('P_source').\n4. For each cardinal direction, calculate the 'distance' from the source P_source. The distance is the count of contiguous pixels having the container color C_container, starting from the neighbor of P_source in that direction and moving outwards, stopping when a pixel with a different color or the grid boundary is reached.\n5. Find the direction(s) with the minimum calculated distance. If there are ties, select the first one in the order: up, down, left, right. This is the 'min_distance_direction'.\n6. Determine the 'projection_direction' which is the cardinal direction opposite to the 'min_distance_direction'.\n7. Find the 'projection_start_point': Starting from P_source, trace a path along the projection_direction through all contiguous pixels belonging to the container. The first pixel encountered along this path *after exiting the container* is the projection_start_point.\n8. Perform Projection: Starting from the projection_start_point, paint pixels with the source color C_source along the projection_direction until the grid boundary is reached, overwriting existing pixels.\n9. The modified grid is the output. If no container or source is found matching the criteria, return the original grid unchanged.\n\"\"\"\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to treat as background (default 0).\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains {'color': int, 'coords': set_of_tuples, 'size': int}.\n              Excludes background objects.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                # Skip background color\n                if color == background_color:\n                    visited[r,c] = True\n                    continue\n\n                # Start BFS for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n\n                # Store the found object\n                if obj_coords:\n                    objects.append({'color': color, 'coords': obj_coords, 'size': len(obj_coords)})\n\n    return objects\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"\n    Get coordinates of cardinal neighbors for a given cell.\n\n    Args:\n        r (int): Row index of the cell.\n        c (int): Column index of the cell.\n        height (int): Grid height.\n        width (int): Grid width.\n\n    Returns:\n        list: A list of (row, col) tuples for valid neighbors.\n    \"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Identify Objects\n    objects = find_objects(grid)\n    if not objects:\n        return output_grid.tolist() # Return copy if no non-background objects\n\n    # 2. Identify Container (largest object)\n    objects.sort(key=lambda x: x['size'], reverse=True)\n    container = objects[0]\n    container_color = container['color']\n    container_coords = container['coords'] # Keep coordinates for efficient checking later\n\n    # 3. Identify Source (single pixel, different color, adjacent to container)\n    source_pixel = None\n    for obj in objects:\n        # Check if it's a single pixel object and not the container color\n        if obj['size'] == 1 and obj['color'] != container_color:\n            # Get the position of this single pixel\n            r_src, c_src = list(obj['coords'])[0]\n            # Get its neighbors\n            neighbors = get_neighbors(r_src, c_src, height, width)\n            # Check if any neighbor is part of the container\n            is_adjacent_to_container = any((nr, nc) in container_coords for nr, nc in neighbors)\n\n            if is_adjacent_to_container:\n                source_pixel = {'color': obj['color'], 'pos': (r_src, c_src)}\n                break # Assume exactly one such source\n\n    # If no valid source pixel found according to the rules, return original grid\n    if not source_pixel:\n        return output_grid.tolist()\n\n    source_color = source_pixel['color']\n    source_r, source_c = source_pixel['pos']\n\n    # 4. Calculate Distances within container\n    distances = {'up': 0, 'down': 0, 'left': 0, 'right': 0}\n    directions_delta = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n\n    for direction, (dr, dc) in directions_delta.items():\n        # Start from the neighbor of the source in the current direction\n        nr, nc = source_r + dr, source_c + dc\n        dist = 0\n        # Count consecutive container cells\n        while 0 <= nr < height and 0 <= nc < width and (nr, nc) in container_coords: # Use container_coords for check\n            dist += 1\n            nr += dr # Move to the next cell in the same direction\n            nc += dc\n        distances[direction] = dist\n\n    # 5. Determine Minimum Distance Direction (with tie-breaking)\n    min_dist = float('inf')\n    min_dir = None\n    # Iterate in a fixed order for deterministic tie-breaking\n    for direction in ['up', 'down', 'left', 'right']:\n        if distances[direction] < min_dist:\n            min_dist = distances[direction]\n            min_dir = direction\n\n    # This case should ideally not be reached if a source was found and adjacent\n    if min_dir is None:\n         return output_grid.tolist()\n\n    # 6. Determine Projection Direction (opposite of min distance direction)\n    opposite_dirs = {'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left'}\n    projection_dir = opposite_dirs[min_dir]\n\n    # 7. Find Projection Start Point\n    proj_dr, proj_dc = directions_delta[projection_dir]\n    # Start tracing from the source's *neighbor* inside the container along the projection direction\n    curr_r, curr_c = source_r + proj_dr, source_c + proj_dc\n\n    # Move through the container along the projection direction\n    while 0 <= curr_r < height and 0 <= curr_c < width and (curr_r, curr_c) in container_coords:\n         curr_r += proj_dr\n         curr_c += proj_dc\n\n    # (curr_r, curr_c) is now the first point *outside* the container along the projection path,\n    # or it's out of bounds if the container touches the edge in that direction.\n    # This is our projection_start_point if it's within bounds.\n    proj_start_r, proj_start_c = curr_r, curr_c\n\n    # 8. Perform Projection\n    # Check if the starting point is within the grid\n    if 0 <= proj_start_r < height and 0 <= proj_start_c < width:\n        # Paint from the start point to the boundary\n        paint_r, paint_c = proj_start_r, proj_start_c\n        while 0 <= paint_r < height and 0 <= paint_c < width:\n            output_grid[paint_r, paint_c] = source_color\n            # Move to the next cell in the projection direction\n            paint_r += proj_dr\n            paint_c += proj_dc\n\n    # 9. Output: Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10730,
    "candidates_token_count": 2275,
    "total_token_count": 13005,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.563163,
  "retries": null
}