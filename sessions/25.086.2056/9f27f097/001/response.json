{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a rectangular block of white pixels (color 0) and another rectangular\nblock of the exact same dimensions containing a pattern (no white pixels).\nCopies the pattern from the second block onto the location of the white block\nin the output grid. The rest of the grid remains unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_solid_rect_block(grid, color):\n    \"\"\"\n    Finds the first occurrence of a solid rectangular block of a given color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the block to find.\n\n    Returns:\n        tuple: (row, col, height, width) of the block, or None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    coords = np.argwhere(grid == color)\n\n    if coords.shape[0] == 0:\n        return None\n\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check if the number of pixels matches the bounding box area\n    if coords.shape[0] != height * width:\n        # This handles cases where the shape isn't rectangular or has holes\n        # A more robust check might be needed for multiple separate blocks\n        # but for this task's examples, this seems sufficient. Let's try\n        # iterating through potential blocks if this fails.\n        pass # Continue to the more rigorous check below\n\n    # Verify that the bounding box area is solidly filled with the target color\n    block = grid[min_r:min_r + height, min_c:min_c + width]\n    if np.all(block == color):\n        return min_r, min_c, height, width\n\n    # Fallback: If the simple bounding box of all color pixels wasn't it,\n    # iterate to find the first actual solid block. This handles cases where\n    # there might be stray pixels of the target color elsewhere.\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                # Found a potential top-left corner\n                # Determine max possible width from this point\n                max_w = 0\n                for w in range(1, cols - c + 1):\n                    if grid[r, c + w - 1] == color:\n                        max_w = w\n                    else:\n                        break\n                if max_w == 0: continue # Should not happen based on initial check\n\n                # Determine max possible height for this width\n                max_h = 0\n                for h in range(1, rows - r + 1):\n                    if np.all(grid[r + h - 1, c:c + max_w] == color):\n                        max_h = h\n                    else:\n                        break\n                if max_h == 0: continue # Should not happen\n\n                # Check if the found block is solid\n                potential_block = grid[r:r + max_h, c:c + max_w]\n                if np.all(potential_block == color):\n                    # Check if this is the *minimal* bounding box for this specific block\n                    # This ensures we don't just find a sub-part of a larger block\n                    actual_coords = np.argwhere(potential_block == color)\n                    if actual_coords.shape[0] == max_h * max_w:\n                         return r, c, max_h, max_w # Found a solid block\n\n    return None # No solid block found\n\n\ndef find_matching_pattern_block(grid, target_height, target_width, white_bbox):\n    \"\"\"\n    Finds a block with target dimensions that does not contain white (0)\n    and is not the white block itself.\n\n    Args:\n        grid (np.array): The input grid.\n        target_height (int): The height of the block to find.\n        target_width (int): The width of the block to find.\n        white_bbox (tuple): The (row, col, height, width) of the white block\n                             to avoid matching the same block.\n\n    Returns:\n        tuple: (row, col, height, width) of the pattern block, or None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    white_r, white_c, _, _ = white_bbox\n\n    for r in range(rows - target_height + 1):\n        for c in range(cols - target_width + 1):\n            # Check if this is the same location as the white block\n            if r == white_r and c == white_c:\n                continue\n\n            # Extract the candidate block\n            candidate_block = grid[r:r + target_height, c:c + target_width]\n\n            # Check if the block contains any white pixels\n            if np.any(candidate_block == 0):\n                continue\n\n            # If we reach here, the block has the right dimensions,\n            # is not the white block, and contains no white pixels.\n            return r, c, target_height, target_width\n\n    return None # No matching pattern block found\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies a white rectangular block and a matching-dimension pattern block.\n    Copies the pattern onto the white block's location.\n    \"\"\"\n    # Convert input to numpy array\n    input_array = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_array)\n\n    # 1. Find the white block\n    white_bbox = find_solid_rect_block(output_grid, 0) # Use output_grid to search\n\n    if white_bbox is None:\n        # Handle error: No white block found (or not solid rectangle)\n        # Based on examples, assume one always exists and is solid.\n        # If the task allows no white block, return input copy.\n        print(\"Warning: No solid white block found.\")\n        return output_grid.tolist() # Return copy in this case\n\n    white_r, white_c, white_h, white_w = white_bbox\n    # print(f\"Found white block at ({white_r}, {white_c}), size {white_h}x{white_w}\")\n\n    # 2. Find the pattern block with matching dimensions\n    pattern_bbox = find_matching_pattern_block(input_array, white_h, white_w, white_bbox)\n\n    if pattern_bbox is None:\n        # Handle error: No matching pattern block found.\n        # Based on examples, assume one always exists.\n        # If the task allows no pattern block, return input copy.\n         print(\"Warning: No matching pattern block found.\")\n         return output_grid.tolist() # Return copy in this case\n\n    pattern_r, pattern_c, pattern_h, pattern_w = pattern_bbox\n    # print(f\"Found pattern block at ({pattern_r}, {pattern_c}), size {pattern_h}x{pattern_w}\")\n\n    # 3. Extract the pattern from the input grid\n    pattern_data = input_array[pattern_r : pattern_r + pattern_h,\n                               pattern_c : pattern_c + pattern_w]\n\n    # 4. Copy (paste) the pattern onto the white block's location in the output grid\n    output_grid[white_r : white_r + white_h,\n                white_c : white_c + white_w] = pattern_data\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3802,
    "candidates_token_count": 1785,
    "total_token_count": 5587,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.643688,
  "retries": null
}