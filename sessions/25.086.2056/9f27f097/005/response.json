{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nOverwrites a specific white rectangular area with a pattern found elsewhere\nin the grid. The white block serves as the target area. The pattern block\n(source) is identified by having the exact same dimensions as the white block,\ncontaining no white pixels, and being surrounded by the same single, non-white\nbackground color that surrounds the white block.\n\"\"\"\n\nimport numpy as np\n\ndef find_solid_rect_block(grid, color):\n    \"\"\"\n    Finds the bounding box of a single solid rectangular block of a given color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the block to find.\n\n    Returns:\n        tuple: (row, col, height, width) of the block, or None if not found\n               or if the pixels of the specified color do not form a single\n               solid rectangle.\n    \"\"\"\n    rows, cols = grid.shape\n    coords = np.argwhere(grid == color)\n\n    if coords.shape[0] == 0:\n        return None\n\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    if coords.shape[0] != height * width:\n        return None # Not a solid rectangle (L-shape, holes, multiple blocks)\n\n    # Double check the block defined by the bounding box is entirely the target color\n    block = grid[min_r:min_r + height, min_c:min_c + width]\n    if np.all(block == color):\n        return min_r, min_c, height, width\n    else:\n        return None\n\n\ndef get_uniform_border_color(grid, r, c, h, w):\n    \"\"\"\n    Checks the pixels immediately adjacent to the border of a block defined by\n    (r, c, h, w).\n\n    Args:\n        grid (np.array): The input grid.\n        r, c, h, w (int): Bounding box of the block.\n\n    Returns:\n        int: The uniform border color if it exists, is single, and is not white (0).\n        None: Otherwise (mixed border, white border, block touches edge inconsistently).\n    \"\"\"\n    rows, cols = grid.shape\n    border_pixels = []\n\n    # Top border (if r > 0)\n    if r > 0:\n        border_pixels.extend(grid[r - 1, c:c + w])\n    # Bottom border (if r + h < rows)\n    if r + h < rows:\n        border_pixels.extend(grid[r + h, c:c + w])\n    # Left border (if c > 0)\n    if c > 0:\n        border_pixels.extend(grid[r:r + h, c - 1])\n    # Right border (if c + w < cols)\n    if c + w < cols:\n        border_pixels.extend(grid[r:r + h, c + w])\n\n    # Add corners if they exist and haven't been implicitly added by sides\n    # Top-left\n    if r > 0 and c > 0:\n        border_pixels.append(grid[r - 1, c - 1])\n    # Top-right\n    if r > 0 and c + w < cols:\n        border_pixels.append(grid[r - 1, c + w])\n    # Bottom-left\n    if r + h < rows and c > 0:\n        border_pixels.append(grid[r + h, c - 1])\n    # Bottom-right\n    if r + h < rows and c + w < cols:\n        border_pixels.append(grid[r + h, c + w])\n\n    if not border_pixels:\n        # Block might occupy the entire grid or be ill-defined\n        return None\n\n    first_pixel_color = border_pixels[0]\n\n    # Check if the border color is white\n    if first_pixel_color == 0:\n        return None\n\n    # Check if all border pixels have the same color\n    if all(p == first_pixel_color for p in border_pixels):\n        return first_pixel_color\n    else:\n        # Border is not uniform\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding a white block and a pattern block\n    with matching dimensions and border color, then copying the pattern onto\n    the white block's location.\n    \"\"\"\n    # Convert input list of lists to a numpy array\n    input_array = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1. Find the unique solid white rectangular block (target)\n    white_bbox = find_solid_rect_block(input_array, 0)\n    if white_bbox is None:\n        # print(\"Warning: No solid white block found.\")\n        return input_grid # Return original if no white block\n\n    wr, wc, h, w = white_bbox\n    # print(f\"Found white block at ({wr}, {wc}), size {h}x{w}\")\n\n    # 2. Determine the uniform border color around the white block\n    border_color = get_uniform_border_color(input_array, wr, wc, h, w)\n    if border_color is None:\n        # print(f\"Warning: Could not determine a valid uniform non-white border color around the white block.\")\n        return input_grid # Return original if border condition not met\n\n    # print(f\"Determined border color: {border_color}\")\n\n    # 3. Find the pattern block (source)\n    pattern_bbox = None\n    for pr in range(rows - h + 1):\n        for pc in range(cols - w + 1):\n            # a. Skip the white block's location\n            if pr == wr and pc == wc:\n                continue\n\n            # Define the candidate block\n            candidate_block = input_array[pr:pr + h, pc:pc + w]\n\n            # b. Check if it contains any white pixels\n            if np.any(candidate_block == 0):\n                continue\n\n            # c. Check if it's surrounded by the determined border_color\n            candidate_border_color = get_uniform_border_color(input_array, pr, pc, h, w)\n\n            if candidate_border_color == border_color:\n                # Found the pattern block (assuming uniqueness as per hypothesis)\n                pattern_bbox = (pr, pc, h, w)\n                # print(f\"Found pattern block at ({pr}, {pc}) matching border color {border_color}\")\n                break # Stop searching once found\n        if pattern_bbox:\n            break # Stop outer loop as well\n\n    # 4. If a pattern block was found, perform the copy\n    if pattern_bbox:\n        pr, pc, _, _ = pattern_bbox\n        # Extract the pattern data\n        pattern_data = input_array[pr:pr + h, pc:pc + w]\n        # Paste the pattern onto the output grid at the white block's location\n        output_grid[wr:wr + h, wc:wc + w] = pattern_data\n    else:\n        # print(\"Warning: No matching pattern block found.\")\n        # If no pattern block found, return the original grid (as per fallback)\n        return input_grid\n\n    # 5. Convert the result back to list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9938,
    "candidates_token_count": 1791,
    "total_token_count": 11729,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.114651,
  "retries": null
}