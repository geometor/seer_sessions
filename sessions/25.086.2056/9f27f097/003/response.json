{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a solid white rectangular block (color 0) and another solid\nrectangular block of the exact same dimensions containing no white pixels.\nCopies the pattern from the second block onto the location of the white\nblock in the output grid. The rest of the grid remains unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_solid_rect_block(grid, color):\n    \"\"\"\n    Finds the bounding box of a single solid rectangular block of a given color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the block to find.\n\n    Returns:\n        tuple: (row, col, height, width) of the block, or None if not found\n               or if the pixels of the specified color do not form a single\n               solid rectangle.\n    \"\"\"\n    rows, cols = grid.shape\n    # Find all coordinates where the grid matches the specified color\n    coords = np.argwhere(grid == color)\n\n    if coords.shape[0] == 0:\n        # No pixels of the target color found\n        return None\n\n    # Determine the bounding box of these pixels\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check 1: Does the number of found pixels match the bounding box area?\n    # This verifies that the shape is rectangular and has no holes.\n    if coords.shape[0] != height * width:\n        # If not, it's not a single solid rectangle (e.g., L-shape, hollow, multiple blocks)\n        return None\n\n    # Check 2: Is the block defined by the bounding box entirely the target color?\n    # This confirms that the bounding box doesn't encompass other colors, which can\n    # happen if the np.argwhere coordinates were misleading (though check 1 makes this less likely).\n    block = grid[min_r:min_r + height, min_c:min_c + width]\n    if np.all(block == color):\n        # If all checks pass, return the location and dimensions\n        return min_r, min_c, height, width\n    else:\n        # If the block within the bounding box isn't solid color, something is wrong.\n        return None\n\n\ndef find_matching_pattern_block(grid, target_height, target_width, white_bbox):\n    \"\"\"\n    Finds a solid block with target dimensions that does not contain white (0)\n    and is not the white block itself. Assumes the pattern block is also solid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_height (int): The height of the block to find.\n        target_width (int): The width of the block to find.\n        white_bbox (tuple): The (row, col, height, width) of the white block\n                             to avoid matching the same block location.\n\n    Returns:\n        tuple: (row, col, height, width) of the pattern block, or None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    white_r, white_c, _, _ = white_bbox # Unpack to check against white block location\n\n    # Iterate through all possible top-left corners for a block of the target size\n    for r in range(rows - target_height + 1):\n        for c in range(cols - target_width + 1):\n            # Check if this candidate block is at the same location as the white block\n            if r == white_r and c == white_c:\n                 continue # Skip the white block location\n\n            # Extract the candidate block region\n            candidate_block = grid[r:r + target_height, c:c + target_width]\n\n            # Check if the candidate block contains any white pixels (color 0)\n            if np.any(candidate_block == 0):\n                continue # Skip if it contains white\n\n            # If we reach here, the block has the right dimensions,\n            # is not at the white block's location, and contains no white pixels.\n            # We assume based on the problem description that this is the pattern block.\n            return r, c, target_height, target_width # Return its location and dimensions\n\n    return None # No matching pattern block found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding a white rectangular block and a\n    pattern block of the same dimensions (without white pixels), then copying\n    the pattern onto the location of the white block.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    # Create a copy of the input array to modify, preserving the original\n    output_grid = np.copy(input_array)\n\n    # 1. Find the solid white rectangular block (color 0) in the input grid\n    white_bbox = find_solid_rect_block(input_array, 0)\n\n    # Handle case where no suitable white block is found\n    if white_bbox is None:\n        # Based on ARC task structure, examples usually guarantee requirements are met.\n        # If not found, it might indicate a misunderstanding of the task.\n        # Returning the original grid is a safe fallback.\n        # print(\"Warning: No solid white block found.\")\n        return input_grid # Return original list of lists\n\n    # Extract dimensions and location of the white block\n    white_r, white_c, white_h, white_w = white_bbox\n    # print(f\"Found white block at ({white_r}, {white_c}), size {white_h}x{white_w}\")\n\n    # 2. Find the corresponding pattern block in the input grid:\n    #    - Same dimensions as the white block (white_h, white_w)\n    #    - Does not contain any white pixels (color 0)\n    #    - Is not the white block itself (using white_bbox for comparison)\n    pattern_bbox = find_matching_pattern_block(input_array, white_h, white_w, white_bbox)\n\n    # Handle case where no suitable pattern block is found\n    if pattern_bbox is None:\n        # print(\"Warning: No matching pattern block found.\")\n        return input_grid # Return original list of lists\n\n    # Extract location and dimensions (h/w should match white block)\n    pattern_r, pattern_c, pattern_h, pattern_w = pattern_bbox\n    # print(f\"Found pattern block at ({pattern_r}, {pattern_c}), size {pattern_h}x{pattern_w}\")\n\n    # 3. Extract the actual pattern data from the input grid using the pattern block's coordinates\n    pattern_data = input_array[pattern_r : pattern_r + pattern_h,\n                               pattern_c : pattern_c + pattern_w]\n\n    # 4. Copy (paste) the extracted pattern data onto the location of the white block\n    #    in the output grid.\n    output_grid[white_r : white_r + white_h,\n                white_c : white_c + white_w] = pattern_data\n\n    # Convert the modified numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5671,
    "candidates_token_count": 1692,
    "total_token_count": 7363,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 113.148801,
  "retries": null
}