{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two main non-white colors: C1 forming a large contiguous shape, and C2 forming crosshair-like lines.\nRemoves C2 pixels that are located within the bounding box of the C1 shape.\nCalculates a shift based on the width of the C1 shape's bounding box.\nRedraws the C2 pixels as a new vertical line shifted right and a new horizontal line shifted up, positioned outside the C1 shape's bounding box.\n\"\"\"\n\ndef find_contiguous_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a specific color using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Von Neumann neighbors\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_pixels.add((nr, nc))\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef find_colors(grid):\n    \"\"\"Identifies the main shape color (C1) and the crosshair color (C2).\"\"\"\n    unique_colors = np.unique(grid)\n    non_white_colors = unique_colors[unique_colors != 0]\n\n    if len(non_white_colors) != 2:\n        # Fallback or error handling if assumption of 2 colors isn't met\n        # For now, assume the task guarantees two non-white colors\n        if len(non_white_colors) == 1:\n             # This case might need specific handling if it occurs\n             # Could be that C1 is the only color, or C2 is.\n             # Based on examples, seems unlikely C2 exists without C1.\n             return non_white_colors[0], -1 # Mark C2 as invalid\n        elif len(non_white_colors) == 0:\n             return -1, -1 # No non-white colors\n        else: # > 2 colors\n             # Need a more robust way, perhaps based on line structure vs blob structure\n             # Let's stick to the largest object heuristic for now\n             pass\n\n\n    max_obj_size = 0\n    c1 = -1\n    c2 = -1\n\n    color_objects = {}\n    for color in non_white_colors:\n        objects = find_contiguous_objects(grid, color)\n        color_objects[color] = objects\n        for obj in objects:\n            if len(obj) > max_obj_size:\n                max_obj_size = len(obj)\n                c1 = color\n\n    if c1 == -1: # Should not happen if there are non-white colors\n        # If no single large object, maybe check total pixels? Less reliable.\n        counts = {color: np.sum(grid == color) for color in non_white_colors}\n        c1 = max(counts, key=counts.get)\n\n\n    # C2 is the other non-white color\n    for color in non_white_colors:\n        if color != c1:\n            c2 = color\n            break\n\n    return c1, c2\n\ndef find_bounding_box(grid, color):\n    \"\"\"Finds the bounding box of all pixels of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if len(rows) == 0:\n        return -1, -1, -1, -1, 0, 0 # Indicate not found\n    min_row, max_row = np.min(rows), np.max(rows)\n    min_col, max_col = np.min(cols), np.max(cols)\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n    return min_row, max_row, min_col, max_col, width, height\n\ndef find_crosshair_center(grid, color):\n    \"\"\"Finds the row and column with the most pixels of the crosshair color.\"\"\"\n    rows, cols = grid.shape\n    max_row_count = -1\n    center_row = -1\n    for r in range(rows):\n        count = np.sum(grid[r, :] == color)\n        if count > max_row_count:\n            max_row_count = count\n            center_row = r\n\n    max_col_count = -1\n    center_col = -1\n    for c in range(cols):\n        count = np.sum(grid[:, c] == color)\n        if count > max_col_count:\n            max_col_count = count\n            center_col = c\n\n    # Handle cases where the color might not be present\n    if center_row == -1: center_row = 0 # Default or error\n    if center_col == -1: center_col = 0 # Default or error\n\n    return center_row, center_col\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules:\n    1. Identify main shape color (C1) and crosshair color (C2).\n    2. Find C1's bounding box and C2's center lines.\n    3. Calculate shift S based on C1's width W (S = W // 2).\n    4. Calculate target row (center_row - S) and target column (center_col + S).\n    5. Create output grid, copy input.\n    6. Remove C2 pixels within C1's bounding box in the output.\n    7. Draw new C2 lines (vertical at target_col, horizontal at target_row) outside C1's bounding box.\n    \"\"\"\n    input_np = np.array(input_grid)\n    rows, cols = input_np.shape\n    output_grid = np.copy(input_np)\n\n    # 1. Identify colors\n    c1, c2 = find_colors(input_np)\n    if c1 == -1 or c2 == -1:\n        print(\"Warning: Could not confidently identify C1 and C2.\")\n        # Attempt a fallback: assume most frequent non-zero is C1, other is C2\n        unique, counts = np.unique(input_np[input_np != 0], return_counts=True)\n        if len(unique) == 2:\n             idx_sorted = np.argsort(counts)\n             c2 = unique[idx_sorted[0]]\n             c1 = unique[idx_sorted[1]]\n        elif len(unique) == 1: # Only one color present, assume it's C1, no C2 action needed\n             c1 = unique[0]\n             c2 = -1 # Signifies no C2 operations\n        else: # Zero or more than 2 colors, cannot proceed reliably\n             return output_grid.tolist() # Return copy of input or empty grid?\n\n    if c2 == -1: # If no second color was identified, return the grid as is.\n        return output_grid.tolist()\n\n    # 2. Find C1 bounding box\n    min_row, max_row, min_col, max_col, width, height = find_bounding_box(input_np, c1)\n    if min_row == -1: # C1 not found\n        print(\"Warning: C1 not found.\")\n        return output_grid.tolist() # Return copy of input\n\n    # 3. Find C2 center lines\n    center_row, center_col = find_crosshair_center(input_np, c2)\n\n    # 4. Calculate shift S\n    shift_s = width // 2\n\n    # 5. Calculate target lines\n    target_row = center_row - shift_s\n    target_col = center_col + shift_s\n\n    # Ensure target indices are within grid bounds, though drawing logic handles this too\n    target_row = max(0, min(target_row, rows - 1))\n    target_col = max(0, min(target_col, cols - 1))\n\n    # 6. Remove C2 pixels within C1's bounding box\n    for r in range(min_row, max_row + 1):\n        for c in range(min_col, max_col + 1):\n            # Check bounds explicitly for safety, though range should handle it\n            if 0 <= r < rows and 0 <= c < cols:\n                if output_grid[r, c] == c2:\n                    output_grid[r, c] = 0 # Change to white\n\n    # 7. Draw new C2 lines outside C1's bounding box\n    # Draw vertical line at target_col\n    for r in range(rows):\n        if r < min_row or r > max_row:\n             # Check if target_col is valid before drawing\n             if 0 <= target_col < cols:\n                 output_grid[r, target_col] = c2\n\n    # Draw horizontal line at target_row\n    for c in range(cols):\n        if c < min_col or c > max_col:\n             # Check if target_row is valid before drawing\n             if 0 <= target_row < rows:\n                 output_grid[target_row, c] = c2\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4854,
    "candidates_token_count": 2312,
    "total_token_count": 7166,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.771362,
  "retries": null
}