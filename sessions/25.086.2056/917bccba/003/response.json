{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies two non-white colors: C1 (forming the largest contiguous object) and C2 (forming a crosshair).\nFinds the bounding box of the largest C1 object and the center of the C2 crosshair in the input.\nCalculates a shift 'S' based on half the width of the C1 object's bounding box.\nDetermines a target row (original center row - S) and target column (original center column + S).\nConstructs an output grid containing only the largest C1 object initially.\nDraws a new horizontal line of color C2 at the target row, excluding the horizontal span of the C1 bounding box.\nDraws a new vertical line of color C2 at the target column, excluding the vertical span of the C1 bounding box.\n\"\"\"\n\n# Helper function to find contiguous objects (using only cardinal neighbors)\ndef find_contiguous_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a specific color using BFS (4-connectivity).\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    q = [] # Use list as deque\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q.append((r, c))\n                visited[r, c] = True\n                obj_pixels.add((r, c))\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    # Von Neumann neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_pixels.add((nr, nc))\n                if obj_pixels:\n                    objects.append(obj_pixels)\n                q = [] # Reset queue for next potential object\n    return objects\n\n# Helper function to identify colors and the largest C1 object\ndef find_colors_and_c1_object(grid):\n    \"\"\"Identifies C1 (largest object color), C2 (other color), and the specific C1 object pixels.\"\"\"\n    unique_colors = np.unique(grid)\n    non_white_colors = unique_colors[unique_colors != 0]\n\n    if len(non_white_colors) == 0:\n        return -1, -1, set() # No non-white colors\n    \n    c1 = -1\n    c1_object = set()\n    c2 = -1\n    max_obj_size = -1\n\n    # Find the color with the largest single contiguous object\n    found_objects_for_color = {}\n    for color in non_white_colors:\n        objects = find_contiguous_objects(grid, int(color)) # Ensure color is int\n        if objects:\n            found_objects_for_color[int(color)] = objects\n            largest_obj_for_color = max(objects, key=len)\n            if len(largest_obj_for_color) > max_obj_size:\n                max_obj_size = len(largest_obj_for_color)\n                c1 = int(color)\n                c1_object = largest_obj_for_color\n\n    # Handle cases where no object found or tie-breaking needed (fallback to frequency)\n    if c1 == -1:\n         if len(non_white_colors) > 0:\n             counts = {int(color): np.sum(grid == color) for color in non_white_colors}\n             c1 = max(counts, key=counts.get)\n             # Need to find the largest object for this chosen C1 again\n             objects = find_contiguous_objects(grid, c1)\n             if objects:\n                 c1_object = max(objects, key=len)\n             else: # Should not happen if counts > 0 but safety check\n                 return -1, -1, set()\n         else: # Should already be handled by the initial check\n             return -1, -1, set()\n\n\n    # Assign C2\n    if len(non_white_colors) > 1:\n        for color in non_white_colors:\n            if int(color) != c1:\n                c2 = int(color)\n                break\n    # If only one non-white color, C2 remains -1\n\n    return c1, c2, c1_object\n\n# Helper function to find bounding box from pixels\ndef find_bounding_box_from_pixels(pixels):\n    \"\"\"Finds the bounding box of a given set of pixels.\"\"\"\n    if not pixels:\n        return -1, -1, -1, -1, 0, 0\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n    return min_row, max_row, min_col, max_col, width, height\n\n# Helper function to find the 'center' of the C2 crosshair\ndef find_crosshair_center(grid, color):\n    \"\"\"Finds the row and column with the most pixels of the crosshair color.\"\"\"\n    if color == -1 or np.sum(grid == color) == 0:\n        return -1, -1 # Color not present or invalid\n        \n    rows, cols = grid.shape\n    center_row = -1\n    row_counts = np.sum(grid == color, axis=1)\n    if np.any(row_counts > 0):\n         # Find the index (row) with the maximum count\n         max_row_count = np.max(row_counts)\n         # Find the first row index that has this max count\n         center_row = np.where(row_counts == max_row_count)[0][0]\n\n\n    center_col = -1\n    col_counts = np.sum(grid == color, axis=0)\n    if np.any(col_counts > 0):\n        # Find the index (col) with the maximum count\n        max_col_count = np.max(col_counts)\n        # Find the first col index that has this max count\n        center_col = np.where(col_counts == max_col_count)[0][0]\n\n    # If somehow only horizontal or vertical line exists, one might still be -1\n    # The calling code needs to handle potentially invalid center coords\n\n    return center_row, center_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by keeping the largest object (C1), removing the\n    original crosshair (C2), and drawing a new crosshair shifted based on C1's width.\n    \"\"\"\n    input_np = np.array(input_grid)\n    rows, cols = input_np.shape\n\n    # 1. Identify Colors and Main Shape\n    c1, c2, c1_object_pixels = find_colors_and_c1_object(input_np)\n\n    # If no main shape found, return empty or input? Return empty for now.\n    if c1 == -1 or not c1_object_pixels:\n        return np.zeros_like(input_np).tolist()\n\n    # 2. Analyze Shape C1\n    min_r, max_r, min_c, max_c, width, height = find_bounding_box_from_pixels(c1_object_pixels)\n\n    # 3. Analyze Original Crosshair (Color C2)\n    center_r, center_c = -1, -1\n    if c2 != -1:\n        center_r, center_c = find_crosshair_center(input_np, c2)\n        # If C2 exists but doesn't form a clear crosshair center, drawing logic will skip\n\n    # 4. Calculate Shift and Target Lines\n    shift_s = width // 2\n    target_r = -1\n    target_c = -1\n    can_draw_c2 = (c2 != -1 and center_r != -1 and center_c != -1)\n\n    if can_draw_c2:\n        target_r = center_r - shift_s\n        target_c = center_c + shift_s\n\n    # 5. Construct Output Grid\n    # Start with a white grid\n    output_grid = np.zeros_like(input_np)\n\n    # Copy C1 shape pixels\n    for r, c in c1_object_pixels:\n        if 0 <= r < rows and 0 <= c < cols: # Bounds check (should be inherent)\n             output_grid[r, c] = c1\n\n    # Draw new C2 lines only if C2 and its center were validly found\n    if can_draw_c2:\n        # Draw horizontal line at target_r, outside C1's horizontal span\n        if 0 <= target_r < rows: # Check if target row is valid\n            for c in range(cols):\n                is_inside_c1_horizontal_span = (min_c <= c <= max_c)\n                if not is_inside_c1_horizontal_span:\n                    output_grid[target_r, c] = c2\n\n        # Draw vertical line at target_c, outside C1's vertical span\n        if 0 <= target_c < cols: # Check if target col is valid\n            for r in range(rows):\n                is_inside_c1_vertical_span = (min_r <= r <= max_r)\n                if not is_inside_c1_vertical_span:\n                    output_grid[r, target_c] = c2\n\n    # 6. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11173,
    "candidates_token_count": 2384,
    "total_token_count": 13557,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.177331,
  "retries": null
}