{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify Background Reachability:** Determine the set of all white (0) pixels that are reachable from the border of the grid. Start a traversal (like Flood Fill or BFS) from all white pixels located on the grid's outer edge (top, bottom, left, right rows/columns). Mark all white pixels that can be reached through a path of contiguous (4-way adjacent) white pixels.\n2.  **Define Holes:** Any white pixel that was *not* marked as reachable in step 1 is considered part of a 'hole' or an 'internal' white region.\n3.  **Identify Blue Objects:** Find all distinct contiguous objects composed of blue (1) pixels using 4-way adjacency.\n4.  **Check Adjacency to Holes:** For each distinct blue object identified in step 3:\n    a.  Examine every pixel belonging to the blue object.\n    b.  Check the 4-way adjacent neighbors of each blue pixel.\n    c.  If any neighbor is a white pixel (0) AND this white pixel was identified as part of a 'hole' (i.e., *not* reachable from the border according to step 1), then this blue object qualifies for transformation.\n5.  **Transform Grid:** Create the output grid.\n    a.  Copy the input grid to the output grid.\n    b.  For every blue object that qualified for transformation in step 4, change the color of *all* pixels belonging to that object from blue (1) to red (2) in the output grid.\n    c.  Leave all other pixels (non-blue pixels, and blue pixels belonging to objects that did *not* qualify) unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of lists, where each inner list contains the\n              coordinates (row, col) of pixels belonging to a single object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = []\n                # Start a Breadth-First Search (BFS) from this pixel\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    # Explore 4-way adjacent neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is the same color and unvisited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                # Add the found object (list of pixel coordinates) to our list\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef flood_fill_background(grid, background_color=0):\n    \"\"\"\n    Performs a flood fill from border pixels of the specified background_color\n    to find all reachable background pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to flood fill from the border (default 0).\n\n    Returns:\n        np.array: A boolean mask where True indicates a pixel of background_color\n                  is reachable from the border.\n    \"\"\"\n    height, width = grid.shape\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Seed the queue with all border pixels of the background color first\n    # Top and Bottom rows\n    for c in range(width):\n        if grid[0, c] == background_color and not reachable_mask[0, c]:\n            q.append((0, c))\n            reachable_mask[0, c] = True\n        if grid[height - 1, c] == background_color and not reachable_mask[height - 1, c]:\n             q.append((height - 1, c))\n             reachable_mask[height - 1, c] = True\n    # Left and Right columns (excluding corners already checked)\n    for r in range(1, height - 1):\n        if grid[r, 0] == background_color and not reachable_mask[r, 0]:\n             q.append((r, 0))\n             reachable_mask[r, 0] = True\n        if grid[r, width - 1] == background_color and not reachable_mask[r, width - 1]:\n             q.append((r, width - 1))\n             reachable_mask[r, width - 1] = True\n\n    # Perform BFS from the border pixels\n    while q:\n        r, c = q.popleft()\n        # Explore 4-way neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if neighbor is background_color, and not already marked reachable\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == background_color and not reachable_mask[nr, nc]:\n                reachable_mask[nr, nc] = True\n                q.append((nr, nc))\n\n    return reachable_mask\n\ndef has_adjacent_hole(grid, obj_pixels, background_reachable_mask, hole_color=0):\n    \"\"\"\n    Checks if any pixel in the object is adjacent (4-way) to an unreachable pixel\n    of the specified hole_color.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_pixels (list): List of (row, col) coordinates for the object.\n        background_reachable_mask (np.array): Boolean mask from flood_fill_background.\n        hole_color (int): The color representing holes (default 0).\n\n    Returns:\n        bool: True if the object is adjacent to a hole pixel, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n\n    # Check neighbors for every pixel in the object\n    for r, c in obj_pixels:\n        # Explore 4-way neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is the hole_color AND was NOT reached\n                # by the background flood fill (meaning it's part of a hole)\n                if grid[nr, nc] == hole_color and not background_reachable_mask[nr, nc]:\n                    # Found an adjacent hole pixel\n                    return True\n\n    # No adjacent hole pixels found after checking all object pixels' neighbors\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by changing blue objects (color 1) to red (color 2)\n    if they enclose or are adjacent to any white pixels (color 0) that are not\n    reachable from the grid border via other white pixels.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n\n    # Define colors\n    blue_color = 1\n    red_color = 2\n    white_color = 0 # Color considered for holes\n\n    # Step 1: Find all white pixels reachable from the border\n    # This mask is True for reachable white pixels, False otherwise\n    # Unreachable white pixels (where mask is False) constitute the 'holes'\n    background_reachable_mask = flood_fill_background(input_grid_np, white_color)\n\n    # Step 2: Find all distinct blue objects\n    blue_objects = find_objects(input_grid_np, blue_color)\n\n    # Step 3: Check each blue object for adjacency to holes and update output grid\n    for obj_pixels in blue_objects:\n        # Check if the object is adjacent to any unreachable white pixel (a hole)\n        if has_adjacent_hole(input_grid_np, obj_pixels, background_reachable_mask, white_color):\n            # If it borders a hole, change all its pixels to red in the output grid\n            for r, c in obj_pixels:\n                output_grid[r, c] = red_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16360,
    "candidates_token_count": 2193,
    "total_token_count": 18553,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.298748,
  "retries": null
}