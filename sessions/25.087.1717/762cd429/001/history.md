
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 5 0 0 0 0 0 0 0 0 0 0 0 0
5 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 2 2 2 5 5 5 5
0 0 0 0 0 0 2 2 2 2 5 5 5 5
0 0 2 2 5 5 2 2 2 2 5 5 5 5
2 5 2 2 5 5 2 2 2 2 5 5 5 5
5 3 5 5 3 3 5 5 5 5 3 3 3 3
0 0 5 5 3 3 5 5 5 5 3 3 3 3
0 0 0 0 0 0 5 5 5 5 3 3 3 3
0 0 0 0 0 0 5 5 5 5 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 2 2 2 3 3 3 3
0 0 0 0 0 0 2 2 2 2 3 3 3 3
0 0 2 2 3 3 2 2 2 2 3 3 3 3
2 3 2 2 3 3 2 2 2 2 3 3 3 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 1 1 1 1 1 1 1 1
0 0 0 0 0 0 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 0 0 0 0 1 1 1 1 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 0 0 0 0 1 1 1 1 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
0 0 1 1 2 2 1 1 1 1 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
1 2 1 1 2 2 1 1 1 1 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2
3 4 3 3 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 3 3 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 3 3 3 3 4 4 4 4 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 3 3 3 3 4 4 4 4 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4
```

Okay, let's break down the task based on the examples provided.

## Perception

1.  **Input Structure:** The input grid always contains a single 2x2 block of non-white pixels, typically located near the bottom-left corner, against a white background.
2.  **Output Structure:** The output grid has the same dimensions as the input grid. It retains the original 2x2 block in its original position. Additionally, several new rectangular blocks appear in the output.
3.  **Color Relationship:** The colors of the new blocks in the output are determined solely by the colors present in the original 2x2 input block.
4.  **Positional Relationship:** The new blocks in the output are positioned relative to the original 2x2 input block. Their placement follows specific offset rules.
5.  **Block Generation Rules:** There seem to be multiple "generations" or types of blocks created based on the input 2x2 pattern.
    *   **Generation 1 (Scaled):** A 4x4 block is created by scaling each pixel of the input 2x2 block into a 2x2 area of the same color. This block is placed slightly above and to the right of the original block.
    *   **Generation 2 (Columnar, Size 4):** Two 8x4 blocks are generated. The first uses the colors from the first column of the input 2x2 block (top 4x4 block has the top-left color, bottom 4x4 block has the bottom-left color). The second uses the colors from the second column similarly. These blocks are placed further above and to the right.
    *   **Generation 3 (Columnar, Size 8):** Two 16x8 blocks are generated, again based on the columns of the input 2x2 block (top 8x8 block has the top color, bottom 8x8 block has the bottom color). These are placed even further above and to the right.
6.  **Boundary Condition:** Not all potential blocks appear in every example. It seems a generated block is only drawn if it fits entirely within the bounds of the output grid. Example 3, with a larger grid, shows more generated blocks than Examples 1 and 2.
7.  **Preservation:** The original 2x2 block from the input is always present in the output at its original location.

## Facts (YAML)


```yaml
task_description: Generate multiple colored rectangular blocks based on a 2x2 pattern block found in the input.

elements:
  - object: grid
    type: input
    properties:
      - background_color: white (0)
      - contains:
          - object: pattern_block
            shape: 2x2
            pixels: non-white colors
            count: 1
            location: variable, often near bottom-left

  - object: grid
    type: output
    properties:
      - dimensions: same as input grid
      - background_color: white (0)
      - contains:
          - object: pattern_block (copied from input)
            location: same as in input
          - object: generated_blocks
            count: variable (up to 5 observed types)
            derivation: based on pattern_block colors and location
            placement: relative offsets from pattern_block location
            condition: must fit entirely within grid boundaries

pattern_block_details:
  - notation: [[c1, c2], [c3, c4]] at (r, c) # c1=top-left, c2=top-right, c3=bottom-left, c4=bottom-right

generated_block_definitions:
  - type: scaled_2x2
    size: 4x4
    location: (r-1, c+2)
    pattern: [[c1, c1, c2, c2], [c1, c1, c2, c2], [c3, c3, c4, c4], [c3, c3, c4, c4]]
  - type: column_1_size_4
    size: 8x4 total (two 4x4 sub-blocks)
    location_top: (r-3, c+6)
    location_bottom: (r+1, c+6)
    color_top: c1
    color_bottom: c3
  - type: column_2_size_4
    size: 8x4 total (two 4x4 sub-blocks)
    location_top: (r-3, c+10)
    location_bottom: (r+1, c+10)
    color_top: c2
    color_bottom: c4
  - type: column_1_size_8
    size: 16x8 total (two 8x8 sub-blocks)
    location_top: (r-7, c+14)
    location_bottom: (r+1, c+14)
    color_top: c1
    color_bottom: c3
  - type: column_2_size_8
    size: 16x8 total (two 8x8 sub-blocks)
    location_top: (r-7, c+22)
    location_bottom: (r+1, c+22)
    color_top: c2
    color_bottom: c4

actions:
  - Find the unique 2x2 non-white pattern_block in the input grid. Record its top-left coordinates (r, c) and its colors [[c1, c2], [c3, c4]].
  - Create a new output grid with the same dimensions as the input grid, initialized to white (0).
  - Copy the found 2x2 pattern_block from the input to the output grid at the same location (r, c).
  - Define the five potential generated block types (scaled_2x2, column_1_size_4, etc.) with their respective sizes, relative locations, and color patterns based on c1, c2, c3, c4, r, and c.
  - For each potential generated block (or sub-block for columnar types):
    - Calculate its absolute coordinates and required dimensions.
    - Check if the entire block fits within the output grid boundaries (0 <= row < height, 0 <= col < width).
    - If the block fits, draw it onto the output grid using its specified color(s).
```


## Natural Language Program

1.  Identify the single 2x2 block of connected non-white pixels in the input grid. Note its top-left row `r` and column `c`, and the colors of its pixels: `c1` (top-left), `c2` (top-right), `c3` (bottom-left), `c4` (bottom-right).
2.  Create an output grid of the same height and width as the input grid, filled entirely with the background color white (0).
3.  Copy the original 2x2 block (`[[c1, c2], [c3, c4]]`) onto the output grid at the location `(r, c)`.
4.  Define a list of block generation rules. Each rule specifies the size, top-left starting coordinates (relative to `(r, c)`), and the color or pattern for the block(s) it generates:
    *   **Rule 1 (Scaled):** Generate a 4x4 block starting at `(r-1, c+2)`. Fill it according to the pattern `[[c1, c1, c2, c2], [c1, c1, c2, c2], [c3, c3, c4, c4], [c3, c3, c4, c4]]`.
    *   **Rule 2 (Col 1, Size 4):** Generate a 4x4 block of color `c1` starting at `(r-3, c+6)` and a 4x4 block of color `c3` starting at `(r+1, c+6)`.
    *   **Rule 3 (Col 2, Size 4):** Generate a 4x4 block of color `c2` starting at `(r-3, c+10)` and a 4x4 block of color `c4` starting at `(r+1, c+10)`.
    *   **Rule 4 (Col 1, Size 8):** Generate an 8x8 block of color `c1` starting at `(r-7, c+14)` and an 8x8 block of color `c3` starting at `(r+1, c+14)`.
    *   **Rule 5 (Col 2, Size 8):** Generate an 8x8 block of color `c2` starting at `(r-7, c+22)` and an 8x8 block of color `c4` starting at `(r+1, c+22)`.
5.  Iterate through each defined block (including the sub-blocks in Rules 2-5). For each block:
    *   Calculate its absolute row and column boundaries (top row, bottom row, left col, right col).
    *   Check if `top_row >= 0`, `bottom_row < grid_height`, `left_col >= 0`, and `right_col < grid_width`.
    *   If all boundary conditions are met, draw the block onto the output grid with its specified color or pattern.
6.  The final state of the output grid is the result.
