{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule operates based on the adjacency of specific object types:\n\n1.  **Single Pixel Expansion:** If two single pixels (1x1 objects) of different colors (A and B) are adjacent (sharing an edge or corner), pixel B expands into a 3x3 cross shape of its original color, centered at its original position. Pixel A remains unchanged.\n\n2.  **Adjacent Square Transformation:** If two solid square objects (X and Y) of the *same size* (NxN) but potentially different colors are adjacent along a full edge:\n    a.  A new (3N)x(3N) area is defined, centered where square Y was located.\n    b.  This area is filled with the color of square X.\n    c.  Square Y (its color and NxN size) is placed back into the central NxN block of this area.\n    d.  The NxN block within the (3N)x(3N) area that is in the *opposite* direction from the center compared to X's original position relative to Y (e.g., if X was Above Y, the block Below Y is targeted) is filled with white (0).\n    e.  This new pattern replaces the original area in the output grid, effectively removing X and modifying the area around Y.\n\n3.  **Default Copy:** Any object not participating in one of the above transformations is copied directly from the input to the output.\n\nThe rules are applied prioritizing rule 1, then rule 2. Once an object participates in a transformation, it cannot participate in another. Transformations must respect grid boundaries.\n\"\"\"\n\n# Helper function to find connected components (objects)\ndef find_objects(grid):\n    \"\"\"\n    Identifies distinct contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with its properties:\n              'id': A unique identifier.\n              'color': The color of the object.\n              'pixels': A set of (row, col) tuples representing the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col) for the bounding box.\n              'shape': 'single_pixel', 'square', or 'other'.\n              'size': N if shape is 'square', 1 if 'single_pixel', None otherwise.\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n    obj_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                obj_id_counter += 1\n                color = grid[r, c]\n                pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (8 directions)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Determine shape and size\n                obj_shape = 'other'\n                obj_size = None\n                if len(pixels) == 1:\n                    obj_shape = 'single_pixel'\n                    obj_size = 1\n                else:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    if height == width and len(pixels) == height * width:\n                         # Check if all pixels within bbox are part of the object\n                         is_solid = True\n                         for br in range(min_r, max_r + 1):\n                             for bc in range(min_c, max_c + 1):\n                                 if (br, bc) not in pixels:\n                                     is_solid = False\n                                     break\n                             if not is_solid:\n                                 break\n                         if is_solid:\n                            obj_shape = 'square'\n                            obj_size = height # N\n\n                objects.append({\n                    'id': obj_id_counter,\n                    'color': color,\n                    'pixels': pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'shape': obj_shape,\n                    'size': obj_size\n                })\n    return objects\n\n# Helper function to check adjacency (8 directions)\ndef are_adjacent(obj1, obj2):\n    \"\"\"Checks if two objects are adjacent (sharing edge or corner).\"\"\"\n    for r1, c1 in obj1['pixels']:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r1 + dr, c1 + dc\n                if (nr, nc) in obj2['pixels']:\n                    return True\n    return False\n\n# Helper function to check edge adjacency (4 directions)\ndef have_edge_adjacency(obj1, obj2):\n    \"\"\"Checks if two objects share a full edge (orthogonal adjacency).\"\"\"\n    for r1, c1 in obj1['pixels']:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r1 + dr, c1 + dc\n            if (nr, nc) in obj2['pixels']:\n                return True\n    return False\n\n# Helper function to get relative position for edge-adjacent squares\ndef get_relative_position(ref_obj, other_obj):\n    \"\"\"Determines relative position (Above, Below, Left, Right) of other_obj w.r.t ref_obj.\"\"\"\n    ref_min_r, ref_min_c, _, _ = ref_obj['bbox']\n    other_min_r, other_min_c, _, _ = other_obj['bbox']\n\n    if other_min_r < ref_min_r: return \"Above\"\n    if other_min_r > ref_min_r: return \"Below\"\n    if other_min_c < ref_min_c: return \"Left\"\n    if other_min_c > ref_min_c: return \"Right\"\n    return None # Should not happen for edge-adjacent squares\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on object adjacency.\n\n    Args:\n        input_grid (np.ndarray): The input 2D numpy array.\n\n    Returns:\n        np.ndarray: The transformed 2D numpy array.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    objects = find_objects(input_grid)\n    processed_object_ids = set()\n\n    # --- Rule 1: Single Pixel Expansion ---\n    pixel_pairs_to_process = []\n    object_map = {obj['id']: obj for obj in objects}\n\n    # Find candidate pairs first\n    for i in range(len(objects)):\n        obj_a = objects[i]\n        if obj_a['shape'] != 'single_pixel' or obj_a['id'] in processed_object_ids:\n            continue\n        for j in range(i + 1, len(objects)):\n            obj_b = objects[j]\n            if obj_b['shape'] != 'single_pixel' or obj_b['id'] in processed_object_ids:\n                continue\n\n            if are_adjacent(obj_a, obj_b):\n                # Order doesn't strictly matter here, but let's pick one to expand\n                # The examples suggest *one* of the pair expands. Let's arbitrarily\n                # choose the one with the higher ID to expand for consistency,\n                # although the examples aren't explicit on *which* one expands.\n                # Let's re-examine Example 2: red (2) and azure (8) -> azure expands.\n                # Example 3: green (3) and red (2) -> green expands.\n                # Example 3: azure (8) and red (2) -> no expansion (not single pixels)\n                # It seems the choice might depend on colors or positions, but let's\n                # try expanding the second one found (obj_b).\n                # No, let's follow the observation: object B expands.\n                # In train_2: red=A(2), azure=B(8). Azure expands.\n                # In train_3: green=A(3), red=B(2). Green expands. Hmm, rule isn't simple A/B.\n                # Let's stick to: if two adjacent single pixels found, one expands.\n                # We'll pick B (the second one in the loop) to expand for now.\n                pixel_pairs_to_process.append((obj_a['id'], obj_b['id']))\n\n\n    # Apply transformations for single pixels\n    for id_a, id_b in pixel_pairs_to_process:\n         if id_a not in processed_object_ids and id_b not in processed_object_ids:\n            obj_a = object_map[id_a]\n            obj_b = object_map[id_b]\n\n            # Get the single pixel coordinate for B\n            (r_b, c_b) = next(iter(obj_b['pixels']))\n            color_b = obj_b['color']\n\n            # Draw 3x3 cross of color_b centered at (r_b, c_b)\n            # Center pixel\n            if 0 <= r_b < rows and 0 <= c_b < cols:\n                 output_grid[r_b, c_b] = color_b # Ensure center is correct color\n            # Orthogonal neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r_b + dr, c_b + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    output_grid[nr, nc] = color_b\n\n            # Mark both as processed\n            processed_object_ids.add(id_a)\n            processed_object_ids.add(id_b)\n\n\n    # --- Rule 2: Adjacent Square Transformation ---\n    square_pairs_to_process = []\n    # Find candidate pairs\n    for i in range(len(objects)):\n        obj_x = objects[i]\n        if obj_x['shape'] != 'square' or obj_x['id'] in processed_object_ids:\n            continue\n        for j in range(len(objects)): # Check all others, not just i+1\n            if i == j: continue\n            obj_y = objects[j]\n            if obj_y['shape'] != 'square' or obj_y['id'] in processed_object_ids:\n                continue\n\n            # Check for same size and edge adjacency\n            if obj_x['size'] == obj_y['size'] and have_edge_adjacency(obj_x, obj_y):\n                square_pairs_to_process.append((obj_x['id'], obj_y['id']))\n\n    # Apply transformations for squares\n    for id_x, id_y in square_pairs_to_process:\n        if id_x not in processed_object_ids and id_y not in processed_object_ids:\n            obj_x = object_map[id_x]\n            obj_y = object_map[id_y]\n\n            n = obj_x['size'] # or obj_y['size'], they are the same\n            color_x = obj_x['color']\n            color_y = obj_y['color']\n            min_r_y, min_c_y, max_r_y, max_c_y = obj_y['bbox']\n\n            # Determine center of the 3Nx3N area (relative to Y's top-left)\n            center_r_3n = min_r_y - n\n            center_c_3n = min_c_y - n\n\n            # Fill the 3Nx3N area with color_x\n            for r in range(center_r_3n, center_r_3n + 3 * n):\n                for c in range(center_c_3n, center_c_3n + 3 * n):\n                    if 0 <= r < rows and 0 <= c < cols:\n                        output_grid[r, c] = color_x\n\n            # Place object Y back in the center\n            for r in range(min_r_y, max_r_y + 1):\n                for c in range(min_c_y, max_c_y + 1):\n                     if 0 <= r < rows and 0 <= c < cols: # Should always be true if Y was in grid\n                         output_grid[r, c] = color_y\n\n            # Determine relative position of X to Y\n            relative_pos = get_relative_position(obj_y, obj_x) # Position of X relative to Y\n\n            # Calculate coordinates for the \"opposite\" NxN block to clear\n            clear_r_start, clear_c_start = -1, -1\n            if relative_pos == \"Above\":   clear_r_start, clear_c_start = min_r_y + n, min_c_y # Below\n            elif relative_pos == \"Below\": clear_r_start, clear_c_start = min_r_y - n, min_c_y # Above\n            elif relative_pos == \"Left\":  clear_r_start, clear_c_start = min_r_y, min_c_y + n # Right\n            elif relative_pos == \"Right\": clear_r_start, clear_c_start = min_r_y, min_c_y - n # Left\n\n            # Clear the opposite block\n            if clear_r_start != -1:\n                for r in range(clear_r_start, clear_r_start + n):\n                    for c in range(clear_c_start, clear_c_start + n):\n                        if 0 <= r < rows and 0 <= c < cols:\n                            output_grid[r, c] = 0 # white background\n\n            # Mark both as processed\n            processed_object_ids.add(id_x)\n            processed_object_ids.add(id_y)\n\n\n    # Objects not processed by rule 1 or 2 are implicitly kept\n    # because we started with a copy of the input grid and only modified\n    # the relevant areas for the processed objects.\n    # For Rule 2, object X *is* effectively removed/overwritten by the new pattern.\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6814,
            "end_index": 7149,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6866,
    "candidates_token_count": 3600,
    "total_token_count": 10466,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.529763,
  "retries": null
}