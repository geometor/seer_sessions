{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on a conditional replacement rule operating on a 3x3 partitioned structure.\n\n1.  **Identify Grid Structure:**\n    *   Determine the background color (assumed to be 0).\n    *   Find the most frequent non-background color; this is the `separator_color`.\n    *   Locate potential horizontal and vertical separator lines. A line is considered a separator if it contains only the `separator_color` and potentially the `background_color`, and the `separator_color` is present.\n    *   Identify the two primary horizontal (`h1`, `h2`) and vertical (`v1`, `v2`) separator lines that define a consistent 3x3 structure where subgrids have height `H = h1` and width `W = v1`, and the second separators are at `h2 = h1 + H + 1` and `v2 = v1 + W + 1`.\n    *   Calculate the boundaries for the 9 subgrids based on these separator indices.\n    *   If a valid 3x3 structure cannot be found, return the input grid unchanged.\n\n2.  **Determine Trigger Color:**\n    *   Extract the central subgrid (1, 1).\n    *   Find all unique colors within the central subgrid, excluding `background_color` and `separator_color`.\n    *   If there is exactly one such unique color, designate it as the `trigger_color` (P).\n    *   If not exactly one, return the input grid unchanged.\n\n3.  **Apply Conditional Replacement:**\n    *   Create a copy of the input grid (`output_grid`).\n    *   Iterate through subgrids `S` at `(r, c)` where `r` is 0 or 1.\n    *   Get the subgrid `SB` below `S` at `(r+1, c)`.\n    *   Check if `trigger_color` P exists in `SB`.\n    *   If yes, replace the content of `S` in `output_grid` with the content of `SB` from the input grid.\n    *   If no, `S` in `output_grid` remains unchanged.\n\n4.  **Return Result:** Return the potentially modified `output_grid`.\n\"\"\"\n\ndef _find_separator_lines(grid, axis, separator_color, background_color):\n    \"\"\"Finds indices of lines along a given axis that qualify as separators.\"\"\"\n    lines = []\n    size = grid.shape[axis]\n    for i in range(size):\n        if axis == 0:  # Horizontal line (check row i)\n            line_data = grid[i, :]\n        else:  # Vertical line (check col i)\n            line_data = grid[:, i]\n\n        # A line is a separator if it only contains separator and background colors,\n        # and the separator color must be present.\n        is_separator_line = (\n            np.all((line_data == separator_color) | (line_data == background_color)) and\n            np.any(line_data == separator_color)\n        )\n        if is_separator_line:\n            lines.append(i)\n    return lines\n\ndef _find_grid_structure(grid):\n    \"\"\"\n    Identifies the separator color, subgrid dimensions, and boundaries.\n    Handles imperfect separator lines and padding around the structure.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (separator_color, subgrid_h, subgrid_w, boundaries)\n               boundaries is a 3x3 list of tuples (r_start, r_end, c_start, c_end).\n               Returns (None, -1, -1, None) if structure is not found or invalid.\n    \"\"\"\n    rows, cols = grid.shape\n    background_color = 0\n\n    # Find potential separator color (most frequent non-background)\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = sorted(zip(counts, unique_colors), reverse=True)\n\n    separator_color = -1\n    for count, color in color_counts:\n        if color != background_color:\n            separator_color = color\n            break\n\n    if separator_color == -1:\n        # print(\"Debug: No non-background color found.\")\n        return None, -1, -1, None # Grid is all background or error\n\n    # Find all potential horizontal and vertical separator lines\n    h_lines = _find_separator_lines(grid, 0, separator_color, background_color)\n    v_lines = _find_separator_lines(grid, 1, separator_color, background_color)\n\n    if len(h_lines) < 2 or len(v_lines) < 2:\n        # print(f\"Debug: Not enough separators found. H:{h_lines}, V:{v_lines}\")\n        return None, -1, -1, None # Need at least 2 lines for a 3x3 grid\n\n    # Find the pair of horizontal lines that define a consistent structure\n    found_h = False\n    h1, h2, subgrid_h = -1, -1, -1\n    for i in range(len(h_lines)):\n        for j in range(i + 1, len(h_lines)):\n            h1_try, h2_try = h_lines[i], h_lines[j]\n            H_try = h1_try # Height of first block (0 to h1_try-1)\n            if H_try < 0: continue # Height must be non-negative (can be 0)\n\n            if h2_try == h1_try + H_try + 1: # Check spacing for second line\n                # Check if structure fits vertically or a third line confirms\n                h3_expected = h2_try + H_try + 1\n                if h3_expected == rows or h3_expected in h_lines:\n                    h1, h2, subgrid_h = h1_try, h2_try, H_try\n                    found_h = True\n                    break\n        if found_h: break\n\n    if not found_h:\n        # print(\"Debug: No consistent horizontal structure found.\")\n        return None, -1, -1, None\n\n    # Find the pair of vertical lines that define a consistent structure\n    found_v = False\n    v1, v2, subgrid_w = -1, -1, -1\n    for i in range(len(v_lines)):\n        for j in range(i + 1, len(v_lines)):\n            v1_try, v2_try = v_lines[i], v_lines[j]\n            W_try = v1_try # Width of first block (0 to v1_try-1)\n            if W_try < 0: continue\n\n            if v2_try == v1_try + W_try + 1: # Check spacing for second line\n                 # Check if structure fits horizontally or a third line confirms\n                v3_expected = v2_try + W_try + 1\n                if v3_expected == cols or v3_expected in v_lines:\n                    v1, v2, subgrid_w = v1_try, v2_try, W_try\n                    found_v = True\n                    break\n        if found_v: break\n\n    if not found_v:\n        # print(\"Debug: No consistent vertical structure found.\")\n        return None, -1, -1, None\n\n    # Structure found, calculate boundaries (top-left inclusive, bottom-right exclusive)\n    boundaries = [[(0, 0, 0, 0) for _ in range(3)] for _ in range(3)]\n    row_starts = [0, h1 + 1, h2 + 1]\n    col_starts = [0, v1 + 1, v2 + 1]\n    # Calculate end rows/cols based on determined H and W\n    row_ends = [h1, h2, h2 + 1 + subgrid_h]\n    col_ends = [v1, v2, v2 + 1 + subgrid_w]\n\n    # Verify calculated boundaries are within the actual grid dimensions\n    if row_ends[2] > rows or col_ends[2] > cols:\n         # print(f\"Debug: Calculated structure exceeds grid dimensions. R_end:{row_ends[2]}(>{rows}), C_end:{col_ends[2]}(>{cols})\")\n         return None, -1, -1, None\n\n    for r_idx in range(3):\n        for c_idx in range(3):\n            boundaries[r_idx][c_idx] = (row_starts[r_idx], row_ends[r_idx],\n                                        col_starts[c_idx], col_ends[c_idx])\n\n    return separator_color, subgrid_h, subgrid_w, boundaries\n\n\ndef _get_subgrid(grid, boundaries):\n    \"\"\"Extracts a subgrid view from the main grid based on boundaries.\"\"\"\n    r_start, r_end, c_start, c_end = boundaries\n    # Handle cases where subgrid dimensions might be 0 or invalid\n    if r_start >= r_end or c_start >= c_end:\n        return np.array([[]], dtype=grid.dtype).reshape(0, 0) # Return empty 2D array\n    # Ensure boundaries are within grid limits before slicing\n    r_end = min(r_end, grid.shape[0])\n    c_end = min(c_end, grid.shape[1])\n    r_start = max(0, r_start)\n    c_start = max(0, c_start)\n    if r_start >= r_end or c_start >= c_end:\n        return np.array([[]], dtype=grid.dtype).reshape(0, 0)\n\n    return grid[r_start:r_end, c_start:c_end]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional subgrid replacement transformation.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = grid.copy()\n    background_color = 0\n\n    # Step 1: Identify the grid structure (separator, dimensions, boundaries)\n    separator_color, subgrid_h, subgrid_w, boundaries = _find_grid_structure(grid)\n\n    # If structure is invalid or not found, return the original grid (as list of lists)\n    if boundaries is None:\n        # print(\"Warning: Could not determine grid structure. Returning original grid.\")\n        return input_grid\n\n    # Step 2: Extract the central subgrid pattern (C)\n    central_boundaries = boundaries[1][1]\n    central_pattern = _get_subgrid(grid, central_boundaries)\n\n    # Step 3: Identify the trigger color (P) in the central pattern\n    # Handle empty central pattern case\n    if central_pattern.size == 0:\n         # print(\"Warning: Central subgrid is empty. Returning original grid.\")\n         return input_grid # Return original list of lists\n\n    unique_pattern_colors = np.unique(central_pattern)\n    # Filter out background and separator colors to find pattern-specific colors\n    pattern_colors = [c for c in unique_pattern_colors if c != background_color and c != separator_color]\n\n    # Step 4: Check if exactly one unique trigger color exists\n    if len(pattern_colors) != 1:\n        # If no single trigger color is found, return the original grid unchanged\n        # print(f\"Warning: Central subgrid does not define a single trigger color (found {pattern_colors}). Returning original grid.\")\n        return input_grid # Return original list of lists\n\n    trigger_color = pattern_colors[0]\n\n    # Step 5 & 6: Iterate through subgrids in the top two rows (r=0, 1)\n    for r in range(2): # Iterate through row indices 0 and 1\n        for c in range(3): # Iterate through column indices 0, 1, 2\n            # Step 7a: Get the subgrid directly below (r+1, c) from the *input* grid\n            below_boundaries = boundaries[r+1][c]\n            subgrid_below = _get_subgrid(grid, below_boundaries)\n\n            # Handle case where subgrid below might be empty (e.g., zero height/width)\n            if subgrid_below.size == 0:\n                 continue # Nothing to check or copy, skip to next subgrid\n\n            # Step 7b: Check if the trigger color P exists in the subgrid below\n            if np.any(subgrid_below == trigger_color):\n                # Step 7c: If trigger found, replace the current subgrid (r, c) in the output grid\n                # with the content of the subgrid below (r+1, c) from the input grid.\n                current_boundaries = boundaries[r][c]\n                cr_start, cr_end, cc_start, cc_end = current_boundaries\n\n                # Target slice in output grid:\n                # Ensure boundary slicing is correct even if subgrid H/W is 0\n                if cr_start >= cr_end or cc_start >= cc_end:\n                    continue # Cannot replace a zero-sized subgrid\n\n                target_slice = output_grid[cr_start:cr_end, cc_start:cc_end]\n\n                # Ensure dimensions match before assignment\n                if target_slice.shape == subgrid_below.shape:\n                    output_grid[cr_start:cr_end, cc_start:cc_end] = subgrid_below\n                else:\n                    # This case might happen if boundary calculation allows different H/W across grid,\n                    # which _find_grid_structure tries to prevent. Log error if it occurs.\n                    print(f\"Error: Shape mismatch during replacement at subgrid ({r},{c}). Target shape {target_slice.shape}, Source shape {subgrid_below.shape}. Skipping replacement.\")\n\n            # Step 7d: If trigger color is not found below, the subgrid (r, c) in output_grid\n            # remains unchanged (because output_grid started as a copy of grid).\n\n    # Step 8: Subgrids in the last row (r=2) are implicitly unchanged.\n\n    # Step 9: Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16138,
    "candidates_token_count": 3385,
    "total_token_count": 19523,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 130.828618,
  "retries": null
}