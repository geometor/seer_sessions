{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all contiguous objects composed of 'red' pixels (color 2) in the input grid.\n2. For each red object found, calculate its size (number of pixels it contains).\n3. Determine a maximum Manhattan distance threshold 'D' for each object based on its size 'L': D = (L - 1) // 2.\n4. Create an output grid initialized as a copy of the input grid.\n5. Iterate through each pixel (r, c) in the input grid.\n6. If the pixel at (r, c) is not red (i.e., color is not 2):\n    a. Find the minimum Manhattan distance ('min_dist') from this pixel (r, c) to *any* red pixel in the grid.\n    b. Identify the specific red pixel ('closest_red_pixel') that yields this minimum distance.\n    c. Determine which red object the 'closest_red_pixel' belongs to.\n    d. Retrieve the pre-calculated distance threshold 'D' associated with that specific red object.\n    e. If 'min_dist' is greater than 0 and less than or equal to 'D', change the color of the pixel at (r, c) in the output grid to 'azure' (color 8).\n7. Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list where each element is a set of (row, col) tuples representing an object.\n            - dict: A dictionary mapping each pixel (row, col) of the specified color to its object ID (index in the list).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    pixel_to_object_map = {}\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                current_object_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_id = object_id_counter\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    pixel_to_object_map[(row, col)] = obj_id\n\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is the correct color and not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Add the found object to the list if it's not empty\n                if current_object_coords:\n                    objects.append(current_object_coords)\n                    object_id_counter += 1\n\n    return objects, pixel_to_object_map\n\ndef calculate_manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Fills areas around red objects with azure based on Manhattan distance\n    relative to the size of the nearest object.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    red_color = 2\n    azure_color = 8\n\n    # 1. Find all red pixels\n    red_pixels = list(zip(*np.where(input_np == red_color)))\n    if not red_pixels:\n        # If there are no red pixels, return the original grid\n        return input_grid\n\n    # 2. Find red objects and map pixels to objects\n    objects, pixel_to_object_map = find_objects(input_np, red_color)\n\n    # 3. Calculate size and distance threshold D for each object\n    object_details = {}\n    for obj_id, obj_coords in enumerate(objects):\n        length = len(obj_coords)\n        threshold_D = (length - 1) // 2\n        object_details[obj_id] = {'coords': obj_coords, 'length': length, 'threshold': threshold_D}\n\n    # 4. Iterate through all pixels in the grid\n    for r in range(height):\n        for c in range(width):\n            # 5. Only consider changing non-red pixels\n            if input_np[r, c] != red_color:\n                min_dist = float('inf')\n                closest_red_pixel = None\n\n                # 6a. Find the minimum Manhattan distance to any red pixel\n                for r_red, c_red in red_pixels:\n                    dist = calculate_manhattan_distance((r, c), (r_red, c_red))\n                    if dist < min_dist:\n                        min_dist = dist\n                        closest_red_pixel = (r_red, c_red)\n\n                # Proceed only if a closest red pixel was found and the distance is > 0\n                if closest_red_pixel is not None and min_dist > 0:\n                    # 6b & 6c. Find the object this closest pixel belongs to\n                    obj_id = pixel_to_object_map.get(closest_red_pixel)\n\n                    if obj_id is not None:\n                       # 6d. Get the threshold distance D for that object\n                       threshold_D = object_details[obj_id]['threshold']\n\n                       # 6e. If the min distance is within the threshold, color azure\n                       if min_dist <= threshold_D:\n                           output_np[r, c] = azure_color\n\n    # 7. Return the modified grid as a list of lists\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3970,
    "candidates_token_count": 1531,
    "total_token_count": 5501,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.734156,
  "retries": null
}