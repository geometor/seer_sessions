{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all contiguous objects composed of 'red' pixels (color 2) in the input grid.\n2. For each red object found:\n    a. Calculate its size 'L' (number of pixels).\n    b. Determine its distance threshold 'D' = (L - 1) // 2.\n    c. Store the object's coordinates and its threshold D.\n3. Perform a multi-source Breadth-First Search (BFS) starting from all red pixels simultaneously.\n4. The BFS calculates the Manhattan distance ('dist') from each grid cell to the *nearest* red pixel and identifies which red object ('obj_id') that nearest red pixel belongs to.\n5. Create an output grid initialized as a copy of the input grid.\n6. Iterate through each pixel (r, c) in the grid.\n7. If the pixel at (r, c) is not red (i.e., color is not 2) and it was reached by the BFS (meaning it has an associated minimum distance 'dist' and a corresponding 'obj_id' from the nearest red object):\n    a. Retrieve the distance threshold 'D' associated with the 'obj_id' of the object that is closest to this pixel (r, c).\n    b. If the calculated minimum distance 'dist' is greater than 0 and less than or equal to the threshold 'D', change the color of the pixel at (r, c) in the output grid to 'azure' (color 8).\n8. Return the modified output grid.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color using Breadth-First Search (BFS).\n    Calculates size and distance threshold for each object.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        tuple: A tuple containing:\n            - dict: Maps object_id to {'coords': set(), 'length': int, 'threshold': int}.\n            - dict: Maps each pixel (row, col) of the specified color to its object ID.\n            - list: A list of all pixel coordinates (r, c) of the specified color.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    object_details = {}\n    pixel_to_object_map = {}\n    all_color_pixels = []\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Add pixel to list if it's the target color\n            if grid[r, c] == color:\n                all_color_pixels.append((r, c))\n                # Start BFS if we find an unvisited pixel of the target color\n                if not visited[r, c]:\n                    current_object_coords = set()\n                    q = deque([(r, c)])\n                    visited[r, c] = True\n                    obj_id = object_id_counter\n\n                    while q:\n                        row, col = q.popleft()\n                        current_object_coords.add((row, col))\n                        pixel_to_object_map[(row, col)] = obj_id # Map pixel to this object ID\n\n                        # Check 4 cardinal neighbors\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if the neighbor is the correct color and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                    # Store details if object is valid\n                    if current_object_coords:\n                        length = len(current_object_coords)\n                        threshold_D = (length - 1) // 2\n                        object_details[obj_id] = {\n                            'coords': current_object_coords,\n                            'length': length,\n                            'threshold': threshold_D\n                        }\n                        object_id_counter += 1\n\n    return object_details, pixel_to_object_map, all_color_pixels\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid. Fills areas around red\n    objects with azure based on Manhattan distance, constrained by a threshold\n    derived from the size of the nearest red object.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    red_color = 2\n    azure_color = 8\n\n    # 1. Find red objects, their properties, and pixel-to-object mapping\n    object_details, pixel_to_object_map, red_pixels = find_objects(input_np, red_color)\n\n    # If there are no red pixels, return the original grid\n    if not red_pixels:\n        return input_grid\n\n    # 3. Initialize BFS structures: distance grid and object ID grid\n    # distance grid stores min distance to any red pixel\n    dist_grid = np.full_like(input_np, fill_value=float('inf'), dtype=float)\n    # object ID grid stores the ID of the object that is closest\n    obj_id_grid = np.full_like(input_np, fill_value=-1, dtype=int)\n    queue = deque()\n\n    # 4. Initialize BFS queue and grids using all red pixels as starting points\n    for r_red, c_red in red_pixels:\n        obj_id = pixel_to_object_map[(r_red, c_red)]\n        dist_grid[r_red, c_red] = 0\n        obj_id_grid[r_red, c_red] = obj_id\n        # Add the pixel coordinate and its corresponding object ID to the queue\n        queue.append(((r_red, c_red), obj_id))\n\n    # 5. Perform multi-source BFS to calculate minimum distances and closest object IDs\n    while queue:\n        (r, c), current_obj_id = queue.popleft() # Get pixel and the ID of the object it belongs to (or was reached from)\n        current_dist = dist_grid[r, c]\n\n        # Explore neighbors (4-connectivity for Manhattan distance)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_dist = current_dist + 1\n                # If this path offers a shorter distance to the neighbor than previously found\n                if new_dist < dist_grid[nr, nc]:\n                    dist_grid[nr, nc] = new_dist\n                    # Record the object ID associated with this shortest path\n                    obj_id_grid[nr, nc] = current_obj_id\n                    # Add the neighbor to the queue for further exploration\n                    queue.append(((nr, nc), current_obj_id))\n                # Note: No complex tie-breaking needed based on examples. First path found with min distance determines the object ID.\n\n    # 6. Iterate through the grid to color pixels based on BFS results\n    for r in range(height):\n        for c in range(width):\n            # Consider only non-red pixels that were reached by the BFS\n            if input_np[r, c] != red_color and obj_id_grid[r, c] != -1:\n                # Get the minimum distance and the ID of the closest object\n                dist = dist_grid[r, c]\n                obj_id = obj_id_grid[r, c]\n                # Retrieve the distance threshold D for that specific object\n                threshold_D = object_details[obj_id]['threshold']\n\n                # 7. Apply the coloring rule: color azure if distance is within threshold\n                # dist > 0 condition prevents coloring the original red pixels\n                if 0 < dist <= threshold_D:\n                    output_np[r, c] = azure_color\n\n    # 8. Return the modified grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7077,
    "candidates_token_count": 1963,
    "total_token_count": 9040,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 54.576347,
  "retries": null
}