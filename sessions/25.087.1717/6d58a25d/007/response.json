{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid by identifying a specific T-shaped pattern and drawing a shape below it using a secondary color.\n\nThe transformation rule involves these steps:\n1.  Identify two distinct non-white colors in the grid. One color ('shape_color') \n    forms a specific T-shaped pattern around a central white pixel, and the other \n    ('filler_color') is scattered elsewhere.\n2.  Locate the central white pixel (anchor_row, anchor_col) which has the \n    'shape_color' directly above it, to its left, and to its right. \n    Specifically, find (r, c) such that grid[r, c] == 0 and \n    grid[r-1, c] == grid[r, c-1] == grid[r, c+1] == shape_color.\n3.  Create the output grid as a copy of the input grid.\n4.  Modify the output grid by drawing a shape using the 'filler_color' relative \n    to the anchor point (anchor_row, anchor_col):\n    a.  Color the anchor pixel (anchor_row, anchor_col).\n    b.  Color the three pixels in the row directly below the anchor: \n        (anchor_row + 1, anchor_col - 1), (anchor_row + 1, anchor_col), and \n        (anchor_row + 1, anchor_col + 1). Perform boundary checks to ensure \n        these columns are valid.\n    c.  Color the pixels in the same column as the anchor, starting from two rows \n        below the anchor (anchor_row + 2) down to the bottom edge of the grid:\n        (row, anchor_col) for row >= anchor_row + 2.\n5.  All other pixels retain their original colors from the input grid.\n\"\"\"\n\ndef find_pattern_center_and_colors(grid):\n    \"\"\"\n    Finds the center of the T-pattern, the shape color, and the filler color.\n\n    The pattern is a white pixel (r, c) where the pixels at (r-1, c), \n    (r, c-1), and (r, c+1) are all the same non-white color (shape_color).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (shape_color, filler_color, center_row, center_col) or \n               (None, None, None, None) if the pattern is not found or if there \n               are not exactly two non-white colors.\n    \"\"\"\n    rows, cols = grid.shape\n    # Find all unique non-white colors\n    non_white_colors = np.unique(grid[grid != 0])\n    \n    # The task structure expects exactly two non-white colors\n    if len(non_white_colors) != 2:\n        # Adding a print statement for debugging if needed\n        # print(f\"Warning: Found {len(non_white_colors)} non-white colors. Expected 2.\")\n        return None, None, None, None \n        \n    color1, color2 = non_white_colors\n\n    # Iterate through possible center pixels (avoiding edges where pattern check would fail)\n    # Need r > 0 to check r-1\n    # Need 0 < c < cols-1 to check c-1 and c+1\n    for r in range(1, rows): \n        for c in range(1, cols - 1): \n            # Check if the current pixel is white (0)\n            if grid[r, c] == 0:\n                # Check neighbors for the specific T-shape pattern\n                up = grid[r - 1, c]\n                left = grid[r, c - 1]\n                right = grid[r, c + 1]\n                \n                # Check if up, left, right are the same non-white color\n                if up != 0 and up == left == right:\n                    shape_color = up\n                    # Determine the filler color (the other non-white color)\n                    filler_color = color1 if shape_color == color2 else color2\n                    # Pattern found, return the details\n                    return shape_color, filler_color, r, c\n                    \n    # Pattern not found\n    # Adding a print statement for debugging if needed\n    # print(\"Warning: T-pattern anchor not found.\")\n    return None, None, None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # 1. Identify Key Elements & 2. Locate Pattern Anchor\n    shape_color, filler_color, anchor_row, anchor_col = find_pattern_center_and_colors(input_grid)\n\n    # Handle case where pattern is not found (return a copy as per instructions)\n    if anchor_row is None:\n        return np.copy(input_grid) \n\n    # 3. Initialize Output Grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # --- Apply transformations ---\n    # 4. Draw the output shape using the filler_color\n\n    # 4a. Color the anchor pixel\n    # Check if anchor is within bounds (although find pattern ensures r>=1)\n    if 0 <= anchor_row < rows and 0 <= anchor_col < cols:\n         output_grid[anchor_row, anchor_col] = filler_color\n\n    # 4b. Color the horizontal line in the row below the anchor\n    row_below = anchor_row + 1\n    if 0 <= row_below < rows:\n        # Center pixel below anchor\n        if 0 <= anchor_col < cols:\n            output_grid[row_below, anchor_col] = filler_color\n        # Pixel to the left\n        col_left = anchor_col - 1\n        if 0 <= col_left < cols:\n            output_grid[row_below, col_left] = filler_color\n        # Pixel to the right\n        col_right = anchor_col + 1\n        if 0 <= col_right < cols:\n            output_grid[row_below, col_right] = filler_color\n\n    # 4c. Color the vertical line starting two rows below the anchor\n    start_row_vertical = anchor_row + 2\n    # Ensure the column is valid\n    if 0 <= anchor_col < cols:\n        # Iterate from the start row down to the bottom of the grid\n        for r in range(start_row_vertical, rows):\n            output_grid[r, anchor_col] = filler_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13304,
    "candidates_token_count": 1599,
    "total_token_count": 14903,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.682472,
  "retries": null
}