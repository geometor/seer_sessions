{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation rule based on observations:\n1. Identify the background color (assumed to be the most frequent color, typically orange/7).\n2. Find distinct contiguous objects touching the four main corners of the grid (top-left, top-right, bottom-left, bottom-right). Ignore background-colored objects.\n3. Collect the unique colors of these corner objects. Let N be the number of unique colors.\n4. Determine a 'target color' based on N and grid dimensions (H, W):\n    - If N = 0: No non-background corner objects, no change.\n    - If N = 1: Target color is the single unique color found.\n    - If N = 2: Let colors be c1, c2 (sorted). If H and W are both odd, target is min(c1, c2). Otherwise, target is max(c1, c2).\n    - If N = 3: Let colors be c1, c2, c3 (sorted). Target color is the median color (c2).\n    - If N >= 4: Rule is undefined by examples, assume no change.\n5. Identify all corner objects that match the 'target color'.\n6. For each target object:\n    - Determine its dimensions (height h, width w).\n    - Determine its origin corner (TL, TR, BL, BR).\n    - Calculate a move vector (dr, dc) based on origin corner and dimensions:\n        - TL origin: dr = h, dc = w\n        - TR origin: dr = h, dc = -w\n        - BL origin: dr = -h, dc = w\n        - BR origin: dr = -h, dc = -w\n    - Move every pixel (r, c) of the object to (r + dr, c + dc).\n7. Update the grid:\n    - Set the original positions of all moved pixels to the background color.\n    - Set the new positions to the target color, handling overlaps (last write wins, effectively).\n\"\"\"\n\ndef _get_background_color(grid):\n    \"\"\"Determine the background color (most frequent).\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef _find_object_details_bfs(grid, start_row, start_col, visited, background_color):\n    \"\"\"\n    Finds all coordinates, color, and dimensions of a connected object starting from (start_row, start_col) using BFS.\n    Avoids searching the background color and already visited pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): Starting row index.\n        start_col (int): Starting column index.\n        visited (set): A set of (row, col) tuples already visited.\n        background_color (int): The background color to ignore.\n\n    Returns:\n        tuple: (frozenset of (row, col) coordinates, object_color, height, width)\n               Returns (None, None, None, None) if the start pixel is background, out of bounds, or already visited.\n    \"\"\"\n    height, width = grid.shape\n\n    if not (0 <= start_row < height and 0 <= start_col < width):\n        return None, None, None, None # Start is out of bounds\n\n    start_color = grid[start_row, start_col]\n\n    if start_color == background_color or (start_row, start_col) in visited:\n        return None, None, None, None # Don't process background or already processed parts\n\n    q = deque([(start_row, start_col)])\n    object_coords = set()\n    visited.add((start_row, start_col)) # Mark start as visited\n\n    min_r, max_r = start_row, start_row\n    min_c, max_c = start_col, start_col\n\n    while q:\n        r, c = q.popleft()\n        object_coords.add((r, c))\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, color match, and if not visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == start_color and (nr, nc) not in visited:\n                visited.add((nr, nc)) # Mark visited when adding to queue\n                q.append((nr, nc))\n\n    obj_h = max_r - min_r + 1\n    obj_w = max_c - min_c + 1\n\n    return frozenset(object_coords), start_color, obj_h, obj_w\n\ndef _get_corner_objects_and_colors(grid, background_color):\n    \"\"\"\n    Identifies objects touching the four corners of the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        tuple: (corner_objects, unique_colors)\n            - corner_objects (dict): Maps color -> list of (coords, height, width) tuples.\n            - unique_colors (list): Sorted list of unique colors found in corner objects.\n    \"\"\"\n    height, width = grid.shape\n    corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]\n    corner_objects = {} # {color: [(coords, h, w), ...]}\n    visited = set() # Shared visited set\n\n    for r_corn, c_corn in corners:\n        # Need to handle cases where the corner pixel itself might be background\n        # but an object touches it. Search neighbors if corner is background.\n        q = deque([(r_corn, c_corn)])\n        potential_starts = set()\n        \n        # Check the corner itself first\n        if grid[r_corn, c_corn] != background_color:\n             potential_starts.add((r_corn, c_corn))\n        else: # If corner is background, check its direct neighbors\n             for dr in [-1, 0, 1]:\n                 for dc in [-1, 0, 1]:\n                     if dr == 0 and dc == 0: continue\n                     nr, nc = r_corn + dr, c_corn + dc\n                     if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] != background_color:\n                         potential_starts.add((nr, nc))\n                         \n        processed_in_this_corner = set() # Track objects found from this corner check\n        for r_start, c_start in potential_starts:\n             if (r_start, c_start) in visited: continue # Already part of a found object\n\n             coords, color, obj_h, obj_w = _find_object_details_bfs(grid, r_start, c_start, visited, background_color)\n             \n             if coords: # If a valid object was found\n                 # Check if this object actually contains/touches one of the four corner pixels\n                 is_corner_object = False\n                 for cr, cc in corners:\n                     # Check if corner pixel is in the object OR if object is adjacent to corner pixel\n                     if (cr, cc) in coords:\n                         is_corner_object = True\n                         break\n                     for dr in [-1, 0, 1]:\n                         for dc in [-1, 0, 1]:\n                             if dr==0 and dc==0: continue\n                             if (cr+dr, cc+dc) in coords:\n                                is_corner_object = True\n                                break\n                     if is_corner_object: break\n\n                 if is_corner_object:\n                    obj_data = (coords, obj_h, obj_w)\n                    # Avoid adding duplicate objects found from different starting points near the same corner\n                    if obj_data not in processed_in_this_corner:\n                        if color not in corner_objects:\n                            corner_objects[color] = []\n                        corner_objects[color].append(obj_data)\n                        processed_in_this_corner.add(obj_data)\n\n    unique_colors = sorted(list(corner_objects.keys()))\n    return corner_objects, unique_colors\n\ndef _determine_move_vector(obj_coords, obj_h, obj_w, H, W):\n    \"\"\"\n    Determines the move vector based on which corner the object occupies and its dimensions.\n\n    Args:\n        obj_coords (frozenset): Set of (row, col) coordinates of the object.\n        obj_h (int): Object height.\n        obj_w (int): Object width.\n        H (int): Grid height.\n        W (int): Grid width.\n\n    Returns:\n        tuple: (dr, dc) representing the movement vector. Returns (0,0) if corner cannot be determined.\n    \"\"\"\n    # Check which corner pixel is contained within the object's coordinates\n    if (0, 0) in obj_coords: return (obj_h, obj_w)         # Top-left moves by (h, w)\n    if (0, W - 1) in obj_coords: return (obj_h, -obj_w)    # Top-right moves by (h, -w)\n    if (H - 1, 0) in obj_coords: return (-obj_h, obj_w)   # Bottom-left moves by (-h, w)\n    if (H - 1, W - 1) in obj_coords: return (-obj_h, -obj_w)# Bottom-right moves by (-h, -w)\n\n    # Fallback: Check adjacency if corner pixel isn't *in* the object, but object touches it.\n    # This might be needed if an object is L-shaped around a corner.\n    # Find the coordinate closest to each corner.\n    min_r = min(r for r,c in obj_coords)\n    min_c = min(c for r,c in obj_coords)\n    max_r = max(r for r,c in obj_coords)\n    max_c = max(c for r,c in obj_coords)\n\n    touches_tl = min_r == 0 and min_c == 0\n    touches_tr = min_r == 0 and max_c == W - 1\n    touches_bl = max_r == H - 1 and min_c == 0\n    touches_br = max_r == H - 1 and max_c == W - 1\n    \n    if touches_tl: return (obj_h, obj_w)\n    if touches_tr: return (obj_h, -obj_w)\n    if touches_bl: return (-obj_h, obj_w)\n    if touches_br: return (-obj_h, -obj_w)\n\n    # If still undetermined, return no move (shouldn't happen with _get_corner_objects logic)\n    print(f\"Warning: Could not determine corner for object with {len(obj_coords)} pixels. h={obj_h}, w={obj_w}. BBox: ({min_r},{min_c})-({max_r},{max_c})\")\n    return (0, 0)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying corner objects, determining a target color\n    based on the count of unique corner object colors and grid dimensions, and moving\n    objects of the target color diagonally inwards by an amount determined by their dimensions.\n    \"\"\"\n    # Determine background color\n    background_color = _get_background_color(input_grid)\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify corner objects and their unique colors\n    # Need to refine _get_corner_objects to handle objects *touching* corners, not just containing the corner pixel\n    corner_objects, unique_colors = _get_corner_objects_and_colors(input_grid, background_color)\n\n    # 2. Determine the target color based on the number of unique colors (N)\n    N = len(unique_colors)\n    target_color = -1 # Default invalid color\n\n    if N == 0:\n        # No non-background corner objects found\n        return output_grid\n    elif N == 1:\n        # If only one color, that's the target\n        target_color = unique_colors[0]\n    elif N == 2:\n        # If two colors, check grid dimensions parity\n        min_color, max_color = unique_colors[0], unique_colors[1]\n        if height % 2 != 0 and width % 2 != 0: # Both dimensions odd\n            target_color = min_color\n        else: # At least one dimension is even\n            target_color = max_color\n    elif N == 3:\n        # If three colors, target is the median\n        target_color = unique_colors[1]\n    else:\n        # Rule for N=4 or more is undefined by examples, assume no move\n        # print(f\"Info: Found {N} unique corner colors. Rule undefined. No objects moved.\")\n        return output_grid # Return original grid if rule undefined\n\n    # 3. Identify objects matching the target color\n    target_object_data = corner_objects.get(target_color, []) # List of (coords, h, w)\n    if not target_object_data:\n        # Target color determined, but no objects of that color found\n        return output_grid\n\n    # 4. Prepare for moving objects\n    pixels_to_clear = set()\n    pixels_to_set = [] # List of (new_row, new_col, color)\n\n    # 5. Calculate moves for each target object\n    for obj_coords, obj_h, obj_w in target_object_data:\n        # Determine movement vector for this object\n        dr, dc = _determine_move_vector(obj_coords, obj_h, obj_w, height, width)\n\n        if dr == 0 and dc == 0: continue # Skip if no move vector determined\n\n        # Add all original pixels to the clear set\n        pixels_to_clear.update(obj_coords)\n\n        # Calculate new positions for all pixels in the object\n        for r, c in obj_coords:\n            nr, nc = r + dr, c + dc\n            # Check if the new position is within grid bounds\n            # (Out of bounds pixels simply disappear)\n            if 0 <= nr < height and 0 <= nc < width:\n                 pixels_to_set.append((nr, nc, target_color))\n\n    # 6. Apply changes to the output grid\n    # First, clear the original positions\n    for r, c in pixels_to_clear:\n        output_grid[r, c] = background_color\n\n    # Then, set the new positions. Overlapping writes are handled implicitly (last one wins)\n    for nr, nc, color in pixels_to_set:\n        output_grid[nr, nc] = color # Assign target color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9205,
    "candidates_token_count": 3577,
    "total_token_count": 12782,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 54.522766,
  "retries": null
}