{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous objects of non-background color (orange, 7) located at the four corners of the input grid.\nDetermines a 'target color' based on the number of unique colors found among these corner objects and the grid dimensions:\n- If 1 unique color: Target is that color.\n- If 2 unique colors: Target is the minimum color if grid height and width are both odd, otherwise the maximum color.\n- If 3 unique colors: Target is the median color.\nMoves all corner objects matching the target color one step diagonally inwards towards the center.\nThe original positions of the moved objects are filled with the background color.\n\"\"\"\n\ndef _find_object_coords_bfs(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds all coordinates of a connected object of the same color starting from (start_row, start_col) using BFS.\n    Avoids searching the background color and already visited pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): Starting row index.\n        start_col (int): Starting column index.\n        visited (set): A set of (row, col) tuples already visited by previous searches.\n\n    Returns:\n        tuple: (frozenset of (row, col) coordinates for the object, object_color)\n               Returns (None, None) if the start pixel is background or already visited.\n    \"\"\"\n    height, width = grid.shape\n    # Use orange (7) as the background color\n    background_color = 7 \n\n    if not (0 <= start_row < height and 0 <= start_col < width):\n        return None, None # Start is out of bounds\n\n    start_color = grid[start_row, start_col]\n\n    if start_color == background_color or (start_row, start_col) in visited:\n        return None, None # Don't process background or already processed parts\n\n    q = deque([(start_row, start_col)])\n    object_coords = set()\n    visited.add((start_row, start_col)) # Mark start as visited immediately\n\n    while q:\n        r, c = q.popleft()\n        object_coords.add((r, c))\n\n        # Explore neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, color match, and if not visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == start_color and (nr, nc) not in visited:\n                visited.add((nr, nc)) # Mark visited when adding to queue\n                q.append((nr, nc))\n\n    return frozenset(object_coords), start_color\n\ndef _get_corner_objects_and_colors(grid):\n    \"\"\"\n    Identifies objects located at the four corners of the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (corner_objects, unique_colors)\n            - corner_objects (dict): Maps color -> list of frozensets of coordinates.\n            - unique_colors (list): Sorted list of unique colors found in corner objects.\n    \"\"\"\n    height, width = grid.shape\n    corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]\n    corner_objects = {} # {color: [frozenset(coords1), frozenset(coords2), ...]}\n    visited = set() # Shared visited set across all BFS calls from corners\n\n    for r_corn, c_corn in corners:\n        coords, color = _find_object_coords_bfs(grid, r_corn, c_corn, visited)\n        if coords: # If an object was found (not background or already visited)\n            if color not in corner_objects:\n                corner_objects[color] = []\n            # The visited set ensures we don't add the same object multiple times\n            # if it touches more than one corner. The BFS initiated from the first\n            # corner encounter will find all its coordinates. Subsequent corner\n            # checks hitting the same object will return (None, None).\n            corner_objects[color].append(coords)\n\n    unique_colors = sorted(list(corner_objects.keys()))\n    return corner_objects, unique_colors\n\ndef _determine_move_vector(obj_coords, H, W):\n    \"\"\"\n    Determines the diagonal inward move vector based on which corner the object occupies.\n    Assumes the object contains one of the corner pixels.\n\n    Args:\n        obj_coords (frozenset): Set of (row, col) coordinates of the object.\n        H (int): Grid height.\n        W (int): Grid width.\n\n    Returns:\n        tuple: (dr, dc) representing the movement vector.\n    \"\"\"\n    if (0, 0) in obj_coords: return (1, 1)       # Top-left moves down-right\n    if (0, W - 1) in obj_coords: return (1, -1)   # Top-right moves down-left\n    if (H - 1, 0) in obj_coords: return (-1, 1)  # Bottom-left moves up-right\n    if (H - 1, W - 1) in obj_coords: return (-1, -1)# Bottom-right moves up-left\n    \n    # Fallback/Error case: should not happen for corner objects found via _get_corner_objects_and_colors\n    # This might occur if an object touches a corner but doesn't include the corner pixel itself,\n    # which contradicts the current interpretation of examples.\n    # For robustness, one could check proximity or centroid, but sticking to corner pixel containment.\n    print(f\"Warning: Could not determine corner for object with coords starting near {next(iter(obj_coords))}\")\n    return (0, 0) \n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving specific corner objects diagonally inwards.\n\n    Args:\n        input_grid (np.array): The input 2D grid.\n\n    Returns:\n        np.array: The transformed 2D grid.\n    \"\"\"\n    # Use orange (7) as the background color\n    background_color = 7\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify corner objects and their unique colors\n    corner_objects, unique_colors = _get_corner_objects_and_colors(input_grid)\n    \n    # 2. Determine the target color based on the number of unique colors (N)\n    N = len(unique_colors)\n    target_color = -1 # Default invalid color\n\n    if N == 0:\n        # No non-background corner objects found\n        return output_grid \n    elif N == 1:\n        # If only one color, that's the target\n        target_color = unique_colors[0]\n    elif N == 2:\n        # If two colors, check grid dimensions parity\n        min_color, max_color = unique_colors[0], unique_colors[1]\n        if height % 2 != 0 and width % 2 != 0: # Both dimensions odd\n            target_color = min_color\n        else: # At least one dimension is even\n            target_color = max_color\n    elif N == 3:\n        # If three colors, target is the median\n        target_color = unique_colors[1] \n    else: \n        # Rule for N=4 or more is undefined by examples, assume no move\n        print(f\"Warning: Found {N} unique corner colors. Rule undefined. No objects moved.\")\n        return output_grid\n\n    # 3. Identify objects matching the target color\n    target_objects_coords = corner_objects.get(target_color, [])\n    if not target_objects_coords:\n        # Target color determined, but no objects of that color found (shouldn't happen with current logic)\n        return output_grid\n\n    # 4. Prepare for moving objects\n    pixels_to_clear = set()\n    pixels_to_set = [] # List of (new_row, new_col, color)\n\n    # 5. Calculate moves for each target object\n    for obj_coords in target_objects_coords:\n        # Determine movement vector for this object\n        dr, dc = _determine_move_vector(obj_coords, height, width)\n\n        if dr == 0 and dc == 0: continue # Skip if no move vector determined\n\n        # Add all original pixels to the clear set\n        pixels_to_clear.update(obj_coords)\n\n        # Calculate new positions for all pixels in the object\n        for r, c in obj_coords:\n            nr, nc = r + dr, c + dc\n            # Check if the new position is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                 pixels_to_set.append((nr, nc, target_color))\n            else:\n                 # Handle cases where movement goes out of bounds (optional, current examples don't show this)\n                 # Option 1: Pixel disappears (do nothing)\n                 # Option 2: Pixel wraps around (not typical in ARC)\n                 # Option 3: Pixel stays at boundary (not a diagonal move)\n                 # Assuming Option 1 based on simplicity\n                 pass\n\n\n    # 6. Apply changes to the output grid\n    # First, clear the original positions\n    for r, c in pixels_to_clear:\n        output_grid[r, c] = background_color\n\n    # Then, set the new positions\n    for nr, nc, color in pixels_to_set:\n        output_grid[nr, nc] = color\n        \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6234,
    "candidates_token_count": 2313,
    "total_token_count": 8547,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.615323,
  "retries": null
}