{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-white objects in the input grid.\nDetermines a color mapping from special marker pairs (vertical non-white pixels) typically found in the bottom-left corner: the top color maps to the bottom color.\nFor each object found:\n  Calculates its minimal bounding box.\n  Finds the target fill color using the object's color and the derived color mapping.\n  Fills all white (0) pixels within the object's bounding box in the output grid with the target fill color.\n  Preserves the original non-white pixels of the object.\nThe background outside any object's bounding box remains white.\n\"\"\"\n\ndef find_marker_pairs(grid):\n    \"\"\"\n    Finds vertical marker pairs in the bottom-left corner (cols 0, 1)\n    and returns a dictionary mapping top_color -> bottom_color.\n    \"\"\"\n    color_map = {}\n    height, width = grid.shape\n    # Search columns 0 and 1, from bottom up\n    for c in range(min(2, width)): # Check col 0 and 1 if they exist\n        for r in range(height - 1, 0, -1): # Iterate upwards, stopping before the top row\n            top_color = grid[r-1, c]\n            bottom_color = grid[r, c]\n            # Check if both are non-white (not 0)\n            if top_color != 0 and bottom_color != 0:\n                # Ensure it's a vertical pair by checking if pixels around are white or boundary\n                is_pair = True\n                # Check pixel above top\n                if r > 1 and grid[r-2, c] != 0: is_pair = False\n                # Check pixel below bottom\n                if r < height - 1 and grid[r+1, c] != 0: is_pair = False\n                # Check left/right if applicable\n                if c > 0 and (grid[r-1, c-1] != 0 or grid[r, c-1] != 0): is_pair = False\n                if c < width - 1 and (grid[r-1, c+1] != 0 or grid[r, c+1] != 0): is_pair = False\n\n                if is_pair and top_color not in color_map: # Only add first found mapping for a color\n                   color_map[top_color] = bottom_color\n                   # print(f\"Found marker pair: ({r-1},{c})={top_color} -> ({r},{c})={bottom_color}\")\n\n    # Fallback if pairs not found in standard location (simple vertical adjacency check)\n    if not color_map:\n         for c in range(min(2, width)):\n             for r in range(height - 1):\n                 top_color = grid[r, c]\n                 bottom_color = grid[r+1, c]\n                 if top_color != 0 and bottom_color != 0:\n                     # A simpler check, just looks for any vertical pair in first 2 cols\n                      if top_color not in color_map:\n                           color_map[top_color] = bottom_color\n\n\n    # Add default mapping if a color exists as an object but not in map?\n    # Based on examples, all object colors seem to have mappings.\n    # Let's assume the map found is sufficient. If a key error occurs later,\n    # we might need to handle missing mappings (e.g., map color to itself or white).\n    # For now, let's assume mappings exist for all object colors.\n    # print(f\"Derived color map: {color_map}\")\n    return color_map\n\ndef find_objects_and_fill(input_grid, color_map):\n    \"\"\"\n    Finds all non-white objects, calculates their bounding boxes,\n    and fills the background within those boxes according to the color_map.\n    Returns the modified grid.\n    \"\"\"\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid)\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and not yet visited (part of a found object)\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                object_color = input_grid[r, c]\n                \n                # Check if this color has a mapping, skip if not\n                if object_color not in color_map:\n                    # Mark as visited to avoid re-processing, but don't fill\n                    q = deque([(r, c)])\n                    while q:\n                        row, col = q.popleft()\n                        if not (0 <= row < height and 0 <= col < width) or \\\n                           visited[row, col] or \\\n                           input_grid[row, col] != object_color:\n                            continue\n                        visited[row, col] = True\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                             q.append((row + dr, col + dc))\n                    continue # Skip to next pixel if no mapping\n\n                fill_color = color_map[object_color]\n                object_coords = set()\n                q = deque([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n\n                    # Bounds check, color check, visited check\n                    if not (0 <= row < height and 0 <= col < width) or \\\n                       visited[row, col] or \\\n                       input_grid[row, col] != object_color:\n                        continue\n\n                    visited[row, col] = True\n                    object_coords.add((row, col))\n\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Add neighbors to queue\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        q.append((nr, nc))\n\n                # Now fill the bounding box in the output grid\n                # print(f\"Found object color {object_color} at ({r},{c}). BBox: ({min_r}-{max_r}, {min_c}-{max_c}). Fill with {fill_color}\")\n                for br in range(min_r, max_r + 1):\n                    for bc in range(min_c, max_c + 1):\n                        # Only fill if the original pixel was white (0)\n                        if input_grid[br, bc] == 0:\n                            output_grid[br, bc] = fill_color\n                        # Original object pixels are preserved because output_grid started as a copy\n                        # and we only overwrite 0s here.\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying objects, determining their\n    bounding boxes, and filling the background within each box using\n    a color mapping derived from marker pairs in the input.\n    \"\"\"\n    # Convert list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # Step 1: Find the color mapping from marker pairs\n    color_map = find_marker_pairs(input_np)\n\n    # Step 2: Find objects and fill their bounding boxes\n    output_np = find_objects_and_fill(input_np, color_map)\n\n    # Convert back to list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5573,
    "candidates_token_count": 1856,
    "total_token_count": 7429,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.027133,
  "retries": null
}