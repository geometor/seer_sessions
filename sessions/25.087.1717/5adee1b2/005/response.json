{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFill the bounding box of each identified object with a color determined by a \nmapping found in the bottom-left corner, then restore the original object pixels.\n\n1. **Find Color Map:** Scan the input grid starting from the bottom row upwards, \n   specifically looking at columns 0 and 1. For each row, if both grid[row, 0] \n   and grid[row, 1] are non-white colors (not 0), record a mapping rule: the \n   color at grid[row, 0] maps to the color at grid[row, 1]. Store these \n   mappings (e.g., in a dictionary). If a color from column 0 already has a \n   mapping, ignore subsequent pairs involving that same color (prioritize the \n   lowest row).\n2. **Identify Objects:** Find all distinct connected areas (objects) of non-white \n   pixels in the input grid using Breadth-First Search (BFS). For each object, \n   record its color and the set of coordinates it occupies.\n3. **Process Each Object:** Iterate through each identified object.\n   a. Let the object's color be `object_color`. Check if this `object_color` \n      exists as a key in the color map created in step 1.\n   b. **If a mapping exists:**\n      i. Determine the target fill color (`fill_color`) using the map: \n         `fill_color = map[object_color]`.\n     ii. Calculate the minimal bounding box (the smallest rectangle enclosing \n         all the object's pixels) defined by its minimum and maximum row and \n         column coordinates.\n    iii. In the **output grid**, fill the entire rectangular area defined by the \n         bounding box with the `fill_color`.\n     iv. Iterate through the original coordinates of the object's pixels found \n         in step 2. For each original pixel coordinate (r, c) belonging to \n         this object, set the pixel at `output_grid[r, c]` back to the \n         `object_color`.\n   c. **If no mapping exists:** Do nothing further for this object; its pixels \n      remain as they were in the initial copy of the input grid.\n4. **Finalize:** The resulting output grid contains the filled bounding boxes \n   overlaid with the original objects for all mapped colors.\n\"\"\"\n\ndef find_marker_pairs(grid):\n    \"\"\"\n    Finds horizontal marker pairs in the bottom-left corner (cols 0 and 1)\n    and returns a dictionary mapping left_color -> right_color.\n    It iterates from the bottom row upwards, prioritizing lower rows for mapping.\n    \"\"\"\n    color_map = {}\n    height, width = grid.shape\n\n    # Only proceed if there are at least 2 columns for horizontal pairs\n    if width < 2:\n        return color_map\n\n    # Search columns 0 and 1, from bottom row up\n    for r in range(height - 1, -1, -1): # Iterate from bottom row up to 0\n        left_color = grid[r, 0]\n        right_color = grid[r, 1]\n\n        # Check if both are non-white (not 0)\n        if left_color != 0 and right_color != 0:\n            # If this left_color hasn't been mapped yet, add the mapping\n            if left_color not in color_map:\n                color_map[left_color] = right_color\n                # print(f\"Found marker pair at row {r}: {left_color} -> {right_color}\")\n\n    # print(f\"Derived color map: {color_map}\")\n    return color_map\n\ndef find_objects(input_grid):\n    \"\"\"\n    Finds all distinct non-white objects (connected components) in the grid.\n    Returns a list of tuples, where each tuple contains (object_color, object_coords).\n    object_coords is a set of (row, col) tuples for the pixels of that object.\n    \"\"\"\n    height, width = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and not yet visited\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                object_color = input_grid[r, c]\n                object_coords = set()\n                q = deque([(r, c)])\n                \n                # Perform BFS to find all connected pixels of the same object_color\n                while q:\n                    row, col = q.popleft()\n\n                    # Bounds check, color check, visited check\n                    if not (0 <= row < height and 0 <= col < width) or \\\n                       visited[row, col] or \\\n                       input_grid[row, col] != object_color:\n                        continue\n\n                    visited[row, col] = True\n                    object_coords.add((row, col))\n\n                    # Add neighbors to queue (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        q.append((nr, nc))\n                \n                # Add the found object to the list\n                if object_coords:\n                     objects.append((object_color, object_coords))\n                     # print(f\"Found object color {object_color} starting at ({r},{c}) with {len(object_coords)} pixels.\")\n\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the described rules.\n    \"\"\"\n    # Convert list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # 1. Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n\n    # 2. Find the color mapping from horizontal marker pairs\n    color_map = find_marker_pairs(input_np)\n\n    # 3. Identify all distinct non-white objects\n    objects = find_objects(input_np)\n\n    # 4. Process each object\n    for object_color, object_coords in objects:\n        # 4a. Check if the object's color has a mapping\n        if object_color in color_map:\n            # 4b.i. Get the target fill color\n            fill_color = color_map[object_color]\n            \n            # 4b.ii. Calculate the minimal bounding box\n            min_r = min(r for r, c in object_coords)\n            max_r = max(r for r, c in object_coords)\n            min_c = min(c for r, c in object_coords)\n            max_c = max(c for r, c in object_coords)\n            # print(f\"Processing object color {object_color}. Map to {fill_color}. BBox: ({min_r}-{max_r}, {min_c}-{max_c})\")\n\n\n            # 4b.iii. Fill the entire bounding box area in the output grid with the fill_color\n            # Slicing provides a view, so modifying output_np[min_r:max_r+1, min_c:max_c+1] modifies output_np directly\n            output_np[min_r:max_r+1, min_c:max_c+1] = fill_color\n            # print(f\"Filled BBox area with {fill_color}\")\n\n            # 4b.iv. Restore the original object pixels\n            for r_obj, c_obj in object_coords:\n                output_np[r_obj, c_obj] = object_color\n            # print(f\"Restored original {object_color} pixels\")\n\n\n        # 4c. If no mapping exists, do nothing (object pixels are already preserved from the initial copy)\n\n    # 5. Convert back to list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9798,
    "candidates_token_count": 1888,
    "total_token_count": 11686,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.527977,
  "retries": null
}