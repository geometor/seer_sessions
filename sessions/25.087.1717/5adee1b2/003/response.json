{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-white objects in the input grid.\nDetermines a color mapping from special marker pairs (horizontal non-white pixels) \ntypically found in the bottom-left corner (columns 0 and 1): the color in column 0\nmaps to the color in column 1.\nFor each object found:\n  Calculates its minimal bounding box.\n  Finds the target fill color using the object's color and the derived color mapping.\n  Fills all white (0) pixels within the object's minimal bounding box in the \n  output grid with the target fill color.\n  Preserves the original non-white pixels of the object.\nThe background outside any object's bounding box remains white. Pixels belonging\nto objects whose color does not appear as a key in the marker pairs are left\nuntouched, and their bounding boxes are not filled.\n\"\"\"\n\ndef find_marker_pairs(grid):\n    \"\"\"\n    Finds horizontal marker pairs in the bottom-left corner (cols 0 and 1)\n    and returns a dictionary mapping left_color -> right_color.\n    It iterates from the bottom row upwards.\n    \"\"\"\n    color_map = {}\n    height, width = grid.shape\n\n    # Only proceed if there are at least 2 columns for horizontal pairs\n    if width < 2:\n        return color_map\n\n    # Search columns 0 and 1, from bottom row up\n    for r in range(height - 1, -1, -1): # Iterate from bottom row (height-1) up to 0\n        left_color = grid[r, 0]\n        right_color = grid[r, 1]\n\n        # Check if both are non-white (not 0)\n        if left_color != 0 and right_color != 0:\n            # If this left_color hasn't been mapped yet, add the mapping\n            if left_color not in color_map:\n                color_map[left_color] = right_color\n                # print(f\"Found marker pair at row {r}: {left_color} -> {right_color}\")\n\n    # print(f\"Derived color map: {color_map}\")\n    return color_map\n\ndef find_objects_and_fill(input_grid, color_map):\n    \"\"\"\n    Finds all non-white objects, calculates their bounding boxes,\n    and fills the background (white pixels) within those boxes according \n    to the color_map. Objects whose colors are not keys in the color_map\n    are ignored for filling purposes.\n    Returns the modified grid.\n    \"\"\"\n    height, width = input_grid.shape\n    # Start with a copy of the input grid\n    output_grid = np.copy(input_grid) \n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and not yet visited (part of a found object)\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                object_color = input_grid[r, c]\n                \n                # Check if this object's color has a mapping defined in the markers\n                if object_color not in color_map:\n                    # If no mapping exists, we still need to mark all parts of this object\n                    # as visited so we don't process them again, but we won't fill its bbox.\n                    q_skip = deque([(r, c)])\n                    while q_skip:\n                        row_s, col_s = q_skip.popleft()\n                        if not (0 <= row_s < height and 0 <= col_s < width) or \\\n                           visited[row_s, col_s] or \\\n                           input_grid[row_s, col_s] != object_color:\n                            continue\n                        visited[row_s, col_s] = True\n                        # Add neighbors for BFS\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                             q_skip.append((row_s + dr, col_s + dc))\n                    # print(f\"Skipping object color {object_color} starting at ({r},{c}) - no mapping found.\")\n                    continue # Move to the next pixel in the grid scan\n\n                # If a mapping exists, proceed to find the object and fill its bbox\n                fill_color = color_map[object_color]\n                object_coords = set()\n                q = deque([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform BFS to find all connected pixels of the same object_color\n                while q:\n                    row, col = q.popleft()\n\n                    # Bounds check, color check, visited check\n                    if not (0 <= row < height and 0 <= col < width) or \\\n                       visited[row, col] or \\\n                       input_grid[row, col] != object_color:\n                        continue\n\n                    visited[row, col] = True\n                    object_coords.add((row, col))\n\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Add neighbors to queue for continuing the BFS\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        q.append((nr, nc))\n\n                # Now fill the bounding box in the output grid\n                # print(f\"Found object color {object_color} at ({r},{c}). BBox: ({min_r}-{max_r}, {min_c}-{max_c}). Fill background with {fill_color}\")\n                for br in range(min_r, max_r + 1):\n                    for bc in range(min_c, max_c + 1):\n                        # Only fill if the original pixel in the input grid was white (0)\n                        # This preserves the original object pixels within the bbox\n                        if input_grid[br, bc] == 0:\n                            output_grid[br, bc] = fill_color\n                        # Else (if input_grid[br, bc] != 0), do nothing, preserving the object pixel\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by:\n    1. Finding color mappings from horizontal marker pairs in the bottom-left corner.\n    2. Identifying all distinct non-white objects.\n    3. For each object whose color has a mapping, determining its minimal bounding box.\n    4. Filling the white background pixels within that bounding box with the mapped color.\n    5. Preserving the original object pixels.\n    \"\"\"\n    # Convert list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # Step 1: Find the color mapping from horizontal marker pairs\n    color_map = find_marker_pairs(input_np)\n\n    # Step 2: Find objects and fill their bounding box backgrounds based on the map\n    output_np = find_objects_and_fill(input_np, color_map)\n\n    # Convert back to list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8310,
    "candidates_token_count": 1740,
    "total_token_count": 10050,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.652527,
  "retries": null
}