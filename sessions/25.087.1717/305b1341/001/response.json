{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on patterns and a color key.\n\n1.  Identifies a 3x2 color key map in the top-left corner (rows 0-2, cols 0-1).\n    This maps pattern colors (col 0) to border colors (col 1).\n2.  Finds unique non-white pattern colors and their locations outside the key map area.\n3.  For each pattern color:\n    a. Determines the corresponding border color using the key map.\n    b. Calculates the minimal bounding box enclosing its locations.\n4.  Sorts the patterns based on the leftmost column of their bounding boxes.\n5.  Initializes an output grid of the same size as the input, filled with white (0).\n6.  Iterates through the sorted patterns and draws rectangles onto the output grid:\n    a. The border of the rectangle is filled with the border color.\n    b. The interior cells corresponding to the original pattern color keep that color.\n    c. Other interior cells (originally white) are filled with the border color.\n\"\"\"\n\ndef find_bounding_box(coords):\n    \"\"\"Calculates the minimal bounding box for a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    rows, cols = input_grid.shape\n\n    # 1. Initialize Output\n    output_grid = np.zeros_like(input_grid)\n\n    # 2. Identify Key Map\n    key_map = {}\n    for r in range(min(3, rows)):\n        if cols >= 2:\n            pattern_color = input_grid[r, 0]\n            border_color = input_grid[r, 1]\n            if pattern_color != 0: # Only map non-white pattern colors\n                 key_map[pattern_color] = border_color\n\n    # Create a temporary grid to easily find patterns outside the key map\n    temp_grid = np.copy(input_grid)\n    if rows >= 3 and cols >= 2:\n        temp_grid[0:3, 0:2] = 0 # Blank out key map area\n\n    # 3. Identify Pattern Objects and their locations\n    pattern_coords = {}\n    unique_colors = np.unique(temp_grid[temp_grid != 0])\n\n    for color in unique_colors:\n        coords = list(zip(*np.where(temp_grid == color)))\n        if coords:\n            pattern_coords[color] = coords\n\n    # 4. Prepare Pattern Data (Color, Border Color, Bounding Box)\n    pattern_data = []\n    for pc, coords in pattern_coords.items():\n        if pc in key_map:\n            bc = key_map[pc]\n            bbox = find_bounding_box(coords)\n            if bbox:\n                min_r, min_c, max_r, max_c = bbox\n                pattern_data.append({\n                    'pc': pc,\n                    'bc': bc,\n                    'min_r': min_r,\n                    'min_c': min_c,\n                    'max_r': max_r,\n                    'max_c': max_c\n                })\n        # else: # Optional: Handle case where pattern color is not in key map\n        #     print(f\"Warning: Pattern color {pc} not found in key map.\")\n        #     continue\n\n    # 5. Determine Processing Order (Sort by min_c)\n    pattern_data.sort(key=lambda x: x['min_c'])\n\n    # 6. Draw Rectangles\n    for pattern in pattern_data:\n        pc = pattern['pc']\n        bc = pattern['bc']\n        min_r, min_c, max_r, max_c = pattern['min_r'], pattern['min_c'], pattern['max_r'], pattern['max_c']\n\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                # Check if on border\n                is_border = (r == min_r or r == max_r or c == min_c or c == max_c)\n\n                if is_border:\n                    output_grid[r, c] = bc\n                else:\n                    # Check original input color for interior cells\n                    if input_grid[r, c] == pc:\n                        output_grid[r, c] = pc\n                    elif input_grid[r, c] == 0: # Fill white interior with border color\n                        output_grid[r, c] = bc\n                    else:\n                        # If the interior pixel belonged to a *different* pattern\n                        # that was already processed, keep its original color?\n                        # Based on example 1, overlapping areas seem to take the border color\n                        # of the *current* pattern being drawn if the original pixel was 0.\n                        # If the original pixel was another pattern color, it seems to be overwritten\n                        # by the border color if it's not the *current* pattern's color.\n                        # Let's stick to the simpler logic first: if input was 0, fill BC, else fill PC.\n                        # Re-evaluating train_1 output: cell (10, 8) is 5 (gray) in input, becomes 6 (magenta) border in output.\n                        # cell (10, 9) is 0 (white) in input, becomes 6 (magenta) border in output.\n                        # cell (10,10) is 5 (gray) in input, becomes 5 (gray) in output.\n                        # cell (10,11) is 0 (white) in input, becomes 6 (magenta) border in output.\n                        # So the logic seems correct: Input PC -> Output PC, Input 0 -> Output BC.\n                        # What about Input OTHER_PC? Example 1 doesn't have overlap of non-zero pixels.\n                        # The logic implemented (check input == PC or input == 0) covers the examples.\n                         if input_grid[r, c] == 0: # Redundant check, already covered, keep for clarity\n                            output_grid[r, c] = bc\n                         # If input_grid[r,c] was a different non-zero color, it gets overwritten by BC\n                         # if it's not the current PC. This might need adjustment if complex overlaps exist.\n                         # But let's assume the current logic derived from examples is sufficient.\n\n\n    # 7. Final Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7552,
    "candidates_token_count": 1616,
    "total_token_count": 9168,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.950208,
  "retries": null
}