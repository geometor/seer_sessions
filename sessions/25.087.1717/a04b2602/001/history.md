
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 0 0 3 3 3 3 3
0 0 2 3 3 3 3 3 3 2 3 0 0 0 2 3 3 2 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 2
0 0 3 2 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 2 0 2 3 3 3 3
0 0 2 3 3 3 3 3 3 3 3 0 2 0 0 3 3 3 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 2 3 3 3 0 2 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 2 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 2 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 3 3
0 1 1 1 3 3 1 2 1 1 1 0 0 0 0 3 1 1 1 3
0 1 2 1 3 3 1 1 1 2 1 0 0 0 2 3 1 2 1 3
0 1 1 1 3 3 1 1 1 1 1 0 0 0 0 3 1 1 1 3
0 0 3 3 3 3 1 2 1 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 1 1
0 0 1 1 1 3 3 3 3 3 3 0 0 0 0 3 3 3 1 2
0 0 1 2 1 3 1 1 1 3 3 0 0 0 1 1 1 3 1 1
0 1 1 1 1 3 1 2 1 3 3 0 0 2 1 2 1 3 3 3
0 1 2 1 3 3 1 1 1 3 3 0 2 0 1 1 1 3 3 3
0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 1 1 1 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 1 2 1 1 1 0 2 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 1 2 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 2 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 2 1 3 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 2 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0
2 0 2 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 2 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 2 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 3 3 3 3 3 3 3 2 0 0 0
0 0 0 0 0 0 0 0 3 3 2 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 3 3 3 2 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 2 3 3 3 3 3 3 3 2 0 0
```


**output:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 1 1 1 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 1 2 1 3 3 1 1 1 3 3 3 0 0 0 0 0
0 0 0 3 1 1 1 3 3 1 2 1 3 1 1 1 0 0 0 0
0 0 0 3 3 3 3 3 3 1 1 1 3 1 2 1 0 0 0 0
2 0 2 1 1 1 3 3 3 3 3 3 3 1 1 1 0 0 0 0
0 0 0 1 2 1 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 1 1 1 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 1 2 1 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 1 1 1 3 3 3 3 3 1 1 1 0 0
0 0 0 0 0 0 2 0 3 1 1 1 3 3 3 1 2 1 0 0
0 0 0 0 0 0 0 0 3 1 2 1 1 3 3 1 1 1 0 0
0 0 0 0 0 0 0 0 3 1 1 2 1 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 1 1 1 1 1 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 1 2 1 3 3 3 3 3 3 2 0 0
```


## train_3

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 2 0 0 0 0 3 3 3 3 3 2 0 0
0 3 3 3 3 0 0 0 0 3 3 3 3 3 3 0 0
0 3 3 3 3 0 0 0 0 3 2 2 3 3 3 0 0
0 2 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 1 1 1 0 0 0 0 0 0 0 1 1 1 0
0 3 3 1 2 1 0 0 0 3 3 3 3 1 2 1 0
0 3 3 1 1 1 0 0 0 1 1 1 1 1 1 1 0
0 3 3 3 3 0 0 0 0 1 2 2 1 3 3 0 0
0 2 0 0 0 0 0 0 0 1 1 1 1 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```

**Perception**

1.  **Grid Structure:** Both input and output grids have the same dimensions.
2.  **Colors Present:** The primary colors involved are white (0, background), red (2), and green (3) in the input. The output introduces blue (1).
3.  **Key Transformation:** The core change is that some green pixels (3) in the input are changed to blue pixels (1) in the output.
4.  **Unaltered Pixels:** White pixels (0) and red pixels (2) remain unchanged between input and output in all corresponding positions.
5.  **Condition for Change:** The transformation of green to blue seems dependent on the proximity of red pixels. Specifically, a green pixel changes to blue *if and only if* it is directly adjacent (horizontally or vertically, not diagonally) to a red pixel.
6.  **Multiple Red Neighbors:** If a green pixel is adjacent to multiple red pixels, it still changes to blue (there's no cumulative effect or different outcome).
7.  **Objects:** We can consider contiguous blocks of green as objects, and individual red pixels as trigger points or agents causing a change in their immediate green neighbors.

**Facts**


```yaml
Grid:
  - dimensions_match: Input and output grids have identical height and width.
Pixels:
  - type: Background
    color: white (0)
    behavior: Remains unchanged.
  - type: Trigger
    color: red (2)
    behavior: Remains unchanged. Acts as a condition for changing adjacent pixels.
  - type: Target
    color: green (3)
    behavior:
      - Changes to blue (1) if directly adjacent (sharing an edge, not just a corner) to at least one red (2) pixel.
      - Remains green (3) if not directly adjacent to any red (2) pixel.
  - type: Result
    color: blue (1)
    behavior: Appears in the output grid in positions where a green (3) pixel was adjacent to a red (2) pixel in the input grid.
Relationships:
  - Adjacency: Direct horizontal or vertical proximity (sharing an edge) between pixels is the key relationship determining the transformation. Diagonal proximity does not trigger the change.
```


**Natural Language Program**

1.  Create a new grid with the same dimensions as the input grid, initially copying all pixel values from the input.
2.  Iterate through each pixel location (row, column) in the input grid.
3.  For the current pixel at (row, column):
    a.  Check if its color in the input grid is green (3).
    b.  If it is green (3), then examine its direct neighbors (up, down, left, right) within the grid boundaries:
        i.  Check if any of these neighbors have the color red (2) in the input grid.
        ii. If at least one neighbor is red (2), change the color of the pixel at (row, column) in the *new* grid to blue (1).
        iii. If none of the neighbors are red (2), the pixel at (row, column) in the new grid retains its green (3) color (no change needed as it was copied initially).
    c.  If the current pixel's color in the input grid is *not* green (3) (i.e., it's white (0), red (2), or any other color), its value in the new grid remains unchanged (as copied initially).
4.  After checking all pixel locations, the new grid represents the final output.
