{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms input grids by finding azure rectangular blocks and replacing\nthem with a specific multi-colored pattern based on internal coordinates.\nThe pattern has a 2-pixel border with colors determined by quadrants\n(top-left: magenta(6), top-right: blue(1), bottom-left: red(2), bottom-right: green(3))\nand a yellow(4) center.\n\"\"\"\n\ndef find_azure_rectangles(grid):\n    \"\"\"\n    Finds all contiguous rectangular blocks of azure (8) pixels.\n\n    Assumes blocks are solid rectangles, as seen in the examples.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples, where each tuple represents a block's\n        bounding box: (r_min, c_min, height, width).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n    azure_color = 8\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if it's an azure pixel and hasn't been visited yet\n            if grid[r, c] == azure_color and not visited[r, c]:\n                # Found the top-left corner of a potential new block\n                q = [(r, c)]\n                visited[r, c] = True\n                block_coords = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Use Breadth-First Search (BFS) to find all connected azure pixels\n                # belonging to this block and determine its bounds.\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check neighbors (4-directional connectivity is sufficient)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == azure_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            block_coords.add((nr, nc))\n\n                # Calculate height and width from min/max coords\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n\n                # Check if the number of found pixels matches the bounding box area\n                # This confirms it's a solid rectangle (as per examples)\n                if len(block_coords) == height * width:\n                    rectangles.append((min_r, min_c, height, width))\n                # else: handle non-rectangular shapes if necessary, but not needed for this task\n\n    return rectangles\n\n\ndef transform_block(grid, r0, c0, H, W):\n    \"\"\"\n    Applies the color pattern transformation to a specific block within the grid.\n    Modifies the grid in place.\n\n    Args:\n        grid: The numpy array grid to modify.\n        r0: Top row index of the block.\n        c0: Left column index of the block.\n        H: Height of the block.\n        W: Width of the block.\n    \"\"\"\n    # Define colors and border thickness\n    MAGENTA = 6\n    BLUE = 1\n    RED = 2\n    GREEN = 3\n    YELLOW = 4\n    BORDER_THICKNESS = 2\n\n    # Calculate midpoints using integer division\n    mid_h = H // 2 # Midpoint row index (relative to block)\n    mid_w = W // 2 # Midpoint col index (relative to block)\n\n    # Iterate through each pixel within the block's bounding box\n    for r_local in range(H): # Local row index within the block (0 to H-1)\n        for c_local in range(W): # Local col index within the block (0 to W-1)\n            # Calculate global grid coordinates\n            row = r0 + r_local\n            col = c0 + c_local\n            \n            color_to_set = -1 # Default/error color\n\n            # Determine the output color based on local coordinates (r_local, c_local)\n            # The order of these checks is important.\n            if r_local < BORDER_THICKNESS:\n                # Pixel is in the Top border rows (first T rows)\n                color_to_set = MAGENTA if c_local < mid_w else BLUE\n            elif r_local >= H - BORDER_THICKNESS:\n                # Pixel is in the Bottom border rows (last T rows)\n                color_to_set = RED if c_local < mid_w else GREEN\n            elif c_local < BORDER_THICKNESS:\n                # Pixel is in the Left border columns (first T columns)\n                # Excludes pixels already colored by Top/Bottom border checks\n                color_to_set = MAGENTA if r_local < mid_h else RED\n            elif c_local >= W - BORDER_THICKNESS:\n                # Pixel is in the Right border columns (last T columns)\n                # Excludes pixels already colored by Top/Bottom/Left border checks\n                color_to_set = BLUE if r_local < mid_h else GREEN\n            else:\n                # Pixel is in the Central region\n                color_to_set = YELLOW\n\n            # Update the grid pixel with the determined color\n            grid[row, col] = color_to_set\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms input grids by finding azure rectangular blocks and replacing\n    them with a specific multi-colored pattern based on internal coordinates.\n    The pattern has a 2-pixel border with colors determined by quadrants\n    (top-left: magenta(6), top-right: blue(1), bottom-left: red(2), bottom-right: green(3))\n    and a yellow(4) center.\n    \"\"\"\n    # Convert list of lists to numpy array for efficient manipulation\n    input_grid = np.array(input_grid_list, dtype=int)\n    \n    # Initialize output_grid as a copy of the input grid. We will modify this copy.\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find all distinct, contiguous rectangular blocks of azure pixels in the input.\n    azure_blocks = find_azure_rectangles(input_grid)\n\n    # 2. For each identified azure block:\n    for r0, c0, H, W in azure_blocks:\n        # 3. Apply the pattern transformation to this block's area in the output grid.\n        #    The transform_block function modifies output_grid directly.\n        transform_block(output_grid, r0, c0, H, W)\n\n    # 4. Return the modified output grid, converted back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6430,
    "candidates_token_count": 1712,
    "total_token_count": 8142,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 50.182901,
  "retries": null
}