{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify the two non-background colors in the input grid. One color forms an 'outer shape' bordering the background (white, 0), and the other forms an 'inner shape' completely enclosed by the outer shape. Let the inner shape's color be C_inner and the outer shape's color be C_outer.\n\nCount the number of pixels comprising the inner shape. If the count is 1, the expansion thickness T is 1. Otherwise, T is 2.\n\nExpand outwards from the outer shape by T layers. In each expansion layer, find all background pixels (0) adjacent (orthogonally or diagonally) to the current boundary (initially the outer shape, then the outer shape plus previously added layers). Change these adjacent background pixels to the color C_inner. The final grid after T expansion layers is the output.\n\"\"\"\n\ndef find_non_background_colors(grid):\n    \"\"\"Finds the unique non-background colors in the grid.\"\"\"\n    unique_colors = np.unique(grid)\n    return [color for color in unique_colors if color != 0]\n\ndef get_pixel_coordinates(grid, color):\n    \"\"\"Returns a list of (row, col) tuples for pixels of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef is_adjacent(grid, r, c, target_color):\n    \"\"\"Checks if a pixel at (r, c) has an orthogonal neighbor with target_color.\"\"\"\n    rows, cols = grid.shape\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == target_color:\n            return True\n    return False\n\ndef get_adjacent_background_pixels(grid, boundary_coords):\n    \"\"\"Finds background (0) pixels adjacent (8-connectivity) to any coordinate in boundary_coords.\"\"\"\n    rows, cols = grid.shape\n    adjacent_bg_pixels = set()\n    boundary_set = set(boundary_coords) # Faster lookups\n\n    potential_neighbors = set()\n    for r, c in boundary_coords:\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                # Check bounds and if the neighbor is background\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                    potential_neighbors.add((nr, nc))\n\n    # # Recheck adjacency for safety, though logic above should be sufficient\n    # for r, c in potential_neighbors:\n    #     is_truly_adjacent = False\n    #     for dr in [-1, 0, 1]:\n    #         for dc in [-1, 0, 1]:\n    #             if dr == 0 and dc == 0:\n    #                 continue\n    #             nr, nc = r + dr, c + dc\n    #             if (nr, nc) in boundary_set:\n    #                 is_truly_adjacent = True\n    #                 break\n    #     if is_truly_adjacent:\n    #         adjacent_bg_pixels.add((r,c))\n\n\n    return list(potential_neighbors) # return list(adjacent_bg_pixels)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Find non-background colors\n    colors = find_non_background_colors(output_grid)\n    if len(colors) != 2:\n        # Handle error case or assume specific structure if needed\n        print(\"Warning: Expected exactly two non-background colors.\")\n        return output_grid # Or raise an error\n\n    color1, color2 = colors\n    coords1 = get_pixel_coordinates(output_grid, color1)\n    coords2 = get_pixel_coordinates(output_grid, color2)\n\n    # 2. Identify C_inner and C_outer\n    # Outer color will have at least one pixel adjacent to background (0)\n    c_outer = -1\n    c_inner = -1\n    inner_coords = []\n    outer_coords = []\n\n    is_color1_outer = False\n    for r, c in coords1:\n        if is_adjacent(output_grid, r, c, 0):\n            is_color1_outer = True\n            break\n\n    if is_color1_outer:\n        c_outer = color1\n        c_inner = color2\n        outer_coords = coords1\n        inner_coords = coords2\n    else:\n        # Check color2 just to be sure, though by logic it must be outer\n        is_color2_outer = False\n        for r, c in coords2:\n             if is_adjacent(output_grid, r, c, 0):\n                 is_color2_outer = True\n                 break\n        if is_color2_outer:\n             c_outer = color2\n             c_inner = color1\n             outer_coords = coords2\n             inner_coords = coords1\n        else:\n            # This case shouldn't happen based on problem description (outer shape touches background)\n             print(\"Warning: Could not determine outer shape touching background.\")\n             return output_grid # Or raise error\n\n    # 3. Count inner shape pixels\n    inner_shape_pixel_count = len(inner_coords)\n\n    # 4. Determine expansion thickness T\n    thickness = 1 if inner_shape_pixel_count == 1 else 2\n\n    # 5. & 6. Define initial boundary and perform expansion\n    current_boundary_coords = set(outer_coords) # Use set for efficient additions\n\n    for _ in range(thickness):\n        # Find background pixels adjacent to the current boundary\n        pixels_to_color = get_adjacent_background_pixels(output_grid, current_boundary_coords)\n\n        # If no more pixels can be colored, stop early\n        if not pixels_to_color:\n            break\n\n        newly_colored_coords = set()\n        # Change color of these pixels to C_inner\n        for r, c in pixels_to_color:\n            if output_grid[r, c] == 0: # Ensure we only color background\n                output_grid[r, c] = c_inner\n                newly_colored_coords.add((r, c))\n\n        # Update the boundary for the next iteration\n        current_boundary_coords.update(newly_colored_coords)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6292,
    "candidates_token_count": 1586,
    "total_token_count": 7878,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.443046,
  "retries": null
}