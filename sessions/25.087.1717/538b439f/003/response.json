{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies a background color, a single dominant separator line (horizontal or vertical), and target objects (contiguous shapes of other colors).\nTransformation logic depends on the separator's orientation:\n\n1.  **Vertical Separator:** Fills the rectangular area between each target object and the separator line (on the side facing the separator) with the separator's color. The fill occurs within the row span of the target object. Only pixels matching the original background color are changed.\n\n2.  **Horizontal Separator:**\n    *   For target objects BELOW the separator: Fills the rectangular area ABOVE the separator line, within the column span of the object, with the OBJECT's color. Only pixels matching the original background color or noise colors (scattered non-background/non-separator pixels) are changed.\n    *   For target objects ABOVE the separator: Fills the rectangular area BELOW the separator line, within the column span of the object, with the SEPARATOR's color. Only pixels matching the original background color or noise colors are changed.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_separator(grid, background_color):\n    \"\"\"\n    Finds a dominant horizontal or vertical line that is not the background color.\n    Returns (orientation, index, color) or None.\n    Uses a threshold heuristic (default 70% coverage).\n    \"\"\"\n    height, width = grid.shape\n    separator = None\n    threshold_factor = 0.7\n\n    # Check for horizontal lines\n    for r in range(height):\n        row = grid[r, :]\n        counts_non_bg = Counter(c for c in row if c != background_color)\n        # Check if the row consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n            # Check if it covers a significant portion of the width\n            if line_count >= width * threshold_factor:\n                 # Prioritize longer lines if multiple candidates exist\n                current_sep_strength = separator[3] if separator else -1\n                if separator is None or line_count > current_sep_strength:\n                     separator = ('horizontal', r, line_color, line_count)\n\n    # Check for vertical lines\n    for c in range(width):\n        col = grid[:, c]\n        counts_non_bg = Counter(r for r in col if r != background_color)\n        # Check if the column consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n             # Check if it covers a significant portion of the height\n            if line_count >= height * threshold_factor:\n                current_sep_strength = separator[3] if separator else -1\n                # Prioritize longer lines or vertical lines if strengths are equal\n                if line_count > current_sep_strength or \\\n                   (separator and line_count == current_sep_strength and separator[0] == 'horizontal'):\n                    separator = ('vertical', c, line_color, line_count)\n\n    return separator[:3] if separator else None\n\n\ndef find_objects(grid, background_color, separator_color, min_size=1):\n    \"\"\"\n    Finds all contiguous objects of colors other than background and separator.\n    Uses BFS. Filters objects smaller than min_size.\n    Returns a list of tuples: [(color, min_r, max_r, min_c, max_c), ...].\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects_found = []\n    potential_target_colors = set(np.unique(grid)) - {background_color, separator_color}\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color in potential_target_colors and not visited[r, c]:\n                # Start BFS for a new potential object\n                q = [(r, c)]\n                visited[r, c] = True\n                object_pixels = []\n                min_r_obj, max_r_obj, min_c_obj, max_c_obj = r, r, c, c\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    object_pixels.append((row, col))\n                    min_r_obj = min(min_r_obj, row)\n                    max_r_obj = max(max_r_obj, row)\n                    min_c_obj = min(min_c_obj, col)\n                    max_c_obj = max(max_c_obj, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Add object if it meets the minimum size requirement\n                if len(object_pixels) >= min_size:\n                    objects_found.append((color, min_r_obj, max_r_obj, min_c_obj, max_c_obj))\n\n    return objects_found\n\ndef get_noise_colors(grid, background_color, separator_color, target_object_colors):\n    \"\"\"Identifies colors present in the grid that are not background, separator, or part of identified target objects.\"\"\"\n    all_colors = set(np.unique(grid))\n    noise = all_colors - {background_color, separator_color} - set(target_object_colors)\n    return noise\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on separator and target shapes.\n    \"\"\"\n    # Initialize\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Locate the Separator Line\n    separator_info = find_separator(input_grid_np, background_color)\n    if not separator_info:\n        # If no clear separator found, return the original grid\n        return output_grid.tolist()\n    orientation, separator_index, separator_color = separator_info\n\n    # 3. Identify Target Objects (consider min_size=2 to filter noise initially?)\n    # Let's stick with min_size=1 for now and handle noise explicitly if needed.\n    target_objects = find_objects(input_grid_np, background_color, separator_color, min_size=1)\n    if not target_objects:\n        # No target objects found, return original\n        return output_grid.tolist()\n        \n    target_object_colors = {obj[0] for obj in target_objects}\n    noise_colors = get_noise_colors(input_grid_np, background_color, separator_color, target_object_colors)\n\n\n    # 4. Apply Fill Logic based on Orientation\n    if orientation == 'vertical':\n        sep_c = separator_index\n        for obj_color, min_r, max_r, min_c, max_c in target_objects:\n            fill_min_c, fill_max_c = -1, -1\n            # Determine fill range based on object position relative to separator\n            if max_c < sep_c: # Target is left of separator\n                fill_min_c = max_c + 1\n                fill_max_c = sep_c - 1\n            elif min_c > sep_c: # Target is right of separator\n                fill_min_c = sep_c + 1\n                fill_max_c = min_c - 1\n            else: # Target overlaps or touches separator - skip filling for this object\n                continue\n\n            # Ensure fill range is valid\n            if fill_min_c > fill_max_c:\n                continue\n\n            # Fill the region with separator color if it's background\n            for r in range(min_r, max_r + 1):\n                # Clamp row index just in case, though should be within bounds\n                r_clamped = max(0, min(r, height - 1))\n                for c in range(fill_min_c, fill_max_c + 1):\n                     # Clamp column index\n                     c_clamped = max(0, min(c, width - 1))\n                     # Only change background pixels\n                     if output_grid[r_clamped, c_clamped] == background_color:\n                         output_grid[r_clamped, c_clamped] = separator_color\n\n    elif orientation == 'horizontal':\n        sep_r = separator_index\n        for obj_color, min_r, max_r, min_c, max_c in target_objects:\n            # Fill based on object position relative to separator\n            if min_r > sep_r: # Target is BELOW separator\n                fill_color = obj_color\n                fill_min_row = 0\n                fill_max_row = sep_r - 1\n            elif max_r < sep_r: # Target is ABOVE separator\n                fill_color = separator_color\n                fill_min_row = sep_r + 1\n                fill_max_row = height - 1 # Fill all the way down? Or just to object? Analysis says all the way down.\n            else: # Target overlaps or touches separator - skip filling for this object\n                continue\n\n            # Define column bounds for filling\n            fill_min_col = min_c\n            fill_max_col = max_c\n\n            # Fill the region\n            for r in range(fill_min_row, fill_max_row + 1):\n                 # Clamp row index\n                r_clamped = max(0, min(r, height - 1))\n                for c in range(fill_min_col, fill_max_col + 1):\n                     # Clamp column index\n                     c_clamped = max(0, min(c, width - 1))\n                     # Change pixel if it's background OR considered noise\n                     current_pixel_color = output_grid[r_clamped, c_clamped]\n                     if current_pixel_color == background_color or current_pixel_color in noise_colors:\n                         output_grid[r_clamped, c_clamped] = fill_color\n\n    # 5. Return the modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16753,
    "candidates_token_count": 2632,
    "total_token_count": 19385,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.858111,
  "retries": null
}