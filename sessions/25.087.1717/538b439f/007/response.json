{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies a background color, a dominant separator line (horizontal or vertical), and distinct objects. The specific transformation depends on the separator's orientation:\n\n1.  **Vertical Separator:**\n    *   Identifies \"significant\" objects (contiguous shapes of non-background, non-separator color with size >= 3).\n    *   For each significant object, it finds the vertical range (min_r to max_r) of the object.\n    *   It then identifies the horizontal range of columns strictly *between* the object's edge and the separator line.\n    *   Within this vertical and horizontal range (forming a rectangle), it fills any pixels matching the original background color with the *separator's color*.\n\n2.  **Horizontal Separator:**\n    *   Identifies all contiguous objects (including size 1) of non-background, non-separator color.\n    *   Focuses only on objects located *below* the separator line.\n    *   Iterates through each column of the grid.\n    *   For a given column `c`:\n        *   Checks if any Green (3) object exists *below* the separator and spans column `c`.\n        *   If yes, it fills the portion of column `c` *above* the separator line (from row 0 to `separator_index - 1`) with Green (3), but only modifies pixels that were originally the background color.\n        *   If no Green object exists below in column `c`, it then checks if any Blue (1) object exists *below* the separator and spans column `c`.\n        *   If yes, it fills the portion of column `c` *above* the separator line with the *separator's color*, again only modifying background pixels.\n    *   Objects located *above* the separator line do not influence the output.\n\"\"\"\n\n# Helper function to find the most frequent color, assumed to be the background\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\n# Helper function to find a dominant separator line\ndef find_separator(grid, background_color):\n    \"\"\"\n    Finds a dominant horizontal or vertical line that is not the background color.\n    Returns (orientation, index, color) or None.\n    Uses a threshold heuristic (default 70% coverage).\n    \"\"\"\n    height, width = grid.shape\n    separator = None\n    # Heuristic threshold: a line must cover at least this fraction of the dimension\n    threshold_factor = 0.7\n\n    # Check for horizontal lines\n    best_h_line = (-1, -1, -1) # index, color, count\n    for r in range(height):\n        row = grid[r, :]\n        counts_non_bg = Counter(c for c in row if c != background_color)\n        # Check if the row consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n            # Check if it covers a significant portion of the width\n            if line_count >= width * threshold_factor:\n                # Prioritize longer lines\n                if line_count > best_h_line[2]:\n                    best_h_line = (r, line_color, line_count)\n\n    # Check for vertical lines\n    best_v_line = (-1, -1, -1) # index, color, count\n    for c in range(width):\n        col = grid[:, c]\n        counts_non_bg = Counter(r for r in col if r != background_color)\n        # Check if the column consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n             # Check if it covers a significant portion of the height\n            if line_count >= height * threshold_factor:\n                 # Prioritize longer lines\n                if line_count > best_v_line[2]:\n                     best_v_line = (c, line_color, line_count)\n\n    # Determine the best separator (prefer vertical if counts are equal and both exist)\n    h_idx, h_color, h_count = best_h_line\n    v_idx, v_color, v_count = best_v_line\n\n    if h_count > 0 and h_count > v_count:\n        separator = ('horizontal', h_idx, h_color)\n    elif v_count > 0 and v_count >= h_count: # Prefer vertical if counts equal or greater\n        separator = ('vertical', v_idx, v_color)\n    else:\n        separator = None # No dominant line found\n\n    #print(f\"Separator Found: {separator}\") # Debug print\n    return separator\n\n# Helper function to find contiguous objects using Breadth-First Search (BFS)\ndef find_objects(grid, background_color, separator_color):\n    \"\"\"\n    Finds all contiguous objects of colors other than background and separator.\n    Uses BFS.\n    Returns a list of tuples: [(color, set_of_pixels, min_r, max_r, min_c, max_c), ...].\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects_found = []\n    potential_target_colors = set(np.unique(grid)) - {background_color}\n    if separator_color is not None:\n        potential_target_colors -= {separator_color}\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited pixel of a potential target color\n            if color in potential_target_colors and not visited[r, c]:\n                q = [(r, c)]\n                visited[r, c] = True\n                object_pixels = set()\n                min_r_obj, max_r_obj, min_c_obj, max_c_obj = r, r, c, c\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    object_pixels.add((row, col))\n                    min_r_obj = min(min_r_obj, row)\n                    max_r_obj = max(max_r_obj, row)\n                    min_c_obj = min(min_c_obj, col)\n                    max_c_obj = max(max_c_obj, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Store the found object\n                objects_found.append((color, object_pixels, min_r_obj, max_r_obj, min_c_obj, max_c_obj))\n\n    #print(f\"Objects Found: {len(objects_found)}\") # Debug print\n    #for o in objects_found: print(f\"  Color: {o[0]}, Size: {len(o[1])}, Bounds: ({o[2]}-{o[3]}, {o[4]}-{o[5]})\") # Debug\n    return objects_found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules derived from examples.\n    Handles vertical and horizontal separator cases differently.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n    #print(f\"Background Color: {background_color}\") # Debug print\n\n    # 2. Locate the Separator Line\n    separator_info = find_separator(input_grid_np, background_color)\n    if not separator_info:\n        # If no clear separator found, return the original grid\n        #print(\"No separator found.\") # Debug\n        return output_grid.tolist()\n    orientation, separator_index, separator_color = separator_info\n\n    # 3. Find all objects (excluding background and separator)\n    all_objects = find_objects(input_grid_np, background_color, separator_color)\n    if not all_objects:\n        # No target objects found, return original\n        #print(\"No target objects found.\") # Debug\n        return output_grid.tolist()\n\n    # 4. Apply Transformation Logic based on Orientation\n    if orientation == 'vertical':\n        sep_c = separator_index\n        # Filter for significant objects (size >= 3) for vertical case\n        significant_objects = [obj for obj in all_objects if len(obj[1]) >= 3]\n        #print(f\"Processing Vertical Separator at c={sep_c}, color={separator_color}. Significant Objects: {len(significant_objects)}\") #Debug\n\n        for obj_color, pixels, min_r, max_r, min_c, max_c in significant_objects:\n            #print(f\"  Processing obj: Color={obj_color}, Size={len(pixels)}, Bounds=({min_r}-{max_r}, {min_c}-{max_c})\") # Debug\n            # Determine fill range columns based on object position relative to separator\n            fill_min_c, fill_max_c = -1, -1\n            if max_c < sep_c: # Target is left of separator\n                fill_min_c = max_c + 1\n                fill_max_c = sep_c - 1\n                #print(f\"    Object left of separator. Fill columns: {fill_min_c} to {fill_max_c}\") # Debug\n            elif min_c > sep_c: # Target is right of separator\n                fill_min_c = sep_c + 1\n                fill_max_c = min_c - 1\n                #print(f\"    Object right of separator. Fill columns: {fill_min_c} to {fill_max_c}\") # Debug\n            else: # Target overlaps or touches separator - skip filling for this object\n                #print(f\"    Object overlaps/touches separator. Skipping fill.\") # Debug\n                continue\n\n            # Ensure fill range is valid and within grid bounds\n            fill_min_c = max(0, fill_min_c)\n            fill_max_c = min(width - 1, fill_max_c)\n\n            if fill_min_c > fill_max_c:\n                #print(f\"    Invalid fill range after bounds check. Skipping.\") # Debug\n                continue\n\n            # Fill the rectangular region with separator color if it's background\n            for r in range(min_r, max_r + 1):\n                # Check row bounds just in case\n                if 0 <= r < height:\n                    for c in range(fill_min_c, fill_max_c + 1):\n                         # Check col bounds (redundant given loop range, but safe)\n                         if 0 <= c < width:\n                             # Only change background pixels\n                             if output_grid[r, c] == background_color:\n                                 output_grid[r, c] = separator_color\n                                 #print(f\"      Filling ({r}, {c}) with {separator_color}\") # Debug\n\n\n    elif orientation == 'horizontal':\n        sep_r = separator_index\n        # Consider only objects BELOW the separator\n        objects_below = [obj for obj in all_objects if obj[2] > sep_r] # obj[2] is min_r\n        #print(f\"Processing Horizontal Separator at r={sep_r}, color={separator_color}. Objects below: {len(objects_below)}\") # Debug\n\n        # Determine fill color for each column above the separator\n        # Iterate through columns 0 to width-1\n        for c in range(width):\n            fill_color_for_col = None # Default: no fill\n            has_green_below_in_col = False\n            has_blue_below_in_col = False\n\n            # Check objects below the separator that span this column 'c'\n            for obj_color, pixels, min_r_obj, max_r_obj, min_c_obj, max_c_obj in objects_below:\n                if min_c_obj <= c <= max_c_obj: # Object spans this column\n                    #print(f\"  Col {c}: Found object below: Color={obj_color}, Bounds=({min_r_obj}-{max_r_obj}, {min_c_obj}-{max_c_obj})\") # Debug\n                    if obj_color == 3: # Green\n                        has_green_below_in_col = True\n                        #print(f\"    Found GREEN below in col {c}\") # Debug\n                        break # Green takes priority for this column\n                    elif obj_color == 1: # Blue\n                        #print(f\"    Found BLUE below in col {c}\") # Debug\n                        has_blue_below_in_col = True\n                        # Don't break, need to check if there's also a green one further down the list\n\n            # Determine fill color based on findings for this specific column\n            if has_green_below_in_col:\n                fill_color_for_col = 3 # Green\n                #print(f\"  Col {c}: Setting fill color to GREEN (3)\") # Debug\n            elif has_blue_below_in_col:\n                fill_color_for_col = separator_color # Use separator color for blue\n                #print(f\"  Col {c}: Setting fill color to Separator Color ({separator_color})\") # Debug\n            #else:\n                #print(f\"  Col {c}: No Green or Blue found below. No fill.\") # Debug\n\n            # If a fill color was determined, fill this column 'c' above the separator\n            if fill_color_for_col is not None:\n                for r in range(sep_r): # Rows 0 to sep_r - 1\n                    # Check bounds (should be fine)\n                    if 0 <= r < height and 0 <= c < width:\n                        # Only change background pixels\n                        if output_grid[r, c] == background_color:\n                            output_grid[r, c] = fill_color_for_col\n                            #print(f\"    Filling ({r}, {c}) with {fill_color_for_col}\") # Debug\n\n\n    # 5. Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8667,
    "candidates_token_count": 3553,
    "total_token_count": 12220,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 205.105403,
  "retries": null
}