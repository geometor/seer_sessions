{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies a background color, a dominant separator line (horizontal or vertical), and distinct objects. The specific transformation depends on the separator's orientation:\n\n1.  **Vertical Separator:**\n    *   Identifies \"significant\" objects (contiguous shapes of non-background, non-separator color with size >= 3).\n    *   For each significant object, it fills the rectangular area between the object's vertical extent and the separator line with the *separator's color*.\n    *   This fill only occurs within the horizontal row span of the object.\n    *   Only pixels matching the original background color are modified.\n\n2.  **Horizontal Separator:**\n    *   Identifies all contiguous objects (including size 1) of non-background, non-separator color.\n    *   Focuses only on objects located *below* the separator line.\n    *   For each column spanned by an object below the line:\n        *   It fills the portion of that column *above* the separator line (from the top edge down to the separator).\n        *   The fill color depends on the color of the object(s) below the separator in that column:\n            *   If any Green (3) object exists below the separator in that column, the fill color is Green (3).\n            *   Otherwise, if any Blue (1) object exists below the separator in that column, the fill color is the *separator's color*.\n        *   Only pixels matching the original background color are modified.\n    *   Objects located *above* the separator line do not influence the output.\n\"\"\"\n\n# Helper function to find the most frequent color, assumed to be the background\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\n# Helper function to find a dominant separator line\ndef find_separator(grid, background_color):\n    \"\"\"\n    Finds a dominant horizontal or vertical line that is not the background color.\n    Returns (orientation, index, color) or None.\n    Uses a threshold heuristic (default 70% coverage).\n    \"\"\"\n    height, width = grid.shape\n    separator = None\n    # Heuristic threshold: a line must cover at least this fraction of the dimension\n    threshold_factor = 0.7 \n\n    # Check for horizontal lines\n    best_h_line = (-1, -1, -1) # index, color, count\n    for r in range(height):\n        row = grid[r, :]\n        counts_non_bg = Counter(c for c in row if c != background_color)\n        # Check if the row consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n            # Check if it covers a significant portion of the width\n            if line_count >= width * threshold_factor:\n                # Prioritize longer lines\n                if line_count > best_h_line[2]:\n                    best_h_line = (r, line_color, line_count)\n\n    # Check for vertical lines\n    best_v_line = (-1, -1, -1) # index, color, count\n    for c in range(width):\n        col = grid[:, c]\n        counts_non_bg = Counter(r for r in col if r != background_color)\n        # Check if the column consists predominantly of one non-background color\n        if len(counts_non_bg) == 1:\n            line_color = list(counts_non_bg.keys())[0]\n            line_count = counts_non_bg[line_color]\n             # Check if it covers a significant portion of the height\n            if line_count >= height * threshold_factor:\n                 # Prioritize longer lines\n                if line_count > best_v_line[2]:\n                     best_v_line = (c, line_color, line_count)\n\n    # Determine the best separator (prefer vertical if counts are equal and both exist)\n    h_idx, h_color, h_count = best_h_line\n    v_idx, v_color, v_count = best_v_line\n\n    if h_count > v_count and h_count > 0:\n        separator = ('horizontal', h_idx, h_color)\n    elif v_count >= h_count and v_count > 0: # Prefer vertical if counts equal\n        separator = ('vertical', v_idx, v_color)\n    else:\n        separator = None # No dominant line found\n\n    return separator\n\n# Helper function to find contiguous objects using Breadth-First Search (BFS)\ndef find_objects(grid, background_color, separator_color):\n    \"\"\"\n    Finds all contiguous objects of colors other than background and separator.\n    Uses BFS.\n    Returns a list of tuples: [(color, set_of_pixels, min_r, max_r, min_c, max_c), ...].\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects_found = []\n    potential_target_colors = set(np.unique(grid)) - {background_color}\n    if separator_color is not None:\n        potential_target_colors -= {separator_color}\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited pixel of a potential target color\n            if color in potential_target_colors and not visited[r, c]:\n                q = [(r, c)]\n                visited[r, c] = True\n                object_pixels = set()\n                min_r_obj, max_r_obj, min_c_obj, max_c_obj = r, r, c, c\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    object_pixels.add((row, col))\n                    min_r_obj = min(min_r_obj, row)\n                    max_r_obj = max(max_r_obj, row)\n                    min_c_obj = min(min_c_obj, col)\n                    max_c_obj = max(max_c_obj, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object\n                objects_found.append((color, object_pixels, min_r_obj, max_r_obj, min_c_obj, max_c_obj))\n\n    return objects_found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules derived from examples.\n    Handles vertical and horizontal separator cases differently.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Locate the Separator Line\n    separator_info = find_separator(input_grid_np, background_color)\n    if not separator_info:\n        # If no clear separator found, return the original grid\n        return output_grid.tolist()\n    orientation, separator_index, separator_color = separator_info\n\n    # 3. Find all objects\n    all_objects = find_objects(input_grid_np, background_color, separator_color)\n    if not all_objects:\n        # No target objects found, return original\n        return output_grid.tolist()\n\n    # 4. Apply Transformation Logic based on Orientation\n    if orientation == 'vertical':\n        sep_c = separator_index\n        # Filter for significant objects (size >= 3) for vertical case\n        significant_objects = [obj for obj in all_objects if len(obj[1]) >= 3]\n\n        for obj_color, pixels, min_r, max_r, min_c, max_c in significant_objects:\n            # Determine fill range based on object position relative to separator\n            fill_min_c, fill_max_c = -1, -1\n            if max_c < sep_c: # Target is left of separator\n                fill_min_c = max_c + 1\n                fill_max_c = sep_c - 1\n            elif min_c > sep_c: # Target is right of separator\n                fill_min_c = sep_c + 1\n                fill_max_c = min_c - 1\n            else: # Target overlaps or touches separator - skip filling for this object\n                continue\n\n            # Ensure fill range is valid\n            if fill_min_c > fill_max_c:\n                continue\n\n            # Fill the region with separator color if it's background\n            for r in range(min_r, max_r + 1):\n                # Check bounds just in case (should be fine)\n                if 0 <= r < height:\n                    for c in range(fill_min_c, fill_max_c + 1):\n                         # Check bounds\n                         if 0 <= c < width:\n                             # Only change background pixels\n                             if output_grid[r, c] == background_color:\n                                 output_grid[r, c] = separator_color\n\n    elif orientation == 'horizontal':\n        sep_r = separator_index\n        # Consider only objects BELOW the separator\n        objects_below = [obj for obj in all_objects if obj[2] > sep_r]\n\n        # Determine fill color for each column above the separator\n        # Iterate through columns 0 to width-1\n        for c in range(width):\n            fill_color_for_col = None # Default: no fill\n            has_green_below = False\n            has_blue_below = False\n\n            # Check objects below the separator that span this column\n            for obj_color, pixels, min_r, max_r, min_c, max_c in objects_below:\n                if min_c <= c <= max_c: # Object spans this column\n                    if obj_color == 3: # Green\n                        has_green_below = True\n                        break # Green takes priority\n                    elif obj_color == 1: # Blue\n                        has_blue_below = True\n                        # Don't break, check if there's a green one\n\n            # Determine fill color based on findings\n            if has_green_below:\n                fill_color_for_col = 3 # Green\n            elif has_blue_below:\n                fill_color_for_col = separator_color # Use separator color for blue\n\n            # If a fill color was determined, fill the column above the separator\n            if fill_color_for_col is not None:\n                for r in range(sep_r): # Rows 0 to sep_r - 1\n                    # Check bounds (should be fine)\n                    if 0 <= r < height and 0 <= c < width:\n                        # Only change background pixels\n                        if output_grid[r, c] == background_color:\n                            output_grid[r, c] = fill_color_for_col\n\n    # 5. Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8485,
    "candidates_token_count": 2802,
    "total_token_count": 11287,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 136.295072,
  "retries": null
}