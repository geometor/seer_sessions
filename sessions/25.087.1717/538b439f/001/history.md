
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 8 8 8 2 2 2 2 2 1 2 2 4 2 2 2 2 2 2 2
2 8 8 8 2 2 2 2 2 1 2 4 2 2 2 4 2 2 2 2
2 8 8 8 2 2 2 4 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 2 4 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 4 2 2 2 2
2 2 2 2 2 4 2 2 2 1 2 2 2 2 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 8 8 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 8 8 8 8 2 2 1 2 2 2 2 2 2 2 2 2 2
2 4 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 8 8 8 1 1 1 1 1 1 1 1 1 1 1 8 8 8 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
4 2 2 2 4 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 4 2 2 2 2
2 2 2 2 2 4 2 2 2 1 2 2 2 2 4 4 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 8 8 8 8 1 1 1 1 1 8 8 8 8 2 2 2 2
4 2 2 8 8 8 8 1 1 1 1 1 8 8 8 8 2 2 2 2
2 4 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 2 2 1 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8
8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8
8 8 8 8 1 8 8 1 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8
8 1 8 8 8 8 8 1 8 8 8 1 8 8 8 8 8 8
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 1
8 8 8 8 1 8 8 1 8 8 1 8 8 8 8 8 8 8
1 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 1 8
8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 8 1 8 8 1 8 3 3 3 8 1 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8
1 8 8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 1 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 1 8
8 2 2 8 8 8 8 8 8 2 2 2 8 1 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 8 8 8 8 1 8
8 2 2 8 1 8 8 1 8 2 2 2 8 8 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 1 8 8 8 8 8
8 2 2 8 8 8 8 1 8 2 2 2 8 8 8 8 8 8
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 2 2 8 1 1 8 8 8 2 2 2 8 8 8 8 8 1
8 2 2 8 1 8 8 1 8 2 2 2 8 8 8 8 8 8
1 2 2 8 8 8 8 1 8 2 2 2 8 8 8 8 1 8
8 2 2 8 8 8 8 8 8 2 2 2 1 8 8 8 8 8
8 2 2 8 8 8 8 8 8 2 2 2 8 8 8 8 8 8
8 3 3 8 1 8 8 1 8 3 3 3 8 1 8 8 8 8
8 3 3 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 1 8 8 8 8
1 8 8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 1 8 8
```

Okay, let's break down the task based on the provided examples.

**Perception of Task Elements:**

1.  **Grid Structure:** Both examples involve a grid with a background color, a prominent line (separator), and distinct shapes (targets) of another color. Other scattered pixels might exist but seem unaffected by the main transformation.
2.  **Separator Line:** In `train_1`, there's a vertical blue line. In `train_2`, there's a horizontal red line. This line acts as a reference boundary.
3.  **Target Shapes:** In `train_1`, the targets are azure shapes. In `train_2`, the targets are green shapes. These shapes determine the regions to be filled.
4.  **Filling Action:** The core transformation involves filling rectangular areas based on the relative positions of the target shapes and the separator line. The fill color depends on which side of the separator the fill occurs and the orientation of the separator.
5.  **Color Interaction:**
    *   Vertical Separator (`train_1`): The area *between* a target shape and the separator line is filled with the *separator's color* (blue).
    *   Horizontal Separator (`train_2`): The area *above* the separator, aligned horizontally with a target shape, is filled with the *target's color* (green). The area *below* the separator, aligned horizontally with a target shape, is filled with the *separator's color* (red).
6.  **Fill Boundaries:**
    *   For a vertical separator, the fill happens within the row span of the target shape and the column span between the shape's edge and the separator.
    *   For a horizontal separator, the fill happens within the column span of the target shape. Vertically, the fill extends from the grid edge to the separator (or separator to grid edge, adjusted). Specifically, in `train_2`, the fill below the separator seems to stop just before the target shape starts (row `separator_index + 1` to `target_min_row - 1`).

**YAML Fact Document:**


```yaml
task_description: Fill regions based on a separator line and target shapes.

elements:
  - type: grid
    properties:
      - background_color: The most frequent color in the input grid (red in train_1, azure in train_2).
  - type: line
    id: separator
    properties:
      - orientation: horizontal or vertical
      - color: color of the line (blue in train_1, red in train_2)
      - index: row or column index of the line
      - continuous: Yes
      - span: Extends across most of the grid dimension perpendicular to its orientation.
  - type: object_group
    id: targets
    properties:
      - object_type: contiguous shape
      - color: color of the shapes (azure in train_1, green in train_2)
      - count: can be one or more
      - location: defined by bounding box (min_row, max_row, min_col, max_col)

actions:
  - name: identify_elements
    inputs: [input_grid]
    outputs: [background_color, separator, targets]
  - name: calculate_fill_regions
    inputs: [separator, targets, grid_dimensions]
    outputs: [list_of_fill_operations] # Each operation specifies: region_bounds, fill_color
    logic:
      - Depends on separator orientation:
        - If vertical:
          - For each target: Determine if left/right of separator. Define fill region between target's vertical edge and separator, within target's row span. Fill color is separator's color.
        - If horizontal:
          - For each target: Define fill region above separator (rows 0 to sep_row-1, target col span). Fill color is target's color. Define fill region below separator (rows sep_row+1 to target_min_row-1, target col span). Fill color is separator's color.
  - name: apply_fill
    inputs: [input_grid, list_of_fill_operations, background_color]
    outputs: [output_grid]
    logic:
      - Create a copy of the input grid.
      - For each fill operation: Iterate through pixels in the specified region_bounds. If a pixel's color matches the background_color, change it to the specified fill_color.

relationships:
  - The fill regions are geometrically defined by the positions (bounding boxes) of the target shapes relative to the separator line.
  - The fill color depends on the separator's color, the target's color, and the position of the fill relative to the separator.
  - The fill operation only modifies pixels that originally had the background color. Separator, targets, and other pixels remain unchanged.
```


**Natural Language Program:**

1.  **Identify** the primary background color of the input grid.
2.  **Locate** a continuous, prominent horizontal or vertical line (the "separator"). Note its color (`separator_color`), orientation (horizontal/vertical), and index (row or column number, `separator_index`).
3.  **Identify** all distinct, contiguous shapes composed of a single color that is neither the background color nor the separator color (the "targets"). Note the color of these shapes (`target_color`) and determine the bounding box (`min_row`, `max_row`, `min_col`, `max_col`) for each target shape.
4.  **Initialize** the output grid as a copy of the input grid.
5.  **If** the separator is vertical:
    *   For each target shape:
        *   If the target shape is to the left of the separator (`max_col < separator_index`): Define the fill region by rows `min_row` to `max_row` and columns `max_col + 1` to `separator_index - 1`. The `fill_color` is the `separator_color`.
        *   If the target shape is to the right of the separator (`min_col > separator_index`): Define the fill region by rows `min_row` to `max_row` and columns `separator_index + 1` to `min_col - 1`. The `fill_color` is the `separator_color`.
        *   Fill the defined region in the output grid with the `fill_color`, but only changing pixels that originally had the background color.
6.  **Else if** the separator is horizontal:
    *   For each target shape:
        *   Define the "above" fill region by rows `0` to `separator_index - 1` and columns `min_col` to `max_col`. The `fill_color` for this region is the `target_color`.
        *   Define the "below" fill region by rows `separator_index + 1` to `min_row - 1` and columns `min_col` to `max_col`. The `fill_color` for this region is the `separator_color`.
        *   Fill the "above" region in the output grid with its `fill_color`, only changing original background pixels.
        *   Fill the "below" region in the output grid with its `fill_color`, only changing original background pixels.
7.  **Return** the modified output grid.
