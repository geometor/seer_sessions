{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies a primary background color, a single dominant horizontal or vertical separator line, and one or more 'target' shapes of a distinct color.\nBased on the separator's orientation:\n- If vertical: Fills the rectangular area between each target shape and the separator line (on the side facing the separator) with the separator's color. The fill occurs within the row span of the target shape. Only pixels matching the original background color are changed.\n- If horizontal: Fills the rectangular area above the separator line, within the column span of each target shape, with the target shapes' color. Fills the rectangular area below the separator line but above the target shape, within the column span of the target shape, with the separator's color. Only pixels matching the original background color are changed.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid case if necessary, though ARC constraints likely prevent it\n    if not counts:\n        return 0 # Default to black/white if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_separator(grid, background_color):\n    \"\"\"\n    Finds a dominant horizontal or vertical line that is not the background color.\n    Returns (orientation, index, color) or None.\n    \"\"\"\n    height, width = grid.shape\n    separator = None\n\n    # Check for horizontal lines\n    for r in range(height):\n        row = grid[r, :]\n        counts = Counter(c for c in row if c != background_color)\n        if len(counts) == 1:\n            line_color = list(counts.keys())[0]\n            line_count = counts[line_color]\n            # Heuristic: Line covers most of the width\n            if line_count > width * 0.7: # Threshold for dominance\n                 # Prioritize longer lines if multiple candidates exist\n                if separator is None or line_count > separator[3]:\n                     separator = ('horizontal', r, line_color, line_count)\n\n\n    # Check for vertical lines\n    for c in range(width):\n        col = grid[:, c]\n        counts = Counter(r for r in col if r != background_color)\n        if len(counts) == 1:\n            line_color = list(counts.keys())[0]\n            line_count = counts[line_color]\n            # Heuristic: Line covers most of the height\n            if line_count > height * 0.7: # Threshold for dominance\n                 # Prioritize longer lines, consider vertical preference if lengths equal?\n                 # If a horizontal separator was already found, compare lengths\n                 if separator is None or line_count > separator[3] or (line_count == separator[3] and separator[0] == 'horizontal'):\n                    separator = ('vertical', c, line_color, line_count)\n\n    return separator[:3] if separator else None\n\ndef find_objects(grid, target_color):\n    \"\"\"\n    Finds all contiguous objects of a specific color using BFS.\n    Returns a list of bounding boxes [(min_r, max_r, min_c, max_c), ...].\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects_bboxes = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new object\n                q = [(r, c)]\n                visited[r, c] = True\n                object_pixels = []\n                min_r, max_r, min_c, max_c = r, r, c, c\n                \n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    object_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if object_pixels: # Should always be true here\n                    objects_bboxes.append((min_r, max_r, min_c, max_c))\n                    \n    return objects_bboxes\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on separator and target shapes.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify background color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Locate the separator line\n    separator_info = find_separator(input_grid_np, background_color)\n    if not separator_info:\n        # If no clear separator found, return the original grid\n        return output_grid.tolist() \n    \n    orientation, separator_index, separator_color = separator_info\n\n    # 3. Identify target color and target objects\n    target_color = -1 # Placeholder\n    potential_target_colors = set(input_grid_np.flatten()) - {background_color, separator_color}\n    if not potential_target_colors:\n         # No target colors found, return original\n         return output_grid.tolist()\n    # Assume the first non-background, non-separator color encountered is the target color\n    # A more robust approach might analyze object sizes or shapes if multiple candidates exist.\n    # For these examples, taking the first one seems sufficient.\n    # Let's find objects of the first potential target color.\n    \n    target_color = list(potential_target_colors)[0] # Choose one potential color\n    target_bboxes = find_objects(input_grid_np, target_color)\n\n    # If no objects of the chosen color, try another potential color?\n    # For now, assume the first potential color is the correct one based on examples.\n    if not target_bboxes:\n        # Check if there are other potential target colors\n        if len(potential_target_colors) > 1:\n             target_color = list(potential_target_colors)[1]\n             target_bboxes = find_objects(input_grid_np, target_color)\n             if not target_bboxes:\n                 return output_grid.tolist() # Still no targets, return original\n        else:\n             return output_grid.tolist() # No targets found at all\n\n    # 4. Apply fill logic based on orientation\n    if orientation == 'vertical':\n        sep_c = separator_index\n        for min_r, max_r, min_c, max_c in target_bboxes:\n            if max_c < sep_c: # Target is left of separator\n                fill_min_c = max_c + 1\n                fill_max_c = sep_c - 1\n            elif min_c > sep_c: # Target is right of separator\n                fill_min_c = sep_c + 1\n                fill_max_c = min_c - 1\n            else: # Target overlaps or touches separator - skip filling?\n                continue \n\n            # Fill the region\n            for r in range(min_r, max_r + 1):\n                for c in range(fill_min_c, fill_max_c + 1):\n                    # Ensure indices are valid (though ranges should be correct)\n                    if 0 <= r < height and 0 <= c < width:\n                        # Only change background pixels\n                        if output_grid[r, c] == background_color:\n                            output_grid[r, c] = separator_color\n\n    elif orientation == 'horizontal':\n        sep_r = separator_index\n        for min_r, max_r, min_c, max_c in target_bboxes:\n            # Fill above separator with target color\n            fill_min_r_above = 0\n            fill_max_r_above = sep_r - 1\n            for r in range(fill_min_r_above, fill_max_r_above + 1):\n                 for c in range(min_c, max_c + 1):\n                     if 0 <= r < height and 0 <= c < width:\n                         if output_grid[r, c] == background_color:\n                             output_grid[r, c] = target_color\n\n            # Fill below separator (but above target) with separator color\n            fill_min_r_below = sep_r + 1\n            fill_max_r_below = min_r - 1 # Fill up to the row just before the target starts\n            for r in range(fill_min_r_below, fill_max_r_below + 1):\n                 for c in range(min_c, max_c + 1):\n                      if 0 <= r < height and 0 <= c < width:\n                         if output_grid[r, c] == background_color:\n                             output_grid[r, c] = separator_color\n\n    # 5. Return the modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5827,
    "candidates_token_count": 2291,
    "total_token_count": 8118,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.6172,
  "retries": null
}