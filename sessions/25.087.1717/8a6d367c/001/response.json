{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom collections import deque\n\n\"\"\"\nIdentifies the largest hollow rectangular frame of a single non-background color in the input grid and extracts the subgrid defined by its bounding box.\n\n1. Determine the background color (most frequent color).\n2. Find all connected objects of non-background colors.\n3. For each object, check if it forms a hollow rectangle:\n    a. All pixels of the object must lie on the perimeter of its bounding box.\n    b. The interior area defined by the bounding box must not contain any pixels of the object's color.\n4. Identify the hollow rectangle object whose bounding box encloses the largest area.\n5. Extract the subgrid corresponding to the bounding box of this largest hollow rectangle.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all connected objects of non-background colors using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore (background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with 'coords' (set of tuples)\n              and 'color' (int).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel is not background and not visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_coords.add((curr_r, curr_c))\n\n                    # Explore neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds and if neighbor is the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({'coords': obj_coords, 'color': obj_color})\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box (min/max row/col) for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef is_hollow_rectangle(grid, obj_color, obj_coords, bbox):\n    \"\"\"\n    Checks if an object forms a hollow rectangle within its bounding box.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_color (int): The color of the object being checked.\n        obj_coords (set): The coordinates of the object pixels.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n\n    Returns:\n        bool: True if the object is a hollow rectangle, False otherwise.\n    \"\"\"\n    if bbox is None:\n        return False\n    min_r, min_c, max_r, max_c = bbox\n    width = max_c - min_c + 1\n    height = max_r - min_r + 1\n\n    # Basic check: must have width and height > 1 to be hollow\n    if width <= 1 or height <= 1:\n        return False\n\n    # Check 1: All object pixels must lie on the perimeter\n    for r, c in obj_coords:\n        if not (r == min_r or r == max_r or c == min_c or c == max_c):\n            return False # Pixel is inside, not on perimeter\n\n    # Check 2: All perimeter pixels within the bbox *must* belong to the object\n    perimeter_coords = set()\n    for r in range(min_r, max_r + 1):\n        perimeter_coords.add((r, min_c))\n        perimeter_coords.add((r, max_c))\n    for c in range(min_c + 1, max_c): # Avoid double counting corners\n        perimeter_coords.add((min_r, c))\n        perimeter_coords.add((max_r, c))\n\n    if obj_coords != perimeter_coords:\n         # Check if all pixels on the perimeter match the object color in the grid\n         for pr, pc in perimeter_coords:\n             if grid[pr, pc] != obj_color:\n                 return False # A perimeter pixel doesn't match the object color\n         # Check if all object coordinates are actually on the defined perimeter\n         if not obj_coords.issubset(perimeter_coords):\n             return False # Some object coordinates are outside the calculated perimeter (shouldn't happen if bbox is correct)\n         # Check if the number of object coordinates matches the number of perimeter coordinates\n         # This handles cases where the object is *part* of the perimeter but doesn't fill it completely\n         if len(obj_coords) != len(perimeter_coords):\n             return False\n\n\n    # Check 3: Ensure the inside is not the object color (Hollow condition)\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            if grid[r, c] == obj_color:\n                return False # Found object color inside the frame\n\n    return True\n\n\ndef transform(input_grid):\n    \"\"\"\n    Finds the largest hollow rectangular frame in the input grid and extracts\n    the subgrid defined by its bounding box.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    np_grid = np.array(input_grid, dtype=int)\n    rows, cols = np_grid.shape\n\n    # 1. Identify background color (most frequent color)\n    colors, counts = np.unique(np_grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find all distinct connected objects (non-background)\n    objects = find_objects(np_grid, background_color)\n\n    # 3. Filter for hollow rectangles and find the largest\n    largest_frame_bbox = None\n    max_area = -1\n\n    for obj in objects:\n        coords = obj['coords']\n        color = obj['color']\n        bbox = get_bounding_box(coords)\n\n        if bbox:\n            # Check if it's a hollow rectangle\n            if is_hollow_rectangle(np_grid, color, coords, bbox):\n                min_r, min_c, max_r, max_c = bbox\n                area = (max_r - min_r + 1) * (max_c - min_c + 1)\n                # Keep track of the largest one found so far\n                if area > max_area:\n                    max_area = area\n                    largest_frame_bbox = bbox\n\n    # 4. Extract the subgrid defined by the largest frame's bounding box\n    if largest_frame_bbox:\n        min_r, min_c, max_r, max_c = largest_frame_bbox\n        output_grid_np = np_grid[min_r:max_r + 1, min_c:max_c + 1]\n        # Convert back to list of lists for the required output format\n        output_grid = output_grid_np.tolist()\n    else:\n        # Handle case where no hollow rectangle is found (though examples suggest one always exists)\n        # Returning an empty grid or the original might be options,\n        # but based on the task, finding one is expected. Let's return empty for now.\n        output_grid = [] # Or potentially raise an error, or return np_grid.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6378,
    "candidates_token_count": 2008,
    "total_token_count": 8386,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.858312,
  "retries": null
}