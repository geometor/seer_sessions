{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Identify the largest connected red (2) rectangular object in the input grid and determine its bounding box (min_row, min_col, max_row, max_col).\n2. Calculate the coordinates of two key internal rows (min_row + 1, max_row - 1) and two key internal columns (min_col + 1, max_col - 1) of this rectangle. Assume the rectangle is at least 3x3.\n3. Identify all \"marker\" pixels, which are any pixels that are not white (0) and not red (2).\n4. For each marker pixel:\n    a. Determine its position relative to the red rectangle (Above, Below, Left, or Right).\n    b. If the marker is Above the rectangle, draw vertical red (2) lines in the two key internal columns, extending from the top edge of the grid (row 0) down to the row just above the rectangle (min_row - 1).\n    c. If the marker is Below the rectangle, draw vertical red (2) lines in the two key internal columns, extending from the row just below the rectangle (max_row + 1) down to the bottom edge of the grid.\n    d. If the marker is Left of the rectangle, draw horizontal red (2) lines in the two key internal rows, extending from the left edge of the grid (col 0) across to the column just left of the rectangle (min_col - 1).\n    e. If the marker is Right of the rectangle, draw horizontal red (2) lines in the two key internal rows, extending from the column just right of the rectangle (max_col + 1) across to the right edge of the grid.\n5. The output grid is the input grid with these added red lines. Original pixels (markers and the red rectangle) remain unchanged. Added red lines overwrite any background (white 0) pixels in their path.\n\"\"\"\n\nimport numpy as np\n\ndef find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    component.append((row, col))\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if component:\n                    components.append(component)\n    return components\n\ndef find_largest_component(grid, color):\n    \"\"\"Finds the largest connected component of a given color.\"\"\"\n    components = find_connected_components(grid, color)\n    if not components:\n        return None\n    # Find the component with the maximum number of pixels\n    largest_component = max(components, key=len)\n    return largest_component\n\ndef get_bounding_box(component_coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) of a component.\"\"\"\n    if not component_coords:\n        return None, None, None, None\n    rows = [r for r, c in component_coords]\n    cols = [c for r, c in component_coords]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of input_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    red_color = 2\n    background_color = 0\n\n    # 1. Find the largest red object and its bounding box\n    red_component = find_largest_component(output_grid, red_color)\n    if not red_component:\n        # Handle case where no red object is found (return original grid?)\n        return output_grid \n        \n    min_row, min_col, max_row, max_col = get_bounding_box(red_component)\n\n    # Check if bounding box is valid\n    if min_row is None:\n        return output_grid # No red object found\n\n    # 2. Determine key internal rows and columns (assuming >= 3x3)\n    # Add checks for smaller rectangles, though examples suggest >= 3x3\n    rect_height = max_row - min_row + 1\n    rect_width = max_col - min_col + 1\n\n    if rect_height < 3 or rect_width < 3:\n         # Fallback for small rectangles - might need refinement based on expected behavior\n         # For now, let's assume examples guarantee >= 3x3 based on observation\n         # If it fails, we'd adjust this logic (e.g., use boundary lines)\n         print(f\"Warning: Red rectangle is smaller than 3x3 ({rect_height}x{rect_width}). Using boundary-based logic.\")\n         # Simple fallback: use min/max row/col if dimension is < 3\n         row_top = min_row if rect_height < 3 else min_row + 1\n         row_bottom = max_row if rect_height < 3 else max_row - 1\n         col_left = min_col if rect_width < 3 else min_col + 1\n         col_right = max_col if rect_width < 3 else max_col - 1\n    else:\n        row_top = min_row + 1\n        row_bottom = max_row - 1\n        col_left = min_col + 1\n        col_right = max_col - 1\n        \n    # Ensure key rows/cols are within grid bounds (should be, but good practice)\n    row_top = max(0, row_top)\n    row_bottom = min(rows - 1, row_bottom)\n    col_left = max(0, col_left)\n    col_right = min(cols - 1, col_right)\n\n\n    # 3. Find all marker pixels\n    marker_coords = []\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] != background_color and output_grid[r, c] != red_color:\n                marker_coords.append((r, c))\n\n    # 4. Process each marker\n    for marker_row, marker_col in marker_coords:\n        # a. Determine relative position\n        is_above = marker_row < min_row\n        is_below = marker_row > max_row\n        is_left = marker_col < min_col\n        is_right = marker_col > max_col\n\n        # b. Draw lines if Above\n        if is_above:\n            for r in range(min_row): # From row 0 up to min_row - 1\n                if 0 <= col_left < cols:\n                   output_grid[r, col_left] = red_color\n                if 0 <= col_right < cols and col_left != col_right: # Avoid double-drawing if width is exactly 3\n                   output_grid[r, col_right] = red_color\n\n        # c. Draw lines if Below\n        if is_below:\n            for r in range(max_row + 1, rows): # From max_row + 1 down to the end\n                 if 0 <= col_left < cols:\n                   output_grid[r, col_left] = red_color\n                 if 0 <= col_right < cols and col_left != col_right:\n                   output_grid[r, col_right] = red_color\n\n        # d. Draw lines if Left\n        if is_left:\n            for c in range(min_col): # From col 0 up to min_col - 1\n                if 0 <= row_top < rows:\n                    output_grid[row_top, c] = red_color\n                if 0 <= row_bottom < rows and row_top != row_bottom: # Avoid double-drawing if height is exactly 3\n                    output_grid[row_bottom, c] = red_color\n\n        # e. Draw lines if Right\n        if is_right:\n            for c in range(max_col + 1, cols): # From max_col + 1 across to the end\n                if 0 <= row_top < rows:\n                    output_grid[row_top, c] = red_color\n                if 0 <= row_bottom < rows and row_top != row_bottom:\n                     output_grid[row_bottom, c] = red_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7314,
    "candidates_token_count": 2192,
    "total_token_count": 9506,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.374645,
  "retries": null
}