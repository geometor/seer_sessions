{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Identify the largest connected red (2) rectangular object in the input grid and determine its bounding box (min_row, min_col, max_row, max_col). Assume this rectangle exists and is at least 3x3.\n3. Calculate the coordinates of the two key internal rows of this rectangle: key_row_top = min_row + 1 and key_row_bottom = max_row - 1.\n4. Identify all \"marker\" pixels, which are any pixels in the input grid that are not white (0) and not red (2).\n5. For each marker pixel located at (marker_row, marker_col):\n    a. Determine its position relative to the red rectangle's bounding box (Above, Below, Left, or Right).\n    b. If the marker is Above the rectangle (marker_row < min_row), draw a vertical red (2) line in column marker_col from row 0 down to min_row - 1. Only change pixels in the output grid if they are currently white (0).\n    c. If the marker is Below the rectangle (marker_row > max_row), draw a vertical red (2) line in column marker_col from row max_row + 1 down to the bottom edge of the grid. Only change pixels in the output grid if they are currently white (0).\n    d. If the marker is Left of the rectangle (marker_col < min_col), draw two horizontal red (2) lines, one in row key_row_top and one in row key_row_bottom, both extending from column 0 across to min_col - 1. Only change pixels in the output grid if they are currently white (0).\n    e. If the marker is Right of the rectangle (marker_col > max_col), draw two horizontal red (2) lines, one in row key_row_top and one in row key_row_bottom, both extending from column max_col + 1 across to the right edge of the grid. Only change pixels in the output grid if they are currently white (0).\n6. Return the modified output grid.\n\"\"\"\n\nimport numpy as np\n\n# --- Helper Functions (copied from previous attempt) ---\n\ndef find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = [(r, c)]\n                visited[r, c] = True\n                component_rows = set()\n                component_cols = set()\n                while q:\n                    row, col = q.pop(0)\n                    component.append((row, col))\n                    component_rows.add(row)\n                    component_cols.add(col)\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Check if the component forms a solid rectangle\n                min_r, max_r = min(component_rows), max(component_rows)\n                min_c, max_c = min(component_cols), max(component_cols)\n                is_rectangle = True\n                if len(component) != (max_r - min_r + 1) * (max_c - min_c + 1):\n                    is_rectangle = False\n                else:\n                    # Double-check all cells within the bounding box are part of the component\n                    for row_idx in range(min_r, max_r + 1):\n                        for col_idx in range(min_c, max_c + 1):\n                             if grid[row_idx, col_idx] != color:\n                                 # This check might be redundant if the component finding is correct\n                                 # but added for robustness against non-solid shapes within the bbox\n                                 pass # Allow non-red colors inside if needed, but examples seem solid\n                             if (row_idx, col_idx) not in component:\n                                is_rectangle = False\n                                break\n                        if not is_rectangle:\n                            break\n\n                if component and is_rectangle: # Only add if it's a rectangle\n                    components.append(component)\n    return components\n\ndef find_largest_component(grid, color):\n    \"\"\"Finds the largest connected rectangular component of a given color.\"\"\"\n    components = find_connected_components(grid, color)\n    if not components:\n        return None\n    # Find the component with the maximum number of pixels\n    largest_component = max(components, key=len)\n    return largest_component\n\ndef get_bounding_box(component_coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) of a component.\"\"\"\n    if not component_coords:\n        return None, None, None, None\n    rows = [r for r, c in component_coords]\n    cols = [c for r, c in component_coords]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on marker positions relative to the largest red rectangle.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of input_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    red_color = 2\n    background_color = 0\n\n    # 2. Find the largest red rectangular object and its bounding box\n    red_component = find_largest_component(output_grid, red_color)\n    if not red_component:\n        # Handle case where no red object is found (return original grid)\n        print(\"Warning: No red rectangular component found.\")\n        return output_grid \n        \n    min_row, min_col, max_row, max_col = get_bounding_box(red_component)\n\n    # Check if bounding box is valid (should be if red_component exists)\n    if min_row is None:\n        print(\"Warning: Could not determine bounding box for red component.\")\n        return output_grid \n\n    rect_height = max_row - min_row + 1\n    rect_width = max_col - min_col + 1\n\n    # 3. Determine key internal rows (assuming >= 3x3 height)\n    if rect_height < 3:\n        # This case is not explicitly handled by the examples or revised logic.\n        # Returning the original grid or implementing a fallback might be needed.\n        # For now, assume height is >= 3 based on examples.\n        print(f\"Warning: Red rectangle height ({rect_height}) is less than 3. Key row logic may fail.\")\n        # Fallback: use boundary rows if height < 3? Let's stick to the assumption for now.\n        key_row_top = min_row # Or some other default?\n        key_row_bottom = max_row\n        # Returning original might be safer if this assumption is violated.\n        # return output_grid \n    else:\n        key_row_top = min_row + 1\n        key_row_bottom = max_row - 1\n\n    # 4. Find all marker pixels\n    marker_coords = []\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] != background_color and output_grid[r, c] != red_color:\n                marker_coords.append((r, c))\n\n    # 5. Process each marker and draw lines, only overwriting background\n    for marker_row, marker_col in marker_coords:\n        # a. Determine relative position\n        is_above = marker_row < min_row\n        is_below = marker_row > max_row\n        is_left = marker_col < min_col\n        is_right = marker_col > max_col\n\n        # b. Draw vertical line if Above\n        if is_above:\n            # Ensure marker_col is within grid bounds\n            if 0 <= marker_col < cols:\n                for r in range(min_row): # From row 0 up to min_row - 1\n                    if output_grid[r, marker_col] == background_color:\n                       output_grid[r, marker_col] = red_color\n\n        # c. Draw vertical line if Below\n        if is_below:\n            # Ensure marker_col is within grid bounds\n            if 0 <= marker_col < cols:\n                for r in range(max_row + 1, rows): # From max_row + 1 down to the end\n                    if output_grid[r, marker_col] == background_color:\n                       output_grid[r, marker_col] = red_color\n\n        # d. Draw horizontal lines if Left\n        if is_left:\n            # Ensure key rows are valid and within grid bounds\n            if 0 <= key_row_top < rows:\n                for c in range(min_col): # From col 0 up to min_col - 1\n                    if output_grid[key_row_top, c] == background_color:\n                        output_grid[key_row_top, c] = red_color\n            if 0 <= key_row_bottom < rows and key_row_top != key_row_bottom: # Avoid double-drawing if height is exactly 3\n                for c in range(min_col): # From col 0 up to min_col - 1\n                     if output_grid[key_row_bottom, c] == background_color:\n                        output_grid[key_row_bottom, c] = red_color\n\n        # e. Draw horizontal lines if Right\n        if is_right:\n             # Ensure key rows are valid and within grid bounds\n            if 0 <= key_row_top < rows:\n                for c in range(max_col + 1, cols): # From max_col + 1 across to the end\n                    if output_grid[key_row_top, c] == background_color:\n                        output_grid[key_row_top, c] = red_color\n            if 0 <= key_row_bottom < rows and key_row_top != key_row_bottom: # Avoid double-drawing if height is exactly 3\n                 for c in range(max_col + 1, cols): # From max_col + 1 across to the end\n                    if output_grid[key_row_bottom, c] == background_color:\n                         output_grid[key_row_bottom, c] = red_color\n\n    # 6. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12944,
    "candidates_token_count": 2628,
    "total_token_count": 15572,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.065121,
  "retries": null
}