{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Identify the largest connected red (2) object that forms a solid rectangle in the input grid. Determine its bounding box coordinates: `min_row`, `min_col`, `max_row`, `max_col`. If no such rectangle is found, return the original grid.\n3. Identify all \"marker\" pixels in the input grid. A marker pixel is any pixel whose color is neither white (0) nor red (2). Record the position (`marker_row`, `marker_col`) of each marker.\n4. Iterate through each identified marker pixel:\n    a. Determine the marker's position relative to the red rectangle's bounding box.\n    b. If the marker is Above the rectangle (`marker_row < min_row`):\n        Draw a vertical red (2) line in the output grid in column `marker_col`. This line should extend from row 0 down to `min_row - 1`. Only change pixels if their current color is white (0).\n    c. If the marker is Below the rectangle (`marker_row > max_row`):\n        Draw a vertical red (2) line in the output grid in column `marker_col`. This line should extend from row `max_row + 1` down to the bottom edge of the grid. Only change pixels if their current color is white (0).\n    d. If the marker is Left of the rectangle (`marker_col < min_col`):\n        For each row `r` from `min_row` to `max_row` (inclusive), draw a horizontal red (2) line in the output grid. This line should be in row `r` and extend from column 0 across to `min_col - 1`. Only change pixels if their current color is white (0).\n    e. If the marker is Right of the rectangle (`marker_col > max_col`):\n        For each row `r` from `min_row` to `max_row` (inclusive), draw a horizontal red (2) line in the output grid. This line should be in row `r` and extend from column `max_col + 1` across to the right edge of the grid. Only change pixels if their current color is white (0).\n5. Return the modified output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = [(r, c)]\n                visited[r, c] = True\n                component_rows = set()\n                component_cols = set()\n                \n                # BFS to find all connected pixels of the same color\n                queue_idx = 0\n                while queue_idx < len(q):\n                    row, col = q[queue_idx]\n                    queue_idx += 1\n                    component.append((row, col))\n                    component_rows.add(row)\n                    component_cols.add(col)\n                    \n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Check if the component forms a solid rectangle\n                if not component_rows or not component_cols: continue # Skip if empty component somehow\n                \n                min_r, max_r = min(component_rows), max(component_rows)\n                min_c, max_c = min(component_cols), max(component_cols)\n                is_rectangle = True\n                # Verify the count of pixels matches the bounding box area\n                if len(component) != (max_r - min_r + 1) * (max_c - min_c + 1):\n                    is_rectangle = False\n                else:\n                    # Optionally, double-check all cells within the bounding box are the correct color\n                    # This check is implicitly handled by the component size check if connectivity is correct.\n                    # for row_idx in range(min_r, max_r + 1):\n                    #     for col_idx in range(min_c, max_c + 1):\n                    #          if grid[row_idx, col_idx] != color: # Should not happen if component finding is correct\n                    #             is_rectangle = False\n                    #             break\n                    #     if not is_rectangle:\n                    #         break\n                     pass # Assume component finding is correct\n\n                if component and is_rectangle: # Only add if it's a non-empty rectangle\n                    components.append(component)\n    return components\n\ndef find_largest_component(grid, color):\n    \"\"\"Finds the largest connected rectangular component of a given color.\"\"\"\n    components = find_connected_components(grid, color)\n    if not components:\n        return None\n    # Find the component with the maximum number of pixels\n    largest_component = max(components, key=len)\n    return largest_component\n\ndef get_bounding_box(component_coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) of a component.\"\"\"\n    if not component_coords:\n        return None, None, None, None\n    rows = [r for r, c in component_coords]\n    cols = [c for r, c in component_coords]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on marker positions relative to the largest red rectangle.\n    Draws lines from the rectangle edges towards markers, filling only white space.\n    Horizontal lines now span the full height of the original rectangle.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of input_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    red_color = 2\n    background_color = 0\n\n    # 2. Find the largest red rectangular object and its bounding box\n    red_component = find_largest_component(output_grid, red_color)\n    if not red_component:\n        # Handle case where no red object is found (return original grid)\n        # print(\"Warning: No red rectangular component found.\") # Optional debug message\n        return output_grid \n        \n    min_row, min_col, max_row, max_col = get_bounding_box(red_component)\n\n    # Check if bounding box is valid (should be if red_component exists)\n    if min_row is None:\n        # print(\"Warning: Could not determine bounding box for red component.\") # Optional debug message\n        return output_grid \n\n    # 3. Find all marker pixels\n    marker_coords = []\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] != background_color and output_grid[r, c] != red_color:\n                marker_coords.append((r, c))\n\n    # 4. Process each marker and draw lines, only overwriting background\n    for marker_row, marker_col in marker_coords:\n        # a. Determine relative position\n        is_above = marker_row < min_row\n        is_below = marker_row > max_row\n        is_left = marker_col < min_col\n        is_right = marker_col > max_col\n\n        # b. Draw vertical line if Above\n        if is_above:\n            # Ensure marker_col is within grid bounds\n            if 0 <= marker_col < cols:\n                for r in range(min_row): # From row 0 up to min_row - 1\n                    if 0 <= r < rows: # Boundary check for row\n                        if output_grid[r, marker_col] == background_color:\n                           output_grid[r, marker_col] = red_color\n\n        # c. Draw vertical line if Below\n        if is_below:\n            # Ensure marker_col is within grid bounds\n            if 0 <= marker_col < cols:\n                for r in range(max_row + 1, rows): # From max_row + 1 down to the end\n                     if 0 <= r < rows: # Boundary check for row (redundant but safe)\n                         if output_grid[r, marker_col] == background_color:\n                            output_grid[r, marker_col] = red_color\n\n        # d. Draw horizontal lines if Left (Corrected Logic)\n        if is_left:\n            # Iterate through all rows spanned by the original rectangle\n            for r in range(min_row, max_row + 1):\n                # Ensure row index is valid\n                if 0 <= r < rows:\n                    # Draw horizontal line from col 0 up to min_col - 1\n                    for c in range(min_col): \n                        if 0 <= c < cols: # Boundary check for column\n                            if output_grid[r, c] == background_color:\n                                output_grid[r, c] = red_color\n\n        # e. Draw horizontal lines if Right (Corrected Logic)\n        if is_right:\n            # Iterate through all rows spanned by the original rectangle\n            for r in range(min_row, max_row + 1):\n                 # Ensure row index is valid\n                if 0 <= r < rows:\n                    # Draw horizontal line from max_col + 1 across to the end\n                    for c in range(max_col + 1, cols): \n                        if 0 <= c < cols: # Boundary check for column (redundant but safe)\n                            if output_grid[r, c] == background_color:\n                                 output_grid[r, c] = red_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17946,
    "candidates_token_count": 2432,
    "total_token_count": 20378,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.094613,
  "retries": null
}