{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Find the largest contiguous object composed of a single non-white color in the input grid. Let its color be `FilterColor`.\n2. Identify all other non-white pixels in the input grid. Find the smallest bounding box that encloses all these pixels. Let this be the `SourceBlock`.\n3. Determine the set of `TargetColors` to be filtered out based on the `FilterColor`:\n    - If `FilterColor` is green (3), the `TargetColors` are {blue (1), azure (8), maroon (9)}.\n    - If `FilterColor` is blue (1), the `TargetColors` are {blue (1), red (2), yellow (4), maroon (9)}.\n    - If `FilterColor` is azure (8), the `TargetColors` are {blue (1), green (3), gray (5), orange (7)}.\n4. Create a new output grid with the same dimensions as the `SourceBlock`.\n5. Iterate through each cell `(r, c)` of the `SourceBlock`:\n    - Get the color `CurrentColor` at `SourceBlock[r, c]`.\n    - Check if `CurrentColor` is present in the set of `TargetColors`.\n    - If it is present, set the corresponding cell in the output grid to white (0).\n    - If it is not present, set the corresponding cell in the output grid to `CurrentColor`.\n6. Return the generated output grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n    Args:\n        grid (np.array): Input grid.\n    Returns:\n        list: A list of objects, where each object is a dictionary containing\n              'color', 'coords' (set of (r, c) tuples), and 'size'.\n              Excludes objects with color 0 (white).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != 0:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    if grid[row, col] == color:\n                        obj_coords.add((row, col))\n                        # Check neighbors (4-connectivity)\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               (nr, nc) not in visited and grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                    # Mark visited even if color doesn't match to avoid re-processing\n                    # Although the BFS condition already ensures we only add same-color neighbors\n                    # this visited mark handles the initial starting point correctly.\n                    visited.add((r, c)) # Make sure initial point is marked if not added to obj_coords\n\n                if obj_coords: # Only add if we found valid coords for this color object\n                     objects.append({\n                         'color': color,\n                         'coords': obj_coords,\n                         'size': len(obj_coords)\n                     })\n                     # Ensure all coords of the found object are marked visited\n                     # This handles cases where BFS might have stopped early if grid[row, col] != color was hit inside loop\n                     visited.update(obj_coords) \n\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n    Args:\n        coords (set): A set of (row, col) tuples.\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col), or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    \n    min_row = min(r for r, c in coords)\n    min_col = min(c for r, c in coords)\n    max_row = max(r for r, c in coords)\n    max_col = max(c for r, c in coords)\n    \n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color filtering transformation based on the largest object's color.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # 1. Find all non-white objects\n    objects = find_objects(input_array)\n    \n    if not objects:\n        # Handle case with no non-white objects (return empty or original?)\n        # Based on examples, this shouldn't happen. Let's return an empty grid.\n        return np.array([[]], dtype=int).tolist() \n        \n    # Find the largest object\n    largest_object = max(objects, key=lambda obj: obj['size'])\n    filter_color = largest_object['color']\n    large_object_coords = largest_object['coords']\n\n    # 2. Identify coordinates of the source block (all non-white pixels NOT in the largest object)\n    all_non_white_coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_array[r,c] != 0:\n                all_non_white_coords.add((r,c))\n                \n    source_block_coords = all_non_white_coords - large_object_coords\n\n    if not source_block_coords:\n         # Handle case where only the largest object exists\n         # Based on examples, this shouldn't happen. Let's return an empty grid.\n        return np.array([[]], dtype=int).tolist() \n\n    # Get the bounding box of the source block coordinates\n    min_r, min_c, max_r, max_c = get_bounding_box(source_block_coords)\n    \n    # Extract the SourceBlock subgrid\n    source_block = input_array[min_r:max_r+1, min_c:max_c+1]\n\n    # 3. Determine TargetColors based on FilterColor\n    target_color_map = {\n        3: {1, 8, 9},      # Green -> Filter Blue, Azure, Maroon\n        1: {1, 2, 4, 9},  # Blue -> Filter Blue, Red, Yellow, Maroon\n        8: {1, 3, 5, 7}   # Azure -> Filter Blue, Green, Gray, Orange\n    }\n    target_colors = target_color_map.get(filter_color, set()) # Default to empty set if color not found\n\n    # 4. Create the output grid (initially a copy of SourceBlock)\n    output_grid = source_block.copy()\n    \n    # 5. Apply filtering: iterate through output_grid and set TargetColors to white (0)\n    out_rows, out_cols = output_grid.shape\n    for r in range(out_rows):\n        for c in range(out_cols):\n            # Important check: only filter pixels that were originally part of the source_block_coords\n            # This prevents filtering pixels within the bounding box that were white or part of the large object\n            # if the large object happened to overlap the bounding box area (unlikely based on examples but safer).\n            # We calculate the original coordinate relative to the input_array.\n            original_r, original_c = r + min_r, c + min_c\n            if (original_r, original_c) in source_block_coords:\n                 current_color = output_grid[r, c]\n                 if current_color in target_colors:\n                     output_grid[r, c] = 0\n            # If the pixel in the bounding box was NOT part of the source_block_coords \n            # (e.g., it was originally white or part of the large shape), set it to white in output.\n            # Or, more simply, the source_block copy handles this implicitly if those pixels were already 0.\n            # Let's double-check: source_block only contains pixels within the bounding box.\n            # The filtering logic only needs to check colors within the source_block against target_colors.\n            # The previous check `if (original_r, original_c) in source_block_coords:` might be redundant\n            # if source_block extraction is correct. Let's simplify.\n\n    # Simplified filtering loop:\n    output_grid_simplified = source_block.copy()\n    for r in range(out_rows):\n        for c in range(out_cols):\n            current_color = output_grid_simplified[r, c]\n            if current_color in target_colors:\n                output_grid_simplified[r, c] = 0\n\n    # 6. Return the result as a list of lists\n    return output_grid_simplified.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5724,
    "candidates_token_count": 2144,
    "total_token_count": 7868,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.483185,
  "retries": null
}