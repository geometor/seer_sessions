{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1.  Identify all contiguous objects (groups of connected pixels of the same color) that are not white (0). Use 4-way connectivity.\n2.  Determine the single largest object based on the number of pixels it contains. If there's a tie in size, select the one whose top-most, left-most pixel comes first in a row-by-row, column-by-column scan. Let the color of this largest object be the `KeyColor` and its coordinates be `KeyObjectCoords`.\n3.  Identify all non-white pixels in the input grid whose coordinates are *not* in `KeyObjectCoords`. These are the `PayloadPixels`. Collect their coordinates (`PayloadCoords`) and colors.\n4.  If there are no `PayloadPixels`, return an empty grid represented as `[[]]`.\n5.  Determine the set of `ColorsToRemove` based on the `KeyColor`:\n    *   If `KeyColor` is Green (3), `ColorsToRemove` = {Green (3), Maroon (9)}.\n    *   If `KeyColor` is Blue (1), `ColorsToRemove` = {Blue (1), Red (2), Yellow (4), Maroon (9)}.\n    *   If `KeyColor` is Azure (8), `ColorsToRemove` = {Blue (1), Orange (7), Azure (8)}.\n    *   Otherwise, `ColorsToRemove` is an empty set.\n6.  Create a new set of coordinates, `KeptPayloadCoords`, containing only the coordinates `(r, c)` from `PayloadCoords` where the color of the input grid at `(r, c)` is *not* in `ColorsToRemove`.\n7.  If `KeptPayloadCoords` is empty, return an empty grid represented as `[[]]`.\n8.  Calculate the minimum bounding box that encloses all coordinates in `KeptPayloadCoords`. Let the top-left corner be `(min_r, min_c)` and the bottom-right corner be `(max_r, max_c)`.\n9.  Calculate the dimensions of the output grid: `height = max_r - min_r + 1`, `width = max_c - min_c + 1`.\n10. Create a new output grid of size `(height, width)`, initialized entirely with white (0).\n11. Iterate through each coordinate `(r, c)` in `KeptPayloadCoords`:\n    *   Get the `CurrentColor` from the input grid at `(r, c)`.\n    *   Calculate the corresponding position in the output grid: `out_r = r - min_r`, `out_c = c - min_c`.\n    *   Set the pixel in the output grid at `(out_r, out_c)` to `CurrentColor`.\n12. Return the generated output grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-white color in the grid using Breadth-First Search (4-connectivity).\n    Sorts objects by size descending, then by top-most row, then left-most column for tie-breaking.\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        list: A list of objects, sorted by size (desc), then top-row (asc), then left-col (asc).\n              Each object is a dictionary containing 'color' (int), 'coords' (set of (r, c) tuples),\n              'size' (int), 'min_r' (int), and 'min_c' (int).\n              Excludes objects with color 0 (white). Returns empty list if no non-white objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell hasn't been visited and is not white (0)\n            if (r, c) not in visited and grid[r, c] != 0:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c)) # Mark start node visited immediately\n                min_r_obj, min_c_obj = r, c # Keep track of top-left for tie-breaking\n\n                # Start BFS from this cell\n                while q:\n                    row, col = q.popleft()\n                    # Update min row/col for this object\n                    min_r_obj = min(min_r_obj, row)\n                    min_c_obj = min(min_c_obj, col)\n                    # Add the current coordinate to the object\n                    obj_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check if the neighbor is within bounds, not visited, and has the same color\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc)) # Mark neighbor visited when adding to queue\n                            q.append((nr, nc))\n\n                # Add the found object to the list\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'size': len(obj_coords),\n                    'min_r': min_r_obj,\n                    'min_c': min_c_obj\n                })\n\n    # Sort by size descending, then row ascending, then col ascending\n    objects.sort(key=lambda o: (-o['size'], o['min_r'], o['min_c']))\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col), or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n\n    min_row = min(r for r, c in coords)\n    min_col = min(c for r, c in coords)\n    max_row = max(r for r, c in coords)\n    max_col = max(c for r, c in coords)\n\n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation based on the natural language program.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # 1. & 2. Find all non-white objects and identify the largest (with tie-breaking)\n    objects = find_objects(input_array)\n\n    # Handle edge case: no non-white objects found\n    if not objects:\n        return [[]] # Return empty list for empty grid\n\n    largest_object = objects[0] # Largest is first due to sorting\n    key_color = largest_object['color']\n    key_object_coords = largest_object['coords']\n\n    # 3. Identify PayloadPixels (all non-white pixels NOT in the largest object)\n    all_non_white_coords = set(zip(*np.where(input_array != 0)))\n    payload_coords = all_non_white_coords - key_object_coords\n\n    # 4. Handle case where no payload pixels exist\n    if not payload_coords:\n         return [[]] # Return empty list for empty grid\n\n    # 5. Determine ColorsToRemove based on KeyColor\n    colors_to_remove = set()\n    if key_color == 3: # Green Key\n        colors_to_remove = {3, 9} # Remove Green, Maroon\n    elif key_color == 1: # Blue Key\n        colors_to_remove = {1, 2, 4, 9} # Remove Blue, Red, Yellow, Maroon\n    elif key_color == 8: # Azure Key\n        colors_to_remove = {1, 7, 8} # Remove Blue, Orange, Azure\n    # Otherwise, colors_to_remove remains empty\n\n    # 6. Filter payload coordinates to get KeptPayloadCoords\n    kept_payload_coords = set()\n    for r, c in payload_coords:\n        if input_array[r, c] not in colors_to_remove:\n            kept_payload_coords.add((r, c))\n\n    # 7. Handle case where no payload pixels are kept after filtering\n    if not kept_payload_coords:\n         return [[]] # Return empty list for empty grid\n\n    # 8. Calculate the bounding box of the kept coordinates\n    min_r, min_c, max_r, max_c = get_bounding_box(kept_payload_coords)\n\n    # 9. Calculate output dimensions\n    out_height = max_r - min_r + 1\n    out_width = max_c - min_c + 1\n\n    # 10. Create the output grid, initialized with white (0)\n    output_grid = np.zeros((out_height, out_width), dtype=int)\n\n    # 11. Populate the output grid with kept payload pixels, adjusting coordinates\n    for r, c in kept_payload_coords:\n        current_color = input_array[r, c]\n        # Calculate the position in the output grid relative to the bounding box origin\n        out_r = r - min_r\n        out_c = c - min_c\n        # Place the color in the output grid\n        output_grid[out_r, out_c] = current_color\n\n    # 12. Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 30244,
    "candidates_token_count": 2286,
    "total_token_count": 32530,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.573082,
  "retries": null
}