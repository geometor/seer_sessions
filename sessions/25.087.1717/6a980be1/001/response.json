{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Identify the border color from the input grid's corner (e.g., input_grid[0, 0]).\n2. Determine the vertical span (minimum and maximum row indices) of the non-white pattern located within the input grid's content area (i.e., excluding the 1-pixel border).\n3. Initialize an output grid of the same dimensions as the input grid.\n4. Process each row of the output grid based on its relationship to the pattern's vertical span:\n    a. If the current row index is within the determined pattern's vertical span:\n        i. Check if the corresponding input row's content area (columns between 1 and width-2) contains any red pixels (color code 2).\n        ii. Determine the background color for this output row: use the identified border color if red pixels were present in the input row's content, otherwise use white (color code 0).\n        iii. Fill the entire output row with this determined background color.\n        iv. Copy the non-white pixels (the actual pattern elements, typically green and red) from the input row's content area to the corresponding positions in the output row, overwriting the background fill.\n    b. If the current row index is outside the determined pattern's vertical span:\n        i. Check if the pattern found in step 2 was \"tall\", meaning it spanned exactly from row index 1 to row index height-2.\n        ii. If the pattern was \"tall\", fill the current output row entirely with white (0). (This condition applies specifically to the top row (index 0) and the bottom row (index height-1) of the grid).\n        iii. If the pattern was \"short\" (did not span the full height minus borders) or if no pattern existed at all, fill the current output row by repeating the horizontal sequence [white (0), border_color, border_color] across the width of the row.\n5. Return the completed output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by selectively filling the background based on\n    the presence of a specific color (red=2) within a central pattern area,\n    preserving the pattern itself, and applying different fill rules for rows\n    outside the pattern's vertical extent.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list of integers representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int) # Work with numpy array for efficiency\n    height, width = input_grid_np.shape\n\n    # Handle grids too small to have a border and content area\n    if height < 3 or width < 3:\n        # Default behavior for small grids might need specific definition,\n        # but based on examples, they likely follow the \"short pattern\" rule.\n        # Identify border color safely\n        border_color = input_grid_np[0, 0] if height > 0 and width > 0 else 0\n        output_grid = np.zeros((height, width), dtype=int)\n        outside_pattern = np.array([0, border_color, border_color])\n        if width > 0 : # Check width before resizing\n             for r in range(height):\n                 output_grid[r, :] = np.resize(outside_pattern, width)\n        return output_grid.tolist()\n\n\n    # 1. Identify border color\n    border_color = input_grid_np[0, 0]\n\n    # Initialize output grid\n    output_grid = np.zeros((height, width), dtype=int)\n\n    # 2. Determine vertical span (min/max rows) of the non-white pattern\n    #    within the input grid's content area [1:-1, 1:-1]\n    pattern_min_r = height\n    pattern_max_r = -1\n    for r in range(1, height - 1):\n        # Check if any non-white pixel exists in the content part of the row\n        if np.any(input_grid_np[r, 1:-1] != 0):\n            pattern_min_r = min(pattern_min_r, r)\n            pattern_max_r = max(pattern_max_r, r)\n\n    pattern_exists = (pattern_max_r != -1) # True if any pattern was found\n\n    # Determine if the pattern fills the full height available (excluding borders)\n    is_tall_pattern = pattern_exists and pattern_min_r == 1 and pattern_max_r == height - 2\n\n    # Define the repeating pattern used for filling rows outside a short pattern's span\n    outside_pattern = np.array([0, border_color, border_color])\n\n    # 4. Process each row to build the output grid\n    for r in range(height):\n        # Case a: Row is within the pattern's vertical span\n        if pattern_exists and pattern_min_r <= r <= pattern_max_r:\n            # i. Check if the input row's content area contains red (2)\n            has_red = np.any(input_grid_np[r, 1:-1] == 2)\n\n            # ii. Determine background color for this output row\n            row_bg_color = border_color if has_red else 0\n\n            # iii. Fill the output row with this background color initially\n            output_grid[r, :] = row_bg_color\n\n            # iv. Copy the non-white pixels (pattern) from the input row's content area\n            # Find column indices of non-white pixels in the content slice [1:-1]\n            content_slice = input_grid_np[r, 1:-1]\n            pattern_indices_in_slice = np.where(content_slice != 0)[0]\n            # Convert these slice indices to indices in the full row\n            pattern_indices_in_row = pattern_indices_in_slice + 1\n            # Copy the original pattern pixel values to the output grid at these indices\n            output_grid[r, pattern_indices_in_row] = input_grid_np[r, pattern_indices_in_row]\n\n        # Case b: Row is outside the pattern's vertical span (or no pattern exists)\n        else:\n            # i/ii. Check if the pattern was \"tall\"\n            if is_tall_pattern:\n                # If tall, the outside rows (0 and height-1) become white\n                output_grid[r, :] = 0\n            # iii. If pattern was \"short\" or didn't exist, use the repeating pattern\n            else:\n                if width > 0 : # Check width before resizing pattern\n                    output_grid[r, :] = np.resize(outside_pattern, width)\n\n    # 5. Return the output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6282,
    "candidates_token_count": 1599,
    "total_token_count": 7881,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 138.744438,
  "retries": null
}