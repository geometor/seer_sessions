{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify the horizontal line of gray pixels (color 5) which divides the input grid into a top half and a bottom half.\n2.  Find the three distinct colored objects in the top half and the single object (Key Object) in the bottom half.\n3.  Identify the leftmost object in the top half (Matched Object) which must match the Key Object in shape and color.\n4.  Identify the middle object in the top half (Discarded Object).\n5.  Identify the rightmost object in the top half (Other Object).\n6.  Determine the shape of the Discarded Object. In the examples, it's either a 'Plus' shape (5 pixels) or a 'T' shape (4 pixels).\n7.  Determine the stacking order for the output based on the Discarded Object's shape:\n    *   If the Discarded Object is 'Plus', stack the Matched Object above the Other Object.\n    *   If the Discarded Object is 'T', stack the Other Object above the Matched Object.\n8.  Construct the output grid:\n    *   Calculate the minimal dimensions needed to contain the two selected objects vertically stacked, with one row of white padding above, between, and below them. The width should accommodate the wider of the two objects.\n    *   Place the two objects in the determined order, horizontally centered within the output grid width.\n\"\"\"\n\n# Helper functions\n\ndef find_gray_line_row(grid):\n    \"\"\"Finds the row index containing the horizontal gray line (color 5).\"\"\"\n    gray_color = 5\n    for r_idx, row in enumerate(grid):\n        if all(pixel == gray_color for pixel in row if gray_color in row):\n             # Check if the entire row is gray or if gray is present and forms a line\n             # A simple check if at least one gray pixel exists and others are gray or white\n             is_line = True\n             found_gray = False\n             for pixel in row:\n                 if pixel == gray_color:\n                     found_gray = True\n                 elif pixel != 0: # Assuming 0 is background, if non-gray, non-white exists, not a simple line\n                     # More robust check might be needed depending on variations\n                     # For now, assume line is solid gray or gray + white\n                     pass # Allow white for now\n             if found_gray: # Simplified: assumes if gray exists, it's the line row\n                 return r_idx\n    return -1 # Not found\n\ndef find_objects_in_region(grid_region, background_color=0):\n    \"\"\"Finds distinct contiguous objects of non-background color in a given grid region.\"\"\"\n    objects = []\n    region_height, region_width = grid_region.shape\n    visited = np.zeros_like(grid_region, dtype=bool)\n\n    for r in range(region_height):\n        for c in range(region_width):\n            if grid_region[r, c] != background_color and not visited[r, c]:\n                color = grid_region[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < region_height and 0 <= nc < region_width and \\\n                               not visited[nr, nc] and grid_region[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store object details relative to the region it was found in\n                relative_coords = frozenset((coord[0] - min_r, coord[1] - min_c) for coord in coords)\n                bbox = (min_r, min_c, max_r, max_c)\n                obj_height = max_r - min_r + 1\n                obj_width = max_c - min_c + 1\n                \n                # Create normalized grid representation\n                normalized_grid = np.full((obj_height, obj_width), background_color, dtype=int)\n                for rel_r, rel_c in relative_coords:\n                    normalized_grid[rel_r, rel_c] = color\n\n                objects.append({\n                    'color': color,\n                    'coords': coords, # Coordinates relative to the original region\n                    'bbox': bbox,     # Bbox relative to the original region\n                    'min_col': min_c, # Min column for sorting horizontally\n                    'pixel_count': len(coords),\n                    'normalized_grid': normalized_grid\n                })\n\n    # Sort objects by horizontal position (min column)\n    objects.sort(key=lambda obj: obj['min_col'])\n    return objects\n\ndef get_object_shape_type(obj_details):\n    \"\"\"Determines if the object shape is 'Plus' or 'T' based on pixel count.\"\"\"\n    # Based on observations from training examples for the middle (red) object\n    if obj_details['pixel_count'] == 5:\n        return 'Plus'\n    elif obj_details['pixel_count'] == 4:\n        return 'T'\n    else:\n        # Fallback or error for unexpected shapes\n        # print(f\"Warning: Unexpected pixel count {obj_details['pixel_count']} for middle object.\")\n        return 'Unknown' # Or raise error\n\ndef are_objects_identical(obj1_details, obj2_details):\n    \"\"\"Checks if two objects have the same color and normalized shape.\"\"\"\n    return obj1_details['color'] == obj2_details['color'] and \\\n           np.array_equal(obj1_details['normalized_grid'], obj2_details['normalized_grid'])\n\n# Main transformation function\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n    \n    # 1. Find the gray line\n    gray_line_r = find_gray_line_row(input_np)\n    if gray_line_r == -1:\n        raise ValueError(\"Gray dividing line not found.\")\n\n    # 2. Define top and bottom regions\n    top_region = input_np[:gray_line_r, :]\n    bottom_region = input_np[gray_line_r + 1:, :]\n\n    # 3. Find objects in the top half\n    top_objects = find_objects_in_region(top_region, background_color)\n    if len(top_objects) != 3:\n        raise ValueError(f\"Expected 3 objects in the top region, found {len(top_objects)}\")\n    \n    # 3a. Identify Leftmost, Middle, Rightmost based on sorted order\n    matched_obj_candidate = top_objects[0]\n    discarded_obj = top_objects[1]\n    other_obj = top_objects[2]\n\n    # 4. Find the Key Object in the bottom half\n    bottom_objects = find_objects_in_region(bottom_region, background_color)\n    if len(bottom_objects) != 1:\n        raise ValueError(f\"Expected 1 object in the bottom region, found {len(bottom_objects)}\")\n    key_obj = bottom_objects[0]\n\n    # 5. Verify Key Object matches the Leftmost (Matched Object)\n    if not are_objects_identical(key_obj, matched_obj_candidate):\n        raise ValueError(\"Key object from bottom does not match leftmost object from top.\")\n    matched_obj = matched_obj_candidate # Confirmed\n\n    # 6. Determine shape type of the Discarded (Middle) Object\n    discarded_shape_type = get_object_shape_type(discarded_obj)\n\n    # 7. Determine stacking order\n    if discarded_shape_type == 'Plus':\n        top_stacked_obj = matched_obj\n        bottom_stacked_obj = other_obj\n    elif discarded_shape_type == 'T':\n        top_stacked_obj = other_obj\n        bottom_stacked_obj = matched_obj\n    else:\n        raise ValueError(f\"Unknown or ambiguous shape type '{discarded_shape_type}' for discarded object.\")\n\n    # 8. Construct the output grid\n    top_norm = top_stacked_obj['normalized_grid']\n    bottom_norm = bottom_stacked_obj['normalized_grid']\n    padding = 1\n\n    # Calculate dimensions\n    output_height = top_norm.shape[0] + bottom_norm.shape[0] + (padding * 3)\n    output_width = max(top_norm.shape[1], bottom_norm.shape[1])\n    \n    # Initialize output grid\n    output_grid_np = np.full((output_height, output_width), background_color, dtype=int)\n\n    # Calculate placement positions (centered horizontally)\n    top_start_row = padding\n    top_start_col = (output_width - top_norm.shape[1]) // 2\n    \n    bottom_start_row = top_start_row + top_norm.shape[0] + padding\n    bottom_start_col = (output_width - bottom_norm.shape[1]) // 2\n\n    # Place objects\n    output_grid_np[top_start_row : top_start_row + top_norm.shape[0], \n                   top_start_col : top_start_col + top_norm.shape[1]] = top_norm\n                   \n    output_grid_np[bottom_start_row : bottom_start_row + bottom_norm.shape[0], \n                   bottom_start_col : bottom_start_col + bottom_norm.shape[1]] = bottom_norm\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5393,
    "candidates_token_count": 2462,
    "total_token_count": 7855,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.198346,
  "retries": null
}