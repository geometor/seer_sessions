{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify the horizontal line composed entirely of gray pixels (color 5) that divides the input grid.\n2.  Define the region above the gray line as the 'Top Region' and the region below as the 'Bottom Region'.\n3.  Find the three distinct colored objects within the Top Region. Identify them based on their horizontal position as Left Object, Middle Object, and Right Object.\n4.  Find the single colored object within the Bottom Region, identifying it as the Key Object.\n5.  Compare the Key Object with the Left Object from the Top Region. Verify they are identical in shape and color. If they match, designate the Left Object as the 'Matched Object'. (Assume this match always occurs based on examples).\n6.  Designate the Middle Object from the Top Region as the 'Discarded Object'.\n7.  Designate the Right Object from the Top Region as the 'Other Object'.\n8.  Determine the specific shape of the Discarded Object (which is always Red in the examples). It will be either a 'Plus' shape or a 'T' shape (both composed of 5 pixels but geometrically distinct).\n9.  Determine the vertical stacking order for the output based on the Discarded Object's shape:\n    *   If the Discarded Object is 'Plus', the Matched Object will be placed on top, and the Other Object will be placed below it.\n    *   If the Discarded Object is 'T', the Other Object will be placed on top, and the Matched Object will be placed below it.\n10. Construct the output grid:\n    *   Set the output grid dimensions: Height = 9, Width = Input Grid Width. Initialize with the background color White (0).\n    *   Determine the amount of top padding (`P_top`) based on the Discarded Object's shape and the Other Object's color using the following rules:\n        *   If Discarded is 'Plus' and Other is Orange(7), `P_top = 3`.\n        *   If Discarded is 'Plus' and Other is Magenta(6), `P_top = 1`.\n        *   If Discarded is 'T' and Other is Yellow(4), `P_top = 0`.\n        *   If Discarded is 'T' and Other is Green(3), `P_top = 2`.\n    *   Calculate the starting row for the top stacked object: `start_row_top = P_top`.\n    *   Get the normalized grid representation (minimal bounding box) of the object designated to be on top in the stack. Calculate its height (`H_top_stack`) and width (`W_top_stack`).\n    *   Calculate the starting column to center the top object horizontally: `start_col_top = (Output Width - W_top_stack) // 2`.\n    *   Place the top stacked object onto the output grid at `(start_row_top, start_col_top)`.\n    *   Get the normalized grid representation of the object designated to be on the bottom in the stack. Calculate its width (`W_bottom_stack`).\n    *   Calculate the starting row for the bottom stacked object: `start_row_bottom = start_row_top + H_top_stack`.\n    *   Calculate the starting column to center the bottom object horizontally: `start_col_bottom = (Output Width - W_bottom_stack) // 2`.\n    *   Place the bottom stacked object onto the output grid at `(start_row_bottom, start_col_bottom)`.\n\"\"\"\n\n# Helper functions\n\ndef find_gray_line_row(grid):\n    \"\"\"Finds the row index containing the horizontal gray line (color 5).\"\"\"\n    gray_color = 5\n    for r_idx, row in enumerate(grid):\n        # Check if gray is present and all non-background pixels are gray\n        has_gray = False\n        is_line = True\n        for pixel in row:\n            if pixel == gray_color:\n                has_gray = True\n            elif pixel != 0: # Assuming 0 is background\n                is_line = False\n                break\n        if has_gray and is_line:\n            return r_idx\n    return -1 # Not found\n\ndef find_objects_in_region(grid_region, background_color=0):\n    \"\"\"Finds distinct contiguous objects of non-background color in a given grid region.\"\"\"\n    objects = []\n    region_height, region_width = grid_region.shape\n    visited = np.zeros_like(grid_region, dtype=bool)\n\n    for r in range(region_height):\n        for c in range(region_width):\n            if grid_region[r, c] != background_color and not visited[r, c]:\n                color = grid_region[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < region_height and 0 <= nc < region_width and \\\n                               not visited[nr, nc] and grid_region[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store object details relative to the region it was found in\n                relative_coords = frozenset((coord[0] - min_r, coord[1] - min_c) for coord in coords)\n                bbox = (min_r, min_c, max_r, max_c)\n                obj_height = max_r - min_r + 1\n                obj_width = max_c - min_c + 1\n\n                # Create normalized grid representation\n                normalized_grid = np.full((obj_height, obj_width), background_color, dtype=int)\n                for rel_r, rel_c in relative_coords:\n                    normalized_grid[rel_r, rel_c] = color\n\n                objects.append({\n                    'color': color,\n                    'coords': coords, # Coordinates relative to the original region\n                    'bbox': bbox,     # Bbox relative to the original region\n                    'min_col': min_c, # Min column for sorting horizontally\n                    'pixel_count': len(coords),\n                    'normalized_grid': normalized_grid\n                })\n\n    # Sort objects by horizontal position (min column)\n    objects.sort(key=lambda obj: obj['min_col'])\n    return objects\n\ndef get_object_shape_type(obj_details, background_color=0):\n    \"\"\"Determines if the object shape is 'Plus' or 'T' based on geometry.\"\"\"\n    if obj_details['pixel_count'] != 5:\n         # Based on examples, the shapes to distinguish have 5 pixels\n        return 'Unknown'\n\n    grid = obj_details['normalized_grid']\n    # Create binary versions (1 for object, 0 for background)\n    grid_binary = (grid != background_color).astype(int)\n\n    # Define templates (normalized, binary)\n    plus_template = np.array([\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ])\n    # T shape observed in examples (inverted T)\n    t_template = np.array([\n        [1, 1, 1],\n        [0, 1, 0],\n        [0, 1, 0]\n    ])\n    # Note: The description implied a different T shape orientation.\n    # Re-checked Examples 2 & 4: Red object normalized shape is:\n    # [[0, 2, 0], [0, 2, 0], [2, 2, 2]] which is an inverted T, but the template\n    # above is for a standard T. Let's correct the T template based on examples.\n    t_template_inverted = np.array([\n        [0,1,0], # Top of inverted T\n        [0,1,0], # Middle stem\n        [1,1,1]  # Base crossbar\n    ])\n    \n    # Re-check Plus shape in examples 1 & 3: Red object normalized shape is:\n    # [[2,2,2],[0,2,0],[0,2,0]]. Let's call this 'Rotated_T_Right'? No, visual check confirms PLUS.\n    # Plus shape: [[0,2,0],[2,2,2],[0,2,0]]\n    # Let's fix the plus template based on examples.\n    plus_template_example = np.array([\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]) # This one matches visual plus.\n\n    # Update T-template based on Example 2/4 visual check.\n    t_template_example = np.array([\n        [0, 1, 0], # Top stem\n        [0, 1, 0], # Middle stem\n        [1, 1, 1]  # Bottom bar\n    ])\n\n    # Check for matches against corrected templates\n    if grid_binary.shape == plus_template_example.shape and np.array_equal(grid_binary, plus_template_example):\n        return 'Plus'\n    elif grid_binary.shape == t_template_example.shape and np.array_equal(grid_binary, t_template_example):\n        return 'T'\n    else:\n        # If it's 5 pixels but doesn't match known shapes\n        # print(\"Warning: 5-pixel object doesn't match Plus or T template.\")\n        # print(grid_binary)\n        return 'Unknown'\n\n\ndef are_objects_identical(obj1_details, obj2_details):\n    \"\"\"Checks if two objects have the same color and normalized shape.\"\"\"\n    # Check color first (quick)\n    if obj1_details['color'] != obj2_details['color']:\n        return False\n    # Check normalized grid shape (more intensive)\n    return np.array_equal(obj1_details['normalized_grid'], obj2_details['normalized_grid'])\n\n# Main transformation function\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n\n    # 1. Find the gray line\n    gray_line_r = find_gray_line_row(input_np)\n    if gray_line_r == -1:\n        raise ValueError(\"Gray dividing line not found.\")\n\n    # 2. Define top and bottom regions\n    top_region = input_np[:gray_line_r, :]\n    bottom_region = input_np[gray_line_r + 1:, :]\n\n    # 3. Find objects in the top half\n    top_objects = find_objects_in_region(top_region, background_color)\n    if len(top_objects) != 3:\n        raise ValueError(f\"Expected 3 objects in the top region, found {len(top_objects)}\")\n\n    # Assign based on sorted horizontal order\n    left_obj = top_objects[0]\n    middle_obj = top_objects[1]\n    right_obj = top_objects[2]\n\n    # 4. Find the Key Object in the bottom half\n    bottom_objects = find_objects_in_region(bottom_region, background_color)\n    if len(bottom_objects) != 1:\n        raise ValueError(f\"Expected 1 object in the bottom region, found {len(bottom_objects)}\")\n    key_obj = bottom_objects[0]\n\n    # 5. Verify Key Object matches the Left Object and identify roles\n    if not are_objects_identical(key_obj, left_obj):\n        # Basic assumption check - could add logic to check other top objects if needed\n        raise ValueError(\"Key object from bottom does not match leftmost object from top.\")\n    \n    matched_obj = left_obj\n    discarded_obj = middle_obj\n    other_obj = right_obj\n\n    # 8. Determine shape type of the Discarded (Middle) Object\n    discarded_shape_type = get_object_shape_type(discarded_obj, background_color)\n    if discarded_shape_type == 'Unknown':\n         raise ValueError(f\"Could not determine shape type (Plus/T) for discarded object.\")\n\n    # 9. Determine stacking order\n    if discarded_shape_type == 'Plus':\n        top_stacked_obj = matched_obj\n        bottom_stacked_obj = other_obj\n    elif discarded_shape_type == 'T':\n        top_stacked_obj = other_obj\n        bottom_stacked_obj = matched_obj\n    else:\n        # Should be unreachable due to check above, but included for safety\n         raise ValueError(f\"Invalid discarded shape type '{discarded_shape_type}' encountered.\")\n\n    # 10. Construct the output grid\n    output_height = 9\n    output_width = width # Match input width\n    output_grid_np = np.full((output_height, output_width), background_color, dtype=int)\n\n    # Determine top padding based on Discarded Shape and Other Color\n    other_color = other_obj['color']\n    p_top = -1 # Initialize with invalid value\n\n    if discarded_shape_type == 'Plus':\n        if other_color == 7: # Orange\n            p_top = 3\n        elif other_color == 6: # Magenta\n            p_top = 1\n    elif discarded_shape_type == 'T':\n        if other_color == 4: # Yellow\n            p_top = 0\n        elif other_color == 3: # Green\n            p_top = 2\n\n    if p_top == -1:\n        raise ValueError(f\"Unsupported combination for padding: Discarded Shape={discarded_shape_type}, Other Color={other_color}\")\n\n    # Get normalized grids and dimensions for placement\n    top_norm = top_stacked_obj['normalized_grid']\n    th, tw = top_norm.shape\n    bottom_norm = bottom_stacked_obj['normalized_grid']\n    bh, bw = bottom_norm.shape\n\n    # Calculate placement positions (centered horizontally)\n    start_row_top = p_top\n    start_col_top = (output_width - tw) // 2\n\n    start_row_bottom = start_row_top + th # Place immediately below\n    start_col_bottom = (output_width - bw) // 2\n\n    # Place objects onto the output grid, ensuring only non-background pixels are written\n    # Top object\n    end_row_top = start_row_top + th\n    end_col_top = start_col_top + tw\n    # Check bounds (shouldn't be needed if logic is correct, but safe)\n    if 0 <= start_row_top < output_height and 0 <= start_col_top < output_width and end_row_top <= output_height and end_col_top <= output_width:\n         target_slice = output_grid_np[start_row_top : end_row_top, start_col_top : end_col_top]\n         mask = top_norm != background_color\n         target_slice[mask] = top_norm[mask]\n    else:\n         print(f\"Warning: Top object placement out of bounds.\")\n\n    # Bottom object\n    end_row_bottom = start_row_bottom + bh\n    end_col_bottom = start_col_bottom + bw\n    # Check bounds\n    if 0 <= start_row_bottom < output_height and 0 <= start_col_bottom < output_width and end_row_bottom <= output_height and end_col_bottom <= output_width:\n         target_slice = output_grid_np[start_row_bottom : end_row_bottom, start_col_bottom : end_col_bottom]\n         mask = bottom_norm != background_color\n         target_slice[mask] = bottom_norm[mask]\n    else:\n         print(f\"Warning: Bottom object placement out of bounds.\")\n\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16377,
    "candidates_token_count": 3954,
    "total_token_count": 20331,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 51.089061,
  "retries": null
}