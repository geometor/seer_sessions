
## train_1

**input:**
```
0 5 5 4 0 0 0 0 0 0 0 5 5 5 5
0 0 4 0 0 5 5 4 5 0 0 5 0 5 5
5 0 5 0 0 0 4 4 5 0 5 5 5 0 5
5 0 0 5 0 5 5 4 0 0 0 5 5 0 5
5 5 0 5 0 5 0 0 0 5 5 0 0 5 0
0 5 0 0 5 0 5 5 0 0 5 5 5 0 0
5 5 0 5 5 0 0 5 0 0 0 0 0 0 0
5 5 4 0 5 0 5 0 0 5 0 5 0 5 5
5 4 5 4 0 5 5 0 4 5 4 5 0 5 0
5 5 5 0 0 5 5 0 0 4 0 5 0 5 5
0 0 0 5 0 0 0 0 0 0 0 0 5 0 5
0 5 0 0 5 0 5 0 0 5 5 0 5 0 0
0 0 0 0 0 5 0 5 5 0 0 0 0 0 5
0 5 0 0 5 5 5 5 0 5 0 5 0 0 0
```


**output:**
```
0 2 2 4 0 0 0 0 0 0 0 5 5 5 5
0 0 4 0 0 5 5 4 5 0 0 5 0 5 5
5 0 5 0 0 0 4 4 2 0 5 5 5 0 5
5 0 0 5 0 5 5 4 0 0 0 5 5 0 5
5 5 0 5 0 5 0 0 0 5 5 0 0 5 0
0 5 0 0 5 0 5 5 0 0 5 5 5 0 0
5 5 0 5 5 0 0 5 0 0 0 0 0 0 0
5 5 4 0 5 0 5 0 0 2 0 5 0 5 5
5 4 2 4 0 5 5 0 4 2 4 5 0 5 0
5 5 2 0 0 5 5 0 0 4 0 5 0 5 5
0 0 0 5 0 0 0 0 0 0 0 0 5 0 5
0 5 0 0 5 0 5 0 0 5 5 0 5 0 0
0 0 0 0 0 5 0 5 5 0 0 0 0 0 5
0 5 0 0 5 5 5 5 0 5 0 5 0 0 0
```


## train_2

**input:**
```
0 5 0 0 5 5 0 0 0 5 5 0 5 0 0 5
5 5 0 0 0 0 5 0 5 0 0 5 5 5 0 0
0 0 4 5 0 5 0 5 5 0 0 4 5 5 5 0
0 5 5 4 0 0 5 0 0 5 0 0 4 0 0 5
0 0 4 5 0 0 5 0 5 0 0 0 0 0 5 0
0 0 0 5 0 5 5 5 5 0 5 0 5 5 0 5
5 0 5 0 0 4 5 4 5 5 5 5 0 5 0 0
0 0 0 0 5 5 4 5 5 0 0 0 0 0 0 5
0 0 5 5 0 0 5 0 5 5 0 5 5 4 5 0
0 0 5 0 0 5 0 0 0 5 5 0 5 5 4 5
5 0 0 4 0 0 0 0 5 0 0 0 0 5 5 5
5 5 4 5 4 5 0 5 5 5 0 0 0 0 5 5
5 0 0 5 5 5 0 5 4 5 4 0 5 0 0 0
5 0 0 5 5 0 0 5 0 4 0 0 0 5 5 0
5 5 5 5 5 0 0 0 5 5 5 0 5 5 0 0
5 5 5 5 0 0 0 0 5 0 5 5 5 5 0 5
5 0 5 0 0 0 0 0 5 0 5 0 5 5 0 0
5 0 0 0 0 5 0 0 5 5 5 5 0 0 0 5
```


**output:**
```
0 5 0 0 5 5 0 0 0 5 5 0 5 0 0 5
5 5 0 0 0 0 5 0 5 0 0 5 2 5 0 0
0 0 4 5 0 5 0 5 5 0 0 4 2 2 5 0
0 2 2 4 0 0 5 0 0 5 0 0 4 0 0 5
0 0 4 5 0 0 5 0 5 0 0 0 0 0 5 0
0 0 0 5 0 5 2 5 5 0 5 0 5 5 0 5
5 0 5 0 0 4 2 4 5 5 5 5 0 5 0 0
0 0 0 0 5 5 4 5 5 0 0 0 0 0 0 5
0 0 5 5 0 0 5 0 5 5 0 5 5 4 5 0
0 0 5 0 0 5 0 0 0 5 5 0 2 2 4 5
5 0 0 4 0 0 0 0 5 0 0 0 0 2 5 5
5 5 4 2 4 5 0 5 5 2 0 0 0 0 5 5
5 0 0 2 5 5 0 5 4 2 4 0 5 0 0 0
5 0 0 5 5 0 0 5 0 4 0 0 0 5 5 0
5 5 5 5 5 0 0 0 5 5 5 0 5 5 0 0
5 5 5 5 0 0 0 0 5 0 5 5 5 5 0 5
5 0 5 0 0 0 0 0 5 0 5 0 5 5 0 0
5 0 0 0 0 5 0 0 5 5 5 5 0 0 0 5
```


## train_3

**input:**
```
0 0 5 0 0 0 0 0 0 5 0 0 5 0 0
0 5 0 0 0 5 5 5 0 5 5 0 5 5 5
0 0 5 0 0 0 5 5 0 5 0 0 5 5 5
5 5 5 4 5 0 0 0 4 4 5 0 5 0 5
0 5 4 5 0 0 0 0 0 5 0 5 0 0 5
5 0 5 0 5 0 0 0 0 0 0 5 5 0 5
0 0 0 5 0 5 0 0 0 0 0 0 0 5 5
5 5 0 0 5 5 0 5 0 5 5 0 0 0 0
5 0 5 0 0 5 5 5 4 5 0 0 0 5 0
0 4 5 5 0 0 5 4 5 5 5 5 0 0 0
0 5 4 5 0 5 5 5 0 0 0 0 5 0 5
0 0 5 0 0 0 5 5 0 0 5 0 5 0 0
0 0 5 0 0 0 0 0 0 0 5 0 5 5 5
0 0 0 5 5 5 0 5 0 0 5 5 0 5 0
```


**output:**
```
0 0 5 0 0 0 0 0 0 5 0 0 5 0 0
0 5 0 0 0 5 5 5 0 5 5 0 5 5 5
0 0 2 0 0 0 5 5 0 2 0 0 5 5 5
5 2 2 4 5 0 0 0 4 4 2 0 5 0 5
0 5 4 5 0 0 0 0 0 2 0 5 0 0 5
5 0 5 0 5 0 0 0 0 0 0 5 5 0 5
0 0 0 5 0 5 0 0 0 0 0 0 0 5 5
5 5 0 0 5 5 0 2 0 5 5 0 0 0 0
5 0 2 0 0 5 2 2 4 5 0 0 0 5 0
0 4 2 2 0 0 5 4 5 5 5 5 0 0 0
0 5 4 5 0 5 5 5 0 0 0 0 5 0 5
0 0 5 0 0 0 5 5 0 0 5 0 5 0 0
0 0 5 0 0 0 0 0 0 0 5 0 5 5 5
0 0 0 5 5 5 0 5 0 0 5 5 0 5 0
```


## train_4

**input:**
```
0 5 0 5 5 0 5 5 5 0 0 0 5 0 0 5 0 5 0
0 0 0 5 0 0 0 5 5 5 0 0 0 0 5 5 0 0 0
0 5 5 0 0 0 5 0 5 5 0 0 0 0 5 0 0 5 0
0 0 5 5 0 5 5 0 0 5 5 0 5 0 5 0 5 0 0
0 0 5 0 0 4 0 5 0 5 0 5 0 0 0 5 5 0 5
0 0 5 0 4 5 4 5 5 0 5 0 0 0 5 4 5 5 5
5 0 0 0 0 4 0 0 5 5 0 0 0 0 5 4 4 5 0
5 0 5 5 5 5 0 5 0 0 0 5 0 5 0 4 5 0 0
5 5 0 0 5 0 5 0 5 5 0 5 5 5 5 5 0 0 0
5 5 0 0 5 5 5 0 5 0 0 5 0 0 5 0 0 0 0
0 0 5 5 0 0 0 0 5 4 5 0 5 5 0 0 0 0 0
5 5 5 4 0 5 0 5 5 4 4 5 0 0 5 5 5 5 0
0 0 4 5 0 0 5 5 0 4 5 0 5 0 0 5 5 5 5
0 0 0 0 5 0 0 5 0 0 0 0 5 0 5 0 0 5 5
5 5 0 5 0 0 0 5 5 5 5 5 0 5 0 0 0 0 0
5 5 0 0 0 5 0 0 0 0 0 0 0 5 0 5 0 0 5
5 0 5 0 5 5 0 5 5 0 0 0 0 5 5 0 0 0 0
0 5 5 0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
```


**output:**
```
0 5 0 5 5 0 5 5 5 0 0 0 5 0 0 5 0 5 0
0 0 0 5 0 0 0 5 5 5 0 0 0 0 5 5 0 0 0
0 5 5 0 0 0 5 0 5 5 0 0 0 0 5 0 0 5 0
0 0 5 5 0 5 5 0 0 5 5 0 5 0 5 0 5 0 0
0 0 5 0 0 4 0 5 0 5 0 5 0 0 0 5 5 0 5
0 0 5 0 4 2 4 5 5 0 5 0 0 0 5 4 5 5 5
5 0 0 0 0 4 0 0 5 5 0 0 0 0 2 4 4 5 0
5 0 5 5 5 5 0 5 0 0 0 5 0 5 0 4 5 0 0
5 5 0 0 5 0 5 0 5 5 0 5 5 5 5 5 0 0 0
5 5 0 0 5 5 5 0 5 0 0 5 0 0 5 0 0 0 0
0 0 2 5 0 0 0 0 5 4 5 0 5 5 0 0 0 0 0
5 2 2 4 0 5 0 5 2 4 4 5 0 0 5 5 5 5 0
0 0 4 5 0 0 5 5 0 4 5 0 5 0 0 5 5 5 5
0 0 0 0 5 0 0 5 0 0 0 0 5 0 5 0 0 5 5
5 5 0 5 0 0 0 5 5 5 5 5 0 5 0 0 0 0 0
5 5 0 0 0 5 0 0 0 0 0 0 0 5 0 5 0 0 5
5 0 5 0 5 5 0 5 5 0 0 0 0 5 5 0 0 0 0
0 5 5 0 0 0 0 0 0 5 5 5 5 5 0 0 0 0 0
```

Okay, let's analyze the task examples.

**Perception of Elements:**

1.  **Grid Structure:** Both input and output are 2D grids of pixels with varying dimensions across examples.
2.  **Colors:** The primary colors involved are white (0 - background), gray (5), and yellow (4). In the output, a new color, red (2), appears.
3.  **Transformation Focus:** The changes between input and output grids are localized. Only certain gray (5) pixels are modified. All other pixels retain their original color and position.
4.  **Pattern of Change:** The gray (5) pixels that change to red (2) are always adjacent (sharing an edge, not just a corner) to yellow (4) pixels.
5.  **Condition for Change:** Observing the locations where gray pixels change to red, it appears the condition is that the gray pixel must be orthogonally adjacent (up, down, left, or right) to exactly *two* yellow (4) pixels. Gray pixels adjacent to zero, one, three, or four yellow pixels remain unchanged.

**Fact Documentation:**


```yaml
task_description: Identify gray pixels that are orthogonally adjacent to exactly two yellow pixels and change their color to red.

elements:
  - element: grid
    description: A 2D array of integers representing pixel colors. Dimensions vary.
  - element: pixel
    description: Represents a single cell in the grid with a color value (0-9).
    properties:
      - color: The integer value representing the color.
      - position: Coordinates (row, column) within the grid.
      - neighbors: Pixels directly above, below, left, and right (orthogonal adjacency).

colors:
  - color: white (0)
    role: Background, unchanged.
  - color: gray (5)
    role: Structural element, potentially modified.
  - color: yellow (4)
    role: Trigger element, unchanged. Influences adjacent gray pixels.
  - color: red (2)
    role: Result element, appears only in the output. Replaces specific gray pixels.

transformation:
  - action: Iterate through each pixel of the input grid.
  - condition: Check if the current pixel's color is gray (5).
  - sub_condition: If it is gray, count its orthogonal neighbors (up, down, left, right).
  - sub_condition_check: Count how many of these neighbors have the color yellow (4).
  - rule:
      - If the count of yellow neighbors is exactly 2:
          - Change the color of the current pixel to red (2) in the output grid.
      - Otherwise (count is 0, 1, 3, or 4):
          - Keep the pixel's color as gray (5) in the output grid.
  - default_action: If the current pixel's color is *not* gray (5), keep its original color in the output grid.
  - output: The resulting grid after applying the transformation to all relevant pixels. It has the same dimensions as the input grid.

relationships:
  - type: adjacency
    description: Orthogonal adjacency (sharing an edge) between pixels is crucial.
  - type: trigger
    description: Yellow (4) pixels trigger a change in adjacent gray (5) pixels based on a specific count (exactly 2).
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the basis for the output grid.
2.  Examine every pixel in the input grid, one by one.
3.  For each pixel, check if its color is gray (value 5).
4.  If the pixel is gray, inspect its four neighbors (up, down, left, right), staying within the grid boundaries.
5.  Count how many of these neighbors are yellow (value 4).
6.  If the count of yellow neighbors is exactly two, change the color of the corresponding pixel in the output grid copy to red (value 2).
7.  If the pixel is not gray, or if it is gray but does not have exactly two yellow neighbors, leave its color unchanged in the output grid copy.
8.  After checking all pixels, the modified grid copy is the final output.
