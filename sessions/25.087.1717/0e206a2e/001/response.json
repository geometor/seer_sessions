{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import defaultdict\nimport math\n\n\"\"\"\nThis program transforms an input grid based on identifying a 'pattern object', pairs of red and blue pixels, and associated yellow pixels.\n\n1.  **Find Pattern Object:** Identifies the largest contiguous object (group of connected pixels of the same color) that is not composed solely of red (2), blue (1), or yellow (4). The color of this object is recorded ('Line Color').\n2.  **Identify Targets and Association:** Locates all red, blue, and yellow pixels. Determines which of these are 'associated' with the pattern object (either part of it or directly adjacent, cardinally or diagonally).\n3.  **Find Valid Pairs:** Finds pairs of (Red pixel, Blue pixel) where neither pixel in the pair is associated with the pattern object.\n4.  **Initialize Output & Remove Pattern:** Creates an output grid by copying the input, then removes the pattern object by setting its pixels to white (0).\n5.  **Draw Lines:** For each valid (Red, Blue) pair:\n    a.  Calculates the coordinates for a line segment connecting them using the 'Line Color'.\n    b.  The line segment runs along the main cardinal axis (horizontal or vertical) between the pair.\n    c.  It starts one pixel away from the Blue pixel (towards Red) and ends one pixel away from the Red pixel (towards Blue).\n    d.  Draws this line on the output grid. The original Red and Blue pixels of the pair are removed (set to white 0).\n6.  **Reposition Yellows:** Identifies Yellow pixels not associated with the pattern object.\n    a.  For each such Yellow pixel, finds the closest Red or Blue pixel that belongs to a valid pair found in step 3.\n    b.  If the distance is within a threshold (<= 5 units):\n        i.  Determines which end (Red or Blue) of the pair the Yellow is closest to.\n        ii. Finds the corresponding end-pixel of the line segment drawn for that pair in step 5.\n        iii.Calculates the Yellow's original column offset relative to its closest Red/Blue partner.\n        iv. Removes the original Yellow pixel from the output grid.\n        v.  Places the Yellow pixel in the output grid at a new location: same row as the line segment's end-pixel, and column calculated by adding the original column offset to the line segment end-pixel's column.\n7.  **Final Output:** Returns the modified grid containing the drawn lines and repositioned yellows, with the pattern object and original paired red/blue/yellow pixels removed.\n\"\"\"\n\ndef get_neighbors(coord, grid_shape, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given coordinate.\"\"\"\n    r, c = coord\n    neighbors = []\n    rows, cols = grid_shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components (objects) in the grid.\"\"\"\n    objects = defaultdict(list)\n    labeled_grid, num_features = label(grid > 0) # Label non-background pixels\n\n    if num_features == 0:\n        return objects\n\n    # Use find_objects to get bounding boxes, then refine\n    slices = find_objects(labeled_grid)\n    for i, sl in enumerate(slices):\n        if sl is None: continue\n        label_id = i + 1\n        component_mask = (labeled_grid[sl] == label_id)\n        coords = np.argwhere(component_mask)\n        \n        # Adjust coordinates relative to the original grid\n        offset_r, offset_c = sl[0].start, sl[1].start\n        abs_coords = [(r + offset_r, c + offset_c) for r, c in coords]\n\n        # Get the color (assuming uniform color within component)\n        if abs_coords:\n            color = grid[abs_coords[0]]\n            objects[label_id] = {'color': color, 'coords': abs_coords, 'size': len(abs_coords)}\n\n    return objects\n    \ndef calculate_distance(p1, p2):\n    \"\"\"Calculates Euclidean distance between two points.\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n\ndef transform(input_grid_np):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = input_grid_np.tolist() # Work with lists of lists for easier modification initially\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    output_grid = [row[:] for row in input_grid] # Make a deep copy\n\n    # --- 1. Find Pattern Object ---\n    objects = find_connected_components(np.array(input_grid))\n    pattern_object = None\n    max_size = -1\n    pattern_object_pixels = set()\n    line_color = 0 # Default to white if no pattern object found\n\n    candidate_objects = []\n    for obj_id, obj_data in objects.items():\n        color = obj_data['color']\n        # Exclude objects made entirely of red, blue, or yellow\n        if color not in [1, 2, 4]:\n             candidate_objects.append(obj_data)\n\n    if candidate_objects:\n        # Find the largest among the candidates\n        pattern_object = max(candidate_objects, key=lambda o: o['size'])\n        line_color = pattern_object['color']\n        pattern_object_pixels = set(pattern_object['coords'])\n        # print(f\"Found Pattern Object: Color={line_color}, Size={pattern_object['size']}\")\n    else:\n        # Handle case where no suitable pattern object is found (maybe return input?)\n        # print(\"No suitable pattern object found.\")\n        pass # Continue processing without a pattern object removal/line color?\n\n    # --- 2. Identify Targets and Association ---\n    red_pixels = []\n    blue_pixels = []\n    yellow_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r][c]\n            if color == 2:\n                red_pixels.append((r, c))\n            elif color == 1:\n                blue_pixels.append((r, c))\n            elif color == 4:\n                yellow_pixels.append((r, c))\n\n    associated_pixels = set(pattern_object_pixels)\n    if pattern_object:\n        for r_obj, c_obj in pattern_object_pixels:\n            neighbors = get_neighbors((r_obj, c_obj), (rows, cols), include_diagonal=True)\n            associated_pixels.update(neighbors)\n\n    non_associated_red = [p for p in red_pixels if p not in associated_pixels]\n    non_associated_blue = [p for p in blue_pixels if p not in associated_pixels]\n    non_associated_yellow = [p for p in yellow_pixels if p not in associated_pixels]\n\n    # --- 3. Find Valid Pairs ---\n    # For simplicity, assume pairs are axis-aligned and unique for now\n    # A more robust approach might check distances or relative positions\n    valid_pairs = []\n    paired_red = set()\n    paired_blue = set()\n    all_pair_partners = [] # Store coords of all red/blue pixels in valid pairs\n\n    # Try pairing based on being on the same row or column\n    # Horizontal pairs\n    row_blues = defaultdict(list)\n    row_reds = defaultdict(list)\n    for r, c in non_associated_blue: row_blues[r].append((r,c))\n    for r, c in non_associated_red: row_reds[r].append((r,c))\n\n    for r in row_blues:\n        if r in row_reds:\n            # Simple 1-to-1 pairing for now\n            for b_coord in row_blues[r]:\n                 if b_coord in paired_blue: continue\n                 # Find closest red in the same row\n                 closest_r_coord = min(row_reds[r], key=lambda r_coord: abs(r_coord[1] - b_coord[1]) if r_coord not in paired_red else float('inf'))\n                 if closest_r_coord not in paired_red:\n                     valid_pairs.append({'red': closest_r_coord, 'blue': b_coord, 'axis': 'h'})\n                     paired_red.add(closest_r_coord)\n                     paired_blue.add(b_coord)\n                     all_pair_partners.extend([closest_r_coord, b_coord])\n\n\n    # Vertical pairs (only consider remaining unpaired pixels)\n    col_blues = defaultdict(list)\n    col_reds = defaultdict(list)\n    for r, c in non_associated_blue:\n        if (r,c) not in paired_blue: col_blues[c].append((r,c))\n    for r, c in non_associated_red:\n        if (r,c) not in paired_red: col_reds[c].append((r,c))\n\n    for c in col_blues:\n        if c in col_reds:\n             # Simple 1-to-1 pairing for now\n            for b_coord in col_blues[c]:\n                 if b_coord in paired_blue: continue\n                 # Find closest red in the same column\n                 closest_r_coord = min(col_reds[c], key=lambda r_coord: abs(r_coord[0] - b_coord[0]) if r_coord not in paired_red else float('inf'))\n                 if closest_r_coord not in paired_red:\n                     valid_pairs.append({'red': closest_r_coord, 'blue': b_coord, 'axis': 'v'})\n                     paired_red.add(closest_r_coord)\n                     paired_blue.add(b_coord)\n                     all_pair_partners.extend([closest_r_coord, b_coord])\n\n    # --- 4. Initialize Output Grid and Remove Pattern Object ---\n    if pattern_object:\n        for r_obj, c_obj in pattern_object_pixels:\n            output_grid[r_obj][c_obj] = 0 # Set pattern object pixels to white\n\n    # --- 5. Draw Lines ---\n    line_endpoints = {} # Store {pair_index: {'red_end': (r,c), 'blue_end': (r,c)}}\n    pixels_to_clear = set() # Track original pair pixels to remove\n\n    for i, pair in enumerate(valid_pairs):\n        r_r, c_r = pair['red']\n        r_b, c_b = pair['blue']\n        pixels_to_clear.add((r_r, c_r))\n        pixels_to_clear.add((r_b, c_b))\n\n        start_r, start_c = -1, -1 # Pixel next to blue, towards red\n        end_r, end_c = -1, -1 # Pixel next to red, towards blue\n\n        if pair['axis'] == 'h': # Horizontal\n            start_r, end_r = r_r, r_r # Same row\n            if c_r > c_b: # Red is right of Blue\n                start_c = c_b + 1\n                end_c = c_r - 1\n                for c in range(start_c, end_c + 1):\n                   if 0 <= c < cols: output_grid[start_r][c] = line_color\n            else: # Blue is right of Red\n                start_c = c_b - 1\n                end_c = c_r + 1\n                for c in range(end_c, start_c + 1):\n                    if 0 <= c < cols: output_grid[start_r][c] = line_color\n            line_endpoints[i] = {'blue_end': (start_r, start_c), 'red_end': (end_r, end_c)}\n\n        elif pair['axis'] == 'v': # Vertical\n            start_c, end_c = c_r, c_r # Same col\n            if r_r > r_b: # Red is below Blue\n                start_r = r_b + 1\n                end_r = r_r - 1\n                for r in range(start_r, end_r + 1):\n                   if 0 <= r < rows: output_grid[r][start_c] = line_color\n            else: # Blue is below Red\n                start_r = r_b - 1\n                end_r = r_r + 1\n                for r in range(end_r, start_r + 1):\n                    if 0 <= r < rows: output_grid[r][start_c] = line_color\n            line_endpoints[i] = {'blue_end': (start_r, start_c), 'red_end': (end_r, end_c)}\n\n    # --- 6 & 7. Identify and Reposition Yellow Pixels ---\n    yellows_to_move = [] # Store (original_coord, new_coord)\n\n    for y_coord in non_associated_yellow:\n        if not all_pair_partners: break # No pairs to associate with\n\n        # Find closest red/blue partner\n        closest_dist = float('inf')\n        closest_partner = None\n        partner_type = None # 'red' or 'blue'\n        closest_pair_index = -1\n\n        for idx, pair in enumerate(valid_pairs):\n             dist_r = calculate_distance(y_coord, pair['red'])\n             dist_b = calculate_distance(y_coord, pair['blue'])\n\n             if dist_r < closest_dist:\n                 closest_dist = dist_r\n                 closest_partner = pair['red']\n                 partner_type = 'red'\n                 closest_pair_index = idx\n             if dist_b < closest_dist:\n                 closest_dist = dist_b\n                 closest_partner = pair['blue']\n                 partner_type = 'blue'\n                 closest_pair_index = idx\n\n        # Check distance threshold\n        if closest_dist <= 5.0 and closest_pair_index != -1:\n            # Get corresponding line endpoint\n            if partner_type == 'red':\n                line_end_coord = line_endpoints[closest_pair_index]['red_end']\n            else: # partner_type == 'blue'\n                line_end_coord = line_endpoints[closest_pair_index]['blue_end']\n\n            # Calculate original column offset\n            col_offset = y_coord[1] - closest_partner[1]\n\n            # Calculate new position\n            new_r = line_end_coord[0]\n            new_c = line_end_coord[1] + col_offset\n\n            # Check bounds before adding to move list\n            if 0 <= new_r < rows and 0 <= new_c < cols:\n                 yellows_to_move.append({'from': y_coord, 'to': (new_r, new_c)})\n\n\n    # Perform yellow moves after calculating all\n    moved_yellow_origins = set()\n    for move in yellows_to_move:\n        from_r, from_c = move['from']\n        to_r, to_c = move['to']\n        \n        # Important: Only clear original if not overwritten by a line or another yellow's target\n        # Check if target is already occupied by something important (line, another yellow)\n        # Simple approach: just move, potentially overwriting. Refined logic might be needed.\n        \n        # Clear original position (add to set to clear later, avoid issues if multiple yellows map to same origin)\n        moved_yellow_origins.add((from_r, from_c))\n        \n        # Place yellow at new position\n        output_grid[to_r][to_c] = 4 # Yellow color\n\n\n    # --- 8. Final Cleanup ---\n    # Clear original red/blue pair pixels and moved yellow origins\n    pixels_to_clear.update(moved_yellow_origins)\n    for r_clear, c_clear in pixels_to_clear:\n         # Only clear if not occupied by a *newly placed* yellow target or a line segment endpoint\n         is_new_yellow_target = any(move['to'] == (r_clear, c_clear) for move in yellows_to_move)\n         is_line_endpoint = any(ep == (r_clear, c_clear) for pair_ends in line_endpoints.values() for ep in pair_ends.values())\n         \n         # Check if it's part of a drawn line segment (more thorough)\n         is_on_line = False\n         # ... (complex to check efficiently here, current drawing overwrites anyway)\n\n         # Simple clear for now\n         if not is_new_yellow_target: # Prioritize keeping the moved yellow\n              output_grid[r_clear][c_clear] = 0\n\n\n    return np.array(output_grid) # Convert back to numpy array\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5219,
    "candidates_token_count": 4092,
    "total_token_count": 9311,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.329149,
  "retries": null
}