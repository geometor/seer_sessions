{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all distinct contiguous objects of azure (8) pixels using 4-way adjacency.\n2. Order these objects based on their top-most, then left-most pixel coordinate.\n3. Count the total number of objects (N).\n4. Classify each object as 'Above' or 'Below' based on its vertical center relative to the grid's horizontal midline.\n5. Select two color sequences, SeqA (for Above) and SeqB (for Below), based on N:\n    - N=4: SeqA=[3], SeqB=[7]\n    - N=5: SeqA=[1, 3], SeqB=[2, 1]\n    - N=6: SeqA=[2, 3], SeqB=[2, 1, 2, 7]\n    - Default: No change / specific default sequence if N is not 4, 5, or 6.\n6. Assign colors cyclically from SeqA to 'Above' objects and from SeqB to 'Below' objects, respecting their original discovery order within each group.\n7. Recolor the pixels of each original azure object with its newly assigned color in the output grid.\n\"\"\"\n\ndef find_objects_ordered(grid: np.ndarray, color_val: int) -> list:\n    \"\"\"\n    Finds all distinct contiguous objects of a given color in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        color_val: The integer value of the color to find objects of.\n\n    Returns:\n        A list of objects, where each object is represented by a list\n        of its coordinate tuples (row, col). Objects are ordered by their\n        top-most, then left-most pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color_val and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n\n                    # Check neighbors (4-way adjacency)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = row + dr, col + dc\n                         if 0 <= nr < rows and 0 <= nc < cols and \\\n                            grid[nr, nc] == color_val and not visited[nr, nc]:\n                             visited[nr, nc] = True\n                             q.append((nr, nc))\n                \n                if obj_coords: # Should always be true if we start from a valid cell\n                     objects.append(obj_coords)\n                     \n    # The raster scan order inherently sorts by top-left coordinate.\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid list.\n    \n    Identifies azure (8) objects, counts them, determines their position relative\n    to the midline, selects color sequences based on the count, assigns colors\n    based on position and sequence cycling, and recolors the objects.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # 1. Identify and order azure (8) objects\n    azure_objects = find_objects_ordered(input_grid, 8)\n    \n    # 2. Count objects\n    N = len(azure_objects)\n    \n    # If no azure objects, return the original grid\n    if N == 0:\n        return input_grid_list\n\n    # 3. Determine midline\n    # Use floating point for accurate comparison with center\n    mid_row_float = (rows - 1) / 2.0 \n\n    # 4. Classify objects and prepare for color assignment\n    above_objects_indices = []\n    below_objects_indices = []\n    object_centers = {} # Store center row for classification\n\n    for i, coords in enumerate(azure_objects):\n        coords_array = np.array(coords)\n        center_r = np.mean(coords_array[:, 0])\n        object_centers[i] = center_r\n        if center_r < mid_row_float:\n            above_objects_indices.append(i)\n        else:\n            below_objects_indices.append(i)\n            \n    # 5. Select color sequences based on N\n    SeqA = [] # Default empty sequence\n    SeqB = [] # Default empty sequence\n    valid_n = True\n\n    if N == 4:\n        SeqA = [3]  # Green\n        SeqB = [7]  # Orange\n    elif N == 5:\n        SeqA = [1, 3]  # Blue, Green\n        SeqB = [2, 1]  # Red, Blue\n    elif N == 6:\n        SeqA = [2, 3]  # Red, Green\n        SeqB = [2, 1, 2, 7] # Red, Blue, Red, Orange\n    else:\n        # If N is not 4, 5, or 6, return the original grid as per observation\n        # Alternatively, could raise an error or have a different default.\n        valid_n = False\n        return input_grid_list \n\n    # 6. Assign colors\n    object_color_map = {}\n    \n    # Assign colors to 'Above' objects\n    if SeqA: # Check if sequence is not empty\n        for i, obj_index in enumerate(above_objects_indices):\n            color = SeqA[i % len(SeqA)]\n            object_color_map[obj_index] = color\n\n    # Assign colors to 'Below' objects\n    if SeqB: # Check if sequence is not empty\n        for i, obj_index in enumerate(below_objects_indices):\n            color = SeqB[i % len(SeqB)]\n            object_color_map[obj_index] = color\n            \n    # 7. Recolor the output grid\n    for i, coords in enumerate(azure_objects):\n        # Ensure every object got assigned a color (should happen if valid_n is True)\n        if i in object_color_map:\n            assigned_color = object_color_map[i]\n            for r, c in coords:\n                output_grid[r, c] = assigned_color\n        # else: # Optional: Handle cases where an object might not get a color if logic changes\n        #    pass \n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27012,
    "candidates_token_count": 1587,
    "total_token_count": 28599,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.285423,
  "retries": null
}