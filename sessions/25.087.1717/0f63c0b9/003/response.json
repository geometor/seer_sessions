{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid containing sparse colored pixels into an output grid with horizontal zones and vertical borders defined by those pixels.\n\n1.  Identify all non-white pixels in the input grid, recording their color and row index. If no non-white pixels are found, return an all-white grid of the same dimensions.\n2.  Determine the unique rows containing non-white pixels and associate each unique row with the color found in that row. If multiple colors exist in the same row, use the color of the first encountered non-white pixel in that row during a top-to-bottom, left-to-right scan (though examples suggest consistency or irrelevance of column).\n3.  Sort these unique rows in ascending order. Let the sorted unique rows be `R_1, R_2, ..., R_n` and their corresponding colors be `C_1, C_2, ..., C_n`.\n4.  Create an output grid of the same dimensions as the input, initialized to white (0).\n5.  Draw a solid horizontal line of color `C_1` (color associated with the topmost row `R_1`) across the full width of the output grid at row 0 (the very top row).\n6.  Draw a solid horizontal line of color `C_n` (color associated with the bottommost row `R_n`) across the full width of the output grid at the last row (`height - 1`).\n7.  For each unique row `R_i` (from `i=1` to `n`), draw a solid horizontal line of color `C_i` across the full width of the output grid at row `R_i`.\n8.  Draw vertical lines in the leftmost column (column 0) and the rightmost column (last column) to connect the horizontal lines:\n    *   Fill the vertical segment from row 1 up to (but not including) row `R_1` with color `C_1`. This applies only if `R_1 > 1`.\n    *   For each pair of consecutive unique rows `R_i` and `R_{i+1}` (where `i` goes from 1 to `n-1`), fill the vertical segment from row `R_i + 1` up to (but not including) row `R_{i+1}` with color `C_{i+1}` (the color associated with the lower row `R_{i+1}`). This applies only if `R_{i+1} > R_i + 1`.\n    *   Fill the vertical segment from row `R_n + 1` up to (but not including) the last row (`height - 1`) with color `C_n`. This applies only if `height - 1 > R_n + 1`.\n9.  Return the completed output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the zone-filling transformation based on non-white input pixels.\n\n    Args:\n        input_grid (list of lists): The input grid containing pixels 0-9.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np) # Initialize with white (0)\n\n    # 1 & 2. Identify non-white pixels and unique rows with their colors\n    row_colors = {}\n    pixel_locations = []\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != 0:\n                pixel_locations.append((r, c, color))\n                # Store the first color encountered for this row\n                if r not in row_colors:\n                    row_colors[r] = color\n\n    # Handle case with no non-white pixels\n    if not row_colors:\n        return output_grid.tolist()\n\n    # 3. Sort unique rows and get corresponding (row, color) pairs\n    sorted_rows = sorted(row_colors.keys())\n    sorted_pixel_data = [(r, row_colors[r]) for r in sorted_rows]\n\n    # Get colors for top and bottom boundaries/segments\n    first_color = sorted_pixel_data[0][1]\n    last_color = sorted_pixel_data[-1][1]\n\n    # 4. Initialize output grid (already done)\n\n    # 5. Draw top boundary line\n    output_grid[0, :] = first_color\n\n    # 6. Draw bottom boundary line\n    output_grid[height - 1, :] = last_color\n\n    # 7. Draw horizontal lines for each identified pixel's row\n    for r, c in sorted_pixel_data:\n        output_grid[r, :] = c\n\n    # 8. Draw vertical borders\n    # Segment above the first pixel row\n    first_row = sorted_pixel_data[0][0]\n    if first_row > 0: # Ensure there's space between row 0 and first_row\n        # Vertical lines go from row 1 up to (but not including) first_row\n        if 1 < first_row:\n            output_grid[1:first_row, 0] = first_color\n            output_grid[1:first_row, width - 1] = first_color\n\n    # Segments between consecutive pixel rows\n    for i in range(len(sorted_pixel_data) - 1):\n        current_row = sorted_pixel_data[i][0]\n        next_row = sorted_pixel_data[i+1][0]\n        next_color = sorted_pixel_data[i+1][1]\n\n        start_vert_row = current_row + 1\n        end_vert_row = next_row # Slice goes up to, but not including, end_vert_row\n\n        if start_vert_row < end_vert_row: # Only draw if there's space\n            output_grid[start_vert_row:end_vert_row, 0] = next_color\n            output_grid[start_vert_row:end_vert_row, width - 1] = next_color\n\n    # Segment below the last pixel row\n    last_row = sorted_pixel_data[-1][0]\n    start_vert_row_final = last_row + 1\n    end_vert_row_final = height - 1 # Slice goes up to, but not including, end_vert_row_final\n\n    if start_vert_row_final < end_vert_row_final: # Only draw if there's space\n        output_grid[start_vert_row_final:end_vert_row_final, 0] = last_color\n        output_grid[start_vert_row_final:end_vert_row_final, width - 1] = last_color\n\n    # 9. Return the completed grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10463,
    "candidates_token_count": 1594,
    "total_token_count": 12057,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.970334,
  "retries": null
}