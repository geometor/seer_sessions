{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a grid with sparse colored pixels into a grid with colored horizontal zones defined by these pixels.\n\n1.  Identify all non-white pixels in the input grid, recording their color and row index. If no non-white pixels are found, return an all-white grid of the same dimensions.\n2.  Determine the unique rows containing non-white pixels and associate each unique row with the color found in that row (using the first encountered color in that row during scan).\n3.  Sort these unique rows in ascending order. Let the sorted unique rows be R_1, R_2, ..., R_n and their corresponding colors be C_1, C_2, ..., C_n.\n4.  Create an output grid of the same dimensions as the input, initialized to white (0).\n5.  Draw a solid horizontal line of color C_1 across the full width of the output grid at row 0 (the very top row).\n6.  Draw a solid horizontal line of color C_n across the full width of the output grid at the last row (height - 1).\n7.  For each unique row R_i (from i=1 to n), draw a solid horizontal line of color C_i across the full width of the output grid at row R_i.\n8.  Draw vertical lines in the leftmost column (column 0) and the rightmost column (last column) to connect the horizontal lines:\n    *   Fill the vertical segment from row 1 up to (but not including) row R_1 with color C_1.\n    *   For each pair of consecutive unique rows R_i and R_{i+1} (where i goes from 1 to n-1), fill the vertical segment from row R_i + 1 up to (but not including) row R_{i+1} with color C_i (the color associated with the upper row R_i).\n    *   Fill the vertical segment from row R_n + 1 up to (but not including) the last row (height - 1) with color C_n.\n9.  Return the completed output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the zone-filling transformation based on non-white input pixels.\n\n    Args:\n        input_grid (list of lists): The input grid containing pixels 0-9.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np) # Initialize with white (0)\n\n    # 1 & 2. Identify non-white pixels and unique rows with their colors\n    row_colors = {}\n    # Scan top-to-bottom, left-to-right to respect \"first encountered color\" rule\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != 0:\n                # Store the first color encountered for this row\n                if r not in row_colors:\n                    row_colors[r] = color\n\n    # Handle edge case: no non-white pixels\n    if not row_colors:\n        return output_grid.tolist()\n\n    # 3. Sort unique rows and get corresponding (row, color) pairs\n    sorted_rows = sorted(row_colors.keys())\n    sorted_pixel_data = [(r, row_colors[r]) for r in sorted_rows]\n\n    # Get colors for top and bottom boundaries/segments\n    first_color = sorted_pixel_data[0][1]\n    last_color = sorted_pixel_data[-1][1]\n\n    # 4. Initialize output grid (already done)\n\n    # 5. Draw top boundary line (row 0)\n    output_grid[0, :] = first_color\n\n    # 6. Draw bottom boundary line (last row)\n    output_grid[height - 1, :] = last_color\n\n    # 7. Draw horizontal lines for each identified pixel's row\n    for r, c in sorted_pixel_data:\n        output_grid[r, :] = c\n\n    # 8. Draw vertical borders (column 0 and width - 1)\n    # Segment above the first pixel row (R_1)\n    first_row = sorted_pixel_data[0][0]\n    if first_row > 0: # Ensure there's space between row 0 and first_row\n        # Vertical lines go from row 1 up to (but not including) first_row\n        # Color is C_1 (first_color)\n        if 1 < first_row:\n            output_grid[1:first_row, 0] = first_color\n            output_grid[1:first_row, width - 1] = first_color\n\n    # Segments between consecutive pixel rows (R_i and R_{i+1})\n    # Loop from the first pair up to the second-to-last pair\n    for i in range(len(sorted_pixel_data) - 1):\n        current_row, current_color = sorted_pixel_data[i] # R_i, C_i\n        next_row = sorted_pixel_data[i+1][0]             # R_{i+1}\n\n        start_vert_row = current_row + 1\n        end_vert_row = next_row # Slice goes up to, but not including, end_vert_row\n\n        # Only draw if there's space between the rows\n        if start_vert_row < end_vert_row:\n            # Fill segment with C_i (current_color) - THIS IS THE FIX\n            output_grid[start_vert_row:end_vert_row, 0] = current_color\n            output_grid[start_vert_row:end_vert_row, width - 1] = current_color\n\n    # Segment below the last pixel row (R_n)\n    last_row = sorted_pixel_data[-1][0]\n    # Vertical lines go from last_row + 1 up to (but not including) height - 1\n    start_vert_row_final = last_row + 1\n    end_vert_row_final = height - 1 # Slice goes up to, but not including, end_vert_row_final\n\n    # Only draw if there's space between the last row and the bottom boundary\n    if start_vert_row_final < end_vert_row_final:\n        # Color is C_n (last_color)\n        output_grid[start_vert_row_final:end_vert_row_final, 0] = last_color\n        output_grid[start_vert_row_final:end_vert_row_final, width - 1] = last_color\n\n    # 9. Return the completed grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10829,
    "candidates_token_count": 1587,
    "total_token_count": 12416,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.627794,
  "retries": null
}