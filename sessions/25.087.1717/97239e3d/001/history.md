
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 6 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 1 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6
0 8 8 8 6 8 8 8 0 8 8 8 0 8 8 8 6
0 8 0 8 6 8 6 8 0 8 6 8 0 8 6 8 6
0 8 8 8 6 8 8 8 0 8 8 8 0 8 8 8 6
0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 8 8 8 0 8 8 8 1 8 8 8 0 8 8 8 0
1 8 1 8 0 8 1 8 1 8 0 8 0 8 0 8 0
1 8 8 8 0 8 8 8 1 8 8 8 0 8 8 8 0
1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0
2 8 8 8 0 8 8 8 0 8 8 8 2 8 8 8 0
2 8 2 8 0 8 2 8 0 8 2 8 2 8 0 8 0
2 8 8 8 0 8 8 8 0 8 8 8 2 8 8 8 0
2 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
2 8 8 8 0 8 8 8 0 8 8 8 2 8 8 8 0
2 8 2 8 0 8 2 8 0 8 2 8 2 8 0 8 0
2 8 8 8 0 8 8 8 0 8 8 8 2 8 8 8 0
2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 7 7 7 7 7
0 8 8 8 0 8 8 8 0 8 8 8 7 8 8 8 7
0 8 0 8 0 8 0 8 0 8 0 8 7 8 7 8 7
0 8 8 8 0 8 8 8 0 8 8 8 7 8 8 8 7
0 0 0 0 0 0 0 0 0 0 0 0 7 7 7 7 7
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0
3 8 8 8 0 8 8 8 0 8 8 8 3 8 8 8 0
3 8 3 8 0 8 3 8 0 8 3 8 3 8 0 8 0
3 8 8 8 0 8 8 8 0 8 8 8 3 8 8 8 0
3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 8 0 8 0 8 0 8 0 8 0 8 0 8 0 8 0
0 8 8 8 0 8 8 8 0 8 8 8 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down the task based on the provided examples.

## Perception

1.  **Grid Structure:** The input grids have a consistent background structure. They are predominantly filled with `white` (0) and `azure` (8). The `azure` pixels form repeating 3x3 block patterns (like hollow squares or the number 8) separated by single lines of `white` pixels. These white lines create a larger grid-like structure, often with divisions at indices that are multiples of 4 (e.g., rows/cols 4, 8, 12).
2.  **Marker Pixels:** Each input grid contains a small number of 'marker' pixels with colors other than `white` (0) or `azure` (8). These marker pixels appear on the `white` background lines or grid boundaries. Examples use `magenta` (6), `blue` (1), `red` (2), `orange` (7), `green` (3).
3.  **Output Transformation:** The output grid is identical to the input grid, except that certain rectangular areas have their `white` (0) pixels replaced by the color of the marker pixels. The original `azure` (8) pixels and the marker pixels themselves remain unchanged.
4.  **Rectangle Definition:** The key transformation is the definition and coloring of these rectangles.
    *   **Pairs of Markers:** If there are two (or more) marker pixels of the *same color*, they define the bounding box (minimum and maximum row and column) of the rectangle to be filled with that color. (See `train_1` blue, `train_2` red, `train_3` orange, `train_3` green).
    *   **Single Markers:** If there is only *one* marker pixel of a given color, it defines a rectangle differently. In `train_1`, the single `magenta` (6) pixel at `(4, 16)` defines a rectangle spanning rows `[0, 4]` and columns `[4, 16]`. This suggests the single pixel `(r, c)` defines the bottom-right corner `(r, c)`, the top row is 0, and the left column is determined by a structural feature (here, column 4, which is the first major vertical grid line).
5.  **Filling Rule:** Within the boundaries of a defined rectangle, only the pixels that were originally `white` (0) in the input grid are changed to the corresponding marker color in the output grid.

## Facts


```yaml
objects:
  - type: grid
    properties:
      - background_color: white (0)
      - structure_color: azure (8)
      - structure_pattern: repeating 3x3 blocks separated by white lines
      - marker_pixels:
          - color: non-white, non-azure (e.g., blue, red, magenta, green, orange)
          - location: typically on white lines/boundaries
rectangles:
  - definition_rule:
      - type: bounding_box
        condition: defined by two or more marker pixels of the same color
        details: uses min/max row and column of the marker pixels
      - type: single_marker_rule
        condition: defined by exactly one marker pixel of a given color (r, c)
        details: uses pixel (r, c) and grid structure (e.g., row 0 and first major column line <= c) to define corners. Example suggests rows=[0, r], cols=[first_positive_major_col, c] (where major cols are multiples of 4).
  - color: determined by the color of the defining marker pixel(s)
actions:
  - action: find_marker_pixels
    inputs: input_grid
    outputs: list of marker pixels with their colors and locations
  - action: group_markers_by_color
    inputs: list of marker pixels
    outputs: groups of marker pixels, one group per color
  - action: define_rectangles
    inputs: groups of marker pixels
    outputs: list of rectangles, each with associated color and row/column bounds
    rule: Apply bounding_box rule for groups >= 2 pixels, single_marker_rule for groups == 1 pixel.
  - action: fill_rectangles
    inputs: input_grid, list of rectangles
    outputs: output_grid
    rule: For each rectangle, iterate through its cells. If an input cell within the rectangle is white (0), change the corresponding output cell to the rectangle's color. Otherwise, keep the input cell's color.
relationships:
  - marker pixel color determines the fill color of the corresponding rectangle.
  - marker pixel location(s) determine the bounds of the corresponding rectangle.
  - only white pixels within the defined rectangles are affected by the transformation.
```


## Natural Language Program

1.  **Initialize:** Create a copy of the input grid to serve as the output grid.
2.  **Identify Markers:** Scan the input grid and identify all pixels whose color is *not* `white` (0) and *not* `azure` (8). Record the color and `(row, column)` coordinates of each identified marker pixel.
3.  **Group Markers:** Group the identified marker pixels based on their color.
4.  **Define and Fill Rectangles (for each color group):**
    a.  Select a color group (all marker pixels of a specific color `C`).
    b.  **Determine Rectangle Bounds:**
        i.  **If the group contains exactly one marker pixel at `(r, c)`:** Define the rectangle's row range as `[0, r]`. Determine the smallest positive major column index `first_pos_major_c` (which is 4 in the examples, assuming major columns are multiples of 4). Define the rectangle's column range as `[min(first_pos_major_c, c), max(first_pos_major_c, c)]`.
        ii. **If the group contains two or more marker pixels:** Find the minimum row (`min_r`), maximum row (`max_r`), minimum column (`min_c`), and maximum column (`max_c`) among all marker pixels in this group. Define the rectangle's row range as `[min_r, max_r]` and column range as `[min_c, max_c]`.
    c.  **Fill the Rectangle:** Iterate through every cell `(i, j)` within the determined row and column ranges. If the color of the cell `(i, j)` in the *original input grid* is `white` (0), update the color of the cell `(i, j)` in the *output grid* to the marker color `C`.
5.  **Finalize:** After processing all color groups, return the modified output grid.
