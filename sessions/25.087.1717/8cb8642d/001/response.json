{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous shapes of a single non-white color in the input grid. \nFor each shape, it checks if it contains exactly one 'marker' pixel of a different color.\nIf a marker is found, a diamond-shaped boundary pattern is drawn expanding outwards from the marker's location using the marker's color. \nThe pattern only colors pixels that originally belonged to the shape (had the shape's primary color). \nThe expansion stops when the pattern reaches pixels that were not part of the original shape.\nAll pixels that originally belonged to the shape but were not colored by the diamond pattern (including the original marker pixel) are then set to white (0).\nShapes without a marker remain unchanged.\n\"\"\"\n\ndef find_shapes_and_markers(grid):\n    \"\"\"\n    Finds contiguous shapes of non-white colors and identifies any single marker pixel within them.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a shape and contains:\n              'coords': set of (row, col) tuples for the shape.\n              'color': the primary color of the shape.\n              'marker_coord': (row, col) of the marker, or None.\n              'marker_color': color of the marker, or None.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Found the start of a potential shape\n                q = deque([(r, c)])\n                visited[r, c] = True\n                shape_coords = set([(r, c)])\n                potential_primary_color = grid[r,c]\n                possible_markers = [] # Store potential markers (different color)\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check neighbors (4-directional connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and not visited[nr, nc] and grid[nr, nc] != 0:\n                             # If neighbor color matches potential primary, add to shape\n                            if grid[nr, nc] == potential_primary_color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                shape_coords.add((nr, nc))\n                            # If neighbor color is different, it's a potential marker\n                            else:\n                                # Only add if not already visited as part of *this* shape search\n                                # This handles cases where a marker touches the main color block\n                                if (nr, nc) not in shape_coords:\n                                    possible_markers.append(((nr,nc), grid[nr,nc]))\n                                    # Mark as visited to avoid starting a new shape from the marker\n                                    visited[nr, nc] = True \n                                    shape_coords.add((nr, nc)) # Add marker coord to shape area initially\n\n                # Analyze potential markers found for this connected component\n                actual_marker_coord = None\n                actual_marker_color = None\n                primary_color = potential_primary_color # Assume initially\n                final_shape_coords = set() # Recalculate coords excluding marker if necessary\n\n                markers_found = []\n                non_primary_coords = set()\n\n                # First pass: Identify the dominant color and potential markers within the found coords\n                color_counts = {}\n                for sr, sc in shape_coords:\n                   color = grid[sr, sc]\n                   color_counts[color] = color_counts.get(color, 0) + 1\n                \n                if not color_counts: continue # Skip if shape is empty (shouldn't happen with logic)\n\n                # Determine primary color (most frequent)\n                primary_color = max(color_counts, key=color_counts.get)\n                \n                # Second pass: Separate primary coords and marker coords\n                for sr, sc in shape_coords:\n                    color = grid[sr, sc]\n                    if color == primary_color:\n                        final_shape_coords.add((sr, sc))\n                    else:\n                        markers_found.append(((sr, sc), color))\n                        non_primary_coords.add((sr,sc))\n\n                # Check if exactly one marker pixel exists\n                if len(markers_found) == 1:\n                    actual_marker_coord, actual_marker_color = markers_found[0]\n                    # Ensure the marker coord is NOT included in the coords to be cleared/patterned initially\n                    # The final clearing step will handle the marker coord location.\n                    # The 'final_shape_coords' should only contain pixels of the primary color.\n\n                # Store the shape details\n                shapes.append({\n                    'coords': final_shape_coords, # Only coords with primary color\n                    'color': primary_color,\n                    'marker_coord': actual_marker_coord,\n                    'marker_color': actual_marker_color,\n                    'all_coords_incl_marker' : shape_coords # Keep track of full extent for bounds checks if needed\n                })\n\n\n    return shapes\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the diamond pattern rule for shapes with markers.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Find all shapes and their potential markers\n    shapes = find_shapes_and_markers(input_np)\n\n    # Process each shape\n    for shape in shapes:\n        if shape['marker_coord'] is not None:\n            # This shape has a single marker, apply the transformation\n            marker_r, marker_c = shape['marker_coord']\n            marker_color = shape['marker_color']\n            primary_color = shape['color']\n            shape_primary_coords = shape['coords'] # Coords with the primary color\n\n            pixels_colored_by_pattern = set()\n            \n            # Expand diamond pattern layer by layer (Manhattan distance)\n            d = 1\n            while True:\n                colored_in_this_layer = False\n                coords_at_distance_d = []\n\n                # Generate coordinates at distance d\n                for i in range(d + 1):\n                    j = d - i\n                    # Check all four quadrants relative to the marker\n                    coords_at_distance_d.append((marker_r + i, marker_c + j))\n                    if i != 0: coords_at_distance_d.append((marker_r - i, marker_c + j))\n                    if j != 0: coords_at_distance_d.append((marker_r + i, marker_c - j))\n                    if i != 0 and j != 0: coords_at_distance_d.append((marker_r - i, marker_c - j))\n                \n                # Filter and color valid coordinates\n                for r, c in coords_at_distance_d:\n                    # Check grid bounds\n                    if 0 <= r < height and 0 <= c < width:\n                         # Check if the target pixel originally belonged to the shape's primary color area\n                         if (r,c) in shape_primary_coords:\n                             output_np[r, c] = marker_color\n                             pixels_colored_by_pattern.add((r, c))\n                             colored_in_this_layer = True\n                \n                # Stop if no pixels were colored in this layer (pattern hit boundary or filled area)\n                if not colored_in_this_layer:\n                    break\n                \n                d += 1 # Move to the next distance layer\n\n            # Clear the remaining interior pixels (including marker position) to white (0)\n            # Iterate through all coordinates that originally had the primary color\n            for r, c in shape_primary_coords:\n                # If a pixel was not colored by the diamond pattern, set it to white\n                if (r, c) not in pixels_colored_by_pattern:\n                    output_np[r, c] = 0\n            \n            # Also explicitly clear the original marker position to white\n            if shape['marker_coord'] is not None:\n                 mr, mc = shape['marker_coord']\n                 # Check if marker coord is within bounds (should always be)\n                 if 0 <= mr < height and 0 <= mc < width:\n                    # Ensure it wasn't somehow colored by the pattern (shouldn't happen as d starts at 1)\n                    if (mr, mc) not in pixels_colored_by_pattern:\n                         output_np[mr, mc] = 0\n\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5226,
    "candidates_token_count": 2092,
    "total_token_count": 7318,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.394971,
  "retries": null
}