{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies contiguous shapes made of a primary non-white color (most frequent) \nthat contain exactly one 'marker' pixel of a different non-white color.\nFor each such shape:\n1. The border pixels of the primary color remain unchanged.\n2. A hollow diamond pattern, using the marker's color, expands outwards from \n   the marker's location based on Manhattan distance.\n3. This pattern only colors pixels that were originally part of the shape's \n   primary color area and are not on the border (interior primary pixels).\n4. The expansion stops when the next diamond layer (at distance d) no longer \n   overlaps with any interior primary pixels.\n5. All original interior primary pixels that are not colored by the final \n   hollow diamond pattern are set to white (0).\n6. The original marker pixel location is also set to white (0).\nShapes without exactly one marker pixel, or components made entirely of one \nnon-white color, remain unchanged.\nPixels outside of any processed shape remain unchanged.\n\"\"\"\n\ndef find_shapes_and_markers(grid):\n    \"\"\"\n    Finds connected non-white components, identifies primary color, \n    and checks for a single marker pixel. Uses 4-directional connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries for shapes meeting the criteria, containing:\n              'primary_pixels': set of (row, col) tuples for the primary color pixels.\n              'primary_color': the primary color of the shape.\n              'marker_coord': (row, col) of the single marker, or None.\n              'marker_color': color of the single marker, or None.\n              'all_pixels': set of (row, col) tuples for all pixels in the component.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS for a new connected component (non-white pixels)\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_pixels = {} # Store {coord: color}\n                component_pixels[(r, c)] = grid[r, c]\n                component_coords = set([(r, c)])\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check neighbors (4-directional connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] != 0:\n                            \n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_pixels[(nr, nc)] = grid[nr, nc]\n                            component_coords.add((nr, nc))\n\n                # Analyze the found component\n                if not component_pixels:\n                    continue\n\n                color_counts = Counter(component_pixels.values())\n                \n                # Components must have at least two different colors to potentially have a marker\n                if len(color_counts) < 2:\n                    continue\n\n                # Determine primary color (most frequent non-white color)\n                primary_color = max(color_counts, key=color_counts.get)\n                \n                # Identify primary pixels and potential markers\n                primary_pixels_set = set()\n                marker_pixels = [] # List of (coord, color)\n                for coord, color in component_pixels.items():\n                    if color == primary_color:\n                        primary_pixels_set.add(coord)\n                    else: # Any other non-white color is a potential marker\n                        marker_pixels.append((coord, color))\n\n                # Check if exactly one marker pixel exists\n                if len(marker_pixels) == 1:\n                    actual_marker_coord, actual_marker_color = marker_pixels[0]\n                    \n                    # Store the shape details if it meets the criteria\n                    shapes.append({\n                        'primary_pixels': primary_pixels_set,\n                        'primary_color': primary_color,\n                        'marker_coord': actual_marker_coord,\n                        'marker_color': actual_marker_color,\n                        'all_pixels': component_coords # All coords in this connected component\n                    })\n\n    return shapes\n\ndef find_border_pixels(primary_pixels, all_shape_pixels, grid_shape):\n    \"\"\"\n    Identifies the border pixels within a set of primary color pixels relative\n    to the entire connected component. A primary pixel is border if it's \n    adjacent to a pixel outside the component or outside the grid.\n\n    Args:\n        primary_pixels (set): Coordinates of pixels with the primary color.\n        all_shape_pixels (set): Coordinates of all pixels in the shape component.\n        grid_shape (tuple): (height, width) of the grid.\n\n    Returns:\n        set: Coordinates of the border pixels among the primary_pixels.\n    \"\"\"\n    height, width = grid_shape\n    border_coords = set()\n    for r, c in primary_pixels:\n        is_border = False\n        # Check 4 neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # A pixel is on the border if a neighbor is:\n            # 1. Outside the grid boundaries.\n            # 2. Not part of the current shape's connected component. (Includes white pixels)\n            if not (0 <= nr < height and 0 <= nc < width) or \\\n               ((nr, nc) not in all_shape_pixels):\n                 is_border = True\n                 break\n        if is_border:\n            border_coords.add((r, c))\n    return border_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the hollow diamond transformation to qualifying shapes in the grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np) # Initialize output grid as a copy of input\n    height, width = input_np.shape\n\n    # 1. Identify Shapes and Markers\n    shapes = find_shapes_and_markers(input_np)\n\n    # 2. Process each qualifying shape\n    for shape in shapes:\n        primary_pixels = shape['primary_pixels']\n        primary_color = shape['primary_color'] \n        marker_coord = shape['marker_coord']\n        marker_color = shape['marker_color']\n        all_pixels_in_component = shape['all_pixels']\n        \n        # 3a. Identify Border Pixels (these will remain primary_color)\n        border_pixels = find_border_pixels(primary_pixels, all_pixels_in_component, (height, width))\n\n        # 3b. Identify Interior Primary Pixels (candidates for pattern or clearing)\n        interior_primary_pixels = primary_pixels - border_pixels\n\n        # 3c. Generate Hollow Diamond Pattern\n        marker_r, marker_c = marker_coord\n        pixels_colored_by_pattern = set()\n        \n        d = 1 # Start with Manhattan distance 1\n        while True:\n            coords_at_distance_d = []\n            # Generate coordinates exactly at distance d\n            for i in range(d + 1):\n                j = d - i\n                # Add points in all four quadrants relative to the marker\n                coords_at_distance_d.append((marker_r + i, marker_c + j))\n                if i != 0: coords_at_distance_d.append((marker_r - i, marker_c + j))\n                if j != 0: coords_at_distance_d.append((marker_r + i, marker_c - j))\n                if i != 0 and j != 0: coords_at_distance_d.append((marker_r - i, marker_c - j))\n\n            # Filter points: keep only those within grid bounds AND within the interior primary pixels\n            target_pixels_this_layer = set()\n            for r, c in coords_at_distance_d:\n                 if 0 <= r < height and 0 <= c < width: # Check grid bounds explicitly\n                     if (r, c) in interior_primary_pixels:\n                         target_pixels_this_layer.add((r, c))\n\n            # Stop expansion if this layer doesn't color any valid interior pixels\n            if not target_pixels_this_layer:\n                break \n            \n            # Add the valid pixels of this layer to the final pattern set\n            pixels_colored_by_pattern.update(target_pixels_this_layer)\n            \n            d += 1 # Move to the next distance layer\n\n        # 4. Update the Output Grid for this shape\n        \n        # 4a. Color the pixels identified for the diamond pattern\n        for r, c in pixels_colored_by_pattern:\n            # Check bounds again just for safety, though filtering should handle it\n            if 0 <= r < height and 0 <= c < width:\n                 output_np[r, c] = marker_color\n        \n        # 4b. Clear remaining interior pixels (not border, not pattern) to white\n        pixels_to_clear = interior_primary_pixels - pixels_colored_by_pattern\n        for r, c in pixels_to_clear:\n             if 0 <= r < height and 0 <= c < width:\n                 output_np[r, c] = 0\n        \n        # 4c. Clear the original marker position to white\n        mr, mc = marker_coord\n        if 0 <= mr < height and 0 <= mc < width:\n             # Ensure marker wasn't part of the border (unlikely but possible in weird shapes)\n             # And ensure it wasn't part of the primary pixels (it shouldn't be by definition)\n             # It should always be cleared.\n             output_np[mr, mc] = 0\n             \n        # Note: Border pixels retain their primary color because they were in the initial\n        # output_np copy and were not included in interior_primary_pixels, \n        # pixels_colored_by_pattern, or pixels_to_clear.\n\n    # 5. Return the final grid\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15423,
    "candidates_token_count": 2463,
    "total_token_count": 17886,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.261832,
  "retries": null
}