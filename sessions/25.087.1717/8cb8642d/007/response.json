{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies contiguous shapes (4-connected non-white pixels) with a primary \n(most frequent non-white) color and exactly one 'marker' pixel of a different \nnon-white color. For each such shape, the transformation proceeds as follows:\n1. Border pixels of the primary color (those adjacent to pixels outside the \n   shape or the grid edge) remain unchanged.\n2. A hollow diamond pattern, using the marker's color, expands outwards from \n   the marker's location based on increasing Manhattan distance (d=1, 2, 3...).\n3. At each distance 'd', only the pixels exactly at that distance are considered \n   for the pattern ('hollow' diamond shell).\n4. This pattern only colors pixels that were originally part of the shape's \n   primary color area and are *not* on the border (i.e., interior primary pixels).\n5. The expansion stops when the diamond shell at distance 'd' no longer \n   overlaps with any interior primary pixels.\n6. All original interior primary pixels that were *not* colored by the final \n   hollow diamond pattern are set to white (0).\n7. The original marker pixel location is also set to white (0).\nShapes without exactly one marker pixel, components made entirely of one \nnon-white color, or pixels outside of any processed shape remain unchanged.\n\"\"\"\n\ndef find_shapes_and_markers(grid):\n    \"\"\"\n    Finds connected non-white components, identifies primary color, \n    and checks for a single marker pixel. Uses 4-directional connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries for shapes meeting the criteria, containing:\n              'primary_pixels': set of (row, col) tuples for the primary color pixels.\n              'primary_color': the primary color of the shape.\n              'marker_coord': (row, col) of the single marker, or None.\n              'marker_color': color of the single marker, or None.\n              'all_pixels': set of (row, col) tuples for all pixels in the component.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS for a new connected component (non-white pixels)\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_pixels = {} # Store {coord: color}\n                component_pixels[(r, c)] = grid[r, c]\n                component_coords = set([(r, c)])\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check neighbors (4-directional connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] != 0:\n                            \n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_pixels[(nr, nc)] = grid[nr, nc]\n                            component_coords.add((nr, nc))\n\n                # Analyze the found component\n                if not component_pixels:\n                    continue\n\n                color_counts = Counter(component_pixels.values())\n                \n                # Components must have at least two different colors to potentially have a marker\n                if len(color_counts) < 2:\n                    continue\n\n                # Determine primary color (most frequent non-white color)\n                primary_color = max(color_counts, key=color_counts.get)\n                \n                # Identify primary pixels and potential markers\n                primary_pixels_set = set()\n                marker_pixels = [] # List of (coord, color)\n                for coord, color in component_pixels.items():\n                    if color == primary_color:\n                        primary_pixels_set.add(coord)\n                    else: # Any other non-white color is a potential marker\n                        marker_pixels.append((coord, color))\n\n                # Check if exactly one marker pixel exists\n                if len(marker_pixels) == 1:\n                    actual_marker_coord, actual_marker_color = marker_pixels[0]\n                    \n                    # Store the shape details if it meets the criteria\n                    shapes.append({\n                        'primary_pixels': primary_pixels_set,\n                        'primary_color': primary_color,\n                        'marker_coord': actual_marker_coord,\n                        'marker_color': actual_marker_color,\n                        'all_pixels': component_coords # All coords in this connected component\n                    })\n\n    return shapes\n\ndef find_border_pixels(primary_pixels, all_shape_pixels, grid_shape):\n    \"\"\"\n    Identifies the border pixels within a set of primary color pixels relative\n    to the entire connected component. A primary pixel is border if it's \n    adjacent (4-dir) to a pixel outside the component or outside the grid.\n\n    Args:\n        primary_pixels (set): Coordinates of pixels with the primary color.\n        all_shape_pixels (set): Coordinates of all pixels in the shape component.\n        grid_shape (tuple): (height, width) of the grid.\n\n    Returns:\n        set: Coordinates of the border pixels among the primary_pixels.\n    \"\"\"\n    height, width = grid_shape\n    border_coords = set()\n    for r, c in primary_pixels:\n        is_border = False\n        # Check 4 neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # A pixel is on the border if a neighbor is:\n            # 1. Outside the grid boundaries.\n            # 2. Not part of the current shape's connected component (includes white pixels).\n            if not (0 <= nr < height and 0 <= nc < width) or \\\n               ((nr, nc) not in all_shape_pixels):\n                 is_border = True\n                 break\n        if is_border:\n            border_coords.add((r, c))\n    return border_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the hollow diamond transformation to qualifying shapes in the grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of input - preserves background and borders initially\n    output_np = np.copy(input_np) \n    height, width = input_np.shape\n\n    # 1. Identify Shapes and Markers meeting the criteria\n    shapes = find_shapes_and_markers(input_np)\n\n    # 2. Process each qualifying shape\n    for shape in shapes:\n        primary_pixels = shape['primary_pixels']\n        # primary_color = shape['primary_color'] # Not strictly needed for modification logic\n        marker_coord = shape['marker_coord']\n        marker_color = shape['marker_color']\n        all_pixels_in_component = shape['all_pixels']\n        \n        # 3a. Identify Border Pixels (these will remain their primary_color in output_np)\n        border_pixels = find_border_pixels(primary_pixels, all_pixels_in_component, (height, width))\n\n        # 3b. Identify Interior Primary Pixels (candidates for pattern or clearing)\n        interior_primary_pixels = primary_pixels - border_pixels\n\n        # 3c. Generate Hollow Diamond Pattern by collecting valid pixels at each distance d\n        marker_r, marker_c = marker_coord\n        pattern_pixels_to_color = set() # Stores interior pixels to be colored by the pattern\n        \n        d = 1 # Start with Manhattan distance 1\n        while True:\n            coords_at_distance_d = []\n            # Generate coordinates exactly at distance d (diamond shell)\n            for i in range(d + 1):\n                j = d - i\n                # Add points in all four quadrants relative to the marker\n                coords_at_distance_d.append((marker_r + i, marker_c + j))\n                if i != 0: coords_at_distance_d.append((marker_r - i, marker_c + j))\n                if j != 0: coords_at_distance_d.append((marker_r + i, marker_c - j))\n                if i != 0 and j != 0: coords_at_distance_d.append((marker_r - i, marker_c - j))\n\n            # Filter points: keep only those within grid bounds AND within the interior primary pixels\n            target_pixels_this_layer = set()\n            for r, c in coords_at_distance_d:\n                 if 0 <= r < height and 0 <= c < width: # Check grid bounds explicitly\n                     if (r, c) in interior_primary_pixels:\n                         target_pixels_this_layer.add((r, c))\n\n            # Stop expansion if this layer doesn't color any valid interior pixels\n            if not target_pixels_this_layer:\n                break \n            \n            # Add the valid pixels of this layer to the final pattern set\n            pattern_pixels_to_color.update(target_pixels_this_layer)\n            \n            d += 1 # Move to the next distance layer\n\n        # 4. Update the Output Grid for this shape based on the pattern\n        \n        # 4a. Color the collected pattern pixels with the marker color\n        for r, c in pattern_pixels_to_color:\n            # Bounds check technically redundant due to filtering, but safe\n            if 0 <= r < height and 0 <= c < width: \n                 output_np[r, c] = marker_color\n        \n        # 4b. Identify and clear interior pixels that were NOT colored by the pattern\n        pixels_to_clear = interior_primary_pixels - pattern_pixels_to_color\n        for r, c in pixels_to_clear:\n             if 0 <= r < height and 0 <= c < width:\n                 output_np[r, c] = 0 # Set to white\n        \n        # 4c. Clear the original marker position to white\n        mr, mc = marker_coord\n        if 0 <= mr < height and 0 <= mc < width:\n             output_np[mr, mc] = 0 # Set to white\n             \n        # Note: Border pixels retain their primary color because they were in the initial\n        # output_np copy and were not part of interior_primary_pixels, thus not \n        # included in pattern_pixels_to_color or pixels_to_clear.\n        # Pixels outside processed shapes also remain unchanged.\n\n    # 5. Return the final grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16397,
    "candidates_token_count": 2565,
    "total_token_count": 18962,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.436131,
  "retries": null
}