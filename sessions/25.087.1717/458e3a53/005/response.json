{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\n1. **Analyze Input Grid Lines:** Scan the input grid to identify the color that forms the most prominent horizontal and vertical line segments (e.g., segments of length 3 or more). Designate this color as the `frame_color`.\n2. **Find Framed Rectangles:** Search the input grid for all occurrences of solid rectangular blocks (`inner_blocks`) where each block consists of a single color (`inner_color`) different from the `frame_color`, and is perfectly enclosed by a 1-pixel thick border composed solely of the `frame_color`.\n3. **Record Rectangle Properties:** For each valid `framed_rectangle` found, store its `inner_color` and the grid coordinates (row, column) of the top-left pixel of its `inner_block`.\n4. **Determine Output Dimensions and Mapping:**\n   - Collect all unique row coordinates from the recorded top-left positions. Sort these unique rows. The number of unique rows is the `output_height`. Create a mapping from each unique row coordinate to its index (0, 1, ...) in the sorted list.\n   - Collect all unique column coordinates from the recorded top-left positions. Sort these unique columns. The number of unique columns is the `output_width`. Create a mapping from each unique column coordinate to its index (0, 1, ...) in the sorted list.\n5. **Construct Output Grid:** Create a new grid with dimensions `output_height` x `output_width`, initializing all cells to white (0).\n6. **Populate Output Grid:** Iterate through the recorded rectangles. For each rectangle, use its stored `inner_color` and its top-left `inner_block` coordinates. Find the corresponding output row index using the row mapping and the output column index using the column mapping. Place the `inner_color` at this (output row, output column) position in the output grid.\n7. **Return Output:** Return the fully populated output grid.\n\"\"\"\n\ndef find_frame_color(grid):\n    \"\"\"\n    Identifies the potential frame color by finding the color that forms\n    the most horizontal and vertical line segments of length 3 or more.\n    \"\"\"\n    rows, cols = grid.shape\n    line_colors = Counter()\n    min_line_length = 3\n\n    # Horizontal lines\n    for r in range(rows):\n        c = 0\n        while c < cols:\n            color = grid[r, c]\n            length = 0\n            while c + length < cols and grid[r, c + length] == color:\n                length += 1\n            # Check length *after* finding the end of the segment\n            if length >= min_line_length:\n                line_colors[color] += 1\n                # Move counter past this counted segment\n                c += length\n            else:\n                # Move counter by 1 if segment wasn't long enough\n                c += 1 # Correctly advance even if line isn't long enough\n\n    # Vertical lines\n    for c in range(cols):\n         r = 0\n         while r < rows:\n            color = grid[r, c]\n            length = 0\n            while r + length < rows and grid[r + length, c] == color:\n                length += 1\n            # Check length *after* finding the end of the segment\n            if length >= min_line_length:\n                line_colors[color] += 1\n                # Move counter past this counted segment\n                r += length\n            else:\n                 # Move counter by 1 if segment wasn't long enough\n                r += 1 # Correctly advance even if line isn't long enough\n\n    # Return the most common color, or a default (e.g., -1) if none found\n    if not line_colors:\n        # Fallback: If no lines >= 3, maybe check most frequent color overall?\n        # Or maybe the task guarantees such lines exist if framing exists.\n        # Let's return -1 to indicate failure to find a line-based frame color.\n         all_colors = Counter(grid.flatten())\n         if all_colors:\n             # Heuristic: perhaps the most frequent non-background (non-0) color?\n             # Or maybe just the overall most frequent? Let's try most frequent.\n             most_common = all_colors.most_common(1)\n             if most_common:\n                 return most_common[0][0] # Return most frequent color as fallback\n         return -1 # Indicate no clear frame color found\n    \n    # Find the color with the maximum count\n    frame_color = line_colors.most_common(1)[0][0]\n    return frame_color\n\n\ndef find_framed_rectangles_with_color(grid, frame_color):\n    \"\"\"\n    Finds all rectangles framed by a specific frame_color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        frame_color (int): The color of the frame.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (inner_color, top_row, left_col)\n              representing the inner color and the top-left coordinates\n              of the inner rectangle. Returns an empty list if none found.\n    \"\"\"\n    rectangles = []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Iterate through potential top-left corners of the *inner* rectangle\n    # The inner rectangle must start at least at (1, 1)\n    for r in range(1, rows - 1):\n        for c in range(1, cols - 1):\n            # Skip if visited or if this pixel is the frame color itself\n            if visited[r, c] or grid[r, c] == frame_color:\n                continue\n\n            inner_color = grid[r, c]\n            \n            # Check if the pixel is potentially framed (immediate neighbors are frame_color)\n            # Top, Left, Top-Left must be frame_color\n            if not (grid[r - 1, c] == frame_color and\n                    grid[r, c - 1] == frame_color and\n                    grid[r - 1, c - 1] == frame_color):\n                continue\n\n            # Try to determine the dimensions of the inner rectangle\n            height = 0\n            width = 0\n\n            # Determine height (check downwards)\n            for h_offset in range(rows - r):\n                if grid[r + h_offset, c] == inner_color:\n                    height += 1\n                else:\n                    break\n\n            # Determine width (check rightwards)\n            for w_offset in range(cols - c):\n                if grid[r, c + w_offset] == inner_color:\n                    width += 1\n                else:\n                    break\n\n            if height == 0 or width == 0:\n                continue # Should not happen if we start on an inner_color pixel\n\n            # Define inner block boundaries\n            inner_r_start, inner_c_start = r, c\n            inner_r_end, inner_c_end = r + height - 1, c + width - 1\n            \n            # --- Verification Step ---\n            is_valid = True\n\n            # 1. Verify the inner area is solid inner_color\n            if not np.all(grid[inner_r_start : inner_r_end + 1, inner_c_start : inner_c_end + 1] == inner_color):\n                is_valid = False\n                continue # Not a solid inner block\n\n            # 2. Verify the surrounding frame (1-pixel thick) is solid frame_color\n            try:\n                # Check Top frame row (r-1, c-1 to c+width)\n                if not np.all(grid[inner_r_start - 1, inner_c_start - 1 : inner_c_end + 2] == frame_color):\n                    is_valid = False\n                # Check Bottom frame row (r+height, c-1 to c+width)\n                elif not np.all(grid[inner_r_end + 1, inner_c_start - 1 : inner_c_end + 2] == frame_color):\n                    is_valid = False\n                # Check Left frame column (r to r+height-1, c-1)\n                elif not np.all(grid[inner_r_start : inner_r_end + 1, inner_c_start - 1] == frame_color):\n                    is_valid = False\n                # Check Right frame column (r to r+height-1, c+width)\n                elif not np.all(grid[inner_r_start : inner_r_end + 1, inner_c_end + 1] == frame_color):\n                    is_valid = False\n            except IndexError:\n                # If any check goes out of bounds, it's not properly framed within the grid\n                is_valid = False\n\n            # If all checks passed, it's a valid framed rectangle\n            if is_valid:\n                # Add to list\n                rectangles.append((inner_color, inner_r_start, inner_c_start))\n                # Mark the entire area (inner block + frame) as visited\n                # Frame rows: r-1 to r+height\n                # Frame cols: c-1 to c+width\n                visited[inner_r_start - 1 : inner_r_end + 2, inner_c_start - 1 : inner_c_end + 2] = True\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding framed rectangles, extracting their\n    inner colors, and arranging them spatially in an output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    \n    # Handle trivial case: 1x1 input\n    if rows <= 2 or cols <= 2:\n        return [[0]] # Cannot contain a framed rectangle\n\n    # Step 1: Identify the frame color\n    frame_color = find_frame_color(grid_np)\n    \n    # If no plausible frame color identified, return default\n    if frame_color == -1:\n         print(\"Warning: Could not reliably determine frame color.\")\n         # Maybe return the input or a small default grid? Let's try default.\n         return [[0]] \n\n    # Step 2 & 3: Find all framed rectangles using the identified frame color\n    # and record their inner color and top-left inner coordinate.\n    found_rectangles = find_framed_rectangles_with_color(grid_np, frame_color)\n\n    # Handle case where no rectangles are found\n    if not found_rectangles:\n        return [[0]] # Return default if no framed rectangles matching the criteria exist\n\n    # Step 4: Determine output dimensions and coordinate mapping\n    # Collect unique row and column coordinates of the *inner* top-left corners\n    rows_coords = sorted(list(set(r for _, r, _ in found_rectangles)))\n    cols_coords = sorted(list(set(c for _, _, c in found_rectangles)))\n\n    # Calculate output grid dimensions\n    output_rows = len(rows_coords)\n    output_cols = len(cols_coords)\n\n    # Create mappings from actual grid coordinates to output grid indices\n    row_map = {r: i for i, r in enumerate(rows_coords)}\n    col_map = {c: i for i, c in enumerate(cols_coords)}\n\n    # Step 5: Create the output grid, initialized with white (0)\n    output_grid = np.zeros((output_rows, output_cols), dtype=int)\n\n    # Step 6: Populate the output grid\n    for inner_color, r, c in found_rectangles:\n        # Find the corresponding output grid indices using the maps\n        output_r = row_map[r]\n        output_c = col_map[c]\n        # Place the inner color at the calculated position\n        output_grid[output_r, output_c] = inner_color\n\n    # Step 7: Return the populated output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15892,
    "candidates_token_count": 2814,
    "total_token_count": 18706,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.932276,
  "retries": null
}