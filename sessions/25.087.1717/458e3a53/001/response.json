{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentify all distinct rectangular regions within the input grid where a solid block \nof one color (inner color) is completely enclosed by a one-pixel-thick frame of \na different, uniform color (frame color). Determine the relative grid layout \n(rows and columns) formed by these framed rectangles based on their top-left \ncorner positions. Create an output grid with dimensions matching this layout. \nPopulate the output grid cells with the inner colors of the identified rectangles, \nmaintaining their relative spatial arrangement.\n\"\"\"\n\ndef find_framed_rectangles(grid):\n    \"\"\"\n    Finds all framed rectangles in the grid.\n\n    A framed rectangle is defined as a solid rectangular block of an inner color\n    completely surrounded by a 1-pixel thick frame of a different, uniform frame color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (inner_color, top_row, left_col)\n              representing the inner color and the top-left coordinates \n              of the inner rectangle. Returns an empty list if no such\n              rectangles are found.\n    \"\"\"\n    rectangles = []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows - 2):\n        for c in range(cols - 2):\n            if visited[r, c]:\n                continue\n\n            frame_color = grid[r, c]\n            potential_inner_color = grid[r+1, c+1]\n\n            # Basic check: frame and inner must be different, and potential frame corners must match\n            if frame_color == potential_inner_color:\n                continue\n            if grid[r+1, c] != frame_color or grid[r, c+1] != frame_color:\n                 continue\n\n\n            # Find the potential extent of the inner rectangle\n            inner_r, inner_c = r + 1, c + 1\n            height = 0\n            width = 0\n\n            # Find height\n            for h in range(inner_r, rows -1):\n                 # Check left frame pixel and first inner pixel\n                if grid[h, inner_c -1] == frame_color and grid[h, inner_c] == potential_inner_color:\n                    height += 1\n                else:\n                    break # Stop if left frame or inner color breaks pattern\n\n            # Find width\n            for w in range(inner_c, cols -1):\n                 # Check top frame pixel and first inner pixel\n                if grid[inner_r -1, w] == frame_color and grid[inner_r, w] == potential_inner_color:\n                    width += 1\n                else:\n                    break # Stop if top frame or inner color breaks pattern\n            \n            if height == 0 or width == 0:\n                continue # Not a valid rectangle start\n\n\n            bottom_r = inner_r + height - 1\n            right_c = inner_c + width - 1\n            \n            # --- Verification ---\n            \n            # 1. Check if the inner area is solid potential_inner_color\n            inner_area = grid[inner_r : bottom_r + 1, inner_c : right_c + 1]\n            if not np.all(inner_area == potential_inner_color):\n                continue\n\n            # 2. Check the surrounding frame\n            is_framed = True\n            # Top row frame check\n            if not np.all(grid[inner_r - 1, inner_c -1 : right_c + 2] == frame_color):\n                 is_framed = False\n            # Bottom row frame check\n            if not np.all(grid[bottom_r + 1, inner_c -1 : right_c + 2] == frame_color):\n                 is_framed = False\n            # Left column frame check\n            if not np.all(grid[inner_r : bottom_r + 1, inner_c - 1] == frame_color):\n                is_framed = False\n            # Right column frame check\n            if not np.all(grid[inner_r : bottom_r + 1, right_c + 1] == frame_color):\n                 is_framed = False\n                 \n            if is_framed:\n                rectangles.append((potential_inner_color, inner_r, inner_c))\n                # Mark the entire framed rectangle area (including frame) as visited\n                visited[inner_r - 1 : bottom_r + 2, inner_c - 1 : right_c + 2] = True\n                \n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies framed rectangles in the input grid, determines their relative\n    layout, and creates an output grid containing their inner colors arranged\n    according to that layout.\n    \"\"\"\n    \n    # 1. Find all framed rectangles and their inner colors/positions\n    #    Each element is (inner_color, top_row, left_col)\n    found_rectangles = find_framed_rectangles(np.array(input_grid))\n\n    if not found_rectangles:\n        # Handle cases where no rectangles are found if necessary\n        # Depending on task specifics, might return empty grid, error, etc.\n        # For now, assume at least one rectangle will be found based on examples.\n        # Let's return a 1x1 grid with 0 if none are found to avoid errors.\n         return np.array([[0]], dtype=int)\n\n\n    # 2. Determine the grid layout based on unique row and column coordinates\n    rows_coords = sorted(list(set(r for _, r, _ in found_rectangles)))\n    cols_coords = sorted(list(set(c for _, _, c in found_rectangles)))\n    \n    output_rows = len(rows_coords)\n    output_cols = len(cols_coords)\n\n    # Create mappings from actual coordinates to output grid indices\n    row_map = {r: i for i, r in enumerate(rows_coords)}\n    col_map = {c: j for i, c in enumerate(cols_coords)}\n\n    # 3. Initialize the output grid\n    output_grid = np.zeros((output_rows, output_cols), dtype=int) # Use 0 (white) as default/background\n\n    # 4. Populate the output grid\n    for inner_color, r, c in found_rectangles:\n        output_r = row_map[r]\n        output_c = col_map[c]\n        output_grid[output_r, output_c] = inner_color\n\n    return output_grid.tolist() # Return as list of lists per ARC format\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5374,
    "candidates_token_count": 1555,
    "total_token_count": 6929,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 105.77508,
  "retries": null
}