{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nScan the input grid to identify all distinct rectangular regions that consist of \na solid block of one color (the \"inner color\") perfectly enclosed by a 1-pixel \nthick border of a different, uniform color (the \"frame color\"). Ignore any shapes \nthat do not meet this exact criterion. For each identified framed rectangle, record \nits inner color and the row and column coordinates of the top-left pixel of its \ninner block. Collect all unique row coordinates and sort them to determine the \noutput grid height. Collect all unique column coordinates and sort them to determine \nthe output grid width. Create a new output grid with the calculated dimensions, \ninitializing all cells to white (0). Iterate through the identified framed \nrectangles again. For each rectangle, find the index of its inner top-left row \ncoordinate within the sorted unique row list (this is the output row index) and \nthe index of its inner top-left column coordinate within the sorted unique \ncolumn list (this is the output column index). Place the rectangle's inner color \ninto the output grid at the calculated (output row index, output column index). \nReturn the populated output grid.\n\"\"\"\n\ndef find_framed_rectangles(grid):\n    \"\"\"\n    Finds all framed rectangles in the grid.\n\n    A framed rectangle is defined as a solid rectangular block of an inner color\n    completely surrounded by a 1-pixel thick frame of a different, uniform frame color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (inner_color, top_row, left_col)\n              representing the inner color and the top-left coordinates \n              of the inner rectangle (pixel immediately inside the top-left frame corner). \n              Returns an empty list if no such rectangles are found.\n    \"\"\"\n    rectangles = []\n    rows, cols = grid.shape\n    # Keep track of visited pixels to avoid redundant checks and overlapping detections\n    visited = np.zeros_like(grid, dtype=bool) \n\n    # Iterate through potential top-left corners of the *frame*\n    for r in range(rows - 2): # Need at least 3 rows (top frame, inner, bottom frame)\n        for c in range(cols - 2): # Need at least 3 cols (left frame, inner, right frame)\n            \n            # Skip if this pixel has already been processed as part of another rectangle\n            if visited[r, c]:\n                continue\n\n            frame_color = grid[r, c]\n            # Potential inner color is at [r+1, c+1]\n            potential_inner_color = grid[r+1, c+1]\n\n            # Basic checks for a potential framed rectangle start point:\n            # 1. Frame color and inner color must be different.\n            if frame_color == potential_inner_color:\n                continue\n            # 2. The pixels directly below and right of the top-left corner must also be frame_color.\n            if grid[r+1, c] != frame_color or grid[r, c+1] != frame_color:\n                 continue\n\n            # If the basic checks pass, try to determine the dimensions of the inner rectangle\n            inner_r, inner_c = r + 1, c + 1\n            height = 0\n            width = 0\n\n            # Determine the height of the potential inner rectangle\n            # Check downwards from the first potential inner pixel [inner_r, inner_c]\n            # Ensure the left frame pixel matches frame_color and the inner pixel matches potential_inner_color\n            for h in range(inner_r, rows -1): # rows-1 because we need to check the bottom frame later\n                if grid[h, inner_c - 1] == frame_color and grid[h, inner_c] == potential_inner_color:\n                    height += 1\n                else:\n                    break # Stop if the pattern breaks (either left frame or inner color changes)\n\n            # Determine the width of the potential inner rectangle\n            # Check rightwards from the first potential inner pixel [inner_r, inner_c]\n            # Ensure the top frame pixel matches frame_color and the inner pixel matches potential_inner_color\n            for w in range(inner_c, cols -1): # cols-1 because we need to check the right frame later\n                if grid[inner_r - 1, w] == frame_color and grid[inner_r, w] == potential_inner_color:\n                    width += 1\n                else:\n                    break # Stop if the pattern breaks (either top frame or inner color changes)\n            \n            # If we couldn't find a valid height or width (at least 1x1 inner), continue searching\n            if height == 0 or width == 0:\n                continue \n\n            # Calculate the coordinates of the bottom-right corner of the inner rectangle\n            bottom_r = inner_r + height - 1\n            right_c = inner_c + width - 1\n\n            # --- Verification Step ---\n            # Now verify if this potential rectangle is truly a framed rectangle\n\n            # 1. Check if the calculated inner area is a solid block of the potential_inner_color.\n            inner_area = grid[inner_r : bottom_r + 1, inner_c : right_c + 1]\n            if not np.all(inner_area == potential_inner_color):\n                continue # Inner area is not solid, this is not a valid framed rectangle\n\n            # 2. Check if the surrounding frame (1-pixel thick) is solid and matches frame_color.\n            is_framed = True\n            try: # Use try-except for boundary checks, simplifying the frame logic\n                # Check Top frame row (including corners)\n                if not np.all(grid[inner_r - 1, inner_c - 1 : right_c + 2] == frame_color):\n                    is_framed = False\n                # Check Bottom frame row (including corners)\n                elif not np.all(grid[bottom_r + 1, inner_c - 1 : right_c + 2] == frame_color):\n                    is_framed = False\n                # Check Left frame column (excluding corners checked above)\n                elif not np.all(grid[inner_r : bottom_r + 1, inner_c - 1] == frame_color):\n                    is_framed = False\n                # Check Right frame column (excluding corners checked above)\n                elif not np.all(grid[inner_r : bottom_r + 1, right_c + 1] == frame_color):\n                    is_framed = False\n            except IndexError:\n                # If any frame check goes out of bounds, it's not properly framed within the grid\n                is_framed = False\n                 \n            # If all checks passed, it's a valid framed rectangle\n            if is_framed:\n                # Record the inner color and the top-left coordinate of the inner rectangle\n                rectangles.append((potential_inner_color, inner_r, inner_c))\n                # Mark the entire area of the framed rectangle (including the frame) as visited\n                # This prevents re-detecting parts of it or overlapping structures incorrectly\n                visited[inner_r - 1 : bottom_r + 2, inner_c - 1 : right_c + 2] = True\n                \n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies framed rectangles in the input grid, determines their relative\n    layout, and creates an output grid containing their inner colors arranged\n    according to that layout.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n\n    # Step 1 & 2: Find all framed rectangles and record inner color and inner top-left position\n    found_rectangles = find_framed_rectangles(grid_np)\n\n    # Handle case where no rectangles are found\n    if not found_rectangles:\n        # Return a 1x1 grid with white(0) as a default output\n        return [[0]] \n\n    # Step 3: Determine unique row coordinates and sort them\n    # These coordinates correspond to the top row of the *inner* rectangle\n    rows_coords = sorted(list(set(r for _, r, _ in found_rectangles)))\n    \n    # Step 4: Determine unique column coordinates and sort them\n    # These coordinates correspond to the left column of the *inner* rectangle\n    cols_coords = sorted(list(set(c for _, _, c in found_rectangles)))\n    \n    # Calculate output grid dimensions based on the number of unique rows/columns found\n    output_rows = len(rows_coords)\n    output_cols = len(cols_coords)\n\n    # Create mappings from the actual grid coordinates to the output grid indices (0-based)\n    row_map = {r: i for i, r in enumerate(rows_coords)}\n    col_map = {c: i for i, c in enumerate(cols_coords)} # Corrected variable 'j' to 'i'\n\n    # Step 5: Create the output grid, initialized with white (0)\n    output_grid = np.zeros((output_rows, output_cols), dtype=int) \n\n    # Step 6: Populate the output grid\n    for inner_color, r, c in found_rectangles:\n        # Find the corresponding output grid row index using the row map\n        output_r = row_map[r]\n        # Find the corresponding output grid column index using the column map\n        output_c = col_map[c]\n        # Place the inner color at the calculated position in the output grid\n        output_grid[output_r, output_c] = inner_color\n\n    # Step 7: Return the populated output grid as a list of lists\n    return output_grid.tolist() \n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4645,
    "candidates_token_count": 2264,
    "total_token_count": 6909,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.919243,
  "retries": null
}