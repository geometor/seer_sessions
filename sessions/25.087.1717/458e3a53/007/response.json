{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies a 'frame' color based on line segments, finds solid rectangular blocks of other colors completely enclosed by a 1-pixel thick border of the frame color, and arranges the colors of these inner blocks into an output grid based on the relative spatial positions of the blocks.\n\n1.  **Determine Frame Color:** Identify the color that forms the most horizontal and vertical line segments of length 3 or more in the input grid. This is the `frame_color`. If no such lines are found, use the most frequent non-background color as a fallback.\n2.  **Find Framed Rectangles:** Iterate through the grid to find potential top-left corners (r, c) of inner blocks (pixels not matching the `frame_color`).\n3.  **Verify Rectangle and Frame:** For each potential corner:\n    a.  Determine the `inner_color`.\n    b.  Calculate the `height` and `width` of the contiguous block of `inner_color` starting at (r, c).\n    c.  Check if this inner block is fully enclosed by a 1-pixel thick border consisting solely of the `frame_color`. The frame check includes corners and must be within grid bounds.\n4.  **Store Rectangle Info:** If a valid framed rectangle is found, store its `inner_color`, and the top-left coordinates `(r, c)` of the inner block.\n5.  **Calculate Output Dimensions:** Collect the unique row coordinates and unique column coordinates from the stored top-left positions. Sort them to determine the order. The number of unique rows is the `output_height`, and the number of unique columns is the `output_width`.\n6.  **Create Coordinate Maps:** Create mappings from the sorted unique row coordinates to output grid row indices (0, 1, ...) and from sorted unique column coordinates to output grid column indices (0, 1, ...).\n7.  **Construct and Populate Output Grid:** Create an output grid of size `output_height` x `output_width`, initialized to white (0). Iterate through the stored rectangle information. For each rectangle, use the coordinate maps to find the corresponding output grid position `(output_r, output_c)` for its `(r, c)` coordinates and place its `inner_color` there.\n8.  **Return Output:** Return the populated output grid. If no frame color or no rectangles are found, return a default `[[0]]` grid.\n\"\"\"\n\ndef find_frame_color(grid):\n    \"\"\"\n    Identifies the potential frame color by finding the color that forms\n    the most horizontal and vertical line segments of length 3 or more.\n    Includes a fallback to most frequent non-background or overall most frequent color.\n    \"\"\"\n    rows, cols = grid.shape\n    line_colors = Counter()\n    min_line_length = 3\n\n    # Horizontal lines\n    for r in range(rows):\n        c = 0\n        while c < cols:\n            color = grid[r, c]\n            if color == 0: # Skip background for line counting? Maybe not necessary\n                c+=1\n                continue\n            length = 0\n            while c + length < cols and grid[r, c + length] == color:\n                length += 1\n\n            if length >= min_line_length:\n                line_colors[color] += 1\n            c += length # Move past the segment regardless of length\n\n\n    # Vertical lines\n    for c in range(cols):\n        r = 0\n        while r < rows:\n            color = grid[r, c]\n            if color == 0: # Skip background for line counting?\n                 r+=1\n                 continue\n            length = 0\n            while r + length < rows and grid[r + length, c] == color:\n                length += 1\n\n            if length >= min_line_length:\n                line_colors[color] += 1\n            r += length # Move past the segment regardless of length\n\n    if line_colors:\n        # Return the most common color found in lines\n        frame_color = line_colors.most_common(1)[0][0]\n        return frame_color\n    else:\n        # Fallback: If no lines >= 3, find the most frequent non-background color\n        all_colors = Counter(grid.flatten())\n        if 0 in all_colors:\n            del all_colors[0] # Remove background color count\n\n        if all_colors:\n             # Return most frequent non-background color\n             return all_colors.most_common(1)[0][0]\n        else:\n            # If only background exists or grid is empty, maybe return background or -1\n            # Let's try returning the overall most frequent if non-background failed\n            all_colors_inc_bg = Counter(grid.flatten())\n            if all_colors_inc_bg:\n                 return all_colors_inc_bg.most_common(1)[0][0]\n            else:\n                 return -1 # Indicate no plausible color found\n\n\ndef find_framed_rectangles(grid, frame_color):\n    \"\"\"\n    Finds all rectangles perfectly framed by a specific frame_color.\n    This version removes the `visited` array to avoid issues with adjacent frames.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        frame_color (int): The color of the frame.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (inner_color, top_row, left_col)\n              representing the inner color and the top-left coordinates\n              of the inner rectangle. Returns an empty list if none found.\n    \"\"\"\n    rectangles = []\n    rows, cols = grid.shape\n    processed_inner_coords = set() # Keep track of inner blocks already found\n\n    # Iterate through potential top-left corners of the *inner* rectangle\n    # The inner rectangle must start at least at (1, 1) and end at most at (rows-2, cols-2)\n    for r in range(1, rows - 1):\n        for c in range(1, cols - 1):\n            \n            # If this coordinate is part of an already identified inner block, skip\n            if (r, c) in processed_inner_coords:\n                continue\n\n            # Potential inner block must not be the frame color\n            if grid[r, c] == frame_color:\n                continue\n\n            inner_color = grid[r, c]\n\n            # Basic check: Immediate top and left must be frame color\n            if grid[r - 1, c] != frame_color or grid[r, c - 1] != frame_color:\n                 continue\n                 \n            # Determine the dimensions of the solid inner rectangle starting at (r,c)\n            height = 0\n            for h_offset in range(rows - r):\n                if grid[r + h_offset, c] == inner_color:\n                    height += 1\n                else:\n                    break\n\n            width = 0\n            # Check first row consistency to find width\n            for w_offset in range(cols - c):\n                 if r + height > rows : # Ensure we don't go out of bounds when checking rows below\n                     width=0\n                     break\n                 # Check if the entire column segment within the potential rect has the inner color\n                 is_solid_column = True\n                 for h_check in range(height):\n                     if c + w_offset >= cols or grid[r + h_check, c + w_offset] != inner_color:\n                         is_solid_column = False\n                         break\n                 if is_solid_column:\n                    width +=1\n                 else:\n                    break\n            \n            if height == 0 or width == 0:\n                continue # Not a valid rectangle start\n\n            # Define inner block boundaries\n            inner_r_start, inner_c_start = r, c\n            inner_r_end, inner_c_end = r + height - 1, c + width - 1\n\n            # --- Verification Step ---\n            is_valid = True\n\n            # 1. Verify the inner area is indeed solid inner_color (redundant given width calc, but safe)\n            # if not np.all(grid[inner_r_start : inner_r_end + 1, inner_c_start : inner_c_end + 1] == inner_color):\n            #     is_valid = False\n            #     continue # This check should be inherently passed by how width/height were found\n\n            # 2. Verify the surrounding frame (1-pixel thick) is solid frame_color\n            frame_r_start, frame_c_start = inner_r_start - 1, inner_c_start - 1\n            frame_r_end, frame_c_end = inner_r_end + 1, inner_c_end + 1\n\n            # Check if frame goes out of bounds\n            if frame_r_start < 0 or frame_c_start < 0 or frame_r_end >= rows or frame_c_end >= cols:\n                is_valid = False\n                continue # Frame extends beyond grid boundaries\n\n            try:\n                # Check Top frame row\n                if not np.all(grid[frame_r_start, frame_c_start : frame_c_end + 1] == frame_color):\n                    is_valid = False\n                # Check Bottom frame row\n                elif not np.all(grid[frame_r_end, frame_c_start : frame_c_end + 1] == frame_color):\n                    is_valid = False\n                # Check Left frame column (excluding corners already checked by rows)\n                elif not np.all(grid[frame_r_start + 1 : frame_r_end, frame_c_start] == frame_color):\n                    is_valid = False\n                # Check Right frame column (excluding corners already checked by rows)\n                elif not np.all(grid[frame_r_start + 1 : frame_r_end, frame_c_end] == frame_color):\n                    is_valid = False\n            except IndexError:\n                 # Should be caught by boundary check above, but as safety\n                is_valid = False\n\n            # If all checks passed, it's a valid framed rectangle\n            if is_valid:\n                # Add to list\n                rectangles.append((inner_color, inner_r_start, inner_c_start))\n                \n                # Mark all pixels within this inner block as processed\n                # This prevents redundant checks starting within this block\n                for row_idx in range(inner_r_start, inner_r_end + 1):\n                    for col_idx in range(inner_c_start, inner_c_end + 1):\n                        processed_inner_coords.add((row_idx, col_idx))\n\n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding framed rectangles, extracting their\n    inner colors, and arranging them spatially in an output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # Handle grids too small to contain a framed rectangle (inner 1x1 + frame = 3x3)\n    if rows < 3 or cols < 3:\n        return [[0]] # Default output for small grids\n\n    # Step 1: Identify the frame color\n    frame_color = find_frame_color(grid_np)\n\n    # If no plausible frame color identified, return default\n    if frame_color == -1:\n         # print(\"Warning: Could not reliably determine frame color.\")\n         return [[0]]\n\n    # Step 2, 3 & 4: Find all framed rectangles using the identified frame color\n    # and record their inner color and top-left inner coordinate.\n    # Uses the revised find_framed_rectangles without the problematic visited array.\n    found_rectangles = find_framed_rectangles(grid_np, frame_color)\n\n    # Handle case where no rectangles are found\n    if not found_rectangles:\n        return [[0]] # Return default if no framed rectangles found\n\n    # Step 5: Determine output dimensions and coordinate mapping\n    # Collect unique row and column coordinates of the *inner* top-left corners\n    rows_coords = sorted(list(set(r for _, r, _ in found_rectangles)))\n    cols_coords = sorted(list(set(c for _, _, c in found_rectangles)))\n\n    # Calculate output grid dimensions\n    output_rows = len(rows_coords)\n    output_cols = len(cols_coords)\n\n    # Handle case where dimensions might be zero (shouldn't happen if rectangles were found)\n    if output_rows == 0 or output_cols == 0:\n         return [[0]]\n\n    # Step 6: Create mappings from actual grid coordinates to output grid indices\n    row_map = {r: i for i, r in enumerate(rows_coords)}\n    col_map = {c: i for i, c in enumerate(cols_coords)}\n\n    # Step 7: Create the output grid, initialized with white (0)\n    output_grid = np.zeros((output_rows, output_cols), dtype=int)\n\n    # Step 8: Populate the output grid\n    for inner_color, r, c in found_rectangles:\n        # Find the corresponding output grid indices using the maps\n        # Check if the coordinates exist in the map (they should)\n        if r in row_map and c in col_map:\n            output_r = row_map[r]\n            output_c = col_map[c]\n            # Place the inner color at the calculated position\n            output_grid[output_r, output_c] = inner_color\n        # else:\n            # This case indicates an issue, perhaps in how rectangles were recorded or maps created.\n            # print(f\"Warning: Coordinate ({r}, {c}) not found in maps.\")\n\n\n    # Step 9: Return the populated output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7689,
    "candidates_token_count": 3217,
    "total_token_count": 10906,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 132.39599,
  "retries": null
}