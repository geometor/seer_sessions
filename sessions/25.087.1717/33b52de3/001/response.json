{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify two distinct regions in the input grid:\n    a. A \"template grid\": A region composed of multiple instances of a repeating gray (5) pattern (specifically a 3x3 hollow square), arranged in a grid structure.\n    b. A \"key pattern\": A compact rectangular block of various colors, spatially separated from the template grid.\n2. Determine the dimensions (rows `tr`, columns `tc`) of the template grid based on the arrangement of the gray patterns.\n3. Determine the dimensions (rows `kh`, columns `kc`) and top-left corner (`kr`, `kc`) of the key pattern. The dimensions must match the template grid dimensions (`tr == kh`, `tc == kw`).\n4. Create an output grid initially identical to the input grid.\n5. Iterate through each position `(r, c)` within the template grid's structure (from `r=0` to `tr-1`, `c=0` to `tc-1`).\n6. For each `(r, c)`:\n    a. Identify the specific gray template pattern instance corresponding to this position in the template grid.\n    b. Get the replacement color from the key pattern at the corresponding relative position: `color = input_grid[kr + r, kc + c]`.\n    c. Find all gray (5) pixels belonging to the identified template pattern instance.\n    d. In the output grid, change the color of these gray pixels to the replacement color obtained in step 6b.\n7. Return the modified output grid. The key pattern itself and the background remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a specific color.\"\"\"\n    h, w = grid.shape\n    visited = np.zeros((h, w), dtype=bool)\n    objects = []\n\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < h and 0 <= nc < w and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Bounding box: top, left, bottom, right (inclusive)\n                bbox = (min_r, min_c, max_r, max_c)\n                objects.append({'pixels': set(obj_pixels), 'bbox': bbox, 'color': color})\n                \n    return objects\n\ndef is_template_pattern(grid, obj):\n    \"\"\"Checks if an object is the specific 3x3 hollow gray square template.\"\"\"\n    if obj['color'] != 5:\n        return False\n        \n    min_r, min_c, max_r, max_c = obj['bbox']\n    h = max_r - min_r + 1\n    w = max_c - min_c + 1\n\n    if h != 3 or w != 3:\n        return False\n\n    # Check if it's a hollow square\n    expected_pixels = set()\n    for r in range(min_r, max_r + 1):\n        expected_pixels.add((r, min_c))\n        expected_pixels.add((r, max_c))\n    for c in range(min_c + 1, max_c):\n        expected_pixels.add((min_r, c))\n        expected_pixels.add((max_r, c))\n        \n    return obj['pixels'] == expected_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule described above.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1a. Find all gray objects\n    gray_objects = find_objects(input_grid, 5)\n\n    # 1a. Identify template instances (3x3 hollow gray squares)\n    template_instances = []\n    for obj in gray_objects:\n        if is_template_pattern(input_grid, obj):\n            template_instances.append(obj)\n\n    if not template_instances:\n        # No template patterns found, return original grid\n        return output_grid.tolist()\n\n    # 2. Determine template grid structure\n    # Get top-left corners and sort them\n    corners = sorted([(obj['bbox'][0], obj['bbox'][1], obj) for obj in template_instances])\n    \n    min_template_r = min(c[0] for c in corners)\n    min_template_c = min(c[1] for c in corners)\n    max_template_r = max(c[0] for c in corners)\n    max_template_c = max(c[1] for c in corners)\n\n    # Find unique row and column coordinates of the templates\n    template_rows = sorted(list(set(c[0] for c in corners)))\n    template_cols = sorted(list(set(c[1] for c in corners)))\n    \n    tr = len(template_rows) # template grid height\n    tc = len(template_cols) # template grid width\n    \n    # Create a mapping from template grid index (r, c) to the actual object\n    template_map = {}\n    corner_to_obj = {(c[0], c[1]): c[2] for c in corners}\n    for r_idx, row_val in enumerate(template_rows):\n        for c_idx, col_val in enumerate(template_cols):\n            if (row_val, col_val) in corner_to_obj:\n                 template_map[(r_idx, c_idx)] = corner_to_obj[(row_val, col_val)]\n            # else: might indicate an incomplete grid, handle if necessary\n\n\n    # 1b. Find potential key patterns (non-white, non-gray objects)\n    key_pattern = None\n    key_r, key_c = -1, -1\n    \n    potential_key_colors = set(range(1, 10)) - {5} # Colors 1-9 excluding gray\n    \n    all_objects = []\n    for color in potential_key_colors:\n         all_objects.extend(find_objects(input_grid, color))\n    # Also consider objects made of multiple colors if needed, but let's assume single-color blocks first.\n    # A more robust approach would find *all* non-background contiguous blocks regardless of color variations within.\n    # For this task, the key seems to be a simple rectangle of single-color cells. Let's refine based on bounding box.\n    \n    # Find *all* non-background pixels\n    non_bg_pixels = np.argwhere(input_grid != 0)\n    \n    # Exclude pixels belonging to template instances\n    template_pixel_set = set()\n    for obj in template_instances:\n        template_pixel_set.update(obj['pixels'])\n        \n    potential_key_pixels = []\n    for r,c in non_bg_pixels:\n        if (r,c) not in template_pixel_set:\n            potential_key_pixels.append((r,c))\n\n    if not potential_key_pixels:\n         # No key pattern found? This shouldn't happen based on examples.\n         return output_grid.tolist() \n\n    # Find the bounding box of the remaining non-background, non-template pixels\n    min_key_r = min(p[0] for p in potential_key_pixels)\n    min_key_c = min(p[1] for p in potential_key_pixels)\n    max_key_r = max(p[0] for p in potential_key_pixels)\n    max_key_c = max(p[1] for p in potential_key_pixels)\n\n    # 3. Check if dimensions match the template grid\n    kh = max_key_r - min_key_r + 1\n    kw = max_key_c - min_key_c + 1\n    \n    if kh == tr and kw == tc:\n        key_pattern_found = True\n        key_r, key_c = min_key_r, min_key_c\n    else:\n        # If simple bounding box doesn't work, we might need a more complex object detection\n        # for the key pattern, possibly involving finding the largest compact non-template object.\n        # But let's assume the bounding box approach works for now.\n        key_pattern_found = False\n\n\n    if not key_pattern_found:\n        # Key pattern matching template dimensions not found\n        print(\"Warning: Key pattern dimensions do not match template grid dimensions.\")\n        return output_grid.tolist() # Return unchanged grid if logic fails\n\n    # 4. Initialize output grid (already done)\n\n    # 5. Iterate through template grid positions\n    for r_idx in range(tr):\n        for c_idx in range(tc):\n            # 6a. Get corresponding template instance\n            if (r_idx, c_idx) in template_map:\n                template_obj = template_map[(r_idx, c_idx)]\n                \n                # 6b. Get replacement color from key pattern\n                replacement_color = input_grid[key_r + r_idx, key_c + c_idx]\n                \n                # 6c & 6d. Find gray pixels in template and replace in output grid\n                for (px_r, px_c) in template_obj['pixels']:\n                    # Check original color is gray (5) before replacing\n                    if input_grid[px_r, px_c] == 5: \n                        output_grid[px_r, px_c] = replacement_color\n            # else: Handle missing template instance in the grid if necessary\n\n\n    # 7. Return the modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6573,
    "candidates_token_count": 2481,
    "total_token_count": 9054,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.97028,
  "retries": null
}