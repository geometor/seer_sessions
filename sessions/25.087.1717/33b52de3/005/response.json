{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport sys\n\n# Increase recursion depth for deep copies or large structures if necessary\n# sys.setrecursionlimit(2000) # Example adjustment, use if needed\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Templates:** Scan the input grid to find all instances of the template pattern: a 3x3 hollow square made entirely of gray (5) pixels (meaning the 8 border pixels are gray). Record the set of coordinates for the 8 gray pixels belonging to each template instance and its top-left corner.\n2.  **Determine Template Grid Structure:** Analyze the top-left corners of the found template instances. Determine the number of unique rows (`tr`) and unique columns (`tc`) these templates occupy, effectively defining the dimensions of a \"template grid\". Create a mapping to easily access the specific template instance corresponding to each logical grid position `(r_idx, c_idx)`, where `0 <= r_idx < tr` and `0 <= c_idx < tc`. If no templates are found, return the input grid unchanged.\n3.  **Identify Key Source Pixels:** Create a set of all pixel coordinates `(r, c)` in the input grid that meet three criteria: (a) the color `input_grid[r, c]` is not background (0), (b) the color `input_grid[r, c]` is not gray (5), and (c) the coordinate `(r, c)` is not part of any pixel set belonging to the templates identified in step 1.\n4.  **Determine Key Source Bounding Box:** If any key source pixels were found in step 3, calculate the minimum bounding box that encloses all of them. Record its top-left corner `(key_min_r, key_min_c)`, its height `key_h`, and its width `key_w`. If no key source pixels were found, return the input grid unchanged.\n5.  **Validate Dimensions:** Check if the template grid height `tr` is equal to the key source bounding box height `key_h`, AND if the template grid width `tc` is equal to the key source bounding box width `key_w`. If these dimensions do not match, return the input grid unchanged.\n6.  **Prepare Output Grid:** Create a copy of the input grid to serve as the output grid.\n7.  **Apply Transformation:** Iterate through each logical position `(r_idx, c_idx)` of the template grid (from `(0, 0)` to `(tr-1, tc-1)`).\n    a.  Check if a template instance exists at this logical position using the mapping from step 2.\n    b.  If a template exists:\n        i.  Determine the corresponding source coordinate within the key region in the original grid: `src_r = key_min_r + r_idx`, `src_c = key_min_c + c_idx`.\n        ii. Retrieve the replacement color from the *original input grid* at `(src_r, src_c)`.\n        iii. For every pixel coordinate `(px_r, px_c)` belonging to the 8 gray pixels of the current template instance, update its color in the *output grid* to the retrieved replacement color.\n8.  **Return Result:** Return the modified output grid.\n\"\"\"\n\ndef find_template_objects(grid):\n    \"\"\"\n    Finds all 3x3 hollow gray square template objects in the grid.\n    A template is defined by 8 gray pixels forming the border of a 3x3 square.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a template object with keys:\n              'pixels' (set of (r, c) tuples for the 8 gray pixels),\n              'top_left' (tuple: r, c).\n    \"\"\"\n    templates = []\n    h, w = grid.shape\n    gray = 5\n\n    # Iterate up to h-3 and w-3 to allow checking a 3x3 area\n    for r in range(h - 2):\n        for c in range(w - 2):\n            # Check if the 8 border pixels of the 3x3 square starting at (r,c) are gray\n            is_template = True\n            template_pixels = set()\n\n            # Top row\n            if grid[r, c] == gray and grid[r, c+1] == gray and grid[r, c+2] == gray:\n                template_pixels.add((r, c))\n                template_pixels.add((r, c+1))\n                template_pixels.add((r, c+2))\n            else:\n                is_template = False\n\n            # Middle row (sides)\n            if is_template and grid[r+1, c] == gray and grid[r+1, c+2] == gray:\n                template_pixels.add((r+1, c))\n                template_pixels.add((r+1, c+2))\n            elif is_template:\n                is_template = False\n\n            # Bottom row\n            if is_template and grid[r+2, c] == gray and grid[r+2, c+1] == gray and grid[r+2, c+2] == gray:\n                template_pixels.add((r+2, c))\n                template_pixels.add((r+2, c+1))\n                template_pixels.add((r+2, c+2))\n            elif is_template:\n                is_template = False\n\n            # If all checks passed, store the template\n            if is_template:\n                # Double-check pixel count (should be 8)\n                if len(template_pixels) == 8:\n                    templates.append({\n                        'pixels': template_pixels,\n                        'top_left': (r, c)\n                    })\n\n    return templates\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule based on templates and a key source region.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n    gray = 5\n    background = 0\n\n    # 1. Identify Templates\n    template_instances = find_template_objects(input_grid)\n\n    # 2. Determine Template Grid Structure & Handle Edge Case (No Templates)\n    if not template_instances:\n        return output_grid.tolist() # Return original if no templates\n\n    # Extract top-left corners and determine unique rows/cols\n    corners = sorted([t['top_left'] for t in template_instances])\n    template_rows = sorted(list(set(r for r, c in corners)))\n    template_cols = sorted(list(set(c for r, c in corners)))\n    tr = len(template_rows) # template grid height\n    tc = len(template_cols) # template grid width\n\n    # Create mapping from template grid index (r_idx, c_idx) to the actual object\n    template_map = {}\n    # Create reverse lookups for rows/cols to indices\n    row_map = {row_val: r_idx for r_idx, row_val in enumerate(template_rows)}\n    col_map = {col_val: c_idx for c_idx, col_val in enumerate(template_cols)}\n    # Build the map using the template instances\n    for template_obj in template_instances:\n        r_val, c_val = template_obj['top_left']\n        if r_val in row_map and c_val in col_map: # Ensure corner belongs to the identified grid\n             r_idx = row_map[r_val]\n             c_idx = col_map[c_val]\n             template_map[(r_idx, c_idx)] = template_obj\n\n\n    # 3. Identify Key Source Pixels\n    all_template_pixels = set().union(*(t['pixels'] for t in template_instances))\n    key_source_pixels = []\n    for r in range(h):\n        for c in range(w):\n            color = input_grid[r, c]\n            coord = (r, c)\n            if color != background and color != gray and coord not in all_template_pixels:\n                key_source_pixels.append(coord)\n\n    # 4. Determine Key Source Bounding Box & Handle Edge Case (No Key Pixels)\n    if not key_source_pixels:\n        return output_grid.tolist() # Return original if no key pixels\n\n    key_min_r = min(r for r, c in key_source_pixels)\n    key_min_c = min(c for r, c in key_source_pixels)\n    key_max_r = max(r for r, c in key_source_pixels)\n    key_max_c = max(c for r, c in key_source_pixels)\n    key_h = key_max_r - key_min_r + 1\n    key_w = key_max_c - key_min_c + 1\n\n    # 5. Validate Dimensions\n    if key_h != tr or key_w != tc:\n        return output_grid.tolist() # Return original if dimensions don't match\n\n    # 6. Prepare Output Grid (already done: output_grid = np.copy(input_grid))\n\n    # 7. Apply Transformation\n    for r_idx in range(tr):\n        for c_idx in range(tc):\n            # 7a. Check if a template exists at this logical position\n            if (r_idx, c_idx) in template_map:\n                template_obj = template_map[(r_idx, c_idx)]\n\n                # 7b. Determine source coordinate and get replacement color\n                src_r = key_min_r + r_idx\n                src_c = key_min_c + c_idx\n\n                # Bounds check for safety, though dimensions should match\n                if 0 <= src_r < h and 0 <= src_c < w:\n                    replacement_color = input_grid[src_r, src_c]\n\n                    # 7c. Replace pixels in the output grid\n                    for (px_r, px_c) in template_obj['pixels']:\n                        # Ensure coordinates are valid (should be)\n                        if 0 <= px_r < h and 0 <= px_c < w:\n                           # Check if the pixel in the *original* input was gray,\n                           # to avoid overwriting something else if templates overlapped (unlikely but safe)\n                           # Although, output_grid initially is a copy, so checking output_grid[px_r, px_c] == gray works too.\n                           # Let's check the original input for conceptual clarity.\n                           if input_grid[px_r, px_c] == gray:\n                               output_grid[px_r, px_c] = replacement_color\n                # else: Handle case where calculated source coordinate is out of bounds (error condition)\n                #      Might indicate flaw in dimension check or key source calculation.\n                #      Current logic relies on dimension check passing.\n\n    # 8. Return Result\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15602,
    "candidates_token_count": 2568,
    "total_token_count": 18170,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.54827,
  "retries": null
}