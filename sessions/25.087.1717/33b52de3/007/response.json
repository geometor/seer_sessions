{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  Initialize: Create a copy of the input grid to serve as the output grid.\n2.  Identify Templates: Scan the input grid to find all instances of the \"template\" pattern: a 3x3 area where the 8 border pixels are gray (5) and the center pixel is *not* gray. For each template found, record the set of coordinates for its 8 gray border pixels and the coordinate of its top-left corner.\n3.  Handle No Templates: If no template instances are found, return the initial output grid (the unchanged copy of the input).\n4.  Determine Template Grid Structure:\n    a.  Collect the top-left corner coordinates of all found template instances.\n    b.  Determine the sorted list of unique row indices and unique column indices from these corners.\n    c.  The number of unique rows is the template grid height (`tr`).\n    d.  The number of unique columns is the template grid width (`tc`).\n    e.  Create a mapping (e.g., a dictionary) where keys are logical grid indices `(r_idx, c_idx)` (from `(0,0)` to `(tr-1, tc-1)`) and values are the corresponding template objects found at that logical position in the grid.\n5.  Identify Key Region Anchor:\n    a.  Create a set containing the coordinates of all gray pixels belonging to *any* identified template instance.\n    b.  Scan the input grid row by row, column by column, to find the first pixel `(r, c)` that meets all the following criteria:\n        i.  Its color is not background (0).\n        ii. Its color is not gray (5).\n        iii. Its coordinate `(r, c)` is not in the set of template pixels identified in step 5a.\n    c.  Record the coordinate `(r, c)` of this first matching pixel as the key region anchor `(key_min_r, key_min_c)`.\n6.  Handle No Anchor: If no anchor pixel is found (meaning there are no non-background, non-gray pixels outside the templates), return the initial output grid.\n7.  Apply Transformation: Iterate through each logical position `(r_idx, c_idx)` of the template grid (from `(0, 0)` up to `(tr-1, tc-1)`).\n    a.  Check if a template instance exists at this logical position using the mapping created in step 4e.\n    b.  If a template exists at `(r_idx, c_idx)`:\n        i.  Calculate the corresponding source coordinate within the key region in the original input grid: `src_r = key_min_r + r_idx`, `src_c = key_min_c + c_idx`.\n        ii. Retrieve the replacement color from the *original input grid* at `(src_r, src_c)`. Handle potential out-of-bounds access if `src_r` or `src_c` fall outside the input grid dimensions.\n        iii. Retrieve the set of 8 gray pixel coordinates associated with the current template instance `(r_idx, c_idx)`.\n        iv. For each coordinate `(px_r, px_c)` in this set, update the color of the pixel at `(px_r, px_c)` in the *output grid* to the retrieved replacement color.\n8.  Return Result: Return the modified output grid.\n\"\"\"\n\ndef find_template_objects(grid):\n    \"\"\"\n    Finds all 3x3 hollow gray square template objects in the grid.\n    A template is defined by 8 gray pixels forming the border of a 3x3 square,\n    and the center pixel NOT being gray.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a template object with keys:\n              'pixels' (set of (r, c) tuples for the 8 gray border pixels),\n              'top_left' (tuple: r, c).\n    \"\"\"\n    templates = []\n    h, w = grid.shape\n    gray = 5\n\n    # Iterate up to h-3 and w-3 to allow checking a 3x3 area\n    for r in range(h - 2):\n        for c in range(w - 2):\n            # Check if the 8 border pixels of the 3x3 square starting at (r,c) are gray\n            is_template_border = True\n            template_pixels = set()\n\n            # Coordinates of the 8 border pixels relative to (r, c)\n            border_coords_relative = [\n                (0, 0), (0, 1), (0, 2),\n                (1, 0),         (1, 2),\n                (2, 0), (2, 1), (2, 2)\n            ]\n\n            for dr, dc in border_coords_relative:\n                pr, pc = r + dr, c + dc\n                if grid[pr, pc] == gray:\n                    template_pixels.add((pr, pc))\n                else:\n                    is_template_border = False\n                    break\n\n            # If border is gray, check center pixel is NOT gray\n            is_hollow = False\n            if is_template_border:\n                 center_r, center_c = r + 1, c + 1\n                 # Check bounds for center (should be fine given loop limits)\n                 if 0 <= center_r < h and 0 <= center_c < w and grid[center_r, center_c] != gray:\n                     is_hollow = True\n\n            # If all checks passed (gray border, non-gray center, 8 pixels), store the template\n            if is_template_border and is_hollow:\n                 # Double-check pixel count (should be 8)\n                if len(template_pixels) == 8:\n                    templates.append({\n                        'pixels': template_pixels,\n                        'top_left': (r, c)\n                    })\n\n    return templates\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule based on templates and a key source region\n    defined by an anchor point and template grid dimensions.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    # 1. Initialize output grid\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n    gray = 5\n    background = 0\n\n    # 2. Identify Templates\n    template_instances = find_template_objects(input_grid)\n\n    # 3. Handle No Templates\n    if not template_instances:\n        return output_grid.tolist() # Return original if no templates found\n\n    # 4. Determine Template Grid Structure\n    corners = sorted([t['top_left'] for t in template_instances])\n    # Determine unique rows and columns from template corners\n    template_rows = sorted(list(set(r for r, c in corners)))\n    template_cols = sorted(list(set(c for r, c in corners)))\n    tr = len(template_rows) # template grid height\n    tc = len(template_cols) # template grid width\n\n    # Create mapping from logical grid index (r_idx, c_idx) to the actual template object\n    template_map = {}\n    # Create reverse lookups for rows/cols to logical indices\n    row_map = {row_val: r_idx for r_idx, row_val in enumerate(template_rows)}\n    col_map = {col_val: c_idx for c_idx, col_val in enumerate(template_cols)}\n    # Build the map using the template instances\n    for template_obj in template_instances:\n        r_val, c_val = template_obj['top_left']\n        # Ensure the corner belongs to the grid structure derived from unique rows/cols\n        if r_val in row_map and c_val in col_map:\n             r_idx = row_map[r_val]\n             c_idx = col_map[c_val]\n             template_map[(r_idx, c_idx)] = template_obj\n\n    # 5. Identify Key Region Anchor\n    # 5a. Get all gray pixels belonging to any template\n    all_template_pixels = set().union(*(t['pixels'] for t in template_instances))\n    key_region_anchor = None\n    # 5b. Scan grid for the anchor pixel\n    for r in range(h):\n        for c in range(w):\n            color = input_grid[r, c]\n            coord = (r, c)\n            # Check criteria: not background, not gray, not part of a template's gray pixels\n            if color != background and color != gray and coord not in all_template_pixels:\n                key_region_anchor = coord # Found the top-leftmost anchor\n                break # Exit inner loop\n        if key_region_anchor:\n            break # Exit outer loop\n\n    # 6. Handle No Anchor\n    if key_region_anchor is None:\n        # No suitable anchor pixel found, return the original grid\n        return output_grid.tolist()\n\n    key_min_r, key_min_c = key_region_anchor\n\n    # 7. Apply Transformation\n    # Iterate through logical template grid positions\n    for r_idx in range(tr):\n        for c_idx in range(tc):\n            # 7a. Check if a template exists at this logical position\n            if (r_idx, c_idx) in template_map:\n                template_obj = template_map[(r_idx, c_idx)]\n\n                # 7b. Determine source coordinate and get replacement color\n                src_r = key_min_r + r_idx\n                src_c = key_min_c + c_idx\n\n                # Check if source coordinate is within the input grid bounds\n                if 0 <= src_r < h and 0 <= src_c < w:\n                    replacement_color = input_grid[src_r, src_c]\n\n                    # 7c. Get the 8 gray pixels for this template\n                    pixels_to_replace = template_obj['pixels']\n\n                    # 7d. Replace pixels in the output grid\n                    for (px_r, px_c) in pixels_to_replace:\n                        # Ensure target coordinates are valid (should be, as they came from template finding)\n                        if 0 <= px_r < h and 0 <= px_c < w:\n                            # Replace the color in the output grid\n                            output_grid[px_r, px_c] = replacement_color\n                # else: source coordinate is out of bounds. This indicates an issue\n                #       either with anchor finding or template grid calculation.\n                #       Silently ignore for now, or could raise an error/warning.\n\n    # 8. Return Result\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19421,
    "candidates_token_count": 2516,
    "total_token_count": 21937,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.874944,
  "retries": null
}