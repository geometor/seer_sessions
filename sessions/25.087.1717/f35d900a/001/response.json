{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on the positions and colors of four 'seed' pixels.\n\nThe transformation involves:\n1. Identifying four non-white seed pixels in the input grid.\n2. Sorting these seeds first by row index, then by column index, forming two pairs: \n   a top pair (seeds 1 and 2) and a bottom pair (seeds 3 and 4).\n3. For each seed, drawing a 3x3 square in the output grid centered at the seed's location. \n   The center pixel of the square takes the seed's original color, while the 8 surrounding \n   pixels take the color of the *other* seed within the same pair.\n4. Drawing grey (color 5) connector pixels between the generated squares:\n   a. Horizontally between the squares of the top pair and between the squares of the bottom pair. \n      Connectors are placed 2 pixels inwards from the center of each square along their shared row. \n      If the horizontal distance between the centers is 7 or more, additional connectors are placed \n      4 pixels inwards.\n   b. Vertically between the corresponding left squares (from the top and bottom pairs) and \n      between the corresponding right squares. Connectors are placed 2 pixels inwards from the \n      center of each square along their shared column. If the vertical distance between the \n      centers is 7 or more, additional connectors are placed 4 pixels inwards.\n\"\"\"\n\ndef find_seeds(grid):\n    \"\"\"Finds all non-white pixels (seeds) in the grid.\"\"\"\n    seeds = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                seeds.append({'row': r, 'col': c, 'color': grid[r, c]})\n    # Sort by row, then by column\n    seeds.sort(key=lambda s: (s['row'], s['col']))\n    return seeds\n\ndef draw_square(grid, center_r, center_c, center_color, surround_color):\n    \"\"\"Draws a 3x3 square on the grid centered at (center_r, center_c).\"\"\"\n    rows, cols = grid.shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            r, c = center_r + dr, center_c + dc\n            # Check boundaries\n            if 0 <= r < rows and 0 <= c < cols:\n                if dr == 0 and dc == 0:\n                    grid[r, c] = center_color\n                else:\n                    grid[r, c] = surround_color\n\ndef set_pixel_safe(grid, r, c, color):\n    \"\"\"Safely sets a pixel color, checking boundaries.\"\"\"\n    rows, cols = grid.shape\n    if 0 <= r < rows and 0 <= c < cols:\n        grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np) # Initialize with white (0)\n\n    # 1. Find and sort seeds\n    seeds = find_seeds(input_np)\n    if len(seeds) != 4:\n        # Handle unexpected number of seeds if necessary, maybe return input or empty\n        print(f\"Warning: Expected 4 seeds, found {len(seeds)}. Returning empty grid.\")\n        return output_grid.tolist() \n        \n    s1, s2, s3, s4 = seeds\n\n    # 2. Draw the 3x3 squares\n    # Pair 1 (Top: s1, s2)\n    draw_square(output_grid, s1['row'], s1['col'], s1['color'], s2['color'])\n    draw_square(output_grid, s2['row'], s2['col'], s2['color'], s1['color'])\n    # Pair 2 (Bottom: s3, s4)\n    draw_square(output_grid, s3['row'], s3['col'], s3['color'], s4['color'])\n    draw_square(output_grid, s4['row'], s4['col'], s4['color'], s3['color'])\n\n    # 3. Draw grey connectors\n    grey_color = 5\n\n    # Horizontal connectors - Pair 1\n    dist_h1 = abs(s2['col'] - s1['col'])\n    set_pixel_safe(output_grid, s1['row'], s1['col'] + 2, grey_color)\n    set_pixel_safe(output_grid, s2['row'], s2['col'] - 2, grey_color)\n    if dist_h1 >= 7:\n        set_pixel_safe(output_grid, s1['row'], s1['col'] + 4, grey_color)\n        set_pixel_safe(output_grid, s2['row'], s2['col'] - 4, grey_color)\n        \n    # Horizontal connectors - Pair 2\n    dist_h2 = abs(s4['col'] - s3['col'])\n    set_pixel_safe(output_grid, s3['row'], s3['col'] + 2, grey_color)\n    set_pixel_safe(output_grid, s4['row'], s4['col'] - 2, grey_color)\n    if dist_h2 >= 7:\n        set_pixel_safe(output_grid, s3['row'], s3['col'] + 4, grey_color)\n        set_pixel_safe(output_grid, s4['row'], s4['col'] - 4, grey_color)\n\n    # Vertical connectors - Left Side (s1, s3)\n    dist_v1 = abs(s3['row'] - s1['row'])\n    set_pixel_safe(output_grid, s1['row'] + 2, s1['col'], grey_color)\n    set_pixel_safe(output_grid, s3['row'] - 2, s3['col'], grey_color) # s1['col'] == s3['col']\n    if dist_v1 >= 7:\n        set_pixel_safe(output_grid, s1['row'] + 4, s1['col'], grey_color)\n        set_pixel_safe(output_grid, s3['row'] - 4, s3['col'], grey_color)\n\n    # Vertical connectors - Right Side (s2, s4)\n    dist_v2 = abs(s4['row'] - s2['row']) # s4['row'] == s3['row'], s2['row'] == s1['row']\n    set_pixel_safe(output_grid, s2['row'] + 2, s2['col'], grey_color) \n    set_pixel_safe(output_grid, s4['row'] - 2, s4['col'], grey_color) # s2['col'] == s4['col']\n    if dist_v2 >= 7:\n        set_pixel_safe(output_grid, s2['row'] + 4, s2['col'], grey_color)\n        set_pixel_safe(output_grid, s4['row'] - 4, s4['col'], grey_color)\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6971,
    "candidates_token_count": 1755,
    "total_token_count": 8726,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.257292,
  "retries": null
}