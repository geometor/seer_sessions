{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a single \"source object\" (pixels with color > 1) in the input grid.\nDetermines the color and the row/column indices occupied by this source object.\nCreates an output grid by copying the input grid.\nIterates through the grid: if a pixel has the background pattern color (blue, 1) \nand its row or column index matches one of the source object's indices, \nchanges that pixel's color in the output grid to the source object's color.\nWhite (0) pixels and the original source object pixels remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_source_object(grid):\n    \"\"\"\n    Finds the color and coordinates of the first pixel belonging to the source object.\n    Assumes there is exactly one source object (color > 1).\n    Then finds all coordinates belonging to this source object.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (source_color, source_coords)\n               source_color (int): The color of the source object.\n               source_coords (list): A list of (row, col) tuples for all pixels of the source object.\n               Returns (None, []) if no source object is found.\n    \"\"\"\n    height, width = grid.shape\n    source_color = None\n    start_coord = None\n    visited = set()\n    source_coords = []\n\n    # Find the first pixel of the source object to get its color\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] > 1:\n                source_color = grid[r, c]\n                start_coord = (r, c)\n                break\n        if start_coord:\n            break\n\n    if start_coord is None:\n        return None, [] # No source object found\n\n    # Use BFS to find all connected pixels of the source color\n    q = deque([start_coord])\n    visited.add(start_coord)\n    source_coords.append(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds and if it's the correct color and not visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == source_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                source_coords.append((nr, nc))\n                \n    # Alternative simpler approach if contiguity isn't strictly required by the logic (only color matters)\n    # source_coords = []\n    # for r in range(height):\n    #     for c in range(width):\n    #          if grid[r, c] == source_color:\n    #              source_coords.append((r, c))\n\n    return source_color, source_coords\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid based on the propagation rule.\n\n    1. Finds the source object (color > 1).\n    2. Gets its color and the rows/columns it occupies.\n    3. Copies the input grid.\n    4. Replaces blue (1) pixels in the copied grid with the source color \n       if they share a row or column with the source object.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Find the source object's color and coordinates\n    # Note: Using the simpler approach first, assuming only color matters for location ID\n    source_color = None\n    source_coords = []\n    for r in range(height):\n        for c in range(width):\n            pixel_color = input_grid[r, c]\n            if pixel_color > 1: # Found a pixel of the source object\n                if source_color is None:\n                    source_color = pixel_color\n                # Collect all coordinates of this color, assuming only one source color exists\n                if pixel_color == source_color:\n                     source_coords.append((r, c))\n\n    # Handle case where no source object is found (return original grid)\n    if source_color is None:\n        return output_grid\n\n    # Determine the unique rows and columns occupied by the source object\n    source_rows = set(r for r, c in source_coords)\n    source_cols = set(c for r, c in source_coords)\n\n    # Iterate through the grid and apply the transformation\n    for r in range(height):\n        for c in range(width):\n            # Check if the pixel is blue (1)\n            if input_grid[r, c] == 1:\n                # Check if the pixel's row OR column is in the source object's occupied rows/columns\n                if r in source_rows or c in source_cols:\n                    # Change the pixel in the output grid to the source color\n                    output_grid[r, c] = source_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5322,
    "candidates_token_count": 1286,
    "total_token_count": 6608,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.871305,
  "retries": null
}