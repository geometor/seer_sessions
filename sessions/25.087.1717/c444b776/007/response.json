{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a single horizontal (hr) or vertical (vc) line composed entirely of yellow (4) pixels.\nPerforms a transformation (reflection or copy) based on the line type and the location of non-background (0), non-yellow (4) 'pattern' pixels relative to the line.\nVertical line reflection takes precedence over horizontal line copying.\n\n1. Vertical Reflection (Priority):\n   - If a vertical yellow line `vc` exists:\n     - If ALL pattern pixels are to the left (column < vc):\n       Reflect the entire region left of `vc` (all rows, columns 0 to vc-1) horizontally across `vc`.\n       A pixel at `(r, c)` is reflected to `(r, vc + (vc - c))`.\n     - Else if ALL pattern pixels are to the right (column > vc):\n       Reflect the entire region right of `vc` (all rows, columns vc+1 to width-1) horizontally across `vc`.\n       A pixel at `(r, c)` is reflected to `(r, vc - (c - vc))`.\n\n2. Horizontal Copy (Fallback):\n   - Else if a horizontal yellow line `hr` exists (and vertical reflection conditions were not met):\n     - If ALL pattern pixels are above (row < hr):\n       Copy the entire region above `hr` (all columns, rows 0 to hr-1) vertically to the area below `hr`, starting at row `hr+1`.\n       A pixel at `(r, c)` is copied to `(hr + 1 + r, c)`.\n     - Else if ALL pattern pixels are below (row > hr):\n       Copy the entire region below `hr` (all columns, rows hr+1 to height-1) vertically to the area above `hr`, starting at row `hr-1` and going upwards.\n       A pixel at `(r, c)` is copied to `(hr - 1 - (r - (hr + 1)), c)` which simplifies to `(2*hr - r, c)`.\n\n3. No Applicable Transformation:\n   - If no yellow line exists, or if pattern pixels exist but do not meet the positional criteria (e.g., on both sides of a line), the grid remains unchanged.\n\nThe yellow lines themselves and the original source pattern(s) are preserved in the output.\nThe transformation overwrites pixels in the destination area.\n\"\"\"\n\ndef find_horizontal_line(grid):\n    \"\"\"Finds the row index of the first complete horizontal line of yellow pixels.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        if np.all(grid[r, :] == 4):\n            return r\n    return None\n\ndef find_vertical_line(grid):\n    \"\"\"Finds the column index of the first complete vertical line of yellow pixels.\"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        if np.all(grid[:, c] == 4):\n            return c\n    return None\n\ndef find_pattern_pixels(grid):\n    \"\"\"Finds coordinates of all non-background (0) and non-yellow (4) pixels.\"\"\"\n    pattern_pixels = np.argwhere((grid != 0) & (grid != 4))\n    return pattern_pixels # Returns array of [row, col] pairs\n\ndef transform(input_grid):\n    \"\"\"\n    Applies reflection or copy based on yellow lines and pattern location.\n    \"\"\"\n    # Convert input list of lists to a NumPy array\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(grid_np)\n\n    # Find potential yellow lines\n    hr = find_horizontal_line(grid_np)\n    vc = find_vertical_line(grid_np)\n\n    # Find pattern pixels (non-background, non-yellow)\n    pattern_pixels = find_pattern_pixels(grid_np)\n\n    # If there are no pattern pixels, no transformation is needed\n    if len(pattern_pixels) == 0:\n        return output_grid.tolist()\n\n    # --- Apply transformation logic (Vertical has priority) ---\n\n    # 1. Check Vertical Reflection\n    if vc is not None:\n        pattern_cols = pattern_pixels[:, 1]\n        # Check if all pattern pixels are to the left\n        if np.all(pattern_cols < vc):\n            # Reflect left region to right\n            for r in range(height):\n                for c in range(vc): # Iterate columns left of the line\n                    reflected_c = vc + (vc - c)\n                    if 0 <= reflected_c < width: # Check bounds\n                        output_grid[r, reflected_c] = grid_np[r, c]\n            return output_grid.tolist() # Transformation done\n        # Check if all pattern pixels are to the right\n        elif np.all(pattern_cols > vc):\n            # Reflect right region to left\n            for r in range(height):\n                for c in range(vc + 1, width): # Iterate columns right of the line\n                    reflected_c = vc - (c - vc)\n                    if 0 <= reflected_c < width: # Check bounds\n                         output_grid[r, reflected_c] = grid_np[r, c]\n            return output_grid.tolist() # Transformation done\n\n    # 2. Check Horizontal Copy (Fallback)\n    if hr is not None:\n        pattern_rows = pattern_pixels[:, 0]\n        # Check if all pattern pixels are above\n        if np.all(pattern_rows < hr):\n             # Copy region above to below\n            for r in range(hr): # Iterate rows above the line (0 to hr-1)\n                source_r = r\n                dest_r = hr + 1 + r # Destination row starts at hr+1\n                if 0 <= dest_r < height: # Check bounds\n                    output_grid[dest_r, :] = grid_np[source_r, :]\n            return output_grid.tolist() # Transformation done\n        # Check if all pattern pixels are below\n        elif np.all(pattern_rows > hr):\n            # Copy region below to above\n            for source_r in range(hr + 1, height): # Iterate rows below the line\n                # dest_r = hr - 1 - (source_r - (hr + 1)) # Calculate destination row upwards from hr-1\n                dest_r = 2 * hr - source_r # Simplified calculation\n                if 0 <= dest_r < height: # Check bounds\n                    output_grid[dest_r, :] = grid_np[source_r, :]\n            return output_grid.tolist() # Transformation done\n\n    # 3. No Applicable Transformation\n    # If none of the conditions above were met and triggered a return,\n    # return the initial grid copy unchanged.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11816,
    "candidates_token_count": 1590,
    "total_token_count": 13406,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.473394,
  "retries": null
}