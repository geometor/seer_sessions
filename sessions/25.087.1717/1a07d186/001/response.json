{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\n1.  Identify static elements: Horizontal and vertical lines (contiguous segments of 2+ identical non-white pixels) and the white background. These remain unchanged in the output.\n2.  Identify agent elements: Single non-white pixels that are not part of any identified line.\n3.  For each agent pixel:\n    a.  Find all lines in the grid that have the same color as the agent.\n    b.  If no same-colored line exists, the agent is removed (becomes white) in the output.\n    c.  If same-colored lines exist, find the nearest one based on perpendicular distance.\n    d.  Calculate the target position, which is one step away from the nearest line, on the same side as the agent's original position.\n    e.  Check the path: Examine all grid cells strictly between the agent's original position and the target position.\n    f.  If this path intersects *any* pixel belonging to *any* identified line, the agent is removed (becomes white).\n    g.  If the path is clear, the agent is moved to the target position in the output grid. Original agent positions are cleared (set to white) unless overwritten by another moved agent.\n4.  The final output grid contains the static lines and the agents in their new positions (or removed).\n\"\"\"\n\ndef _find_lines_and_agents(grid):\n    \"\"\"Identifies lines and agent pixels in the grid.\"\"\"\n    height, width = grid.shape\n    lines = []\n    line_coords = set()\n    \n    # Find horizontal lines\n    for r in range(height):\n        start_col = -1\n        current_color = -1\n        for c in range(width):\n            pixel = grid[r, c]\n            if pixel != 0:\n                if start_col == -1: # Start of a potential line\n                    start_col = c\n                    current_color = pixel\n                elif pixel != current_color: # End of line (different color)\n                    if c - start_col >= 2:\n                        lines.append({'color': current_color, 'orientation': 'h', 'row': r, 'start': start_col, 'end': c - 1})\n                        for i in range(start_col, c):\n                           line_coords.add((r, i))\n                    start_col = c # Start new potential line\n                    current_color = pixel\n            elif start_col != -1: # End of line (white pixel)\n                 if c - start_col >= 2:\n                     lines.append({'color': current_color, 'orientation': 'h', 'row': r, 'start': start_col, 'end': c - 1})\n                     for i in range(start_col, c):\n                        line_coords.add((r, i))\n                 start_col = -1\n                 current_color = -1\n        # Check for line ending at the edge\n        if start_col != -1 and width - start_col >= 2:\n            lines.append({'color': current_color, 'orientation': 'h', 'row': r, 'start': start_col, 'end': width - 1})\n            for i in range(start_col, width):\n               line_coords.add((r, i))\n\n    # Find vertical lines\n    for c in range(width):\n        start_row = -1\n        current_color = -1\n        for r in range(height):\n            pixel = grid[r, c]\n            if pixel != 0:\n                if start_row == -1: # Start of a potential line\n                    start_row = r\n                    current_color = pixel\n                elif pixel != current_color: # End of line (different color)\n                    if r - start_row >= 2:\n                         lines.append({'color': current_color, 'orientation': 'v', 'col': c, 'start': start_row, 'end': r - 1})\n                         for i in range(start_row, r):\n                            # Avoid adding coords twice if part of H and V line\n                            line_coords.add((i, c)) \n                    start_row = r # Start new potential line\n                    current_color = pixel\n            elif start_row != -1: # End of line (white pixel)\n                 if r - start_row >= 2:\n                     lines.append({'color': current_color, 'orientation': 'v', 'col': c, 'start': start_row, 'end': r - 1})\n                     for i in range(start_row, r):\n                        line_coords.add((i, c))\n                 start_row = -1\n                 current_color = -1\n        # Check for line ending at the edge\n        if start_row != -1 and height - start_row >= 2:\n             lines.append({'color': current_color, 'orientation': 'v', 'col': c, 'start': start_row, 'end': height - 1})\n             for i in range(start_row, height):\n                line_coords.add((i, c))\n\n    # Find agents (single non-white pixels not in line_coords)\n    agents = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and (r, c) not in line_coords:\n                agents.append({'color': grid[r, c], 'r': r, 'c': c})\n\n    return lines, agents, line_coords\n\ndef _is_path_blocked(start_pos, end_pos, line_coords):\n    \"\"\"Checks if the path between start and end (exclusive) intersects any line coords.\"\"\"\n    r_start, c_start = start_pos\n    r_end, c_end = end_pos\n    \n    # Vertical movement\n    if c_start == c_end:\n        r_min = min(r_start, r_end)\n        r_max = max(r_start, r_end)\n        for r in range(r_min + 1, r_max):\n            if (r, c_start) in line_coords:\n                return True\n    # Horizontal movement\n    elif r_start == r_end:\n        c_min = min(c_start, c_end)\n        c_max = max(c_start, c_end)\n        for c in range(c_min + 1, c_max):\n             if (r_start, c) in line_coords:\n                return True\n    # Diagonal or other movement (not expected by rules, but check anyway)\n    else:\n        # This scenario shouldn't occur based on the perpendicular movement rule.\n        # If it did, we'd need a line-drawing algorithm (like Bresenham's)\n        # to check intermediate points. Assuming only H/V movement.\n        pass \n        \n    return False\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Moves single pixels towards the nearest line of the same color, stopping one step away,\n    unless the path is blocked by any line or no same-colored line exists.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = input_grid.copy()\n    height, width = output_grid.shape\n\n    # 1. Identify lines, agents, and coordinates belonging to lines\n    lines, agents, line_coords = _find_lines_and_agents(input_grid)\n\n    # 2. Temporarily remove agents from the output grid\n    for agent in agents:\n        output_grid[agent['r'], agent['c']] = 0\n\n    # 3. Process each agent\n    for agent in agents:\n        agent_color = agent['color']\n        agent_r, agent_c = agent['r'], agent['c']\n\n        # a. Find matching lines\n        matching_lines = [line for line in lines if line['color'] == agent_color]\n\n        # b. If no matching line, agent stays removed (already set to 0)\n        if not matching_lines:\n            continue\n\n        # c. Find the nearest matching line\n        nearest_line = None\n        min_dist = float('inf')\n\n        for line in matching_lines:\n            dist = -1\n            if line['orientation'] == 'h':\n                # Check if agent's column is within the line's horizontal span\n                if line['start'] <= agent_c <= line['end']:\n                    dist = abs(agent_r - line['row'])\n                else: # Need distance to closest endpoint column-wise AND row-wise\n                    # This seems overly complex and likely not intended by ARC rules.\n                    # Let's stick to perpendicular distance first.\n                    # Revisit if examples fail.\n                    # Simple perpendicular distance:\n                    dist = abs(agent_r - line['row'])\n\n            elif line['orientation'] == 'v':\n                 # Check if agent's row is within the line's vertical span\n                if line['start'] <= agent_r <= line['end']:\n                    dist = abs(agent_c - line['col'])\n                else: # As above, stick to perpendicular\n                    dist = abs(agent_c - line['col'])\n            \n            # Update nearest line if this one is closer\n            # Simple tie-breaking: prefer horizontal, then lower index if still tied (implicit in iteration order)\n            if dist >= 0 and dist < min_dist:\n                min_dist = dist\n                nearest_line = line\n            elif dist == min_dist:\n                 # Prioritize horizontal over vertical if distances are equal? Let's try this.\n                 if nearest_line and nearest_line['orientation'] == 'v' and line['orientation'] == 'h':\n                     nearest_line = line\n                 # Otherwise, keep the first one found (implicit)\n\n        # If a nearest line was found (should always happen if matching_lines is not empty)\n        if nearest_line:\n            # d. Calculate target position\n            target_r, target_c = -1, -1\n            if nearest_line['orientation'] == 'h':\n                target_c = agent_c\n                line_row = nearest_line['row']\n                if agent_r < line_row:\n                    target_r = line_row - 1\n                else: # agent_r > line_row (cannot be equal, agent isn't *on* line)\n                    target_r = line_row + 1\n            elif nearest_line['orientation'] == 'v':\n                target_r = agent_r\n                line_col = nearest_line['col']\n                if agent_c < line_col:\n                    target_c = line_col - 1\n                else: # agent_c > line_col\n                    target_c = line_col + 1\n\n            # Ensure target is within bounds (should be if lines are)\n            if 0 <= target_r < height and 0 <= target_c < width:\n                # e. Check path for blockage by ANY line\n                path_blocked = _is_path_blocked((agent_r, agent_c), (target_r, target_c), line_coords)\n\n                # f/g. Place agent if path is clear\n                if not path_blocked:\n                    output_grid[target_r, target_c] = agent_color\n            # else: target is out of bounds, agent is removed (remains 0)\n        # else: agent is removed (remains 0) - this case handled by empty matching_lines check\n\n    # 4. Return the final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5618,
    "candidates_token_count": 2680,
    "total_token_count": 8298,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.820758,
  "retries": null
}