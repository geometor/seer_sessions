{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nGenerates a repeating line pattern (horizontal or vertical) based on the \nlocation and color of two initial non-white pixels.\n\n1. Find the coordinates and colors of the two non-white pixels.\n2. Determine the primary axis (row-wise or column-wise) for the pattern based \n   on the relative row and column distances between the two pixels.\n   - If column difference is 0, axis is row-wise.\n   - Else if row difference is 0, axis is column-wise.\n   - Else if column difference >= row difference, axis is row-wise.\n   - Otherwise, axis is column-wise.\n3. Sort the pixels based on their index along the chosen axis (smaller index first). \n   Let the first pixel be P1 (color C1, index I1) and the second be P2 (color C2, index I2).\n4. Calculate the pattern cycle length L = I2 - I1 + 1.\n5. Create an output grid of the same dimensions as the input, filled with white (0).\n6. If the axis is row-wise, iterate rows 'r' from I1 downwards.\n   - Fill row 'r' with C1 if (r - I1) % L == 0.\n   - Fill row 'r' with C2 if (r - I1) % L == L - 1.\n7. If the axis is column-wise, iterate columns 'c' from I1 rightwards.\n   - Fill column 'c' with C1 if (c - I1) % L == 0.\n   - Fill column 'c' with C2 if (c - I1) % L == L - 1.\n8. Return the resulting grid.\n\"\"\"\n\ndef find_non_white_pixels(grid):\n    \"\"\"Finds coordinates and colors of non-white pixels.\"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append({'row': r, 'col': c, 'color': grid[r, c]})\n    # Expecting exactly two pixels based on examples\n    if len(pixels) != 2:\n        # This case might need specific handling if inputs can vary\n        # For now, assume exactly two as per the training data pattern\n        print(f\"Warning: Expected 2 non-white pixels, found {len(pixels)}\")\n        # Returning first two found if more exist, or fewer if less exist.\n        # Error handling might be needed for robust solution.\n        pass \n    return pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by creating a repeating line pattern based on two pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 1. Find the two non-white pixels\n    pixels = find_non_white_pixels(input_np)\n    if len(pixels) != 2:\n         # If not exactly two pixels, return the empty grid or handle error\n         # Based on training data, we expect exactly two.\n         print(\"Error: Did not find exactly two non-white pixels.\")\n         return output_grid.tolist() # Return empty grid\n\n    p1 = pixels[0]\n    p2 = pixels[1]\n\n    # 2. Calculate differences\n    row_diff = abs(p1['row'] - p2['row'])\n    col_diff = abs(p1['col'] - p2['col'])\n\n    # 3. Determine axis and sort pixels\n    axis = None\n    # Special case: points are in the same column\n    if p1['col'] == p2['col']:\n         axis = 'row'\n    # Special case: points are in the same row\n    elif p1['row'] == p2['row']:\n         axis = 'col'\n    # General case: compare row and column differences\n    elif col_diff >= row_diff:\n        axis = 'row'\n    else: # col_diff < row_diff\n        axis = 'col'\n\n    # Sort pixels based on the determined axis index\n    if axis == 'row':\n        if p1['row'] <= p2['row']:\n            first_pixel = p1\n            second_pixel = p2\n        else:\n            first_pixel = p2\n            second_pixel = p1\n        idx1 = first_pixel['row']\n        idx2 = second_pixel['row']\n    else: # axis == 'col'\n        if p1['col'] <= p2['col']:\n            first_pixel = p1\n            second_pixel = p2\n        else:\n            first_pixel = p2\n            second_pixel = p1\n        idx1 = first_pixel['col']\n        idx2 = second_pixel['col']\n        \n    color1 = first_pixel['color']\n    color2 = second_pixel['color']\n\n    # 4. Calculate pattern cycle length\n    # +1 because the range includes both start and end indices\n    cycle_len = idx2 - idx1 + 1\n    \n    # Prevent division by zero if pixels are the same (cycle_len=1)\n    if cycle_len <= 0: \n        print(\"Error: Pixels have invalid indices or cycle length.\")\n        return output_grid.tolist() # Return empty grid\n\n    # 6. & 7. Fill the output grid based on the axis and pattern\n    if axis == 'row':\n        # Iterate through rows starting from the first pixel's row index\n        for r in range(idx1, height):\n            # Determine position in the cycle\n            pattern_pos = (r - idx1) % cycle_len\n            # Fill row with color1 if at the start of the cycle\n            if pattern_pos == 0:\n                output_grid[r, :] = color1\n            # Fill row with color2 if at the position corresponding to the second pixel\n            elif pattern_pos == cycle_len - 1: # which is (idx2 - idx1) % cycle_len\n                output_grid[r, :] = color2\n    else: # axis == 'col'\n        # Iterate through columns starting from the first pixel's column index\n        for c in range(idx1, width):\n            # Determine position in the cycle\n            pattern_pos = (c - idx1) % cycle_len\n            # Fill column with color1 if at the start of the cycle\n            if pattern_pos == 0:\n                output_grid[:, c] = color1\n            # Fill column with color2 if at the position corresponding to the second pixel\n            elif pattern_pos == cycle_len - 1: # which is (idx2 - idx1) % cycle_len\n                output_grid[:, c] = color2\n\n    # Convert back to list of lists for the ARC standard format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6834,
    "candidates_token_count": 1626,
    "total_token_count": 8460,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.690417,
  "retries": null
}