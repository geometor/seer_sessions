{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nGenerates a repeating line pattern (horizontal or vertical) based on the \nlocation and color of two initial non-white pixels.\n\n1. Find the coordinates and colors of the two non-white pixels.\n2. Determine the primary axis ('row' or 'col') for the pattern based \n   on the relative row and column distances between the two pixels.\n   - If column difference is 0, axis is 'row'.\n   - Else if row difference is 0, axis is 'col'.\n   - Else if column difference >= row difference, axis is 'row'.\n   - Otherwise, axis is 'col'.\n3. Sort the pixels based on their index along the chosen axis (smaller index first). \n   Let the first pixel be P1 (color C1, index idx1) and the second be P2 (color C2, index idx2).\n4. Calculate the pattern cycle length L = (idx2 - idx1) * 2. Handle the edge case L=0 by setting L=1 (though not expected based on examples where idx1 != idx2).\n5. Create an output grid of the same dimensions as the input, filled with white (0).\n6. Fill the output grid based on the axis and pattern:\n   - Iterate through indices 'i' from the starting index of P1 (idx1) up to the grid boundary along the determined axis. If (i - idx1) is divisible by L, fill the corresponding row/column 'i' with color C1.\n   - Iterate through indices 'i' from the starting index of P2 (idx2) up to the grid boundary along the determined axis. If (i - idx2) is divisible by L, fill the corresponding row/column 'i' with color C2.\n7. Return the resulting grid.\n\"\"\"\n\ndef find_non_white_pixels(grid):\n    \"\"\"Finds coordinates and colors of non-white pixels.\"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                pixels.append({'row': r, 'col': c, 'color': grid[r, c]})\n    # Expecting exactly two pixels based on examples\n    if len(pixels) != 2:\n        # This case might need specific handling if inputs can vary\n        # For now, assume exactly two as per the training data pattern\n        print(f\"Warning/Error: Expected 2 non-white pixels, found {len(pixels)}\")\n        pass # Let the main function handle the list length\n    return pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by creating a repeating line pattern based on two pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # 1. Find the two non-white pixels\n    pixels = find_non_white_pixels(input_np)\n    \n    # Initialize output grid with white (0) - return if pixel condition not met\n    output_grid = np.zeros_like(input_np)\n    if len(pixels) != 2:\n         print(\"Error: Did not find exactly two non-white pixels. Returning empty grid.\")\n         return output_grid.tolist() # Return empty grid\n\n    p_a = pixels[0]\n    p_b = pixels[1]\n\n    # 2. Calculate differences and determine axis\n    row_diff = abs(p_a['row'] - p_b['row'])\n    col_diff = abs(p_a['col'] - p_b['col'])\n\n    axis = None\n    # Special case: points are in the same column\n    if col_diff == 0:\n         axis = 'row'\n    # Special case: points are in the same row\n    elif row_diff == 0:\n         axis = 'col'\n    # General case: compare row and column differences\n    elif col_diff >= row_diff:\n        axis = 'row'\n    else: # col_diff < row_diff\n        axis = 'col'\n\n    # 3. Sort pixels based on the determined axis index\n    if axis == 'row':\n        key = 'row'\n    else: # axis == 'col'\n        key = 'col'\n        \n    if p_a[key] <= p_b[key]:\n        p1 = p_a\n        p2 = p_b\n    else:\n        p1 = p_b\n        p2 = p_a\n        \n    idx1 = p1[key]\n    idx2 = p2[key]\n    color1 = p1['color']\n    color2 = p2['color']\n\n    # 4. Calculate pattern cycle length\n    # L is double the distance between the indices along the axis.\n    cycle_len = (idx2 - idx1) * 2\n    \n    # Handle edge case where pixels might have the same index (L=0)\n    # This shouldn't happen if pixels are distinct, but as a safeguard:\n    if cycle_len <= 0: \n        # If indices are the same, L becomes 0. What should happen?\n        # Maybe fill only the line at idx1 with both colors? Or just color1?\n        # Let's assume this means the pattern doesn't repeat, just draw the initial lines.\n        # Set L=1 to prevent division by zero, but this might not be the correct logic for L=0.\n        # Revisit if examples show this case. For now, printing a warning.\n        print(f\"Warning: Cycle length calculated as {cycle_len}. Setting to 1. Check logic if this occurs.\")\n        cycle_len = 1 # Avoid division by zero, allows initial lines to be drawn.\n\n    # 5. Initialize output grid (done earlier)\n\n    # 6. Fill the output grid based on the axis and pattern\n    if axis == 'row':\n        # Fill for color1\n        for r in range(idx1, height):\n            # Check if the current row index 'r' is a multiple of L steps away from idx1\n            if (r - idx1) % cycle_len == 0:\n                output_grid[r, :] = color1\n        # Fill for color2\n        for r in range(idx2, height):\n            # Check if the current row index 'r' is a multiple of L steps away from idx2\n            if (r - idx2) % cycle_len == 0:\n                output_grid[r, :] = color2\n    else: # axis == 'col'\n        # Fill for color1\n        for c in range(idx1, width):\n             # Check if the current col index 'c' is a multiple of L steps away from idx1\n            if (c - idx1) % cycle_len == 0:\n                output_grid[:, c] = color1\n        # Fill for color2\n        for c in range(idx2, width):\n             # Check if the current col index 'c' is a multiple of L steps away from idx2\n            if (c - idx2) % cycle_len == 0:\n                output_grid[:, c] = color2\n\n    # 7. Convert back to list of lists for the ARC standard format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12008,
    "candidates_token_count": 1678,
    "total_token_count": 13686,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.247715,
  "retries": null
}