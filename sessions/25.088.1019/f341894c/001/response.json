{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_adjacent_pairs(grid, color1, color2):\n    \"\"\"\n    Finds all unique pairs of adjacent cells with specified colors.\n    Checks right and down neighbors only to avoid duplicates.\n    Returns a list of pairs of coordinates: [((r1, c1), (r2, c2)), ...].\n    \"\"\"\n    pairs = []\n    height, width = grid.shape\n    processed = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if processed[r, c]:\n                continue\n\n            current_color = grid[r, c]\n\n            # Check right neighbor\n            if c + 1 < width:\n                right_neighbor_color = grid[r, c + 1]\n                if not processed[r, c + 1]:\n                    if (current_color == color1 and right_neighbor_color == color2) or \\\n                       (current_color == color2 and right_neighbor_color == color1):\n                        pairs.append(((r, c), (r, c + 1)))\n                        processed[r, c] = True\n                        processed[r, c + 1] = True\n                        continue # Move to next cell once paired\n\n            # Check down neighbor (only if not already paired horizontally)\n            if r + 1 < height:\n                down_neighbor_color = grid[r + 1, c]\n                if not processed[r + 1, c]:\n                     if (current_color == color1 and down_neighbor_color == color2) or \\\n                        (current_color == color2 and down_neighbor_color == color1):\n                        pairs.append(((r, c), (r + 1, c)))\n                        processed[r, c] = True\n                        processed[r + 1, c] = True\n                        continue # Move to next cell once paired\n            \n            # Mark as processed even if no pair found starting here\n            # This isn't strictly necessary with the continue statements, \n            # but doesn't hurt. The key is marking pairs as processed.\n            # processed[r, c] = True \n\n    return pairs\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping the positions of adjacent blue (1) and magenta (6) pixels.\n    All other pixels remain unchanged.\n    The adjacency considered is horizontal (left-right) and vertical (up-down).\n    Each pair of adjacent blue and magenta pixels swaps exactly once.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Create a copy of the input grid to modify\n    output_grid = input_array.copy()\n    \n    # Define the colors to swap\n    color1 = 1 # blue\n    color2 = 6 # magenta\n    \n    # Find all adjacent pairs of color1 and color2\n    # Using a helper function that prevents double counting/processing\n    # Note: The original find_adjacent_pairs had a slight logic flaw.\n    # A simpler approach is to iterate and swap directly in the output grid,\n    # using a processed marker to avoid double swaps. Let's use that instead.\n\n    height, width = input_array.shape\n    processed = np.zeros_like(input_array, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            # Skip if this cell was already part of a swap\n            if processed[r, c]:\n                continue\n\n            current_color = input_array[r, c]\n\n            # Check only if the current cell is one of the colors of interest\n            if current_color == color1 or current_color == color2:\n                # Check right neighbor\n                if c + 1 < width and not processed[r, c + 1]:\n                    right_neighbor_color = input_array[r, c + 1]\n                    if (current_color == color1 and right_neighbor_color == color2) or \\\n                       (current_color == color2 and right_neighbor_color == color1):\n                        # Perform swap in the output grid\n                        output_grid[r, c] = right_neighbor_color\n                        output_grid[r, c + 1] = current_color\n                        # Mark both cells as processed\n                        processed[r, c] = True\n                        processed[r, c + 1] = True\n                        # Move to the next cell in the main loop\n                        continue \n\n                # Check down neighbor (only if not already swapped horizontally)\n                if r + 1 < height and not processed[r + 1, c]:\n                    down_neighbor_color = input_array[r + 1, c]\n                    if (current_color == color1 and down_neighbor_color == color2) or \\\n                       (current_color == color2 and down_neighbor_color == color1):\n                         # Perform swap in the output grid\n                        output_grid[r, c] = down_neighbor_color\n                        output_grid[r + 1, c] = current_color\n                        # Mark both cells as processed\n                        processed[r, c] = True\n                        processed[r + 1, c] = True\n                        # Move to the next cell in the main loop\n                        continue\n            \n            # No swap initiated from this cell, mark as processed (optional but clarifies)\n            # processed[r, c] = True # This line is not strictly needed due to the continue statements\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2546,
    "candidates_token_count": 1290,
    "total_token_count": 3836,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.745332,
  "retries": null
}