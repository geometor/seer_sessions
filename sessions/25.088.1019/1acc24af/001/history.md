
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0 1 1 1 0
0 0 1 0 0 1 0 0 1 0 1 0
1 1 1 0 0 1 1 1 1 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0
0 0 0 5 0 0 5 5 5 0 5 0
5 5 0 5 5 0 5 5 5 0 5 0
5 5 0 0 5 0 0 0 5 0 5 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 0 0 1 1 1 0
0 0 1 0 0 1 0 0 1 0 1 0
1 1 1 0 0 1 1 1 1 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 5 0 0 2 2 2 0 2 0
2 2 0 5 5 0 2 2 2 0 2 0
2 2 0 0 5 0 0 0 2 0 2 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 1 0 0 1 0 0 0 0 0
1 1 1 1 0 0 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0
0 5 5 5 0 5 5 0 5 5 0 0
0 5 5 0 0 5 5 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 1 0 0 1 0 0 0 0 0
1 1 1 1 0 0 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0
0 2 2 2 0 2 2 0 5 5 0 0
0 2 2 0 0 2 2 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 1 1 1 0 0
0 0 1 0 1 1 1 1 0 1 1 0
1 1 1 0 0 1 1 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 5 0 0 5
0 5 0 0 5 5 5 0 5 0 0 5
5 5 5 0 0 5 0 0 5 0 5 5
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 0 0 1 1 1 0 0
0 0 1 0 1 1 1 1 0 1 1 0
1 1 1 0 0 1 1 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 5 0 0 5
0 2 0 0 2 2 2 0 5 0 0 5
2 2 2 0 0 2 0 0 5 0 5 5
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0
0 0 0 0 0 1 0 0 1 0 0 0
1 1 1 1 1 1 0 0 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 5 5 0 5 0 0 0 0 0 0 0
0 5 5 0 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0
0 0 0 0 0 1 0 0 1 0 0 0
1 1 1 1 1 1 0 0 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 2 2 0 5 0 0 0 0 0 0 0
0 2 2 0 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, I will analyze the provided examples to understand the transformation rule.

**Perception of Task Elements:**

1.  **Grid Structure:** The input and output are 2D grids of pixels represented by integers 0-9 (colors). The background is consistently white (0).
2.  **Object Identification:** The grids contain distinct contiguous regions (objects) of non-background colors. Specifically, I observe blue (1) objects and gray (5) objects in the input.
3.  **Transformation Focus:** The primary change between input and output involves the gray (5) objects. Some gray pixels turn into red (2) pixels in the output.
4.  **Consistency:** The blue (1) objects appear completely unchanged in position and color across all examples.
5.  **Selective Change:** Not all gray (5) objects change color. In each example, only one contiguous gray object undergoes a transformation.
6.  **Size Matters:** Comparing the gray objects within each input grid, the object that changes to red (2) appears to be the *largest* gray object in terms of the number of pixels it occupies. Other, smaller gray objects remain unchanged.

**YAML Facts:**


```yaml
task_elements:
  - grid:
      description: A 2D array of pixels with colors 0-9.
      background_color: white (0)
  - objects:
      description: Contiguous areas of the same non-background color.
      types:
        - color: blue (1)
          role: static element, unchanged between input and output.
        - color: gray (5)
          role: dynamic element, potentially transformed.
        - color: red (2)
          role: result of transformation, appears only in output.
  - properties:
      - size:
          description: The number of pixels composing an object.
          relevance: Key factor in determining which gray object is transformed.
      - contiguity:
          description: Pixels are part of the same object if they share an edge (not just a corner). Used to define object boundaries.
  - relationships:
      - comparison: The sizes of all gray objects within an input grid are compared.
  - actions:
      - identify_objects: Find all contiguous groups of gray pixels.
      - calculate_size: Determine the pixel count for each identified gray object.
      - find_largest: Select the gray object with the maximum pixel count.
      - recolor: Change the color of the pixels belonging to the largest gray object from gray (5) to red (2).
      - copy: All other pixels (background, blue objects, smaller gray objects) retain their original color and position.
```


**Natural Language Program:**

1.  **Identify Gray Objects:** Scan the input grid and identify all distinct, contiguous objects composed of gray (5) pixels. Treat pixels connected horizontally or vertically (but not diagonally) as part of the same object.
2.  **Measure Gray Objects:** For each distinct gray object found, calculate its size by counting the number of pixels it contains.
3.  **Select Largest Gray Object:** Compare the sizes of all identified gray objects and determine which object has the largest size (the greatest number of pixels).
4.  **Recolor Largest Object:** Create the output grid as a copy of the input grid. Then, locate all the pixels belonging to the largest gray object (identified in step 3) and change their color from gray (5) to red (2) in the output grid.
5.  **Preserve Others:** Ensure all other pixels in the output grid, including the background (0), blue (1) objects, and any gray (5) objects that were *not* the largest, remain identical to their corresponding pixels in the input grid.
