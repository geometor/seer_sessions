{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nHorizontally shift the single colored object to the left based on its position relative to its bounding box.\n\n1. Find the single connected group of non-white pixels (the \"object\") in the input grid. Record its color. If no object exists, return an empty grid of the same size.\n2. Determine the bounding box of the object, specifically identifying the minimum row index (`min_row`) and minimum column index (`min_col`).\n3. Find the actual top-leftmost pixel of the object. This is the pixel within the object that has the row index `min_row` and the smallest column index among pixels in that row. Let this column index be `top_pixel_col`.\n4. Calculate the horizontal shift amount, `delta_c`, based on the following condition:\n   a. If the object occupies the top-left corner of its bounding box (i.e., if `min_col` is equal to `top_pixel_col`), then the shift amount `delta_c` is equal to `min_col`.\n   b. Otherwise (if `min_col` is less than `top_pixel_col`), the shift amount `delta_c` is calculated as `min_row + (top_pixel_col - min_col)`.\n5. Create a new output grid with the same dimensions as the input grid, filled entirely with the background color (white, 0).\n6. Copy the object onto the output grid by taking each pixel `(r, c)` of the object from the input grid and placing its color at the coordinates `(r, c - delta_c)` in the output grid. Ensure that the destination column `c - delta_c` is not less than 0.\n\"\"\"\n\ndef find_colored_object(grid):\n    \"\"\"\n    Finds the first connected non-background object in the grid using BFS.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - set of (row, col) tuples for the object's pixels.\n        - the color of the object (int).\n        Returns (None, None) if no object is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                object_color = grid[r, c]\n                object_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    object_pixels.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == object_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Found the first (and assumed only) object\n                return object_pixels, object_color\n\n    return None, None # No object found\n\n\ndef get_object_properties(pixels):\n    \"\"\"\n    Calculates bounding box and top-left pixel properties.\n\n    Args:\n        pixels: A set of (row, col) tuples representing the object pixels.\n\n    Returns:\n        A tuple (min_row, min_col, top_pixel_row, top_pixel_col).\n        Returns (None, None, None, None) if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None, None, None, None\n\n    # Find bounding box top-left corner\n    min_row = min(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    \n    # top_pixel_row is the same as min_row by definition of top-leftmost\n    top_pixel_row = min_row \n    \n    # Find the minimum column among pixels *only in the top row*\n    top_pixel_col = min(c for r, c in pixels if r == top_pixel_row)\n\n    return min_row, min_col, top_pixel_row, top_pixel_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by shifting the single colored object left.\n    The shift amount depends on the object's position relative to its bounding box\n    and potentially the top row index of the bounding box.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output_grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # Step 1: Identify the single connected non-white object\n    object_pixels, object_color = find_colored_object(input_np)\n\n    # Handle case where no object is found\n    if object_pixels is None:\n        return output_grid.tolist() # Return background grid\n\n    # Step 2 & 3: Determine bounding box and top-leftmost pixel properties\n    min_row, min_col, top_pixel_row, top_pixel_col = get_object_properties(object_pixels)\n\n    # Step 4: Calculate the horizontal shift amount delta_c\n    if min_col == top_pixel_col:\n        # Case a: Object occupies top-left corner of bounding box\n        delta_c = min_col\n    else:\n        # Case b: Top-left corner of bounding box is empty\n        delta_c = min_row + (top_pixel_col - min_col)\n        \n    # Step 5: Output grid initialized previously.\n\n    # Step 6: Place the shifted object onto the output grid\n    for r, c in object_pixels:\n        # Calculate new position (vertical position unchanged)\n        new_r = r\n        new_c = c - delta_c\n        \n        # Ensure the new column coordinate is within the grid bounds\n        if 0 <= new_c < cols:\n            output_grid[new_r, new_c] = object_color\n\n    # Convert numpy array back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7754,
    "candidates_token_count": 1512,
    "total_token_count": 9266,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.164253,
  "retries": null
}