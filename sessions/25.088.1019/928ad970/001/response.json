{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nDraws a rectangular frame on the grid. The frame's color is determined by the \nsingle contiguous non-gray (5), non-white (0) shape present in the input. \nThe frame's position is determined by finding the bounding box of all non-white \npixels (including the primary shape and any gray pixels), shrinking this bounding \nbox inwards by one pixel from all sides, and then drawing the perimeter of this \nshrunk box using the primary shape's color. The frame is drawn only over \nexisting white (0) pixels; original non-white pixels along the frame's path \nare preserved.\n\"\"\"\n\ndef find_non_white_pixels(grid):\n    \"\"\"Finds coordinates of all pixels that are not white (0).\n    \n    Args:\n        grid (np.array): The input grid.\n    \n    Returns:\n        list: A list of (row, col) tuples for non-white pixels.\n    \"\"\"\n    rows, cols = np.where(grid != 0)\n    return list(zip(rows, cols))\n\ndef find_primary_color(grid, non_white_pixels):\n    \"\"\"Finds the color of the first non-white, non-gray pixel encountered.\n    \n    Assumes there is exactly one such color/shape based on task examples.\n    \n    Args:\n        grid (np.array): The input grid.\n        non_white_pixels (list): List of (row, col) tuples for non-white pixels.\n\n    Returns:\n        int or None: The primary color value, or None if not found.\n    \"\"\"\n    for r, c in non_white_pixels:\n        color = grid[r, c]\n        # Color 0 is excluded by non_white_pixels, check for non-gray\n        if color != 5: \n            return color\n    return None \n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the minimum bounding box containing all given pixel coordinates.\n    \n    Args:\n        pixels (list): A list of (row, col) tuples.\n        \n    Returns:\n        tuple or None: (min_row, min_col, max_row, max_col) or None if input is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    rows = [p[0] for p in pixels]\n    cols = [p[1] for p in pixels]\n    # Adjust max values to be inclusive\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef transform(input_grid):\n    \"\"\"\n    Draws a frame based on the bounding box of all non-white pixels,\n    shrunk inwards by one pixel. Frame color matches the primary shape color.\n    Only white background pixels are overwritten.\n\n    Args:\n        input_grid (np.array): The input grid.\n\n    Returns:\n        np.array: The output grid with the frame drawn.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Step 1: Identify the locations of all non-white pixels.\n    non_white_pixels = find_non_white_pixels(input_grid)\n    if not non_white_pixels:\n        # If no non-white pixels, no frame can be determined.\n        return output_grid \n\n    # Step 2: Identify the primary color (non-white, non-gray).\n    primary_color = find_primary_color(input_grid, non_white_pixels)\n    if primary_color is None:\n        # If no primary color shape is found, cannot determine frame color.\n        return output_grid \n\n    # Step 3: Determine the overall bounding box for all non-white pixels.\n    bbox = get_bounding_box(non_white_pixels)\n    if bbox is None:\n         # Should not happen if non_white_pixels is not empty\n         return output_grid \n\n    min_r, min_c, max_r, max_c = bbox\n\n    # Step 4: Calculate the coordinates for the inner, shrunk frame.\n    frame_min_r = min_r + 1\n    frame_min_c = min_c + 1\n    frame_max_r = max_r - 1\n    frame_max_c = max_c - 1\n\n    # Step 5: Check if the shrunk frame is valid (has non-negative dimensions).\n    # If the bounding box was only 1 or 2 pixels thick/wide, shrinking makes it invalid.\n    if frame_min_r > frame_max_r or frame_min_c > frame_max_c:\n        # Shrunk box is invalid (e.g., negative width/height).\n        return output_grid \n\n    # Step 6 & 7: Draw the frame perimeter, only overwriting white pixels (0).\n    # Ensure drawing stays within grid bounds (although shrinking should guarantee this).\n    \n    # Draw Top row\n    # Check if row index is valid\n    if 0 <= frame_min_r < height:\n        # Iterate through columns of the top row\n        for c in range(max(0, frame_min_c), min(width, frame_max_c + 1)):\n            # Check if the original pixel at this location is white\n            if input_grid[frame_min_r, c] == 0:\n                output_grid[frame_min_r, c] = primary_color\n\n    # Draw Bottom row (avoid double drawing if frame height is 1)\n    # Check if row index is valid and different from top row\n    if 0 <= frame_max_r < height and frame_max_r != frame_min_r: \n        # Iterate through columns of the bottom row\n        for c in range(max(0, frame_min_c), min(width, frame_max_c + 1)):\n             # Check if the original pixel at this location is white\n            if input_grid[frame_max_r, c] == 0:\n                output_grid[frame_max_r, c] = primary_color\n\n    # Draw Left column (excluding corners already drawn by top/bottom row logic)\n    # Check if column index is valid\n    if 0 <= frame_min_c < width:\n        # Iterate through rows between the top and bottom row corners\n        for r in range(max(0, frame_min_r + 1), min(height, frame_max_r)):\n             # Check if the original pixel at this location is white\n            if input_grid[r, frame_min_c] == 0:\n                output_grid[r, frame_min_c] = primary_color\n\n    # Draw Right column (excluding corners, avoid double drawing if frame width is 1)\n    # Check if column index is valid and different from left column\n    if 0 <= frame_max_c < width and frame_max_c != frame_min_c: \n        # Iterate through rows between the top and bottom row corners\n       for r in range(max(0, frame_min_r + 1), min(height, frame_max_r)):\n            # Check if the original pixel at this location is white\n            if input_grid[r, frame_max_c] == 0:\n                output_grid[r, frame_max_c] = primary_color\n\n    # Step 8: Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4890,
    "candidates_token_count": 1727,
    "total_token_count": 6617,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 50.585787,
  "retries": null
}