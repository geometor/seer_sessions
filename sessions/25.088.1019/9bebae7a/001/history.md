
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 0 0 0
0 0 0 0 4 4 0 0 0 0
0 0 0 0 4 0 4 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 6 6 6 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 4 4 0
0 0 0 0 4 4 0 0 4 4
0 0 0 0 4 0 4 4 0 4
0 0 0 0 0 4 0 0 4 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 6 6 6 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 4 4 0 0 0 0 0 0 0
0 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 4 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 4 4 0 0 4 4 0 0 0
0 4 4 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 0 0 6 6 6 6 0
0 0 0 0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 6 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 4 4 4 4 0 0
```

*   **Perception:** The task involves two distinct objects in the input grid, one yellow (color 4) and one magenta (color 6). The output grid contains only yellow objects, derived from the input objects. The magenta object seems to act as an instruction or modifier for the yellow object. The shape of the magenta object ('L' shape or '+' shape) and its horizontal position relative to the yellow object determine the transformation. The background is white (color 0) and remains unchanged except where new yellow pixels are placed.

*   **YAML Facts:**
    
```yaml
    elements:
      - object_type: grid
        property: background_color
        value: 0 (white)
      - object_type: shape
        property: color
        value: 4 (yellow)
        alias: Y
      - object_type: shape
        property: color
        value: 6 (magenta)
        alias: M
    relationships:
      - type: spatial_relative_position
        object1: M
        object2: Y
        details: Focus on horizontal alignment (left of, right of, overlapping/centered).
      - type: shape_classification
        object: M
        possible_shapes: ['L', '+']
    actions:
      - name: identify_objects
        input: input_grid
        output: Y_object, M_object
      - name: get_bounding_box
        input: object
        output: bounding_box (top_row, left_col, height, width)
      - name: determine_shape
        input: M_object
        output: shape_type ('L' or '+')
      - name: determine_relative_horizontal_position
        input: Y_bounding_box, M_bounding_box
        output: position_relation ('left', 'right', 'centered')
      - name: transform
        based_on: [M_shape_type, position_relation]
        operations:
          - case: M is 'L' and position is 'left'
            action: mirror M horizontally, place at Y's top-left BB corner, remove Y
          - case: M is 'L' and position is 'right'
            action: copy Y, translate copy right by Y's BB width, combine with original Y
          - case: M is '+' and position is 'centered'
            action: copy Y, translate copy down by Y's BB height, combine with original Y
          - case: M is '+' and position is 'right'
            action: copy Y, translate copy up by Y's BB height, combine with original Y
      - name: generate_output
        input: transformed_yellow_object(s), original_grid_dimensions
        output: output_grid
    ```


*   **Natural Language Program:**
    1.  Identify the contiguous yellow object (Y) and the contiguous magenta object (M) in the input grid.
    2.  Determine the bounding box (BB) for both Y and M (Y_BB, M_BB).
    3.  Classify the shape of the magenta object M as either 'L' or '+'.
    4.  Determine the horizontal spatial relationship between M_BB and Y_BB:
        *   'left': M_BB's rightmost column is less than Y_BB's leftmost column.
        *   'right': M_BB's leftmost column is greater than Y_BB's rightmost column.
        *   'centered': Their column ranges overlap.
    5.  Apply the transformation based on M's shape and the relative horizontal position:
        *   **If M is 'L' shape:**
            *   If M is 'left' of Y: Create the output grid by taking the shape of M, mirroring it horizontally, and placing it so its new top-left corner aligns with the top-left corner of Y_BB. The original Y object is removed.
            *   If M is 'right' of Y: Create the output grid containing the original Y object, plus a copy of the Y object translated horizontally to the right by the width of Y_BB.
        *   **If M is '+' shape:**
            *   If M is 'centered' relative to Y: Create the output grid containing the original Y object, plus a copy of the Y object translated vertically downwards by the height of Y_BB.
            *   If M is 'right' of Y: Create the output grid containing the original Y object, plus a copy of the Y object translated vertically upwards by the height of Y_BB.
    6.  Ensure the output grid retains the original dimensions and background color (white). The magenta object M is not present in the output grid.
