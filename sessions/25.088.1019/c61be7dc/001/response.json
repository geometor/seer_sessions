{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nIdentifies a pair of parallel white (0) lines (horizontal or vertical) in the input grid.\nFinds the gray (5) object enclosed between these lines.\nTransforms the grid by:\n1. Moving the white lines one step inwards towards each other.\n2. Replacing the enclosed gray object with a single gray line segment.\n3. The orientation of the output gray line matches the orientation of the input white lines.\n4. If input lines are vertical: The output gray line is vertical, centered horizontally between the new white lines, and has a length equal to the grid height minus 2, centered vertically.\n5. If input lines are horizontal: The output gray line is horizontal, centered vertically between the new white lines, and has a length equal to the number of gray pixels in the original enclosed object, centered horizontally.\n6. The background is orange (7).\n\"\"\"\n\ndef find_parallel_white_lines(grid):\n    \"\"\"Finds the pair of parallel white lines (rows or columns).\"\"\"\n    height, width = grid.shape\n    white_rows = []\n    white_cols = []\n\n    # Check for horizontal lines (full rows of white)\n    for r in range(height):\n        if np.all(grid[r, :] == 0):\n            white_rows.append(r)\n\n    # Check for vertical lines (full columns of white)\n    for c in range(width):\n        if np.all(grid[:, c] == 0):\n            white_cols.append(c)\n\n    if len(white_rows) == 2:\n        return 'horizontal', white_rows[0], white_rows[1]\n    elif len(white_cols) == 2:\n        return 'vertical', white_cols[0], white_cols[1]\n    else:\n        # Fallback: check for lines that might be interrupted by gray pixels crossing them\n        # (This seems less likely given the examples, but could be a variation)\n        # Scan rows for potential horizontal lines (mostly 0, some 5 maybe)\n        candidate_rows = []\n        for r in range(height):\n             if np.count_nonzero(grid[r, :] != 0) <= np.count_nonzero(grid[r, :] == 5): # Allow only 0s and 5s, mostly 0s? simpler: count 0s\n                 if np.count_nonzero(grid[r,:] == 0) > width // 2 : # Heuristic: majority are 0\n                     candidate_rows.append(r)\n        if len(candidate_rows) == 2:\n             # Check if gray pixels are ONLY between these rows\n             gray_coords = np.argwhere(grid == 5)\n             min_r_gray = np.min(gray_coords[:, 0]) if gray_coords.size > 0 else -1\n             max_r_gray = np.max(gray_coords[:, 0]) if gray_coords.size > 0 else -1\n             if gray_coords.size > 0 and min_r_gray > candidate_rows[0] and max_r_gray < candidate_rows[1]:\n                 return 'horizontal', candidate_rows[0], candidate_rows[1]\n\n\n        # Scan columns for potential vertical lines\n        candidate_cols = []\n        for c in range(width):\n             if np.count_nonzero(grid[:, c] != 0) <= np.count_nonzero(grid[:, c] == 5):\n                 if np.count_nonzero(grid[:,c] == 0) > height // 2 :\n                      candidate_cols.append(c)\n        if len(candidate_cols) == 2:\n             # Check if gray pixels are ONLY between these cols\n             gray_coords = np.argwhere(grid == 5)\n             min_c_gray = np.min(gray_coords[:, 1]) if gray_coords.size > 0 else -1\n             max_c_gray = np.max(gray_coords[:, 1]) if gray_coords.size > 0 else -1\n             if gray_coords.size > 0 and min_c_gray > candidate_cols[0] and max_c_gray < candidate_cols[1]:\n                 return 'vertical', candidate_cols[0], candidate_cols[1]\n\n    # If no clear pair found by above methods, look for the two rows/cols with the most zeros\n    # This is less robust but might catch cases missed by strict line checks\n    row_zero_counts = [(r, np.sum(grid[r, :] == 0)) for r in range(height)]\n    col_zero_counts = [(c, np.sum(grid[:, c] == 0)) for c in range(width)]\n\n    row_zero_counts.sort(key=lambda x: x[1], reverse=True)\n    col_zero_counts.sort(key=lambda x: x[1], reverse=True)\n\n    # Check if the top 2 row counts are significantly higher and form potential lines\n    if len(row_zero_counts) >= 2 and row_zero_counts[0][1] > width * 0.7 and row_zero_counts[1][1] > width * 0.7:\n         rows = sorted([row_zero_counts[0][0], row_zero_counts[1][0]])\n         # Check if gray is between\n         gray_coords = np.argwhere(grid == 5)\n         if gray_coords.size > 0:\n             min_r_gray = np.min(gray_coords[:, 0])\n             max_r_gray = np.max(gray_coords[:, 0])\n             if min_r_gray > rows[0] and max_r_gray < rows[1]:\n                 return 'horizontal', rows[0], rows[1]\n\n    # Check if the top 2 col counts are significantly higher and form potential lines\n    if len(col_zero_counts) >= 2 and col_zero_counts[0][1] > height * 0.7 and col_zero_counts[1][1] > height * 0.7:\n         cols = sorted([col_zero_counts[0][0], col_zero_counts[1][0]])\n          # Check if gray is between\n         gray_coords = np.argwhere(grid == 5)\n         if gray_coords.size > 0:\n             min_c_gray = np.min(gray_coords[:, 1])\n             max_c_gray = np.max(gray_coords[:, 1])\n             if min_c_gray > cols[0] and max_c_gray < cols[1]:\n                 return 'vertical', cols[0], cols[1]\n\n\n    raise ValueError(\"Could not reliably find two parallel white lines.\")\n\n\ndef count_enclosed_gray_pixels(grid, orientation, idx1, idx2):\n    \"\"\"Counts gray pixels strictly between the given lines.\"\"\"\n    count = 0\n    if orientation == 'horizontal':\n        for r in range(idx1 + 1, idx2):\n            for c in range(grid.shape[1]):\n                if grid[r, c] == 5:\n                    count += 1\n    elif orientation == 'vertical':\n        for r in range(grid.shape[0]):\n            for c in range(idx1 + 1, idx2):\n                if grid[r, c] == 5:\n                    count += 1\n    return count\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described rules.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid with background color (orange, 7)\n    output_grid = np.full_like(input_np, 7)\n\n    # Find the parallel white lines\n    try:\n        orientation, idx1, idx2 = find_parallel_white_lines(input_np)\n    except ValueError as e:\n        print(f\"Error finding lines: {e}\")\n        # Default behavior if lines aren't found? Return input? Or orange grid?\n        # Let's return orange grid for now, indicates processing happened but failed finding key features.\n        return output_grid.tolist()\n\n\n    # Count the gray pixels between the lines\n    gray_pixel_count = count_enclosed_gray_pixels(input_np, orientation, idx1, idx2)\n\n    # Calculate new line positions\n    new_idx1 = idx1 + 1\n    new_idx2 = idx2 - 1\n\n    # Calculate the center index for the new gray line\n    # Ensure it stays within bounds if lines become adjacent\n    center_idx = math.floor((new_idx1 + new_idx2) / 2)\n\n    # Draw the moved white lines onto the output grid\n    if orientation == 'horizontal':\n        if new_idx1 >= 0 and new_idx1 < height:\n             output_grid[new_idx1, :] = 0\n        if new_idx2 >= 0 and new_idx2 < height and new_idx1 != new_idx2: # Avoid overwriting if they meet\n             output_grid[new_idx2, :] = 0\n    elif orientation == 'vertical':\n         if new_idx1 >= 0 and new_idx1 < width:\n             output_grid[:, new_idx1] = 0\n         if new_idx2 >= 0 and new_idx2 < width and new_idx1 != new_idx2:\n             output_grid[:, new_idx2] = 0\n             \n    # Check if lines have merged or crossed (new_idx1 >= new_idx2)\n    # If they meet, the center is ambiguous, maybe just draw white lines? Example 1 output suggests center pixel is orange if lines meet vertically.\n    # Example 2 output suggests center row becomes white if lines meet horizontally.\n    # Let's stick to the plan: if they meet or cross, maybe there's no gray line.\n    # The derived NL program doesn't explicitly cover lines meeting/crossing.\n    # Let's assume valid inputs always have space after moving lines inwards. idx2 > idx1 + 1 initially.\n    # Thus new_idx2 will always be > new_idx1.\n\n    # Determine and draw the new gray line\n    if orientation == 'vertical':\n        # Output line is vertical\n        line_len = height - 2\n        if line_len <= 0: # Handle very small grids\n             line_len = 1 if height > 0 else 0\n\n        start_row = math.floor((height - line_len) / 2)\n        end_row = start_row + line_len\n        \n        # Ensure column index is valid\n        if center_idx >= 0 and center_idx < width:\n            # Draw the gray line, ensuring row indices are valid\n            actual_start_row = max(0, start_row)\n            actual_end_row = min(height, end_row)\n            if actual_start_row < actual_end_row: # Check if there's anything to draw\n                 output_grid[actual_start_row:actual_end_row, center_idx] = 5\n\n    elif orientation == 'horizontal':\n        # Output line is horizontal\n        line_len = gray_pixel_count\n        if line_len <= 0: # Handle cases with no gray pixels found\n             line_len = 0\n\n        start_col = math.floor((width - line_len) / 2)\n        end_col = start_col + line_len\n\n         # Ensure row index is valid\n        if center_idx >= 0 and center_idx < height:\n            # Draw the gray line, ensuring column indices are valid\n            actual_start_col = max(0, start_col)\n            actual_end_col = min(width, end_col)\n            if actual_start_col < actual_end_col: # Check if there's anything to draw\n                 output_grid[center_idx, actual_start_col:actual_end_col] = 5\n                 \n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4266,
    "candidates_token_count": 2819,
    "total_token_count": 7085,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.250494,
  "retries": null
}