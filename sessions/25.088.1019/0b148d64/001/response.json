{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies the bottom-most contiguous block of non-background (non-zero) pixels \nin the input grid, where blocks are separated by horizontal rows consisting \nentirely of the background color (0). The transformation extracts the bounding \nbox of this bottom-most block.\n\n1. Scan the input grid from bottom to top to find the index of the last row \n   containing any non-background pixel. This is the bottom edge of the target region.\n2. Scan from this bottom edge row upwards to find the index of the first row \n   encountered that consists entirely of the background color (0). The row below \n   this separator row is the top edge of the target region. If no separator row \n   is found above the bottom edge, the top edge is the first row (index 0) of \n   the grid.\n3. Within the identified rows (from top edge to bottom edge, inclusive), find the \n   minimum and maximum column indices that contain a non-background pixel across \n   any of these rows. These are the left and right edges of the target region.\n4. Extract the subgrid defined by these row and column boundaries.\n\"\"\"\n\ndef find_last_non_background_row(grid: np.ndarray, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the index of the last row containing any non-background pixels.\n    Scans from bottom to top. Returns None if the grid is empty or all background.\n    \"\"\"\n    height = grid.shape[0]\n    for r in range(height - 1, -1, -1):\n        if np.any(grid[r] != background_color):\n            return r\n    return None\n\ndef find_last_all_background_row_before(grid: np.ndarray, end_row_index: int, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the index of the last row consisting entirely of background_color,\n    searching upwards from (but not including) end_row_index down to row 0.\n    Returns None if no such row is found.\n    \"\"\"\n    for r in range(end_row_index - 1, -1, -1):\n        if np.all(grid[r] == background_color):\n            return r\n    return None\n\ndef find_column_bounds(grid: np.ndarray, start_row: int, end_row: int, background_color: int = 0) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the minimum and maximum column indices containing non-background pixels\n    within the specified row range (inclusive).\n    Returns None if no non-background pixels are found in the range.\n    \"\"\"\n    min_col = grid.shape[1]\n    max_col = -1\n    found_non_bg = False\n\n    for r in range(start_row, end_row + 1):\n        non_bg_indices = np.where(grid[r] != background_color)[0]\n        if non_bg_indices.size > 0:\n            found_non_bg = True\n            current_min = np.min(non_bg_indices)\n            current_max = np.max(non_bg_indices)\n            min_col = min(min_col, current_min)\n            max_col = max(max_col, current_max)\n\n    if not found_non_bg:\n        return None\n    return min_col, max_col\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Extracts the bottom-most non-background region from the input grid.\n    \n    Args:\n        input_grid: A list of lists representing the input grid.\n        \n    Returns:\n        A list of lists representing the extracted subgrid (the bottom region).\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    background_color = 0\n    height, width = grid.shape\n\n    if height == 0 or width == 0:\n        return [] # Handle empty input\n\n    # 1. Find the bottom row index of the target region\n    last_row = find_last_non_background_row(grid, background_color)\n    \n    # If no non-background pixels exist anywhere, return empty grid\n    if last_row is None:\n        return [] \n\n    # 2. Find the top row index of the target region\n    # Scan upwards from the last_row to find the first all-background separator row\n    separator_row = find_last_all_background_row_before(grid, last_row, background_color)\n\n    # The target region starts the row *after* the separator, or row 0 if no separator found\n    first_row = 0 if separator_row is None else separator_row + 1\n        \n    # 3. Find the column bounds (left and right edges) within the target rows\n    col_bounds = find_column_bounds(grid, first_row, last_row, background_color)\n    \n    # This check might be redundant if last_row was found, but good practice\n    if col_bounds is None:\n        # This case should ideally not be reached if last_row is not None,\n        # but handles potential edge cases or empty regions between separators.\n        # Let's return an empty grid or the single row/column if that makes sense.\n        # Based on examples, an empty result is unlikely if a non-bg row was found.\n        # If last_row exists, there must be columns.\n         return [] # Or potentially handle differently if needed.\n        \n    first_col, last_col = col_bounds\n\n    # 4. Extract the subgrid using numpy slicing\n    output_grid_np = grid[first_row : last_row + 1, first_col : last_col + 1]\n\n    # Convert the resulting numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4747,
    "candidates_token_count": 1413,
    "total_token_count": 6160,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.414477,
  "retries": null
}