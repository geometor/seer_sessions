{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set\n\n\"\"\"\nExtracts a subgrid representing the bounding box of specific color(s) found only \nin the bottom-most horizontal region of the input grid, where regions are \nseparated by rows of the background color (white, 0). The specific color(s) \nto extract are those present in the bottom region but not in the region \nimmediately above it.\n\nThe process involves:\n1. Identifying the last row containing non-background pixels (`last_row`).\n2. Identifying the last separator row (all background) before `last_row`.\n3. Defining the row ranges for the 'bottom block' (below separator) and 'top block' (above or including separator).\n4. Finding the unique non-background colors in each block.\n5. Determining the 'target colors' (those unique to the bottom block).\n6. Finding the minimal column bounds containing any target color pixels within the bottom block's rows.\n7. Extracting the subgrid defined by the bottom block's row range and the target color's column bounds.\n\"\"\"\n\ndef find_last_non_background_row(grid: np.ndarray, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the index of the last row containing any non-background pixels.\n    Scans from bottom to top. Returns None if the grid is empty or all background.\n    \"\"\"\n    height = grid.shape[0]\n    for r in range(height - 1, -1, -1):\n        if np.any(grid[r] != background_color):\n            return r\n    return None\n\ndef find_last_all_background_row_before(grid: np.ndarray, end_row_index: int, background_color: int = 0) -> int:\n    \"\"\"\n    Finds the index of the last row consisting entirely of background_color,\n    searching upwards from (but not including) end_row_index down to row 0.\n    Returns -1 if no such row is found.\n    \"\"\"\n    for r in range(end_row_index - 1, -1, -1):\n        if np.all(grid[r] == background_color):\n            return r\n    return -1 # Indicates no separator row found above the content\n\ndef get_unique_colors_in_rows(grid: np.ndarray, start_row: int, end_row: int, background_color: int = 0) -> Set[int]:\n    \"\"\"\n    Finds the set of unique non-background colors within a specified row range (inclusive).\n    Returns an empty set if the range is invalid or contains only background.\n    \"\"\"\n    if start_row < 0 or end_row < start_row or start_row >= grid.shape[0]:\n        return set()\n    # Ensure end_row is within grid bounds for slicing\n    actual_end_row = min(end_row, grid.shape[0] - 1)\n    subgrid = grid[start_row : actual_end_row + 1]\n    if subgrid.size == 0:\n        return set()\n    unique_colors = np.unique(subgrid)\n    non_background_colors = unique_colors[unique_colors != background_color]\n    return set(non_background_colors)\n\ndef find_target_column_bounds(grid: np.ndarray, start_row: int, end_row: int, target_colors: Set[int]) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the minimum and maximum column indices containing any of the target_colors\n    within the specified row range (inclusive).\n    Returns None if no target colors are found in the range.\n    \"\"\"\n    min_col = grid.shape[1]\n    max_col = -1\n    found_target = False\n\n    # Ensure row bounds are valid\n    start_row = max(0, start_row)\n    end_row = min(grid.shape[0] - 1, end_row)\n    \n    if start_row > end_row: # Handle cases where block might be empty after clipping\n         return None\n\n    for r in range(start_row, end_row + 1):\n        for c in range(grid.shape[1]):\n            if grid[r, c] in target_colors:\n                found_target = True\n                min_col = min(min_col, c)\n                max_col = max(max_col, c)\n\n    if not found_target:\n        return None\n    return min_col, max_col\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the described rule.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    background_color = 0\n    height, width = grid.shape\n\n    if height == 0 or width == 0:\n        return [] # Handle empty input\n\n    # 1. Find the bottom row index of any non-background content\n    last_row = find_last_non_background_row(grid, background_color)\n\n    # If no non-background pixels exist anywhere, return empty grid\n    if last_row is None:\n        return []\n\n    # 2. Find the highest separator row (all background) below last_row\n    separator_row = find_last_all_background_row_before(grid, last_row, background_color)\n    # separator_row is -1 if no separator exists\n\n    # 3. Define row ranges for blocks\n    bottom_block_start_row = separator_row + 1\n    bottom_block_end_row = last_row\n    top_block_start_row = 0\n    top_block_end_row = separator_row # Use separator_row directly. Slicing handles end<start.\n\n    # 4. Identify unique non-background colors in each block\n    top_colors = get_unique_colors_in_rows(grid, top_block_start_row, top_block_end_row, background_color)\n    bottom_colors = get_unique_colors_in_rows(grid, bottom_block_start_row, bottom_block_end_row, background_color)\n\n    # 5. Determine the target colors (present in bottom block, absent in top block)\n    target_colors = bottom_colors - top_colors\n\n    # If no unique colors in bottom block, result is empty (shouldn't happen if last_row exists)\n    if not target_colors:\n         # This might occur if the only non-bg color in bottom is also in top\n         # Let's find the bounding box of *all* non-bg colors in the bottom block in this case?\n         # Or maybe the rule implies there *must* be a unique color.\n         # Based on examples, there's always a unique color. If not, returning empty seems plausible.\n         # Let's stick to the derived rule: only extract unique colors.\n        # Re-evaluate if a test case fails this assumption.\n        # We need *some* bounds to extract *something*. Let's calculate bounds for any non-bg color in the bottom block.\n        all_non_bg_bottom_colors = get_unique_colors_in_rows(grid, bottom_block_start_row, bottom_block_end_row, background_color)\n        if not all_non_bg_bottom_colors: return [] # Truly empty bottom block\n        col_bounds = find_target_column_bounds(grid, bottom_block_start_row, bottom_block_end_row, all_non_bg_bottom_colors)\n\n        # The previous code simply returned [], let's try that first.\n        # The examples always have a target color.\n        # A more robust approach might be needed if edge cases without unique colors exist.\n        # For now, assume target_colors will be non-empty if bottom_colors is non-empty.\n        # If bottom_colors IS empty, last_row wouldn't have been found, so we shouldn't reach here.\n        # Let's check if target_colors is empty but bottom_colors is not.\n        if not target_colors and bottom_colors:\n             # This means all colors in bottom also exist in top.\n             # The examples don't cover this. What should happen?\n             # Possibility 1: Extract bounding box of *all* colors in bottom block.\n             # Possibility 2: Return empty.\n             # Let's choose Possibility 2 for now as it aligns with strict interpretation.\n             return []\n\n\n    # 6. Find the column bounds (left and right edges) for target colors within the bottom block rows\n    col_bounds = find_target_column_bounds(grid, bottom_block_start_row, bottom_block_end_row, target_colors)\n\n    # If no target colors were found within the bottom block (e.g., if target_colors was somehow empty)\n    if col_bounds is None:\n        return []\n\n    first_col, last_col = col_bounds\n\n    # 7. Extract the subgrid using numpy slicing\n    # Rows: from bottom_block_start_row up to and including bottom_block_end_row\n    # Cols: from first_col up to and including last_col\n    output_grid_np = grid[bottom_block_start_row : bottom_block_end_row + 1, first_col : last_col + 1]\n\n    # Convert the resulting numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12079,
    "candidates_token_count": 2230,
    "total_token_count": 14309,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.877087,
  "retries": null
}