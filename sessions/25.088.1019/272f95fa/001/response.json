{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify horizontal and vertical lines of azure (8) pixels that divide the grid.\n2. Find all contiguous regions of white (0) pixels.\n3. For each white region, determine if it is fully enclosed by the azure lines (i.e., it does not touch the grid boundaries).\n4. If a white region is enclosed, determine its relative position within the central 3x3 area defined by the lines (top-center, middle-left, center, middle-right, bottom-center).\n5. Fill the enclosed regions with specific colors based on their position:\n    - top-center: red (2)\n    - middle-left: yellow (4)\n    - center: magenta (6)\n    - middle-right: green (3)\n    - bottom-center: blue (1)\n6. Leave the azure lines and non-enclosed white regions unchanged.\n\"\"\"\n\ndef find_regions(grid, color):\n    \"\"\"Finds all contiguous regions of a specified color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                region_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    region_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store region coords and bounding box\n                regions.append({\n                    'coords': region_coords,\n                    'min_r': min_r, 'max_r': max_r,\n                    'min_c': min_c, 'max_c': max_c\n                })\n    return regions\n\ndef find_lines(grid, color):\n    \"\"\"Finds the indices of horizontal and vertical lines of a specified color.\"\"\"\n    height, width = grid.shape\n    h_lines = []\n    v_lines = []\n\n    # Find horizontal lines (rows full of the color)\n    for r in range(height):\n        if np.all(grid[r, :] == color):\n            h_lines.append(r)\n\n    # Find vertical lines (columns full of the color) - more complex if lines aren't full grid extent\n    # Let's find columns that consist ONLY of the line color or background color,\n    # and contain at least one line color pixel. A simpler approach for this specific problem\n    # might be to find columns that contain the line color between the identified horizontal lines.\n    # A robust way is finding columns with ONLY line color:\n    for c in range(width):\n         if np.all(grid[:, c] == color):\n            v_lines.append(c)\n\n    # Refined check for vertical lines based on examples: lines might not span the *entire* height\n    # Find columns that contain the line color (8)\n    potential_v_lines = [c for c in range(width) if color in grid[:, c]]\n    \n    # In the context of this problem, vertical lines are continuous segments of color 8.\n    # Let's assume the vertical lines are simple and continuous columns of color 8.\n    # We can refine this if needed, but the simple check seems to work for the examples.\n    v_lines_strict = []\n    for c in potential_v_lines:\n        is_line = True\n        for r in range(height):\n             # A vertical line pixel should either be color 8, or be part of a horizontal line\n             is_horizontal_line_pixel = False\n             if r in h_lines and grid[r,c] == color:\n                 is_horizontal_line_pixel = True\n             \n             if grid[r, c] != color and not is_horizontal_line_pixel: \n                 # Allow 0s only outside the horizontal bounds, if structure is always H-shape\n                 # Check if this 0 is 'outside' the main structure defined by h_lines\n                 if h_lines and (r < min(h_lines) or r > max(h_lines)):\n                     pass # Allow 0s outside the horizontal lines\n                 else:\n                     # If it's not color 8 and not part of crossing horizontal line, it's not a pure vertical line\n                     # However, the examples show 0s within the column span.\n                     # Let's stick to the simpler definition first: columns containing only 8s or crossing horizontal 8s.\n                     # The examples have columns that *are* pure 8s except at intersections.\n                     pass # Revisit logic if needed\n\n    # Simpler approach based on examples: Find columns containing only color 8 between the horizontal lines.\n    v_lines = []\n    if len(h_lines) >= 2:\n       h_min, h_max = min(h_lines), max(h_lines)\n       for c in range(width):\n           segment = grid[h_min+1:h_max, c]\n           # Check if this column has a continuous line of 8s between the horizontal lines\n           # A simpler check might just be finding columns with 8s *somewhere*\n           if color in grid[:, c]: \n               # Let's just find *all* columns that contain the color 8\n               # The relative positioning logic will use the *innermost* ones implicitly.\n               if c > 0 and c < width -1 : # Avoid grid edge columns if they happen to be 8\n                    # Let's identify the main vertical dividers based on their position relative to each other\n                    pass # This requires more complex line identification\n    \n    # Based on visual inspection of examples, let's find *any* column index containing color 8\n    # and rely on sorting later.\n    v_lines_indices = sorted(list(set(np.where(grid == color)[1])))\n    h_lines_indices = sorted(list(set(np.where(grid == color)[0])))\n\n    # Filter out lines that are just the border (if applicable, not in these examples)\n    h_lines_indices = [r for r in h_lines_indices if 0 < r < height - 1 and np.all(grid[r, 1:-1] == color)] # check if it's a line internally\n    v_lines_indices = [c for c in v_lines_indices if 0 < c < width - 1 and np.all(grid[1:-1, c] == color)] # check if it's a line internally\n    \n    # Assuming 2 horizontal and 2 vertical lines define the inner grid.\n    h_lines_indices = sorted(list(set(np.where(grid == color)[0])))\n    v_lines_indices = sorted(list(set(np.where(grid == color)[1])))\n\n    # Filter based on actual lines (long segments) rather than individual pixels\n    final_h_lines = []\n    for r in h_lines_indices:\n        if np.all(grid[r,:] == color): # Check for full horizontal line\n             final_h_lines.append(r)\n    \n    final_v_lines = []\n    for c in v_lines_indices:\n         if np.all(grid[:,c] == color): # Check for full vertical line\n             final_v_lines.append(c)\n             \n    # If full lines are not found, perhaps partial lines?\n    # Let's refine based on the structure: Find rows/cols that are *mostly* color 8.\n    final_h_lines = []\n    for r in range(height):\n        if np.count_nonzero(grid[r, :] == color) > width // 2 : # Heuristic: More than half the row is the line color\n             # Check for continuity? Assume simple lines for now.\n             is_line = True\n             for c in range(width):\n                 # If it's not line color, it must be an intersecting vertical line pixel\n                 if grid[r, c] != color and grid[r, c] != 0: # Allow intersections if vertical lines exist\n                     if not any(grid[:,c] == color): # Check if this column is a vertical line\n                        # pass # This logic is getting complex, let's rethink\n                        pass\n\n             # Simpler: identify the row indices containing the horizontal segments of color 8\n             if color in grid[r,:]:\n                 is_solid_line = True\n                 start_col, end_col = -1, -1\n                 for c_idx in range(width):\n                     if grid[r, c_idx] == color:\n                         if start_col == -1: start_col = c_idx\n                         end_col = c_idx\n                     elif start_col != -1: # End of a segment\n                         # Check if it's a significant segment?\n                         break # Found a break, maybe not a main line\n                 if start_col != -1 and end_col > start_col + 1: # Need at least 2 pixels\n                     # Check if it spans most of the width or between vertical lines\n                     # Let's assume the main horizontal lines span the whole width\n                     if np.all(grid[r,:] == color):\n                         final_h_lines.append(r)\n\n    final_v_lines = []\n    for c in range(width):\n         # Assume main vertical lines span the whole height\n         if np.all(grid[:,c] == color):\n             final_v_lines.append(c)\n\n    # Fallback / specific structure identification for this task:\n    # Assume exactly two dominant horizontal and two dominant vertical lines.\n    h_line_rows = sorted([r for r in range(height) if np.all(grid[r, :] == color)])\n    v_line_cols = sorted([c for c in range(width) if np.all(grid[:, c] == color)])\n\n    # If full lines aren't found, maybe they are interrupted?\n    # Let's find rows/cols with *any* pixel of the line color (8)\n    if not h_line_rows:\n        h_line_rows = sorted(list(set(np.where(grid == color)[0])))\n    if not v_line_cols:\n        v_line_cols = sorted(list(set(np.where(grid == color)[1])))\n        \n    # Heuristic: Assume the lines are those rows/columns with the most color 8 pixels,\n    # excluding borders if they are also color 8.\n    h_counts = {r: np.count_nonzero(grid[r, :] == color) for r in range(height)}\n    v_counts = {c: np.count_nonzero(grid[:, c] == color) for c in range(width)}\n\n    # Sort by count descending, take top 2 (or more if counts are equal)\n    sorted_h = sorted(h_counts.items(), key=lambda item: item[1], reverse=True)\n    sorted_v = sorted(v_counts.items(), key=lambda item: item[1], reverse=True)\n\n    # Filter out potential lines with low counts if there are clear dominant lines\n    h_lines = []\n    if sorted_h:\n      max_h_count = sorted_h[0][1]\n      # Take all rows with count >= max_count * 0.8 (heuristic threshold)\n      h_lines = sorted([r for r, count in sorted_h if count >= max_h_count * 0.8])\n\n    v_lines = []\n    if sorted_v:\n      max_v_count = sorted_v[0][1]\n      v_lines = sorted([c for c, count in sorted_v if count >= max_v_count * 0.8])\n\n    # In the specific examples, it seems the relevant lines *are* solid.\n    final_h_lines = sorted([r for r in range(height) if np.all(grid[r, :] == color)])\n    final_v_lines = sorted([c for c in range(width) if np.all(grid[:, c] == color)])\n\n\n    # Final attempt: The examples seem to have exactly two solid lines each way.\n    h_lines = [r for r in range(height) if np.all(grid[r, :] == color)]\n    v_lines = [c for c in range(width) if np.all(grid[:, c] == color)]\n\n    # It's possible the lines are not *fully* solid due to intersections.\n    # Let's find rows and columns that are *predominantly* the line color.\n    h_lines_final = []\n    v_lines_final = []\n    for r in range(height):\n        # Check if row r is mostly line color, allowing for intersections with vertical lines\n        count8 = 0\n        for c in range(width):\n             # Pixel is 8 OR it's a column identified as a potential vertical line\n             is_potential_vline = np.any(grid[:,c] == color) # Does column c have *any* 8s?\n             if grid[r,c] == color or (grid[r,c]!=color and is_potential_vline) :\n                 count8 +=1\n        # A less strict check: simply find rows containing 8s. The sorting will matter.\n        if color in grid[r,:]:\n             h_lines_final.append(r)\n\n\n    for c in range(width):\n        if color in grid[:,c]:\n             v_lines_final.append(c)\n             \n    # Let's assume the examples *always* have exactly two clear horizontal and two clear vertical lines.\n    h_lines = sorted([r for r in range(height) if np.count_nonzero(grid[r, :] == color) > 1])\n    v_lines = sorted([c for c in range(width) if np.count_nonzero(grid[:, c] == color) > 1])\n\n    # Identify the two most prominent lines based on count?\n    h_counts = {r: np.count_nonzero(grid[r, :] == color) for r in h_lines}\n    v_counts = {c: np.count_nonzero(grid[:, c] == color) for c in v_lines}\n    \n    # Sort by row/col index first, then maybe filter by count?\n    # Let's assume the first and last lines found are the ones defining the outer boundary of the inner grid.\n    if len(h_lines) >= 2:\n        h_lines = [min(h_lines), max(h_lines)]\n    if len(v_lines) >= 2:\n        v_lines = [min(v_lines), max(v_lines)]\n        \n    # Use the visually correct lines from examples:\n    h_lines_indices = sorted(list(set(np.where(grid == color)[0])))\n    v_lines_indices = sorted(list(set(np.where(grid == color)[1])))\n    \n    # Assume the lines defining the structure are the min and max indices found.\n    h_lines = []\n    if h_lines_indices:\n        h_lines = [min(h_lines_indices), max(h_lines_indices)]\n        # Check if they are actual lines (mostly 8s)\n        h_lines = [r for r in h_lines if np.count_nonzero(grid[r,:] == color) > width * 0.5]\n\n\n    v_lines = []\n    if v_lines_indices:\n        v_lines = [min(v_lines_indices), max(v_lines_indices)]\n        v_lines = [c for c in v_lines if np.count_nonzero(grid[:,c] == color) > height * 0.5]\n\n\n    # Based on the problem structure: find the indices of the horizontal and vertical lines\n    # These lines seem solid in the examples.\n    h_lines = sorted([r for r in range(grid.shape[0]) if np.all(grid[r, :] == color)])\n    v_lines = sorted([c for c in range(grid.shape[1]) if np.all(grid[:, c] == color)])\n\n    # If lines are not solid (e.g., cross shape), adjust logic.\n    # For now, assume solid lines based on train examples.\n\n    return h_lines, v_lines\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding enclosed white regions defined by azure lines\n    and filling them with colors based on their relative position.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    azure_color = 8\n    white_color = 0\n\n    # 1. Find the dividing azure lines\n    h_lines, v_lines = find_lines(input_grid, azure_color)\n\n    # Expect exactly two horizontal and two vertical lines for the 3x3 inner structure\n    if len(h_lines) != 2 or len(v_lines) != 2:\n        # If line detection failed or structure is different, return copy\n        # Or handle differently based on more examples\n        print(f\"Warning: Expected 2 horizontal and 2 vertical lines, found {len(h_lines)}h, {len(v_lines)}v. Using as is.\")\n        # return output_grid # Keep processing if possible\n\n    # Ensure lines are sorted\n    h_lines.sort()\n    v_lines.sort()\n\n    # 2. Find all white regions\n    white_regions = find_regions(input_grid, white_color)\n\n    # 3. Process each white region\n    for region_info in white_regions:\n        coords = region_info['coords']\n        min_r, max_r = region_info['min_r'], region_info['max_r']\n        min_c, max_c = region_info['min_c'], region_info['max_c']\n        \n        # Any point in the region can be used for position check, e.g., top-left\n        rep_r, rep_c = min_r, min_c \n\n        # 4. Check if the region is enclosed (not touching borders)\n        is_on_border = (min_r == 0 or max_r == height - 1 or\n                        min_c == 0 or max_c == width - 1)\n\n        if not is_on_border and len(h_lines) == 2 and len(v_lines) == 2:\n            h1, h2 = h_lines\n            v1, v2 = v_lines\n\n            # 5. Determine relative position and assign color\n            fill_color = -1 # Default/error color\n\n            # Check position relative to the identified lines\n            if rep_r < h1 and v1 < rep_c < v2: # Top-center\n                fill_color = 2 # red\n            elif h1 < rep_r < h2 and rep_c < v1: # Middle-left\n                fill_color = 4 # yellow\n            elif h1 < rep_r < h2 and v1 < rep_c < v2: # Center\n                fill_color = 6 # magenta\n            elif h1 < rep_r < h2 and rep_c > v2: # Middle-right\n                fill_color = 3 # green\n            elif rep_r > h2 and v1 < rep_c < v2: # Bottom-center\n                fill_color = 1 # blue\n\n            # 6. Fill the region in the output grid\n            if fill_color != -1:\n                for r, c in coords:\n                    output_grid[r, c] = fill_color\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4223,
    "candidates_token_count": 4755,
    "total_token_count": 8978,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.652345,
  "retries": null
}