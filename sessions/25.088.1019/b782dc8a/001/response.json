{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify the main structure color (assumed to be the most frequent non-background color).\nIdentify the two pattern colors present in the input (either blue (1) and yellow (4), or green (3) and red (2)).\nIterate through each background (white, 0) pixel in the input grid.\nIf a background pixel is adjacent (including diagonals) to a pixel of the structure color:\n  Calculate the sum of its row and column index (r + c).\n  Determine the color based on the identified pattern and the parity of (r + c):\n  - If the pattern colors are blue (1) and yellow (4):\n    Change the pixel to blue (1) if (r + c) is even.\n    Change the pixel to yellow (4) if (r + c) is odd.\n  - If the pattern colors are green (3) and red (2):\n    Change the pixel to red (2) if (r + c) is even.\n    Change the pixel to green (3) if (r + c) is odd.\nLeave all other pixels unchanged.\n\"\"\"\n\ndef has_neighbor_color(grid, r, c, color):\n    \"\"\"\n    Checks if cell (r, c) has any neighbor (including diagonals) \n    with the specified color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        r (int): Row index of the cell.\n        c (int): Column index of the cell.\n        color (int): The color to check for in neighbors.\n\n    Returns:\n        bool: True if a neighbor with the specified color exists, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    # Iterate through the 3x3 neighborhood centered at (r, c)\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center cell itself\n            if dr == 0 and dc == 0:\n                continue\n            \n            # Calculate neighbor coordinates\n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor coordinates are within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor has the target color\n                if grid[nr, nc] == color:\n                    return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a checkerboard pattern fill to background pixels adjacent to a main structure.\n    The specific pattern colors (blue/yellow or green/red) and their assignment based \n    on coordinate parity depend on the non-structure colors present in the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- Perception and Analysis ---\n\n    # Find unique non-background (0) colors present in the grid\n    unique_colors = np.unique(input_grid[input_grid != 0])\n\n    # Handle edge cases: if only background or only one non-background color exists,\n    # no transformation based on patterns is possible.\n    if len(unique_colors) <= 1:\n        # print(\"Edge case: No pattern colors found or only structure color exists.\")\n        return output_grid \n\n    # Identify the structure color - assumed to be the most frequent non-zero color\n    counts = {color: np.sum(input_grid == color) for color in unique_colors}\n    structure_color = max(counts, key=counts.get)\n    # print(f\"Identified structure color: {structure_color}\")\n\n    # Identify the pattern colors (non-structure, non-background)\n    pattern_colors = {c for c in unique_colors if c != structure_color}\n    # print(f\"Identified potential pattern colors: {pattern_colors}\")\n\n    # Determine which pattern set to use (1/4 or 3/2) based on presence\n    use_pattern_1_4 = 1 in pattern_colors or 4 in pattern_colors\n    use_pattern_3_2 = 3 in pattern_colors or 2 in pattern_colors\n\n    # If neither pattern set is indicated, return the original grid\n    if not use_pattern_1_4 and not use_pattern_3_2:\n         # print(\"No identifiable pattern color set (1/4 or 3/2) found.\")\n         return output_grid\n\n    # --- Transformation ---\n    \n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # Focus on background pixels (color 0)\n            if input_grid[r, c] == 0:\n                # Check if this background pixel is adjacent to the structure color\n                if has_neighbor_color(input_grid, r, c, structure_color):\n                    # Calculate the parity of the coordinate sum (0 for even, 1 for odd)\n                    parity = (r + c) % 2\n\n                    # Apply the determined pattern based on parity\n                    if use_pattern_1_4:\n                       # Pattern blue(1)/yellow(4): Even sum -> blue(1), Odd sum -> yellow(4)\n                       output_grid[r, c] = 1 if parity == 0 else 4\n                    elif use_pattern_3_2:\n                       # Pattern green(3)/red(2): Even sum -> red(2), Odd sum -> green(3)\n                       output_grid[r, c] = 2 if parity == 0 else 3\n                       \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2866,
    "candidates_token_count": 1327,
    "total_token_count": 4193,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 128.203553,
  "retries": null
}