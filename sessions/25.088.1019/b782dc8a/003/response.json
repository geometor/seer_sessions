{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFill specific background (White/0) areas adjacent to a main structure (most frequent non-background color) with a checkerboard pattern. \nThe filling starts from existing 'seed' pixels (pixels with the pattern colors) in the input grid.\nThe checkerboard pattern colors are determined by the seed pixels: either Blue(1)/Yellow(4) or Red(2)/Green(3).\nThe specific color applied to a background pixel depends on the parity of the sum of its coordinates (row + col).\nA background pixel is filled only if it's adjacent (8-connectivity) to the structure color AND adjacent to a pixel that is already part of the growing pattern (either a seed or a previously filled pixel).\n\"\"\"\n\ndef is_valid(r, c, rows, cols):\n    \"\"\"Checks if coordinates (r, c) are within the grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef has_neighbor_color(grid, r, c, color, rows, cols):\n    \"\"\"\n    Checks if cell (r, c) has any neighbor (including diagonals) \n    with the specified color in the given grid.\n    \"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if is_valid(nr, nc, rows, cols) and grid[nr, nc] == color:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a checkerboard pattern flood fill to background pixels adjacent \n    to a main structure, starting from seed pixels.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    background_color = 0\n\n    # --- 1. Analyze Input ---\n    \n    # Find unique non-background colors and their counts\n    unique_colors, counts = np.unique(input_grid[input_grid != background_color], return_counts=True)\n    \n    # Handle edge case: No non-background colors or only one type\n    if len(unique_colors) <= 1:\n        return output_grid # Nothing to pattern or no seeds\n\n    # Determine the structure_color (most frequent non-background)\n    color_counts = dict(zip(unique_colors, counts))\n    structure_color = max(color_counts, key=color_counts.get)\n\n    # Identify pattern colors (seeds) and their locations\n    pattern_colors = set()\n    seed_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            if color != background_color and color != structure_color:\n                pattern_colors.add(color)\n                seed_pixels.append((r, c))\n\n    # Handle edge case: No seed pixels found\n    if not seed_pixels:\n        return output_grid\n\n    # Determine the pattern_type based on present pattern colors\n    use_pattern_1_4 = 1 in pattern_colors or 4 in pattern_colors\n    use_pattern_3_2 = 3 in pattern_colors or 2 in pattern_colors\n\n    # Handle edge case: Pattern colors don't match expected pairs\n    if not use_pattern_1_4 and not use_pattern_3_2:\n         return output_grid\n\n    # --- 2. Initialize Fill Process ---\n    \n    process_queue = deque(seed_pixels)\n    # visited_coords stores coordinates of background pixels that have been \n    # processed (colored) or added to the queue. Seed pixels are not background,\n    # so they aren't added here initially, only their background neighbors will be.\n    visited_coords = set() \n\n    # --- 3. Flood Fill Execution ---\n    \n    while process_queue:\n        r, c = process_queue.popleft()\n\n        # Examine 8 neighbors of the current pixel (from the queue)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                \n                nr, nc = r + dr, c + dc\n\n                # Check Validity: Within grid bounds?\n                if not is_valid(nr, nc, rows, cols):\n                    continue\n\n                # Check Target: Is it a background pixel in the *original* grid?\n                if input_grid[nr, nc] != background_color:\n                    continue\n\n                # Check Visited: Has this background pixel already been processed?\n                if (nr, nc) in visited_coords:\n                    continue\n\n                # Check Structure Adjacency: Is it adjacent to the structure color?\n                if not has_neighbor_color(input_grid, nr, nc, structure_color, rows, cols):\n                    continue\n                    \n                # --- Fill and Enqueue ---\n                # Mark as visited *before* adding to queue\n                visited_coords.add((nr, nc)) \n\n                # Calculate parity\n                parity = (nr + nc) % 2\n\n                # Determine fill color based on pattern type and parity\n                fill_color = -1 # Default invalid color\n                if use_pattern_1_4:\n                    # Pattern blue(1)/yellow(4): Even sum -> blue(1), Odd sum -> yellow(4)\n                    fill_color = 1 if parity == 0 else 4\n                elif use_pattern_3_2:\n                    # Pattern green(3)/red(2): Even sum -> red(2), Odd sum -> green(3)\n                    fill_color = 2 if parity == 0 else 3\n                \n                # Update the output grid\n                output_grid[nr, nc] = fill_color\n                \n                # Add the newly colored background pixel to the queue \n                # so its neighbors can be checked\n                process_queue.append((nr, nc))\n\n    # --- 4. Return Output ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8293,
    "candidates_token_count": 1447,
    "total_token_count": 9740,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.000946,
  "retries": null
}