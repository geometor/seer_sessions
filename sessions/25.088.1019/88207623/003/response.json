{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on vertical red lines and associated fill colors.\n\n1. Find unique 'fill colors' (not white=0, red=2, yellow=4) in scan order (top-to-bottom, left-to-right).\n2. Find all distinct, contiguous, vertical segments composed only of red (2) pixels. Record each segment's column index, start row, and end row.\n3. Sort the red segments first by their start row index (ascending) and then by their column index (ascending).\n4. Associate the sorted red segments with the identified fill colors sequentially. The i-th segment corresponds to the i-th fill color.\n5. For each associated (segment, fill_color) pair:\n   a. Determine the fill side (left or right of the red segment). Count the number of fillable pixels (white=0 or yellow=4) immediately to the left (in column segment_col - 1) and immediately to the right (in column segment_col + 1) of the segment, but only considering rows spanned by the segment (from start_row to end_row).\n   b. If the count on the right is greater than the count on the left, the fill direction is RIGHT.\n   c. If the count on the left is greater than the count on the right, the fill direction is LEFT.\n   d. If the counts are equal and non-zero, the fill direction is RIGHT (tie-breaker).\n   e. If both counts are zero, or the chosen fill side is outside the grid, no fill operation is performed for this segment.\n6. Perform a flood fill operation on the chosen side:\n   a. Identify the initial \"seed\" pixels for the flood fill. These are the pixels in the column immediately adjacent to the red segment on the determined fill side (column segment_col + direction), within the segment's row bounds (start_row to end_row). Only include seeds that are initially fillable (white=0 or yellow=4).\n   b. If there are no valid seed pixels, skip the fill operation for this segment.\n   c. Starting from the seed pixels, perform a flood fill:\n      i. Use a queue and a set to track visited pixels for this specific fill operation.\n      ii. Change the color of fillable pixels (white=0 or yellow=4) encountered during the fill to the associated `fill_color`.\n      iii. The flood fill propagates horizontally and vertically (up, down, left, right) to adjacent pixels.\n      iv. The fill is constrained: it only affects pixels whose row index is within the original red segment's row bounds (start_row to end_row).\n      v. The fill stops at pixels that are not fillable (i.e., not white=0 or yellow=4) or are outside the vertical bounds.\n7. Return the modified grid.\n\"\"\"\n\ndef find_fill_colors(grid):\n    \"\"\"\n    Finds unique fill colors (not 0, 2, or 4) in scan order.\n    \"\"\"\n    fill_colors = []\n    seen_colors = set()\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Fill colors are those not white(0), red(2), or yellow(4)\n            if color not in {0, 2, 4} and color not in seen_colors:\n                fill_colors.append(color)\n                seen_colors.add(color)\n    return fill_colors\n\ndef find_red_segments(grid):\n    \"\"\"\n    Finds all vertical red (2) segments and returns them as a list of dicts:\n    {'col': c, 'start_row': start_row, 'end_row': end_row}.\n    Segments are sorted by start_row, then col.\n    \"\"\"\n    rows, cols = grid.shape\n    segments = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the cell is red and not yet part of a found segment\n            if grid[r, c] == 2 and not visited[r, c]:\n                # Found the potential start of a vertical segment\n                start_row = r\n                end_row = r\n                # Explore downwards to find the end of the segment\n                while end_row + 1 < rows and grid[end_row + 1, c] == 2:\n                    end_row += 1\n\n                # Mark the cells of this segment as visited\n                for row_idx in range(start_row, end_row + 1):\n                    if row_idx < rows: # Boundary check is technically redundant due to loop condition, but safe\n                       visited[row_idx, c] = True\n\n                # Store the segment information\n                segments.append({'col': c, 'start_row': start_row, 'end_row': end_row})\n\n    # Sort segments primarily by start_row, secondarily by col\n    segments.sort(key=lambda s: (s['start_row'], s['col']))\n    return segments\n\ndef flood_fill(grid, seeds, fill_color, segment_row_bounds, fillable_colors):\n    \"\"\"\n    Performs a flood fill on the grid, constrained vertically.\n    Modifies the grid in place.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque(seeds)\n    visited = set(seeds) # Initialize visited with seeds\n\n    min_row, max_row = segment_row_bounds\n\n    while q:\n        r, c = q.popleft()\n\n        # Current cell must be fillable (already checked for seeds, check again for neighbors)\n        # This check should happen *before* filling\n        # if grid[r, c] not in fillable_colors: # This check is implicitly handled by neighbor check\n        #    continue\n\n        # Fill the current cell\n        grid[r, c] = fill_color\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check grid bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue\n\n            # Check vertical constraint (within segment rows)\n            if not (min_row <= nr <= max_row):\n                 continue\n\n            # Check if fillable color\n            if grid[nr, nc] not in fillable_colors:\n                continue\n\n            # Check if already visited for this specific flood fill\n            if (nr, nc) in visited:\n                continue\n\n            # Add to queue and mark visited\n            visited.add((nr, nc))\n            q.append((nr, nc))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on red lines and fill colors.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    fillable_colors = {0, 4} # Colors that can be replaced by the fill\n\n    # 1. Find fill colors in scan order\n    fill_colors = find_fill_colors(input_grid)\n\n    # 2. & 3. Find and sort vertical red segments\n    red_segments = find_red_segments(input_grid)\n\n    # 4. Associate segments with fill colors\n    num_segments = len(red_segments)\n    num_colors = len(fill_colors)\n\n    # Iterate through matched pairs of segments and colors\n    for i in range(min(num_segments, num_colors)):\n        segment = red_segments[i]\n        fill_color = fill_colors[i]\n\n        seg_col = segment['col']\n        start_row = segment['start_row']\n        end_row = segment['end_row']\n        segment_row_bounds = (start_row, end_row) # For flood fill constraint\n\n        # 5. Determine fill side based on adjacent fillable pixels\n        count_left = 0\n        left_col = seg_col - 1\n        if 0 <= left_col < cols:\n            for r in range(start_row, end_row + 1):\n                # Check against the *current state* of output_grid, as previous fills might change things\n                # Although, fillable check {0,4} should be based on initial state? No, examples imply fill stops at boundaries created by prior fills. So use output_grid.\n                if output_grid[r, left_col] in fillable_colors:\n                    count_left += 1\n\n        count_right = 0\n        right_col = seg_col + 1\n        if 0 <= right_col < cols:\n             for r in range(start_row, end_row + 1):\n                 if output_grid[r, right_col] in fillable_colors:\n                     count_right += 1\n\n        direction = 0 # Default: no fill\n        if count_right > count_left:\n            direction = 1 # Fill Right\n        elif count_left > count_right:\n            direction = -1 # Fill Left\n        # Tie-breaker: If counts are equal AND non-zero, fill Right\n        elif count_left == count_right and count_right > 0:\n             direction = 1 # Fill Right\n\n        # If no direction determined (e.g., both counts 0, or segment at edge), skip\n        if direction == 0:\n            continue\n\n        # 6. Prepare seeds and perform flood fill\n        start_fill_col = seg_col + direction\n\n        # Check if the starting column for the fill is within grid bounds\n        if not (0 <= start_fill_col < cols):\n             continue\n\n        seeds = []\n        for r in range(start_row, end_row + 1):\n             # Add point as a seed only if it's within bounds and initially fillable in the target column\n             if output_grid[r, start_fill_col] in fillable_colors:\n                 seeds.append((r, start_fill_col))\n\n        # If there are valid starting points for the fill\n        if seeds:\n            # Perform the flood fill, modifying output_grid in place\n            flood_fill(output_grid, seeds, fill_color, segment_row_bounds, fillable_colors)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5541,
    "candidates_token_count": 2409,
    "total_token_count": 7950,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.439386,
  "retries": null
}