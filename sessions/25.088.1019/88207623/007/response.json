{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by performing flood fills adjacent to vertical red lines.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Find unique 'fill colors' by scanning the input grid (top-to-bottom, left-to-right). Fill colors are any color other than white (0), red (2), or yellow (4). Store them in the order they appear.\n3. Find all distinct, contiguous, vertical segments composed only of red (2) pixels in the input grid. Record each segment's column index, start row, and end row.\n4. Sort the red segments first by their start row index (ascending) and then by their column index (ascending).\n5. Associate the Nth sorted red segment with the Nth found fill color.\n6. For each associated (segment, fill_color) pair:\n    a. Determine the fill side (left or right) by counting white (0) pixels in the *input grid* immediately adjacent to the segment (left column vs. right column), within the segment's row bounds (start_row to end_row).\n    b. Fill on the side with more adjacent white pixels. If counts are equal and non-zero, fill right (tie-breaker). If counts are zero, or the chosen side is off-grid, do nothing for this segment.\n    c. Identify initial 'seed' pixels for the fill. These are pixels `(r, c)` where `c` is the adjacent column on the chosen fill side, `r` is within the segment's row bounds, `input_grid[r, c]` is white (0), and `output_grid[r, c]` is currently white (0).\n    d. If seed pixels exist, perform a flood fill on the `output_grid` starting from these seeds using the `fill_color`.\n    e. The flood fill propagates horizontally and vertically to adjacent pixels `(nr, nc)`.\n    f. A pixel `(nr, nc)` is filled (changed to `fill_color` in the `output_grid`) *only if* it is within the grid boundaries AND the corresponding pixel `input_grid[nr, nc]` was originally white (0). Non-white pixels in the input grid act as boundaries.\n7. Return the modified output grid.\n\"\"\"\n\ndef find_fill_colors(grid):\n    \"\"\"\n    Finds unique fill colors (not 0, 2, or 4) in scan order.\n    \"\"\"\n    fill_colors = []\n    seen_colors = set()\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Fill colors are those not white(0), red(2), or yellow(4)\n            if color not in {0, 2, 4} and color not in seen_colors:\n                fill_colors.append(color)\n                seen_colors.add(color)\n    return fill_colors\n\ndef find_red_segments(grid):\n    \"\"\"\n    Finds all vertical red (2) segments and returns them as a list of dicts:\n    {'col': c, 'start_row': start_row, 'end_row': end_row}.\n    Segments are sorted by start_row, then col.\n    \"\"\"\n    rows, cols = grid.shape\n    segments = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the cell is red and not yet part of a found segment\n            if grid[r, c] == 2 and not visited[r, c]:\n                # Found the potential start of a vertical segment\n                start_row = r\n                end_row = r\n                # Explore downwards to find the end of the segment\n                while end_row + 1 < rows and grid[end_row + 1, c] == 2:\n                    end_row += 1\n\n                # Mark the cells of this segment as visited\n                for row_idx in range(start_row, end_row + 1):\n                    if row_idx < rows:\n                       visited[row_idx, c] = True\n\n                # Store the segment information\n                segments.append({'col': c, 'start_row': start_row, 'end_row': end_row})\n\n    # Sort segments primarily by start_row, secondarily by col\n    segments.sort(key=lambda s: (s['start_row'], s['col']))\n    return segments\n\ndef flood_fill(output_grid, seeds, fill_color, input_grid):\n    \"\"\"\n    Performs a flood fill on the output_grid, constrained by non-white pixels\n    in the input_grid. Modifies output_grid in place.\n    \"\"\"\n    rows, cols = output_grid.shape\n    if not seeds: # No starting points\n        return\n\n    q = deque(seeds)\n    # Keep track of visited cells for *this specific fill operation*\n    # Initialize visited with the seeds themselves\n    visited_this_fill = set(seeds)\n\n    while q:\n        r, c = q.popleft()\n\n        # Fill the current cell *in the output grid*\n        # Check if it's still white (though seeds should guarantee this initially)\n        # This check is mainly for safety if seeds could overlap strangely,\n        # but primarily the propagation logic below handles boundaries.\n        # We rely on the fact that seeds were already checked against input_grid == 0\n        # and output_grid == 0.\n        if output_grid[r,c] == 0: # Check if it hasn't been filled by this *same* fill process already (handled by visited) or a *prior* fill process\n            output_grid[r, c] = fill_color\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check grid bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue\n\n            # Check if the neighbor *in the input grid* is fillable (white=0)\n            if input_grid[nr, nc] != 0:\n                continue\n\n            # Check if already visited *for this specific flood fill*\n            if (nr, nc) in visited_this_fill:\n                continue\n\n            # Check if the neighbor in the output grid hasn't *already* been\n            # filled by a *previous* fill operation (or is a non-white original pixel)\n            # This prevents re-filling or filling over other colors.\n            if output_grid[nr, nc] != 0:\n                 continue\n\n            # Add valid neighbor to queue and mark visited for this fill\n            visited_this_fill.add((nr, nc))\n            q.append((nr, nc))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the flood fill transformation based on red lines and fill colors.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    fillable_color = 0 # Explicitly state that only white is fillable\n\n    # 2. Find fill colors in scan order\n    fill_colors = find_fill_colors(input_grid)\n\n    # 3. & 4. Find and sort vertical red segments\n    red_segments = find_red_segments(input_grid)\n\n    # 5. Associate segments with fill colors and process\n    num_segments = len(red_segments)\n    num_colors = len(fill_colors)\n\n    # Iterate through matched pairs of segments and colors\n    for i in range(min(num_segments, num_colors)):\n        segment = red_segments[i]\n        fill_color = fill_colors[i]\n\n        seg_col = segment['col']\n        start_row = segment['start_row']\n        end_row = segment['end_row']\n\n        # 6a. Determine fill side based on adjacent WHITE pixels in the ORIGINAL grid\n        count_left = 0\n        left_col = seg_col - 1\n        if 0 <= left_col < cols:\n            for r in range(start_row, end_row + 1):\n                 # Check against the *original input grid* and only count white (0)\n                 if 0 <= r < rows and input_grid[r, left_col] == fillable_color:\n                    count_left += 1\n\n        count_right = 0\n        right_col = seg_col + 1\n        if 0 <= right_col < cols:\n             for r in range(start_row, end_row + 1):\n                 # Check against the *original input grid* and only count white (0)\n                 if 0 <= r < rows and input_grid[r, right_col] == fillable_color:\n                     count_right += 1\n\n        # 6b. Decide direction\n        direction = 0 # Default: no fill\n        if count_right > count_left:\n            direction = 1 # Fill Right\n        elif count_left > count_right:\n            direction = -1 # Fill Left\n        # Tie-breaker: If counts are equal AND non-zero, fill Right\n        elif count_left == count_right and count_right > 0:\n             direction = 1 # Fill Right\n\n        # If no direction determined or side off-grid, skip\n        if direction == 0:\n            continue\n\n        fill_side_col = seg_col + direction\n        if not (0 <= fill_side_col < cols):\n             continue\n\n        # 6c. Identify seed pixels\n        seeds = []\n        for r in range(start_row, end_row + 1):\n             # Check row bounds (redundant due to loop, but safe)\n             if 0 <= r < rows:\n                 # Seed must be originally white in input\n                 if input_grid[r, fill_side_col] == fillable_color:\n                     # Seed must also be currently white in output (not filled previously)\n                     if output_grid[r, fill_side_col] == fillable_color:\n                         seeds.append((r, fill_side_col))\n\n        # 6d. & 6e. & 6f. Perform flood fill if seeds exist\n        if seeds:\n            # Perform the flood fill, modifying output_grid in place\n            # The fill uses input_grid to check boundaries/fillable areas\n            flood_fill(output_grid, seeds, fill_color, input_grid)\n\n    # 7. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10004,
    "candidates_token_count": 2474,
    "total_token_count": 12478,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.882875,
  "retries": null
}