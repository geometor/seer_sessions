{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a red '+' shape in the input grid.\nPreserves the original red cross in the output grid.\nDraws lines radiating outwards from the cross towards the grid boundaries.\n- Diagonal lines starting from the corners adjacent to the cross are drawn in blue (1).\n- Orthogonal lines starting from the pixels adjacent to the central arms of the cross are drawn with a repeating pattern of Azure (8), Azure (8), Yellow (4).\nLines only overwrite white (0) background pixels.\n\"\"\"\n\ndef find_cross_center(grid):\n    \"\"\"Finds the center pixel of the red '+' cross.\"\"\"\n    red_pixels = np.where(grid == 2)\n    if not red_pixels or len(red_pixels[0]) == 0:\n        # Handle cases where no red pixels are found (optional, based on task constraints)\n        return None \n\n    # Iterate through potential centers (red pixels)\n    for r, c in zip(red_pixels[0], red_pixels[1]):\n        # Check for 4 red neighbours within bounds\n        is_center = True\n        height, width = grid.shape\n        # Check North\n        if r == 0 or grid[r-1, c] != 2: is_center = False\n        # Check South\n        if r == height - 1 or grid[r+1, c] != 2: is_center = False\n        # Check West\n        if c == 0 or grid[r, c-1] != 2: is_center = False\n        # Check East\n        if c == width - 1 or grid[r, c+1] != 2: is_center = False\n        \n        if is_center:\n            return (r, c)\n            \n    # Fallback or error if no center is found (might indicate malformed input)\n    # For ARC, we can often assume valid input structure based on examples.\n    # Let's try a simpler approach if the strict center check fails: find the mean coordinate.\n    if len(red_pixels[0]) > 0:\n        center_r = int(np.round(np.mean(red_pixels[0])))\n        center_c = int(np.round(np.mean(red_pixels[1])))\n        # Verify if this calculated center is indeed red\n        if grid[center_r, center_c] == 2:\n             return (center_r, center_c)\n\n    return None # Indicate failure to find a suitable center\n\ndef draw_line(grid, start_r, start_c, dr, dc, color=None, pattern=None):\n    \"\"\"\n    Draws a line on the grid starting from (start_r, start_c) moving in direction (dr, dc).\n    Can draw a single color line or a patterned line.\n    Only overwrites white (0) pixels.\n    \"\"\"\n    height, width = grid.shape\n    r, c = start_r + dr, start_c + dc  # Start drawing from the next pixel\n    k = 0 # Pattern counter\n\n    while 0 <= r < height and 0 <= c < width:\n        if grid[r, c] == 0: # Only draw on white background\n            k += 1\n            if pattern:\n                current_color = pattern[(k - 1) % len(pattern)]\n                grid[r, c] = current_color\n            elif color is not None:\n                grid[r, c] = color\n            else:\n                 # Should not happen if called correctly\n                 break \n        \n        # Stop if we hit a non-background pixel along the path? \n        # The examples suggest lines extend fully to boundary regardless of intermediate colors.\n        # So, continue moving even if we don't draw.\n        \n        r += dr\n        c += dc\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: find red cross, draw radiating lines.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Start with a copy of the input\n    height, width = grid.shape\n\n    # Find the center of the red cross\n    center = find_cross_center(grid)\n    if center is None:\n        # If no center found, return the original grid (or handle as error)\n        return input_grid \n\n    center_r, center_c = center\n\n    # Define colors and patterns\n    blue_color = 1\n    orthogonal_pattern = [8, 8, 4] # Azure, Azure, Yellow\n\n    # Define starting points relative to the center for the pixel *adjacent* to the 3x3 box\n    # These are the points *from* which the drawing starts in the given direction\n    start_points_directions = [\n        # Diagonals (Blue)\n        ((center_r - 1, center_c - 1), (-1, -1), blue_color, None), # Up-Left\n        ((center_r - 1, center_c + 1), (-1, +1), blue_color, None), # Up-Right\n        ((center_r + 1, center_c - 1), (+1, -1), blue_color, None), # Down-Left\n        ((center_r + 1, center_c + 1), (+1, +1), blue_color, None), # Down-Right\n        # Orthogonals (Pattern)\n        ((center_r - 1, center_c), (-1, 0), None, orthogonal_pattern), # Up\n        ((center_r + 1, center_c), (+1, 0), None, orthogonal_pattern), # Down\n        ((center_r, center_c - 1), (0, -1), None, orthogonal_pattern), # Left\n        ((center_r, center_c + 1), (0, +1), None, orthogonal_pattern), # Right\n    ]\n\n    # Draw all the lines\n    for (start_r, start_c), (dr, dc), color, pattern in start_points_directions:\n         # Check if start point itself is valid before calling draw_line\n         if 0 <= start_r < height and 0 <= start_c < width:\n             draw_line(output_grid, start_r, start_c, dr, dc, color=color, pattern=pattern)\n\n\n    # Convert back to list of lists for standard ARC output format\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3511,
    "candidates_token_count": 1497,
    "total_token_count": 5008,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.563595,
  "retries": null
}