{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a red '+' shape in the input grid.\nPreserves the original red cross in the output grid.\nDraws 8 lines radiating outwards from the pixels adjacent to the cross center towards the grid boundaries.\n- Diagonal lines starting from the pixels diagonally adjacent to the cross center are drawn in blue (1).\n- Orthogonal lines starting from the pixels orthogonally adjacent to the cross center are drawn with a repeating pattern of Azure (8), Azure (8), Yellow (4).\nLines only overwrite white (0) background pixels. The starting pixel of the line is colored first, then the line continues outwards.\n\"\"\"\n\ndef find_cross_center(grid):\n    \"\"\"\n    Finds the center pixel (row, col) of the red '+' cross.\n    The center is defined as the red pixel with 4 adjacent red neighbors.\n    Returns None if no such center is found.\n    \"\"\"\n    red_pixels = np.argwhere(grid == 2)\n    if len(red_pixels) < 5: # A '+' shape needs at least 5 red pixels\n        return None\n\n    height, width = grid.shape\n\n    for r, c in red_pixels:\n        # Check for 4 red neighbours within bounds\n        neighbor_count = 0\n        # Check North\n        if r > 0 and grid[r-1, c] == 2: neighbor_count += 1\n        # Check South\n        if r < height - 1 and grid[r+1, c] == 2: neighbor_count += 1\n        # Check West\n        if c > 0 and grid[r, c-1] == 2: neighbor_count += 1\n        # Check East\n        if c < width - 1 and grid[r, c+1] == 2: neighbor_count += 1\n\n        if neighbor_count == 4:\n             # Check if the center itself is red (already guaranteed by loop, but good practice)\n             if grid[r,c] == 2:\n                 return (r, c)\n\n    return None # Indicate failure to find a suitable center\n\n\ndef draw_line(grid, start_r, start_c, dr, dc, color=None, pattern=None):\n    \"\"\"\n    Draws a line on the grid starting *at* (start_r, start_c) and moving \n    in direction (dr, dc).\n    Can draw a single color line or a patterned line.\n    Only overwrites white (0) pixels.\n    Modifies the grid in place.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Check if the starting point is valid and is white\n    k = 0 # Pattern counter\n    if 0 <= start_r < height and 0 <= start_c < width and grid[start_r, start_c] == 0:\n        if pattern:\n            current_color = pattern[k % len(pattern)]\n            grid[start_r, start_c] = current_color\n            k += 1\n        elif color is not None:\n            grid[start_r, start_c] = color\n        # If neither color nor pattern provided, or start isn't white, nothing happens to start pixel\n\n    # Continue drawing from the next pixel\n    r, c = start_r + dr, start_c + dc\n\n    while 0 <= r < height and 0 <= c < width:\n        if grid[r, c] == 0: # Only draw on white background\n            if pattern:\n                current_color = pattern[k % len(pattern)]\n                grid[r, c] = current_color\n                k += 1 # Increment pattern counter only when drawing\n            elif color is not None:\n                grid[r, c] = color\n            else:\n                 # Should not happen if called correctly\n                 break \n        \n        # Always move to the next pixel regardless of whether we drew\n        r += dr\n        c += dc\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: find red cross, draw radiating lines.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Initialize output_grid as a copy of the input\n    height, width = grid.shape\n\n    # Find the center of the red cross\n    center = find_cross_center(output_grid) # Use output_grid as it will be modified\n    if center is None:\n        # If no center found, return the original grid \n        # (as per ARC behavior, avoid crashing)\n        return input_grid \n\n    center_r, center_c = center\n\n    # Define colors and patterns\n    blue_color = 1\n    orthogonal_pattern = [8, 8, 4] # Azure, Azure, Yellow\n\n    # Define starting points *and* directions relative to the center.\n    # The start point is the pixel immediately adjacent to the center.\n    # The direction is the vector pointing away from the center.\n    # Format: ((start_r, start_c), (dr, dc), color, pattern)\n    lines_to_draw = [\n        # Diagonals (Blue) - Start points are diagonal neighbors of the center\n        ((center_r - 1, center_c - 1), (-1, -1), blue_color, None), # Up-Left\n        ((center_r - 1, center_c + 1), (-1, +1), blue_color, None), # Up-Right\n        ((center_r + 1, center_c - 1), (+1, -1), blue_color, None), # Down-Left\n        ((center_r + 1, center_c + 1), (+1, +1), blue_color, None), # Down-Right\n        # Orthogonals (Pattern) - Start points are orthogonal neighbors of the center\n        ((center_r - 1, center_c), (-1, 0), None, orthogonal_pattern), # Up\n        ((center_r + 1, center_c), (+1, 0), None, orthogonal_pattern), # Down\n        ((center_r, center_c - 1), (0, -1), None, orthogonal_pattern), # Left\n        ((center_r, center_c + 1), (0, +1), None, orthogonal_pattern), # Right\n    ]\n\n    # Draw all the lines\n    for (start_r, start_c), (dr, dc), color, pattern in lines_to_draw:\n         # draw_line handles boundary checks for the start point internally\n         draw_line(output_grid, start_r, start_c, dr, dc, color=color, pattern=pattern)\n\n    # Convert back to list of lists for standard ARC output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8539,
    "candidates_token_count": 1565,
    "total_token_count": 10104,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.806719,
  "retries": null
}