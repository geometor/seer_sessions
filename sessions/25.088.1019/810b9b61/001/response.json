{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct blue (1) objects in the input grid.\nFor each blue object, checks if it contains at least one internal 'hole' \n(a white (0) pixel completely surrounded by pixels of that same object using 4-way adjacency).\nIf an object contains a hole, all its pixels are recolored to green (3) in the output grid.\nObjects without holes remain blue (1). The background (0) remains unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all distinct connected objects of a given color in the grid using BFS.\n    Connectivity is based on 4-way adjacency (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a single connected object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel is the target color and hasn't been visited yet, start BFS\n            if grid[r, c] == color and (r, c) not in visited:\n                current_object = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    current_object.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Add the found object to the list\n                if current_object:\n                    objects.append(current_object)\n    return objects\n\ndef has_hole(grid, object_coords):\n    \"\"\"\n    Checks if a given object contains an internal hole (a white pixel surrounded by object pixels).\n\n    Args:\n        grid (np.array): The input grid.\n        object_coords (set): A set of (row, col) tuples representing the object.\n\n    Returns:\n        bool: True if the object contains at least one hole, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # We need to find a white pixel (0) such that all its 4 neighbors\n    # are part of the *current* object_coords.\n    \n    # An efficient way is to check potential hole locations.\n    # A potential hole location is adjacent to an object pixel.\n    potential_holes = set()\n    for r, c in object_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n             nr, nc = r + dr, c + dc\n             if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                 potential_holes.add((nr, nc))\n\n    # Check each potential hole\n    for r_hole, c_hole in potential_holes:\n        is_hole = True\n        neighbors = []\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_hole + dr, c_hole + dc\n            # Check if neighbor is within bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                is_hole = False # Hole touches the boundary, not internal\n                break\n            neighbors.append((nr, nc))\n            \n        if not is_hole:\n            continue\n\n        # Check if all neighbors are part of the *current* object\n        all_neighbors_in_object = True\n        for nr, nc in neighbors:\n            if (nr, nc) not in object_coords:\n                all_neighbors_in_object = False\n                break\n        \n        if all_neighbors_in_object:\n            return True # Found a hole\n\n    return False # No holes found for this object\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring blue objects with holes to green.\n\n    Args:\n        input_grid (np.array): The input 2D numpy array.\n\n    Returns:\n        np.array: The transformed 2D numpy array.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Define the colors involved\n    blue = 1\n    green = 3\n    white = 0 # Background and potential hole color\n\n    # Find all distinct blue objects\n    blue_objects = find_objects(input_grid, blue)\n\n    # Iterate through each identified blue object\n    for obj_coords in blue_objects:\n        # Check if the current object has an internal hole\n        if has_hole(input_grid, obj_coords):\n            # If it has a hole, recolor all pixels of this object to green in the output grid\n            for r, c in obj_coords:\n                output_grid[r, c] = green\n        # If it doesn't have a hole, it remains blue (already copied)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4120,
    "candidates_token_count": 1319,
    "total_token_count": 5439,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 97.688048,
  "retries": null
}