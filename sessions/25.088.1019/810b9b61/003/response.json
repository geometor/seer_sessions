{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct blue (1) objects in the input grid using 4-way adjacency.\nDetermines if a blue object encloses an area of white (0) pixels. An enclosure means\nthere are white pixels adjacent to the object that cannot reach the grid boundary\nby moving only through other white pixels (4-way adjacency).\nIf a blue object encloses a white area (contains a 'hole'), all its pixels are \nrecolored to green (3) in the output grid.\nBlue objects that do not enclose any white area remain blue (1).\nAll other pixels (including the background) remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all distinct connected objects of a given color in the grid using BFS.\n    Connectivity is based on 4-way adjacency (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a single connected object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel is the target color and hasn't been visited yet, start BFS\n            if grid[r, c] == color and (r, c) not in visited:\n                current_object = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_object.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check 4 neighbors\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_object.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Add the found object to the list\n                objects.append(current_object)\n    return objects\n\ndef find_external_white_pixels(grid):\n    \"\"\"\n    Finds all white pixels connected to the grid boundary using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        set: A set of (row, col) tuples representing external white pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    white = 0\n    external_white = set()\n    visited = set()\n    q = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up\n\n    # Add all boundary white pixels to the queue and sets\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and Right boundaries\n            if grid[r, c] == white and (r, c) not in visited:\n                visited.add((r, c))\n                external_white.add((r, c))\n                q.append((r, c))\n    for c in range(cols):\n        for r in [0, rows - 1]: # Top and Bottom boundaries\n             if grid[r, c] == white and (r, c) not in visited:\n                visited.add((r, c))\n                external_white.add((r, c))\n                q.append((r, c))\n\n    # Perform BFS from boundary white pixels\n    while q:\n        r, c = q.popleft()\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            # Check bounds, color, and visited status\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == white and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                external_white.add((nr, nc))\n                q.append((nr, nc))\n\n    return external_white\n\n\ndef check_for_internal_hole(grid, object_coords, external_white):\n    \"\"\"\n    Checks if any pixel of the object is adjacent to an internal white pixel.\n\n    Args:\n        grid (np.array): The input grid.\n        object_coords (set): Coordinates of the object's pixels.\n        external_white (set): Coordinates of white pixels connected to the boundary.\n\n    Returns:\n        bool: True if the object is adjacent to an internal white pixel, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    white = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up\n\n    # Check neighbors of all pixels belonging to the object\n    for r, c in object_coords:\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor is within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is white AND NOT external\n                if grid[nr, nc] == white and (nr, nc) not in external_white:\n                    return True # Found an adjacent internal white pixel\n\n    return False # No adjacent internal white pixels found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring blue objects that enclose white areas to green.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Define colors\n    blue = 1\n    green = 3\n    white = 0\n\n    # Find all distinct blue objects\n    blue_objects = find_objects(input_grid, blue)\n\n    # Find all white pixels connected to the boundary\n    external_white_pixels = find_external_white_pixels(input_grid)\n\n    # Iterate through each identified blue object\n    for obj_coords in blue_objects:\n        # Check if the current object encloses an internal white area (hole)\n        if check_for_internal_hole(input_grid, obj_coords, external_white_pixels):\n            # If it encloses a hole, recolor all pixels of this object to green\n            for r, c in obj_coords:\n                output_grid[r, c] = green\n        # If it doesn't enclose a hole, it remains blue (already copied)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7641,
    "candidates_token_count": 1592,
    "total_token_count": 9233,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.172748,
  "retries": null
}