{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\n1.  **Identify Background:** Determine the most frequent color in the input grid, which is considered the background color.\n2.  **Find Objects:** Locate all contiguous areas (objects) of pixels that are not the background color. For each object, record its color, the set of pixel coordinates it occupies, its bounding box, and its top-left coordinate.\n3.  **Filter Objects:** Select objects for processing based on their color:\n    *   Always ignore objects with colors Gray (5), Orange (7), or Maroon (9).\n    *   If the background color is Azure (8), additionally ignore objects with color Red (2).\n4.  **Sort Objects:** Arrange the filtered (relevant) objects based on their position:\n    *   Primary sort key: Row of the top-left coordinate (ascending).\n    *   Secondary sort key: Column of the top-left coordinate (ascending).\n    *   Conditional Reversal: If the background color is Yellow (4), reverse the order of the sorted objects.\n5.  **Determine Output Dimensions:**\n    *   Calculate the height (`H_i`) of the bounding box for each relevant object `i`.\n    *   The output grid's height (`output_height`) is the sum of all `H_i`.\n    *   The output grid's width (`output_width`) is the maximum value among all `H_i`.\n6.  **Construct Output Grid:**\n    *   Create an output grid with the calculated `output_height` and `output_width`, filled entirely with the background color.\n    *   Iterate through the final sorted list of relevant objects. For each object:\n        *   Determine its bounding box height `h` and width `w`.\n        *   Calculate the horizontal starting position (`start_col`) to center the object's pixels within the `output_width`: `start_col = (output_width - w) // 2`.\n        *   For each pixel `(r, c)` belonging to the current object:\n            *   Calculate its position relative to the object's bounding box top-left corner (`min_r`, `min_c`): `rel_r = r - min_r`, `rel_c = c - min_c`.\n            *   Calculate the target column in the output slice: `target_c = start_col + rel_c`.\n            *   Place the object's color at the corresponding position in the output grid slice for this object (row `current_row + rel_r`, column `target_c`).\n        *   Advance `current_row` by the object's height `h`.\n7.  **Return:** Convert the final NumPy output grid to a list of lists format. If no relevant objects are found after filtering, return an empty grid `[[]]`.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    # Handles empty or invalid input gracefully\n    if grid.size == 0:\n        return 0 # Default to white/black if grid is empty\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Should not happen if grid.size > 0, but safe check\n    # Background is the most frequent color.\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all contiguous objects of non-background colors using Breadth-First Search.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                processed_in_current_object = set([(r,c)]) # Track nodes added to queue\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            # Check if already queued for this object to prevent duplicates\n                           if (nr, nc) not in processed_in_current_object:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                processed_in_current_object.add((nr,nc))\n\n                if obj_pixels:\n                    bounding_box = (min_r, min_c, max_r, max_c)\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': bounding_box,\n                        'top_left': (min_r, min_c),\n                        'height': height,\n                        'width': width\n                    })\n    return objects\n\ndef filter_objects(objects, background_color):\n    \"\"\"Filters objects based on color rules.\"\"\"\n    ignored_colors = {5, 7, 9} # Gray, Orange, Maroon\n    relevant_objects = []\n    for obj in objects:\n        color = obj['color']\n        # Rule 1: Ignore specific colors\n        if color in ignored_colors:\n            continue\n        # Rule 2: Ignore Red if background is Azure\n        if background_color == 8 and color == 2:\n            continue\n        relevant_objects.append(obj)\n    return relevant_objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting, filtering, sorting, and stacking shapes\n    based on the specified rules.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Determine background color\n    background_color = find_background_color(input_np)\n\n    # 2. Find all objects\n    all_objects = find_objects(input_np, background_color)\n\n    # 3. Filter objects\n    relevant_objects = filter_objects(all_objects, background_color)\n\n    # 4. Handle case with no relevant objects\n    if not relevant_objects:\n        return [[]] # Return empty grid as per requirement analysis\n\n    # 5. Sort objects by top-left (row, then column)\n    # Sorting key is a tuple (row, column)\n    sorted_objects = sorted(relevant_objects, key=lambda obj: obj['top_left'])\n\n    # 6. Conditional reverse if background is Yellow (4)\n    if background_color == 4:\n        sorted_objects.reverse()\n\n    final_ordered_objects = sorted_objects\n\n    # 7. Determine output grid dimensions\n    output_height = 0\n    max_object_height = 0\n    if final_ordered_objects: # Ensure list is not empty before calculating max\n      max_object_height = max(obj['height'] for obj in final_ordered_objects)\n\n    output_width = max_object_height # Output width is the max height of relevant objects\n    for obj in final_ordered_objects:\n        output_height += obj['height']\n\n    # Ensure valid dimensions, at least 1x1 if objects exist\n    if output_height <= 0 or output_width <= 0:\n         return [[]] # Or potentially a 1x1 background grid? Empty seems safer.\n\n    # 8. Construct the output grid\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    current_row = 0\n    # 9. Iterate through sorted objects and place them in the output grid\n    for obj in final_ordered_objects:\n        h = obj['height']\n        w = obj['width']\n        min_r, min_c, _, _ = obj['bbox']\n        obj_color = obj['color']\n        pixels = obj['pixels']\n\n        # Calculate starting column for horizontal centering\n        start_col = (output_width - w) // 2\n\n        # Place the object's pixels onto the output grid slice\n        for r, c in pixels:\n            rel_r = r - min_r  # Relative row within the object's bounding box\n            rel_c = c - min_c  # Relative col within the object's bounding box\n\n            target_r = current_row + rel_r\n            target_c = start_col + rel_c\n\n            # Check bounds (should be safe with centering if width calc is right, but good practice)\n            if 0 <= target_r < output_height and 0 <= target_c < output_width:\n                output_grid[target_r, target_c] = obj_color\n\n        # Move to the starting row for the next object\n        current_row += h\n\n    # 10. Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5883,
    "candidates_token_count": 2246,
    "total_token_count": 8129,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 227.311649,
  "retries": null
}