{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nThis program transforms an input grid by extracting specific colored shapes, \nsorting them based on their top-left position (with a conditional reversal if the background is yellow), \nand then stacking their bounding boxes vertically in the output grid.\n\n1. Determine the background color (most frequent color).\n2. Find all contiguous objects (shapes) of colors different from the background.\n3. Filter these objects:\n    - Remove objects with colors Gray(5), Orange(7), or Maroon(9).\n    - If the background color is Azure(8), also remove objects with color Red(2).\n4. For each remaining relevant object, determine its bounding box and top-left coordinate.\n5. Sort the relevant objects primarily by the row of their top-left coordinate, then by the column.\n6. If the background color is Yellow(4), reverse this sorted order.\n7. Calculate the output grid dimensions: width is the maximum width of the bounding boxes, height is the sum of the heights of the bounding boxes.\n8. Construct the output grid by vertically stacking the bounding boxes of the finally ordered objects. Each bounding box area in the output is filled with the background color, and then the pixels of the corresponding object are overlaid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Background is typically the most frequent color.\n    # If there's a tie, this picks one arbitrarily, which seems okay for ARC.\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all contiguous objects of non-background colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    bounding_box = (min_r, min_c, max_r, max_c)\n                    top_left = (min_r, min_c)\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': bounding_box,\n                        'top_left': top_left\n                    })\n    return objects\n\ndef filter_objects(objects, background_color):\n    \"\"\"Filters objects based on color rules.\"\"\"\n    ignored_colors = {5, 7, 9} # Gray, Orange, Maroon\n    relevant_objects = []\n    for obj in objects:\n        color = obj['color']\n        if color in ignored_colors:\n            continue\n        if background_color == 8 and color == 2: # Ignore Red if background is Azure\n            continue\n        relevant_objects.append(obj)\n    return relevant_objects\n\ndef get_object_subgrid(grid, obj, background_color):\n    \"\"\"Extracts the object within its bounding box, filling background.\"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    subgrid = np.full((height, width), background_color, dtype=grid.dtype)\n    \n    for r, c in obj['pixels']:\n        subgrid[r - min_r, c - min_c] = obj['color']\n        \n    return subgrid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting, filtering, sorting, and stacking shapes.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Determine background color\n    background_color = find_background_color(input_np)\n\n    # 2. Find all objects\n    all_objects = find_objects(input_np, background_color)\n\n    # 3. Filter objects\n    relevant_objects = filter_objects(all_objects, background_color)\n\n    if not relevant_objects:\n        # Handle cases where no relevant objects are found (e.g., return empty or background grid?)\n        # Based on examples, if no relevant objects, it seems like an empty grid of appropriate type might be expected,\n        # but the examples provided always have relevant objects leading to an output.\n        # Let's assume for now we always find objects to stack.\n        # If this assumption is wrong, we might need a default (like 0x0 grid or error).\n         return np.array([[]], dtype=int) # Or potentially raise an error or return a small background grid\n\n    # 4. Calculate bounding boxes and top-left (already done in find_objects)\n\n    # 5. Sort objects by top-left (row, then column)\n    sorted_objects = sorted(relevant_objects, key=lambda obj: obj['top_left'])\n\n    # 6. Conditional reverse if background is Yellow (4)\n    if background_color == 4:\n        sorted_objects.reverse()\n\n    final_ordered_objects = sorted_objects\n\n    # 7. Determine output grid dimensions\n    output_height = 0\n    output_width = 0\n    object_subgrids = []\n\n    for obj in final_ordered_objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        output_height += height\n        output_width = max(output_width, width)\n        # Also create the subgrids now\n        subgrid = get_object_subgrid(input_np, obj, background_color)\n        object_subgrids.append(subgrid)\n\n\n    # 8. Construct the output grid\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    current_row = 0\n    for subgrid in object_subgrids:\n        h, w = subgrid.shape\n        # Center the subgrid horizontally if needed, or align left?\n        # The examples suggest left alignment or perhaps centering within the max width.\n        # Let's re-examine example 1 output:\n        # Widths are all 6. Max width is 6. Looks like they are just placed.\n        # Let's try placing them directly, padding with background if necessary.\n        \n        # Ensure the subgrid fits within the output width, padding with background if wider\n        place_w = min(w, output_width)\n        output_grid[current_row : current_row + h, 0 : place_w] = subgrid[:, 0:place_w]\n        \n        # If the subgrid is narrower than output_width, the rest is already background.\n        \n        current_row += h\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4810,
    "candidates_token_count": 1878,
    "total_token_count": 6688,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.01814,
  "retries": null
}