{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom skimage.measure import label, regionprops\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\n1.  **Identify Background:** Determine the `background_color` as the most frequent color in the input grid.\n2.  **Identify Relevant Pixels:** Create a mask identifying 'relevant' pixels. A pixel is relevant if its color is NOT the background color, NOT Gray (5), NOT Orange (7), and NOT Maroon (9). Additionally, if the background color is Azure (8), then Red (2) pixels are also NOT relevant.\n3.  **Find Conceptual Shapes:** Find connected components (using 4-connectivity, meaning only horizontal and vertical neighbors are considered connected) within the `relevant_mask`. These components represent the conceptual shapes.\n4.  **Characterize Shapes:** For each connected component (shape):\n    *   Determine its bounding box (`min_row`, `min_col`, `max_row`, `max_col`).\n    *   Calculate its height `h = max_row - min_row + 1`.\n    *   Find the coordinates of the top-most, left-most pixel belonging to this component within the original input grid.\n    *   Determine the `representative_color` which is the original color of this top-left pixel in the input grid.\n    *   Store the shape's `height`, `representative_color`, and `top_left` coordinate (`min_row`, `min_col`).\n5.  **Sort Shapes:** Sort the characterized shapes primarily by their `min_row` (top coordinate) and secondarily by their `min_col` (left coordinate).\n6.  **Conditional Reverse:** If the `background_color` is Yellow (4), reverse the order of the sorted shapes.\n7.  **Determine Output Dimensions:**\n    *   Calculate `max_shape_height` which is the maximum height (`h`) among all identified shapes. If no shapes are found, default to 0.\n    *   The `output_width` will be equal to `max_shape_height`.\n    *   The `output_height` will be the sum of the heights (`h`) of all identified shapes.\n    *   If either dimension is 0 (e.g., no shapes found), return an empty grid.\n8.  **Construct Output Grid:**\n    *   Create a new grid initialized with the `background_color`, with dimensions `output_height` x `output_width`.\n    *   Initialize `current_row = 0`.\n    *   Iterate through the sorted (and potentially reversed) shapes. For each shape with height `h` and `representative_color`:\n        *   Calculate the starting column for horizontal centering: `start_col = (output_width - h) // 2`.\n        *   Draw a solid square block of size `h` x `h` using the `representative_color` in the output grid. The top-left corner of this square will be at `(current_row, start_col)`.\n        *   Update `current_row` by adding `h` to position the next shape below the current one.\n9.  **Return:** The constructed output grid as a list of lists.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    if grid.size == 0:\n        return 0 # Default to white\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the described rules.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    if input_np.size == 0:\n        return [[]]\n\n    # 1. Identify Background\n    background_color = find_background_color(input_np)\n\n    # 2. Identify Relevant Pixels\n    rows, cols = input_np.shape\n    relevant_mask = np.ones_like(input_np, dtype=bool)\n    always_ignored_colors = {5, 7, 9} # Gray, Orange, Maroon\n\n    relevant_mask[input_np == background_color] = False\n    for color in always_ignored_colors:\n        relevant_mask[input_np == color] = False\n    if background_color == 8: # If background is Azure\n        relevant_mask[input_np == 2] = False # Ignore Red\n\n    # 3. Find Conceptual Shapes using skimage.measure.label\n    # connectivity=1 means 4-connectivity (rook's moves)\n    labeled_grid, num_labels = label(relevant_mask, connectivity=1, background=0, return_num=True)\n\n    shapes = []\n    # 4. Characterize Shapes\n    # Skip label 0 as it represents the background/non-relevant areas\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        if coords.size == 0:\n            continue\n\n        min_row = np.min(coords[:, 0])\n        min_col = np.min(coords[:, 1])\n        max_row = np.max(coords[:, 0])\n        max_col = np.max(coords[:, 1])\n\n        height = max_row - min_row + 1\n        #width = max_col - min_col + 1 # Width not directly used for output square size\n\n        # Find the top-most, left-most pixel *of this component*\n        top_left_component_pixel_coord = min(coords, key=lambda x: (x[0], x[1]))\n        representative_color = input_np[top_left_component_pixel_coord[0], top_left_component_pixel_coord[1]]\n\n        shapes.append({\n            'min_row': min_row,\n            'min_col': min_col, # Keep min_col for sorting\n            'height': height,\n            'representative_color': representative_color\n        })\n\n    # Handle case with no relevant shapes found\n    if not shapes:\n        return [[]] # Return empty grid as per rule 7\n\n    # 5. Sort Shapes\n    # Sort by min_row (top coordinate), then min_col (left coordinate)\n    sorted_shapes = sorted(shapes, key=lambda s: (s['min_row'], s['min_col']))\n\n    # 6. Conditional Reverse\n    if background_color == 4: # Yellow background\n        sorted_shapes.reverse()\n\n    # 7. Determine Output Dimensions\n    if not sorted_shapes: # Double check after potential filtering/sorting issues\n         return [[]]\n\n    max_shape_height = max(s['height'] for s in sorted_shapes) if sorted_shapes else 0\n    output_width = max_shape_height\n    output_height = sum(s['height'] for s in sorted_shapes)\n\n    # Additional check for zero dimensions\n    if output_height <= 0 or output_width <= 0:\n        return [[]]\n\n    # 8. Construct Output Grid\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n    current_row = 0\n\n    for shape in sorted_shapes:\n        h = shape['height']\n        rep_color = shape['representative_color']\n\n        # Calculate start column for horizontal centering of the h x h square\n        start_col = (output_width - h) // 2\n\n        # Define the slice for the h x h square\n        row_slice = slice(current_row, current_row + h)\n        col_slice = slice(start_col, start_col + h)\n\n        # Draw the solid square block\n        output_grid[row_slice, col_slice] = rep_color\n\n        # Update the starting row for the next shape\n        current_row += h\n\n    # 9. Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6763,
    "candidates_token_count": 1849,
    "total_token_count": 8612,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.057361,
  "retries": null
}