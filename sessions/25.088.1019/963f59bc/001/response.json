{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Start with the output grid being an identical copy of the input grid.\n2. Analyze the input grid to find all separate objects (contiguous areas of the same non-white color). An object is defined by its color and the set of coordinates it occupies.\n3. Distinguish between objects that are single pixels (\"seed pixels\") and objects that consist of multiple pixels (\"shape objects\").\n4. Collect the colors of all identified seed pixels.\n5. Identify the \"template shape\" by finding the shape object whose color is *not* among the collected seed pixel colors. Determine the pattern of this template shape (the positions of its pixels relative to its top-left corner).\n6. Iterate through each identified seed pixel:\n    a. Note the color and position (row, column) of the current seed pixel.\n    b. Use the pattern of the template shape identified in step 5.\n    c. For each pixel position in the template shape's pattern, calculate the corresponding position on the output grid by adding the relative coordinates of the template pixel to the seed pixel's position.\n    d. Change the color of the pixel at this calculated position on the output grid to the color of the current seed pixel. Ensure this operation stays within the grid boundaries.\n7. The final modified grid is the result.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid, ignoring a specified color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_color (int): The color to ignore (typically the background).\n\n    Returns:\n        list: A list of objects. Each object is a dictionary containing:\n              'color' (int): The color of the object.\n              'coords' (set): A set of (row, col) tuples representing the object's pixels.\n              'size' (int): The number of pixels in the object.\n              'top_left' (tuple): The (row, col) of the top-leftmost pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != ignore_color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'size': len(obj_coords),\n                    'top_left': (min_r, min_c)\n                })\n    return objects\n\ndef get_relative_shape(obj_coords, top_left):\n    \"\"\"\n    Calculates the relative coordinates of an object's pixels from its top-left corner.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n        top_left (tuple): The (row, col) of the top-leftmost pixel.\n\n    Returns:\n        set: A set of (dr, dc) relative coordinates.\n    \"\"\"\n    min_r, min_c = top_left\n    relative_coords = set()\n    for r, c in obj_coords:\n        relative_coords.add((r - min_r, c - min_c))\n    return relative_coords\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Copies a template shape to the locations of seed pixels,\n    recoloring the copied shape with the seed pixel's color.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = output_grid.shape\n\n    # Find all non-background objects\n    objects = find_objects(input_np, ignore_color=0)\n\n    # Separate objects into seeds (size 1) and shapes (size > 1)\n    seed_pixels = []\n    shape_objects = []\n    for obj in objects:\n        if obj['size'] == 1:\n            seed_pixels.append(obj)\n        else:\n            shape_objects.append(obj)\n\n    # Get the set of colors used by seed pixels\n    seed_colors = {seed['color'] for seed in seed_pixels}\n\n    # Find the template shape (shape object whose color is not a seed color)\n    template_object = None\n    for shape in shape_objects:\n        if shape['color'] not in seed_colors:\n            template_object = shape\n            break # Assume only one template per input based on examples\n\n    if template_object is None:\n        # Handle case where no template is found (e.g., return input unchanged or raise error)\n        # Based on examples, a template should exist. If not, maybe return input.\n        print(\"Warning: No template object found.\")\n        return input_grid \n\n    # Get the relative shape of the template\n    template_relative_shape = get_relative_shape(template_object['coords'], template_object['top_left'])\n\n    # Iterate through each seed pixel and apply the template\n    for seed in seed_pixels:\n        seed_color = seed['color']\n        # A seed pixel has only one coordinate, get it\n        seed_pos = next(iter(seed['coords'])) \n        seed_r, seed_c = seed_pos\n\n        # Apply the template shape relative to the seed position\n        for dr, dc in template_relative_shape:\n            target_r = seed_r + dr\n            target_c = seed_c + dc\n\n            # Check bounds before writing to the output grid\n            if 0 <= target_r < rows and 0 <= target_c < cols:\n                output_grid[target_r, target_c] = seed_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4355,
    "candidates_token_count": 1613,
    "total_token_count": 5968,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.491527,
  "retries": null
}