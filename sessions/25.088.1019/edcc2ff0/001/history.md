
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 2 3 8 3
3 1 1 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 2 2 3 3 3 3 8 3
3 3 3 3 3 3 3 3 3 3
3 3 8 8 3 3 3 3 3 3
3 3 8 8 3 4 4 4 3 3
3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3
3 2 2 3 3 3 3 2 2 3
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 2 2 3 3 3 3 8 3
3 3 3 3 3 3 3 3 3 3
3 3 8 8 3 3 3 3 3 3
3 3 8 8 3 4 4 4 3 3
3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3
3 2 2 3 3 3 3 2 2 3
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
1 2 2 1 1 1 1 1 1 1
1 2 1 1 1 2 2 1 3 1
1 1 1 1 1 2 2 1 3 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 8 1 1 3 3 1 1 1
1 1 8 1 1 3 3 1 1 1
1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
1 2 2 1 1 1 1 1 1 1
1 2 1 1 1 2 2 1 3 1
1 1 1 1 1 2 2 1 3 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 3 3 1 1 1
1 1 1 1 1 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8
8 2 2 8 8 8 8 8 4 8
8 8 8 8 8 8 1 8 4 8
8 6 8 4 4 8 1 8 8 8
8 6 8 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 4 8 2 2 8 8 3 3 8
8 4 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 8
8 8 1 8 8 6 6 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 4 4 4 4 8
8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8
8 2 2 8 8 8 8 8 4 8
8 8 8 8 8 8 1 8 4 8
8 8 8 4 4 8 1 8 8 8
8 8 8 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 4 8 2 2 8 8 8 8 8
8 4 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 4 4 4 4 8
8 8 8 8 8 8 8 8 8 8
```

Okay, let's analyze the provided examples to understand the transformation rules.

**Perception of Elements:**

1.  **Grid Structure:** The grids are 20x10. They appear visually divided into two main sections:
    *   **Top Section (Rows 0-6):** Contains sparse information, primarily single colored pixels in the first column (column 0) on a white background.
    *   **Bottom Section (Rows 7-19):** Contains denser patterns, often featuring a large background area of a single color with various smaller, distinct objects embedded within it.
2.  **Color Roles:**
    *   **Indicator Colors:** The colors appearing in column 0 of the top section seem to act as indicators or keys.
    *   **Background Color:** The color filling most of the bottom section (specifically, the color at row 7, column 0) acts as the background for that region.
    *   **Object Colors:** Colors forming distinct shapes within the bottom section's background.
    *   **White (0):** Primarily acts as a background in the top section.
3.  **Transformation Pattern:** The transformation appears to happen in two related parts:
    *   **Bottom Section Modification:** Colors in the bottom section are selectively removed (replaced by the background color) based on whether they match one of the indicator colors from the top section.
    *   **Top Section Modification:** The single pixels in the top section's first column are transformed into horizontal lines. The length of each line seems determined by properties of objects of the corresponding color in the bottom section of the *input* grid. Specifically, the length corresponds to the *count* of distinct objects of that color. If a color from the top section has no corresponding objects in the bottom section, it's removed (becomes white).

**YAML Fact Document:**


```yaml
Grid_Structure:
  Dimensions: 20x10
  Sections:
    - Top_Section:
        Rows: 0-6
        Content: Sparse, primarily single pixels in column 0 on white background.
    - Bottom_Section:
        Rows: 7-19
        Content: Dense patterns, background color with embedded objects.
Color_Roles:
  - Indicator_Colors:
      Location: Top_Section, column 0
      Function: Determine which colors persist in the Bottom_Section and control line length in the Top_Section output.
      Excludes: White (0)
  - Background_Color:
      Location: Dominant color in Bottom_Section, specifically at (7, 0).
      Function: Replaces removed object colors in the Bottom_Section output.
  - Object_Colors:
      Location: Embedded within Bottom_Section background.
      Properties: Form distinct contiguous shapes (connected horizontally/vertically).
Relationships_Actions:
  - Bottom_Section_Filtering:
      Input: Bottom_Section pixels, Indicator_Colors, Background_Color
      Action: Iterate through Bottom_Section pixels. If a pixel's color is NOT Background_Color AND NOT in Indicator_Colors, change its color to Background_Color in the output. Otherwise, keep the original color.
      Trigger: Presence/absence of the pixel's color in the Indicator_Colors set.
  - Top_Section_Line_Generation:
      Input: Indicator_Colors from Top_Section (column 0), Objects in Bottom_Section (input grid)
      Action: For each Indicator_Color `C` at row `r` in Top_Section (column 0):
        1. Count the number `N` of distinct contiguous objects of color `C` in the Bottom_Section of the input grid.
        2. In the output grid's Top_Section, draw a horizontal line of color `C` starting at (r, 0) with length `N`.
        3. Fill the rest of row `r` (from column `N` onwards) with White (0).
      Condition: If `N` is 0 (no objects of color `C` found), the entire row `r` in the output Top_Section becomes White (0).
Object_Definition:
  Contiguity: Pixels of the same color connected horizontally or vertically form a single object.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the set of "indicator colors" by collecting all non-white colors present in column 0 between rows 0 and 6 (inclusive) of the input grid.
3.  Identify the "bottom section background color" as the color of the pixel at position (row 7, column 0) in the input grid.
4.  **Process the Bottom Section (Rows 7-19):** Iterate through each pixel (r, c) where r >= 7. Let `P` be the color of this pixel in the *input* grid. If `P` is *not* the bottom section background color AND `P` is *not* present in the set of indicator colors, set the color of the pixel at (r, c) in the *output* grid to the bottom section background color.
5.  **Process the Top Section (Rows 0-6):** Iterate through each row `r` from 0 to 6.
    *   Let `C` be the color of the pixel at (r, 0) in the *input* grid.
    *   If `C` is white (0), set all pixels in row `r` (columns 0-9) of the *output* grid to white (0).
    *   If `C` is not white:
        *   Count the number `N` of distinct, contiguous objects of color `C` located within the bottom section (rows 7-19) of the *input* grid. (Objects are formed by same-colored pixels connected horizontally or vertically).
        *   In the *output* grid, set the pixels in row `r` from column 0 to column `N-1` (inclusive) to color `C`.
        *   Set the remaining pixels in row `r` (from column `N` to column 9) to white (0). (This handles the case where N=0 correctly, making the whole row white).
