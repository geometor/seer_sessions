{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the background color (from corners) and frame color (adjacent to border).\n2. Identifying 'object' pixels (neither background nor frame).\n3. Determining a central point:\n    - If object pixels exist, the center is the middle of their bounding box.\n    - If no object pixels exist, the center is the geometric middle of the input grid.\n4. Extracting a 3x3 'core pattern' from the input grid, centered at the determined point.\n5. Constructing a 5x5 'placed pattern':\n    - The center 3x3 area is the extracted 'core pattern'.\n    - The border sides (non-corners) are filled with the frame color.\n    - The border corners are filled with the background color.\n6. Creating a 15x15 output grid filled with the background color.\n7. Placing the 5x5 'placed pattern' onto the output grid twice, at fixed top-left coordinates (2, 2) and (8, 8).\n\"\"\"\n\ndef find_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Finds the minimum bounding box containing all coordinates.\"\"\"\n    if not coords:\n        return 0, 0, -1, -1 # Indicate empty box if no coords\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef place_subgrid(target_grid: np.ndarray, subgrid: np.ndarray, r_start: int, c_start: int):\n    \"\"\"Safely places a subgrid onto a target grid, handling boundary clipping.\"\"\"\n    target_h, target_w = target_grid.shape\n    sub_h, sub_w = subgrid.shape\n    \n    r_end = min(r_start + sub_h, target_h)\n    c_end = min(c_start + sub_w, target_w)\n    \n    paste_h = r_end - r_start\n    paste_w = c_end - c_start\n    \n    if paste_h > 0 and paste_w > 0:\n        target_grid[r_start:r_end, c_start:c_end] = subgrid[:paste_h, :paste_w]\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed 15x15 output grid as a list of lists.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    h, w = input_grid_np.shape\n\n    # --- 1. Identify Colors ---\n    background_color = input_grid_np[0, 0]\n    \n    # Find frame color (look adjacent to background border)\n    frame_color = -1 \n    possible_frame_coords = []\n    if h > 1:\n        possible_frame_coords.extend([(1, c) for c in range(w)])\n        possible_frame_coords.extend([(h-2, c) for c in range(w)])\n    if w > 1:\n        possible_frame_coords.extend([(r, 1) for r in range(h)])\n        possible_frame_coords.extend([(r, w-2) for r in range(h)])\n    # Special case for 1xN or Nx1 near corners\n    if h>1 and w > 1:\n        possible_frame_coords.extend([(1,1), (1,w-2), (h-2,1), (h-2, w-2)])\n    elif h>1:\n        possible_frame_coords.extend([(1,0)])\n    elif w>1:\n         possible_frame_coords.extend([(0,1)])\n        \n    for r, c in possible_frame_coords:\n         # Ensure coords are valid (might be duplicates or outside for small grids)\n         if 0 <= r < h and 0 <= c < w:\n             pixel = input_grid_np[r, c]\n             if pixel != background_color:\n                 frame_color = pixel\n                 break\n                 \n    # Fallback if frame color still not found (e.g. input is solid background)\n    # Use a default distinct color like -1, though this shouldn't happen based on examples\n    if frame_color == -1:\n         # This case is unlikely given the problem structure, but safest to handle.\n         # We can assume the frame color is the same as the background in this edge case.\n         frame_color = background_color\n\n\n    # --- 2. Identify Object Pixels ---\n    object_coords = []\n    for r in range(h):\n        for c in range(w):\n            if input_grid_np[r, c] != background_color and input_grid_np[r, c] != frame_color:\n                object_coords.append((r, c))\n\n    # --- 3. Determine Center for Core Extraction ---\n    center_r, center_c = 0, 0\n    if object_coords:\n        min_r, min_c, max_r, max_c = find_bounding_box(object_coords)\n        # Calculate the center of the bounding box\n        center_r = (min_r + max_r) // 2\n        center_c = (min_c + max_c) // 2\n    else:\n        # Use the geometric center of the grid\n        center_r = (h - 1) // 2\n        center_c = (w - 1) // 2\n        \n    # --- 4. Extract 3x3 Core Pattern ---\n    # Calculate the top-left corner for the 3x3 slice\n    core_start_r = center_r - 1\n    core_start_c = center_c - 1\n    \n    # Extract the 3x3 pattern, ensuring indices stay within bounds\n    # We assume the 3x3 region exists fully within the input based on examples.\n    # A more robust solution might pad, but let's stick to direct slicing first.\n    core_pattern = input_grid_np[core_start_r : core_start_r + 3, core_start_c : core_start_c + 3]\n    \n    # Ensure core_pattern is exactly 3x3, handling edge cases where slicing might yield smaller.\n    # This shouldn't be necessary if the center guarantees a full 3x3 slice.\n    if core_pattern.shape != (3, 3):\n         # This indicates an issue with center calculation or assumption.\n         # For now, create a default 3x3 if extraction failed.\n         # Using frame_color as a placeholder default fill.\n         print(f\"Warning: Core pattern extraction failed for center ({center_r}, {center_c}), shape={core_pattern.shape}. Defaulting.\")\n         core_pattern = np.full((3, 3), frame_color, dtype=int)\n\n\n    # --- 5. Construct 5x5 Placed Pattern ---\n    placed_pattern = np.full((5, 5), background_color, dtype=int)\n    # Place core in the center\n    placed_pattern[1:4, 1:4] = core_pattern\n    # Fill border sides\n    placed_pattern[0, 1:4] = frame_color  # Top\n    placed_pattern[4, 1:4] = frame_color  # Bottom\n    placed_pattern[1:4, 0] = frame_color  # Left\n    placed_pattern[1:4, 4] = frame_color  # Right\n\n    # --- 6. Create Output Grid ---\n    output_h = 15\n    output_w = 15\n    output_grid = np.full((output_h, output_w), background_color, dtype=int)\n\n    # --- 7. Place Pattern ---\n    loc1_r, loc1_c = 2, 2\n    loc2_r, loc2_c = 8, 8\n\n    place_subgrid(output_grid, placed_pattern, loc1_r, loc1_c)\n    place_subgrid(output_grid, placed_pattern, loc2_r, loc2_c)\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7487,
    "candidates_token_count": 2040,
    "total_token_count": 9527,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.182188,
  "retries": null
}