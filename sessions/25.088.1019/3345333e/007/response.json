{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nProcesses an input grid containing a background color (White 0) and exactly two \nother foreground colors. One foreground color forms a single, solid, connected \nrectangular object (the 'mask'). The other foreground color forms the 'persistent' \nobject, which may consist of multiple disconnected components or have a complex shape. \nThe transformation produces an output grid containing only the pixels of the \n'persistent' object that do *not* share the exact same coordinates as any pixel \nof the 'mask' object. All other output pixels are the background color.\n\nNote: While this rule is derived from the object properties (mask = single solid \nrectangle), it does not perfectly replicate the pixel counts observed in the \nprovided example outputs, which show an unexpected increase in persistent pixels. \nThis implementation follows the direct overlap removal logic as the most plausible \nintended rule based on the structure.\n\"\"\"\n\n# Helper function to find connected components (objects) of a specific color\n# using 4-way connectivity (neighbors: up, down, left, right)\ndef find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int): The color of the components to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a connected component.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start search if pixel is the target color and not yet visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n\n                # Breadth-First Search (BFS) to find all connected pixels\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor has the target color and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n                # Add the found component to the list if it's not empty\n                if component_coords:\n                    objects.append(component_coords)\n    return objects\n\n# Helper function to check if a set of coordinates forms a solid rectangle\ndef is_solid_rectangle(object_coords):\n    \"\"\"\n    Checks if a set of coordinates represents a solid rectangle.\n\n    Args:\n        object_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        bool: True if the coordinates form a solid rectangle, False otherwise.\n    \"\"\"\n    if not object_coords:\n        return False # An empty set is not a rectangle\n\n    try:\n        # Find the bounding box of the coordinates\n        rows = [r for r, c in object_coords]\n        cols = [c for r, c in object_coords]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n\n        # Calculate the expected number of pixels if it were a solid rectangle\n        expected_size = (max_r - min_r + 1) * (max_c - min_c + 1)\n\n        # Compare the actual number of pixels with the expected size\n        return len(object_coords) == expected_size\n    except ValueError: # Handles case where object_coords might be empty after filtering etc.\n         return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the direct overlap removal transformation based on mask identification.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    background_color = 0 # Assuming White (0) is always background\n\n    # 1. Identify all unique non-background colors\n    unique_colors = np.unique(input_np)\n    foreground_colors = [c for c in unique_colors if c != background_color]\n\n    # 2. Expecting exactly two foreground colors based on examples\n    if len(foreground_colors) != 2:\n        # If assumptions are violated, return an empty (background) grid.\n        # print(f\"Warning: Expected 2 foreground colors, found {len(foreground_colors)}. Returning background grid.\")\n        return np.full_like(input_np, background_color).tolist()\n\n    mask_color = None\n    persistent_color = None\n    mask_coords = set()\n\n    # 3. & 4. Analyze each foreground color to find the 'mask' color\n    for color in foreground_colors:\n        # a. Find connected components for this color\n        components = find_connected_components(input_np, color)\n        # b. Count components\n        num_components = len(components)\n        # c. Check if it's the mask: exactly one component AND it's a solid rectangle\n        if num_components == 1:\n            component = components[0]\n            if is_solid_rectangle(component):\n                mask_color = color\n                mask_coords = component # Store the coordinates of the mask object\n                break # Found the mask color, no need to check the other\n\n    # 5. Identify the 'persistent' color (and handle if no mask found)\n    if mask_color is None:\n        # This might happen if neither color fits the mask criteria.\n        # print(\"Warning: Could not identify a mask color (single solid rectangle component). Returning background grid.\")\n        return np.full_like(input_np, background_color).tolist()\n\n    # The persistent color is the one that isn't the mask color\n    persistent_color = next(c for c in foreground_colors if c != mask_color)\n\n    # 6. Find the set of coordinates for the mask object (already done in step 4)\n    # mask_coords contains the set of (r, c) tuples for the mask.\n\n    # 7. Initialize the output grid with the background color\n    output_np = np.full_like(input_np, background_color)\n\n    # 8. Iterate through input grid coordinates\n    for r in range(rows):\n        for c in range(cols):\n            # 9. Check if the input pixel is the persistent color\n            if input_np[r, c] == persistent_color:\n                # 10. Check if this coordinate is NOT part of the mask's coordinates (direct overlap check)\n                if (r, c) not in mask_coords:\n                    # 11. If it's persistent and not masked, copy it to the output\n                    output_np[r, c] = persistent_color\n\n    # 12. Return the completed output grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22391,
    "candidates_token_count": 1745,
    "total_token_count": 24136,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.990625,
  "retries": null
}