{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two non-background colors in the input grid. One color defines a 'mask'\nobject, characterized by forming exactly one connected component that is a solid\nrectangle. The other color defines the 'persistent' object. The transformation\ncreates an output grid containing only the pixels of the persistent object that\ndo *not* spatially overlap with the mask object's area in the input grid. All\nother pixels in the output grid are set to the background color (White 0).\n\"\"\"\n\n# Helper function to find connected components (objects) of a specific color\n# using 4-way connectivity (neighbors: up, down, left, right)\ndef find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int): The color of the components to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a connected component.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start search if pixel is the target color and not yet visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n\n                # Breadth-First Search (BFS) to find all connected pixels\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor has the target color and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n                # Add the found component to the list if it's not empty\n                if component_coords:\n                    objects.append(component_coords)\n    return objects\n\n# Helper function to check if a set of coordinates forms a solid rectangle\ndef is_solid_rectangle(object_coords):\n    \"\"\"\n    Checks if a set of coordinates represents a solid rectangle.\n\n    Args:\n        object_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        bool: True if the coordinates form a solid rectangle, False otherwise.\n    \"\"\"\n    if not object_coords:\n        return False # An empty set is not a rectangle\n\n    try:\n        # Find the bounding box of the coordinates\n        rows = [r for r, c in object_coords]\n        cols = [c for r, c in object_coords]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n\n        # Calculate the expected number of pixels if it were a solid rectangle\n        expected_size = (max_r - min_r + 1) * (max_c - min_c + 1)\n\n        # Compare the actual number of pixels with the expected size\n        return len(object_coords) == expected_size\n    except ValueError: # Handles case where object_coords might be empty after filtering etc.\n         return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the mask-overlap removal transformation to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    background_color = 0\n\n    # 1. Identify all unique non-background colors\n    unique_colors = np.unique(input_np)\n    object_colors = [c for c in unique_colors if c != background_color]\n\n    # Expecting exactly two object colors based on examples\n    if len(object_colors) != 2:\n        # If assumptions are violated, return an empty (background) grid.\n        print(f\"Warning: Expected 2 object colors, found {len(object_colors)}. Returning background grid.\")\n        return np.full_like(input_np, background_color).tolist()\n\n    mask_color = None\n    persistent_color = None\n    mask_coords = set()\n\n    # 2. & 3. Analyze each color to find the 'mask' color\n    for color in object_colors:\n        # a. Find connected components for this color\n        components = find_connected_components(input_np, color)\n        # b. Count components\n        num_components = len(components)\n        # c. Check if it's the mask: exactly one component AND it's a solid rectangle\n        if num_components == 1:\n            component = components[0]\n            if is_solid_rectangle(component):\n                mask_color = color\n                mask_coords = component # Store the coordinates of the mask\n                break # Found the mask color, no need to check the other\n\n    # 4. Identify the 'persistent' color (and handle if no mask found)\n    if mask_color is None:\n        # This might happen if neither color fits the mask criteria.\n        print(\"Warning: Could not identify a mask color (single solid rectangle component). Returning background grid.\")\n        return np.full_like(input_np, background_color).tolist()\n\n    # The persistent color is the one that isn't the mask color\n    persistent_color = next(c for c in object_colors if c != mask_color)\n\n    # 5. Create the output grid initialized with the background color\n    output_np = np.full_like(input_np, background_color)\n\n    # 6. & 7. Iterate through input, copy persistent pixels *not* covered by mask\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current pixel is the persistent color\n            if input_np[r, c] == persistent_color:\n                # Check if this coordinate is NOT part of the mask area\n                if (r, c) not in mask_coords:\n                    # If it's persistent and not masked, copy it to the output\n                    output_np[r, c] = persistent_color\n\n    # 8. Return the completed output grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21418,
    "candidates_token_count": 1593,
    "total_token_count": 23011,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.286596,
  "retries": null
}