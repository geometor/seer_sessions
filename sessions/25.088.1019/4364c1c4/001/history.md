
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 4 1 1 1 4 4 4 1 1 1
1 1 4 1 1 1 4 4 4 1 1 1
1 1 4 4 4 4 4 4 4 1 1 1
1 1 4 4 4 4 4 4 4 1 1 1
1 1 2 2 2 2 2 2 2 1 1 1
1 1 2 2 2 2 1 1 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 4 1 1 1 4 4 4 1 1 1 1
1 4 1 1 1 4 4 4 1 1 1 1
1 4 4 4 4 4 4 4 1 1 1 1
1 4 4 4 4 4 4 4 1 1 1 1
1 1 1 2 2 2 2 2 2 2 1 1
1 1 1 2 2 2 2 1 1 2 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8
8 8 6 6 6 6 8 8 8 8 8 8
8 8 6 6 6 6 8 8 8 8 8 8
8 8 6 6 6 6 6 6 6 8 8 8
8 8 6 6 6 6 6 6 6 8 8 8
8 8 3 3 3 3 3 3 3 8 8 8
8 8 3 3 3 3 3 3 3 8 8 8
8 8 3 3 3 3 3 3 3 8 8 8
8 8 3 3 3 3 3 3 3 8 8 8
8 8 3 3 3 8 8 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8
8 6 6 6 6 8 8 8 8 8 8 8
8 6 6 6 6 8 8 8 8 8 8 8
8 6 6 6 6 6 6 6 8 8 8 8
8 6 6 6 6 6 6 6 8 8 8 8
8 8 8 3 3 3 3 3 3 3 8 8
8 8 8 3 3 3 3 3 3 3 8 8
8 8 8 3 3 3 3 3 3 3 8 8
8 8 8 3 3 3 3 3 3 3 8 8
8 8 8 3 3 3 8 8 3 3 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 2 2 2 3 3 3
3 3 3 3 3 3 3 7 7 7 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3
3 8 8 3 3 3 3 3 3 3 3 3 3
3 8 8 3 3 3 3 3 3 3 3 3 3
3 8 8 8 8 3 3 3 3 3 3 3 3
3 8 8 8 8 3 3 3 3 3 3 3 3
3 8 8 8 8 3 3 3 3 3 3 3 3
3 6 6 6 6 3 3 3 3 3 3 3 3
3 6 6 6 6 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 2 2 2 3 3 3 3
3 3 3 3 3 3 3 3 7 7 7 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3
8 8 3 3 3 3 3 3 3 3 3 3 3
8 8 3 3 3 3 3 3 3 3 3 3 3
8 8 8 8 3 3 3 3 3 3 3 3 3
8 8 8 8 3 3 3 3 3 3 3 3 3
8 8 8 8 3 3 3 3 3 3 3 3 3
3 3 6 6 6 6 3 3 3 3 3 3 3
3 3 6 6 6 6 3 3 3 3 3 3 3
```

**Perception:**

1.  **Grid Structure:** The input and output are grids of the same dimensions.
2.  **Background:** Each grid has a single dominant background color which remains unchanged in the output.
3.  **Objects:** Embedded within the background are several distinct objects, each composed of a contiguous block of pixels of a single color (different from the background).
4.  **Transformation:** The core transformation involves shifting these objects horizontally (left or right) by one column. The shapes and colors of the objects themselves are preserved.
5.  **Shift Logic:** The direction of the shift (left or right) is not determined solely by the object's color or its absolute position. Instead, it depends on the relative vertical position of the objects compared to each other.
6.  **Sorting and Alternation:** When the objects are ordered based on their topmost row index (from top to bottom), they appear to shift in an alternating pattern: the topmost object shifts left, the next object shifts right, the third shifts left, the fourth shifts right, and so on.

**YAML Facts:**


```yaml
task_description: Shift objects horizontally based on their vertical order.
elements:
  - role: background
    description: A single color filling most of the grid.
    properties:
      - remains_unchanged_in_output
  - role: object
    description: Contiguous block of pixels of the same color, distinct from the background.
    properties:
      - color: preserved during transformation
      - shape: preserved during transformation
      - position: modified by horizontal shift
      - topmost_row: The minimum row index occupied by the object's pixels. Used for ordering.
relationships:
  - type: spatial_order
    description: Objects can be ordered vertically based on their topmost row index.
    attribute: topmost_row
    order: ascending (top to bottom)
actions:
  - name: identify_objects
    description: Find all contiguous pixel groups not matching the background color.
  - name: determine_topmost_row
    description: For each object, find the minimum row index it occupies.
  - name: sort_objects
    description: Order the identified objects based on their topmost row index, ascending.
  - name: apply_alternating_shift
    description: Iterate through the sorted objects, shifting the first left by 1 column, the second right by 1 column, the third left by 1, and so on.
    parameters:
      - shift_amount: 1 column
      - directions: alternating [left, right, left, right, ...]
transformation_rule:
  - The grid contains a background color and multiple distinct objects.
  - Identify all objects (contiguous non-background color blocks).
  - Determine the topmost row for each object.
  - Sort the objects based on their topmost row index (top to bottom).
  - Apply a horizontal shift to each object based on its position in the sorted list:
    - Objects at odd positions (1st, 3rd, 5th, ...) shift left by one column.
    - Objects at even positions (2nd, 4th, 6th, ...) shift right by one column.
  - Reconstruct the output grid with the shifted objects on the original background. Pixels shifted off the grid are removed.
```


**Natural Language Program:**

1.  Identify the background color (the most frequent color in the input grid).
2.  Identify all distinct, contiguous objects in the input grid that have colors different from the background color.
3.  For each identified object, determine its topmost row index (the smallest row number where any pixel of the object exists).
4.  Create a list of these objects and sort them based on their topmost row index in ascending order (from highest on the grid to lowest).
5.  Initialize the output grid as a copy of the input grid's background color.
6.  Iterate through the sorted list of objects, keeping track of the object's index (position) in the list (starting from 1).
7.  For each object:
    a.  If the object's index in the sorted list is odd (1, 3, 5, ...), calculate its new position by shifting all its pixels one column to the left.
    b.  If the object's index in the sorted list is even (2, 4, 6, ...), calculate its new position by shifting all its pixels one column to the right.
    c.  Draw the object (with its original color) onto the output grid at its new, shifted position. Ensure that pixels shifted beyond the grid boundaries (left of column 0 or right of the last column) are discarded.
8.  The final output grid contains the original background with all objects shifted according to the alternating left/right pattern based on their vertical order.
