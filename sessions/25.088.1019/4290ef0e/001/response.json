{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies the background color (most frequent) in the input grid.\nFinds all non-background objects (contiguous pixels of the same color).\nDetermines a central alignment point:\n  - If a unique non-background pixel exists, its location is the center, and its color overrides the output center.\n  - Otherwise, the center of the single 'plus' shaped object is the center.\nCalculates the relative positions of all non-background pixels to this center.\nOverlays these pixels onto a conceptual canvas based on relative positions.\nDetermines the bounding box of the overlaid pixels.\nCreates the output grid sized to the bounding box, initialized with the background color.\nCopies the overlaid pixels from the canvas to the output grid.\nIf a unique center pixel determined alignment, sets the corresponding output pixel to its color.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default to black/white if grid is empty, though ARC constraints prevent this.\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all contiguous objects of non-background colors.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and not visited[r, c]:\n                obj_coords = []\n                q = [(r, c)]\n                visited[r, c] = True\n                obj_color = color\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.append((row, col))\n                    \n                    # Check 4 orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef find_center(grid, background_color):\n    \"\"\"\n    Finds the alignment center.\n    Returns ((center_row, center_col), center_color_override)\n    center_color_override is None if alignment is based on the plus shape.\n    \"\"\"\n    height, width = grid.shape\n    counts = Counter(grid.flatten())\n    \n    # 1. Check for unique non-background pixel\n    unique_pixel_color = None\n    unique_pixel_coords = None\n    for color, count in counts.items():\n        if color != background_color and count == 1:\n            unique_pixel_color = color\n            break\n            \n    if unique_pixel_color is not None:\n        # Find its coordinates\n        for r in range(height):\n            for c in range(width):\n                if grid[r, c] == unique_pixel_color:\n                    unique_pixel_coords = (r, c)\n                    return unique_pixel_coords, unique_pixel_color\n\n    # 2. If no unique pixel, find the center of the plus shape\n    plus_center_coords = None\n    for r in range(1, height - 1):\n        for c in range(1, width - 1):\n            center_color = grid[r, c]\n            if center_color != background_color:\n                # Check N, S, E, W neighbors\n                if (grid[r-1, c] == center_color and\n                        grid[r+1, c] == center_color and\n                        grid[r, c-1] == center_color and\n                        grid[r, c+1] == center_color):\n                    # Basic check assumes only one such shape per problem constraints\n                    # More robust check could ensure corners are different, etc.\n                    plus_center_coords = (r, c)\n                    return plus_center_coords, None # No color override\n\n    # Should not happen based on examples, but return geometric center as fallback?\n    # Or raise error? For now, assume one of the above conditions is met.\n    if plus_center_coords is None:\n         raise ValueError(\"Could not determine alignment center (no unique pixel or plus shape found).\")\n\n    return plus_center_coords, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by overlaying non-background shapes centered\n    according to specific rules.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Analyze Input: Identify background color\n    background_color = find_background_color(input_np)\n\n    # 2. Identify Objects\n    objects = find_objects(input_np, background_color)\n    if not objects:\n        # Handle cases with no non-background objects if necessary\n        # (e.g., return empty grid or grid with only background)\n        # For ARC, likely means returning a minimal grid of background color.\n        # Let's assume 1x1 background based on usual ARC patterns if no objects.\n         return np.array([[background_color]], dtype=int)\n\n\n    # 3. Find Center\n    center_coords, center_color_override = find_center(input_np, background_color)\n    center_r, center_c = center_coords\n\n    # 4. Perform Overlay (conceptually)\n    # Store pixels relative to the center: {(rel_r, rel_c): color}\n    relative_pixels = {}\n    for obj in objects:\n        obj_color = obj['color']\n        for r, c in obj['coords']:\n            rel_r = r - center_r\n            rel_c = c - center_c\n            relative_pixels[(rel_r, rel_c)] = obj_color\n            \n    if not relative_pixels:\n         # This case should ideally be caught by the 'objects' check earlier\n         return np.array([[background_color]], dtype=int)\n\n\n    # 5. Determine Output Bounds\n    min_r = min(r for r, c in relative_pixels)\n    max_r = max(r for r, c in relative_pixels)\n    min_c = min(c for r, c in relative_pixels)\n    max_c = max(c for r, c in relative_pixels)\n\n    out_height = max_r - min_r + 1\n    out_width = max_c - min_c + 1\n\n    # 6. Create Output Grid\n    output_grid = np.full((out_height, out_width), background_color, dtype=int)\n\n    # Copy pixels from relative map to output grid\n    for (rel_r, rel_c), color in relative_pixels.items():\n        # Calculate output coordinates based on top-left corner (min_r, min_c)\n        out_r = rel_r - min_r\n        out_c = rel_c - min_c\n        # Ensure coords are within bounds (should always be, but good practice)\n        if 0 <= out_r < out_height and 0 <= out_c < out_width:\n             output_grid[out_r, out_c] = color\n\n    # 7. Set Center Color (if applicable)\n    if center_color_override is not None:\n        # Calculate the output grid coordinates corresponding to the relative center (0, 0)\n        center_out_r = 0 - min_r\n        center_out_c = 0 - min_c\n        \n        # Check if the calculated center falls within the output grid bounds\n        if 0 <= center_out_r < out_height and 0 <= center_out_c < out_width:\n            output_grid[center_out_r, center_out_c] = center_color_override\n\n    # 8. Return Output Grid\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4851,
    "candidates_token_count": 1960,
    "total_token_count": 6811,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.142483,
  "retries": null
}