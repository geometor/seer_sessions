{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy import ndimage\nimport collections\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Preserves magenta (6) pixels from the input.\n2. Creates a green (3) border by changing azure (8) pixels that are orthogonally or diagonally adjacent to any magenta (6) pixel.\n3. Identifies regions of azure (8) pixels in the input that are enclosed by magenta (6) pixels (cannot reach the grid border via azure pixels).\n4. Fills these enclosed regions in the output grid:\n    - If the enclosed region consists of exactly a 2x2 block of azure pixels, fill with green (3).\n    - Otherwise, fill with yellow (4).\n5. Azure pixels not part of the border or fill remain azure (8).\n\"\"\"\n\ndef find_adjacent_pixels(grid, target_color):\n    \"\"\"Finds pixels adjacent (ortho & diag) to the target color.\"\"\"\n    H, W = grid.shape\n    target_mask = (grid == target_color)\n    # Use binary dilation with a 3x3 structure to find pixels touching the target color\n    structure = np.ones((3, 3), dtype=bool)\n    dilated_mask = ndimage.binary_dilation(target_mask, structure=structure)\n    # Adjacent pixels are those marked by dilation but not part of the original target\n    adjacent_mask = dilated_mask & (~target_mask)\n    return adjacent_mask\n\ndef find_enclosed_regions(grid, background_color, wall_color):\n    \"\"\"Finds connected regions of background_color enclosed by wall_color.\"\"\"\n    H, W = grid.shape\n    background_mask = (grid == background_color)\n    \n    # Use BFS starting from border background pixels to find reachable background pixels\n    visited = np.zeros_like(grid, dtype=bool)\n    queue = collections.deque()\n\n    # Add all border background pixels to the queue\n    for r in range(H):\n        for c in [0, W - 1]:\n            if background_mask[r, c] and not visited[r, c]:\n                visited[r, c] = True\n                queue.append((r, c))\n    for c in range(W):\n        for r in [0, H - 1]:\n             if background_mask[r, c] and not visited[r, c]:\n                visited[r, c] = True\n                queue.append((r, c))\n                \n    # BFS to find all reachable background pixels\n    while queue:\n        r, c = queue.popleft()\n        # Check orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if background_mask[nr, nc] and not visited[nr, nc]:\n                    visited[nr, nc] = True\n                    queue.append((nr, nc))\n\n    # Enclosed regions are background pixels that were not visited\n    enclosed_mask = background_mask & (~visited)\n    \n    # Label the connected components of enclosed background pixels\n    # Use orthogonal connectivity (structure)\n    connectivity_structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=bool)\n    labeled_enclosed, num_labels = ndimage.label(enclosed_mask, structure=connectivity_structure)\n    \n    return labeled_enclosed, num_labels\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Define colors\n    AZURE = 8\n    MAGENTA = 6\n    GREEN = 3\n    YELLOW = 4\n    \n    # Initialize output grid as a copy of the input\n    output_grid = input_grid.copy()\n    H, W = input_grid.shape\n\n    # --- Step 1: Preserve Magenta (already done by copying) ---\n\n    # --- Step 2: Create Green Border ---\n    # Find azure pixels adjacent to magenta\n    magenta_adjacency_mask = find_adjacent_pixels(input_grid, MAGENTA)\n    border_pixels_mask = magenta_adjacency_mask & (input_grid == AZURE)\n    # Change these azure pixels to green in the output\n    output_grid[border_pixels_mask] = GREEN\n\n    # --- Step 3 & 4: Identify and Fill Enclosed Azure Regions ---\n    # Find enclosed azure regions\n    labeled_enclosed, num_labels = find_enclosed_regions(input_grid, AZURE, MAGENTA)\n\n    if num_labels > 0:\n        # Iterate through each unique enclosed region label\n        for i in range(1, num_labels + 1):\n            # Get a mask for the current component\n            component_mask = (labeled_enclosed == i)\n            # Get coordinates of the pixels in this component\n            coords = np.argwhere(component_mask)\n            \n            num_pixels = len(coords)\n            if num_pixels == 0: # Should not happen with labels > 0\n                continue\n\n            # Calculate the bounding box dimensions of the azure pixels\n            min_r, min_c = coords.min(axis=0)\n            max_r, max_c = coords.max(axis=0)\n            height = max_r - min_r + 1\n            width = max_c - min_c + 1\n\n            # Determine fill color based on size: green if exactly 2x2, yellow otherwise\n            # Check height, width, and total number of pixels to ensure it's a filled 2x2 square\n            if height == 2 and width == 2 and num_pixels == 4:\n                fill_color = GREEN\n            else:\n                fill_color = YELLOW\n            \n            # Apply the fill color to the enclosed region in the output grid\n            # This overwrites the original azure pixels. It might overwrite\n            # green border pixels if an enclosed pixel was also adjacent to magenta,\n            # but the logic seems to prioritize the fill color based on examples.\n            output_grid[component_mask] = fill_color\n\n    # --- Step 5: Return final grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8495,
    "candidates_token_count": 1462,
    "total_token_count": 9957,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.068233,
  "retries": null
}