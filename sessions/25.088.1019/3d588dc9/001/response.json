{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify a unique pixel (excluding background and white) in the input grid. \nFind the white (color 0) object closest to this unique pixel. \nIf the unique pixel is horizontally to the right of the closest white object, change the rightmost column of that object to magenta (color 6).\nIf the unique pixel is horizontally to the left of the closest white object, change the leftmost column of that object to magenta (color 6).\nThe background color is assumed to be the most frequent color in the grid (orange, 7 in the examples).\nDistance is measured as the minimum Manhattan distance between the unique pixel and any pixel of the white object.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set[tuple[int, int]]]: A list of objects, where each object is a\n                                      set of (row, col) coordinates.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj.add((row, col))\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj:\n                    objects.append(obj)\n    return objects\n\ndef get_bounding_box(obj):\n    \"\"\"\n    Calculates the bounding box of an object.\n\n    Args:\n        obj (set[tuple[int, int]]): The object (set of coordinates).\n\n    Returns:\n        tuple[int, int, int, int]: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    if not obj:\n        return None\n    rows = [r for r, c in obj]\n    cols = [c for r, c in obj]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef manhattan_distance(p1, p2):\n    \"\"\"\n    Calculates the Manhattan distance between two points.\n\n    Args:\n        p1 (tuple[int, int]): First point (row, col).\n        p2 (tuple[int, int]): Second point (row, col).\n\n    Returns:\n        int: The Manhattan distance.\n    \"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_closest_point_in_object(point, obj):\n    \"\"\"\n    Finds the minimum Manhattan distance from a point to any point in an object.\n\n    Args:\n        point (tuple[int, int]): The reference point (row, col).\n        obj (set[tuple[int, int]]): The object (set of coordinates).\n\n    Returns:\n        int: The minimum Manhattan distance. Returns infinity if object is empty.\n    \"\"\"\n    if not obj:\n        return float('inf')\n    min_dist = float('inf')\n    for obj_point in obj:\n        dist = manhattan_distance(point, obj_point)\n        min_dist = min(min_dist, dist)\n    return min_dist\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Determine background color (most frequent color)\n    color_counts = Counter(grid.flatten())\n    if not color_counts:\n        return output_grid.tolist() # Handle empty grid case\n    background_color = color_counts.most_common(1)[0][0]\n    \n    # 2. Find the unique activating pixel (color count == 1, not background, not white)\n    unique_pixel_coord = None\n    unique_pixel_color = -1\n    \n    # Adjust counts to exclude background and white (0)\n    pixel_counts = Counter()\n    for r in range(rows):\n        for c in range(cols):\n             val = grid[r, c]\n             if val != background_color and val != 0:\n                 pixel_counts[val] += 1\n\n    unique_colors = [color for color, count in pixel_counts.items() if count == 1]\n\n    if len(unique_colors) == 1:\n        unique_pixel_color = unique_colors[0]\n        # Find the coordinates of this unique pixel\n        unique_pixel_coords_list = np.argwhere(grid == unique_pixel_color)\n        if len(unique_pixel_coords_list) == 1:\n             unique_pixel_coord = tuple(unique_pixel_coords_list[0])\n    \n    if unique_pixel_coord is None:\n        # No unique pixel found, return original grid\n        return output_grid.tolist()\n\n    # 3. Find all white objects\n    white_objects = find_objects(grid, 0)\n    if not white_objects:\n        # No white objects found, return original grid\n        return output_grid.tolist()\n\n    # 4. Find the white object closest to the unique pixel\n    min_dist = float('inf')\n    target_white_object = None\n    for obj in white_objects:\n        dist = find_closest_point_in_object(unique_pixel_coord, obj)\n        if dist < min_dist:\n            min_dist = dist\n            target_white_object = obj\n        # Tie-breaking: could add rules here if needed, e.g., top-most, left-most\n        # For now, the first one found with the min distance is kept.\n\n    if target_white_object is None:\n         # Should not happen if white_objects is not empty, but good practice\n        return output_grid.tolist()\n\n    # 5. Get bounding box and relative position\n    min_r, min_c, max_r, max_c = get_bounding_box(target_white_object)\n    unique_r, unique_c = unique_pixel_coord\n\n    # 6. Modify the output grid based on relative position\n    modification_color = 6 # magenta\n    \n    if unique_c > max_c: # Unique pixel is to the right\n        # Change rightmost column (max_c) of the object to magenta\n        for r, c in target_white_object:\n            if c == max_c:\n                output_grid[r, c] = modification_color\n                \n    elif unique_c < min_c: # Unique pixel is to the left\n        # Change leftmost column (min_c) of the object to magenta\n        for r, c in target_white_object:\n            if c == min_c:\n                output_grid[r, c] = modification_color\n                \n    # If unique_c is between min_c and max_c (inclusive), no change happens per observed logic.\n\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4373,
    "candidates_token_count": 1842,
    "total_token_count": 6215,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.346124,
  "retries": null
}