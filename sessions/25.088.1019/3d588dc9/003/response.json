{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\n1. Determine the background color (most frequent).\n2. Find all \"activator pixels\": isolated pixels (no neighbors, including diagonals, of the same color) that are not background and not white (0).\n3. If multiple activators exist, select the one closest (Manhattan distance) to its individually nearest white object.\n4. Identify the target white object: the white object closest (minimum Manhattan distance) to the selected activator pixel.\n5. If the activator pixel is horizontally to the right of the target white object's bounding box, change the rightmost column of the object to magenta (6).\n6. If the activator pixel is horizontally to the left of the target white object's bounding box, change the leftmost column of the object to magenta (6).\n7. Otherwise, make no changes.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set[tuple[int, int]]]: A list of objects, where each object is a\n                                      set of (row, col) coordinates.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj.add((row, col))\n                    # Use 4-connectivity for finding objects\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj:\n                    objects.append(obj)\n    return objects\n\ndef is_isolated(grid, r, c):\n    \"\"\"\n    Checks if a pixel at (r, c) is isolated from pixels of the same color.\n    Isolation means no neighbors (including diagonals) have the same color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n\n    Returns:\n        bool: True if the pixel is isolated, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    pixel_color = grid[r, c]\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == pixel_color:\n                return False\n    return True\n\ndef get_bounding_box(obj):\n    \"\"\"\n    Calculates the bounding box of an object.\n\n    Args:\n        obj (set[tuple[int, int]]): The object (set of coordinates).\n\n    Returns:\n        tuple[int, int, int, int]: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    if not obj:\n        return None\n    rows = [r for r, c in obj]\n    cols = [c for r, c in obj]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef manhattan_distance(p1, p2):\n    \"\"\"\n    Calculates the Manhattan distance between two points.\n\n    Args:\n        p1 (tuple[int, int]): First point (row, col).\n        p2 (tuple[int, int]): Second point (row, col).\n\n    Returns:\n        int: The Manhattan distance.\n    \"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_closest_point_in_object(point, obj):\n    \"\"\"\n    Finds the minimum Manhattan distance from a point to any point in an object.\n\n    Args:\n        point (tuple[int, int]): The reference point (row, col).\n        obj (set[tuple[int, int]]): The object (set of coordinates).\n\n    Returns:\n        int: The minimum Manhattan distance. Returns infinity if object is empty.\n    \"\"\"\n    if not obj:\n        return float('inf')\n    min_dist = float('inf')\n    for obj_point in obj:\n        dist = manhattan_distance(point, obj_point)\n        min_dist = min(min_dist, dist)\n    return min_dist\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Determine background color (most frequent color)\n    color_counts = Counter(grid.flatten())\n    if not color_counts:\n        return output_grid.tolist() # Handle empty grid case\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Find potential activator pixels (isolated, not background, not white)\n    potential_activators = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color and color != 0:\n                if is_isolated(grid, r, c):\n                    potential_activators.append(((r, c), color))\n\n    # 3. If no potential activators, return original grid\n    if not potential_activators:\n        return output_grid.tolist()\n\n    # 4. Find all white objects\n    white_objects = find_objects(grid, 0)\n    if not white_objects:\n        return output_grid.tolist() # No white objects, return original grid\n\n    # 5. Select the main activator\n    selected_activator_coord = None\n    if len(potential_activators) == 1:\n        selected_activator_coord = potential_activators[0][0]\n    else:\n        # 6. If multiple activators, find the one closest to its nearest white object\n        min_overall_dist = float('inf')\n        best_activator_coord = None\n        for activator_coord, _ in potential_activators:\n            min_dist_to_any_white = float('inf')\n            for white_obj in white_objects:\n                dist = find_closest_point_in_object(activator_coord, white_obj)\n                min_dist_to_any_white = min(min_dist_to_any_white, dist)\n\n            if min_dist_to_any_white < min_overall_dist:\n                 min_overall_dist = min_dist_to_any_white\n                 best_activator_coord = activator_coord\n            # Tie-breaking: Current logic takes the first one found with the min distance.\n            # More sophisticated tie-breaking (e.g., top-left) could be added if needed.\n\n        selected_activator_coord = best_activator_coord\n\n    if selected_activator_coord is None:\n         # This case might occur if multiple activators exist but tie-breaking fails or an edge case.\n         # Or if somehow no best activator was found despite multiple potentials.\n         return output_grid.tolist() # Return original if no activator could be definitively selected\n\n    # 7. Find the target white object (closest to the *selected* activator)\n    min_dist_to_selected = float('inf')\n    target_white_object = None\n    for obj in white_objects:\n        dist = find_closest_point_in_object(selected_activator_coord, obj)\n        if dist < min_dist_to_selected:\n            min_dist_to_selected = dist\n            target_white_object = obj\n        # Tie-breaking: again, takes the first found closest object.\n\n    if target_white_object is None:\n         # Should not happen if white_objects is not empty, but good practice\n        return output_grid.tolist()\n\n    # 8. Get bounding box of the target white object\n    min_r, min_c, max_r, max_c = get_bounding_box(target_white_object)\n    activator_r, activator_c = selected_activator_coord\n\n    # 9. Modify the output grid based on relative position\n    modification_color = 6 # magenta\n\n    # 10. Apply modification logic\n    if activator_c > max_c: # Activator is strictly to the right\n        # Change rightmost column (max_c) of the object to magenta\n        for r, c in target_white_object:\n            if c == max_c:\n                output_grid[r, c] = modification_color\n\n    elif activator_c < min_c: # Activator is strictly to the left\n        # Change leftmost column (min_c) of the object to magenta\n        for r, c in target_white_object:\n            if c == min_c:\n                output_grid[r, c] = modification_color\n\n    # Otherwise (activator column within or equal to min/max bounds), no change\n\n    # 11. Return the modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8502,
    "candidates_token_count": 2291,
    "total_token_count": 10793,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.988306,
  "retries": null
}