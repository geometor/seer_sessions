{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom skimage.measure import label\nfrom skimage.draw import polygon\nfrom scipy.spatial import ConvexHull, QhullError\nfrom scipy.ndimage import binary_dilation, generate_binary_structure\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify Colors:\n    a.  Determine the background color (most frequent).\n    b.  Identify the two non-background colors. If not exactly two, return the input unchanged.\n    c.  Count orthogonal adjacencies between each non-background color and the background color.\n    d.  The non-background color with more background adjacencies is the 'frame' color; the other is the 'fill' color.\n    e.  Handle ties: If counts are equal, check if only one touches the background; if still tied or both touch equally, the color with the lower numerical value is the 'frame' color. If neither touches the background, return input unchanged.\n2.  Prepare Output: Create a copy of the input grid.\n3.  Find Frame Objects: Identify all distinct groups (objects) of orthogonally connected 'frame' color pixels.\n4.  Process Each Frame Object: For each object:\n    a.  Get its pixel coordinates.\n    b.  Find all background pixels orthogonally adjacent to this object.\n    c.  If the object size is 1 or 2 pixels: Target all these adjacent background pixels.\n    d.  If the object size is 3 or more pixels:\n        i.  Calculate the coordinates covered by the filled convex hull of the object's pixels.\n        ii. Target only those adjacent background pixels whose coordinates are *outside* this filled convex hull.\n    e.  Fill Target Pixels: Change the color of the targeted background pixels to the 'fill' color in the output grid.\n5.  Return Result: Return the modified output grid.\n\"\"\"\n\n# Helper function to identify background, frame, and fill colors\ndef _identify_colors(input_array):\n    \"\"\"Identifies background, frame, and fill colors based on frequency and adjacency.\"\"\"\n    colors, counts = np.unique(input_array, return_counts=True)\n\n    # Need at least background + 2 other colors\n    if len(colors) < 3:\n        return None, None, None\n\n    background_color = colors[np.argmax(counts)]\n    non_background_colors = sorted([c for c in colors if c != background_color])\n\n    # Must have exactly two non-background colors\n    if len(non_background_colors) != 2:\n        return None, None, None\n\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    rows, cols = input_array.shape\n    adj_counts = {color1: 0, color2: 0}\n\n    # Define orthogonal neighbors shifts\n    shifts = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Count adjacencies to background for each non-background color\n    for r in range(rows):\n        for c in range(cols):\n            current_color = input_array[r, c]\n            if current_color == color1 or current_color == color2:\n                for dr, dc in shifts:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if input_array[nr, nc] == background_color:\n                            adj_counts[current_color] += 1\n\n    # Determine frame and fill based on adjacency counts\n    c1_adj = adj_counts[color1]\n    c2_adj = adj_counts[color2]\n\n    if c1_adj == 0 and c2_adj == 0:\n         # Neither color touches the background\n         return None, None, None\n    elif c1_adj > c2_adj:\n        frame_color = color1\n        fill_color = color2\n    elif c2_adj > c1_adj:\n        frame_color = color2\n        fill_color = color1\n    else: # Equal adjacency counts - tie-breaking needed\n        # Check if only one touches the background at all\n        c1_touches = c1_adj > 0\n        c2_touches = c2_adj > 0\n        if c1_touches and not c2_touches:\n             frame_color = color1\n             fill_color = color2\n        elif c2_touches and not c1_touches:\n             frame_color = color2\n             fill_color = color1\n        else: # Still ambiguous (both touch equally or neither touches - though latter is handled above)\n              # Use the lower numerical color value as frame\n              frame_color = min(color1, color2)\n              fill_color = max(color1, color2)\n\n    return background_color, frame_color, fill_color\n\n# Helper function to get coordinates covered by a filled convex hull\ndef _get_filled_convex_hull_coords(coords, grid_shape):\n    \"\"\"Computes the filled convex hull coordinates for a set of points.\"\"\"\n    if not coords:\n        return set()\n    if len(coords) < 3:\n        # For 1 or 2 points, the \"hull\" is just the points themselves.\n        return set(coords)\n\n    # Convert (row, col) to (x, y) for ConvexHull, which expects (col, row)\n    points = np.array(list(coords))[:, ::-1]\n    \n    try:\n        hull = ConvexHull(points)\n        # Get vertices in order (col, row)\n        hull_vertices = points[hull.vertices] \n        # Use skimage.draw.polygon to fill the hull. It needs (rows, cols) or (y, x)\n        # hull_vertices[:, 1] are row coordinates (y)\n        # hull_vertices[:, 0] are column coordinates (x)\n        rr, cc = polygon(hull_vertices[:, 1], hull_vertices[:, 0], shape=grid_shape)\n        hull_coords = set(zip(rr, cc)) # Store as (row, col)\n        return hull_coords\n    except QhullError:\n        # Handle collinear points - treat as a line segment or points\n        # For simplicity, we can just return the original points in this case,\n        # or try to draw a line if needed, but the original points cover the minimum case.\n        # A more robust line drawing could be added if examples require it.\n         return set(coords)\n    except Exception as e:\n        # Catch other potential issues\n        print(f\"Error during convex hull calculation: {e}\")\n        return set(coords) # Fallback\n\n# Main transformation function\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying frame/fill colors, finding frame objects,\n    and filling adjacent background pixels based on whether they are inside or outside\n    the convex hull of the frame object (for objects size >= 3).\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1. Identify Colors\n    background_color, frame_color, fill_color = _identify_colors(input_array)\n\n    # If colors can't be determined as required, return the original grid\n    if background_color is None or frame_color is None or fill_color is None:\n        return input_grid\n\n    # 3. Find Frame Objects\n    frame_mask = (input_array == frame_color)\n    # Use connectivity=1 for 4-connectivity (orthogonal)\n    labeled_frame_objects, num_labels = label(frame_mask, connectivity=1, background=0, return_num=True)\n\n    # Define structure for orthogonal adjacency check (dilation)\n    struct = generate_binary_structure(2, 1) # Orthogonal connectivity\n\n    # 4. Process Each Frame Object\n    for i in range(1, num_labels + 1):\n        # a. Get coordinates of the current frame object\n        current_object_mask = (labeled_frame_objects == i)\n        frame_object_coords_tuple = tuple(map(tuple, np.argwhere(current_object_mask)))\n        frame_object_coords_set = set(frame_object_coords_tuple)\n        object_size = len(frame_object_coords_set)\n\n        # b. Find all background pixels orthogonally adjacent to this object\n        # Dilate the object mask\n        dilated_object = binary_dilation(current_object_mask, structure=struct)\n        # Find pixels in dilation but not in original object (adjacent pixels)\n        adjacent_mask = dilated_object & ~current_object_mask\n        # Filter these adjacent pixels to keep only those that are background color\n        adjacent_bg_mask = adjacent_mask & (input_array == background_color)\n        adjacent_bg_coords_tuple = tuple(map(tuple, np.argwhere(adjacent_bg_mask)))\n        adjacent_bg_coords_set = set(adjacent_bg_coords_tuple)\n\n        if not adjacent_bg_coords_set:\n             continue # No background neighbors for this object\n\n        # Determine which adjacent background pixels to fill\n        pixels_to_fill = set()\n        if object_size < 3:\n            # c. If object size is 1 or 2, fill all adjacent background pixels\n            pixels_to_fill = adjacent_bg_coords_set\n        else:\n            # d. If object size is 3 or more, calculate hull and fill exterior adjacent background\n            # i. Calculate filled convex hull coordinates\n            hull_coords_set = _get_filled_convex_hull_coords(frame_object_coords_set, (rows, cols))\n            # ii. Target adjacent background pixels *outside* the hull\n            for r, c in adjacent_bg_coords_set:\n                if (r, c) not in hull_coords_set:\n                    pixels_to_fill.add((r,c))\n\n        # e. Fill Target Pixels in the output grid\n        for r, c in pixels_to_fill:\n            # Ensure coordinates are within bounds (should be, but belt-and-suspenders)\n            if 0 <= r < rows and 0 <= c < cols:\n                 output_array[r, c] = fill_color\n\n    # 5. Return Result\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5156,
    "candidates_token_count": 2409,
    "total_token_count": 7565,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.98978,
  "retries": null
}