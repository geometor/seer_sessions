{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the background color (most frequent color).\n2.  Identify the two non-background colors present in the central pattern.\n3.  Determine which of these two colors is the 'frame' color (adjacent to the background) and which is the 'fill' color (the other one).\n4.  Create an output grid initialized as a copy of the input grid.\n5.  Iterate through each pixel of the input grid.\n6.  If a pixel is the background color and has at least one direct neighbor (up, down, left, right) with the 'frame' color, change this pixel's color in the output grid to the 'fill' color.\n7.  Otherwise, the pixel retains its original color in the output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1. Identify background color (most frequent)\n    colors, counts = np.unique(input_array, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Identify the two non-background colors\n    non_background_colors = [c for c in colors if c != background_color]\n    \n    # Check if we have exactly two non-background colors as expected\n    if len(non_background_colors) != 2:\n        # Handle unexpected case, maybe return input or raise error\n        # For now, assume the pattern holds based on examples\n        print(f\"Warning: Expected 2 non-background colors, found {len(non_background_colors)}. Proceeding with available colors.\")\n        if not non_background_colors: return input_grid # Cannot proceed\n        # If only one, logic below might need adjustment, but let's try\n        \n    frame_color = -1 # Initialize with invalid value\n    fill_color = -1  # Initialize with invalid value\n\n    # 3. Determine frame and fill colors\n    possible_frame_colors = set()\n    for r in range(rows):\n        for c in range(cols):\n            color = input_array[r, c]\n            if color in non_background_colors:\n                # Check neighbors for background color\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check boundaries\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if input_array[nr, nc] == background_color:\n                            possible_frame_colors.add(color)\n                            break # Found adjacent background, no need to check other neighbors for this cell\n\n    # Based on examples, only one non-background color should be adjacent to background\n    if len(possible_frame_colors) == 1:\n         frame_color = list(possible_frame_colors)[0]\n         # Fill color is the other non-background color\n         for c in non_background_colors:\n             if c != frame_color:\n                 fill_color = c\n                 break\n    elif len(possible_frame_colors) == 2 and len(non_background_colors) == 2:\n         # This case is ambiguous based on the rule description, but unlikely given examples.\n         # If it occurs, we might need a more specific rule (e.g., which color appears more on the border?)\n         # Let's arbitrarily pick one based on value, though this is a guess.\n         print(\"Warning: Ambiguous frame/fill colors. Both touch background.\")\n         frame_color = min(non_background_colors) # Arbitrary choice\n         fill_color = max(non_background_colors) # Arbitrary choice\n    elif len(possible_frame_colors) == 0 and len(non_background_colors) > 0:\n         # None touch background? Maybe the pattern is fully enclosed.\n         # This violates the premise, but let's handle it. Assign arbitrarily.\n         print(\"Warning: No non-background color touches background.\")\n         if len(non_background_colors) >= 1: frame_color = non_background_colors[0]\n         if len(non_background_colors) >= 2: fill_color = non_background_colors[1]\n         else: fill_color = frame_color # If only one non-bg color, it's both?\n    elif not non_background_colors:\n        print(\"Warning: No non-background colors found.\")\n        return input_grid # Nothing to transform\n    else: # If only one non_bg color was found initially, and it touched background\n        frame_color = list(possible_frame_colors)[0]\n        fill_color = frame_color # Use the same color? The rule needs clarification here. Let's assume this for now.\n\n\n    # Check if frame and fill colors were successfully assigned\n    if frame_color == -1 or fill_color == -1:\n        print(\"Error: Could not determine frame or fill color reliably.\")\n        return input_grid # Return original if colors couldn't be determined\n\n\n    # 4. & 5. Iterate through grid and apply transformation\n    for r in range(rows):\n        for c in range(cols):\n            # 6. Check if the current pixel is background\n            if input_array[r, c] == background_color:\n                # Check direct neighbors (up, down, left, right)\n                has_frame_neighbor = False\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check boundaries\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if neighbor is the frame color\n                        if input_array[nr, nc] == frame_color:\n                            has_frame_neighbor = True\n                            break # Found one, no need to check others\n                \n                # If it has a frame color neighbor, change the output pixel to fill color\n                if has_frame_neighbor:\n                    output_array[r, c] = fill_color\n            # 7. Otherwise (pixel is not background, or is background but no frame neighbor), \n            # the output_array already has the correct original color from the copy.\n\n    # Convert the result back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4257,
    "candidates_token_count": 1534,
    "total_token_count": 5791,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.463472,
  "retries": null
}