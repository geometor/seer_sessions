{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom skimage.measure import label\nfrom skimage.draw import polygon\nfrom scipy.spatial import ConvexHull\nfrom scipy.ndimage import binary_dilation, generate_binary_structure\n\n\"\"\"\nTransformation Rule:\n\n1.  Determine the background color (the most frequent color in the grid).\n2.  Identify the two non-background colors present.\n3.  Determine the 'frame' color by finding which of the two non-background colors has more pixels directly adjacent (up, down, left, right) to background pixels. The other non-background color is the 'fill' color.\n4.  Find all connected groups (objects) of pixels that have the 'frame' color, using orthogonal adjacency.\n5.  Create the output grid, starting as a copy of the input grid.\n6.  For each 'frame' object found:\n    a. If the object has 1 or 2 pixels, find all background pixels orthogonally adjacent to it and change them to the 'fill' color in the output grid.\n    b. If the object has 3 or more pixels:\n        i. Get the coordinates of the pixels in the object.\n        ii. Calculate the convex hull covering these coordinates.\n        iii. Determine all integer grid coordinates that fall within this filled convex hull.\n        iv. Find all background pixels in the input grid that are orthogonally adjacent to any pixel of this 'frame' object.\n        v. From this set of adjacent background pixels, keep only those whose coordinates do *not* fall inside the calculated filled convex hull of the 'frame' object.\n        vi. Change the color of these remaining 'exterior' adjacent background pixels to the 'fill' color in the output grid.\n7.  Return the final output grid.\n\"\"\"\n\ndef _identify_colors(input_array):\n    \"\"\"Identifies background, frame, and fill colors.\"\"\"\n    colors, counts = np.unique(input_array, return_counts=True)\n    \n    if len(colors) <= 1:\n        # Not enough colors to perform the transformation\n        return None, None, None \n\n    background_color = colors[np.argmax(counts)]\n    non_background_colors = sorted([c for c in colors if c != background_color])\n\n    if len(non_background_colors) != 2:\n        # Requires exactly two non-background colors\n        return None, None, None\n\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    rows, cols = input_array.shape\n    adj_counts = {color1: 0, color2: 0}\n    \n    # Create shifted arrays to find neighbors efficiently\n    neighbors = {}\n    neighbors['up'] = np.pad(input_array[1:, :], ((0, 1), (0, 0)), mode='constant', constant_values=-1)\n    neighbors['down'] = np.pad(input_array[:-1, :], ((1, 0), (0, 0)), mode='constant', constant_values=-1)\n    neighbors['left'] = np.pad(input_array[:, 1:], ((0, 0), (0, 1)), mode='constant', constant_values=-1)\n    neighbors['right'] = np.pad(input_array[:, :-1], ((0, 0), (1, 0)), mode='constant', constant_values=-1)\n\n    # Count adjacencies to background for each non-background color\n    for color in [color1, color2]:\n        mask_color = (input_array == color)\n        count = 0\n        for direction in ['up', 'down', 'left', 'right']:\n            is_bg_neighbor = (neighbors[direction] == background_color)\n            count += np.sum(mask_color & is_bg_neighbor)\n        adj_counts[color] = count # Note: This counts adjacencies, not pixels with adjacent bg\n\n    # Determine frame and fill based on counts\n    if adj_counts[color1] == 0 and adj_counts[color2] == 0:\n        return None, None, None # Neither touches background\n    elif adj_counts[color1] > adj_counts[color2]:\n        frame_color = color1\n        fill_color = color2\n    elif adj_counts[color2] > adj_counts[color1]:\n        frame_color = color2\n        fill_color = color1\n    else: # Equal counts or one is zero - default to simple adjacency check / min value\n        # Check if only one touches at all\n        c1_touches = np.any((input_array == color1) & np.isin(neighbors['up'], background_color) | \\\n                            (input_array == color1) & np.isin(neighbors['down'], background_color) | \\\n                            (input_array == color1) & np.isin(neighbors['left'], background_color) | \\\n                            (input_array == color1) & np.isin(neighbors['right'], background_color))\n        c2_touches = np.any((input_array == color2) & np.isin(neighbors['up'], background_color) | \\\n                            (input_array == color2) & np.isin(neighbors['down'], background_color) | \\\n                            (input_array == color2) & np.isin(neighbors['left'], background_color) | \\\n                            (input_array == color2) & np.isin(neighbors['right'], background_color))\n\n        if c1_touches and not c2_touches:\n            frame_color = color1\n            fill_color = color2\n        elif c2_touches and not c1_touches:\n             frame_color = color2\n             fill_color = color1\n        else: # Still ambiguous or both touch equally, use min value as tie-breaker\n             frame_color = min(color1, color2)\n             fill_color = max(color1, color2)\n             \n    return background_color, frame_color, fill_color\n\n\ndef _get_filled_convex_hull_coords(coords, grid_shape):\n    \"\"\"Computes the filled convex hull coordinates for a set of points.\"\"\"\n    if len(coords) < 3:\n        return set(coords) # Hull is just the points themselves for 1 or 2 points\n\n    points = np.array(coords)[:, ::-1] # Convert (row, col) to (x, y) for ConvexHull\n    try:\n        hull = ConvexHull(points)\n        hull_vertices = points[hull.vertices]\n    except: # QhullError might happen for collinear points\n        # Fallback for collinear points: treat as a line segment or single point\n         min_r, min_c = np.min(coords, axis=0)\n         max_r, max_c = np.max(coords, axis=0)\n         if min_r == max_r: # Horizontal line\n             rr, cc = np.array([min_r] * (max_c - min_c + 1)), np.arange(min_c, max_c + 1)\n         elif min_c == max_c: # Vertical line\n             rr, cc = np.arange(min_r, max_r + 1), np.array([min_c] * (max_r - min_r + 1))\n         else: # Diagonal or single point - skimage.draw.line? For now, just return points\n              return set(coords) # Fallback for complex collinear cases\n              \n         hull_coords = set(zip(rr, cc))\n         return hull_coords\n\n\n    # Use skimage.draw.polygon to fill the hull\n    # hull_vertices[:, 1] are row coordinates, hull_vertices[:, 0] are column coordinates\n    rr, cc = polygon(hull_vertices[:, 1], hull_vertices[:, 0], shape=grid_shape)\n    hull_coords = set(zip(rr, cc))\n    return hull_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the convex hull-based frame outlining transformation.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1, 2, 3: Identify background, frame, and fill colors\n    background_color, frame_color, fill_color = _identify_colors(input_array)\n\n    if background_color is None or frame_color is None or fill_color is None:\n        # If colors can't be identified according to rules, return original grid\n        return input_grid\n\n    # 4: Find connected components (objects) of the frame color\n    frame_mask = (input_array == frame_color)\n    # Use connectivity=1 for 4-connectivity (orthogonal)\n    labeled_frame_objects, num_labels = label(frame_mask, connectivity=1, background=0, return_num=True)\n\n    # Define structure for orthogonal adjacency check (dilation)\n    struct = generate_binary_structure(2, 1) \n\n    # 6: Process each frame object\n    for i in range(1, num_labels + 1):\n        # a/bi: Get coordinates of the current frame object\n        frame_object_coords_tuple = tuple(map(tuple, np.argwhere(labeled_frame_objects == i)))\n        frame_object_coords_set = set(frame_object_coords_tuple)\n        \n        # Create a mask for the current object\n        current_object_mask = (labeled_frame_objects == i)\n\n        # 4c / 6b iv: Find all adjacent pixels (including non-BG for now) using dilation\n        dilated_object = binary_dilation(current_object_mask, structure=struct)\n        adjacent_mask = dilated_object & ~current_object_mask \n        \n        # Filter for adjacent pixels that are background color in the input\n        adjacent_bg_mask = adjacent_mask & (input_array == background_color)\n        adjacent_bg_coords_tuple = tuple(map(tuple, np.argwhere(adjacent_bg_mask)))\n        \n        if not adjacent_bg_coords_tuple:\n             continue # No background neighbors for this object\n\n        # Handle small objects (1 or 2 pixels) separately - fill all adjacent BG\n        if len(frame_object_coords_set) < 3:\n             for r, c in adjacent_bg_coords_tuple:\n                 output_array[r,c] = fill_color\n             continue # Move to next object\n\n        # b ii/iii: Calculate filled convex hull coordinates\n        hull_coords_set = _get_filled_convex_hull_coords(frame_object_coords_tuple, (rows, cols))\n\n        # b v: Filter adjacent background pixels: keep only those outside the hull\n        for r, c in adjacent_bg_coords_tuple:\n            if (r, c) not in hull_coords_set:\n                # b vi: Change color in output grid\n                output_array[r, c] = fill_color\n\n    # 7: Return the modified grid\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21449,
    "candidates_token_count": 2561,
    "total_token_count": 24010,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.828237,
  "retries": null
}