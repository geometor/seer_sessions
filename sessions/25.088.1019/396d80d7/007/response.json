{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransformation Rule:\n\n1.  Analyze Colors:\n    a.  Identify the most frequent color in the input grid; this is the `background_color`.\n    b.  Identify the two other colors present. If there are not exactly two other colors, return the input grid unchanged.\n    c.  Count, for each of the two non-background colors, how many times its pixels are orthogonally adjacent to a `background_color` pixel.\n    d.  The non-background color with the strictly *higher* count of adjacencies to the background is the `frame_color`. The other non-background color is the `fill_color`.\n    e.  If the adjacency counts are equal, the non-background color with the *lower* numerical value is the `frame_color`, and the other is the `fill_color`.\n    f.  If *neither* non-background color has any adjacency to the background, return the input grid unchanged.\n2.  Prepare Output: Create a mutable copy of the input grid.\n3.  Process Frame Objects:\n    a.  Find all distinct groups (objects) of orthogonally connected pixels that have the `frame_color`.\n    b.  For each `frame_object` found:\n        i.  Identify all `background_color` pixels that are orthogonally adjacent to *any* pixel within this `frame_object`. Let this set be `adjacent_background_pixels`.\n        ii. Determine Fill Targets: Select *all* pixels from `adjacent_background_pixels` to be filled. (Simplified hypothesis, replacing previous complex rule).\n        iii. Apply Fill: Change the color of the selected target pixels in the output grid to the `fill_color`.\n4.  Return Result: Return the modified output grid.\n\"\"\"\n\ndef _identify_colors(input_array):\n    \"\"\"\n    Identifies background, frame, and fill colors based on frequency and adjacency.\n\n    Args:\n        input_array: numpy array representing the input grid.\n\n    Returns:\n        A tuple (background_color, frame_color, fill_color).\n        Returns (None, None, None) if the criteria (e.g., exactly 3 colors,\n        non-background colors adjacent to background) are not met.\n    \"\"\"\n    colors, counts = np.unique(input_array, return_counts=True)\n\n    # Check for exactly 3 colors\n    if len(colors) != 3:\n        return None, None, None\n\n    # Identify background color (most frequent)\n    background_color = colors[np.argmax(counts)]\n    non_background_colors = sorted([c for c in colors if c != background_color])\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n\n    rows, cols = input_array.shape\n    adj_counts = {color1: 0, color2: 0}\n    shifts = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Orthogonal neighbors\n\n    # Count adjacencies to background for each non-background color\n    for r in range(rows):\n        for c in range(cols):\n            current_color = input_array[r, c]\n            if current_color == color1 or current_color == color2:\n                for dr, dc in shifts:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if input_array[nr, nc] == background_color:\n                            adj_counts[current_color] += 1\n\n    c1_adj = adj_counts[color1]\n    c2_adj = adj_counts[color2]\n\n    # Check if at least one non-background color touches the background\n    if c1_adj == 0 and c2_adj == 0:\n         return None, None, None\n\n    # Determine frame and fill based on adjacency counts and tie-breaking\n    if c1_adj > c2_adj:\n        frame_color = color1\n        fill_color = color2\n    elif c2_adj > c1_adj:\n        frame_color = color2\n        fill_color = color1\n    else: # Equal adjacency counts - tie-break using numerical value\n        frame_color = min(color1, color2)\n        fill_color = max(color1, color2)\n\n    return background_color, frame_color, fill_color\n\ndef _find_objects(grid, target_color):\n    \"\"\"\n    Finds all distinct orthogonally connected objects of a target color in the grid.\n\n    Args:\n        grid: numpy array representing the grid.\n        target_color: The color of the objects to find.\n\n    Returns:\n        A list of lists, where each inner list contains (row, col) tuples\n        representing the coordinates of one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    shifts = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Orthogonal neighbors\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's the target color and not visited yet, start BFS\n            if grid[r, c] == target_color and not visited[r, c]:\n                obj_coords = []\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    # Explore neighbors\n                    for dr, dc in shifts:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, target color, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords: # Add the found object\n                    objects.append(obj_coords)\n    return objects\n\ndef _get_adjacent_coords(coords, grid_shape, target_color, grid):\n    \"\"\"\n    Finds all coordinates of a specific target_color orthogonally adjacent\n    to any coordinate in the input list `coords`.\n\n    Args:\n        coords: A list or set of (row, col) tuples representing the source object.\n        grid_shape: A tuple (rows, cols) of the grid dimensions.\n        target_color: The color to search for in adjacent cells.\n        grid: The numpy array representing the grid.\n\n    Returns:\n        A set of (row, col) tuples of adjacent cells with the target_color.\n    \"\"\"\n    rows, cols = grid_shape\n    adjacent = set()\n    shifts = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Orthogonal neighbors\n    object_coords_set = set(coords) # Use set for faster checking if neighbor is part of object\n\n    for r, c in coords:\n        for dr, dc in shifts:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 # Check if the neighbor is the target color AND not part of the object itself\n                 if grid[nr, nc] == target_color and (nr, nc) not in object_coords_set:\n                    adjacent.add((nr, nc))\n    return adjacent\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding 'frame' objects and filling adjacent\n    'background' pixels with the 'fill' color. Color roles are determined by\n    frequency and adjacency counts.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1. Analyze Colors\n    background_color, frame_color, fill_color = _identify_colors(input_array)\n\n    # If colors can't be determined as required, return the original grid\n    if background_color is None or frame_color is None or fill_color is None:\n        # Convert back to list of lists for ARC standard\n        return input_array.tolist()\n\n    # 3a. Find Frame Objects\n    frame_objects = _find_objects(input_array, frame_color)\n\n    # 3b. Process Each Frame Object\n    pixels_to_fill = set()\n    for obj_coords in frame_objects:\n        # 3bi. Identify adjacent background pixels\n        adjacent_background_pixels = _get_adjacent_coords(\n            obj_coords, (rows, cols), background_color, input_array\n        )\n\n        # 3bii. Determine Fill Targets: Select all adjacent background pixels\n        # (Simplified hypothesis compared to previous attempts)\n        pixels_to_fill.update(adjacent_background_pixels)\n\n    # 3biii. Apply Fill (modify the output array)\n    for r, c in pixels_to_fill:\n         # Check bounds just in case, although _get_adjacent_coords should ensure this\n         if 0 <= r < rows and 0 <= c < cols:\n             output_array[r, c] = fill_color\n\n    # 4. Return Result\n    # Convert back to list of lists for ARC standard\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7430,
    "candidates_token_count": 2191,
    "total_token_count": 9621,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.920507,
  "retries": null
}