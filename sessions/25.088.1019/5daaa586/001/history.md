
## train_1

**input:**
```
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
8 8 4 8 8 8 8 8 8 1 8 8
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 8 0 0 1 0 8
0 0 4 8 0 0 8 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 8 0 1 0 8
6 6 6 6 6 6 6 6 6 1 6 6
0 0 4 0 0 0 8 0 0 1 0 0
0 8 4 0 0 0 0 8 0 1 0 0
```


**output:**
```
4 8 8 8 8 8 8 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 0 0 0 0 8 0 1
4 0 0 0 0 8 0 1
6 6 6 6 6 6 6 1
```


## train_2

**input:**
```
0 0 0 0 0 3 0 0 0 2 0 0 0 0 0 0 8 0 0 0 0 0
1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 2 8 0 0 0 0 0
0 0 0 2 0 3 0 0 0 0 0 0 0 0 0 0 8 0 2 0 0 0
0 0 0 0 0 3 0 0 0 2 0 0 0 0 0 0 8 0 0 2 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 2 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 2 0 3 0 2 0 0 0 0 0 0 2 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 2 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 2 2 2 2 3 2 2 2 2 2 2 2 2 2 2 8 2 2 2 2 2
0 0 0 0 0 3 0 0 2 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 2 0
```


**output:**
```
3 1 1 1 1 1 1 1 1 1 1 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 2 8
3 0 0 0 0 0 0 0 0 0 2 8
3 0 0 0 2 0 0 0 0 0 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 2 0 2 0 0 0 0 2 2 8
3 0 2 0 2 0 0 0 0 2 2 8
3 2 2 0 2 0 0 0 0 2 2 8
3 2 2 2 2 2 2 2 2 2 2 8
```


## train_3

**input:**
```
0 0 4 3 0 0 0 4 0 0 0 4 0 0 0
0 0 0 3 0 4 0 0 0 0 0 4 0 0 0
0 0 0 3 0 0 4 0 0 0 0 4 0 0 0
0 0 0 3 0 4 0 0 0 0 0 4 0 0 0
0 0 0 3 0 0 0 0 0 0 4 4 4 0 4
2 2 2 3 2 2 2 2 2 2 2 4 2 2 2
4 0 0 3 4 4 0 4 0 0 0 4 0 0 0
0 0 0 3 0 0 0 0 0 0 0 4 0 0 0
4 0 0 3 0 0 0 0 4 0 4 4 0 0 0
4 0 0 3 0 0 4 0 0 0 4 4 0 0 0
8 8 8 3 8 8 8 8 8 8 8 4 8 8 8
0 0 0 3 0 0 0 0 0 0 4 4 0 0 4
0 0 0 3 4 0 0 4 0 0 0 4 0 0 0
0 0 4 3 0 0 0 0 0 4 0 4 0 0 0
```


**output:**
```
3 2 2 2 2 2 2 2 4
3 4 4 4 4 4 4 4 4
3 0 0 0 0 0 0 0 4
3 0 0 0 0 4 4 4 4
3 0 0 4 4 4 4 4 4
3 8 8 8 8 8 8 8 4
```

Okay, let's analyze the task examples.

## Perception

1.  **Input Grid Structure:** Each input grid contains a background (usually white pixels, value 0), scattered non-white pixels, and four distinct lines.
2.  **Line Objects:** There are always two vertical lines and two horizontal lines in the input grid.
    *   A vertical line is a column where most or all pixels have the same non-white color, potentially interrupted by other colors but maintaining a dominant color signature for the column.
    *   A horizontal line is a row where most or all pixels have the same non-white color, with similar potential interruptions.
    *   These lines span the full width or height of the grid, respectively.
    *   The colors of these lines vary between examples (yellow, blue, azure, magenta in train_1; green, azure, blue, red in train_2; green, yellow, red, azure in train_3).
3.  **Output Grid Structure:** The output grid is always a rectangular subgrid of the input grid.
4.  **Transformation:** The transformation appears to be an extraction or cropping operation. The boundaries of the extracted rectangle are defined by the positions of the four lines identified in the input.
5.  **Boundary Definition:**
    *   The column indices of the two vertical lines define the left and right boundaries of the output grid.
    *   The row indices of the two horizontal lines define the top and bottom boundaries of the output grid.
6.  **Extraction Logic:** The output grid consists of all pixels within the rectangle formed by these four lines, including the lines themselves. The range of rows extracted is from the minimum row index of the horizontal lines to the maximum row index (inclusive). Similarly, the range of columns extracted is from the minimum column index of the vertical lines to the maximum column index (inclusive).

## Facts


```yaml
elements:
  - object: grid
    description: A 2D array of pixels with values 0-9 representing colors.
  - object: line
    description: A contiguous set of pixels forming a straight line across the grid dimension (horizontal or vertical).
    properties:
      - orientation: vertical | horizontal
      - location: row_index (for horizontal) or column_index (for vertical)
      - color: The dominant non-white color of the line pixels.
      - role: Defines a boundary for extraction.
input_specifics:
  - property: contains_exactly_four_lines
    value: true
    details: Two lines are vertical, and two lines are horizontal.
  - property: line_characteristics
    details: Lines span the full dimension (height for vertical, width for horizontal) and have a dominant non-white color.
output_specifics:
  - property: is_subgrid_of_input
    value: true
  - property: boundaries_defined_by_input_lines
    value: true
transformation:
  - action: identify_lines
    details: Locate the row indices of the two horizontal lines (row1, row2) and the column indices of the two vertical lines (col1, col2) in the input grid.
  - action: determine_bounding_box
    details: Calculate the bounding box coordinates - top_row = min(row1, row2), bottom_row = max(row1, row2), left_col = min(col1, col2), right_col = max(col1, col2).
  - action: extract_subgrid
    details: Create the output grid by copying the pixels from the input grid within the determined bounding box, specifically from top_row to bottom_row (inclusive) and from left_col to right_col (inclusive).
```


## Natural Language Program

1.  **Identify Lines:** Scan the input grid to find the locations (indices) of the two distinct horizontal lines and the two distinct vertical lines. A line is characterized by a row or column that consists predominantly of a single non-white color and spans the grid's width or height, respectively.
2.  **Determine Boundaries:** Let the row indices of the horizontal lines be `r1` and `r2`, and the column indices of the vertical lines be `c1` and `c2`. Calculate the top boundary `top_row = min(r1, r2)`, the bottom boundary `bottom_row = max(r1, r2)`, the left boundary `left_col = min(c1, c2)`, and the right boundary `right_col = max(c1, c2)`.
3.  **Extract Subgrid:** Construct the output grid by selecting the portion of the input grid starting from `top_row` and ending at `bottom_row` (inclusive), and starting from `left_col` and ending at `right_col` (inclusive).
