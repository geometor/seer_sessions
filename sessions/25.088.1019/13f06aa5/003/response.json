{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies sparse 'special' pixels against a background, modifies grid boundaries based on the distance of these pixels to the boundaries, and adds connecting lines of pixels between the special pixel and the modified boundary.\n\nTransformation Steps:\n1.  **Initialization:** Create a copy of the input grid.\n2.  **Identify Background:** Find the most frequent color (background color).\n3.  **Identify Special Pixels:**\n    *   Find all non-background pixels.\n    *   Count occurrences of each non-background color.\n    *   Identify colors with the minimum count (\"special\" colors).\n    *   For each special color, find the representative location (top-most, then left-most pixel).\n4.  **Apply Transformation based on Count:**\n    *   **One Special Pixel (P, C):**\n        a. Find the furthest boundary (FB) from P (Tiebreak: T > B > L > R).\n        b. Modify FB with color C.\n        c. Add internal pixels of color C every two steps from P towards FB (excluding P and FB).\n    *   **Two Special Pixels (P1, C1; P2, C2):**\n        a. Calculate distances, furthest boundaries (FB1, FB2), max distances (MaxD1, MaxD2), and closest boundaries (CB1, CB2) for both P1 and P2 (Tiebreak: T > B > L > R).\n        b. **If MaxD1 > MaxD2:** P1 is primary (furthest), P2 is secondary (closest). Modify FB1 with C1, add internals from P1 towards FB1. Modify CB2 with C2, add internals from P2 towards CB2.\n        c. **If MaxD2 > MaxD1:** P2 is primary, P1 is secondary. Modify FB2 with C2, add internals from P2 towards FB2. Modify CB1 with C1, add internals from P1 towards CB1.\n        d. **If MaxD1 == MaxD2:** Both are secondary. Modify CB1 with C1, add internals from P1 towards CB1. Modify CB2 with C2, add internals from P2 towards CB2.\n        e. **Intersection Check:** If one modified boundary was horizontal (T/B) and the other vertical (L/R), set their intersection pixel to White (0).\n5.  **Return:** Return the modified grid.\n\"\"\"\n\n\ndef get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_special_pixels(grid, background_color):\n    \"\"\"\n    Finds the least frequent non-background color(s) and one representative location for each.\n    Returns a list of tuples: [(color, (row, col)), ...], sorted by color index.\n    \"\"\"\n    non_background_pixels = []\n    locations = {} # Store locations for each color: {color: [(r,c), ...]}\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                non_background_pixels.append(color)\n                if color not in locations:\n                    locations[color] = []\n                locations[color].append((r, c))\n\n    if not non_background_pixels:\n        return [] # No non-background pixels found\n\n    counts = Counter(non_background_pixels)\n    if not counts: # Handles case where grid might only have background\n         return []\n    min_count = min(counts.values())\n\n    special_pixels_info = []\n    # Ensure consistent order by sorting colors\n    sorted_colors = sorted(locations.keys())\n    for color in sorted_colors:\n        if counts[color] == min_count:\n            # Get the first location found (top-left most)\n            first_location = min(locations[color], key=lambda x: (x[0], x[1]))\n            special_pixels_info.append((color, first_location))\n\n    return special_pixels_info\n\ndef calculate_distances(point, height, width):\n    \"\"\"Calculates distances from a point (r, c) to the boundaries.\"\"\"\n    r, c = point\n    return {\n        'T': r,\n        'B': height - 1 - r,\n        'L': c,\n        'R': width - 1 - c\n    }\n\ndef get_furthest_boundary(distances):\n    \"\"\"\n    Finds the boundary type ('T', 'B', 'L', 'R') with the maximum distance.\n    Tie-breaking order: T > B > L > R.\n    \"\"\"\n    max_dist = -1\n    furthest = None\n    # Check in tie-breaking order\n    for boundary in ['T', 'B', 'L', 'R']:\n        # Use >= to ensure the first encountered max in tie-break order is kept\n        # No, use >. If T=5, B=5, we want T. If T=5, B=4, we want T.\n        # If T=4, B=5, we want B.\n        # The logic is: Check T. If B > T's dist, B becomes candidate. If B == T's dist, T remains.\n        if distances[boundary] > max_dist:\n            max_dist = distances[boundary]\n            furthest = boundary\n    # Example: T=5, B=5, L=3, R=2 -> max_dist=5, furthest=T\n    # Example: T=3, B=5, L=5, R=2 -> max_dist=5, furthest=B\n    # Example: T=3, B=4, L=5, R=5 -> max_dist=5, furthest=L\n    return furthest, max_dist\n\n\ndef get_closest_boundary(distances):\n    \"\"\"\n    Finds the boundary type ('T', 'B', 'L', 'R') with the minimum distance.\n    Tie-breaking order: T > B > L > R.\n    \"\"\"\n    min_dist = float('inf')\n    closest = None\n    # Find the minimum distance value\n    min_dist_val = min(distances.values())\n\n    # Find all boundaries matching the minimum distance\n    candidates = [b for b, d in distances.items() if d == min_dist_val]\n\n    # Apply tie-breaking order\n    if 'T' in candidates: return 'T', min_dist_val\n    if 'B' in candidates: return 'B', min_dist_val\n    if 'L' in candidates: return 'L', min_dist_val\n    if 'R' in candidates: return 'R', min_dist_val\n    return None, None # Should not happen if distances is valid\n\n\ndef modify_boundary(grid, boundary_type, color):\n    \"\"\"Modifies the specified boundary row or column with the given color.\"\"\"\n    height, width = grid.shape\n    if boundary_type == 'T':\n        grid[0, :] = color\n    elif boundary_type == 'B':\n        grid[height - 1, :] = color\n    elif boundary_type == 'L':\n        grid[:, 0] = color\n    elif boundary_type == 'R':\n        grid[:, width - 1] = color\n\ndef add_internal_pixels(grid, start_point, boundary_type, color):\n    \"\"\"Adds pixels every two steps towards the specified boundary, excluding start and end.\"\"\"\n    height, width = grid.shape\n    r, c = start_point\n\n    if boundary_type == 'T':\n        # Move up from r-2, r-4, ... stopping *before* row 0\n        for i in range(r - 2, 0, -2):\n             grid[i, c] = color\n    elif boundary_type == 'B':\n        # Move down from r+2, r+4, ... stopping *before* row H-1\n        for i in range(r + 2, height - 1, 2):\n             grid[i, c] = color\n    elif boundary_type == 'L':\n        # Move left from c-2, c-4, ... stopping *before* col 0\n        for j in range(c - 2, 0, -2):\n             grid[r, j] = color\n    elif boundary_type == 'R':\n        # Move right from c+2, c+4, ... stopping *before* col W-1\n        for j in range(c + 2, width - 1, 2):\n             grid[r, j] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # 1. Initialization\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # 2. Identify Background\n    background_color = get_background_color(output_grid)\n\n    # 3. Identify Special Pixels\n    special_pixels = find_special_pixels(output_grid, background_color)\n\n    # If no special pixels, return the copy\n    if not special_pixels:\n        return output_grid\n\n    # 4. Apply Transformation based on Count\n    modified_boundaries_info = {} # Store {boundary_type: color}\n\n    if len(special_pixels) == 1:\n        # Case: One special color\n        color, point = special_pixels[0]\n        distances = calculate_distances(point, height, width)\n        furthest_boundary, _ = get_furthest_boundary(distances)\n\n        # Modify the furthest boundary\n        modify_boundary(output_grid, furthest_boundary, color)\n        modified_boundaries_info[furthest_boundary] = color\n        # Add internal pixels towards the furthest boundary\n        add_internal_pixels(output_grid, point, furthest_boundary, color)\n\n    elif len(special_pixels) >= 2:\n        # Case: Two or more special colors (use the first two found based on color index)\n        c1, p1 = special_pixels[0]\n        c2, p2 = special_pixels[1]\n\n        # Calculate properties for P1\n        dist1 = calculate_distances(p1, height, width)\n        furthest1, max_dist1 = get_furthest_boundary(dist1)\n        closest1, _ = get_closest_boundary(dist1)\n\n        # Calculate properties for P2\n        dist2 = calculate_distances(p2, height, width)\n        furthest2, max_dist2 = get_furthest_boundary(dist2)\n        closest2, _ = get_closest_boundary(dist2)\n\n        # Determine actions based on max distances\n        if max_dist1 > max_dist2:\n            # P1=Primary (furthest), P2=Secondary (closest)\n            modify_boundary(output_grid, furthest1, c1)\n            add_internal_pixels(output_grid, p1, furthest1, c1)\n            modified_boundaries_info[furthest1] = c1\n\n            modify_boundary(output_grid, closest2, c2)\n            add_internal_pixels(output_grid, p2, closest2, c2) # ADDED THIS LINE\n            modified_boundaries_info[closest2] = c2\n\n        elif max_dist2 > max_dist1:\n            # P2=Primary (furthest), P1=Secondary (closest)\n            modify_boundary(output_grid, furthest2, c2)\n            add_internal_pixels(output_grid, p2, furthest2, c2)\n            modified_boundaries_info[furthest2] = c2\n\n            modify_boundary(output_grid, closest1, c1)\n            add_internal_pixels(output_grid, p1, closest1, c1) # ADDED THIS LINE\n            modified_boundaries_info[closest1] = c1\n\n        else: # max_dist1 == max_dist2\n            # Both are Secondary (closest)\n            modify_boundary(output_grid, closest1, c1)\n            add_internal_pixels(output_grid, p1, closest1, c1) # ADDED THIS LINE\n            modified_boundaries_info[closest1] = c1\n\n            modify_boundary(output_grid, closest2, c2)\n            add_internal_pixels(output_grid, p2, closest2, c2) # ADDED THIS LINE\n            modified_boundaries_info[closest2] = c2\n\n        # Intersection Handling\n        row_intersect = None\n        col_intersect = None\n\n        # Identify horizontal boundary (if any)\n        if 'T' in modified_boundaries_info: row_intersect = 0\n        elif 'B' in modified_boundaries_info: row_intersect = height - 1\n\n        # Identify vertical boundary (if any)\n        if 'L' in modified_boundaries_info: col_intersect = 0\n        elif 'R' in modified_boundaries_info: col_intersect = width - 1\n\n        # Check if exactly one horizontal and one vertical boundary were modified\n        if row_intersect is not None and col_intersect is not None:\n             # Ensure the boundary modification didn't overwrite the corner first\n             # (The modify_boundary calls happened first)\n             output_grid[row_intersect, col_intersect] = 0\n\n\n    # If more than 2 special pixels, the current logic only considers the first two.\n\n    # 5. Return\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11566,
    "candidates_token_count": 3169,
    "total_token_count": 14735,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.172719,
  "retries": null
}