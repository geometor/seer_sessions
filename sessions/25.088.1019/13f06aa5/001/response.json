{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies the background color (most frequent) and \"special\" pixels (least frequent non-background colors).\nBased on the number and location of special pixels, modifies the grid boundaries and potentially adds internal pixels.\n\nTransformation Steps:\n1. Copy the input grid to the output grid.\n2. Find the background color (most frequent).\n3. Find all non-background colors and their frequencies.\n4. Identify the color(s) with the minimum frequency (\"special colors\"). Record one location for each special color.\n5. **If one special color `C` at `P = (r, c)`:**\n   a. Calculate distances from `P` to boundaries (Top, Bottom, Left, Right).\n   b. Determine the furthest boundary from `P`.\n   c. Overwrite this furthest boundary line with color `C`.\n   d. Add pixels of color `C` every two steps from `P` towards the furthest boundary (not including `P` or the boundary itself).\n6. **If two special colors `C1` at `P1` and `C2` at `P2`:**\n   a. Calculate furthest boundary distances for both `P1` (MaxDist1) and `P2` (MaxDist2).\n   b. **If MaxDist1 > MaxDist2:**\n      i. `C1` is primary: Modify `P1`'s furthest boundary with `C1` and add internal pixels towards it.\n      ii. `C2` is secondary: Modify `P2`'s closest boundary (T > B > L > R tiebreak) with `C2`.\n   c. **If MaxDist2 > MaxDist1:**\n      i. `C2` is primary: Modify `P2`'s furthest boundary with `C2` and add internal pixels towards it.\n      ii. `C1` is secondary: Modify `P1`'s closest boundary (T > B > L > R tiebreak) with `C1`.\n   d. **If MaxDist1 == MaxDist2:**\n      i. Modify `P1`'s closest boundary (T > B > L > R tiebreak) with `C1`.\n      ii. Modify `P2`'s closest boundary (T > B > L > R tiebreak) with `C2`.\n   e. **Intersection Handling:** If the two modified boundaries intersect (one horizontal, one vertical), set the intersection pixel to White (0).\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_special_pixels(grid, background_color):\n    \"\"\"\n    Finds the least frequent non-background color(s) and one representative location for each.\n    Returns a list of tuples: [(color, (row, col)), ...].\n    \"\"\"\n    non_background_pixels = []\n    locations = {} # Store locations for each color: {color: [(r,c), ...]}\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                non_background_pixels.append(color)\n                if color not in locations:\n                    locations[color] = []\n                locations[color].append((r, c))\n\n    if not non_background_pixels:\n        return [] # No non-background pixels found\n\n    counts = Counter(non_background_pixels)\n    min_count = min(counts.values())\n\n    special_pixels_info = []\n    # Ensure consistent order by sorting colors\n    sorted_colors = sorted(locations.keys())\n    for color in sorted_colors:\n        if counts[color] == min_count:\n            # Get the first location found (top-left most)\n            first_location = min(locations[color], key=lambda x: (x[0], x[1]))\n            special_pixels_info.append((color, first_location))\n\n    return special_pixels_info\n\ndef calculate_distances(point, height, width):\n    \"\"\"Calculates distances from a point (r, c) to the boundaries.\"\"\"\n    r, c = point\n    return {\n        'T': r,\n        'B': height - 1 - r,\n        'L': c,\n        'R': width - 1 - c\n    }\n\ndef get_furthest_boundary(distances):\n    \"\"\"\n    Finds the boundary type ('T', 'B', 'L', 'R') with the maximum distance.\n    Tie-breaking order: T > B > L > R.\n    \"\"\"\n    max_dist = -1\n    furthest = None\n    # Check in tie-breaking order\n    for boundary in ['T', 'B', 'L', 'R']:\n        if distances[boundary] > max_dist:\n            max_dist = distances[boundary]\n            furthest = boundary\n    return furthest, max_dist\n\n\ndef get_closest_boundary(distances):\n    \"\"\"\n    Finds the boundary type ('T', 'B', 'L', 'R') with the minimum distance.\n    Tie-breaking order: T > B > L > R.\n    \"\"\"\n    min_dist = float('inf')\n    closest = None\n    # Check in tie-breaking order\n    for boundary in ['T', 'B', 'L', 'R']:\n        if distances[boundary] < min_dist:\n            min_dist = distances[boundary]\n            closest = boundary\n        # No need for explicit tie-breaking logic here because we check\n        # in the desired T > B > L > R order and only update if *strictly* less.\n        # The first minimum encountered in this order will be kept.\n    # Correction: need to handle the case where multiple boundaries have the same MINIMUM distance.\n    # Example: A point exactly in the center of a square grid. Closest is ambiguous.\n    # Re-implement with explicit tie-breaking check.\n    min_dist = min(distances.values())\n    candidates = [b for b, d in distances.items() if d == min_dist]\n\n    if 'T' in candidates: return 'T'\n    if 'B' in candidates: return 'B'\n    if 'L' in candidates: return 'L'\n    if 'R' in candidates: return 'R'\n    return None # Should not happen if distances is valid\n\n\ndef modify_boundary(grid, boundary_type, color):\n    \"\"\"Modifies the specified boundary row or column with the given color.\"\"\"\n    height, width = grid.shape\n    if boundary_type == 'T':\n        grid[0, :] = color\n    elif boundary_type == 'B':\n        grid[height - 1, :] = color\n    elif boundary_type == 'L':\n        grid[:, 0] = color\n    elif boundary_type == 'R':\n        grid[:, width - 1] = color\n\ndef add_internal_pixels(grid, start_point, boundary_type, color):\n    \"\"\"Adds pixels every two steps towards the specified boundary.\"\"\"\n    height, width = grid.shape\n    r, c = start_point\n\n    if boundary_type == 'T':\n        # Move up from r-2, r-4, ... until row 0 is reached or passed\n        for i in range(r - 2, -1, -2):\n             if i >= 0: # check boundary explicitely\n                 grid[i, c] = color\n    elif boundary_type == 'B':\n        # Move down from r+2, r+4, ... until row H-1 is reached or passed\n        for i in range(r + 2, height, 2):\n             if i < height: # check boundary explicitely\n                grid[i, c] = color\n    elif boundary_type == 'L':\n        # Move left from c-2, c-4, ... until col 0 is reached or passed\n        for j in range(c - 2, -1, -2):\n            if j >= 0: # check boundary explicitely\n                grid[r, j] = color\n    elif boundary_type == 'R':\n        # Move right from c+2, c+4, ... until col W-1 is reached or passed\n        for j in range(c + 2, width, 2):\n            if j < width: # check boundary explicitely\n                grid[r, j] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # 1. Find background color\n    background_color = get_background_color(output_grid)\n\n    # 2. Find special pixels (least frequent non-background)\n    special_pixels = find_special_pixels(output_grid, background_color)\n\n    # If no special pixels, return the copy\n    if not special_pixels:\n        return output_grid\n\n    # 3. Apply rules based on the number of special pixels\n    modified_boundaries = [] # Keep track of modified boundaries for intersection check\n\n    if len(special_pixels) == 1:\n        # Case 1: One special color\n        color, point = special_pixels[0]\n        distances = calculate_distances(point, height, width)\n        furthest_boundary, _ = get_furthest_boundary(distances)\n\n        # Modify the furthest boundary\n        modify_boundary(output_grid, furthest_boundary, color)\n        # Add internal pixels towards the furthest boundary\n        add_internal_pixels(output_grid, point, furthest_boundary, color)\n\n    elif len(special_pixels) >= 2:\n        # Case 2: Two or more special colors (use the first two found)\n        # Note: Examples only show 1 or 2 special colors. Assuming we only act on the first two if more exist.\n        c1, p1 = special_pixels[0]\n        c2, p2 = special_pixels[1]\n\n        dist1 = calculate_distances(p1, height, width)\n        dist2 = calculate_distances(p2, height, width)\n\n        furthest1, max_dist1 = get_furthest_boundary(dist1)\n        furthest2, max_dist2 = get_furthest_boundary(dist2)\n\n        closest1 = get_closest_boundary(dist1)\n        closest2 = get_closest_boundary(dist2)\n\n        boundary1_type = None\n        boundary2_type = None\n\n        if max_dist1 > max_dist2:\n            # C1 is primary (furthest), C2 is secondary (closest)\n            modify_boundary(output_grid, furthest1, c1)\n            add_internal_pixels(output_grid, p1, furthest1, c1)\n            boundary1_type = furthest1\n\n            modify_boundary(output_grid, closest2, c2)\n            boundary2_type = closest2\n\n        elif max_dist2 > max_dist1:\n            # C2 is primary (furthest), C1 is secondary (closest)\n            modify_boundary(output_grid, furthest2, c2)\n            add_internal_pixels(output_grid, p2, furthest2, c2)\n            boundary2_type = furthest2\n\n            modify_boundary(output_grid, closest1, c1)\n            boundary1_type = closest1\n\n        else: # max_dist1 == max_dist2\n            # Both are secondary (closest)\n            modify_boundary(output_grid, closest1, c1)\n            boundary1_type = closest1\n\n            modify_boundary(output_grid, closest2, c2)\n            boundary2_type = closest2\n\n        modified_boundaries = [boundary1_type, boundary2_type]\n\n        # Handle intersection\n        horizontal = None\n        vertical = None\n        if boundary1_type in ['T', 'B']: horizontal = boundary1_type\n        elif boundary1_type in ['L', 'R']: vertical = boundary1_type\n\n        if boundary2_type in ['T', 'B']: horizontal = boundary2_type\n        elif boundary2_type in ['L', 'R']: vertical = boundary2_type\n\n        # Check if we have one of each type *and* they are from different modifications\n        # (Avoids setting corner to 0 if only one boundary modified, although logic above prevents this scenario)\n        # Also ensure both boundary types are not None\n        if boundary1_type and boundary2_type and \\\n           ((boundary1_type in ['T', 'B'] and boundary2_type in ['L', 'R']) or \\\n            (boundary1_type in ['L', 'R'] and boundary2_type in ['T', 'B'])):\n\n            row_intersect = 0 if 'T' in modified_boundaries else height - 1 if 'B' in modified_boundaries else -1 # Should get assigned if intersection exists\n            col_intersect = 0 if 'L' in modified_boundaries else width - 1 if 'R' in modified_boundaries else -1 # Should get assigned if intersection exists\n\n            # Determine row index based on horizontal boundary\n            if 'T' in modified_boundaries: row_intersect = 0\n            elif 'B' in modified_boundaries: row_intersect = height - 1\n\n             # Determine col index based on vertical boundary\n            if 'L' in modified_boundaries: col_intersect = 0\n            elif 'R' in modified_boundaries: col_intersect = width - 1\n\n            # Only set to 0 if both indices were validly determined\n            if row_intersect != -1 and col_intersect != -1:\n                 output_grid[row_intersect, col_intersect] = 0\n\n    # If more than 2 special pixels, the current logic only considers the first two.\n    # The problem description and examples don't cover this, so this is an assumption.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4726,
    "candidates_token_count": 3250,
    "total_token_count": 7976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.867954,
  "retries": null
}