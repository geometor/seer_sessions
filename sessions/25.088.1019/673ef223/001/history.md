
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 8 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 8 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 4 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 4 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 8 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 8 8 8 4 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 8 0 0 2
0 0 8 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 8 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 4 8 8 2
0 0 4 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 4 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 8 8 8
2 8 8 8 8 8 8 8 8 8
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 8 8 8
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

**Perception of Elements:**

1.  **Grid Structure:** The input and output grids have the same dimensions.
2.  **Background:** The background is predominantly white (0).
3.  **Key Colors:**
    *   Red (2): Appears as vertical lines, always located at the very left (column 0) or very right (last column) edge of the grid. These red lines persist in the output.
    *   Azure (8): Appears as scattered single pixels in the input. In the output, azure pixels form horizontal lines, and sometimes replace the original azure input pixels.
    *   Yellow (4): Appears only in the output, replacing the original position of some azure (8) input pixels.
    *   White (0): The background color, largely unchanged except where azure lines are drawn.
4.  **Transformation Pattern:** The core transformation involves drawing horizontal azure (8) lines in specific rows. The presence and location of red (2) and azure (8) pixels in the input determine where these lines are drawn and where they stop.
5.  **Line Generation:**
    *   Lines are generated only in rows containing a red (2) pixel.
    *   The line originates from the side with the red pixel and extends horizontally towards the opposite side.
    *   The line color is azure (8).
    *   If the line encounters an azure (8) pixel from the input *within the same row*, the line stops just before that pixel, and the encountered azure pixel is replaced with yellow (4).
    *   If no azure (8) pixel is encountered in the row (between the starting red pixel and the opposite edge), the azure line extends all the way across the row, stopping just before the opposite edge.

**YAML Facts:**


```yaml
Grid:
  Properties:
    - Size: Consistent between input and output.
    - BackgroundColor: White (0).
Objects:
  - Type: VerticalLine
    Color: Red (2)
    Location: Always at column 0 or the last column.
    Persistence: Retained in the output.
    Role: Defines rows where horizontal lines are generated ('active rows').
  - Type: Point
    Color: Azure (8)
    Location: Scattered in the input grid.
    Role: Acts as a 'stopper' or 'terminator' for the horizontal lines drawn in its row. Replaced by Yellow (4) in the output if it stops a line.
  - Type: HorizontalLine (Generated)
    Color: Azure (8)
    Location: Generated in 'active rows' in the output grid.
    Origin: Adjacent to the Red (2) pixel in the row.
    Termination:
      - Stops one cell before an input Azure (8) pixel in the same row.
      - Stops one cell before the opposite grid edge if no input Azure (8) pixel is encountered in the row.
  - Type: Point (Generated)
    Color: Yellow (4)
    Location: Appears in the output grid at the position of an input Azure (8) pixel that acted as a stopper.
Relationships:
  - A Red (2) pixel in a row triggers the potential generation of a HorizontalLine (Azure, 8) in that row.
  - An input Azure (8) pixel in an active row determines the endpoint of the generated HorizontalLine and is replaced by Yellow (4).
  - The direction of the HorizontalLine generation depends on whether the Red (2) pixel is on the left or right edge.
```


**Natural Language Program:**

1.  Create the output grid as a copy of the input grid.
2.  Iterate through each row of the grid, from top to bottom.
3.  For the current row, check if it contains a red (2) pixel.
4.  If a red (2) pixel exists at the start of the row (column 0):
    a.  Initialize a variable `stopper_column` to -1.
    b.  Scan the row from column 1 to the end (exclusive). If an azure (8) pixel is found, record its column index in `stopper_column` and stop scanning this row.
    c.  If `stopper_column` is not -1 (an azure stopper was found):
        i.  Fill the cells in the current row of the output grid from column 1 up to (but not including) `stopper_column` with azure (8).
        ii. Set the cell at `stopper_column` in the current row of the output grid to yellow (4).
    d.  If `stopper_column` is -1 (no azure stopper was found):
        i.  Fill the cells in the current row of the output grid from column 1 up to (but not including) the last column with azure (8).
5.  If a red (2) pixel exists at the end of the row (last column):
    a.  Initialize a variable `stopper_column` to -1.
    b.  Scan the row backwards, from the second-to-last column down to column 0 (inclusive). If an azure (8) pixel is found, record its column index in `stopper_column` and stop scanning this row.
    c.  If `stopper_column` is not -1 (an azure stopper was found):
        i.  Fill the cells in the current row of the output grid from the second-to-last column down to (but not including) `stopper_column` with azure (8).
        ii. Set the cell at `stopper_column` in the current row of the output grid to yellow (4).
    d.  If `stopper_column` is -1 (no azure stopper was found):
        i.  Fill the cells in the current row of the output grid from the second-to-last column down to column 0 (inclusive) with azure (8).
6.  After iterating through all rows, return the modified output grid.
