{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n# --- Constants ---\nBACKGROUND_COLOR = 0\n\n# --- Helper Functions: Object Finding ---\n\ndef find_objects(grid, colors=None, connectivity=1):\n    \"\"\"\n    Finds contiguous objects of specified colors in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors (set, optional): Set of colors to look for. If None, finds all non-background objects. Defaults to None.\n        connectivity (int): 1 for 4-way (adjacent), 2 for 8-way (adjacent + diagonal). Defaults to 1.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with:\n              'color': The color of the object.\n              'pixels': Set of (row, col) tuples belonging to the object.\n              'bbox': Tuple (min_row, min_col, max_row, max_col).\n              'shape': Frozenset of relative pixel coordinates (dr, dc) from bbox top-left.\n              'size': Number of pixels in the object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if colors is None:\n        # Find all non-background colors present in the grid\n        unique_colors = set(np.unique(grid)) - {BACKGROUND_COLOR}\n        if not unique_colors: # Handle case of empty or all-background grid\n            return []\n        colors_to_find = unique_colors\n    else:\n        colors_to_find = set(colors)\n\n    # Prioritize objects based on position (top-left) for tie-breaking in size\n    sorted_coords = sorted([(r, c) for r in range(rows) for c in range(cols) if grid[r,c] in colors_to_find])\n\n    for r, c in sorted_coords:\n        if not visited[r, c] and grid[r, c] in colors_to_find:\n            color = grid[r, c]\n            obj_pixels = set()\n            q = [(r, c)]\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            processed_in_this_object = set([(r,c)]) # Track pixels added to queue for this object\n\n            while q:\n                row, col = q.pop(0)\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Define neighbors based on connectivity\n                if connectivity == 1:\n                    neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                else: # connectivity == 2 (or default)\n                     neighbors = [(dr, dc) for dr in range(row-1, row+2) for dc in range(col-1, col+2) if not (dr==row and dc==col)]\n\n                for nr, nc in neighbors:\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       not visited[nr, nc] and grid[nr, nc] == color and \\\n                       (nr, nc) not in processed_in_this_object: # Check if already queued/visited for this object\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n                        processed_in_this_object.add((nr,nc))\n                \n            if obj_pixels:\n                # Ensure consistent sorting for shape signature\n                sorted_pixels = sorted(list(obj_pixels))\n                rel_pixels = frozenset((pr - min_r, pc - min_c) for pr, pc in sorted_pixels)\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'shape': rel_pixels, # Shape relative to bbox top-left\n                    'size': len(obj_pixels)\n                })\n    return objects\n\n# --- Helper Functions: Drawing ---\n\ndef draw_shape(grid, shape_sig, color, top_left_pos):\n    \"\"\"\n    Draws a shape defined by its relative pixel signature onto the grid.\n\n    Args:\n        grid (np.array): The target grid to draw on.\n        shape_sig (frozenset): Set of (dr, dc) relative coordinates defining the shape.\n        color (int): The color to draw with.\n        top_left_pos (tuple): The (row, col) of the top-left corner where the shape starts.\n    \"\"\"\n    start_r, start_c = top_left_pos\n    rows, cols = grid.shape\n    for dr, dc in shape_sig:\n        r, c = start_r + dr, start_c + dc\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n        # else: print(f\"Warning: Pixel ({r},{c}) out of bounds for grid {grid.shape}\") # Optional: for debugging bounds issues\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify all distinct contiguous objects (non-background color).\n    2. Select the object with the largest area (pixel count) as the 'template'. If there's a tie in size, the one whose bounding box starts further up (minimum row) and then further left (minimum column) is chosen.\n    3. Identify all non-background pixels that *do not* belong to the template object. These are the 'palette' pixels.\n    4. Determine the color sequence from the palette pixels by reading them primarily from top to bottom, and secondarily from left to right. Extract the unique colors in this order.\n    5. Determine the starting position for stacking:\n        - The starting column is the leftmost column of the template object's bounding box.\n        - The starting row is the topmost row containing any palette pixel.\n    6. Calculate the vertical offset for stacking: This is the height of the template object's bounding box.\n    7. Calculate the required output grid dimensions:\n        - Width is the same as the input grid width.\n        - Height is determined by the starting row, the number of shapes to stack (length of the palette color sequence), and the vertical offset. It must be at least as tall as the input grid.\n    8. Create the output grid initialized with the background color.\n    9. Draw copies of the template shape vertically onto the output grid:\n        - Start at the calculated starting position (row, col).\n        - Use the colors from the determined palette sequence, in order.\n        - Stack subsequent shapes directly below the previous one, using the calculated vertical offset.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    input_rows, input_cols = input_grid_np.shape\n\n    # 1. & 2. Identify all objects and select the template\n    input_objects = find_objects(input_grid_np)\n\n    if not input_objects:\n        # Handle empty input or input with only background\n        return input_grid # Return input as is\n\n    # Sort objects: Primarily by size (desc), secondarily by min_row (asc), thirdly by min_col (asc)\n    input_objects.sort(key=lambda o: (-o['size'], o['bbox'][0], o['bbox'][1]))\n    template_object = input_objects[0]\n    template_shape = template_object['shape']\n    template_bbox = template_object['bbox']\n    template_pixels = template_object['pixels']\n    template_min_r, template_min_c, template_max_r, template_max_c = template_bbox\n    template_height = template_max_r - template_min_r + 1\n\n    # 3. Identify palette pixels\n    all_colored_pixels = set(zip(*np.where(input_grid_np != BACKGROUND_COLOR)))\n    palette_pixels_set = all_colored_pixels - template_pixels\n\n    if not palette_pixels_set:\n         # If no palette pixels, maybe just draw the template in its original color and position?\n         # Or follow the logic assuming an empty sequence (draw nothing new)?\n         # Let's assume the task implies a palette always exists if transformation occurs.\n         # If not, maybe return the input? For now, proceed, resulting sequence will be empty.\n         # Revisit: The examples imply a palette. Let's try returning input if no palette.\n         return input_grid # No palette found, transformation rule might not apply.\n\n\n    # 4. Determine palette sequence\n    # Sort palette pixels: top-to-bottom, then left-to-right\n    sorted_palette_pixels = sorted(list(palette_pixels_set), key=lambda p: (p[0], p[1]))\n    \n    palette_color_sequence = []\n    seen_colors = set()\n    palette_min_row = input_rows # Initialize high to find minimum\n\n    for r, c in sorted_palette_pixels:\n        color = input_grid_np[r, c]\n        palette_min_row = min(palette_min_row, r) # Update the minimum row found for palette pixels\n        if color not in seen_colors:\n            palette_color_sequence.append(color)\n            seen_colors.add(color)\n            \n    # Handle case where palette_min_row wasn't updated (no palette pixels found - redundant check)\n    if not palette_color_sequence:\n        return input_grid # Should have been caught earlier, but safe check\n\n    # 5. Determine stacking start position\n    start_col = template_min_c\n    start_row = palette_min_row # Use the topmost row of any palette pixel\n\n    # 6. Vertical offset is template height (already calculated)\n    vertical_offset = template_height\n\n    # 7. Calculate output grid dimensions\n    num_shapes = len(palette_color_sequence)\n    output_cols = input_cols\n\n    # Calculate the maximum row index needed for the last shape\n    if num_shapes == 0:\n         # This case should ideally not be reached if we return input grid when no palette\n         max_r_occupied = template_max_r # Or maybe 0? Depends on desired output for edge case.\n    elif num_shapes == 1:\n         max_r_occupied = start_row + (template_max_r - template_min_r) # Bottom edge of the single shape\n    else:\n         last_shape_start_r = start_row + (num_shapes - 1) * vertical_offset\n         max_r_occupied = last_shape_start_r + (template_max_r - template_min_r) # Bottom edge of the last shape\n\n    output_rows = max(input_rows, max_r_occupied + 1)\n\n    # 8. Create output grid\n    output_grid = np.full((output_rows, output_cols), BACKGROUND_COLOR, dtype=int)\n\n    # 9. Draw the shapes\n    for i, color in enumerate(palette_color_sequence):\n        # Calculate top-left position for this instance\n        current_start_r = start_row + i * vertical_offset\n        current_start_c = start_col\n        \n        # Draw the shape\n        draw_shape(output_grid, template_shape, color, (current_start_r, current_start_c))\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7076,
    "candidates_token_count": 2739,
    "total_token_count": 9815,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 197.6666,
  "retries": null
}