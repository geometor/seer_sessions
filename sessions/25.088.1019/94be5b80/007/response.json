{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n# --- Constants ---\nBACKGROUND_COLOR = 0\n\n# --- Helper Functions: Object Finding ---\n\ndef find_objects(grid, colors=None, connectivity=1):\n    \"\"\"\n    Finds contiguous objects of specified colors in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors (set, optional): Set of colors to look for. If None, finds all non-background objects. Defaults to None.\n        connectivity (int): 1 for 4-way (adjacent), 2 for 8-way (adjacent + diagonal). Defaults to 1.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with:\n              'color': The color of the object.\n              'pixels': Set of (row, col) tuples belonging to the object.\n              'bbox': Tuple (min_row, min_col, max_row, max_col).\n              'shape': Frozenset of relative pixel coordinates (dr, dc) from bbox top-left.\n              'size': Number of pixels in the object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if colors is None:\n        unique_colors = set(np.unique(grid)) - {BACKGROUND_COLOR}\n        if not unique_colors: return []\n        colors_to_find = unique_colors\n    else:\n        colors_to_find = set(colors)\n\n    sorted_coords = sorted([(r, c) for r in range(rows) for c in range(cols) if grid[r,c] in colors_to_find])\n\n    for r, c in sorted_coords:\n        if not visited[r, c] and grid[r, c] in colors_to_find:\n            color = grid[r, c]\n            obj_pixels = set()\n            q = [(r, c)]\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n            processed_in_this_object = set([(r,c)]) \n\n            while q:\n                row, col = q.pop(0)\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                if connectivity == 1:\n                    neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                else: \n                     neighbors = [(dr, dc) for dr in range(row-1, row+2) for dc in range(col-1, col+2) if not (dr==row and dc==col)]\n\n                for nr, nc in neighbors:\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       not visited[nr, nc] and grid[nr, nc] == color and \\\n                       (nr, nc) not in processed_in_this_object: \n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n                        processed_in_this_object.add((nr,nc))\n                \n            if obj_pixels:\n                sorted_pixels = sorted(list(obj_pixels))\n                rel_pixels = frozenset((pr - min_r, pc - min_c) for pr, pc in sorted_pixels)\n                objects.append({\n                    'color': color, 'pixels': obj_pixels, 'bbox': (min_r, min_c, max_r, max_c),\n                    'shape': rel_pixels, 'size': len(obj_pixels)\n                })\n    return objects\n\n# --- Helper Functions: Drawing ---\n\ndef draw_shape(grid, shape_sig, color, top_left_pos):\n    \"\"\"\n    Draws a shape defined by its relative pixel signature onto the grid.\n\n    Args:\n        grid (np.array): The target grid to draw on.\n        shape_sig (frozenset): Set of (dr, dc) relative coordinates defining the shape.\n        color (int): The color to draw with.\n        top_left_pos (tuple): The (row, col) of the top-left corner where the shape starts.\n    \"\"\"\n    start_r, start_c = top_left_pos\n    rows, cols = grid.shape\n    for dr, dc in shape_sig:\n        r, c = start_r + dr, start_c + dc\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n        # else: print(f\"Warning: Pixel ({r},{c}) out of bounds for grid {grid.shape}\") # Optional debugging\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify all distinct contiguous objects (non-background color).\n    2. Select the object with the largest area (pixel count) as the 'template'. Ties are broken by highest (min row) then leftmost (min col) bounding box.\n    3. Identify all non-background pixels that *do not* belong to the template object ('palette' pixels).\n    4. Determine the color sequence from the palette pixels by reading them top-to-bottom, then left-to-right, taking unique colors in order of appearance.\n    5. Determine the starting position for stacking:\n        - Column: Leftmost column of the template's bounding box.\n        - Row: Topmost row of the template's bounding box MINUS the template's height.\n    6. Determine the vertical offset for stacking: Height of the template's bounding box.\n    7. Calculate output grid dimensions to accommodate the stacked shapes, ensuring it's at least as large as the input.\n    8. Create the output grid initialized with the background color.\n    9. Draw copies of the template shape vertically onto the output grid, starting at the calculated position, using colors from the palette sequence, and stacking with the calculated vertical offset.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    input_rows, input_cols = input_grid_np.shape\n\n    # 1. Identify Objects\n    input_objects = find_objects(input_grid_np)\n\n    # Handle empty input or input with only background\n    if not input_objects:\n        return input_grid \n\n    # 2. Select Template Object\n    # Sort: Primarily by size (desc), secondarily by min_row (asc), thirdly by min_col (asc)\n    input_objects.sort(key=lambda o: (-o['size'], o['bbox'][0], o['bbox'][1]))\n    template_object = input_objects[0]\n    template_shape = template_object['shape']\n    template_bbox = template_object['bbox']\n    template_pixels = template_object['pixels']\n    template_min_r, template_min_c, template_max_r, template_max_c = template_bbox\n    template_height = template_max_r - template_min_r + 1 # Bbox height\n\n    # 3. Identify Palette Pixels\n    all_colored_pixels = set(zip(*np.where(input_grid_np != BACKGROUND_COLOR)))\n    palette_pixels_set = all_colored_pixels - template_pixels\n\n    # Handle case where no palette pixels are found (transformation might not apply)\n    if not palette_pixels_set:\n         return input_grid \n\n    # 4. Determine Palette Color Sequence\n    # Sort palette pixels: top-to-bottom, then left-to-right\n    sorted_palette_pixels = sorted(list(palette_pixels_set), key=lambda p: (p[0], p[1]))\n    \n    palette_color_sequence = []\n    seen_colors = set()\n    for r, c in sorted_palette_pixels:\n        color = input_grid_np[r, c]\n        if color not in seen_colors:\n            palette_color_sequence.append(color)\n            seen_colors.add(color)\n            \n    # Double-check if sequence ended up empty (should have been caught by empty set check)\n    if not palette_color_sequence:\n        return input_grid \n\n    # 5. Determine Stacking Start Position (Corrected Rule)\n    start_col = template_min_c\n    start_row = template_min_r - template_height # Key change based on analysis\n\n    # 6. Determine Vertical Offset\n    vertical_offset = template_height\n\n    # 7. Calculate Output Grid Dimensions\n    num_shapes = len(palette_color_sequence)\n    output_cols = input_cols\n\n    # Calculate the maximum row index needed for the bottom-most pixel of the last shape\n    # Bottom row relative to start_row is (template_height - 1)\n    last_shape_start_r = start_row + (num_shapes - 1) * vertical_offset\n    max_r_occupied = last_shape_start_r + (template_height - 1) \n\n    # Ensure output grid is large enough vertically, and at least as tall as input\n    output_rows = max(input_rows, max_r_occupied + 1)\n    # Also ensure output rows is at least 1 (edge case for very small grids/shapes)\n    output_rows = max(1, output_rows) \n\n    # 8. Create Output Grid\n    output_grid = np.full((output_rows, output_cols), BACKGROUND_COLOR, dtype=int)\n\n    # 9. Draw Stacked Shapes\n    for i, color in enumerate(palette_color_sequence):\n        # Calculate top-left position for this instance\n        current_start_r = start_row + i * vertical_offset\n        current_start_c = start_col\n        \n        # Draw the shape\n        draw_shape(output_grid, template_shape, color, (current_start_r, current_start_c))\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12764,
    "candidates_token_count": 2374,
    "total_token_count": 15138,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.049355,
  "retries": null
}