{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n# --- Constants ---\nBACKGROUND_COLOR = 0\n\n# --- Helper Functions: Object Finding ---\n\ndef find_objects(grid, colors=None, connectivity=1):\n    \"\"\"\n    Finds contiguous objects of specified colors in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors (set, optional): Set of colors to look for. If None, finds all non-background objects. Defaults to None.\n        connectivity (int): 1 for 4-way (adjacent), 2 for 8-way (adjacent + diagonal). Defaults to 1.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with:\n              'color': The color of the object.\n              'pixels': Set of (row, col) tuples belonging to the object.\n              'bbox': Tuple (min_row, min_col, max_row, max_col).\n              'shape': Frozenset of relative pixel coordinates (dr, dc) from bbox top-left.\n              'size': Number of pixels in the object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if colors is None:\n        colors_to_find = set(np.unique(grid)) - {BACKGROUND_COLOR}\n    else:\n        colors_to_find = set(colors)\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] in colors_to_find:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Define neighbors based on connectivity\n                    if connectivity == 1:\n                        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                    else: # connectivity == 2 (or default)\n                         neighbors = [(dr, dc) for dr in range(row-1, row+2) for dc in range(col-1, col+2) if not (dr==row and dc==col)]\n\n                    for nr, nc in neighbors:\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    # Ensure consistent sorting for shape signature\n                    sorted_pixels = sorted(list(obj_pixels))\n                    rel_pixels = frozenset((pr - min_r, pc - min_c) for pr, pc in sorted_pixels)\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'shape': rel_pixels, # Shape relative to bbox top-left\n                        'size': len(obj_pixels)\n                    })\n    return objects\n\n# --- Helper Functions: Drawing ---\n\ndef draw_shape(grid, shape_sig, color, top_left_pos):\n    \"\"\"\n    Draws a shape defined by its relative pixel signature onto the grid.\n\n    Args:\n        grid (np.array): The target grid to draw on.\n        shape_sig (frozenset): Set of (dr, dc) relative coordinates defining the shape.\n        color (int): The color to draw with.\n        top_left_pos (tuple): The (row, col) of the top-left corner where the shape starts.\n    \"\"\"\n    min_r, min_c = top_left_pos\n    rows, cols = grid.shape\n    for dr, dc in shape_sig:\n        r, c = min_r + dr, min_c + dc\n        if 0 <= r < rows and 0 <= c < cols:\n            grid[r, c] = color\n        # else: print(f\"Warning: Pixel ({r},{c}) out of bounds for grid {grid.shape}\") # Optional: for debugging bounds issues\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by:\n    1. Identifying the largest monochromatic object as the 'template'.\n    2. Identifying remaining non-background pixels as the 'palette'.\n    3. Determining the vertical sequence of colors in the palette.\n    4. Creating an output color sequence: [template color] + [palette sequence].\n    5. Stacking copies of the template shape vertically in a new grid, colored according\n       to the output color sequence. The vertical offset between shapes equals the\n       template's height. The output grid size is adjusted as needed.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    input_rows, input_cols = input_grid_np.shape\n\n    # 1. Identify all distinct objects\n    input_objects = find_objects(input_grid_np)\n\n    if not input_objects:\n        # No objects found, return empty grid of same size? Or input?\n        # Return input seems safer if the premise of template+palette fails.\n        return input_grid\n\n    # 2. Identify the template object (largest by pixel count)\n    input_objects.sort(key=lambda o: o['size'], reverse=True)\n    template_object = input_objects[0]\n    template_color = template_object['color']\n    template_shape = template_object['shape']\n    template_bbox = template_object['bbox']\n    template_pixels = template_object['pixels']\n    template_min_r, template_min_c, template_max_r, template_max_c = template_bbox\n    template_height = template_max_r - template_min_r + 1\n    # template_width = template_max_c - template_min_c + 1 # Not needed for offset calc here\n\n    # 3. Identify palette pixels and their colors/positions\n    all_input_pixels = set(zip(*np.where(input_grid_np != BACKGROUND_COLOR)))\n    palette_pixels_set = all_input_pixels - template_pixels\n    \n    palette_colors_positions = {} # color -> (r, c) - assuming single pixel per color\n    for r, c in palette_pixels_set:\n        color = input_grid_np[r, c]\n        # Store the first encountered position for each color (or topmost)\n        if color not in palette_colors_positions or r < palette_colors_positions[color][0]:\n             palette_colors_positions[color] = (r, c)\n\n    # 4. Determine palette sequence (vertical, top to bottom)\n    palette_sequence = sorted(palette_colors_positions.keys(), key=lambda c: palette_colors_positions[c][0])\n\n    # 5. Construct the output color sequence\n    output_color_sequence = [template_color] + palette_sequence\n    num_shapes = len(output_color_sequence)\n\n    # 6. Calculate the vertical offset for stacking\n    # Offset is the height of the template bounding box.\n    vertical_offset = template_height\n\n    # 7. Calculate required output grid dimensions\n    output_cols = input_cols # Width remains the same\n    # Calculate the maximum row index needed\n    if num_shapes == 0: # Should not happen if template exists, but safeguard\n        max_r_occupied = template_max_r\n    elif num_shapes == 1:\n        max_r_occupied = template_max_r\n    else:\n        # Row where the last shape *starts* drawing\n        last_shape_start_r = template_min_r + (num_shapes - 1) * vertical_offset\n        # Max row occupied by the last shape (its bottom edge)\n        max_r_occupied = last_shape_start_r + (template_max_r - template_min_r)\n\n    output_rows = max(input_rows, max_r_occupied + 1)\n\n    # 8. Create the output grid\n    output_grid = np.full((output_rows, output_cols), BACKGROUND_COLOR, dtype=int)\n\n    # 9. Draw the shapes onto the output grid\n    for i, color in enumerate(output_color_sequence):\n        # Calculate the top-left position for this shape instance\n        # Row = template's original top row + index * offset\n        # Col = template's original left col\n        pos_r = template_min_r + i * vertical_offset\n        pos_c = template_min_c\n        \n        # Draw the shape\n        draw_shape(output_grid, template_shape, color, (pos_r, pos_c))\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17909,
    "candidates_token_count": 2172,
    "total_token_count": 20081,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.499232,
  "retries": null
}