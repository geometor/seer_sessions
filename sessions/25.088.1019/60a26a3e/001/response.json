{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies contiguous red (2) shapes in the input grid. Calculates the center and bounding box for each shape. \nFinds pairs of shapes whose centers are aligned either horizontally (same row) or vertically (same column).\nFor each aligned pair, draws a blue (1) line segment in the white (0) space between their bounding boxes along the line connecting their centers.\nHorizontal lines are drawn along the shared center row, and vertical lines are drawn along the shared center column.\nThe final output is the input grid with these blue lines added.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a dictionary containing:\n              'pixels': A set of (row, col) tuples for the object's pixels.\n              'center': A tuple (center_row, center_col) rounded to nearest int.\n              'bbox': A tuple (min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                sum_r, sum_c = 0, 0\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    sum_r += row\n                    sum_c += col\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    num_pixels = len(obj_pixels)\n                    center_r = round(sum_r / num_pixels)\n                    center_c = round(sum_c / num_pixels)\n                    objects.append({\n                        'pixels': obj_pixels,\n                        'center': (int(center_r), int(center_c)),\n                        'bbox': (min_r, max_r, min_c, max_c)\n                    })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Connects aligned red shapes with blue lines.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid with blue lines added.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    red_color = 2\n    blue_color = 1\n    background_color = 0\n\n    # 1. Identify all red shapes, their centers, and bounding boxes\n    red_objects = find_objects(grid, red_color)\n\n    # 2. Iterate through all pairs of shapes to find alignments\n    num_objects = len(red_objects)\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            obj1 = red_objects[i]\n            obj2 = red_objects[j]\n\n            center1_r, center1_c = obj1['center']\n            center2_r, center2_c = obj2['center']\n            bbox1 = obj1['bbox'] # min_r, max_r, min_c, max_c\n            bbox2 = obj2['bbox'] # min_r, max_r, min_c, max_c\n\n            # 3. Check for horizontal alignment (same center row)\n            if center1_r == center2_r:\n                draw_row = center1_r\n                # Determine which object is left and which is right\n                if center1_c < center2_c:\n                    left_obj_bbox = bbox1\n                    right_obj_bbox = bbox2\n                else:\n                    left_obj_bbox = bbox2\n                    right_obj_bbox = bbox1\n                \n                # Define the column range for the line\n                start_col = left_obj_bbox[3] + 1 # max_col of left object + 1\n                end_col = right_obj_bbox[2]     # min_col of right object (exclusive)\n\n                # Check if the path is clear (all background) and draw the line\n                is_clear = True\n                if start_col < end_col: # Ensure there's a gap\n                    for c in range(start_col, end_col):\n                         # Check bounds just in case center is outside grid somehow (shouldn't happen with rounding)\n                        if not (0 <= draw_row < output_grid.shape[0] and 0 <= c < output_grid.shape[1]):\n                            is_clear = False\n                            break\n                        if output_grid[draw_row, c] != background_color:\n                            is_clear = False\n                            break\n                    if is_clear:\n                        output_grid[draw_row, start_col:end_col] = blue_color\n\n            # 4. Check for vertical alignment (same center column)\n            elif center1_c == center2_c:\n                draw_col = center1_c\n                # Determine which object is top and which is bottom\n                if center1_r < center2_r:\n                    top_obj_bbox = bbox1\n                    bottom_obj_bbox = bbox2\n                else:\n                    top_obj_bbox = bbox2\n                    bottom_obj_bbox = bbox1\n\n                # Define the row range for the line\n                start_row = top_obj_bbox[1] + 1 # max_row of top object + 1\n                end_row = bottom_obj_bbox[0]    # min_row of bottom object (exclusive)\n\n                # Check if the path is clear (all background) and draw the line\n                is_clear = True\n                if start_row < end_row: # Ensure there's a gap\n                    for r in range(start_row, end_row):\n                         # Check bounds\n                        if not (0 <= r < output_grid.shape[0] and 0 <= draw_col < output_grid.shape[1]):\n                            is_clear = False\n                            break\n                        if output_grid[r, draw_col] != background_color:\n                            is_clear = False\n                            break\n                    if is_clear:\n                        output_grid[start_row:end_row, draw_col] = blue_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4322,
    "candidates_token_count": 1742,
    "total_token_count": 6064,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.248333,
  "retries": null
}