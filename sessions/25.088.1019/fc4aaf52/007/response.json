{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies the single non-background object in the input grid, which is composed of exactly two distinct non-background colors.\nCreates a new grid based on the input grid.\nErases the original object from the new grid by replacing its pixels with the background color.\nCreates a copy of the original object, but swaps its two constituent non-background colors.\nPlaces this color-swapped copy onto the new grid such that its leftmost column is positioned one column to the right of the original object's rightmost column.\nThe vertical position remains unchanged. Pixels shifted outside the grid boundary are discarded.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    # Use Counter for efficiency\n    counts = Counter(grid.flatten())\n    # Handle empty grids\n    if not counts:\n        return 0 # Default background\n    # Background is the most frequent color\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_connected_object(grid, start_r, start_c, background_color, visited):\n    \"\"\"Finds all connected non-background pixels starting from (start_r, start_c) using BFS.\"\"\"\n    rows, cols = grid.shape\n    # Use deque for efficient queue operations\n    q = deque([(start_r, start_c)])\n    object_coords = set()\n    object_colors = set()\n\n    # Check if starting point is valid and not background\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or grid[start_r, start_c] == background_color:\n        return object_coords, object_colors # Return empty sets if start is invalid or background\n\n    while q:\n        r, c = q.popleft() # Use popleft for BFS\n\n        # Boundary and visited checks\n        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited:\n            continue\n\n        pixel_color = grid[r, c]\n        # Check if current pixel is part of the object (not background)\n        if pixel_color == background_color:\n            continue\n\n        # Mark as visited and add to object coordinates and colors\n        visited.add((r, c))\n        object_coords.add((r, c))\n        object_colors.add(pixel_color)\n\n        # Explore neighbors (4-connectivity: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Add valid, unvisited neighbors that are not background to the queue\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr, nc] != background_color:\n                 q.append((nr, nc))\n\n    return object_coords, object_colors\n\n\ndef find_the_object(grid, background_color):\n    \"\"\"Finds the single non-background object and its constituent colors in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    # Iterate through grid to find the first non-background pixel\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                # Found the start of an object, find all connected parts and colors\n                object_coords, object_colors = find_connected_object(grid, r, c, background_color, visited)\n                # Assuming only one object per task description\n                if object_coords:\n                    return object_coords, object_colors\n    # Return None if no non-background object is found\n    return None, None\n\n\ndef get_object_bounding_box(object_coords):\n    \"\"\"Calculates bounding box of the object.\"\"\"\n    if not object_coords:\n        return None, None, None, None\n\n    # Extract row and column coordinates\n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n\n    # Calculate bounding box limits\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    return min_row, max_row, min_col, max_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: find object, identify its two colors,\n    erase original, place a color-swapped copy immediately to the right.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient manipulation\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Determine the background color\n    background_color = find_background_color(grid)\n\n    # 2. Identify the single connected object, its pixels, and its colors\n    object_coords, object_colors = find_the_object(grid, background_color)\n\n    # If no object is found (e.g., grid is all background), return the original grid\n    if not object_coords:\n        return input_grid # Return original as list of lists\n\n    # 3. Identify the two distinct non-background colors and create swap map\n    non_background_colors = list(object_colors)\n    if len(non_background_colors) != 2:\n        # According to the examples, there should always be exactly two.\n        # If not, maybe return original or raise error. Returning original for now.\n        print(f\"Warning: Expected 2 object colors, found {len(non_background_colors)}. Returning original.\")\n        return input_grid\n\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    color_swap_map = {color1: color2, color2: color1}\n\n    # 4. Calculate the bounding box of the original object\n    min_row, max_row, min_col, max_col = get_object_bounding_box(object_coords)\n\n    # 5. Calculate the horizontal shift amount\n    # The new copy's minimum column (left edge) should be one column past the original's maximum column\n    new_copy_min_col = max_col + 1\n    # The shift amount is the difference between the new start column and the original start column\n    horizontal_shift = new_copy_min_col - min_col\n\n    # 6. Create a new output grid, initially identical to the input grid\n    output_grid = np.copy(grid)\n\n    # 7. Erase the original object from the output grid\n    for r, c in object_coords:\n        output_grid[r, c] = background_color\n\n    # 8. Create the transformed (color-swapped) copy\n    for r, c in object_coords:\n        # 8a. Get the original color of this pixel from the input grid\n        original_color = grid[r, c]\n        # 8b. Use the color mapping to find the corresponding swapped color\n        swapped_color = color_swap_map[original_color]\n        # 8c. Calculate the destination coordinates\n        dest_r, dest_c = r, c + horizontal_shift\n        # 8d. If the destination coordinates are within bounds, update the output grid\n        if 0 <= dest_r < rows and 0 <= dest_c < cols:\n            output_grid[dest_r, dest_c] = swapped_color\n        # else: Pixel shifted off-grid is discarded\n\n    # 9. Return the modified output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14245,
    "candidates_token_count": 1798,
    "total_token_count": 16043,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.803883,
  "retries": null
}