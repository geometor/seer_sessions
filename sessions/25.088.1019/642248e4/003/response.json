{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies border lines (either horizontal top/bottom or vertical left/right) in the input grid.\nFor each blue pixel (color 1) in the input grid, determines if it's closer to the first border (top/left) or the second border (bottom/right).\nIf the blue pixel is closer to the first border, it attempts to color the adjacent cell in the direction of the first border (up/left) with the first border's color, but only if that adjacent cell is currently white (color 0).\nIf the blue pixel is closer to the second border, it attempts to color the adjacent cell in the direction of the second border (down/right) with the second border's color, but only if that adjacent cell is currently white (color 0).\nIf the blue pixel is equidistant from both borders (only possible if the dimension is odd, which doesn't occur in the examples), it defaults to acting as if it were closer to the first border (top/left).\nThe coloring actions modify a copy of the input grid, ensuring that original white cells are checked before modification.\n\"\"\"\n\ndef find_borders(grid):\n    \"\"\"\n    Identifies the location and colors of the two border lines.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - border_type (str): 'horizontal' or 'vertical'.\n            - border1_color (int): Color of the first border (top or left).\n            - border1_direction (tuple): Relative direction vector for border 1.\n            - border2_color (int): Color of the second border (bottom or right).\n            - border2_direction (tuple): Relative direction vector for border 2.\n        Returns None if two distinct borders are not found as expected.\n    \"\"\"\n    height, width = grid.shape\n\n    # Define directions\n    UP = (-1, 0)\n    DOWN = (1, 0)\n    LEFT = (0, -1)\n    RIGHT = (0, 1)\n\n    # Check for horizontal borders (top/bottom)\n    top_row = grid[0, :]\n    bottom_row = grid[height - 1, :]\n    # Ensure the entire row is a single non-white color\n    is_top_border = len(np.unique(top_row)) == 1 and top_row[0] != 0\n    is_bottom_border = len(np.unique(bottom_row)) == 1 and bottom_row[0] != 0\n\n    if is_top_border and is_bottom_border:\n        # Ensure border colors are different (as implied by examples, though not strictly necessary for logic)\n        # if top_row[0] != bottom_row[0]:\n        return 'horizontal', top_row[0], UP, bottom_row[0], DOWN\n\n    # Check for vertical borders (left/right)\n    left_col = grid[:, 0]\n    right_col = grid[:, width - 1]\n    # Ensure the entire col is a single non-white color\n    is_left_border = len(np.unique(left_col)) == 1 and left_col[0] != 0\n    is_right_border = len(np.unique(right_col)) == 1 and right_col[0] != 0\n\n    if is_left_border and is_right_border:\n        # Ensure border colors are different\n        # if left_col[0] != right_col[0]:\n        return 'vertical', left_col[0], LEFT, right_col[0], RIGHT\n\n    # Did not find the expected pair of borders\n    return None\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by placing colored pixels adjacent to blue pixels\n    based on proximity to borders, only on white cells.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n\n    # Identify borders and their properties\n    border_info = find_borders(input_grid_np)\n    if border_info is None:\n        # If borders aren't as expected, return the original grid (or handle error)\n        # This case doesn't seem to occur in the provided examples.\n        print(\"Warning: Could not identify standard borders. Returning input.\")\n        return input_grid # Return original list format\n\n    border_type, color1, direction1, color2, direction2 = border_info\n\n    # Define the range to iterate over (excluding borders)\n    if border_type == 'horizontal':\n        row_start, row_end = 1, height - 1\n        col_start, col_end = 0, width\n    else: # vertical\n        row_start, row_end = 0, height\n        col_start, col_end = 1, width - 1\n\n    # Iterate through the inner part of the grid\n    for r in range(row_start, row_end):\n        for c in range(col_start, col_end):\n            # Check if the current cell in the *input* grid is blue (1)\n            if input_grid_np[r, c] == 1:\n                target_r, target_c = -1, -1 # Initialize invalid coordinates\n                color_to_place = -1 # Initialize invalid color\n\n                # Determine which border is closer and the corresponding action\n                if border_type == 'horizontal':\n                    dist1 = r - 0 # Distance from top border (row 0)\n                    dist2 = (height - 1) - r # Distance from bottom border (row H-1)\n\n                    if dist1 <= dist2: # Closer to top or equidistant (default to top)\n                        target_r, target_c = r + direction1[0], c + direction1[1]\n                        color_to_place = color1\n                    else: # Closer to bottom\n                        target_r, target_c = r + direction2[0], c + direction2[1]\n                        color_to_place = color2\n\n                else: # vertical borders\n                    dist1 = c - 0 # Distance from left border (col 0)\n                    dist2 = (width - 1) - c # Distance from right border (col W-1)\n\n                    if dist1 <= dist2: # Closer to left or equidistant (default to left)\n                        target_r, target_c = r + direction1[0], c + direction1[1]\n                        color_to_place = color1\n                    else: # Closer to right\n                        target_r, target_c = r + direction2[0], c + direction2[1]\n                        color_to_place = color2\n\n                # Check bounds and if the target cell in the *input* grid was white (0)\n                if 0 <= target_r < height and 0 <= target_c < width and input_grid_np[target_r, target_c] == 0:\n                    # Place the determined color in the *output* grid\n                    output_grid[target_r, target_c] = color_to_place\n\n    # Return the transformed grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4927,
    "candidates_token_count": 1680,
    "total_token_count": 6607,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 138.743978,
  "retries": null
}