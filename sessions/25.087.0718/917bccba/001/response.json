{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, namedtuple\n\nBoundingBox = namedtuple(\"BoundingBox\", [\"min_row\", \"max_row\", \"min_col\", \"max_col\"])\n\ndef find_connected_components(grid, ignore_color=0):\n    \"\"\"\n    Finds all connected components (objects) in the grid, ignoring a specific color.\n    Uses BFS.\n    Returns a list of tuples: (color, set_of_coordinates).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                color = grid[r, c]\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                component_pixels.add((nr, nc))\n                                q.append((nr, nc))\n                \n                if component_pixels:\n                     components.append((color, component_pixels))\n                     \n    return components\n\ndef find_largest_object(grid, ignore_color=0):\n    \"\"\"\n    Finds the largest connected component (object) in the grid, ignoring the background color.\n    Returns the color and pixels of the largest object, or (None, None) if no object found.\n    \"\"\"\n    components = find_connected_components(grid, ignore_color)\n    if not components:\n        return None, None\n\n    largest_component = max(components, key=lambda item: len(item[1]))\n    return largest_component[0], largest_component[1]\n\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixel coordinates.\n    Returns a BoundingBox named tuple, or None if pixels set is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    \n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    \n    return BoundingBox(min(rows), max(rows), min(cols), max(cols))\n\ndef find_active_color(grid, main_shape_color, bbox, ignore_color=0):\n    \"\"\"\n    Finds the color (other than background and main shape color) that exists\n    both inside and outside the given bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    candidate_colors = set(np.unique(grid)) - {ignore_color, main_shape_color}\n\n    for color in candidate_colors:\n        found_inside = False\n        found_outside = False\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r, c] == color:\n                    is_inside = (bbox.min_row <= r <= bbox.max_row and \n                                 bbox.min_col <= c <= bbox.max_col)\n                    if is_inside:\n                        found_inside = True\n                    else:\n                        found_outside = True\n                if found_inside and found_outside:\n                    return color # Found the active color\n    return None # No active color found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the observed pattern:\n    1. Identifies the main solid shape (largest non-background object) and its bounding box.\n    2. Identifies the 'active color' present both inside and outside the main shape's bounding box.\n    3. Removes active color pixels from inside the main shape's bounding box.\n    4. Moves active color pixels from outside the bounding box:\n        - If vertically aligned with the box, move 3 columns right.\n        - If horizontally aligned with the box, move to the top edge (min_row) of the box.\n    \"\"\"\n    \n    # Find the main shape (largest non-background object)\n    main_shape_color, main_shape_pixels = find_largest_object(input_grid, ignore_color=0)\n    \n    if main_shape_color is None or main_shape_pixels is None:\n        # Cannot identify main shape, return input unchanged\n        return input_grid.copy()\n        \n    # Determine the bounding box of the main shape\n    bbox = get_bounding_box(main_shape_pixels)\n    if bbox is None:\n         # Should not happen if main_shape_pixels is not None, but safety check\n        return input_grid.copy()\n\n    # Identify the active color\n    active_color = find_active_color(input_grid, main_shape_color, bbox, ignore_color=0)\n    \n    if active_color is None:\n        # Cannot identify active color, return input unchanged\n        return input_grid.copy()\n        \n    # Initialize output_grid as a copy of input_grid\n    output_grid = input_grid.copy()\n    rows, cols = input_grid.shape\n    \n    # Store movements to apply later to avoid conflicts during iteration\n    movements = [] # List of tuples: (target_r, target_c, color)\n\n    # Iterate through the input grid to process active color pixels\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] == active_color:\n                # Check if the pixel is inside the bounding box\n                is_inside = (bbox.min_row <= r <= bbox.max_row and \n                             bbox.min_col <= c <= bbox.max_col)\n\n                if is_inside:\n                    # Remove active color pixels from inside the bbox\n                    output_grid[r, c] = 0 \n                else:\n                    # Remove active color pixel from its original outside position\n                    output_grid[r, c] = 0 \n                    \n                    # Determine target position for movement\n                    target_r, target_c = -1, -1 # Initialize invalid target\n\n                    # Check if pixel is vertically aligned (within column span of bbox)\n                    if bbox.min_col <= c <= bbox.max_col:\n                        target_r, target_c = r, c + 3\n                    # Check if pixel is horizontally aligned (within row span of bbox)\n                    elif bbox.min_row <= r <= bbox.max_row:\n                         target_r, target_c = bbox.min_row, c\n                         \n                    # Check if target is valid and within grid bounds before adding movement\n                    if 0 <= target_r < rows and 0 <= target_c < cols:\n                         movements.append((target_r, target_c, active_color))\n\n    # Apply the stored movements to the output grid\n    for r, c, color in movements:\n        # Check bounds again just in case (e.g., if multiple pixels move to same spot, last one wins)\n         if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4333,
    "candidates_token_count": 1756,
    "total_token_count": 6089,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.570023,
  "retries": null
}