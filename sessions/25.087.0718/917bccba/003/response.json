{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, namedtuple\nimport math\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identifies the main solid shape (largest non-background connected component) and its bounding box.\n2. Calculates the width of the bounding box.\n3. Identifies the 'active color' - a color (not background or main shape color) present both inside and outside the main shape's bounding box.\n4. Creates an output grid initially identical to the input.\n5. Removes active color pixels from inside the main shape's bounding box in the output grid (sets them to background color 0).\n6. Moves active color pixels from outside the bounding box in the output grid:\n    a. Erases the pixel from its original position (sets to background color 0).\n    b. If the pixel was vertically aligned with the box (within its column range), its new position is in the same row, but shifted right by floor(bounding_box_width / 2) columns.\n    c. If the pixel was horizontally aligned with the box (within its row range), its new position is in the same column, but moved to the top row of the bounding box (bbox.min_row).\n7. The moved pixels are painted onto the output grid in their new locations. If multiple pixels move to the same location, the last one processed determines the final color.\n\"\"\"\n\nBoundingBox = namedtuple(\"BoundingBox\", [\"min_row\", \"max_row\", \"min_col\", \"max_col\"])\n\ndef find_connected_components(grid, ignore_color=0):\n    \"\"\"\n    Finds all connected components (objects) in the grid, ignoring a specific color.\n    Uses BFS with 8-way connectivity (including diagonals).\n    Returns a list of tuples: (color, set_of_coordinates).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                color = grid[r, c]\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                component_pixels.add((nr, nc))\n                                q.append((nr, nc))\n\n                if component_pixels:\n                     components.append((color, component_pixels))\n\n    return components\n\ndef find_largest_object(grid, ignore_color=0):\n    \"\"\"\n    Finds the largest connected component (object) in the grid, ignoring the background color.\n    Returns the color and pixels of the largest object, or (None, None) if no object found.\n    \"\"\"\n    components = find_connected_components(grid, ignore_color)\n    if not components:\n        return None, None\n\n    largest_component = max(components, key=lambda item: len(item[1]))\n    return largest_component[0], largest_component[1]\n\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixel coordinates.\n    Returns a BoundingBox named tuple, or None if pixels set is empty.\n    \"\"\"\n    if not pixels:\n        return None\n\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n\n    return BoundingBox(min(rows), max(rows), min(cols), max(cols))\n\ndef find_active_color(grid, main_shape_color, bbox, ignore_color=0):\n    \"\"\"\n    Finds the color (other than background and main shape color) that exists\n    both inside and outside the given bounding box. Returns the color or None.\n    \"\"\"\n    rows, cols = grid.shape\n    # Find all unique colors present in the grid\n    unique_colors = set(np.unique(grid))\n    # Define candidate colors: exclude background and main shape color\n    candidate_colors = unique_colors - {ignore_color, main_shape_color}\n\n    for color in candidate_colors:\n        found_inside = False\n        found_outside = False\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r, c] == color:\n                    # Check if the pixel is inside the bounding box\n                    is_inside = (bbox.min_row <= r <= bbox.max_row and\n                                 bbox.min_col <= c <= bbox.max_col)\n                    if is_inside:\n                        found_inside = True\n                    else:\n                        found_outside = True\n                # If we found the color both inside and outside, no need to check further for this color\n                if found_inside and found_outside:\n                    return color # Found the active color\n\n    return None # No active color found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n\n    # 1. Identify the main shape (largest non-background object)\n    main_shape_color, main_shape_pixels = find_largest_object(input_grid, ignore_color=0)\n\n    if main_shape_color is None or main_shape_pixels is None:\n        # Cannot identify main shape, return input unchanged\n        return input_grid.copy()\n\n    # 2. Determine the bounding box of the main shape\n    bbox = get_bounding_box(main_shape_pixels)\n    if bbox is None:\n         # Should not happen if main_shape_pixels is not None, but safety check\n        return input_grid.copy()\n\n    # Calculate bounding box width\n    bbox_width = bbox.max_col - bbox.min_col + 1\n    # Calculate the vertical shift distance\n    vertical_shift = math.floor(bbox_width / 2)\n\n\n    # 3. Identify the active color\n    active_color = find_active_color(input_grid, main_shape_color, bbox, ignore_color=0)\n\n    if active_color is None:\n        # Cannot identify active color, return input unchanged\n        return input_grid.copy()\n\n    # 4. Initialize output_grid as a copy of input_grid\n    output_grid = input_grid.copy()\n\n    # 5 & 6. Process active color pixels: remove inside, determine moves for outside\n    movements = [] # Store target locations for moved pixels: (target_r, target_c, color)\n\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] == active_color:\n                # Check if the pixel is inside the bounding box\n                is_inside = (bbox.min_row <= r <= bbox.max_row and\n                             bbox.min_col <= c <= bbox.max_col)\n\n                if is_inside:\n                    # Remove active color pixels from inside the bbox\n                    output_grid[r, c] = 0\n                else:\n                    # Pixel is outside the bbox. Erase from original position.\n                    output_grid[r, c] = 0\n\n                    # Determine target position based on alignment\n                    target_r, target_c = -1, -1 # Initialize invalid target\n\n                    # Check if pixel is vertically aligned (within column span of bbox)\n                    if bbox.min_col <= c <= bbox.max_col:\n                        target_r, target_c = r, c + vertical_shift # Apply calculated shift\n                    # Check if pixel is horizontally aligned (within row span of bbox)\n                    elif bbox.min_row <= r <= bbox.max_row:\n                         target_r, target_c = bbox.min_row, c # Move to top edge of bbox\n\n                    # If a valid target was determined, store the movement\n                    if target_r != -1 or target_c != -1: # Check if either target was set\n                         movements.append((target_r, target_c, active_color))\n\n\n    # 7. Apply the stored movements to the output grid\n    for r, c, color in movements:\n        # Apply movement only if target is within grid bounds\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10311,
    "candidates_token_count": 2046,
    "total_token_count": 12357,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.875458,
  "retries": null
}