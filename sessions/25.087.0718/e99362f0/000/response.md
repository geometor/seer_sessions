## Perception of Task Elements

1.  **Input Grid Structure**: The input grids consistently have dimensions 11x9.
2.  **Output Grid Structure**: The output grids consistently have dimensions 5x4.
3.  **Separators**: Each input grid contains a single horizontal line of yellow pixels (color 4) at row index 5 and a single vertical column of yellow pixels at column index 4. These act as dividers.
4.  **Quadrants**: The yellow separators divide the non-yellow parts of the input grid into four distinct quadrants:
    *   **Upper-Left (UL)**: Rows 0-4, Columns 0-3 (5x4 grid).
    *   **Upper-Right (UR)**: Rows 0-4, Columns 5-8 (5x4 grid).
    *   **Lower-Left (LL)**: Rows 6-10, Columns 0-3 (5x4 grid).
    *   **Lower-Right (LR)**: Rows 6-10, Columns 5-8 (5x4 grid).
5.  **Transformation Logic**: The output grid is generated by comparing the pixels at corresponding positions within the four input quadrants.
6.  **Pixel Priority**: When combining the quadrants, there is a clear priority rule. If multiple quadrants have a non-white pixel at the same location, the pixel from the highest priority quadrant determines the output color. The observed priority order is: Lower-Right (LR) > Upper-Left (UL) > Upper-Right (UR) > Lower-Left (LL).
7.  **White Background**: If the corresponding pixels in all four quadrants are white (color 0), the output pixel at that position is also white.
8.  **Ignored Elements**: The yellow separator row and column are not directly represented in the output grid; they serve only to define the quadrants.

## YAML Fact Document


```yaml
task_context:
  description: >
    The task involves processing an input grid divided into four quadrants by a
    central yellow cross (one horizontal line, one vertical column). The output
    grid is generated by combining these four quadrants pixel by pixel according
    to a specific priority rule.
  grid_dimensions:
    input: [11, 9]
    output: [5, 4]
  separators:
    - type: horizontal_line
      color: yellow
      index: 5
    - type: vertical_column
      color: yellow
      index: 4
elements:
  - object: quadrant
    attributes:
      - name: upper_left (UL)
        location: rows 0-4, cols 0-3
        size: [5, 4]
      - name: upper_right (UR)
        location: rows 0-4, cols 5-8
        size: [5, 4]
      - name: lower_left (LL)
        location: rows 6-10, cols 0-3
        size: [5, 4]
      - name: lower_right (LR)
        location: rows 6-10, cols 5-8
        size: [5, 4]
  - object: output_grid
    attributes:
      size: [5, 4]
relationships:
  - type: derived_from
    source: [UL, UR, LL, LR]
    target: output_grid
    details: >
      Each pixel in the output grid is determined by the corresponding pixel
      in the four input quadrants.
actions:
  - action: split_input
    details: >
      Divide the input grid into four 5x4 quadrants (UL, UR, LL, LR) using the
      yellow line at row 5 and yellow column at column 4 as separators. The
      separators themselves are discarded.
  - action: combine_quadrants
    details: >
      Create the output grid pixel by pixel. For each coordinate (r, c):
      Check the pixel colors at (r, c) in the quadrants LR, UL, UR, LL in that order.
      The output pixel at (r, c) takes the color of the first non-white pixel found.
      If all corresponding pixels in the quadrants are white (0), the output pixel is white (0).
    priority_order: [LR, UL, UR, LL] # Highest to lowest
```


## Natural Language Program

1.  **Identify Separators**: Locate the horizontal row (index 5) and vertical column (index 4) consisting entirely of yellow pixels (color 4) in the 11x9 input grid.
2.  **Extract Quadrants**: Using the separators as boundaries, extract the four 5x4 subgrids (quadrants) from the input grid, ignoring the separator row and column:
    *   Define Upper-Left (UL) as the subgrid from rows 0-4 and columns 0-3.
    *   Define Upper-Right (UR) as the subgrid from rows 0-4 and columns 5-8.
    *   Define Lower-Left (LL) as the subgrid from rows 6-10 and columns 0-3.
    *   Define Lower-Right (LR) as the subgrid from rows 6-10 and columns 5-8.
3.  **Initialize Output**: Create a new 5x4 output grid, initially filled with a default value (e.g., white/0).
4.  **Combine Quadrants with Priority**: Iterate through each cell position (`r`, `c`) from `r=0` to `4` and `c=0` to `3`:
    *   Get the pixel color at (`r`, `c`) from each quadrant: `lr_color = LR[r, c]`, `ul_color = UL[r, c]`, `ur_color = UR[r, c]`, `ll_color = LL[r, c]`.
    *   Apply the priority rule to determine the output color:
        *   If `lr_color` is not white (0), set `Output[r, c]` to `lr_color`.
        *   Else if `ul_color` is not white (0), set `Output[r, c]` to `ul_color`.
        *   Else if `ur_color` is not white (0), set `Output[r, c]` to `ur_color`.
        *   Else if `ll_color` is not white (0), set `Output[r, c]` to `ll_color`.
        *   Else (all are white), set `Output[r, c]` to white (0).
5.  **Return Output**: The resulting 5x4 grid is the final output.