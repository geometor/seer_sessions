{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation determines the output grid by applying the first matching rule from the following prioritized list, using red (2) as the primary color and white (0) as the background color:\n\n1.  **Solid Row Separation Rule:** Check if the input grid contains exactly three unique colors AND if it has a horizontal row composed entirely of the primary color (red). If both conditions are true:\n    *   Identify the 'third color' (neither white nor red).\n    *   Find the row index (`sr`) of the topmost solid red row.\n    *   Create the output grid by filling rows `0` to `sr-1` with white, row `sr` with red, and rows `sr+1` to the bottom with the 'third color'.\n\n2.  **Fixed Diagonal Pattern Rule:** If Rule 1 does not apply, check if the input grid contains exactly three unique colors AND if *all* red pixels are located at positions `(r, c)` where `r = c + 1` or `r = c + 2`. If both conditions are true:\n    *   Identify the 'third color'.\n    *   Create the output grid with a fixed pattern: pixels where `r < c + 1` are white, pixels where `r == c + 1` or `r == c + 2` are red, and pixels where `r > c + 2` are the 'third color'.\n\n3.  **Column Filter with Conditional Downward Propagation Rule:** If neither Rule 1 nor Rule 2 applies, construct the output grid by processing each column independently based on the input grid:\n    *   Find the row index (`mr`) of the topmost red pixel in the input column.\n    *   If no red pixel exists in the input column, the output column is identical to the input column.\n    *   If a topmost red pixel exists at `mr` in the input column:\n        *   Initialize the corresponding output column.\n        *   Set rows `0` to `mr-1` in the output column to white.\n        *   Set the pixel at `(mr, col)` in the output column to red.\n        *   For each row `r` from `mr + 1` downwards to the bottom of the grid:\n            *   Examine the pixel at `(r, col)` in the *input* grid.\n            *   If the input pixel `input_grid[r, col]` is white (0), set the output pixel `output_grid[r, col]` to the color of the pixel directly above it in the *output* grid (`output_grid[r - 1, col]`).\n            *   Otherwise (if `input_grid[r, col]` is not white), set the output pixel `output_grid[r, col]` to its original color from the input grid (`input_grid[r, col]`).\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_unique_colors(grid):\n    \"\"\"Identifies unique colors in the grid.\"\"\"\n    return set(grid.flatten())\n\ndef find_solid_row(grid, color):\n    \"\"\"Finds the index of the first row consisting entirely of the specified color. Returns -1 if none found.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        if np.all(grid[r, :] == color):\n            return r\n    return -1\n\ndef check_all_key_on_diag(grid, key_color):\n    \"\"\"Checks if all occurrences of key_color are on diagonals r=c+1 or r=c+2.\"\"\"\n    key_locations = np.argwhere(grid == key_color)\n    if len(key_locations) == 0:\n        # Rule 2 requires 3 colors, one of which must be the key color.\n        # If no key color exists, Rule 2 cannot apply.\n        return False\n    for r, c in key_locations:\n        if not (r == c + 1 or r == c + 2):\n            return False\n    return True\n\n# --- Rule Application Functions ---\n\ndef apply_row_separation(grid_shape, key_color, background_color, third_color, solid_row_index):\n    \"\"\"Applies Rule 1: Row Separation.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Fill above with background initially\n\n    # Set the separator row\n    output_grid[solid_row_index, :] = key_color\n\n    # Fill below with third color, only if there are rows below\n    if solid_row_index < height - 1:\n        output_grid[solid_row_index + 1:, :] = third_color\n\n    return output_grid\n\ndef apply_fixed_pattern(grid_shape, key_color, background_color, third_color):\n    \"\"\"Applies Rule 2: Fixed Diagonal Pattern Generation.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Default to background\n\n    for r in range(height):\n        for c in range(width):\n            # Key color diagonal band\n            if r == c + 1 or r == c + 2:\n                output_grid[r, c] = key_color\n            # Third color below the band\n            elif r > c + 2:\n                output_grid[r, c] = third_color\n            # Background color above the band (already set by default)\n\n    return output_grid\n\ndef apply_column_filter_propagation(input_grid, key_color, background_color):\n    \"\"\"Applies Rule 3: Column Filtering with Conditional Downward Propagation.\"\"\"\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid) # Start with a copy of the input\n\n    for c in range(width):\n        # Find the row index of the highest occurrence (minimum row index) of the key color in the input column\n        key_color_indices = np.where(input_grid[:, c] == key_color)[0]\n\n        if len(key_color_indices) > 0:\n            min_row = np.min(key_color_indices)\n\n            # 1. Set pixels above the highest key color to background in the output\n            output_grid[:min_row, c] = background_color\n\n            # 2. Set the topmost key color pixel itself to the key color in the output\n            #    (This overwrites whatever might have been there in the input, ensuring it's the key color)\n            output_grid[min_row, c] = key_color\n\n            # 3. Propagate colors downwards starting from min_row + 1,\n            #    but *only* fill if the original input pixel was background color.\n            for r in range(min_row + 1, height):\n                # Check the corresponding pixel in the *original input* grid\n                if input_grid[r, c] == background_color:\n                    # If it was background, fill it with the color from above in the *output* grid\n                    output_grid[r, c] = output_grid[r - 1, c]\n                # Else (if input_grid[r, c] was not background):\n                #   The output_grid[r, c] already holds the correct value\n                #   because output_grid was initialized as a copy of input_grid.\n                #   So, no action is needed here.\n\n        # If key color not in column, the column remains unchanged (already copied from input)\n\n    return output_grid\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the prioritized rules.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    grid_shape = (height, width)\n\n    # Define constants\n    BACKGROUND_COLOR = 0\n    KEY_COLOR = 2 # Red\n\n    # --- Analyze Input Grid Properties ---\n    unique_colors = find_unique_colors(input_np)\n    other_colors = unique_colors - {BACKGROUND_COLOR, KEY_COLOR}\n    # Determine the 'third_color' only if exactly 3 unique colors exist\n    third_color = next(iter(other_colors), None) if len(unique_colors) == 3 else None\n    num_unique_colors = len(unique_colors)\n\n    # --- Rule Application Logic ---\n\n    # 1. Check Rule 1: Solid Row Separation\n    solid_row_index = find_solid_row(input_np, KEY_COLOR)\n    # Rule 1 requires a solid key row AND exactly 3 unique colors\n    if solid_row_index != -1 and third_color is not None:\n        # Apply Rule 1\n        output_grid = apply_row_separation(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color, solid_row_index)\n\n    # 2. Check Rule 2: Fixed Diagonal Pattern Generation\n    # Rule 2 requires NO solid key row, exactly 3 unique colors, AND all key pixels on specific diagonals\n    elif solid_row_index == -1 and third_color is not None:\n        all_key_on_diag = check_all_key_on_diag(input_np, KEY_COLOR)\n        if all_key_on_diag:\n            # Apply Rule 2\n            output_grid = apply_fixed_pattern(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color)\n        else:\n            # Conditions for Rule 1 & 2 (diag part) not met, proceed to Rule 3\n            output_grid = apply_column_filter_propagation(input_np, KEY_COLOR, BACKGROUND_COLOR)\n\n    # 3. Apply Rule 3: Column Filter (Default)\n    else:\n        # Conditions for Rule 1 & 2 not met (e.g., not 3 colors, or rule 2 diag condition failed, or no solid row but not 3 colors)\n        output_grid = apply_column_filter_propagation(input_np, KEY_COLOR, BACKGROUND_COLOR)\n\n    # Convert final numpy array back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10220,
    "candidates_token_count": 2355,
    "total_token_count": 12575,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.047356,
  "retries": null
}