{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis program transforms an input grid based on the arrangement of a 'key color' (red=2) and the presence of other colors. \n\nThe transformation follows these prioritized rules:\n\n1.  **Solid Row Rule:** If a horizontal row consists entirely of the key color (red=2), this row acts as a separator. The output grid will have this separator row preserved. All rows above it are filled with the background color (white=0). All rows below it are filled with the 'third color' present in the input grid (if one exists).\n\n2.  **Fixed Diagonal Pattern Rule:** If Rule 1 does not apply, and the input grid contains exactly three distinct colors (background=0, key=2, and a third color), the output grid is constructed with a fixed diagonal pattern. A band two pixels thick diagonally (specifically, cells where row == col + 1 or row == col + 2) is filled with the key color (red=2). The area below this band (row > col + 2) is filled with the third color. The area above the band (row < col + 1) is filled with the background color (white=0).\n\n3.  **Column Filter Rule:** If neither Rule 1 nor Rule 2 applies, a column-wise filter is applied. For each column, the highest occurrence of the key color (red=2) is identified. All pixels in that column *above* this highest key color pixel are changed to the background color (white=0). Pixels at or below the highest key color pixel, and pixels in columns containing no key color, remain unchanged from the input.\n\"\"\"\n\ndef find_unique_colors(grid):\n    \"\"\"Identifies unique colors in the grid.\"\"\"\n    return set(grid.flatten())\n\ndef find_solid_row(grid, color):\n    \"\"\"Finds the index of the first row consisting entirely of the specified color. Returns -1 if none found.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        if np.all(grid[r, :] == color):\n            return r\n    return -1\n\ndef apply_row_separation(grid_shape, key_color, background_color, third_color, solid_row_index):\n    \"\"\"Applies Rule 1: Row Separation.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Fill above with background initially\n    \n    if solid_row_index < height -1 :\n         # Fill below with third color\n        output_grid[solid_row_index + 1:, :] = third_color\n   \n    # Set the separator row\n    output_grid[solid_row_index, :] = key_color\n\n    return output_grid\n\ndef apply_fixed_pattern(grid_shape, key_color, background_color, third_color):\n    \"\"\"Applies Rule 2: Fixed Diagonal Pattern.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Default to background\n\n    for r in range(height):\n        for c in range(width):\n            # Key color diagonal band\n            if r == c + 1 or r == c + 2:\n                output_grid[r, c] = key_color\n            # Third color below the band\n            elif r > c + 2:\n                output_grid[r, c] = third_color\n            # Background color above the band (already set by default)\n            # else: output_grid[r, c] = background_color\n\n    return output_grid\n\ndef apply_column_filter(grid, key_color, background_color):\n    \"\"\"Applies Rule 3: Column Filtering.\"\"\"\n    height, width = grid.shape\n    output_grid = np.copy(grid) # Start with a copy of the input\n\n    for c in range(width):\n        # Find the row index of the highest occurrence of the key color in the column\n        key_color_indices = np.where(grid[:, c] == key_color)[0]\n        if len(key_color_indices) > 0:\n            min_row = np.min(key_color_indices)\n            # Set pixels above the highest key color to background\n            output_grid[:min_row, c] = background_color\n        # If key color not in column, the column remains unchanged (already copied)\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules described above.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    grid_shape = (height, width)\n\n    BACKGROUND_COLOR = 0\n    KEY_COLOR = 2\n\n    # 1. Analyze Input\n    unique_colors = find_unique_colors(input_np)\n    other_colors = unique_colors - {BACKGROUND_COLOR, KEY_COLOR}\n    third_color = next(iter(other_colors)) if len(other_colors) == 1 else None # Assign if exactly one other color exists\n    num_unique_colors = len(unique_colors)\n\n    # 2. Check for Solid Key Color Row (Rule 1)\n    solid_row_index = find_solid_row(input_np, KEY_COLOR)\n    if solid_row_index != -1 and third_color is not None: # Rule 1 needs a third color to fill below\n        # print(f\"Applying Rule 1: Solid row at {solid_row_index}, third_color={third_color}\")\n        output_grid = apply_row_separation(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color, solid_row_index)\n\n    # 3. Check for Three Colors & Fixed Pattern Rule (Rule 2)\n    elif solid_row_index == -1 and num_unique_colors == 3 and third_color is not None:\n        # print(f\"Applying Rule 2: Three colors found ({BACKGROUND_COLOR}, {KEY_COLOR}, {third_color})\")\n        output_grid = apply_fixed_pattern(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color)\n\n    # 4. Apply Column Filter Rule (Rule 3 - Default)\n    else:\n        # print(\"Applying Rule 3: Column Filter\")\n        output_grid = apply_column_filter(input_np, KEY_COLOR, BACKGROUND_COLOR)\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4093,
    "candidates_token_count": 1504,
    "total_token_count": 5597,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.958529,
  "retries": null
}