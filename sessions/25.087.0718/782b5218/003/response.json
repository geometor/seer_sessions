{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation process determines the output grid based on the following prioritized rules, using red (2) as the key color and white (0) as the background color:\n\n1.  **Solid Row Separation Rule:** First, check if the input grid contains a horizontal row composed entirely of the key color (red). If such a row exists, *and* if the grid contains exactly three distinct colors in total (background, key color, and one other 'third color'), then apply this rule. Create a new grid of the same size. Fill all rows above the solid red row with the background color (white). Keep the solid red row itself red. Fill all rows below the solid red row with the 'third color'.\n\n2.  **Fixed Diagonal Pattern Rule:** If the Solid Row Separation Rule does not apply, check two conditions: (a) Does the input grid contain exactly three distinct colors (background, key color, and a 'third color')? (b) Do *all* pixels matching the key color (red) in the input grid satisfy the positional requirement `row_index = column_index + 1` or `row_index = column_index + 2`? If *both* conditions are true, apply this rule. Create a new grid of the same size. Fill this grid with a fixed pattern: pixels where `row < column + 1` become background color (white), pixels where `row == column + 1` or `row == column + 2` become key color (red), and pixels where `row > column + 2` become the 'third color'.\n\n3.  **Column Filter Rule:** If neither the Solid Row Separation Rule nor the Fixed Diagonal Pattern Rule applies, use this default rule. Create a new grid initially as a copy of the input grid. Then, for each column independently: find the uppermost (minimum row index) pixel that has the key color (red). If such a pixel exists in the column, change the color of all pixels *above* it in that same column to the background color (white). Pixels at or below the uppermost red pixel, and all pixels in columns containing no red pixels, remain unchanged from the input grid.\n\"\"\"\n\ndef find_unique_colors(grid):\n    \"\"\"Identifies unique colors in the grid.\"\"\"\n    return set(grid.flatten())\n\ndef find_solid_row(grid, color):\n    \"\"\"Finds the index of the first row consisting entirely of the specified color. Returns -1 if none found.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        if np.all(grid[r, :] == color):\n            return r\n    return -1\n\ndef check_all_key_on_diag(grid, key_color):\n    \"\"\"Checks if all occurrences of key_color are on diagonals r=c+1 or r=c+2.\"\"\"\n    key_locations = np.argwhere(grid == key_color)\n    if len(key_locations) == 0:\n        return False # If no key color, it doesn't fit the pattern requirement for Rule 2.\n    for r, c in key_locations:\n        if not (r == c + 1 or r == c + 2):\n            return False\n    return True\n\ndef apply_row_separation(grid_shape, key_color, background_color, third_color, solid_row_index):\n    \"\"\"Applies Rule 1: Row Separation.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Fill above with background initially\n\n    if solid_row_index < height -1 :\n         # Fill below with third color, only if there are rows below\n        output_grid[solid_row_index + 1:, :] = third_color\n\n    # Set the separator row\n    output_grid[solid_row_index, :] = key_color\n\n    return output_grid\n\ndef apply_fixed_pattern(grid_shape, key_color, background_color, third_color):\n    \"\"\"Applies Rule 2: Fixed Diagonal Pattern Generation.\"\"\"\n    height, width = grid_shape\n    output_grid = np.full(grid_shape, background_color, dtype=int) # Default to background\n\n    for r in range(height):\n        for c in range(width):\n            # Key color diagonal band\n            if r == c + 1 or r == c + 2:\n                output_grid[r, c] = key_color\n            # Third color below the band\n            elif r > c + 2:\n                output_grid[r, c] = third_color\n            # Background color above the band (already set by default)\n            # else: output_grid[r, c] = background_color\n\n    return output_grid\n\ndef apply_column_filter(grid, key_color, background_color):\n    \"\"\"Applies Rule 3: Column Filtering.\"\"\"\n    height, width = grid.shape\n    output_grid = np.copy(grid) # Start with a copy of the input\n\n    for c in range(width):\n        # Find the row index of the highest occurrence (minimum row index) of the key color in the column\n        key_color_indices = np.where(grid[:, c] == key_color)[0]\n        if len(key_color_indices) > 0:\n            min_row = np.min(key_color_indices)\n            # Set pixels above the highest key color to background\n            output_grid[:min_row, c] = background_color\n        # If key color not in column, the column remains unchanged (already copied)\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the rules described in the module docstring.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    grid_shape = (height, width)\n\n    BACKGROUND_COLOR = 0\n    KEY_COLOR = 2\n\n    # 1. Analyze Input Grid Properties\n    unique_colors = find_unique_colors(input_np)\n    other_colors = unique_colors - {BACKGROUND_COLOR, KEY_COLOR}\n    # Determine the 'third_color' only if exactly 3 unique colors exist\n    third_color = next(iter(other_colors), None) if len(unique_colors) == 3 else None\n    num_unique_colors = len(unique_colors)\n\n    # 2. Check Rule 1: Solid Row Separation\n    solid_row_index = find_solid_row(input_np, KEY_COLOR)\n    # Rule 1 requires a solid key row AND exactly 3 unique colors (implying third_color is not None)\n    if solid_row_index != -1 and third_color is not None:\n        # Apply Rule 1\n        output_grid = apply_row_separation(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color, solid_row_index)\n\n    # 3. Check Rule 2: Fixed Diagonal Pattern Generation\n    # Rule 2 requires NO solid key row, exactly 3 unique colors, AND all key pixels on specific diagonals\n    elif solid_row_index == -1 and third_color is not None:\n        all_key_on_diag = check_all_key_on_diag(input_np, KEY_COLOR)\n        if all_key_on_diag:\n            # Apply Rule 2\n            output_grid = apply_fixed_pattern(grid_shape, KEY_COLOR, BACKGROUND_COLOR, third_color)\n        else:\n            # Conditions for Rule 1 & 2 not met, proceed to Rule 3\n            output_grid = apply_column_filter(input_np, KEY_COLOR, BACKGROUND_COLOR)\n    \n    # 4. Apply Rule 3: Column Filter (Default)\n    else:\n        # Conditions for Rule 1 & 2 not met\n        output_grid = apply_column_filter(input_np, KEY_COLOR, BACKGROUND_COLOR)\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8023,
    "candidates_token_count": 1842,
    "total_token_count": 9865,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.703324,
  "retries": null
}