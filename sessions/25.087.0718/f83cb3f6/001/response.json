{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n\n1. Identify a continuous line of azure (8) pixels, which acts as a static barrier. Determine its orientation (horizontal or vertical) and location (row or column index).\n2. Identify the 'mobile' color, which is the non-white (0), non-azure (8) color present in the input grid.\n3. Initialize an output grid of the same dimensions as the input, filled with white (0).\n4. Copy the azure barrier line from the input to the output grid.\n5. If the barrier is horizontal at row `b_idx`:\n    - For each column, count the number of mobile pixels located strictly *below* the barrier (`row > b_idx`) in the input grid.\n    - Place that number of mobile pixels in the same column in the output grid, stacking vertically *upwards* starting from the row immediately *above* the barrier (`row = b_idx - 1`).\n6. If the barrier is vertical at column `b_idx`:\n    - For each row, count the number of mobile pixels located strictly *to the right* of the barrier (`col > b_idx`) in the input grid.\n    - Place that number of mobile pixels in the same row in the output grid, stacking horizontally *rightwards* starting from the column immediately *to the right* of the barrier (`col = b_idx + 1`).\n7. Pixels of the mobile color on the 'other' side of the barrier (above a horizontal barrier, left of a vertical barrier) are effectively removed as the output grid starts white and only pixels below/right are counted and relocated.\n\"\"\"\n\ndef find_barrier(grid):\n    \"\"\"Finds the location, orientation, and color of the barrier line.\"\"\"\n    barrier_color = 8 # Azure is the barrier color in examples\n    coords = np.argwhere(grid == barrier_color)\n\n    if coords.size == 0:\n        return None, None, None # No barrier found\n\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # Check if all barrier pixels are in the same row\n    if np.all(rows == rows[0]):\n        return 'horizontal', rows[0], barrier_color\n    # Check if all barrier pixels are in the same column\n    elif np.all(cols == cols[0]):\n        return 'vertical', cols[0], barrier_color\n    else:\n        # This case shouldn't happen based on examples (barrier is always a straight line)\n        return None, None, None # Malformed barrier\n\n\ndef find_mobile_color(grid, barrier_color):\n    \"\"\"Finds the color of the mobile pixels.\"\"\"\n    unique_colors = np.unique(grid)\n    for color in unique_colors:\n        if color != 0 and color != barrier_color: # Not white and not barrier\n            return color\n    return None # No mobile color found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    height, width = input_grid.shape\n\n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the barrier line\n    orientation, barrier_index, barrier_color = find_barrier(input_grid)\n\n    if orientation is None:\n        # Handle cases without a clear barrier if necessary,\n        # for now, assume valid input per examples\n        return output_grid # Or return input_grid, or raise error\n\n    # Find the mobile color\n    mobile_color = find_mobile_color(input_grid, barrier_color)\n\n    if mobile_color is None:\n        # Handle cases without mobile pixels if necessary\n        # Copy only the barrier if it exists\n        if barrier_index is not None:\n             if orientation == 'horizontal':\n                 output_grid[barrier_index, :] = barrier_color\n             elif orientation == 'vertical':\n                 output_grid[:, barrier_index] = barrier_color\n        return output_grid\n\n    # Copy the barrier to the output grid\n    if orientation == 'horizontal':\n        output_grid[barrier_index, :] = barrier_color\n    elif orientation == 'vertical':\n        output_grid[:, barrier_index] = barrier_color\n\n    # Process based on barrier orientation\n    if orientation == 'horizontal':\n        # Iterate through each column\n        for c in range(width):\n            # Count mobile pixels below the barrier in this column\n            count = 0\n            for r in range(barrier_index + 1, height):\n                if input_grid[r, c] == mobile_color:\n                    count += 1\n            \n            # Place the counted pixels above the barrier in the output\n            for i in range(count):\n                target_row = barrier_index - 1 - i\n                # Check bounds before placing\n                if target_row >= 0:\n                    output_grid[target_row, c] = mobile_color\n                else:\n                    # Stop if we run out of space above the barrier\n                    break\n\n    elif orientation == 'vertical':\n        # Iterate through each row\n        for r in range(height):\n            # Count mobile pixels to the right of the barrier in this row\n            count = 0\n            for c in range(barrier_index + 1, width):\n                if input_grid[r, c] == mobile_color:\n                    count += 1\n\n            # Place the counted pixels to the right of the barrier in the output\n            for i in range(count):\n                target_col = barrier_index + 1 + i\n                # Check bounds before placing\n                if target_col < width:\n                    output_grid[r, target_col] = mobile_color\n                else:\n                    # Stop if we run out of space to the right\n                    break\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4417,
    "candidates_token_count": 1345,
    "total_token_count": 5762,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.830535,
  "retries": null
}