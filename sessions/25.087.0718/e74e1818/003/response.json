{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nVertically flips horizontal bands of the grid if the pattern within the band is \nnot vertically symmetric. A band is defined as a maximal contiguous set of one \nor more rows where all non-background pixels share the same single color. \nBands are separated by rows containing only background pixels (0) or rows \ncontaining pixels of multiple different non-background colors.\n\"\"\"\n\ndef _get_bands(grid):\n    \"\"\"\n    Identifies maximal vertical bands of uniform non-background color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list[dict]: A list of dictionaries, where each dictionary represents a band \n                    and contains 'color' (int) and 'rows' (list of ints).\n                    Returns an empty list if no bands are found.\n    \"\"\"\n    rows, cols = grid.shape\n    bands = []\n    current_band_color = -1 # -1: no active band, 0: background/mixed row\n    start_row = 0\n    \n    for r in range(rows):\n        # Find unique non-background colors in the current row\n        unique_colors = np.unique(grid[r, :])\n        non_background_colors = unique_colors[unique_colors != 0]\n        \n        current_row_color_type = -1 # Default: mixed colors or error\n        if len(non_background_colors) == 1:\n            current_row_color_type = non_background_colors[0] # Single non-background color\n        elif len(non_background_colors) == 0:\n             current_row_color_type = 0 # Pure background row\n        # else: mixed colors, keep -1\n             \n        # --- State machine for band detection ---\n        if r == 0:\n            # First row initializes the state\n            if current_row_color_type > 0: # Start of a potential band\n                 current_band_color = current_row_color_type\n                 start_row = r\n            # If background/mixed, current_band_color remains -1 (no active band)\n        else:\n            # Subsequent rows\n            if current_band_color > 0: \n                # Currently inside a band of color `current_band_color`\n                if current_row_color_type == current_band_color:\n                    # Row continues the current band, do nothing\n                    pass\n                else: \n                    # Row breaks the current band (different color, background, or mixed)\n                    # Finalize the previous band\n                    bands.append({\"color\": current_band_color, \"rows\": list(range(start_row, r))})\n                    # Check if this row starts a new band\n                    if current_row_color_type > 0:\n                        current_band_color = current_row_color_type\n                        start_row = r\n                    else: # Background or mixed row, reset band state\n                        current_band_color = -1 \n            else: \n                # Not currently in a band (last row was background/mixed or start)\n                if current_row_color_type > 0: # Start a new band\n                    current_band_color = current_row_color_type\n                    start_row = r\n                # else: Still background/mixed, remain outside a band\n\n    # After loop, check if the last rows formed a band that needs to be added\n    if current_band_color > 0:\n        bands.append({\"color\": current_band_color, \"rows\": list(range(start_row, rows))})\n        \n    return bands\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by identifying uniform color vertical bands and \n    flipping the rows within a band if the band's pattern is not vertically \n    symmetric.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    \n    # Initialize output_grid as a copy of the input grid.\n    # Modifications will be applied based on band symmetry.\n    output_grid = np.copy(input_grid)\n    \n    # Identify all maximal vertical color bands.\n    bands = _get_bands(input_grid)\n    \n    # Iterate through each identified band.\n    for band in bands:\n        # Get the row indices for the band.\n        rows = band[\"rows\"]\n        if not rows: # Skip if somehow an empty band was generated\n             continue\n             \n        min_row = rows[0]\n        max_row = rows[-1]\n        \n        # Extract the grid slice corresponding to the band's rows.\n        input_slice = input_grid[min_row : max_row + 1, :]\n        \n        # Check if the extracted slice is vertically symmetric.\n        # A slice is symmetric if it's identical to its vertically flipped version.\n        # Note: Single row slices are always symmetric.\n        flipped_slice_for_check = np.flipud(input_slice)\n        is_symmetric = np.array_equal(input_slice, flipped_slice_for_check)\n        \n        # If the slice is NOT vertically symmetric, flip it in the output grid.\n        if not is_symmetric:\n            # Use the already computed flipped slice\n            output_grid[min_row : max_row + 1, :] = flipped_slice_for_check\n            \n        # If the slice IS vertically symmetric, do nothing, as the output_grid \n        # already contains the original (unflipped) rows from the initial copy.\n            \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13176,
    "candidates_token_count": 1317,
    "total_token_count": 14493,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.584023,
  "retries": null
}