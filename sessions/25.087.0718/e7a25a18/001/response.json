{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the largest, single-colored, non-white rectangular frame in the input grid.\n2. Crop the input grid to the boundaries of this frame. The result forms the initial output grid.\n3. Identify all distinct, non-white, non-frame colored objects located strictly inside the frame in the input grid. Note their colors and relative positions (e.g., top-left, top-right, bottom-left, bottom-right quadrants).\n4. Divide the area strictly inside the frame (the internal area) into a grid of equally sized regions matching the number and relative arrangement of the internal objects (e.g., 4 quadrants for 4 objects).\n5. Fill each internal region in the output grid with the color of the corresponding internal object from the input grid, preserving the original frame border.\n\"\"\"\n\ndef find_objects(grid, colors_to_find=None, ignore_colors=None, min_size=1):\n    \"\"\"\n    Finds contiguous objects of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): Set of colors to look for. If None, finds all colors.\n        ignore_colors (set, optional): Set of colors to ignore. Defaults to {0} (white).\n        min_size (int): Minimum number of pixels for an object to be counted.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'pixels' (set of (r, c) tuples), and 'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    if ignore_colors is None:\n        ignore_colors = {0}\n    \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if not visited[r, c] and color not in ignore_colors and \\\n               (colors_to_find is None or color in colors_to_find):\n                \n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if len(obj_pixels) >= min_size:\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n                    \n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef is_rectangular(obj):\n    \"\"\"Checks if an object perfectly fills its bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    expected_size = (max_r - min_r + 1) * (max_c - min_c + 1)\n    return len(obj['pixels']) == expected_size\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid)\n    \n    # 1. Identify the Frame\n    # Find all non-white objects\n    all_objects = find_objects(input_np, ignore_colors={0})\n    \n    # Assume the frame is the largest object by pixel count\n    if not all_objects:\n        # Handle cases with no non-white objects if necessary\n        return input_np.tolist() # Or return an empty grid, based on expected behavior\n\n    frame_obj = max(all_objects, key=lambda obj: len(obj['pixels']))\n    frame_color = frame_obj['color']\n    frame_bbox = frame_obj['bbox']\n    min_r, min_c, max_r, max_c = frame_bbox\n    \n    # 2. Crop to Frame\n    # Create the output grid by slicing the input grid based on the frame's bbox\n    output_grid = input_np[min_r : max_r + 1, min_c : max_c + 1].copy()\n    out_h, out_w = output_grid.shape\n\n    # 3. Identify Internal Objects\n    internal_objects = []\n    # Define the inner area boundaries (relative to the input grid)\n    inner_min_r, inner_min_c = min_r + 1, min_c + 1\n    inner_max_r, inner_max_c = max_r - 1, max_c - 1\n\n    # Find objects strictly inside the frame\n    # We iterate through potential internal pixels and use find_objects on a masked grid or check coordinates\n    for r in range(inner_min_r, inner_max_r + 1):\n         for c in range(inner_min_c, inner_max_c + 1):\n             color = input_np[r,c]\n             if color != 0 and color != frame_color:\n                 # Check if this pixel belongs to an already found internal object\n                 is_part_of_existing = False\n                 for obj in internal_objects:\n                     if (r, c) in obj['pixels']:\n                         is_part_of_existing = True\n                         break\n                 if not is_part_of_existing:\n                     # Find the full object this pixel belongs to\n                     # Use find_objects restricted to the potential color and a starting point\n                     # Or simpler: reuse all_objects found earlier\n                     found = False\n                     for obj in all_objects:\n                         if obj['color'] == color and (r, c) in obj['pixels']:\n                            # Check if the object is strictly inside the frame boundaries\n                            obj_min_r, obj_min_c, obj_max_r, obj_max_c = obj['bbox']\n                            if obj_min_r >= inner_min_r and obj_min_c >= inner_min_c and \\\n                               obj_max_r <= inner_max_r and obj_max_c <= inner_max_c:\n                                internal_objects.append(obj)\n                                found = True\n                                break\n                     # This logic might slightly overcomplicate if find_objects is efficient\n                     # Alternative: filter all_objects directly\n    \n    # Refined way to find internal objects by filtering all_objects\n    internal_objects = []\n    inner_min_r, inner_min_c = min_r + 1, min_c + 1\n    inner_max_r, inner_max_c = max_r - 1, max_c - 1    \n    for obj in all_objects:\n         if obj['color'] != frame_color:\n             obj_min_r, obj_min_c, obj_max_r, obj_max_c = obj['bbox']\n             # Check if the object's bounding box is strictly within the inner frame area\n             if obj_min_r >= inner_min_r and obj_min_c >= inner_min_c and \\\n                obj_max_r <= inner_max_r and obj_max_c <= inner_max_c:\n                 internal_objects.append(obj)\n\n\n    # 4. Define Internal Regions (Assuming 4 quadrants based on examples)\n    if len(internal_objects) == 4:\n        # Calculate center of the *input* inner area to classify object positions\n        center_r = (inner_min_r + inner_max_r) / 2.0\n        center_c = (inner_min_c + inner_max_c) / 2.0\n        \n        quadrant_colors = {'tl': 0, 'tr': 0, 'bl': 0, 'br': 0} # Default to black/0 if unassigned? Examples use source colors.\n\n        for obj in internal_objects:\n            # Use the center of the object's bounding box for position\n            obj_center_r = (obj['bbox'][0] + obj['bbox'][2]) / 2.0\n            obj_center_c = (obj['bbox'][1] + obj['bbox'][3]) / 2.0\n            \n            if obj_center_r < center_r and obj_center_c < center_c:\n                quadrant_colors['tl'] = obj['color']\n            elif obj_center_r < center_r and obj_center_c >= center_c:\n                quadrant_colors['tr'] = obj['color']\n            elif obj_center_r >= center_r and obj_center_c < center_c:\n                quadrant_colors['bl'] = obj['color']\n            elif obj_center_r >= center_r and obj_center_c >= center_c:\n                quadrant_colors['br'] = obj['color']\n\n        # 5. Fill Regions in the Output Grid\n        # Inner area dimensions in the output grid\n        out_inner_h = (inner_max_r - inner_min_r + 1)\n        out_inner_w = (inner_max_c - inner_min_c + 1)\n        \n        # Top-left corner of inner area in output grid is (1, 1)\n        out_center_r = out_inner_h / 2.0 \n        out_center_c = out_inner_w / 2.0\n\n        for r_out in range(1, out_h - 1): # Iterate through inner rows of output grid\n            for c_out in range(1, out_w - 1): # Iterate through inner columns of output grid\n                # Determine which quadrant this output pixel (r_out, c_out) falls into\n                # Coordinates relative to the top-left of the inner area (which is at (1,1))\n                rel_r = r_out - 1 \n                rel_c = c_out - 1\n                \n                if rel_r < out_center_r and rel_c < out_center_c:\n                    output_grid[r_out, c_out] = quadrant_colors['tl']\n                elif rel_r < out_center_r and rel_c >= out_center_c:\n                    output_grid[r_out, c_out] = quadrant_colors['tr']\n                elif rel_r >= out_center_r and rel_c < out_center_c:\n                    output_grid[r_out, c_out] = quadrant_colors['bl']\n                elif rel_r >= out_center_r and rel_c >= out_center_c:\n                    output_grid[r_out, c_out] = quadrant_colors['br']\n                    \n    # Handle cases with different numbers of internal objects if needed\n    elif len(internal_objects) == 1:\n         # If only one object, fill the entire inner area with its color\n         single_color = internal_objects[0]['color']\n         for r_out in range(1, out_h - 1):\n             for c_out in range(1, out_w - 1):\n                 output_grid[r_out, c_out] = single_color\n                 \n    # Add more conditions here if other numbers/arrangements of internal objects are possible\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3461,
    "candidates_token_count": 2940,
    "total_token_count": 6401,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.723849,
  "retries": null
}