{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis transformation identifies vertical colored lines in the odd-numbered columns \non the left side of the input grid and uses their colors to paint corresponding \nazure shapes found on the right side.\n\n1.  Create a new output grid of the same dimensions as the input, filled with white (0).\n2.  Scan the input grid's odd-numbered columns (1, 3, 5, ...) from left to right.\n    Collect the non-white color found in each of these columns into an ordered list (`color_palette`).\n3.  Identify all distinct contiguous shapes composed of azure pixels (8) in the input grid.\n4.  Sort these azure shapes based on their horizontal position (leftmost pixel).\n5.  Iterate through the sorted azure shapes. For the Nth shape, paint its pixels in \n    the output grid using the Nth color from the `color_palette`.\n6.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates\n              of the pixels belonging to one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited yet,\n            # start a Breadth-First Search (BFS) to find the connected object.\n            if grid[r, c] == color and not visited[r, c]:\n                current_object_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if the neighbor is within bounds, has the target color,\n                        # and hasn't been visited.\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            current_object_coords.add((nr, nc))\n                \n                # Add the coordinates of the found object to the list of objects.\n                if current_object_coords:\n                    objects.append(current_object_coords)\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replacing azure shapes with colors derived from\n    vertical lines on the left.\n    \"\"\"\n    # Initialize output grid with the same shape as input, filled with white (0).\n    output_grid = np.zeros_like(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- Step 1: Extract the color palette from vertical lines ---\n    color_palette = []\n    # Iterate through odd-numbered columns (index 1, 3, 5, ...)\n    for c in range(1, cols, 2):\n        # Get all pixels in the current column\n        col_data = input_grid[:, c]\n        # Find non-white colors in this column\n        non_white_colors = col_data[col_data != 0]\n        # If a non-white color exists, add the first one found to the palette\n        # (Assuming each line column has a single dominant color)\n        if len(non_white_colors) > 0:\n            color_palette.append(non_white_colors[0])\n        # Stop if we reach a column with no colored line or only white pixels\n        elif np.all(col_data == 0): \n             # Optimization: Assume lines stop when an empty odd column is found\n             # This might need adjustment if lines can reappear after a gap.\n             # Based on examples, this seems safe.\n             pass # Continue checking other odd columns just in case, but could break too.\n\n    # --- Step 2: Find all azure (color 8) shapes ---\n    azure_shapes_coords = find_objects(input_grid, 8)\n\n    # --- Step 3: Sort azure shapes by horizontal position (leftmost point) ---\n    if azure_shapes_coords: # Proceed only if azure shapes were found\n        shape_min_cols = []\n        for shape in azure_shapes_coords:\n            # Find the minimum column index for each shape\n            min_col = min(c for r, c in shape)\n            shape_min_cols.append({'min_col': min_col, 'coords': shape})\n\n        # Sort the shapes based on their minimum column index\n        shape_min_cols.sort(key=lambda x: x['min_col'])\n        sorted_shapes = [item['coords'] for item in shape_min_cols]\n\n        # --- Step 4: Paint the shapes onto the output grid ---\n        # Iterate through the sorted shapes and assign colors from the palette\n        for i, shape_coords in enumerate(sorted_shapes):\n            # Ensure we have a color in the palette for this shape index\n            if i < len(color_palette):\n                paint_color = color_palette[i]\n                # Color each pixel of the shape in the output grid\n                for r, c in shape_coords:\n                    # Ensure coordinates are within bounds (should be, but safe check)\n                    if 0 <= r < rows and 0 <= c < cols:\n                        output_grid[r, c] = paint_color\n            # else: If there are more shapes than colors, they remain white (0)\n\n    # Return the final grid with colored shapes\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3611,
    "candidates_token_count": 1413,
    "total_token_count": 5024,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.695262,
  "retries": null
}