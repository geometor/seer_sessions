
## train_1

**input:**
```
7 0 0 0 0 6 0 0 0 0
0 0 9 0 0 0 0 7 0 0
0 0 0 0 5 0 0 0 0 0
6 0 0 5 5 5 0 6 0 9
0 0 5 5 5 5 5 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 0 5 0 0 0 6 0
9 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 9 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 6 6 6 0 0 0 0
0 0 6 6 6 6 6 0 0 0
0 0 0 6 6 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 9 0 0 0 0 0 0 0 4
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 9 0 0
4 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 2
0 0 9 0 0 0 0 0 0 0
2 0 0 0 0 0 0 4 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 9 9 9 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
8 0 4 0 0 0 3 0 4 0
0 0 0 0 0 0 0 0 0 0
3 0 0 0 5 0 0 8 0 0
0 0 4 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 4
0 8 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 8 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 8 0 0 3 0 0 4 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 4 0 0 0 0 0 0 4 0
0 0 0 0 0 0 3 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3
0 0 0 5 5 5 5 0 0 0
3 0 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0
0 4 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 6
0 3 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 6 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception of Task Elements**

1.  **Input Grid Structure:** Each input grid contains multiple colored pixels on a white (0) background. There is consistently one larger, contiguous object composed of gray (5) pixels. Additionally, there are several scattered, single pixels of various other colors (non-white, non-gray).
2.  **Output Grid Structure:** Each output grid contains only one object, which occupies the exact same positions as the large gray object from the corresponding input grid. All other pixels are white (0). The color of this single object in the output is *not* gray.
3.  **Transformation Goal:** The core task appears to be identifying the main gray object, determining a new color for it based on the nearby scattered pixels, and then redrawing only that object in the new color, removing all other non-background pixels.
4.  **Color Selection Logic:** The color used to repaint the gray object in the output seems to be derived from one of the scattered pixels in the input. By comparing inputs and outputs:
    *   Train 1: Scattered pixels include magenta (6), maroon (9), orange (7). Output object is magenta (6).
    *   Train 2: Scattered pixels include maroon (9), red (2), yellow (4). Output object is maroon (9).
    *   Train 3: Scattered pixels include azure (8), yellow (4), green (3). Output object is yellow (4).
    *   Train 4: Scattered pixels include yellow (4), green (3), magenta (6). Output object is magenta (6).
    *   Train 5: Scattered pixels include yellow (4), magenta (6). Output object is yellow (4).
5.  **Proximity Rule:** The selection of the output color likely depends on proximity. The scattered pixel whose color is used in the output appears to be the "closest" to the central gray object. "Closest" is likely measured by Manhattan distance (sum of row and column differences) between a scattered pixel and the nearest pixel of the gray object.
6.  **Tie-breaking:** In Train 2, both maroon (9) and red (2) pixels seem to have the same minimum distance (2) to the gray object. The output uses maroon (9). This suggests that if multiple colors share the minimum distance, the color with the highest numerical value is chosen.

**YAML Fact Documentation**


```yaml
task_description: Recolor the largest contiguous object based on the color of the nearest non-background, non-object pixel.

definitions:
  - &background_color 0 # white
  - &target_object_input_color 5 # gray
  - &target_object
    description: The largest contiguous block of non-background pixels in the input. In all examples, this object's color is gray (5).
    properties:
      - contiguity: forms a single connected component (adjacency includes diagonals).
      - size: largest by pixel count compared to other non-background components.
  - &source_pixels
    description: All pixels in the input grid that are not the background color and do not belong to the target_object.
    properties:
      - color: Varies across examples (e.g., magenta, maroon, orange, red, yellow, azure, green).
      - distribution: Scattered across the grid, often appearing as single pixels.
  - &output_object
    description: The single object present in the output grid.
    properties:
      - shape: Identical shape and position as the target_object from the input.
      - color: Determined by a specific rule involving source_pixels.

transformation_rule:
  - step: 1
    action: identify_target_object
    description: Find the largest contiguous block of non-background pixels in the input grid. Note its constituent pixel coordinates and original color (always gray=5 in examples).
  - step: 2
    action: identify_source_pixels
    description: Find all other non-background pixels in the input grid (those not part of the target_object). Note their coordinates and colors.
  - step: 3
    action: calculate_min_distances
    description: For each unique color `C` found among the source_pixels, calculate the minimum Manhattan distance from any source pixel of color `C` to any pixel of the target_object.
    details:
      - Manhattan distance between (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.
      - Find the minimum distance over all pairs of (source_pixel_of_color_C, target_object_pixel).
  - step: 4
    action: determine_replacement_color
    description: Identify the source color(s) that yielded the overall minimum Manhattan distance in step 3.
    tie_breaking: If multiple source colors share the same minimum distance, select the color with the highest numerical value. This is the replacement_color.
  - step: 5
    action: generate_output
    description: Create a new grid of the same dimensions as the input, filled with the background_color (0).
  - step: 6
    action: paint_output_object
    description: For every pixel coordinate that belonged to the target_object in the input, set the color of the corresponding pixel in the output grid to the replacement_color determined in step 4.

examples_summary:
  - train_1: Target=gray(5), Sources=[magenta(6), maroon(9), orange(7)]. Min dist for 6 is 2. Output=magenta(6).
  - train_2: Target=gray(5), Sources=[maroon(9), red(2), yellow(4)]. Min dist for 9 and 2 is 2. Tie-break: 9 > 2. Output=maroon(9).
  - train_3: Target=gray(5), Sources=[azure(8), yellow(4), green(3)]. Min dist for 4 is 2. Output=yellow(4).
  - train_4: Target=gray(5), Sources=[yellow(4), green(3), magenta(6)]. Min dist for 6 is 2. Output=magenta(6).
  - train_5: Target=gray(5), Sources=[yellow(4), magenta(6)]. Min dist for 4 is 3. Output=yellow(4).

```


**Natural Language Program**

1.  **Identify the Target Object:** Locate the largest contiguous group of connected non-white pixels in the input grid. Record the locations (coordinates) of all pixels belonging to this object. (In the provided examples, this object is always gray, color 5).
2.  **Identify Source Pixels:** Locate all other non-white pixels in the input grid that are *not* part of the Target Object identified in step 1. Record their locations and colors.
3.  **Calculate Minimum Distances by Color:** For each unique color found among the Source Pixels:
    a.  Consider all Source Pixels having that specific color.
    b.  For each of these Source Pixels, find the shortest Manhattan distance to *any* pixel belonging to the Target Object.
    c.  Keep track of the overall minimum distance found for this specific color.
4.  **Select the Winning Color:** Compare the minimum distances calculated for each unique Source Color in step 3.
    a.  Find the smallest distance value among them.
    b.  Identify all Source Colors that achieved this smallest distance.
    c.  If only one color achieved the minimum distance, select that color.
    d.  If multiple colors share the minimum distance, select the color with the highest numerical value among them. This is the "Replacement Color".
5.  **Construct the Output:** Create a new grid with the same dimensions as the input grid, initially filled entirely with the white background color (0).
6.  **Paint the Output Object:** For each pixel location recorded as part of the Target Object in step 1, set the color of the corresponding pixel in the new output grid to the Replacement Color determined in step 4. Leave all other pixels as white.
