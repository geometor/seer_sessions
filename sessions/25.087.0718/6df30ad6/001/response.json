{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\n\n\"\"\"\nIdentifies the largest contiguous object of color gray (5) in the input grid.\nIdentifies all other non-background (non-0) pixels as source pixels.\nCalculates the minimum Manhattan distance from each unique source pixel color to the gray object.\nDetermines the replacement color by finding the source color(s) with the overall minimum distance.\nIf multiple colors share the minimum distance, the one with the highest numerical value is chosen.\nCreates an output grid containing only the original gray object's shape, but colored with the determined replacement color. All other pixels are background (0).\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to treat as background/ignore.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, set_of_coords).\n              Returns an empty list if the grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    height, width = grid.shape\n    visited = set()\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if (r, c) not in visited and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                coords = set()\n                queue = deque([(r, c)])\n                visited.add((r, c))\n                current_object_coords = set()\n\n                while queue:\n                    row, col = queue.popleft()\n                    current_object_coords.add((row, col))\n\n                    # Check neighbors (8-directional, including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               (nr, nc) not in visited and grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                queue.append((nr, nc))\n                \n                if current_object_coords:\n                     objects.append((color, current_object_coords))\n                     \n    return objects\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points (r, c).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the described rule.\n    \n    1. Finds the target gray (5) object.\n    2. Finds source pixels (non-background, non-target).\n    3. Calculates min distances from source colors to target object.\n    4. Determines replacement color based on min distance (highest value tie-breaker).\n    5. Creates output grid with target shape filled with replacement color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    if input_np.size == 0:\n        return []\n        \n    height, width = input_np.shape\n    background_color = 0\n    target_object_input_color = 5\n    \n    # Find all non-background objects\n    objects = find_objects(input_np, ignore_color=background_color)\n\n    # Identify the target object (must be color 5)\n    # If multiple color 5 objects exist, choose the largest one.\n    target_object_coords = set()\n    target_candidates = []\n    for color, coords in objects:\n        if color == target_object_input_color:\n            target_candidates.append(coords)\n\n    if not target_candidates:\n        # No gray object found, return an empty grid\n        return np.zeros_like(input_np).tolist()\n\n    # Select the largest gray object if multiple exist (unlikely based on examples)\n    target_object_coords = max(target_candidates, key=len)\n\n    # Identify source pixels (not background, not target object)\n    source_pixels = []\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != background_color and (r, c) not in target_object_coords:\n                source_pixels.append({'r': r, 'c': c, 'color': color})\n\n    if not source_pixels:\n         # No source pixels found, the rule cannot be applied. Return empty grid.\n        return np.zeros_like(input_np).tolist()\n\n    # Calculate minimum distances from each source color to the target object\n    min_distances_by_color = defaultdict(lambda: float('inf'))\n    unique_source_colors = sorted(list(set(p['color'] for p in source_pixels)), reverse=True) # Sort high to low for potential tie-break pre-computation, though direct max() is used later\n\n    for color in unique_source_colors:\n        min_dist_for_this_color = float('inf')\n        source_pixels_of_this_color = [p for p in source_pixels if p['color'] == color]\n        \n        # Iterate through source pixels of the current color\n        for sp in source_pixels_of_this_color:\n            sp_coord = (sp['r'], sp['c'])\n            min_dist_for_sp = float('inf')\n            # Find the closest point in the target object to this source pixel\n            for tp_coord in target_object_coords:\n                 dist = manhattan_distance(sp_coord, tp_coord)\n                 min_dist_for_sp = min(min_dist_for_sp, dist)\n                 # Optimization: if distance is 1, this is the minimum possible for this sp\n                 if min_dist_for_sp == 1:\n                     break \n            # Update the minimum distance found *for this color*\n            min_dist_for_this_color = min(min_dist_for_this_color, min_dist_for_sp)\n            # Optimization: if the minimum distance for this color is 1, no need to check other sp's of this color\n            if min_dist_for_this_color == 1:\n                 break\n\n        min_distances_by_color[color] = min_dist_for_this_color\n\n    # Determine the winning replacement color\n    if not min_distances_by_color:\n        # Should not happen if source_pixels exist, but as a safeguard\n        return np.zeros_like(input_np).tolist()\n\n    # Find the minimum distance achieved across all colors\n    overall_min_distance = min(min_distances_by_color.values())\n\n    # Find all colors that achieved this minimum distance\n    candidate_colors = [\n        color for color, dist in min_distances_by_color.items()\n        if dist == overall_min_distance\n    ]\n\n    # Apply tie-breaking rule: select the color with the highest numerical value\n    replacement_color = max(candidate_colors)\n\n    # Construct the output grid\n    output_np = np.full_like(input_np, background_color)\n    for r, c in target_object_coords:\n         # Ensure coordinates are within bounds (should be, but safety check)\n         if 0 <= r < height and 0 <= c < width:\n             output_np[r, c] = replacement_color\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4953,
    "candidates_token_count": 1774,
    "total_token_count": 6727,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.015393,
  "retries": null
}