{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis function transforms an input grid based on the positions of two gray pixels.\n1. Find the coordinates of the two gray (5) pixels.\n2. Identify which gray pixel is the 'anchor' (part of a larger connected component of non-white pixels) and which is the 'target' (isolated or part of a smaller component, usually size 1). The connected component containing the anchor is the 'source object'. Connectivity is defined by adjacent non-white (0) pixels (including diagonals - 8-way connectivity).\n3. Calculate the translation vector (row_offset, col_offset) required to move from the anchor point to the target point.\n4. Create a copy of the input grid to serve as the output grid.\n5. Iterate through each pixel belonging to the source object (identified in step 2).\n6. For each pixel in the source object *except* the anchor gray pixel:\n    a. Calculate its new destination coordinates by adding the translation vector to its original coordinates.\n    b. If the destination coordinates are within the grid bounds, update the pixel at the destination coordinates in the output grid with the color of the current source object pixel. This overwrites any existing pixel at the destination.\n7. Return the modified output grid.\n\"\"\"\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all pixels of a specific color in the grid.\"\"\"\n    coords = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] == color:\n                coords.append((r, c))\n    return coords\n\ndef find_connected_component(grid, start_coord, background_color=0):\n    \"\"\"\n    Finds the connected component of non-background pixels including start_coord using 8-way connectivity (BFS).\n    Returns a set of (row, col) tuples belonging to the component.\n    \"\"\"\n    if grid[start_coord] == background_color:\n        return set()\n\n    height, width = grid.shape\n    component = set()\n    queue = deque([start_coord])\n    visited = set([start_coord])\n\n    while queue:\n        r, c = queue.popleft()\n        if grid[r, c] != background_color:\n            component.add((r, c))\n\n            # Check 8 neighbors (Moore neighborhood)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue # Skip self\n\n                    nr, nc = r + dr, c + dc\n\n                    # Check bounds\n                    if 0 <= nr < height and 0 <= nc < width:\n                        neighbor_coord = (nr, nc)\n                        # Check if not visited and not background\n                        if neighbor_coord not in visited and grid[nr, nc] != background_color:\n                            visited.add(neighbor_coord)\n                            queue.append(neighbor_coord)\n                            \n    # Ensure the starting coordinate itself (even if isolated and non-background) is included if found\n    if grid[start_coord] != background_color:\n         component.add(start_coord)\n            \n    return component\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by copying a source object defined by an anchor gray pixel\n    to a location defined by a target gray pixel.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    gray_color = 5\n    background_color = 0\n\n    # 1. Find the coordinates of the two gray pixels.\n    gray_pixels = find_pixels(input_grid, gray_color)\n    if len(gray_pixels) != 2:\n        # Handle error or unexpected input: assume no transformation if not exactly 2 gray pixels\n        # Or return input grid? Based on task structure, assume 2 gray pixels always exist.\n        # For robustness, let's return the input copy if the assumption fails.\n        print(f\"Warning: Expected 2 gray pixels, found {len(gray_pixels)}. Returning input copy.\")\n        return output_grid.tolist()\n\n    p1, p2 = gray_pixels[0], gray_pixels[1]\n\n    # 2. Identify Anchor, Target, and Source Object\n    comp1 = find_connected_component(input_grid, p1, background_color)\n    comp2 = find_connected_component(input_grid, p2, background_color)\n\n    anchor_point = None\n    target_point = None\n    source_object_coords = set()\n\n    # The anchor is the gray pixel belonging to the larger component.\n    # If components are same size (e.g., both isolated), the logic might need refinement,\n    # but examples suggest one is clearly part of a larger shape.\n    if len(comp1) > len(comp2):\n        anchor_point = p1\n        target_point = p2\n        source_object_coords = comp1\n    elif len(comp2) > len(comp1):\n        anchor_point = p2\n        target_point = p1\n        source_object_coords = comp2\n    else: # len(comp1) == len(comp2), e.g., both size 1\n          # This case doesn't appear in training data. Assume the first found is anchor arbitrarily?\n          # Or assume the one with lower row/col index? Let's default to p1 as anchor.\n          # More robust would be needed if this case appears.\n        anchor_point = p1\n        target_point = p2\n        source_object_coords = comp1 # component only contains the anchor itself in this case\n        print(f\"Warning: Ambiguous anchor/target (components size {len(comp1)}). Defaulting {p1} to anchor.\")\n\n\n    # 3. Calculate the translation vector\n    dr = target_point[0] - anchor_point[0]\n    dc = target_point[1] - anchor_point[1]\n\n    # 4. Initialize Output Grid (already done with np.copy)\n\n    # 5. & 6. Iterate through source object, translate, and draw (excluding anchor)\n    for r, c in source_object_coords:\n        # Skip the anchor point itself\n        if (r, c) == anchor_point:\n            continue\n\n        source_color = input_grid[r, c]\n\n        # 6a. Calculate destination coordinates\n        dest_r, dest_c = r + dr, c + dc\n\n        # 6b. Check bounds\n        if 0 <= dest_r < height and 0 <= dest_c < width:\n            # 6c. Update output grid\n            output_grid[dest_r, dest_c] = source_color\n            \n    # Handle the case where the target marker might need explicit clearing if nothing lands on it.\n    # The description said \"Clear Target Marker\", but overwriting seems to be the actual behaviour.\n    # If the target point wasn't overwritten by the copied object, should it become white?\n    # Let's test. In train_2 output, the target gray pixel position (8,7) becomes white (0).\n    # It seems the intended logic might be: the target marker *location* is the destination for the anchor *location*,\n    # but the marker itself disappears. Overwriting achieves this if part of the object lands there.\n    # If not, it should perhaps be cleared. Let's re-add the clearing step *before* copying.\n    \n    # Re-evaluate: The target gray pixel is *part of the input*. The copy operation *overwrites* pixels\n    # in the *output* grid (which starts as a copy of input). If nothing is copied onto the\n    # original target marker location, it will retain its original gray color in the output.\n    # Example 2 output shows the location (8,7) which was gray(5) becomes white(0).\n    # This implies the target marker *is* removed/overwritten. If a non-anchor part of the\n    # source object lands there, it gets that color. If the *anchor* point lands there (offset=0),\n    # it should become white? No, anchor isn't copied. If *nothing* lands there, it should become white.\n    # Let's try clearing the target point in the output *after* the copy loop IF it wasn't overwritten.\n\n    # Simpler approach: Clear the target marker *before* copying.\n    output_grid_cleared = np.copy(input_grid)\n    output_grid_cleared[target_point[0], target_point[1]] = background_color # Clear the target marker\n\n    for r, c in source_object_coords:\n        if (r, c) == anchor_point:\n            continue\n        source_color = input_grid[r, c]\n        dest_r, dest_c = r + dr, c + dc\n        if 0 <= dest_r < height and 0 <= dest_c < width:\n            # Draw onto the grid where the target marker was already cleared\n            output_grid_cleared[dest_r, dest_c] = source_color\n\n    # 7. Return the final grid\n    return output_grid_cleared.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3789,
    "candidates_token_count": 2154,
    "total_token_count": 5943,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.076266,
  "retries": null
}