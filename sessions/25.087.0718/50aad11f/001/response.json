{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport math\n\n\"\"\"\nIdentify single-pixel 'markers' (not white 0 or magenta 6) and magenta (6) objects in the input grid. \nAssociate each marker with the geometrically closest magenta object. \nFor each associated pair, extract the pattern within the magenta object's minimal 4x4 bounding box (using the top-left corner of the minimal bounding box as the anchor, padding with 0 if necessary).\nRecolor the extracted 4x4 pattern by changing magenta (6) pixels to the marker's color.\nSort these recolored 4x4 patterns based on the horizontal position (column index) of their original markers.\nConcatenate the sorted patterns horizontally to form the output grid.\n\"\"\"\n\ndef find_markers(grid):\n    \"\"\"Finds single pixels that are not background (0) or magenta (6).\"\"\"\n    markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and color != 6:\n                # Check if it's isolated (surrounded by 0 or 6, or grid boundary)\n                # Although the examples show single pixels, let's just find non-0/6 colors for now.\n                # The logic seems robust even if markers aren't strictly single pixels.\n                markers.append({'color': color, 'pos': (r, c)})\n    return markers\n\ndef find_magenta_objects(grid):\n    \"\"\"Finds connected components of magenta (6) pixels.\"\"\"\n    magenta_mask = grid == 6\n    labeled_array, num_features = label(magenta_mask)\n    \n    # find_objects returns slices, convert them to coordinates\n    objects_slices = find_objects(labeled_array)\n    objects_coords = []\n    \n    if num_features > 0:\n        for i in range(1, num_features + 1):\n            coords = np.argwhere(labeled_array == i)\n            if coords.size > 0:\n                 # Store as list of (row, col) tuples\n                objects_coords.append(coords.tolist())\n                \n    return objects_coords # List of lists, each inner list contains [row, col] pairs for an object\n\ndef get_bounding_box(obj_coords):\n    \"\"\"Calculates the minimal bounding box for a list of coordinates.\"\"\"\n    if not obj_coords:\n        return None\n    rows = [coord[0] for coord in obj_coords]\n    cols = [coord[1] for coord in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef calculate_min_distance(marker_pos, obj_coords):\n    \"\"\"Calculates the minimum Euclidean distance between a marker and any pixel of an object.\"\"\"\n    min_dist_sq = float('inf')\n    marker_r, marker_c = marker_pos\n    for r, c in obj_coords:\n        dist_sq = (marker_r - r)**2 + (marker_c - c)**2\n        if dist_sq < min_dist_sq:\n            min_dist_sq = dist_sq\n    return math.sqrt(min_dist_sq)\n\ndef extract_and_recolor_4x4_pattern(grid, obj_coords, marker_color):\n    \"\"\"Extracts a 4x4 pattern based on the object's bounding box and recolors it.\"\"\"\n    if not obj_coords:\n        return np.zeros((4, 4), dtype=int)\n\n    min_r, min_c, _, _ = get_bounding_box(obj_coords)\n    \n    # Define the 4x4 extraction area starting from the top-left of the bounding box\n    pattern = np.zeros((4, 4), dtype=int)\n    \n    # Copy the relevant part of the input grid into the 4x4 pattern\n    max_extract_r = min(grid.shape[0], min_r + 4)\n    max_extract_c = min(grid.shape[1], min_c + 4)\n    \n    for r_in in range(min_r, max_extract_r):\n        for c_in in range(min_c, max_extract_c):\n            r_out = r_in - min_r\n            c_out = c_in - min_c\n            \n            color = grid[r_in, c_in]\n            # Only copy magenta pixels or background within the *actual* object coords\n            # Check if (r_in, c_in) is part of the object\n            is_object_pixel = False\n            for obj_r, obj_c in obj_coords:\n                if obj_r == r_in and obj_c == c_in:\n                    is_object_pixel = True\n                    break\n\n            if is_object_pixel and color == 6:\n                pattern[r_out, c_out] = marker_color # Recolor magenta\n            elif is_object_pixel: # If part of object but not magenta (shouldn't happen?)\n                 pattern[r_out, c_out] = 0 # Treat as background maybe? Or keep original? Let's use 0.\n            # else: keep pattern[r_out, c_out] = 0 (background)\n            # Refined logic: Copy everything within the 4x4 box, then recolor ONLY the magenta pixels\n            \n    # Alternative simpler logic: extract the 4x4 box directly, then recolor\n    pattern_direct = np.zeros((4, 4), dtype=int)\n    input_rows, input_cols = grid.shape\n    for r_pat in range(4):\n        for c_pat in range(4):\n             r_in = min_r + r_pat\n             c_in = min_c + c_pat\n             if 0 <= r_in < input_rows and 0 <= c_in < input_cols:\n                 color = grid[r_in, c_in]\n                 if color == 6:\n                     # Check if this specific magenta pixel belongs to *this* object\n                     # This check prevents grabbing parts of other nearby magenta objects\n                     is_correct_object_pixel = False\n                     for obj_r, obj_c in obj_coords:\n                         if obj_r == r_in and obj_c == c_in:\n                             is_correct_object_pixel = True\n                             break\n                     if is_correct_object_pixel:\n                           pattern_direct[r_pat, c_pat] = marker_color\n                 # else: leave as 0 (background)\n\n    return pattern_direct\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules:\n    1. Find markers and magenta objects.\n    2. Associate markers with the closest magenta object.\n    3. Extract 4x4 patterns based on object bounding boxes.\n    4. Recolor patterns using marker colors.\n    5. Sort patterns by marker column index.\n    6. Concatenate patterns horizontally.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Find markers and magenta objects\n    markers = find_markers(input_grid_np)\n    magenta_objects = find_magenta_objects(input_grid_np)\n    \n    if not markers or not magenta_objects:\n        # Handle cases with no markers or no magenta objects if necessary\n        # Based on examples, assume there's always at least one pair\n        # Return empty or based on specific requirements if needed\n        # For now, let's assume valid inputs based on examples.\n        # Determining output size might be tricky here. Let's default to 4x0?\n         return np.zeros((4, 0), dtype=int) # Match height 4 assumption\n\n    # 2. Associate markers with closest magenta objects\n    associations = []\n    for marker in markers:\n        min_dist = float('inf')\n        closest_obj = None\n        for obj_coords in magenta_objects:\n            if not obj_coords: continue # Skip empty objects if any\n            dist = calculate_min_distance(marker['pos'], obj_coords)\n            if dist < min_dist:\n                min_dist = dist\n                closest_obj = obj_coords\n                \n        if closest_obj:\n            associations.append({\n                'marker_color': marker['color'],\n                'marker_pos': marker['pos'],\n                'object_coords': closest_obj\n            })\n\n    # 3. & 4. Extract and recolor patterns for each association\n    processed_patterns = []\n    for assoc in associations:\n        pattern = extract_and_recolor_4x4_pattern(\n            input_grid_np, \n            assoc['object_coords'], \n            assoc['marker_color']\n        )\n        # Store pattern along with marker's column for sorting\n        processed_patterns.append({\n            'pattern': pattern,\n            'marker_col': assoc['marker_pos'][1] \n        })\n\n    # 5. Sort patterns by marker column index\n    processed_patterns.sort(key=lambda x: x['marker_col'])\n\n    # 6. Concatenate patterns horizontally\n    # Assume all patterns are 4x4 as per the extraction logic\n    if not processed_patterns:\n         return np.zeros((4, 0), dtype=int) # Consistent empty output\n\n    final_patterns = [p['pattern'] for p in processed_patterns]\n    \n    # Check if final_patterns list is empty before attempting hstack\n    if not final_patterns:\n        # This case might occur if association failed, though unlikely with current logic\n        return np.zeros((4, 0), dtype=int)\n        \n    output_grid = np.hstack(final_patterns)\n\n    return output_grid.tolist() # Convert back to list of lists if required by ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3700,
    "candidates_token_count": 2303,
    "total_token_count": 6003,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 103.647806,
  "retries": null
}