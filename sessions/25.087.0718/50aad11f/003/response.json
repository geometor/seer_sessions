{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport math\n\n\"\"\"\nIdentifies 'markers' (pixels not white 0 or magenta 6) and 'magenta shapes' (connected magenta 6 pixels) in the input grid.\nAssociates each marker with the geometrically closest magenta shape based on minimum Euclidean distance.\nFor each association, extracts a 4x4 pattern:\n  Finds the top-left corner of the magenta shape's bounding box.\n  Creates a 4x4 grid (initially white 0).\n  For each pixel belonging *only* to the associated magenta shape, calculates its position relative to the bounding box top-left corner.\n  If the relative position is within the 4x4 bounds, sets the corresponding pixel in the 4x4 grid to the marker's color.\nDetermines the arrangement direction by comparing the range of marker row indices to the range of marker column indices.\n  If row_range > col_range, arrangement is 'vertical', sort key is marker row index.\n  Otherwise (col_range >= row_range or single marker), arrangement is 'horizontal', sort key is marker column index.\nSorts the generated 4x4 patterns based on the determined sort key.\nConcatenates the sorted patterns: vertically if arrangement is 'vertical', horizontally otherwise.\n\"\"\"\n\ndef find_markers(grid):\n    \"\"\"Finds pixels that are not background (0) or magenta (6).\"\"\"\n    markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Identify markers: color is not 0 (white) and not 6 (magenta)\n            if color != 0 and color != 6:\n                markers.append({'color': color, 'pos': (r, c)})\n    return markers\n\ndef find_magenta_objects(grid):\n    \"\"\"Finds connected components of magenta (6) pixels.\"\"\"\n    # Create a mask where only magenta pixels are True\n    magenta_mask = grid == 6\n    # Label connected components in the mask\n    labeled_array, num_features = label(magenta_mask)\n    \n    objects_coords = []\n    if num_features > 0:\n        # Iterate through each found feature (connected component)\n        for i in range(1, num_features + 1):\n            # Find the coordinates of all pixels belonging to the current component\n            coords = np.argwhere(labeled_array == i)\n            if coords.size > 0:\n                # Store coordinates as a list of [row, col] pairs\n                objects_coords.append(coords.tolist())\n                \n    return objects_coords # List of lists, each inner list contains [row, col] pairs for an object\n\ndef get_bounding_box(obj_coords):\n    \"\"\"Calculates the minimal bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\"\"\"\n    if not obj_coords:\n        return None, None, None, None\n    # Extract all row and column coordinates\n    rows = [coord[0] for coord in obj_coords]\n    cols = [coord[1] for coord in obj_coords]\n    # Return the min/max row and column\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef calculate_min_distance(marker_pos, obj_coords):\n    \"\"\"Calculates the minimum Euclidean distance between a marker point and any point in a list of object coordinates.\"\"\"\n    min_dist_sq = float('inf')\n    marker_r, marker_c = marker_pos\n    # Calculate squared Euclidean distance to avoid sqrt until the end\n    for r, c in obj_coords:\n        dist_sq = (marker_r - r)**2 + (marker_c - c)**2\n        if dist_sq < min_dist_sq:\n            min_dist_sq = dist_sq\n    # Return the actual distance\n    return math.sqrt(min_dist_sq)\n\ndef extract_and_recolor_4x4_pattern(obj_coords, marker_color):\n    \"\"\"\n    Creates a 4x4 pattern based on the object's pixels relative\n    to its bounding box top-left corner and recolors using the marker color.\n    \"\"\"\n    # Handle empty object coordinates list\n    if not obj_coords:\n        return np.zeros((4, 4), dtype=int)\n\n    # Calculate the top-left corner of the minimal bounding box\n    min_r, min_c, _, _ = get_bounding_box(obj_coords)\n    if min_r is None: # Check if bounding box calculation failed\n         return np.zeros((4, 4), dtype=int)\n\n    # Initialize the 4x4 pattern with background color (0)\n    pattern = np.zeros((4, 4), dtype=int)\n\n    # Iterate through *only* the pixels belonging to this specific object\n    for r, c in obj_coords:\n        # Calculate the relative position within the 4x4 frame anchored at the bounding box top-left\n        relative_r = r - min_r\n        relative_c = c - min_c\n\n        # Check if the relative position is within the 4x4 bounds (0 to 3)\n        if 0 <= relative_r < 4 and 0 <= relative_c < 4:\n            # Place the marker's color at this relative position in the pattern\n            pattern[relative_r, relative_c] = marker_color\n\n    return pattern\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by associating markers with magenta shapes,\n    extracting/recoloring 4x4 patterns, determining arrangement based on marker spread,\n    sorting the patterns, and concatenating them.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify Components\n    markers = find_markers(input_grid_np)\n    magenta_objects = find_magenta_objects(input_grid_np)\n    \n    # Handle cases with no markers or no magenta objects\n    if not markers or not magenta_objects:\n         # Return an empty grid (0x0) if essential components are missing\n         return np.array([[]], dtype=int).tolist() \n\n    # 2. Associate Markers to Shapes\n    associations = []\n    marker_positions = [] # Keep track of marker positions for arrangement logic\n    used_objects = set() # Keep track of objects already associated to handle 1-to-1 mapping if needed (though current logic uses closest)\n\n    for marker in markers:\n        min_dist = float('inf')\n        closest_obj_coords = None\n        closest_obj_index = -1\n\n        for idx, obj_coords in enumerate(magenta_objects):\n            if not obj_coords: continue # Skip if an object somehow has no coords\n            dist = calculate_min_distance(marker['pos'], obj_coords)\n            \n            # Find the closest object\n            if dist < min_dist:\n                min_dist = dist\n                closest_obj_coords = obj_coords\n                closest_obj_index = idx\n            # Potential tie-breaking needed? Examples suggest unique closest.\n                \n        if closest_obj_coords:\n            associations.append({\n                'marker_color': marker['color'],\n                'marker_pos': marker['pos'],\n                'object_coords': closest_obj_coords\n            })\n            marker_positions.append(marker['pos'])\n            # Note: Multiple markers might associate with the same object if it's closest to them.\n\n    # Check if any associations were made\n    if not associations:\n        return np.array([[]], dtype=int).tolist()\n\n    # 3. Extract and Recolor Patterns\n    processed_patterns = []\n    for assoc in associations:\n        pattern = extract_and_recolor_4x4_pattern(\n            assoc['object_coords'], \n            assoc['marker_color']\n        )\n        # Store pattern along with marker's position for sorting\n        processed_patterns.append({\n            'pattern': pattern,\n            'marker_row': assoc['marker_pos'][0], \n            'marker_col': assoc['marker_pos'][1] \n        })\n\n    # 4. Determine Arrangement and Sort Order\n    arrangement_mode = 'horizontal' # Default\n    sort_key_func = lambda x: x['marker_col'] # Default sort by column\n\n    # Only need to check range if more than one marker exists\n    if len(marker_positions) > 1:\n        rows = [pos[0] for pos in marker_positions]\n        cols = [pos[1] for pos in marker_positions]\n        row_range = max(rows) - min(rows)\n        col_range = max(cols) - min(cols)\n\n        # If the spread in rows is greater than the spread in columns, arrange vertically\n        if row_range > col_range:\n            arrangement_mode = 'vertical'\n            sort_key_func = lambda x: x['marker_row'] # Sort by row index\n        # Otherwise, stick to horizontal arrangement, sorting by column (default)\n\n    # 5. Sort Patterns\n    processed_patterns.sort(key=sort_key_func)\n\n    # 6. Combine Patterns\n    final_patterns = [p['pattern'] for p in processed_patterns]\n    \n    # Concatenate based on the determined arrangement mode\n    if arrangement_mode == 'vertical':\n        output_grid = np.vstack(final_patterns)\n    else: # 'horizontal'\n        output_grid = np.hstack(final_patterns)\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7626,
    "candidates_token_count": 2237,
    "total_token_count": 9863,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.786195,
  "retries": null
}