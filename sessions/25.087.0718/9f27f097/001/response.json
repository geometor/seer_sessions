{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies two distinct rectangular regions within the input grid: \n1. A source region containing a pattern of various non-background, non-white colors.\n2. A target region composed entirely of white pixels (color 0). \nBoth regions are typically surrounded by a dominant background color.\nThe transformation copies the exact pattern from the source region into the target region, \nreplacing the white pixels. The background and the original source region remain unchanged.\nThe dimensions of the source pattern area must match the dimensions of the target white area.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Identifies the background color, assumed to be the most frequent color\n    excluding white (0).\n    \"\"\"\n    # Flatten the grid and count color frequencies\n    counts = Counter(grid.flatten())\n    # Remove white color if present\n    if 0 in counts:\n        del counts[0]\n    # If grid only contained white, handle appropriately (e.g., return default or raise error)\n    if not counts:\n        # Fallback or error: maybe check corners or assume a default?\n        # For these examples, corners often hold the background color.\n        corners = [grid[0, 0], grid[0, -1], grid[-1, 0], grid[-1, -1]]\n        corner_counts = Counter(c for c in corners if c != 0)\n        if corner_counts:\n            return corner_counts.most_common(1)[0][0]\n        return -1 # Indicate error or ambiguous background\n\n    # Return the most frequent non-white color\n    return counts.most_common(1)[0][0]\n\ndef find_region_bounds(grid, condition_func):\n    \"\"\"\n    Finds the bounding box (min_r, min_c, max_r, max_c) for pixels\n    satisfying the condition_func. Returns None if no such pixels exist.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c = rows, cols\n    max_r, max_c = -1, -1\n    found = False\n\n    for r in range(rows):\n        for c in range(cols):\n            if condition_func(grid[r, c]):\n                min_r = min(min_r, r)\n                min_c = min(min_c, c)\n                max_r = max(max_r, r)\n                max_c = max(max_c, c)\n                found = True\n\n    if not found:\n        return None\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Copies a pattern from a source region into a target white region within the grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify the background color\n    background_color = get_background_color(grid)\n    if background_color == -1:\n        # Handle error: Could not determine background color\n        print(\"Warning: Could not determine background color.\")\n        # As a simple fallback for these examples, let's try the top-left if it's not 0\n        background_color = grid[0,0] if grid[0,0] != 0 else grid[0,1] # Basic fallback\n\n\n    # 2. Find the target white region (composed entirely of 0s)\n    white_bounds = find_region_bounds(grid, lambda pixel: pixel == 0)\n    if white_bounds is None:\n        # Handle error: No white region found\n        print(\"Error: No white region found.\")\n        return input_grid # Return original if no target\n\n    target_r_min, target_c_min, target_r_max, target_c_max = white_bounds\n    target_height = target_r_max - target_r_min + 1\n    target_width = target_c_max - target_c_min + 1\n\n    # Verify it's a solid rectangle of white\n    is_solid_white = np.all(grid[target_r_min:target_r_max+1, target_c_min:target_c_max+1] == 0)\n    if not is_solid_white:\n         # This assumes the *only* white pixels form the target rectangle.\n         # If there are stray white pixels elsewhere, find_region_bounds might encompass them.\n         # A more robust approach might find *all* contiguous white areas and pick the rectangular one.\n         # For now, proceed assuming the bounds correctly identified *the* target rectangle.\n         print(\"Warning: Bounded white area might not be solidly white, proceeding.\")\n\n\n    # 3. Find the source pattern region (non-background, non-white pixels)\n    source_bounds = find_region_bounds(grid, lambda pixel: pixel != background_color and pixel != 0)\n    if source_bounds is None:\n        # Handle error: No source pattern found\n        print(\"Error: No source pattern found.\")\n        return input_grid # Return original if no source\n\n    source_r_min, source_c_min, source_r_max, source_c_max = source_bounds\n    source_height = source_r_max - source_r_min + 1\n    source_width = source_c_max - source_c_min + 1\n\n    # 4. Extract the source pattern\n    source_pattern = grid[source_r_min:source_r_max+1, source_c_min:source_c_max+1]\n\n    # 5. Verify dimensions match (optional but good practice)\n    if source_height != target_height or source_width != target_width:\n        print(f\"Error: Source dimensions ({source_height}x{source_width}) do not match target dimensions ({target_height}x{target_width}).\")\n        # Decide how to handle mismatch - return original, try resizing, etc.\n        return input_grid # Return original on mismatch\n\n    # 6. Copy the source pattern into the target region in the output grid\n    output_grid[target_r_min:target_r_max+1, target_c_min:target_c_max+1] = source_pattern\n\n    # Convert back to list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3915,
    "candidates_token_count": 1532,
    "total_token_count": 5447,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.078366,
  "retries": null
}