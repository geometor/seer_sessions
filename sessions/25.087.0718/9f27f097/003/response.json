{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies two distinct rectangular regions within the input grid: \n1. A source region containing a pattern of various non-background, non-white colors.\n2. A target region composed entirely of white pixels (color 0). \nBoth regions are typically surrounded by a dominant background color.\nThe transformation copies the pattern from the source region, **flips it horizontally**, \nand then pastes the flipped pattern into the target region, replacing the white pixels. \nThe background and the original source region remain unchanged.\nThe dimensions of the source pattern area must match the dimensions of the target white area.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Identifies the background color, assumed to be the most frequent color\n    excluding white (0).\n    If only white exists, or frequencies are ambiguous, uses corner heuristics.\n    \"\"\"\n    # Flatten the grid and count color frequencies\n    counts = Counter(grid.flatten())\n    \n    # Remove white color if present\n    if 0 in counts:\n        del counts[0]\n        \n    # If grid only contained white or only background and white\n    if not counts:\n        # Use corners as a heuristic, preferring non-white\n        corners = [grid[0, 0], grid[0, -1], grid[-1, 0], grid[-1, -1]]\n        corner_counts = Counter(c for c in corners if c != 0)\n        if corner_counts:\n            return corner_counts.most_common(1)[0][0]\n        # If corners are also white, return the most frequent overall (which must be white now)\n        # Or perhaps better, return the corner value if it's consistent\n        if len(set(corners)) == 1 and corners[0] != 0:\n             return corners[0]\n        # Last resort if corners are mixed or all white/no non-white found anywhere\n        overall_counts = Counter(grid.flatten())\n        if overall_counts:\n            return overall_counts.most_common(1)[0][0] # Might return 0 if only white\n        return -1 # Indicate error or truly ambiguous background\n\n\n    # Return the most frequent non-white color\n    return counts.most_common(1)[0][0]\n\ndef find_region_bounds(grid, condition_func):\n    \"\"\"\n    Finds the bounding box (min_r, min_c, max_r, max_c) for pixels\n    satisfying the condition_func. Returns None if no such pixels exist.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c = rows, cols\n    max_r, max_c = -1, -1\n    found = False\n\n    for r in range(rows):\n        for c in range(cols):\n            if condition_func(grid[r, c]):\n                min_r = min(min_r, r)\n                min_c = min(min_c, c)\n                max_r = max(max_r, r)\n                max_c = max(max_c, c)\n                found = True\n\n    if not found:\n        return None\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Copies a pattern from a source region, flips it horizontally, \n    and pastes it into a target white region within the grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify the background color\n    background_color = get_background_color(grid)\n    if background_color == -1:\n        print(\"Warning: Could not reliably determine background color.\")\n        # Fallback: Assume the most frequent color overall is background\n        background_color = Counter(grid.flatten()).most_common(1)[0][0]\n\n\n    # 2. Find the target white region (composed entirely of 0s)\n    # Define condition for finding white pixels\n    white_condition = lambda pixel: pixel == 0\n    white_bounds = find_region_bounds(grid, white_condition)\n    \n    if white_bounds is None:\n        print(\"Error: No white region found.\")\n        return input_grid # Return original if no target\n\n    target_r_min, target_c_min, target_r_max, target_c_max = white_bounds\n    target_height = target_r_max - target_r_min + 1\n    target_width = target_c_max - target_c_min + 1\n\n    # Optional: Verify it's a solid rectangle of white - crucial if find_region_bounds could be misled by scattered white pixels\n    target_subgrid = grid[target_r_min:target_r_max+1, target_c_min:target_c_max+1]\n    if not np.all(target_subgrid == 0):\n         # If bounding box includes non-white, try finding the largest solid white rectangle instead.\n         # This simple implementation assumes the bounding box *is* the target.\n         print(\"Warning: Bounded white area is not solidly white. Check find_region_bounds logic or task assumptions.\")\n         # Could add logic here to find solid white sub-rectangles if needed.\n\n\n    # 3. Find the source pattern region (non-background, non-white pixels)\n    source_condition = lambda pixel: pixel != background_color and pixel != 0\n    source_bounds = find_region_bounds(grid, source_condition)\n    \n    if source_bounds is None:\n        print(\"Error: No source pattern found (non-background, non-white pixels).\")\n        return input_grid # Return original if no source\n\n    source_r_min, source_c_min, source_r_max, source_c_max = source_bounds\n    source_height = source_r_max - source_r_min + 1\n    source_width = source_c_max - source_c_min + 1\n\n    # 4. Extract the source pattern based on its bounding box\n    source_pattern = grid[source_r_min:source_r_max+1, source_c_min:source_c_max+1]\n\n    # 5. Verify dimensions match\n    if source_height != target_height or source_width != target_width:\n        print(f\"Error: Source dimensions ({source_height}x{source_width}) do not match target dimensions ({target_height}x{target_width}).\")\n        # Consider alternative source finding if dimensions mismatch? For now, return original.\n        return input_grid \n\n    # 6. **Flip the source pattern horizontally**\n    flipped_source_pattern = np.fliplr(source_pattern)\n\n    # 7. Copy the *flipped* source pattern into the target region in the output grid\n    output_grid[target_r_min:target_r_max+1, target_c_min:target_c_max+1] = flipped_source_pattern\n\n    # Convert back to list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5579,
    "candidates_token_count": 1699,
    "total_token_count": 7278,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.286535,
  "retries": null
}