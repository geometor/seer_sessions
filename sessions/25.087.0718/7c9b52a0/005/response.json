{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms an input grid based on identifying internal rectangular content areas, \ndetermining a target size based on the mode dimensions of these areas, \noverlaying the contents of these areas onto a target-sized canvas, and finally \ncropping any surrounding whitespace (color 0).\n\n1.  Determine the border color (assumed to be the color of the top-left pixel).\n2.  Identify all distinct, maximal rectangular blocks composed of non-border \n    colors that are located fully inside the single-pixel outer border of the \n    input grid.\n3.  For each identified content rectangle, determine its height and width.\n4.  Find the most common height (Mode Height) and the most common width \n    (Mode Width) among all identified content rectangles.\n5.  Prepare an intermediate canvas grid with dimensions Mode Height x Mode Width, \n    initially filled entirely with white pixels (0).\n6.  Iterate through each identified content rectangle from the input grid:\n    a. Extract the content grid (pixels from the input grid within the \n       rectangle's bounds).\n    b. Create a temporary grid, also of size Mode Height x Mode Width, filled \n       with white pixels (0).\n    c. Place the extracted content onto the top-left corner of this temporary \n       grid. Crop the content if it's larger than Mode Height x Mode Width; \n       pad with white if it's smaller.\n    d. Overlay the temporary grid onto the intermediate canvas grid: For each \n       pixel, if the temporary grid pixel is non-white (not 0) AND the corresponding \n       intermediate canvas pixel IS white (0), update the intermediate canvas pixel \n       to the temporary grid pixel's color. (This prevents overwriting existing \n       non-white content with other non-white content, only fills in the white \n       background).\n7.  After processing all content rectangles, crop the intermediate canvas grid by \n    removing any all-white (0) rows or columns from the outside edges inwards.\n8.  Return the final cropped grid.\n\"\"\"\n\ndef get_border_color(grid):\n    \"\"\"Determines the border color, assuming it's the color of grid[0, 0].\"\"\"\n    if grid.size == 0:\n        return 0 # Default or raise error? Assuming default for now.\n    return grid[0, 0]\n\ndef find_content_rectangles(grid, border_color):\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of non-border colors,\n    located strictly inside the 1-pixel border. Uses BFS to identify \n    connected components of non-border colors and checks if they form a \n    solid rectangle within their bounding box.\n    \n    Returns:\n        list: A list of dictionaries, where each dictionary represents a found \n              rectangle and has keys 'r', 'c', 'h', 'w' corresponding to its \n              top-left row, top-left column, height, and width relative to the \n              original grid coordinates.\n    \"\"\"\n    h, w = grid.shape\n    rectangles = []\n    \n    # Cannot have content inside a border if grid is too small\n    if h <= 2 or w <= 2: \n        return rectangles\n\n    # Search area is inside the 1-pixel border\n    inner_grid = grid[1:-1, 1:-1] \n    inner_h, inner_w = inner_grid.shape\n    visited = np.zeros_like(inner_grid, dtype=bool)\n\n    for r in range(inner_h):\n        for c in range(inner_w):\n            # If it's NOT the border color and hasn't been visited yet\n            if inner_grid[r, c] != border_color and not visited[r, c]:\n                \n                component_cells = [] # Store coordinates relative to inner_grid\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                is_component = True # Flag to track if BFS starts successfully\n\n                # BFS to find all connected non-border cells\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_cells.append((curr_r, curr_c))\n                    \n                    # Update bounding box (relative to inner_grid)\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds and if it's non-border and unvisited\n                        if 0 <= nr < inner_h and 0 <= nc < inner_w and \\\n                           inner_grid[nr, nc] != border_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # After BFS, check if the identified component forms a solid rectangle\n                # within its bounding box based on non-border colors.\n                if is_component and component_cells: # Ensure BFS actually ran and found cells\n                    rect_h = max_r - min_r + 1\n                    rect_w = max_c - min_c + 1\n                    \n                    is_solid_rectangle = True\n                    actual_cell_count = 0\n                    # Check all cells within the bounding box (in the inner_grid)\n                    for check_r in range(min_r, max_r + 1):\n                        for check_c in range(min_c, max_c + 1):\n                            if inner_grid[check_r, check_c] != border_color:\n                                actual_cell_count += 1\n                            else:\n                                # If a border-colored pixel is found within the bounding box, \n                                # it's not a solid rectangle of content.\n                                is_solid_rectangle = False\n                                break\n                        if not is_solid_rectangle:\n                            break\n                    \n                    # The component must perfectly fill its bounding box with non-border cells\n                    if is_solid_rectangle and len(component_cells) == actual_cell_count and len(component_cells) == rect_h * rect_w :\n                         # Adjust coordinates back to original grid (+1 for border offset)\n                        rectangles.append({'r': min_r + 1, 'c': min_c + 1, 'h': rect_h, 'w': rect_w})\n                        # No need to re-mark visited, BFS already did.\n                        \n    return rectangles\n\n\ndef crop_grid(grid):\n    \"\"\"Removes all-white (0) rows and columns from the border of the grid.\"\"\"\n    # Handle empty input grid possibility\n    if grid is None or grid.size == 0:\n        return np.array([[]], dtype=int) # Return empty grid representation\n\n    # If the grid contains only white pixels after processing\n    if np.all(grid == 0):\n         # Standard ARC output for all-white is usually a single white pixel\n        return np.array([[0]], dtype=int) \n\n    # Find rows and columns that contain at least one non-white pixel\n    rows_with_content = np.any(grid != 0, axis=1)\n    cols_with_content = np.any(grid != 0, axis=0)\n    \n    # If somehow all rows or columns are white (should be caught by np.all above, but safety)\n    if not np.any(rows_with_content) or not np.any(cols_with_content):\n         return np.array([[0]], dtype=int)\n\n    # Get the indices of the first and last row/column with content\n    rmin, rmax = np.where(rows_with_content)[0][[0, -1]]\n    cmin, cmax = np.where(cols_with_content)[0][[0, -1]]\n    \n    # Slice the grid to the bounding box of the content\n    return grid[rmin:rmax+1, cmin:cmax+1]\n\ndef transform(input_grid_list):\n    \"\"\"\n    Finds content rectangles inside the border, calculates the mode size, \n    overlays the content of these rectangles onto a canvas of the mode size, \n    and crops the result.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    \n    # Handle potential empty input\n    if input_grid.size == 0:\n      return [[]] # Return empty list for empty input\n\n    # 1. Determine Border Color\n    border_color = get_border_color(input_grid)\n\n    # 2. Identify content rectangles inside the border\n    content_rectangles = find_content_rectangles(input_grid, border_color)\n\n    # Handle cases where no valid content rectangles are found\n    if not content_rectangles:\n        # If no content areas are found inside the border, what should output be?\n        # Often it's an empty grid or a single pixel based on context.\n        # Let's default to [[0]] as per crop_grid's behavior for an all-white result.\n        return [[0]] \n\n    # 3. Record heights and widths of the found rectangles\n    heights = [rect['h'] for rect in content_rectangles]\n    widths = [rect['w'] for rect in content_rectangles]\n\n    # 4. Calculate Mode Height and Mode Width\n    height_counts = Counter(heights)\n    width_counts = Counter(widths)\n    \n    # Find the mode (most frequent value).\n    # If heights or widths list is empty (shouldn't happen due to check above), default?\n    # No, the check `if not content_rectangles:` handles this.\n    mode_height = height_counts.most_common(1)[0][0]\n    mode_width = width_counts.most_common(1)[0][0]\n\n    # 5. Prepare intermediate canvas filled with white (0)\n    intermediate_canvas = np.zeros((mode_height, mode_width), dtype=int)\n\n    # 6. Iterate through each identified rectangle, extract its content, and overlay it\n    for rect in content_rectangles:\n        r, c, h_rect, w_rect = rect['r'], rect['c'], rect['h'], rect['w']\n        \n        # 6a. Extract the content from the input grid corresponding to the rectangle\n        # Coordinates r, c, h, w are already relative to the original grid\n        content = input_grid[r : r + h_rect, c : c + w_rect]\n        \n        # 6b. Create a temporary grid of the target mode size, filled with white\n        temp_grid = np.zeros((mode_height, mode_width), dtype=int)\n        \n        # 6c. Determine the dimensions for copying (handle content larger/smaller than mode size)\n        copy_h = min(h_rect, mode_height)\n        copy_w = min(w_rect, mode_width)\n        \n        # Place the (potentially cropped) content onto the top-left of the temp grid\n        # Ensure slicing is correct: target[0:copy_h, 0:copy_w] = source[0:copy_h, 0:copy_w]\n        temp_grid[0:copy_h, 0:copy_w] = content[0:copy_h, 0:copy_w]\n        \n        # 6d. Overlay the temporary grid onto the intermediate canvas\n        # Update canvas pixels only where the temp grid has non-white content (value != 0)\n        # AND the corresponding canvas pixel is currently white (value == 0).\n        \n        # Mask for non-white pixels in the temporary grid\n        temp_non_white_mask = (temp_grid != 0)\n        # Mask for white pixels in the current intermediate canvas\n        canvas_is_white_mask = (intermediate_canvas == 0)\n        \n        # Combine masks: Update only where temp is non-white AND canvas is white\n        update_mask = temp_non_white_mask & canvas_is_white_mask\n        \n        # Apply the update using the combined mask\n        intermediate_canvas[update_mask] = temp_grid[update_mask]\n        \n        # --- Alternative Overlay Logic (If any non-white should overwrite anything): ---\n        # If the rule was simply \"non-white pixels from the current piece overwrite \n        # whatever is on the canvas\", the logic would be:\n        # update_mask = (temp_grid != 0) \n        # intermediate_canvas[update_mask] = temp_grid[update_mask]\n        # The current implementation follows the more specific interpretation from the NL description.\n\n    # 7. Crop final whitespace (0) from the resulting canvas\n    final_grid_np = crop_grid(intermediate_canvas)\n\n    # 8. Return the final grid as a list of lists\n    return final_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5625,
    "candidates_token_count": 3091,
    "total_token_count": 8716,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.595896,
  "retries": null
}