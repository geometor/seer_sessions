{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms an input grid based on identifying internal white rectangular areas, \ndetermining a target size based on the mode dimensions of these areas, \noverlaying the contents of these areas onto a target-sized canvas, and finally \ncropping any surrounding whitespace.\n\n1.  Identify all distinct, maximal rectangular blocks composed entirely of white \n    pixels (color 0) that are located inside the single-pixel outer border of \n    the input grid.\n2.  For each identified white rectangle, determine its height and width.\n3.  Find the most common height (Mode Height) and the most common width \n    (Mode Width) among all identified white rectangles.\n4.  Prepare an intermediate canvas grid with dimensions Mode Height x Mode Width, \n    initially filled entirely with white pixels (0).\n5.  Iterate through each identified white rectangle from the input grid:\n    a. Extract the content grid (pixels from the input grid within the \n       rectangle's bounds).\n    b. Create a temporary grid, also of size Mode Height x Mode Width, filled \n       with white pixels (0).\n    c. Place the extracted content onto the top-left corner of this temporary \n       grid. Crop the content if it's larger than Mode Height x Mode Width; \n       pad with white if it's smaller.\n    d. Overlay the temporary grid onto the intermediate canvas grid: For each \n       pixel, if the temporary grid pixel is non-white AND the corresponding \n       intermediate canvas pixel is white, update the intermediate canvas pixel \n       to the temporary grid pixel's color.\n6.  After processing all white rectangles, crop the intermediate canvas grid by \n    removing any all-white rows or columns from the outside edges inwards.\n7.  Return the final cropped grid.\n\"\"\"\n\ndef find_white_rectangles(grid):\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of white (0) pixels,\n    ignoring the 1-pixel border. Uses BFS to identify connected components\n    and checks if they form a solid rectangle.\n    Returns a list of dictionaries: {'r': row, 'c': col, 'h': height, 'w': width}.\n    Coordinates are relative to the original grid.\n    \"\"\"\n    h, w = grid.shape\n    rectangles = []\n    \n    # Cannot have content inside a border if grid is too small\n    if h <= 2 or w <= 2: \n        return rectangles\n\n    # Search area is inside the border\n    inner_grid = grid[1:-1, 1:-1] \n    inner_h, inner_w = inner_grid.shape\n    visited = np.zeros_like(inner_grid, dtype=bool)\n\n    for r in range(inner_h):\n        for c in range(inner_w):\n            # If it's a white pixel and hasn't been visited yet\n            if inner_grid[r, c] == 0 and not visited[r, c]:\n                \n                component_cells = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # BFS to find all connected white cells\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_cells.append((curr_r, curr_c))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds and if it's white and unvisited\n                        if 0 <= nr < inner_h and 0 <= nc < inner_w and \\\n                           inner_grid[nr, nc] == 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Check if the component forms a solid rectangle\n                rect_h = max_r - min_r + 1\n                rect_w = max_c - min_c + 1\n                \n                is_solid_rectangle = True\n                if len(component_cells) != rect_h * rect_w:\n                    is_solid_rectangle = False\n                else:\n                    # Double check all cells within the bounding box are part of the component\n                    # (This might be redundant if BFS explored correctly and marked visited)\n                     for check_r in range(min_r, max_r + 1):\n                         for check_c in range(min_c, max_c + 1):\n                             if inner_grid[check_r, check_c] != 0:\n                                 is_solid_rectangle = False\n                                 break\n                         if not is_solid_rectangle:\n                             break\n\n                # If it's a solid rectangle, add it to the list\n                if is_solid_rectangle:\n                    # Adjust coordinates back to original grid (+1 for border)\n                    rectangles.append({'r': min_r + 1, 'c': min_c + 1, 'h': rect_h, 'w': rect_w})\n                    # Mark all cells within this rectangle as visited \n                    # (redundant due to BFS marking, but safe)\n                    for cell_r, cell_c in component_cells:\n                         visited[cell_r, cell_c] = True # Ensure all parts are marked\n\n    return rectangles\n\n\ndef crop_grid(grid):\n    \"\"\"Removes all-white (0) rows and columns from the border of the grid.\"\"\"\n    # Handle empty input grid possibility\n    if grid is None or grid.size == 0:\n        return np.array([[]], dtype=int) # Return empty grid representation\n\n    # If the grid contains only white pixels after processing\n    if np.all(grid == 0):\n         # Standard ARC output for all-white is usually a single white pixel\n        return np.array([[0]], dtype=int) \n\n    # Find rows and columns that contain at least one non-white pixel\n    rows_with_content = np.any(grid != 0, axis=1)\n    cols_with_content = np.any(grid != 0, axis=0)\n    \n    # If somehow all rows or columns are white (should be caught by np.all above, but safety)\n    if not np.any(rows_with_content) or not np.any(cols_with_content):\n         return np.array([[0]], dtype=int)\n\n    # Get the indices of the first and last row/column with content\n    rmin, rmax = np.where(rows_with_content)[0][[0, -1]]\n    cmin, cmax = np.where(cols_with_content)[0][[0, -1]]\n    \n    # Slice the grid to the bounding box of the content\n    return grid[rmin:rmax+1, cmin:cmax+1]\n\ndef transform(input_grid_list):\n    \"\"\"\n    Finds white rectangles inside the border, calculates the mode size, \n    overlays the content of these rectangles onto a canvas of the mode size, \n    and crops the result.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    h, w = input_grid.shape\n\n    # 1. Identify white rectangles inside the border\n    white_rectangles = find_white_rectangles(input_grid)\n\n    # Handle cases where no valid white rectangles are found\n    if not white_rectangles:\n        # Return an empty grid representation or single white pixel?\n        # Let's return [[0]] as per crop_grid's behavior for all-white.\n        # If the task expects truly empty for no input rectangles, return [[]]\n        return [[0]] # Consistent with crop_grid for empty result\n\n    # 2. Record heights and widths of the found rectangles\n    heights = [rect['h'] for rect in white_rectangles]\n    widths = [rect['w'] for rect in white_rectangles]\n\n    # 3. Calculate Mode Height and Mode Width\n    # Counter handles potential empty lists gracefully, but we checked above\n    height_counts = Counter(heights)\n    width_counts = Counter(widths)\n    \n    # Find the mode (most frequent value). most_common(1) returns a list of [(value, count)]\n    # If there are ties for the mode, Counter arbitrarily picks one.\n    mode_height = height_counts.most_common(1)[0][0]\n    mode_width = width_counts.most_common(1)[0][0]\n\n    # 4. Prepare intermediate canvas filled with white (0)\n    intermediate_canvas = np.zeros((mode_height, mode_width), dtype=int)\n\n    # 5. Iterate through each identified rectangle, extract its content, and overlay it\n    for rect in white_rectangles:\n        r, c, h_rect, w_rect = rect['r'], rect['c'], rect['h'], rect['w']\n        \n        # 5a. Extract the content from the input grid corresponding to the rectangle\n        content = input_grid[r : r + h_rect, c : c + w_rect]\n        \n        # 5b/5c. Prepare a temporary grid and place the extracted content\n        # Create a temporary grid of the target mode size, filled with white\n        temp_grid = np.zeros((mode_height, mode_width), dtype=int)\n        \n        # Determine the dimensions for copying (handle cases where content is larger/smaller)\n        copy_h = min(h_rect, mode_height)\n        copy_w = min(w_rect, mode_width)\n        \n        # Place the (potentially cropped) content onto the top-left of the temp grid\n        temp_grid[0:copy_h, 0:copy_w] = content[0:copy_h, 0:copy_w]\n        \n        # 5d. Overlay the temporary grid onto the intermediate canvas\n        # Update canvas pixels only where the temp grid has non-white content\n        # AND the corresponding canvas pixel is currently white.\n        # This prevents overwriting previously placed content with white from later overlaps.\n        \n        # Mask for non-white pixels in the temporary grid\n        temp_non_white_mask = (temp_grid != 0)\n        # Mask for white pixels in the current intermediate canvas\n        canvas_is_white_mask = (intermediate_canvas == 0)\n        \n        # Combine masks: Update only where temp is non-white AND canvas is white\n        update_mask = temp_non_white_mask & canvas_is_white_mask\n        \n        # Apply the update\n        intermediate_canvas[update_mask] = temp_grid[update_mask]\n        \n        # --- Alternative Overlay Logic (If non-white should always overwrite): ---\n        # If any non-white pixel from any rectangle should overwrite anything \n        # (even previously placed non-white pixels), the logic is simpler:\n        # update_mask = (temp_grid != 0) \n        # intermediate_canvas[update_mask] = temp_grid[update_mask]\n        # Based on the problem description \"overlay... if non-white AND canvas is white\",\n        # the original logic is correct.\n\n    # 6. Crop final whitespace from the resulting canvas\n    final_grid_np = crop_grid(intermediate_canvas)\n\n    # 7. Return the final grid as a list of lists\n    return final_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6096,
    "candidates_token_count": 2753,
    "total_token_count": 8849,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.617608,
  "retries": null
}