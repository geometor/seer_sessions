{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport itertools\n\n\"\"\"\nTransforms an input grid based on identifying internal white rectangular areas, \ndetermining a target size based on the mode dimensions of these areas, \noverlaying the contents of these areas onto a target-sized canvas, and finally \ncropping any surrounding whitespace.\n\n1.  Identify all distinct, maximal rectangular blocks composed entirely of white \n    pixels (color 0) that are located inside the single-pixel outer border of \n    the input grid.\n2.  For each identified white rectangle, determine its height and width.\n3.  Find the most common height (Mode Height) and the most common width \n    (Mode Width) among all identified white rectangles.\n4.  Prepare an intermediate canvas grid with dimensions Mode Height x Mode Width, \n    initially filled entirely with white pixels (0).\n5.  Iterate through each identified white rectangle from the input grid:\n    a. Extract the content grid (pixels from the input grid within the \n       rectangle's bounds).\n    b. Create a temporary grid, also of size Mode Height x Mode Width, filled \n       with white pixels (0).\n    c. Place the extracted content onto the top-left corner of this temporary \n       grid. Crop the content if it's larger than Mode Height x Mode Width; \n       pad with white if it's smaller.\n    d. Overlay the temporary grid onto the intermediate canvas grid: For each \n       pixel, if the temporary grid pixel is non-white AND the corresponding \n       intermediate canvas pixel is white, update the intermediate canvas pixel \n       to the temporary grid pixel's color.\n6.  After processing all white rectangles, crop the intermediate canvas grid by \n    removing any all-white rows or columns from the outside edges inwards.\n7.  Return the final cropped grid.\n\"\"\"\n\ndef find_maximal_white_rectangles(grid):\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of white (0) pixels,\n    ignoring the 1-pixel border.\n    Returns a list of tuples: (row, col, height, width).\n    \"\"\"\n    h, w = grid.shape\n    if h <= 2 or w <= 2: # Cannot have content inside a border\n        return []\n\n    # Search area is inside the border\n    inner_grid = grid[1:-1, 1:-1] \n    inner_h, inner_w = inner_grid.shape\n    visited = np.zeros_like(inner_grid, dtype=bool)\n    rectangles = []\n\n    for r in range(inner_h):\n        for c in range(inner_w):\n            if inner_grid[r, c] == 0 and not visited[r, c]:\n                # Found potential top-left corner of a white rectangle\n                # Determine max width from this point\n                max_c = c\n                while max_c + 1 < inner_w and inner_grid[r, max_c + 1] == 0 and not visited[r, max_c + 1]:\n                    max_c += 1\n                current_w = max_c - c + 1\n\n                # Determine max height for this initial width\n                max_r = r\n                possible = True\n                while possible and max_r + 1 < inner_h:\n                    # Check if the next row maintains the rectangle shape and color\n                    for col_check in range(c, c + current_w):\n                        if inner_grid[max_r + 1, col_check] != 0 or visited[max_r + 1, col_check]:\n                            possible = False\n                            break\n                    if possible:\n                        max_r += 1\n                current_h = max_r - r + 1\n\n                # Check if we can expand width further down\n                for r_check in range(r + 1, r + current_h):\n                    max_c_row = c + current_w - 1\n                    while max_c_row + 1 < inner_w and inner_grid[r_check, max_c_row + 1] == 0 and not visited[r_check, max_c_row + 1]:\n                        # Check if all cells above in this new column are also white and unvisited\n                        valid_col_expansion = True\n                        for r_above in range(r, r_check + 1):\n                           if inner_grid[r_above, max_c_row + 1] != 0 or visited[r_above, max_c_row+1]:\n                               valid_col_expansion = False\n                               break\n                        if valid_col_expansion:\n                           max_c_row += 1\n                        else:\n                           break\n                           \n                    new_w = max_c_row - c + 1\n                    if new_w < current_w: # Shrink width if necessary to maintain rectangular shape\n                        current_w = new_w\n\n                # Mark visited and store rectangle (adjusting coords for original grid)\n                for row_idx in range(r, r + current_h):\n                    for col_idx in range(c, c + current_w):\n                        visited[row_idx, col_idx] = True\n                \n                # Store coordinates relative to the original grid (add 1 for border offset)\n                rectangles.append({'r': r + 1, 'c': c + 1, 'h': current_h, 'w': current_w})\n\n    # Filter for maximality (crude way: remove rectangles contained within others)\n    # A better way is integrated into the search, the above attempts this.\n    # Let's refine the check: only start a search if grid[r-1, c] or grid[r, c-1] was non-white\n    \n    # --- Re-implementing search focusing on top-left corners ---\n    visited = np.zeros_like(inner_grid, dtype=bool)\n    rectangles = []\n    for r in range(inner_h):\n        for c in range(inner_w):\n            is_top = (r == 0 or inner_grid[r-1, c] != 0)\n            is_left = (c == 0 or inner_grid[r, c-1] != 0)\n            \n            if inner_grid[r, c] == 0 and not visited[r,c]: #and is_top and is_left: #<-- this check makes it miss some cases if shapes touch\n                 # Found a white cell, potentially part of a new maximal rectangle. Determine its extent.\n                \n                # Find width\n                rect_w = 0\n                while c + rect_w < inner_w and inner_grid[r, c + rect_w] == 0:\n                     rect_w += 1\n\n                # Find height\n                rect_h = 0\n                while r + rect_h < inner_h:\n                    valid_row = True\n                    for k in range(rect_w):\n                        if c + k >= inner_w or inner_grid[r + rect_h, c + k] != 0:\n                            valid_row = False\n                            break\n                    if valid_row:\n                        rect_h += 1\n                    else:\n                        break\n                \n                # Now, we have a rectangle of size rect_h x rect_w starting at (r, c)\n                # Mark cells as visited for this specific rectangle to avoid recounting sub-parts\n                # However, we need *maximal* rectangles. The first one found might not be.\n                # A better flood-fill or region growing approach is complex.\n\n                # Let's try a simpler scan and record all possible white rectangles\n                # Then filter based on maximality later? Or just assume the first pass gets it?\n                # The logic above tries to find height first, then adjusts width. Let's stick with that\n                # Mark cells visited only after finding the full HxW rectangle from a top-left candidate\n                \n                # --- Reverting to a modified version of the first attempt, seems more robust ---\n                if inner_grid[r, c] == 0 and not visited[r, c]:\n                    # Max width at current row r\n                    start_c = c\n                    while c + 1 < inner_w and inner_grid[r, c + 1] == 0 and not visited[r, c + 1]:\n                        c += 1\n                    current_w = c - start_c + 1\n                    \n                    # Max height for this width starting at start_c\n                    start_r = r\n                    possible_h = True\n                    while possible_h and r + 1 < inner_h:\n                        for col_idx in range(start_c, start_c + current_w):\n                            if inner_grid[r + 1, col_idx] != 0 or visited[r + 1, col_idx]:\n                                possible_h = False\n                                break\n                        if possible_h:\n                            r += 1\n                    current_h = r - start_r + 1\n\n                    # Mark visited\n                    is_maximal = True # Assume maximal until proven otherwise\n                    for row_idx in range(start_r, start_r + current_h):\n                       for col_idx in range(start_c, start_c + current_w):\n                           if visited[row_idx, col_idx]:\n                               is_maximal = False # Part of this rectangle was already claimed by another\n                           visited[row_idx, col_idx] = True\n\n                    # Store if it wasn't part of an already found larger one\n                    # (This check might still not be perfect for complex overlaps)\n                    if is_maximal:\n                         rectangles.append({'r': start_r + 1, 'c': start_c + 1, 'h': current_h, 'w': current_w})\n                    \n                    c = start_c + current_w -1 # Continue scan after the found rect width\n                    r = start_r # Reset row scanning for next column checks\n\n    return rectangles\n\n\ndef crop_grid(grid):\n    \"\"\"Removes all-zero rows and columns from the border of the grid.\"\"\"\n    if grid.size == 0:\n        return grid\n    if np.all(grid == 0):\n        return np.array([[0]]) # Return 1x1 white if grid is all white\n\n    rows = np.any(grid != 0, axis=1)\n    cols = np.any(grid != 0, axis=0)\n    \n    if not np.any(rows) or not np.any(cols):\n         return np.array([[0]]) # Should not happen if check above works, but safety\n\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n    \n    return grid[rmin:rmax+1, cmin:cmax+1]\n\ndef transform(input_grid):\n    \"\"\"\n    Finds white rectangles, calculates mode size, overlays content, crops result.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    h, w = input_grid.shape\n\n    # 1. Identify white rectangles inside the border\n    white_rectangles = find_maximal_white_rectangles(input_grid)\n\n    if not white_rectangles:\n        # No white rectangles found, perhaps return empty or input?\n        # Based on examples, this shouldn't happen. Let's return empty grid.\n        return [[]]\n\n    # 2. Record heights and widths\n    heights = [rect['h'] for rect in white_rectangles]\n    widths = [rect['w'] for rect in white_rectangles]\n\n    # 3. Calculate Mode Height and Mode Width\n    # Handle empty lists case although checked above\n    if not heights or not widths:\n       return [[]]\n       \n    height_counts = Counter(heights)\n    width_counts = Counter(widths)\n    \n    # Find the mode (most frequent value). If ties, Counter().most_common(1) picks one.\n    mode_height = height_counts.most_common(1)[0][0]\n    mode_width = width_counts.most_common(1)[0][0]\n\n    # 4. Prepare intermediate canvas\n    intermediate_canvas = np.zeros((mode_height, mode_width), dtype=int)\n\n    # 5. Iterate, extract, resize/align, and overlay\n    for rect in white_rectangles:\n        r, c, h_rect, w_rect = rect['r'], rect['c'], rect['h'], rect['w']\n        \n        # 5a. Extract content\n        content = input_grid[r : r + h_rect, c : c + w_rect]\n        \n        # 5b/5c. Create temporary grid and place content (crop/pad)\n        temp_grid = np.zeros((mode_height, mode_width), dtype=int)\n        \n        # Determine copy dimensions\n        copy_h = min(h_rect, mode_height)\n        copy_w = min(w_rect, mode_width)\n        \n        temp_grid[0:copy_h, 0:copy_w] = content[0:copy_h, 0:copy_w]\n        \n        # 5d. Overlay onto intermediate canvas (non-white onto white)\n        # Create masks for where temp is non-zero and canvas is zero\n        temp_non_white_mask = (temp_grid != 0)\n        canvas_is_white_mask = (intermediate_canvas == 0)\n        \n        # Update canvas only where temp is non-white AND canvas is white\n        update_mask = temp_non_white_mask & canvas_is_white_mask\n        intermediate_canvas[update_mask] = temp_grid[update_mask]\n\n    # 6. Crop final whitespace\n    final_grid = crop_grid(intermediate_canvas)\n\n    # 7. Return as list of lists\n    return final_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6855,
    "candidates_token_count": 3225,
    "total_token_count": 10080,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.623907,
  "retries": null
}