{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all distinct connected components (objects) of non-white pixels in the input grid using 4-way adjacency.\n2. Determine the component with the largest number of pixels; this is the 'frame'. Store its color ('frame_color') and coordinates ('frame_coords').\n3. If no non-white components exist, return the input grid unchanged.\n4. Create a set of 'barrier_coords' containing the coordinates of *all* non-white pixels found in step 1 (including the frame and any internal objects).\n5. Perform a Breadth-First Search (BFS) starting from all white (0) pixels located on the grid borders.\n6. The BFS can only traverse white pixels and cannot enter any coordinates present in the 'barrier_coords' set.\n7. Keep track of all white pixels visited by the BFS ('reachable_white_coords'). These are the white pixels connected to the outside.\n8. Create the output grid as a copy of the input grid.\n9. Iterate through every pixel (r, c) of the grid:\n    a. If the pixel in the *input* grid `input_grid[r, c]` is white (0) AND its coordinate `(r, c)` is *not* in the 'reachable_white_coords' set:\n        i. Set the corresponding pixel in the *output* grid `output_grid[r, c]` to the 'frame_color'.\n10. Return the modified output grid.\n\"\"\"\n\ndef find_all_components(grid):\n    \"\"\"\n    Finds all connected components of non-white pixels using 4-way adjacency.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples [(color, coords_set), ...], where each tuple\n        represents a connected non-white component. Returns an empty list\n        if no non-white pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    all_components = [] # List to store (color, coords_set)\n\n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-white and hasn't been visited as part of a component yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start a BFS to find the connected component\n                component_color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark starting cell visited\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                           # Check if neighbor has the same color and hasn't been visited\n                           if grid[nr, nc] == component_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store the found component (color and its coordinates)\n                if component_coords: # Should always be true here\n                    all_components.append((component_color, component_coords))\n\n    return all_components\n\ndef find_reachable_white(grid, barrier_coords):\n    \"\"\"\n    Finds white pixels reachable from the grid borders via white pixels,\n    avoiding the specified barrier coordinates. Uses BFS.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        barrier_coords: A set of (row, col) tuples representing all barrier pixels\n                       (typically all non-white pixels).\n\n    Returns:\n        A set of (row, col) tuples for the white pixels reachable from the border.\n    \"\"\"\n    rows, cols = grid.shape\n    # Keep track of visited/reachable white cells to avoid cycles and redundant work\n    reachable_white = set()\n    q = deque()\n\n    # Initialize queue with all border white cells that are NOT barriers\n    # Check top/bottom borders\n    for c in range(cols):\n        for r in [0, rows - 1]:\n            coord = (r, c)\n            # If it's white, not a barrier, and not already found/queued\n            if grid[r, c] == 0 and coord not in barrier_coords and coord not in reachable_white:\n                reachable_white.add(coord)\n                q.append(coord)\n    # Check left/right borders (excluding corners already checked)\n    for r in range(1, rows - 1):\n        for c in [0, cols - 1]:\n            coord = (r, c)\n            # If it's white, not a barrier, and not already found/queued\n            if grid[r, c] == 0 and coord not in barrier_coords and coord not in reachable_white:\n                reachable_white.add(coord)\n                q.append(coord)\n\n    # Perform BFS starting from the border white cells\n    while q:\n        r, c = q.popleft()\n        # Explore orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_coord = (nr, nc)\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is white, not a barrier, and not already visited/reachable\n                if grid[nr, nc] == 0 and \\\n                   neighbor_coord not in barrier_coords and \\\n                   neighbor_coord not in reachable_white:\n                    # Mark as reachable and add to queue for further exploration\n                    reachable_white.add(neighbor_coord)\n                    q.append(neighbor_coord)\n\n    # Return the set of all white coordinates reachable from the border\n    return reachable_white\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Fills enclosed white areas with the color of the largest non-white object,\n    treating all non-white objects as barriers for the fill.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Find all non-white connected components\n    all_components = find_all_components(input_grid)\n\n    # 2. Handle edge case: If no non-white components exist, return the original grid\n    if not all_components:\n        return output_grid\n\n    # 3. Identify the largest component (the 'frame') by pixel count\n    # The key for max is the length of the coordinate set (item[1])\n    largest_component = max(all_components, key=lambda item: len(item[1]))\n    frame_color = largest_component[0]\n    # frame_coords = largest_component[1] # Not strictly needed after barriers are built\n\n    # 4. Create a single set of barrier coordinates from ALL non-white components\n    barrier_coords = set()\n    for _, coords in all_components:\n        barrier_coords.update(coords) # Add coordinates from current component\n\n    # 5. Find all white pixels reachable from the border, avoiding barriers\n    reachable_white_coords = find_reachable_white(input_grid, barrier_coords)\n\n    # 6. Fill the 'internal' white pixels (those not reachable from the border)\n    # Iterate through every cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is white in the original input grid\n            if input_grid[r, c] == 0:\n                # Check if this white pixel's coordinate was NOT found by the reachability BFS\n                if (r, c) not in reachable_white_coords:\n                    # This is an internal, unreachable white pixel. Fill it.\n                    output_grid[r, c] = frame_color\n            # Else (if it's non-white or reachable white), it keeps its original color\n            # (already handled by copying input_grid initially)\n\n    # 7. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9685,
    "candidates_token_count": 1981,
    "total_token_count": 11666,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.519242,
  "retries": null
}