{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the largest connected component (object) composed of a single non-white color in the input grid. This is the 'frame'. Note its color (`frame_color`) and the coordinates of its pixels (`frame_coords`).\n2. Identify all white (0) pixels that are enclosed by this frame and are not reachable from the grid borders by traversing only white pixels.\n3. Create the output grid by copying the input grid.\n4. Change the color of these enclosed white pixels in the output grid to the `frame_color`.\n5. All other pixels (the frame itself, non-white objects inside the frame, and white pixels reachable from the border) retain their original colors.\n\"\"\"\n\ndef find_largest_component(grid):\n    \"\"\"\n    Finds the largest connected component of non-white pixels.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple (frame_color, frame_coords_set):\n            frame_color: The color of the largest component.\n            frame_coords_set: A set of (row, col) tuples for the pixels in the largest component.\n        Returns (None, set()) if no non-white component is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    largest_component = (None, set()) # (color, coords_set)\n    max_size = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Found the start of a potential component\n                component_color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_size = 0\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    current_size += 1\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == component_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Check if this component is the largest found so far\n                if current_size > max_size:\n                    max_size = current_size\n                    largest_component = (component_color, component_coords)\n\n    return largest_component\n\n\ndef find_internal_white_coords(grid, barrier_coords):\n    \"\"\"\n    Finds white pixels enclosed by the barrier that are not reachable\n    from the grid borders via white pixels.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        barrier_coords: A set of (row, col) tuples representing the frame/barrier.\n\n    Returns:\n        A set of (row, col) tuples for the internal white pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    visited_external = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Mark barrier cells as visited to prevent traversal through them\n    for r_b, c_b in barrier_coords:\n        if 0 <= r_b < rows and 0 <= c_b < cols: # Ensure barrier coord is in bounds\n             visited_external[r_b, c_b] = True\n\n    # Add all border white cells (not part of the barrier) to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right borders\n             if grid[r, c] == 0 and not visited_external[r, c]:\n                 visited_external[r,c] = True\n                 q.append((r,c))\n    for c in range(cols):\n        for r in [0, rows-1]: # Top and bottom borders (avoid double adding corners)\n             if grid[r,c] == 0 and not visited_external[r, c]:\n                 visited_external[r, c] = True\n                 q.append((r, c))\n\n\n    # Perform BFS from border white cells\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if it's a white cell, and not visited\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == 0 and not visited_external[nr, nc]:\n                visited_external[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify internal white cells (white and not visited by external BFS)\n    internal_white_coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 0 and not visited_external[r, c]:\n                internal_white_coords.add((r, c))\n\n    return internal_white_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the area enclosed by the largest non-white shape with the shape's color.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify the largest connected non-white component (the frame)\n    frame_color, frame_coords = find_largest_component(input_grid)\n\n    # If no frame is found, return the original grid\n    if frame_color is None:\n        return output_grid\n\n    # 2. Find the white pixels enclosed by the frame\n    internal_white_coords = find_internal_white_coords(input_grid, frame_coords)\n\n    # 3. Fill the internal white pixels with the frame color\n    for r, c in internal_white_coords:\n        output_grid[r, c] = frame_color\n\n    # 4. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3732,
    "candidates_token_count": 1527,
    "total_token_count": 5259,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.948347,
  "retries": null
}