{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all separate connected groups (objects) of non-white pixels in the input grid, using 4-way (up, down, left, right) connections.\n2. Find the object with the most pixels; this is the 'frame'. Note its color ('frame_color').\n3. Identify all other non-white objects besides the frame; these are the 'internal objects'.\n4. Create a set of 'barrier coordinates' containing the locations of *all* non-white pixels (from the frame and all internal objects).\n5. Find all white pixels that can be reached starting from any white pixel on the border of the grid, moving only through other white pixels (4-way adjacency) and without entering any 'barrier coordinates'. Mark these as 'reachable white pixels'.\n6. Find all white pixels that are orthogonally adjacent (share an edge) to any pixel belonging to an 'internal object'. Mark these as 'protected white pixels'.\n7. Create the output grid as a copy of the input grid.\n8. Examine every pixel location (row, column). If the pixel in the *input* grid is white AND it is *not* a 'reachable white pixel' AND it is *not* a 'protected white pixel', then change the color of that pixel in the *output* grid to the 'frame_color'.\n9. If no non-white objects exist, return the input grid unchanged.\n\"\"\"\n\ndef find_all_components(grid):\n    \"\"\"\n    Finds all connected components of non-white pixels using 4-way adjacency.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples [(color, coords_set), ...], where each tuple\n        represents a connected non-white component. Returns an empty list\n        if no non-white pixels are found. Components are sorted by size descending.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    all_components = [] # List to store (color, coords_set)\n\n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-white and hasn't been visited as part of a component yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start a BFS to find the connected component\n                component_color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark starting cell visited\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                           # Check if neighbor has the same color and hasn't been visited\n                           if grid[nr, nc] == component_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store the found component (color and its coordinates)\n                if component_coords: # Should always be true here\n                    all_components.append((component_color, component_coords))\n\n    # Sort components by size (number of coordinates) in descending order\n    all_components.sort(key=lambda item: len(item[1]), reverse=True)\n\n    return all_components\n\ndef find_reachable_white(grid, barrier_coords):\n    \"\"\"\n    Finds white pixels reachable from the grid borders via white pixels,\n    avoiding the specified barrier coordinates. Uses BFS.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        barrier_coords: A set of (row, col) tuples representing all barrier pixels\n                       (typically all non-white pixels).\n\n    Returns:\n        A set of (row, col) tuples for the white pixels reachable from the border.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_white = set()\n    q = deque()\n\n    # Initialize queue with all border white cells that are NOT barriers\n    for r in range(rows):\n        for c in range(cols):\n            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                coord = (r, c)\n                if grid[r, c] == 0 and coord not in barrier_coords and coord not in reachable_white:\n                    reachable_white.add(coord)\n                    q.append(coord)\n\n    # Perform BFS starting from the border white cells\n    while q:\n        r, c = q.popleft()\n        # Explore orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_coord = (nr, nc)\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is white, not a barrier, and not already visited/reachable\n                if grid[nr, nc] == 0 and \\\n                   neighbor_coord not in barrier_coords and \\\n                   neighbor_coord not in reachable_white:\n                    reachable_white.add(neighbor_coord)\n                    q.append(neighbor_coord)\n\n    return reachable_white\n\ndef find_protected_white(grid, internal_object_coords):\n    \"\"\"\n    Finds white pixels that are orthogonally adjacent to any internal object pixel.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        internal_object_coords: A set of (row, col) tuples representing the coordinates\n                                of all internal (non-frame) non-white objects.\n\n    Returns:\n        A set of (row, col) tuples for the white pixels adjacent to internal objects.\n    \"\"\"\n    rows, cols = grid.shape\n    protected_white = set()\n\n    # Iterate through each coordinate belonging to an internal object\n    for r, c in internal_object_coords:\n        # Check orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_coord = (nr, nc)\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is white\n                if grid[nr, nc] == 0:\n                    # Add this adjacent white pixel to the protected set\n                    protected_white.add(neighbor_coord)\n\n    return protected_white\n\n\ndef transform(input_grid):\n    \"\"\"Applies the transformation rule to the input grid.\"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify all non-white connected components, sorted by size descending\n    all_components = find_all_components(input_grid)\n\n    # 9. Handle edge case: If no non-white components exist, return original grid\n    if not all_components:\n        return output_grid\n\n    # 2. Identify the largest component (the 'frame') and its color\n    frame_component = all_components[0]\n    frame_color = frame_component[0]\n    # frame_coords = frame_component[1] # Not directly needed after barrier/internal sets built\n\n    # 3. Identify internal objects (all components except the frame)\n    internal_object_coords = set()\n    if len(all_components) > 1:\n        for _, coords in all_components[1:]: # Skip the first (largest) component\n            internal_object_coords.update(coords)\n\n    # 4. Create a single set of barrier coordinates from ALL non-white components\n    barrier_coords = set()\n    for _, coords in all_components:\n        barrier_coords.update(coords)\n\n    # 5. Find all white pixels reachable from the border, avoiding barriers\n    reachable_white_coords = find_reachable_white(input_grid, barrier_coords)\n\n    # 6. Find all white pixels orthogonally adjacent to internal objects\n    protected_white_coords = find_protected_white(input_grid, internal_object_coords)\n\n    # 7. & 8. Fill the 'internal fillable' white pixels\n    # Iterate through every cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            coord = (r, c)\n            # Check if the pixel is white in the original input grid\n            if input_grid[r, c] == 0:\n                # Check if this white pixel is NOT reachable from border AND NOT protected\n                if coord not in reachable_white_coords and coord not in protected_white_coords:\n                    # This is an internal, fillable white pixel. Fill it.\n                    output_grid[r, c] = frame_color\n            # Else (if it's non-white, reachable white, or protected white),\n            # it keeps its original color (already handled by copying input_grid)\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7396,
    "candidates_token_count": 2193,
    "total_token_count": 9589,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.168545,
  "retries": null
}