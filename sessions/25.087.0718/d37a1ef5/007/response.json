{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Find all separate connected groups (objects) of non-white pixels in the input grid, using 4-way (up, down, left, right) connections.\n2. If no non-white objects exist, return the input grid unchanged.\n3. Identify the object with the most pixels; this is the 'frame'. Note its color ('frame_color').\n4. Identify all other non-white objects besides the frame; these are the 'internal objects'. Create a set of coordinates for all pixels belonging to internal objects ('internal_object_coords').\n5. Create the output grid as a copy of the input grid.\n6. Iterate through every pixel location (r, c) in the input grid.\n7. If the pixel at (r, c) in the *input* grid is white (color 0):\n    a. Perform a flood fill (BFS) starting from (r, c), visiting only adjacent white pixels (4-way).\n    b. Determine if this flood fill reaches the border of the grid.\n    c. If the flood fill *does not* reach the border (i.e., the white area is enclosed):\n        i. Check if the original white pixel (r, c) is orthogonally adjacent to any pixel in `internal_object_coords`.\n        ii. If the white pixel (r, c) is enclosed AND *not* adjacent to any internal object pixel, change the color of the pixel at (r, c) in the *output* grid to `frame_color`.\n8. Return the output grid.\n\"\"\"\n\ndef find_all_components(grid):\n    \"\"\"\n    Finds all connected components of non-white pixels using 4-way adjacency.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples [(color, coords_set), ...], where each tuple\n        represents a connected non-white component. Returns an empty list\n        if no non-white pixels are found. Components are sorted by size descending.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    all_components = [] # List to store (color, coords_set)\n    non_white_coords = set() # Keep track of all non-white coords for faster lookup\n\n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is non-white and hasn't been visited as part of a component yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start a BFS to find the connected component\n                component_color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark starting cell visited\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    non_white_coords.add((row, col)) # Add to overall non-white set\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                           # Check if neighbor has the same color and hasn't been visited\n                           # Optimization: Check if it's non-white first\n                           if grid[nr, nc] == component_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store the found component (color and its coordinates)\n                if component_coords: # Should always be true here\n                    all_components.append((component_color, component_coords))\n\n    # Sort components by size (number of coordinates) in descending order\n    all_components.sort(key=lambda item: len(item[1]), reverse=True)\n\n    return all_components, non_white_coords\n\n\ndef check_white_pixel_enclosure_and_adjacency(r, c, grid, non_white_coords, internal_object_coords):\n    \"\"\"\n    Checks if a starting white pixel (r, c) belongs to an enclosed white area\n    and if it's adjacent to any internal object.\n\n    Args:\n        r: Starting row of the white pixel.\n        c: Starting column of the white pixel.\n        grid: The input numpy grid.\n        non_white_coords: A set of all non-white pixel coordinates.\n        internal_object_coords: A set of coordinates for internal objects.\n\n    Returns:\n        A tuple (is_enclosed, is_adjacent_to_internal):\n        - is_enclosed (bool): True if the white area containing (r,c) does not reach the border.\n        - is_adjacent_to_internal (bool): True if the pixel (r,c) is orthogonally adjacent\n          to any internal object pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque([(r, c)])\n    visited_white = set([(r, c)])\n    reaches_border = False\n\n    # Check initial adjacency to internal objects\n    is_adjacent_to_internal = False\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if (nr, nc) in internal_object_coords:\n            is_adjacent_to_internal = True\n            break # Found one adjacent internal pixel, no need to check others\n\n    # BFS to check if the white area reaches the border\n    while q:\n        curr_r, curr_c = q.popleft()\n\n        # Check if current pixel is on the border\n        if curr_r == 0 or curr_r == rows - 1 or curr_c == 0 or curr_c == cols - 1:\n            reaches_border = True\n            # We can stop the BFS early if border is reached, as we only need to know *if* it reaches\n            break\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n            neighbor_coord = (nr, nc)\n\n            # Check bounds, if it's white, and not visited in *this specific BFS*\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               neighbor_coord not in non_white_coords and \\\n               neighbor_coord not in visited_white:\n                visited_white.add(neighbor_coord)\n                q.append(neighbor_coord)\n\n    is_enclosed = not reaches_border\n    return is_enclosed, is_adjacent_to_internal\n\n\ndef transform(input_grid):\n    \"\"\"Applies the transformation rule to the input grid.\"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify all non-white connected components and all non-white coords\n    all_components, non_white_coords = find_all_components(input_grid)\n\n    # 2. Handle edge case: If no non-white components exist, return original grid\n    if not all_components:\n        return output_grid\n\n    # 3. Identify the largest component (the 'frame') and its color\n    frame_component = all_components[0]\n    frame_color = frame_component[0]\n    # frame_coords = frame_component[1] # Not directly needed now\n\n    # 4. Identify internal objects and collect their coordinates\n    internal_object_coords = set()\n    if len(all_components) > 1:\n        for _, coords in all_components[1:]: # Skip the first (largest) component\n            internal_object_coords.update(coords)\n\n    # 5. Output grid is already initialized\n\n    # 6. & 7. Iterate through each pixel\n    for r in range(rows):\n        for c in range(cols):\n            coord = (r, c)\n            # Check if the pixel is white in the original input grid\n            if input_grid[r, c] == 0:\n                # Check if this white pixel is enclosed and not adjacent to internal objects\n                is_enclosed, is_adjacent = check_white_pixel_enclosure_and_adjacency(\n                    r, c, input_grid, non_white_coords, internal_object_coords\n                )\n\n                # 7.c.ii: Fill if enclosed and NOT adjacent to internal\n                if is_enclosed and not is_adjacent:\n                    output_grid[r, c] = frame_color\n\n    # 8. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5669,
    "candidates_token_count": 2082,
    "total_token_count": 7751,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 103.524451,
  "retries": null
}