{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies the largest connected non-background object in the input grid. \nDetermines a \"characteristic color\" based on the most frequent color among the \nobject's border pixels (pixels adjacent to background/edge). Transforms the \ncolors of all pixels within this largest object based on specific rules dictated \nby the characteristic color:\n- If characteristic_color=Azure(8): Swap Red(2)<->Green(3), Swap Blue(1)<->Yellow(4).\n- If characteristic_color=Green(3): Blue(1)->Red(2), Gray(5)->Yellow(4), Azure(8)->Magenta(6).\n- If characteristic_color=Blue(1): Yellow(4)->Red(2), Azure(8)->Green(3).\nOther colors within the object remain unchanged. The output grid contains only \nthe transformed target object, cropped to its bounding box.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid_np):\n    \"\"\"\n    Finds all connected components (objects) of non-background pixels (1-9) \n    in the grid using Breadth-First Search (BFS). Considers 8-way adjacency \n    (including diagonals).\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object \n              and contains:\n              - 'pixels': set of (row, col) tuples for the object's pixels.\n              - 'size': integer count of pixels in the object.\n              - 'bb': tuple (min_row, min_col, max_row, max_col) bounding box.\n    \"\"\"\n    height, width = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if pixel is non-background and not visited\n            if grid_np[r, c] != 0 and not visited[r, c]:\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels.add((r, c))\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is non-background and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid_np[nr, nc] != 0 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                current_object_pixels.add((nr, nc))\n                                q.append((nr, nc))\n                                \n                # Store found object details\n                if current_object_pixels:\n                    objects.append({\n                        'pixels': current_object_pixels,\n                        'size': len(current_object_pixels),\n                        'bb': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef get_border_pixels(grid_np, obj_pixels):\n    \"\"\"\n    Identifies the border pixels of a given object. A border pixel is an object \n    pixel that is adjacent (8-way) to a background pixel (0) or the grid edge.\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n        obj_pixels (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        set: A set of (row, col) tuples representing the border pixels.\n    \"\"\"\n    height, width = grid_np.shape\n    border_pixels = set()\n    for r, c in obj_pixels:\n        is_border = False\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                # Check if neighbor is outside grid bounds or is background (0)\n                if not (0 <= nr < height and 0 <= nc < width) or \\\n                   grid_np[nr, nc] == 0:\n                    is_border = True\n                    break # Found a condition making it a border pixel\n        if is_border:\n             border_pixels.add((r, c))\n             \n    # Ensure even single-pixel objects touching background are counted\n    if not border_pixels and len(obj_pixels) > 0:\n         r,c = next(iter(obj_pixels)) # Get any pixel from the object\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 if dr == 0 and dc == 0: continue\n                 nr, nc = r + dr, c + dc\n                 if not (0 <= nr < height and 0 <= nc < width) or grid_np[nr, nc] == 0:\n                     # If any neighbor is background/edge, the whole (small) object counts as border\n                      return obj_pixels\n\n\n    return border_pixels\n\ndef get_characteristic_color(grid_np, border_pixels):\n    \"\"\"\n    Determines the characteristic color by finding the most frequent color \n    among the border pixels. Ties are broken by choosing the smallest color index.\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n        border_pixels (set): The set of border pixels for the target object.\n\n    Returns:\n        int: The characteristic color index, or -1 if no border pixels exist.\n    \"\"\"\n    if not border_pixels:\n        return -1 \n    \n    # Get colors of the border pixels\n    border_colors = [grid_np[r, c] for r, c in border_pixels]\n    if not border_colors:\n        return -1\n\n    # Count frequencies of each color\n    color_counts = Counter(border_colors)\n    \n    # Find the most common color(s)\n    # Sort by frequency (descending) then by color index (ascending) for tie-breaking\n    most_common = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n    \n    # Return the color index of the most frequent (and smallest in case of tie)\n    return most_common[0][0]\n\ndef transform_pixel_color(original_color, characteristic_color):\n    \"\"\"\n    Applies color transformation rules based on the characteristic color.\n\n    Args:\n        original_color (int): The original color index of the pixel.\n        characteristic_color (int): The determined characteristic color for the object.\n\n    Returns:\n        int: The transformed color index.\n    \"\"\"\n    if characteristic_color == 8: # Azure border -> Azure rules\n        if original_color == 2: return 3 # Red -> Green\n        if original_color == 3: return 2 # Green -> Red\n        if original_color == 1: return 4 # Blue -> Yellow\n        if original_color == 4: return 1 # Yellow -> Blue\n    elif characteristic_color == 3: # Green border -> Green rules\n        if original_color == 1: return 2 # Blue -> Red\n        if original_color == 5: return 4 # Gray -> Yellow\n        if original_color == 8: return 6 # Azure -> Magenta\n    elif characteristic_color == 1: # Blue border -> Blue rules\n        if original_color == 4: return 2 # Yellow -> Red\n        if original_color == 8: return 3 # Azure -> Green\n        \n    # If no specific rule applies for the characteristic color / original color combo,\n    # or if characteristic color isn't one of the special cases (1, 3, 8),\n    # return the original color.\n    return original_color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the described logic: find the largest \n    object, determine its characteristic border color, transform all its pixels \n    based on rules associated with that color, and return the cropped, \n    transformed object.\n\n    Args:\n        input_grid (list of list of int): The input grid.\n\n    Returns:\n        list of list of int: The transformed output grid.\n    \"\"\"\n    # Convert input to NumPy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Find all non-background objects\n    objects = find_objects(input_grid_np)\n\n    # Handle case with no objects found\n    if not objects:\n        return [[]] # Return empty grid as per ARC convention maybe?\n\n    # 2. Select the largest object\n    # If sizes are equal, find_objects order + max will pick one deterministically.\n    target_object = max(objects, key=lambda obj: obj['size'])\n    target_pixels = target_object['pixels']\n    min_r, min_c, max_r, max_c = target_object['bb']\n\n    # 3. Determine the border pixels of the target object\n    border_pixels = get_border_pixels(input_grid_np, target_pixels)\n\n    # 4. Find the characteristic color from the border pixels\n    characteristic_color = get_characteristic_color(input_grid_np, border_pixels)\n\n    # Handle edge case where characteristic color couldn't be determined (e.g., no border pixels found)\n    if characteristic_color == -1:\n         # This case seems unlikely based on examples for the largest object, \n         # but if it happens, maybe return the object untransformed? Or empty?\n         # Let's return it untransformed for now as a fallback.\n         output_height = max_r - min_r + 1\n         output_width = max_c - min_c + 1\n         output_grid = np.zeros((output_height, output_width), dtype=int)\n         for r, c in target_pixels:\n              out_r, out_c = r - min_r, c - min_c\n              output_grid[out_r, out_c] = input_grid_np[r,c]\n         return output_grid.tolist()\n\n\n    # 5. Create the output grid based on the target object's bounding box\n    output_height = max_r - min_r + 1\n    output_width = max_c - min_c + 1\n    # Initialize with background color (0)\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # 6. Iterate through *all* pixels of the target object and apply transformation\n    for r, c in target_pixels:\n        # Get original color\n        original_color = input_grid_np[r, c]\n        \n        # 7. Apply transformation rule based on characteristic color\n        transformed_color = transform_pixel_color(original_color, characteristic_color)\n        \n        # 8. Place transformed color in the output grid at relative coordinates\n        out_r = r - min_r\n        out_c = c - min_c\n        output_grid[out_r, out_c] = transformed_color\n            \n    # 9. Return the final cropped and transformed grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10970,
    "candidates_token_count": 2804,
    "total_token_count": 13774,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.234312,
  "retries": null
}