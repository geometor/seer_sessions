{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nIdentifies the smallest bounding box containing all non-background (non-zero) pixels in the input grid.\nThis bounding box defines the 'pattern'.\nCalculates the 90, 180, and 270 degree clockwise rotations of this pattern.\nConstructs an output grid large enough to hold the original pattern and its rotations arranged in a specific cross shape.\nThe output grid dimensions are determined by the pattern's height (h) and width (w): output height = 2h + w, output width = 2w + h.\nThe patterns are placed in the output grid as follows, where (row, col) indicates the top-left corner of placement:\n- 90-degree rotation (P90): Placed at (0, w).\n- Original pattern (P): Placed at (w, 0).\n- 180-degree rotation (P180): Placed at (w, w + h).\n- 270-degree rotation (P270): Placed at (w + h, w).\nThe remaining areas of the output grid are filled with the background color (0).\n\"\"\"\n\ndef find_pattern_bbox(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"Finds the minimum bounding box containing all non-zero pixels.\"\"\"\n    non_zero_coords = np.argwhere(grid != 0)\n    if non_zero_coords.size == 0:\n        # Handle empty grid or grid with only background color\n        return 0, 0, 0, 0 \n    min_row = non_zero_coords[:, 0].min()\n    max_row = non_zero_coords[:, 0].max()\n    min_col = non_zero_coords[:, 1].min()\n    max_col = non_zero_coords[:, 1].max()\n    return min_row, min_col, max_row, max_col\n\ndef extract_pattern(grid: np.ndarray, bbox: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the subgrid defined by the bounding box.\"\"\"\n    min_row, min_col, max_row, max_col = bbox\n    # Handle case where bbox might be invalid for empty grids\n    if max_row < min_row or max_col < min_col:\n        return np.array([[]], dtype=grid.dtype)\n    return grid[min_row:max_row + 1, min_col:max_col + 1]\n\ndef rotate_grid(grid: np.ndarray, degrees: int) -> np.ndarray:\n    \"\"\"Rotates the grid clockwise by the specified degrees (90, 180, 270).\"\"\"\n    if degrees == 90:\n        k = 3  # np.rot90 rotates counter-clockwise, so 3 times CCW = 1 time CW\n    elif degrees == 180:\n        k = 2\n    elif degrees == 270:\n        k = 1\n    else:\n        # No rotation or invalid degrees\n        return grid\n    return np.rot90(grid, k=k)\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by extracting a pattern, rotating it, and arranging\n    the original and rotated patterns in a cross shape on a larger grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # Find the bounding box of the non-background pixels\n    bbox = find_pattern_bbox(input_np)\n    \n    # Handle edge case: grid is all background\n    if bbox == (0, 0, 0, 0) and np.all(input_np == 0):\n         # Check if the input grid actually contains non-zero elements before declaring empty\n        non_zero_coords_check = np.argwhere(input_np != 0)\n        if non_zero_coords_check.size == 0:\n            # If truly empty, return an empty grid or based on specific requirement (e.g., 1x1 of background)\n            # Based on examples, an empty input likely doesn't occur, but robust code handles it.\n            # Let's assume it should return an empty representation if pattern is empty.\n            # Or, if the input is just 0s, maybe return 0s of same size? Task implies a pattern exists.\n            # Let's follow the derived output size logic, even if pattern is empty (0x0).\n            h, w = 0, 0\n            output_h = 2 * h + w\n            output_w = 2 * w + h\n            return np.zeros((output_h, output_w), dtype=int).tolist()\n\n\n    # Extract the pattern P\n    pattern = extract_pattern(input_np, bbox)\n    \n    # Check if pattern extraction yielded something meaningful\n    if pattern.size == 0:\n        # This case might happen if bbox was calculated but resulted in empty slice\n        # Fallback to treating it as an all-background grid scenario\n        h, w = 0, 0\n        output_h = 2 * h + w\n        output_w = 2 * w + h\n        return np.zeros((output_h, output_w), dtype=int).tolist()\n        \n    h, w = pattern.shape\n\n    # Calculate rotated versions\n    p90 = rotate_grid(pattern, 90)   # Size w x h\n    p180 = rotate_grid(pattern, 180) # Size h x w\n    p270 = rotate_grid(pattern, 270) # Size w x h\n\n    # Determine output grid size\n    output_h = 2 * h + w\n    output_w = 2 * w + h\n\n    # Initialize output grid with background color (0)\n    output_grid = np.zeros((output_h, output_w), dtype=int)\n\n    # Place the patterns into the output grid\n    \n    # Place P90 (w x h) at (0, w)\n    if p90.size > 0: # Ensure pattern is not empty before slicing\n        output_grid[0:w, w:w + h] = p90\n\n    # Place P (h x w) at (w, 0)\n    if pattern.size > 0:\n        output_grid[w:w + h, 0:w] = pattern\n\n    # Place P180 (h x w) at (w, w + h)\n    if p180.size > 0:\n        output_grid[w:w + h, w + h:w + h + w] = p180 # Corrected end column index\n\n    # Place P270 (w x h) at (w + h, w)\n    if p270.size > 0:\n        output_grid[w + h:w + h + w, w:w + h] = p270 # Corrected end row index\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4107,
    "candidates_token_count": 1682,
    "total_token_count": 5789,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.56819,
  "retries": null
}