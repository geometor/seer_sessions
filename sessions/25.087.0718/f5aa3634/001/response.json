{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentify all distinct object patterns within the input grid. An object pattern is defined as the smallest rectangular subgrid (bounding box) enclosing a connected component of non-background (non-zero) pixels, including any background (zero) pixels within that rectangle. Count the occurrences of each unique pattern. Select the pattern that appears exactly two times. If multiple patterns appear twice, this rule might need refinement, but based on examples, we assume only one does. Among the two instances of the selected pattern, identify the one whose top-left corner has the minimum row index, breaking ties with the minimum column index. The output grid is this specific instance's pattern subgrid.\n\"\"\"\n\ndef _find_patterns_and_locations(grid):\n    \"\"\"\n    Finds all object patterns and their locations in the grid.\n\n    An object is a connected component of non-background pixels.\n    A pattern is the rectangular bounding box containing the object,\n    including any background pixels within the box.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are pattern tuples (tuple of tuples)\n              and values are lists of (row, col) tuples representing the\n              top-left coordinates of each occurrence.\n    \"\"\"\n    patterns = defaultdict(list)\n    visited = set()\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            # Check if the cell is non-background and not yet visited as part of an object\n            if grid[r, c] != 0 and (r, c) not in visited:\n                # Found the start of a potential new object\n                component_cells = set()\n                q = [(r, c)]\n                visited.add((r, c))\n                component_cells.add((r,c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform BFS to find all connected non-background cells (8-way connectivity)\n                while q:\n                    curr_r, curr_c = q.pop(0)\n\n                    # Update bounding box coordinates\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds and if neighbor is non-background and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] != 0 and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                component_cells.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Extract the pattern (bounding box)\n                pattern_grid = grid[min_r:max_r+1, min_c:max_c+1]\n                # Convert numpy array to tuple of tuples for hashability\n                pattern_tuple = tuple(map(tuple, pattern_grid))\n\n                # Record the pattern and its top-left location\n                patterns[pattern_tuple].append((min_r, min_c))\n\n    return patterns\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Identifies the unique object pattern occurring exactly twice in the input grid\n    and returns the instance that appears first (top-most, then left-most).\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The extracted output grid corresponding to the first instance\n                    of the pattern that occurs exactly twice.\n    \"\"\"\n    # 1. Find all distinct patterns and their locations\n    patterns_locations = _find_patterns_and_locations(input_grid)\n\n    # 2. Identify the pattern that occurs exactly twice\n    target_pattern_tuple = None\n    target_locations = []\n    for pattern, locations in patterns_locations.items():\n        if len(locations) == 2:\n            target_pattern_tuple = pattern\n            target_locations = locations\n            break # Assume only one such pattern exists per examples\n\n    if target_pattern_tuple is None:\n        # Handle the case where no pattern occurs exactly twice (e.g., return empty or raise error)\n        # Based on the examples, this shouldn't happen for valid inputs.\n        print(\"Warning: No pattern found occurring exactly twice.\")\n        # Returning the input might be a safe default, or an empty grid. Let's return empty.\n        return np.array([[]], dtype=int)\n\n\n    # 3. Sort the locations to find the first occurrence (min row, then min col)\n    # The sort key is a tuple (row, col), Python sorts tuples element by element.\n    sorted_locations = sorted(target_locations)\n    first_location = sorted_locations[0] # Not strictly needed, just for clarity\n\n    # 4. The output grid is the pattern itself\n    # Convert the target pattern tuple back to a numpy array\n    output_grid = np.array(target_pattern_tuple, dtype=int)\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2971,
    "candidates_token_count": 1256,
    "total_token_count": 4227,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 88.220106,
  "retries": null
}