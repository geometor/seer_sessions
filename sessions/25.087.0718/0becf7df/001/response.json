{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify two distinct non-white objects in the input grid. One object's bounding \nbox includes the top-left corner (0,0) (source object), and the other does not \n(target object). Extract the four unique non-white colors from the source object \nand sort them numerically: [c1, c2, c3, c4]. Determine the color swapping rule \nbased on whether c1 + c4 == c2 + c3. If true, swaps are (c1, c4) and (c2, c3). \nIf false, swaps are (c1, c3) and (c2, c4). Apply these swaps to the pixels \nwithin the target object only. The source object and background remain unchanged.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds contiguous regions of non-white pixels (objects) in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates\n              of the pixels belonging to one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-white pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is part of the same object\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != 0 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                obj_coords.add((nr, nc))\n                                q.append((nr, nc))\n                objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(object_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\n\n    Args:\n        object_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.\n    \"\"\"\n    if not object_coords:\n        return None\n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_unique_colors(grid, object_coords):\n    \"\"\"\n    Extracts unique non-white colors from specified coordinates within the grid.\n\n    Args:\n        grid (np.ndarray): The grid.\n        object_coords (set): A set of (row, col) coordinates for the object.\n\n    Returns:\n        list: Sorted list of unique non-white colors.\n    \"\"\"\n    colors = set()\n    for r, c in object_coords:\n        color = grid[r, c]\n        if color != 0:\n            colors.add(color)\n    return sorted(list(colors))\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color swapping transformation based on the rules derived from examples.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Initialize output as a copy of input\n\n    # 1. Find all distinct non-white objects\n    objects = find_objects(grid)\n\n    if len(objects) != 2:\n        # Assumption based on examples: there are always exactly two objects\n        # If not, return the input unchanged or handle error appropriately\n        print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning input.\")\n        return input_grid \n\n    # 2. & 3. Identify source and target objects\n    source_object_coords = None\n    target_object_coords = None\n\n    for obj_coords in objects:\n        bbox = get_bounding_box(obj_coords)\n        if bbox is None: continue # Should not happen if find_objects works correctly\n        min_r, min_c, _, _ = bbox\n        # Check if the bounding box includes (0, 0)\n        if min_r == 0 and min_c == 0:\n            # Check if (0,0) itself is part of the object, not just the bbox\n            if (0, 0) in obj_coords:\n                 source_object_coords = obj_coords\n            else: \n                # If (0,0) is not in the object but in the bbox, search further\n                # Check if any coordinate in obj_coords is (0,0)\n                is_source = False\n                for r_coord, c_coord in obj_coords:\n                    if r_coord == 0 and c_coord == 0:\n                        is_source = True\n                        break\n                if is_source:\n                    source_object_coords = obj_coords\n                else:\n                     target_object_coords = obj_coords # If not source, must be target\n        else:\n            target_object_coords = obj_coords\n\n    if source_object_coords is None or target_object_coords is None:\n        print(\"Warning: Could not identify both source and target objects. Returning input.\")\n        # Fallback: Try identifying based purely on bounding box including (0,0)\n        # This might be needed if the (0,0) pixel itself is background\n        source_object_coords = None\n        target_object_coords = None\n        for obj_coords in objects:\n            bbox = get_bounding_box(obj_coords)\n            if bbox is None: continue\n            min_r, min_c, _, _ = bbox\n            if min_r == 0 and min_c == 0:\n                source_object_coords = obj_coords\n            else:\n                target_object_coords = obj_coords\n        if source_object_coords is None or target_object_coords is None:\n             print(\"Warning: Still could not identify both source and target objects. Returning input.\")\n             return input_grid\n\n\n    # 4. & 5. Get and sort unique colors from the source object\n    source_colors = get_unique_colors(grid, source_object_coords)\n\n    if len(source_colors) != 4:\n        # Assumption based on examples: source object always has 4 unique non-white colors\n        print(f\"Warning: Expected 4 unique colors in source object, found {len(source_colors)}. Returning input.\")\n        return input_grid\n\n    c1, c2, c3, c4 = source_colors\n\n    # 6. Determine swap pairs\n    swap_map = {}\n    if c1 + c4 == c2 + c3:\n        # Pairs are (c1, c4) and (c2, c3)\n        swap_map[c1] = c4\n        swap_map[c4] = c1\n        swap_map[c2] = c3\n        swap_map[c3] = c2\n    else:\n        # Pairs are (c1, c3) and (c2, c4)\n        swap_map[c1] = c3\n        swap_map[c3] = c1\n        swap_map[c2] = c4\n        swap_map[c4] = c2\n\n    # 7. & 8. Apply swaps to the target object in the output grid\n    for r, c in target_object_coords:\n        current_color = grid[r, c]\n        if current_color in swap_map:\n            output_grid[r, c] = swap_map[current_color]\n        # If color is not in swap_map (e.g., it's 0, or not one of the 4 source colors),\n        # it remains unchanged because output_grid started as a copy.\n\n    # 9. Source object and background are already correct in the copied grid.\n\n    # 10. Return the final grid\n    return output_grid.tolist() # Convert back to list of lists if needed\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3829,
    "candidates_token_count": 2026,
    "total_token_count": 5855,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.957973,
  "retries": null
}