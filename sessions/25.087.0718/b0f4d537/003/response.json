{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n# Constants for colors\nWHITE = 0\nBLUE = 1\nRED = 2\nGREEN = 3\nYELLOW = 4\nGRAY = 5\n\n\"\"\"\nThe transformation rule depends on the location (left or right of a central gray vertical line) of 'significant' colors (Red or Green).\n\n1.  **Find Separator**: Identify the vertical column composed entirely of gray pixels (5). This divides the grid into left and right parts.\n2.  **Determine Case**: Check if Red (2) or Green (3) pixels exist exclusively on the left side or exclusively on the right side of the gray separator.\n    *   **Case A (Left)**: If Red or Green appear only on the left side.\n    *   **Case B (Right)**: If Red or Green appear only on the right side.\n\n3.  **Transformation Logic**:\n\n    *   **Case A (Left Side Rule)**:\n        a.  Create an output grid with the same height as the input and a fixed width of 7, initialized to White (0).\n        b.  Set the central column (index 3) of the output grid entirely to Blue (1).\n        c.  Iterate through each row `r` of the input grid:\n            i.  Examine the portion of the input row `r` to the left of the gray separator.\n            ii. If Red (2) is present in this left portion, fill all cells in the corresponding output row `r`, *except* the central column (index 3), with Red (2).\n            iii.Else if Green (3) is present in this left portion, fill all cells in the corresponding output row `r`, *except* the central column (index 3), with Green (3).\n            iv. Otherwise (if neither Red nor Green is present on the left), the output row `r` remains White (0) in the non-central columns and Blue (1) in the center.\n\n    *   **Case B (Right Side Rule)**:\n        a.  Create an output grid with the same height as the input and a fixed width of 7, initialized to White (0).\n        b.  **Find Pattern Row**: Locate the row (`pattern_r`) in the input grid that contains Blue (1) pixels *to the right* of the gray separator. Extract the segment of this row to the right of the separator as the `pattern_p`.\n        c.  **Find Special Row**: Identify the row index (`yellow_r`) in the input grid which has the *maximum number* of Yellow (4) pixels *to the left* of the gray separator. This row determines the unique row in the output.\n        d.  **Fill Fixed Columns**: Determine two colors from the `pattern_p`. The color at index 1 of `pattern_p` dictates the color for the entire output column 2. The color at index 3 of `pattern_p` dictates the color for the entire output column 4.\n        e.  **Fill Special Row**: Populate the output row `yellow_r` based on an expanded version of `pattern_p`. Specifically:\n            - output[yellow_r, 0] = pattern_p[0]\n            - output[yellow_r, 1] = pattern_p[0]\n            - output[yellow_r, 2] = pattern_p[1] (already set in step 3d)\n            - output[yellow_r, 3] = pattern_p[2]\n            - output[yellow_r, 4] = pattern_p[3] (already set in step 3d)\n            - output[yellow_r, 5] = pattern_p[4]\n            - output[yellow_r, 6] = pattern_p[4]\n        f.  All other rows in the output (rows != `yellow_r`) retain their White (0) background in the columns not set in step 3d (columns 0, 1, 3, 5, 6).\n\n\"\"\"\n\ndef find_gray_separator(grid):\n    \"\"\"Finds the index of the first column composed entirely of GRAY pixels.\"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        # Check if all elements in the column are GRAY\n        if np.all(grid[:, c] == GRAY):\n            return c\n    # Return -1 if no such column is found (should not happen based on examples)\n    return -1\n\ndef check_significant_color_location(grid, sep_col):\n    \"\"\"Checks if Red(2) or Green(3) are present left or right of the separator.\"\"\"\n    height, width = grid.shape\n    # Define the significant colors\n    sig_colors = {RED, GREEN}\n\n    # Check left side (columns before separator)\n    left_colors = set()\n    if sep_col > 0:\n        left_colors = set(grid[:, :sep_col].flatten())\n    left_has_sig = bool(sig_colors.intersection(left_colors))\n\n    # Check right side (columns after separator)\n    right_colors = set()\n    if sep_col < width - 1:\n        right_colors = set(grid[:, sep_col+1:].flatten())\n    right_has_sig = bool(sig_colors.intersection(right_colors))\n\n    # Determine location based on exclusive presence\n    if left_has_sig and not right_has_sig:\n        return \"left\"\n    elif right_has_sig and not left_has_sig:\n        return \"right\"\n    elif left_has_sig and right_has_sig:\n         # This case wasn't explicitly in examples, assume 'left' as priority or handle error\n         # Based on re-evaluation, examples seem mutually exclusive.\n         # Let's treat this as ambiguous for now.\n         print(\"Warning: Significant colors found on both sides.\")\n         return \"ambiguous\"\n    else:\n        # No significant colors found anywhere\n        return \"none\"\n\ndef transform_case_a(input_grid, sep_col):\n    \"\"\"Handles transformation when significant colors (Red/Green) are on the left.\"\"\"\n    height, width = input_grid.shape\n    output_height = height\n    output_width = 7\n    # Initialize output grid with white background\n    output_grid = np.full((output_height, output_width), WHITE, dtype=int)\n\n    # Set the central column (index 3) to blue\n    output_grid[:, 3] = BLUE\n\n    # Process each row based on colors found on the left side\n    for r in range(height):\n        # Extract the segment of the row left of the separator\n        if sep_col > 0:\n             left_row_segment = input_grid[r, :sep_col]\n        else:\n             left_row_segment = np.array([]) # Handle edge case where separator is column 0\n\n        fill_color = WHITE # Default fill color if no significant color found\n        if RED in left_row_segment:\n            fill_color = RED\n        elif GREEN in left_row_segment:\n            fill_color = GREEN\n        # Else: fill_color remains WHITE\n\n        # Fill the non-central columns of the output row if needed\n        if fill_color != WHITE:\n            for c in range(output_width):\n                if c != 3: # Do not overwrite the central blue column\n                    output_grid[r, c] = fill_color\n            # Note: central column remains blue\n\n    return output_grid\n\ndef find_max_yellow_row(grid, sep_col):\n    \"\"\"Finds the index of the row with the most YELLOW pixels left of the separator.\"\"\"\n    height = grid.shape[0]\n    max_yellow_count = -1\n    yellow_r = -1\n    if sep_col <= 0: # No left side to check\n        return -1\n        \n    for r in range(height):\n        left_row_segment = grid[r, :sep_col]\n        # Count occurrences of YELLOW in the left segment\n        yellow_count = np.count_nonzero(left_row_segment == YELLOW)\n        # Update if this row has more yellow pixels than the current max\n        if yellow_count > 0 and yellow_count >= max_yellow_count: # >= handles ties, preferring later rows if counts equal\n             # Small correction: if counts are equal, maybe prefer first row? Let's stick to \">\" first.\n             # After checking Example 4, it seems just \">\" is sufficient if there's a unique max.\n             # Let's try >= to be robust against ties, taking the last one. If that fails, revert to >.\n             # Reverting to > as the original logic implicitly picked the unique max row 4 in example 4.\n             # If yellow_count > max_yellow_count: -> This seems safer if a unique max exists.\n             if yellow_count > max_yellow_count:\n                 max_yellow_count = yellow_count\n                 yellow_r = r\n                 \n    # If max_yellow_count is still 0 (or -1), no yellow was found\n    if max_yellow_count <= 0:\n        return -1 # Indicate no suitable yellow row found\n\n    return yellow_r\n\n\ndef transform_case_b(input_grid, sep_col):\n    \"\"\"Handles transformation when significant colors (Red/Green) are on the right.\"\"\"\n    height, width = input_grid.shape\n    output_height = height\n    output_width = 7\n    # Initialize output grid with white background\n    output_grid = np.full((output_height, output_width), WHITE, dtype=int)\n\n    # --- Find pattern row (contains BLUE on right side) ---\n    pattern_r = -1\n    pattern_p = None\n    if sep_col < width - 1:\n        for r in range(height):\n            # Extract segment right of separator\n            right_row_segment = input_grid[r, sep_col+1:]\n            # Check if Blue exists in this segment\n            if BLUE in right_row_segment:\n                pattern_r = r\n                pattern_p = right_row_segment\n                break # Found the first pattern row\n\n    if pattern_p is None:\n        print(f\"Error: Pattern row (with Blue right of col {sep_col}) not found.\")\n        return output_grid # Return empty grid or handle error appropriately\n\n    # --- Find special output row (row with max YELLOW on left side) ---\n    yellow_r = find_max_yellow_row(input_grid, sep_col)\n\n    if yellow_r == -1:\n        print(f\"Error: Yellow row (left of col {sep_col}) not found or none had max count.\")\n        return output_grid # Return empty grid or handle error appropriately\n\n    # --- Determine fixed column colors from pattern P ---\n    # Ensure pattern has enough elements for indices 1 and 3\n    if len(pattern_p) < 4:\n         print(f\"Error: Pattern P (length {len(pattern_p)}) is too short for column definition.\")\n         return output_grid\n\n    fixed_col_2_color = pattern_p[1] # Color for output column 2\n    fixed_col_4_color = pattern_p[3] # Color for output column 4\n\n    # --- Fill fixed columns ---\n    output_grid[:, 2] = fixed_col_2_color\n    output_grid[:, 4] = fixed_col_4_color\n\n    # --- Fill the special row (yellow_r) based on expanded pattern P ---\n    # Ensure pattern has enough elements for indices 0, 2, 4\n    if len(pattern_p) < 5:\n         print(f\"Error: Pattern P (length {len(pattern_p)}) is too short for special row fill.\")\n         # We might still be able to fill columns, but not the special row fully.\n         # Let's return the grid with columns filled but potentially incomplete special row.\n         return output_grid\n\n    # Fill cells in the special row 'yellow_r'\n    output_grid[yellow_r, 0] = pattern_p[0]\n    output_grid[yellow_r, 1] = pattern_p[0]\n    # output_grid[yellow_r, 2] is already set by column fill\n    output_grid[yellow_r, 3] = pattern_p[2]\n    # output_grid[yellow_r, 4] is already set by column fill\n    output_grid[yellow_r, 5] = pattern_p[4]\n    output_grid[yellow_r, 6] = pattern_p[4]\n\n    # --- Rows other than yellow_r keep WHITE background in non-fixed columns ---\n    # This is already handled by initializing with WHITE and only filling fixed columns\n    # and the specific special row.\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the location of Red/Green relative\n    to a vertical gray line.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Find the gray separator column\n    sep_col = find_gray_separator(input_grid_np)\n    if sep_col == -1:\n        print(\"Error: Gray separator column not found.\")\n        # Return a default grid or original if separator is mandatory but missing\n        # Let's return an empty grid of expected size as a fallback.\n        # Size might vary, let's default to 7 width and original height\n        return np.full((height, 7), WHITE, dtype=int).tolist()\n\n    # 2. Determine location of significant colors (Red=2, Green=3)\n    location = check_significant_color_location(input_grid_np, sep_col)\n\n    # 3. Apply transformation based on location\n    if location == \"left\":\n        output_grid_np = transform_case_a(input_grid_np, sep_col)\n    elif location == \"right\":\n        output_grid_np = transform_case_b(input_grid_np, sep_col)\n    elif location == \"ambiguous\":\n         print(\"Ambiguous case: Significant colors on both sides. No defined transformation.\")\n         # Return default/empty grid\n         output_grid_np = np.full((height, 7), WHITE, dtype=int)\n    else: # location == \"none\"\n        print(\"Warning: Significant colors (Red/Green) not found.\")\n        # Define behavior if no Red/Green found. Maybe return Case A default?\n        # Let's return the default white grid with blue center from Case A.\n        output_grid_np = np.full((height, 7), WHITE, dtype=int)\n        output_grid_np[:, 3] = BLUE\n\n\n    # Convert the final numpy grid back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5581,
    "candidates_token_count": 3447,
    "total_token_count": 9028,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 142.438818,
  "retries": null
}