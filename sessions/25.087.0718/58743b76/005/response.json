{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nRecolors specific pixels within an azure-framed area based on their quadrant \nrelative to the area's center, using colors defined by a separate 2x2 key.\n\n1.  **Copy Input:** Create a mutable copy of the input grid.\n2.  **Locate the Key:** Find the unique 2x2 block where no pixel is white (0) or azure (8). Record the four colors (Key-TL, Key-TR, Key-BL, Key-BR) and the set of key colors.\n3.  **Identify Frame Bounds:** Find the min/max row/column indices of all azure (8) pixels.\n4.  **Define Target Area:** Calculate the area strictly inside the azure frame boundaries (min_row+1, min_col+1, max_row-1, max_col-1).\n5.  **Identify the Source Color:** Find the unique non-white (0) color present both in the Key colors and within the Target Area.\n6.  **Determine Quadrants:** Calculate the center dividing lines (rows/columns) of the Target Area.\n7.  **Apply Transformation:** Iterate through pixels within the Target Area. If a pixel matches the Source Color, change its color in the copied grid to the Key color corresponding to its quadrant.\n8.  **Output:** Return the modified grid.\n\"\"\"\n\ndef find_key(grid):\n    \"\"\"Finds the 2x2 key block (non-0, non-8 colors) and its top-left coordinates.\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements are not 0 (white) and not 8 (azure)\n            if np.all((subgrid != 0) & (subgrid != 8)):\n                return subgrid, (r, c)\n    return None, None # Key not found\n\ndef find_target_area_by_frame(grid):\n    \"\"\"\n    Identifies the target area by finding the bounding box of azure (8) pixels\n    and returning the coordinates of the region strictly inside this frame.\n    Returns the boundaries (top, left, bottom, right) of the inner area.\n    \"\"\"\n    azure_color = 8\n    azure_coords = np.argwhere(grid == azure_color)\n\n    if azure_coords.size == 0:\n        # print(\"Debug: No azure pixels found.\")\n        return None # No frame found\n\n    # Determine the bounding box of azure pixels\n    azure_min_r, azure_min_c = azure_coords.min(axis=0)\n    azure_max_r, azure_max_c = azure_coords.max(axis=0)\n\n    # Calculate the potential inner area bounds\n    target_top = azure_min_r + 1\n    target_left = azure_min_c + 1\n    target_bottom = azure_max_r - 1\n    target_right = azure_max_c - 1\n\n    # Check if the inner area is valid (at least 1x1)\n    if target_top > target_bottom or target_left > target_right:\n        # print(f\"Debug: Invalid inner area derived from frame ({azure_min_r, azure_min_c} to {azure_max_r, azure_max_c}).\")\n        return None # Frame is too thin or invalid\n\n    # Optional: Add further validation? E.g., check if the frame is solid.\n    # For now, assume the bounding box defines the frame.\n\n    return target_top, target_left, target_bottom, target_right\n\ndef find_source_color(grid, key_colors, target_area_bounds):\n    \"\"\"\n    Finds the unique color present in the key colors and within the target area (non-0).\n    \"\"\"\n    if target_area_bounds is None:\n        return -1 # Indicate error: target area not defined\n\n    target_top, target_left, target_bottom, target_right = target_area_bounds\n\n    # Ensure bounds are valid before slicing\n    if target_top > target_bottom or target_left > target_right:\n         return -1 # Invalid target area\n\n    target_area_grid = grid[target_top : target_bottom + 1, target_left : target_right + 1]\n    \n    # Find unique colors in the target area, excluding white (0)\n    target_area_colors = set(np.unique(target_area_grid)) - {0}\n\n\n    # Find colors present in both the key and the target area (excluding 0)\n    valid_source_colors = key_colors.intersection(target_area_colors)\n\n    if len(valid_source_colors) == 1:\n        return list(valid_source_colors)[0]\n    else:\n        # print(f\"Debug: Found {len(valid_source_colors)} potential source colors: {valid_source_colors}. Key: {key_colors}, Target: {target_area_colors}\")\n        return -1 # Indicate error or ambiguous source\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring pixels based on their quadrant\n    within an azure-framed target area, using a 2x2 color key.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    # 1. Create a mutable copy of the input grid\n    output_grid = np.copy(grid)\n\n    # 2. Locate the Key\n    key_matrix, key_coords = find_key(grid)\n    if key_matrix is None:\n        # print(\"Error: Could not find the 2x2 key.\")\n        return input_grid # Return original if key is missing\n\n    key_colors = set(key_matrix.flatten())\n    key_tl = key_matrix[0, 0]\n    key_tr = key_matrix[0, 1]\n    key_bl = key_matrix[1, 0]\n    key_br = key_matrix[1, 1]\n\n    # 3. Identify Frame Bounds and 4. Define Target Area\n    target_area_bounds = find_target_area_by_frame(grid)\n    if target_area_bounds is None:\n        # print(\"Error: Could not identify a framed target area.\")\n        return input_grid # Return original if target area not found\n\n    target_top, target_left, target_bottom, target_right = target_area_bounds\n    target_height = target_bottom - target_top + 1\n    target_width = target_right - target_left + 1\n\n    # Check for valid dimensions (should be caught by find_target_area_by_frame, but good practice)\n    if target_height <= 0 or target_width <= 0:\n        # print(\"Error: Identified target area has invalid dimensions.\")\n        return input_grid\n\n    # 5. Identify the Source Color\n    source_color = find_source_color(grid, key_colors, target_area_bounds)\n    if source_color == -1:\n        # print(\"Error: Could not uniquely identify the source color.\")\n        return input_grid # Return original if source color is ambiguous or missing\n\n    # 6. Determine Quadrants boundaries (midpoints define the split)\n    # Rows with index < mid_row_exclusive are Top\n    # Cols with index < mid_col_exclusive are Left\n    mid_row_exclusive = target_top + target_height // 2\n    mid_col_exclusive = target_left + target_width // 2\n\n    # 7. Apply Transformation\n    # Iterate through each pixel *only* within the identified Target Area\n    for r in range(target_top, target_bottom + 1):\n        for c in range(target_left, target_right + 1):\n            # Check if the pixel in the original grid is the source color\n            if grid[r, c] == source_color:\n                # Determine quadrant\n                is_top = r < mid_row_exclusive\n                is_left = c < mid_col_exclusive\n\n                new_color = -1 # Default invalid color\n                if is_top and is_left:         # Top-Left\n                    new_color = key_tl\n                elif is_top and not is_left:   # Top-Right\n                    new_color = key_tr\n                elif not is_top and is_left:   # Bottom-Left\n                    new_color = key_bl\n                elif not is_top and not is_left:# Bottom-Right\n                    new_color = key_br\n\n                # Update the output grid if a valid quadrant was found\n                if new_color != -1:\n                   output_grid[r, c] = new_color\n                # No else needed, if pixel isn't source color, it remains unchanged\n\n    # 8. Output: Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10815,
    "candidates_token_count": 2083,
    "total_token_count": 12898,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.644515,
  "retries": null
}