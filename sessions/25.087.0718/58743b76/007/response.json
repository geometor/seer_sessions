{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nRecolors pixels of a specific 'source' color based on their quadrant \nwithin the bounding box of all such source pixels (outside a special 'key' area). \nThe new colors are determined by a 2x2 'key' block.\n\n1.  **Initialize:** Create a copy of the input grid.\n2.  **Find Key:** Locate the unique 2x2 block with no white(0) or azure(8) pixels. Extract its 4 colors (TL, TR, BL, BR), top-left coordinates (key_r, key_c), and the set of its unique colors.\n3.  **Identify Source Color & Coordinates:** Find pixels outside the key's 2x2 area that are not white(0) or azure(8). Identify the unique color among these that is also present in the key's colors (the 'Source Color'). Collect the coordinates of all pixels having the Source Color.\n4.  **Define Target Area:** Calculate the bounding box (min_row, min_col, max_row, max_col) enclosing all identified Source Color Pixel coordinates.\n5.  **Calculate Quadrant Boundaries:** Determine the row and column indices that divide the Target Area into four quadrants using integer division.\n6.  **Apply Transformation:** Iterate through the coordinates of the Source Color Pixels. For each pixel, determine its quadrant within the Target Area and update its color in the output grid using the corresponding color from the Key (TL, TR, BL, BR).\n7.  **Output:** Return the modified grid.\n\"\"\"\n\n\ndef find_key(grid):\n    \"\"\"\n    Finds the unique 2x2 key block (non-0, non-8 colors), its top-left coordinates,\n    its individual colors (TL, TR, BL, BR), and the set of its unique colors.\n    Returns None for all if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements are not 0 (white) and not 8 (azure)\n            if np.all((subgrid != 0) & (subgrid != 8)):\n                key_colors = set(subgrid.flatten())\n                key_tl = subgrid[0, 0]\n                key_tr = subgrid[0, 1]\n                key_bl = subgrid[1, 0]\n                key_br = subgrid[1, 1]\n                return subgrid, (r, c), key_colors, key_tl, key_tr, key_bl, key_br\n    # Key not found\n    return None, None, None, None, None, None, None\n\ndef find_source_color_and_coords(grid, key_colors_set, key_coords):\n    \"\"\"\n    Identifies the source color and the coordinates of all pixels with that color\n    located outside the key area.\n    Source color is the unique color present in both key_colors_set and among\n    non-white, non-azure pixels outside the key.\n    Returns (source_color, list_of_source_coords) or (None, None) if ambiguous/not found.\n    \"\"\"\n    if key_colors_set is None or key_coords is None:\n        return None, None # Cannot proceed without a key\n\n    key_r, key_c = key_coords\n    rows, cols = grid.shape\n    \n    outside_pixels_data = [] # Stores (r, c, color)\n    outside_colors = set()\n\n    # Iterate through grid to find potential source pixels\n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is outside the key's 2x2 bounding box\n            is_outside_key = not (key_r <= r < key_r + 2 and key_c <= c < key_c + 2)\n            \n            if is_outside_key:\n                color = grid[r, c]\n                # Check if color is not white (0) and not azure (8)\n                if color != 0 and color != 8:\n                    outside_pixels_data.append((r, c, color))\n                    outside_colors.add(color)\n\n    # Find the unique intersection color\n    possible_source_colors = key_colors_set.intersection(outside_colors)\n\n    if len(possible_source_colors) != 1:\n        # print(f\"Debug: Ambiguous source color. Intersection: {possible_source_colors}\")\n        return None, None # Source color is not unique or not found\n\n    source_color = list(possible_source_colors)[0]\n\n    # Collect coordinates of actual source pixels\n    source_pixel_coords = []\n    for r, c, color in outside_pixels_data:\n        if color == source_color:\n            source_pixel_coords.append((r, c))\n\n    if not source_pixel_coords:\n        # print(f\"Debug: Source color {source_color} identified, but no pixels found outside key.\")\n        return source_color, [] # Return color but empty list if no pixels found\n\n    return source_color, source_pixel_coords\n\n\ndef calculate_target_area_bounds(source_pixel_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col)\n    for the given list of coordinates.\n    Returns None if the list is empty.\n    \"\"\"\n    if not source_pixel_coords:\n        return None\n\n    coords_array = np.array(source_pixel_coords)\n    min_r, min_c = coords_array.min(axis=0)\n    max_r, max_c = coords_array.max(axis=0)\n\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring pixels based on their quadrant\n    relative to the bounding box of source pixels, using a 2x2 color key.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    # 1. Initialize output grid as a copy\n    output_grid = np.copy(grid)\n\n    # 2. Find Key\n    key_matrix, key_coords, key_colors_set, key_tl, key_tr, key_bl, key_br = find_key(grid)\n    if key_matrix is None:\n        # print(\"Error: Could not find the 2x2 key.\")\n        return input_grid # Return original if key is missing\n\n    # 3. Identify Source Color & Coordinates\n    source_color, source_pixel_coords = find_source_color_and_coords(grid, key_colors_set, key_coords)\n\n    if source_color is None:\n        # print(\"Error: Could not uniquely identify the source color or no source pixels found.\")\n        return input_grid # Return original if source color ambiguous or no pixels\n\n    if not source_pixel_coords:\n         # print(\"Info: Source color identified, but no instances found outside the key. No changes needed.\")\n         return input_grid # No pixels to transform\n\n    # 4. Define Target Area\n    target_bounds = calculate_target_area_bounds(source_pixel_coords)\n    # This check is technically redundant if source_pixel_coords is not empty, but safe\n    if target_bounds is None:\n        # print(\"Error: Could not determine target area bounds.\") # Should not happen if source_pixel_coords is populated\n        return input_grid\n\n    min_r, min_c, max_r, max_c = target_bounds\n\n    # 5. Calculate Quadrant Boundaries\n    target_height = max_r - min_r + 1\n    target_width = max_c - min_c + 1\n\n    # Rows with index < mid_row_exclusive are Top\n    # Cols with index < mid_col_exclusive are Left\n    mid_row_exclusive = min_r + target_height // 2\n    mid_col_exclusive = min_c + target_width // 2\n\n    # 6. Apply Transformation\n    # Iterate through each source pixel coordinate\n    for r, c in source_pixel_coords:\n        # Determine quadrant based on the target area's center lines\n        is_top = r < mid_row_exclusive\n        is_left = c < mid_col_exclusive\n\n        new_color = -1 # Default invalid color\n        if is_top and is_left:         # Top-Left\n            new_color = key_tl\n        elif is_top and not is_left:   # Top-Right\n            new_color = key_tr\n        elif not is_top and is_left:   # Bottom-Left\n            new_color = key_bl\n        elif not is_top and not is_left:# Bottom-Right\n            new_color = key_br\n\n        # Update the output grid\n        if new_color != -1: # Should always be true given the quadrant logic\n           output_grid[r, c] = new_color\n        # else: print(f\"Warning: Could not determine quadrant for pixel at ({r},{c})\") # Should not happen\n\n    # 7. Output: Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9246,
    "candidates_token_count": 2170,
    "total_token_count": 11416,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.20579,
  "retries": null
}