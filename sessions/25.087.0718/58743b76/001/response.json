{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nRecolors specific pixels within a defined canvas area based on their quadrant location, \nusing a 2x2 color key found elsewhere in the grid.\n\n1.  Identify the 2x2 Key: Locate the 2x2 block of non-white (0), non-azure (8) \n    colors. Store these four colors (K_ul, K_ur, K_ll, K_lr) and the key's \n    top-left coordinates.\n2.  Identify the Canvas and Source Color: Find the primary rectangular area \n    predominantly composed of white (0) pixels, excluding the key block and any \n    azure (8) frame. Determine its boundaries (top, bottom, left, right) and \n    dimensions. Within this canvas, identify the single non-white color; this is \n    the source color.\n3.  Calculate Quadrant Boundaries: Divide the canvas into four quadrants (Top-Left, \n    Top-Right, Bottom-Left, Bottom-Right) based on its center.\n4.  Apply Transformation: Create a copy of the input grid. Iterate through each \n    pixel within the canvas boundaries. If a pixel in the input grid matches the \n    source color, determine its quadrant and change its color in the copied grid \n    to the corresponding color from the Key (K_ul for TL, K_ur for TR, K_ll for BL, \n    K_lr for BR). Leave all other pixels unchanged.\n5.  Output the modified grid.\n\"\"\"\n\ndef find_key(grid):\n    \"\"\"Finds the 2x2 key block (non-0, non-8 colors) and its top-left coordinates.\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements are not 0 and not 8\n            if np.all((subgrid != 0) & (subgrid != 8)):\n                return subgrid, (r, c)\n    return None, None # Should not happen based on examples\n\ndef find_canvas_and_source(grid, key_coords, key_shape):\n    \"\"\"Finds the canvas boundaries and the source color within it.\"\"\"\n    rows, cols = grid.shape\n    key_r, key_c = key_coords\n    key_h, key_w = key_shape\n\n    # Find potential canvas pixels (not 8 and not part of the key)\n    potential_canvas_coords = []\n    source_color = -1 # Initialize source color\n    \n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is outside the key boundaries\n            is_outside_key = not (key_r <= r < key_r + key_h and key_c <= c < key_c + key_w)\n            \n            if grid[r, c] != 8 and is_outside_key:\n                 potential_canvas_coords.append((r, c))\n                 # Identify source color (first non-0, non-8 pixel outside key)\n                 if grid[r,c] != 0 and source_color == -1:\n                     source_color = grid[r,c]\n\n    if not potential_canvas_coords:\n         # If no potential canvas pixels found besides 0s maybe?\n         # Re-scan only for 0s if source_color is still -1?\n         # Or maybe the source *is* 0? Let's stick to the description first.\n         # It might be that the source color must be found first.\n         \n         # Let's refine: Source color MUST be one of the key colors. Find it first.\n         key_colors = set(grid[key_r:key_r+key_h, key_c:key_c+key_w].flatten())\n         potential_source_colors = set()\n         all_non_8_coords = []\n         for r in range(rows):\n             for c in range(cols):\n                  is_outside_key = not (key_r <= r < key_r + key_h and key_c <= c < key_c + key_w)\n                  if grid[r,c] != 8:\n                      all_non_8_coords.append((r,c))\n                      if is_outside_key and grid[r,c] != 0:\n                          potential_source_colors.add(grid[r,c])\n\n         # The true source color should be the one present outside the key *and* inside the key\n         valid_source_colors = potential_source_colors.intersection(key_colors)\n         if len(valid_source_colors) == 1:\n             source_color = list(valid_source_colors)[0]\n         elif len(valid_source_colors) > 1:\n             # This case isn't expected by the examples, assume the first one or handle error\n             print(f\"Warning: Multiple potential source colors found: {valid_source_colors}. Choosing {list(valid_source_colors)[0]}\")\n             source_color = list(valid_source_colors)[0]\n         else:\n             # No valid source color found outside the key that is also in the key\n             print(\"Warning: No valid source color found.\")\n             # Fallback: Try finding the bounding box of 0s?\n             # For now, assume source color must be found this way. Handle error if needed.\n              return None, None, None, None, -1 # Indicate failure\n\n\n         # Now define canvas based on bounding box of non-8 pixels, EXCLUDING the key itself\n         canvas_pixels_coords = []\n         for r, c in all_non_8_coords:\n              is_outside_key = not (key_r <= r < key_r + key_h and key_c <= c < key_c + key_w)\n              if is_outside_key:\n                   canvas_pixels_coords.append((r,c))\n\n         if not canvas_pixels_coords:\n             return None, None, None, None, source_color # No canvas pixels found outside key\n\n         min_r = min(r for r, c in canvas_pixels_coords)\n         max_r = max(r for r, c in canvas_pixels_coords)\n         min_c = min(c for r, c in canvas_pixels_coords)\n         max_c = max(c for r, c in canvas_pixels_coords)\n\n         canvas_top = min_r\n         canvas_bottom = max_r\n         canvas_left = min_c\n         canvas_right = max_c\n         canvas_height = canvas_bottom - canvas_top + 1\n         canvas_width = canvas_right - canvas_left + 1\n\n         return canvas_top, canvas_height, canvas_left, canvas_width, source_color\n\n    # If the first pass worked (unlikely given refinement needed above)\n    if not potential_canvas_coords:\n        return None, None, None, None, source_color # Should not happen\n\n    min_r = min(r for r, c in potential_canvas_coords)\n    max_r = max(r for r, c in potential_canvas_coords)\n    min_c = min(c for r, c in potential_canvas_coords)\n    max_c = max(c for r, c in potential_canvas_coords)\n\n    canvas_top = min_r\n    canvas_bottom = max_r\n    canvas_left = min_c\n    canvas_right = max_c\n    canvas_height = canvas_bottom - canvas_top + 1\n    canvas_width = canvas_right - canvas_left + 1\n\n    # Verify source color if found in the first pass\n    if source_color == -1: # If no non-zero pixel was found initially\n         key_colors = set(grid[key_r:key_r+key_h, key_c:key_c+key_w].flatten())\n         for r in range(canvas_top, canvas_top + canvas_height):\n             for c in range(canvas_left, canvas_left + canvas_width):\n                 if grid[r,c] != 0 and grid[r,c] in key_colors:\n                      source_color = grid[r,c]\n                      break\n             if source_color != -1:\n                 break\n         if source_color == -1:\n              print(\"Warning: Could not definitively identify source color within canvas.\")\n              # Maybe the canvas only contains 0s? This seems unlikely given task.\n\n    return canvas_top, canvas_height, canvas_left, canvas_width, source_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring pixels based on their quadrant \n    within a canvas area, using a 2x2 color key.\n    \"\"\"\n    # Convert input_grid list of lists to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid) # Create a copy to modify\n\n    # 1. Identify the Key\n    key_matrix, key_coords = find_key(grid)\n    if key_matrix is None:\n        print(\"Error: Key not found.\")\n        return input_grid # Return original if key not found\n\n    key_ul = key_matrix[0, 0]\n    key_ur = key_matrix[0, 1]\n    key_ll = key_matrix[1, 0]\n    key_lr = key_matrix[1, 1]\n    key_shape = key_matrix.shape\n\n    # 2. Identify the Canvas and Source Color\n    canvas_top, canvas_height, canvas_left, canvas_width, source_color = find_canvas_and_source(grid, key_coords, key_shape)\n\n    if canvas_top is None or source_color == -1:\n         print(\"Error: Canvas or source color not identified correctly.\")\n         # Attempting a simpler canvas identification: bounding box of 0s\n         zero_coords = np.argwhere(grid == 0)\n         if zero_coords.size > 0:\n             min_r_z, min_c_z = zero_coords.min(axis=0)\n             max_r_z, max_c_z = zero_coords.max(axis=0)\n             canvas_top = min_r_z\n             canvas_height = max_r_z - min_r_z + 1\n             canvas_left = min_c_z\n             canvas_width = max_c_z - min_c_z + 1\n             # Re-identify source color within this 0-defined canvas\n             source_color = -1\n             key_colors = set(key_matrix.flatten())\n             for r in range(canvas_top, canvas_top + canvas_height):\n                for c in range(canvas_left, canvas_left + canvas_width):\n                    if grid[r,c] != 0 and grid[r,c] in key_colors:\n                        source_color = grid[r,c]\n                        break\n                if source_color != -1: break\n             if source_color == -1:\n                 print(\"Error: Source color not found even with 0-based canvas.\")\n                 return input_grid # Return original if still failing\n         else:\n            print(\"Error: No zero pixels found to define canvas.\")\n            return input_grid # Return original\n\n    # 3. Calculate Quadrant Boundaries (exclusive midpoints)\n    # Midpoint rows/cols belong to the bottom/right quadrants respectively\n    mid_row_exclusive = canvas_top + (canvas_height) // 2 # Rows < mid belong to top\n    mid_col_exclusive = canvas_left + (canvas_width) // 2 # Cols < mid belong to left\n    \n    # Handle edge case for 1-pixel height/width canvases (assign to top-left)\n    # Let's adjust the logic slightly: use indices relative to canvas origin\n    # rel_mid_row = canvas_height // 2\n    # rel_mid_col = canvas_width // 2\n\n\n    # 4. Apply Transformation\n    for r in range(canvas_top, canvas_top + canvas_height):\n        for c in range(canvas_left, canvas_left + canvas_width):\n            # Check if the pixel in the original grid is the source color\n            if grid[r, c] == source_color:\n                # Determine quadrant\n                is_top = r < mid_row_exclusive\n                is_left = c < mid_col_exclusive\n                \n                # Example: 8x8 canvas (0-7 relative indices)\n                # Height = 8, Width = 8\n                # Mid_row = 0 + 8 // 2 = 4. Rows 0,1,2,3 are top. Rows 4,5,6,7 are bottom.\n                # Mid_col = 0 + 8 // 2 = 4. Cols 0,1,2,3 are left. Cols 4,5,6,7 are right.\n                # Let's test with example 1: Canvas 8x8, rows 2-9, cols 2-9\n                # canvas_top=2, height=8, canvas_left=2, width=8\n                # mid_row_exclusive = 2 + 8 // 2 = 6. Rows 2,3,4,5 are top.\n                # mid_col_exclusive = 2 + 8 // 2 = 6. Cols 2,3,4,5 are left.\n                \n                # Pixel (2,6) -> blue(1) -> input[2,6]=1\n                # r=2, c=6. source=1.\n                # is_top = 2 < 6 -> True\n                # is_left = 6 < 6 -> False\n                # Top-Right Quadrant -> Use key_ur (4 - yellow)\n                # output[2,6] should be 4. Correct.\n\n                # Pixel (4,8) -> blue(1) -> input[4,8]=1\n                # r=4, c=8. source=1.\n                # is_top = 4 < 6 -> True\n                # is_left = 8 < 6 -> False\n                # Top-Right Quadrant -> Use key_ur (4 - yellow)\n                # output[4,8] should be 4. Correct.\n\n                # Pixel (4,9) -> blue(1) -> input[4,9]=1\n                # r=4, c=9. source=1.\n                # is_top = 4 < 6 -> True\n                # is_left = 9 < 6 -> False\n                # Top-Right Quadrant -> Use key_ur (4 - yellow)\n                # output[4,9] should be 4. Correct.\n\n                # Pixel (6,4) -> blue(1) -> input[6,4]=1\n                # r=6, c=4. source=1\n                # is_top = 6 < 6 -> False\n                # is_left = 4 < 6 -> True\n                # Bottom-Left Quadrant -> Use key_ll (3 - green)\n                # output[6,4] should be 3. Correct.\n\n                # Pixel (6,7) -> blue(1) -> input[6,7]=1\n                # r=6, c=7. source=1\n                # is_top = 6 < 6 -> False\n                # is_left = 7 < 6 -> False\n                # Bottom-Right Quadrant -> Use key_lr (2 - red)\n                # output[6,7] should be 2. Correct.\n                \n                # Seems correct logic.\n\n                new_color = -1 # Default invalid color\n                if is_top and is_left:         # Top-Left\n                    new_color = key_ul\n                elif is_top and not is_left:   # Top-Right\n                    new_color = key_ur\n                elif not is_top and is_left:   # Bottom-Left\n                    new_color = key_ll\n                elif not is_top and not is_left:# Bottom-Right\n                    new_color = key_lr\n\n                if new_color != -1:\n                   output_grid[r, c] = new_color\n                else:\n                    print(f\"Warning: Could not determine quadrant for pixel ({r},{c})\")\n\n\n    # 5. Output\n    # Convert back to list of lists if necessary for the environment\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3902,
    "candidates_token_count": 3850,
    "total_token_count": 7752,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.149493,
  "retries": null
}