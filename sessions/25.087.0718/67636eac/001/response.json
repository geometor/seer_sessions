{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct non-white objects in the input grid.\nFor each object, determine its minimal bounding box and extract the corresponding subgrid.\nSort these extracted subgrids based on the top-to-bottom, then left-to-right position of the top-left corner of their bounding boxes in the original input grid.\nConstruct the output grid by vertically stacking the sorted subgrids.\nThe width of the output grid is the maximum width among all extracted subgrids. Pad narrower subgrids with the background color (white, 0) on the right if necessary.\nThe height of the output grid is the sum of the heights of all extracted subgrids.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components (objects) of non-white pixels using 8-way connectivity.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates\n              of the pixels belonging to a single object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    # 8-way connectivity (including diagonals)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0),\n                  (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and not visited, start a search (BFS)\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Check all 8 neighbors\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds, visited status, and if neighbor has the same color\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            current_object_pixels.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Add the found object (set of pixels) to the list\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n    return objects\n\n\ndef get_bounding_box(object_pixels):\n    \"\"\"\n    Calculates the minimal bounding box for a set of pixels.\n\n    Args:\n        object_pixels (set): A set of (row, col) coordinates for an object.\n\n    Returns:\n        tuple: (min_row, min_col, height, width) of the bounding box,\n               or None if the input set is empty.\n    \"\"\"\n    if not object_pixels:\n        return None\n    rows = [r for r, c in object_pixels]\n    cols = [c for r, c in object_pixels]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return (min_r, min_c, height, width)\n\n\ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts the subgrid defined by the bounding box from the main grid.\n\n    Args:\n        grid (np.ndarray): The main input grid.\n        bbox (tuple): The bounding box (min_row, min_col, height, width).\n\n    Returns:\n        np.ndarray: The extracted subgrid.\n    \"\"\"\n    min_r, min_c, height, width = bbox\n    # Use numpy slicing to extract the rectangular region\n    return grid[min_r : min_r + height, min_c : min_c + width]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting non-white objects, sorting them,\n    and stacking them vertically in the output grid.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Find all distinct non-white objects\n    objects = find_objects(input_np)\n\n    # Handle case where no objects are found\n    if not objects:\n        return [[0]] # Return a 1x1 white grid\n\n    object_data = []\n    for obj_pixels in objects:\n        # 2. Determine bounding box for each object\n        bbox = get_bounding_box(obj_pixels)\n        if bbox:\n            # 3. Extract the subgrid corresponding to the bounding box\n            # Note: This extracts the rectangular area, including any background pixels within it.\n            subgrid = extract_subgrid(input_np, bbox)\n            object_data.append({'bbox': bbox, 'subgrid': subgrid})\n\n    # Handle case where found objects somehow resulted in no valid data\n    if not object_data:\n         return [[0]]\n\n    # 4. Sort the extracted subgrids based on the top-left corner (row, then column)\n    # bbox = (min_r, min_c, height, width) -> sort key is (min_r, min_c)\n    object_data.sort(key=lambda x: (x['bbox'][0], x['bbox'][1]))\n\n    # 5. Determine output dimensions\n    max_width = 0\n    total_height = 0\n    subgrids_to_stack = [] # Store just the subgrids in sorted order\n    for item in object_data:\n        subgrid = item['subgrid']\n        h, w = subgrid.shape\n        total_height += h\n        if w > max_width:\n            max_width = w\n        subgrids_to_stack.append(subgrid)\n\n    # 6. Construct the output grid by stacking vertically\n    # Initialize with background color (0)\n    output_grid = np.zeros((total_height, max_width), dtype=int)\n    current_row = 0\n    for subgrid in subgrids_to_stack:\n        h, w = subgrid.shape\n        # Place the subgrid into the output grid at the current row, aligned left\n        # Padding with 0s on the right happens automatically due to initialization\n        output_grid[current_row : current_row + h, 0 : w] = subgrid\n        # Move insertion point down for the next subgrid\n        current_row += h\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3269,
    "candidates_token_count": 1660,
    "total_token_count": 4929,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 54.303034,
  "retries": null
}