{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentify all distinct non-white objects (contiguous pixels of same color, 8-way connectivity).\nFor each object, find its minimal bounding box, extract the subgrid, determine its color, and calculate its center coordinates.\nIf zero objects, output a 1x1 white grid.\nIf one object, output its extracted subgrid.\nIf multiple objects, calculate standard deviation of row centers (std_rows) and column centers (std_cols).\nDetermine alignment type: 'Vertical' if std_cols < std_rows, otherwise 'Horizontal/Scattered'.\nSort the objects: by top-left position (row then col) if 'Vertical', by color index (ascending) if 'Horizontal/Scattered'.\nAssemble output based on alignment:\n    If 'Vertical': Stack sorted subgrids vertically, left-aligned. Output width is max subgrid width, output height is sum of subgrid heights. Pad right with white if needed.\n    If 'Horizontal/Scattered': Place sorted subgrids horizontally adjacent, top-aligned. Output height is max subgrid height, output width is sum of subgrid widths. Pad bottom with white if needed.\n\"\"\"\n\ndef find_objects_with_details(grid):\n    \"\"\"\n    Finds all connected components (objects) of non-white pixels using 8-way connectivity,\n    and gathers details like color, bounding box, center, and extracted subgrid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dict contains information about an object:\n              {'pixels': set((r, c)), 'color': int, 'bbox': tuple(min_r, min_c, h, w),\n               'center': tuple(center_r, center_c), 'subgrid': np.ndarray}\n              Returns an empty list if no non-white objects are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects_data = []\n    # 8-way connectivity (including diagonals)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0),\n                  (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and not visited, start a search (BFS)\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Check all 8 neighbors\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, visited status, and if neighbor has the same color\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            current_object_pixels.add((nr, nc))\n                            q.append((nr, nc))\n\n                # If an object was found, calculate its properties\n                if current_object_pixels:\n                    rows = [px_r for px_r, px_c in current_object_pixels]\n                    cols = [px_c for px_r, px_c in current_object_pixels]\n                    min_r, max_r = min(rows), max(rows)\n                    min_c, max_c = min(cols), max(cols)\n                    h = max_r - min_r + 1\n                    w = max_c - min_c + 1\n                    bbox = (min_r, min_c, h, w)\n                    center_r = min_r + (h - 1) / 2.0\n                    center_c = min_c + (w - 1) / 2.0\n                    center = (center_r, center_c)\n                    subgrid = grid[min_r : min_r + h, min_c : min_c + w]\n\n                    objects_data.append({\n                        'pixels': current_object_pixels,\n                        'color': int(color), # Ensure standard int type\n                        'bbox': bbox,\n                        'center': center,\n                        'subgrid': subgrid\n                    })\n    return objects_data\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the spatial alignment of its non-white objects.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Find Objects and their details\n    objects_data = find_objects_with_details(input_np)\n    num_objects = len(objects_data)\n\n    # 2. Handle Simple Cases\n    if num_objects == 0:\n        return [[0]] # Output 1x1 white grid\n    if num_objects == 1:\n        return objects_data[0]['subgrid'].tolist() # Output the single object's subgrid\n\n    # 3. Analyze Multiple Objects\n    centers = np.array([obj['center'] for obj in objects_data])\n    \n    # Using try-except for std dev calculation in case of single point variance\n    try:\n        std_rows = np.std(centers[:, 0]) if centers.shape[0] > 1 else 0\n    except IndexError:\n        std_rows = 0\n        \n    try:\n        std_cols = np.std(centers[:, 1]) if centers.shape[0] > 1 else 0\n    except IndexError:\n        std_cols = 0\n\n    # Determine alignment and sort\n    # Add a small epsilon to handle floating point comparisons near zero, though std>=0\n    # Treat std_cols == std_rows as Horizontal/Scattered\n    if std_cols < std_rows:\n        alignment = \"Vertical\"\n        # Sort by top-left (bbox[0], then bbox[1])\n        objects_data.sort(key=lambda x: (x['bbox'][0], x['bbox'][1]))\n    else: # std_cols >= std_rows\n        alignment = \"Horizontal/Scattered\"\n        # Sort by color index\n        objects_data.sort(key=lambda x: x['color'])\n\n    # 4. Assemble Output Grid\n    if alignment == \"Vertical\":\n        # Calculate output dimensions\n        max_width = 0\n        total_height = 0\n        for obj in objects_data:\n            h, w = obj['subgrid'].shape\n            total_height += h\n            if w > max_width:\n                max_width = w\n\n        # Initialize output grid\n        output_grid = np.zeros((total_height, max_width), dtype=int)\n\n        # Stack subgrids vertically\n        current_row = 0\n        for obj in objects_data:\n            subgrid = obj['subgrid']\n            h, w = subgrid.shape\n            output_grid[current_row : current_row + h, 0 : w] = subgrid\n            current_row += h\n\n    else: # alignment == \"Horizontal/Scattered\"\n        # Calculate output dimensions\n        max_height = 0\n        total_width = 0\n        for obj in objects_data:\n            h, w = obj['subgrid'].shape\n            total_width += w\n            if h > max_height:\n                max_height = h\n\n        # Initialize output grid\n        output_grid = np.zeros((max_height, total_width), dtype=int)\n\n        # Place subgrids horizontally adjacent\n        current_col = 0\n        for obj in objects_data:\n            subgrid = obj['subgrid']\n            h, w = subgrid.shape\n            # Place subgrid, top-aligned. Padding bottom with 0 happens automatically.\n            output_grid[0 : h, current_col : current_col + w] = subgrid\n            current_col += w\n\n    # Convert final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13310,
    "candidates_token_count": 1969,
    "total_token_count": 15279,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.220473,
  "retries": null
}