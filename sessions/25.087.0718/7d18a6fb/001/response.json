{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a blue frame in the input grid. Finds 'key' pixels (non-white, non-blue) inside the frame's bounding box.\nFinds 'target' shapes (non-white components) outside the frame's bounding box.\nMatches key pixels to target shapes based on color.\nArranges the matched target shapes in the output grid according to the relative positions of their corresponding key pixels within the frame, maintaining a 1-pixel white spacing between adjacent shapes.\n\"\"\"\n\ndef find_connected_components(grid, colors_to_find=None, mask=None):\n    \"\"\"\n    Finds connected components of specified colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        colors_to_find (set, optional): A set of colors to include in components. \n                                        If None, finds components of any non-zero color.\n        mask (np.ndarray, optional): A boolean grid of the same shape as grid. \n                                     Only cells where mask is True will be considered.\n\n    Returns:\n        list: A list of components. Each component is a tuple:\n              (color, set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # Check mask if provided\n            if mask is not None and not mask[r, c]:\n                continue\n                \n            # Check if visited or not a target color\n            color = grid[r, c]\n            is_target_color = False\n            if colors_to_find is None:\n                 if color != 0: # Any non-background color if colors_to_find is None\n                     is_target_color = True\n            elif color in colors_to_find:\n                 is_target_color = True\n\n            if visited[r, c] or not is_target_color:\n                continue\n\n            # Start BFS to find a new component\n            component_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            component_color = color # All pixels in a component must have the same color in ARC\n\n            while q:\n                row, col = q.popleft()\n                component_pixels.add((row, col))\n\n                # Check neighbors (4-way connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n\n                    if 0 <= nr < height and 0 <= nc < width:\n                         # Check mask if provided\n                        if mask is not None and not mask[nr, nc]:\n                            continue\n                            \n                        # Check if valid neighbor\n                        neighbor_color = grid[nr, nc]\n                        if not visited[nr, nc] and neighbor_color == component_color:\n                             # Check mask if provided for the neighbor as well\n                            if mask is None or mask[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n            \n            if component_pixels:\n                 components.append((component_color, component_pixels))\n\n    return components\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef get_relative_shape(pixels, color):\n    \"\"\" Extracts the shape details: relative coordinates, color, height, width. \"\"\"\n    if not pixels:\n        return None, None, 0, 0\n    \n    min_r, min_c, max_r, max_c = get_bounding_box(pixels)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    relative_pixels = set()\n    for r, c in pixels:\n        relative_pixels.add((r - min_r, c - min_c))\n        \n    shape_grid = np.zeros((height, width), dtype=int)\n    for r_rel, c_rel in relative_pixels:\n        shape_grid[r_rel, c_rel] = color\n        \n    return shape_grid, (min_r, min_c), height, width\n\n\ndef paste_shape(target_grid, shape_grid, top_left_r, top_left_c):\n    \"\"\" Pastes a shape_grid onto the target_grid at the specified top-left corner. \"\"\"\n    h, w = shape_grid.shape\n    target_h, target_w = target_grid.shape\n    \n    for r in range(h):\n        for c in range(w):\n            tr, tc = top_left_r + r, top_left_c + c\n            if 0 <= tr < target_h and 0 <= tc < target_w:\n                # Only paste non-background pixels of the shape\n                if shape_grid[r, c] != 0:\n                    target_grid[tr, tc] = shape_grid[r, c]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described logic.\n    \"\"\"\n    input_np = np.array(input_grid)\n    height, width = input_np.shape\n\n    # 1. Find the blue frame and its bounding box\n    blue_components = find_connected_components(input_np, colors_to_find={1})\n    if not blue_components:\n        # Handle cases with no blue frame if necessary, maybe return input or empty?\n        # Based on examples, a frame is always present. Let's assume this.\n         return np.array([[]]) # Or raise error? Return empty for now.\n\n    # Assume largest blue component is the frame\n    frame_pixels = max(blue_components, key=lambda item: len(item[1]))[1]\n    frame_bb = get_bounding_box(frame_pixels)\n    if frame_bb is None:\n         return np.array([[]]) # Error case\n    fr_min_r, fr_min_c, fr_max_r, fr_max_c = frame_bb\n\n    # 2. Find Key Pixels inside the frame's bounding box\n    key_pixels_data = []\n    for r in range(fr_min_r, fr_max_r + 1):\n        for c in range(fr_min_c, fr_max_c + 1):\n            color = input_np[r, c]\n            # Check if it's inside the bounding box AND not blue (1) or white (0)\n            if color not in [0, 1]:\n                 # Check if it's truly inside the frame area (not part of the frame itself)\n                 # A simple check: ensure it's not part of the found frame pixels\n                 if (r, c) not in frame_pixels:\n                     # Store color and absolute coordinates\n                     key_pixels_data.append({'color': color, 'pos': (r, c)})\n                         \n    if not key_pixels_data:\n        return np.array([[]]) # No keys found\n\n    # 3. Find Target Shapes outside the frame's bounding box\n    outside_mask = np.ones_like(input_np, dtype=bool)\n    if frame_bb: # If a frame was found, mask its bounding box\n        outside_mask[fr_min_r:fr_max_r+1, fr_min_c:fr_max_c+1] = False\n\n    potential_target_components = find_connected_components(input_np, mask=outside_mask)\n    \n    target_shapes_data = []\n    for color, pixels in potential_target_components:\n        # Ensure the component is entirely outside the frame's bounding box\n        # (The mask already mostly ensures this, but double check for safety)\n        is_fully_outside = True\n        if frame_bb:\n            for r, c in pixels:\n                if fr_min_r <= r <= fr_max_r and fr_min_c <= c <= fr_max_c:\n                    is_fully_outside = False\n                    break\n        \n        if is_fully_outside:\n            shape_grid, _, shape_h, shape_w = get_relative_shape(pixels, color)\n            if shape_grid is not None:\n                target_shapes_data.append({\n                    'color': color, \n                    'shape': shape_grid, \n                    'height': shape_h,\n                    'width': shape_w\n                })\n\n    # 4. Match Key Pixels to Target Shapes by color\n    matched_targets = {} # Map key position -> target shape details\n    available_targets = {s['color']: s for s in target_shapes_data}\n    \n    keys_to_process = [] # Store keys that have a matching shape\n    for key in key_pixels_data:\n        color = key['color']\n        pos = key['pos']\n        if color in available_targets:\n            matched_targets[pos] = available_targets[color]\n            keys_to_process.append(key)\n            # Remove target to prevent reuse (assuming 1-to-1 mapping)\n            del available_targets[color] \n            \n    if not keys_to_process:\n         return np.array([[]]) # No matches found\n\n    # 5. Determine relative arrangement of Key Pixels\n    key_coords = sorted([k['pos'] for k in keys_to_process]) # Sort by row, then col\n    \n    # Find unique rows and columns used by keys\n    unique_rows = sorted(list(set(r for r, c in key_coords)))\n    unique_cols = sorted(list(set(c for r, c in key_coords)))\n    \n    # Map absolute key position to grid index (row_idx, col_idx)\n    key_grid_indices = {}\n    row_map = {r: i for i, r in enumerate(unique_rows)}\n    col_map = {c: i for i, c in enumerate(unique_cols)}\n    for r, c in key_coords:\n        key_grid_indices[(r, c)] = (row_map[r], col_map[c])\n\n    num_grid_rows = len(unique_rows)\n    num_grid_cols = len(unique_cols)\n\n    # 6. Calculate output grid dimensions\n    spacing = 1 # Space between shapes\n    \n    # Find max height per grid row and max width per grid col\n    grid_row_max_h = {i: 0 for i in range(num_grid_rows)}\n    grid_col_max_w = {i: 0 for i in range(num_grid_cols)}\n\n    for key_pos, target_data in matched_targets.items():\n        grid_r_idx, grid_c_idx = key_grid_indices[key_pos]\n        grid_row_max_h[grid_r_idx] = max(grid_row_max_h[grid_r_idx], target_data['height'])\n        grid_col_max_w[grid_c_idx] = max(grid_col_max_w[grid_c_idx], target_data['width'])\n\n    # Calculate total height and width\n    output_h = sum(grid_row_max_h.values()) + max(0, num_grid_rows - 1) * spacing\n    output_w = sum(grid_col_max_w.values()) + max(0, num_grid_cols - 1) * spacing\n\n    # 7. Initialize output grid\n    output_grid = np.zeros((output_h, output_w), dtype=int)\n\n    # 8. Place shapes onto the output grid\n    current_r = 0\n    for grid_r_idx in range(num_grid_rows):\n        current_c = 0\n        max_h_this_row = grid_row_max_h[grid_r_idx]\n        for grid_c_idx in range(num_grid_cols):\n            max_w_this_col = grid_col_max_w[grid_c_idx]\n            \n            # Find the key/shape corresponding to this grid cell (if any)\n            found_key_pos = None\n            for key_pos, (gr, gc) in key_grid_indices.items():\n                if gr == grid_r_idx and gc == grid_c_idx:\n                    found_key_pos = key_pos\n                    break\n            \n            if found_key_pos and found_key_pos in matched_targets:\n                target_data = matched_targets[found_key_pos]\n                shape_to_paste = target_data['shape']\n                # Paste the shape at the current calculated position\n                paste_shape(output_grid, shape_to_paste, current_r, current_c)\n\n            # Move to the next column position\n            current_c += max_w_this_col + spacing\n            \n        # Move to the next row position\n        current_r += max_h_this_row + spacing\n\n    return output_grid.tolist() # Convert back to list of lists for ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4241,
    "candidates_token_count": 3189,
    "total_token_count": 7430,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.306347,
  "retries": null
}