{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nIdentifies a blue frame in the input grid. Finds 'key' pixels (non-white, non-blue) inside the frame's inner area.\nFinds 'target' shapes (non-white components) outside the frame's bounding box.\nMatches key pixels to target shapes based on color.\nCalculates the relative positions of key pixels within the frame's inner area.\nDetermines the output grid layout based on these relative positions and the dimensions of the matched target shapes, maintaining a 1-pixel white spacing.\nConstructs the output grid by placing the matched target shapes according to the determined layout.\n\"\"\"\n\n# === Helper Functions (Mostly from previous attempt, verified/slightly refined) ===\n\ndef find_connected_components(grid, colors_to_find=None, mask=None, connectivity=4):\n    \"\"\"\n    Finds connected components of specified colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        colors_to_find (set, optional): A set of colors to include in components.\n                                        If None, finds components of any non-zero color.\n        mask (np.ndarray, optional): A boolean grid of the same shape as grid.\n                                     Only cells where mask is True will be considered.\n        connectivity (int): 4 or 8 for neighbor connectivity. Defaults to 4.\n\n    Returns:\n        list: A list of components. Each component is a tuple:\n              (color, set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n\n    for r in range(height):\n        for c in range(width):\n            # Apply mask if provided\n            if mask is not None and not mask[r, c]:\n                continue\n\n            # Check if visited\n            if visited[r, c]:\n                continue\n\n            color = grid[r, c]\n            # Check if it's a target color\n            is_target_color = False\n            if colors_to_find is None:\n                if color != 0: # Any non-background color\n                    is_target_color = True\n            elif color in colors_to_find:\n                is_target_color = True\n\n            if not is_target_color:\n                continue\n\n            # Start BFS for a new component\n            component_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            component_color = color # All pixels in a component must have the same color\n\n            while q:\n                row, col = q.popleft()\n                component_pixels.add((row, col))\n\n                # Check neighbors\n                for dr, dc in deltas:\n                    nr, nc = row + dr, col + dc\n\n                    if 0 <= nr < height and 0 <= nc < width:\n                        # Check mask for neighbor\n                        if mask is not None and not mask[nr, nc]:\n                            continue\n\n                        neighbor_color = grid[nr, nc]\n                        if not visited[nr, nc] and neighbor_color == component_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n            if component_pixels:\n                components.append((component_color, component_pixels))\n\n    return components\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef get_relative_shape(pixels, color):\n    \"\"\" Extracts the shape details: shape grid, top-left absolute coord, height, width. \"\"\"\n    if not pixels:\n        return None, None, 0, 0\n\n    min_r, min_c, max_r, max_c = get_bounding_box(pixels)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    shape_grid = np.zeros((height, width), dtype=int)\n    for r, c in pixels:\n        shape_grid[r - min_r, c - min_c] = color\n\n    return shape_grid, (min_r, min_c), height, width\n\n\ndef paste_shape(target_grid, shape_grid, top_left_r, top_left_c):\n    \"\"\" Pastes a shape_grid onto the target_grid at the specified top-left corner. \"\"\"\n    shape_h, shape_w = shape_grid.shape\n    target_h, target_w = target_grid.shape\n\n    for r_rel in range(shape_h):\n        for c_rel in range(shape_w):\n            # Only paste non-background pixels of the shape\n            if shape_grid[r_rel, c_rel] != 0:\n                abs_r = top_left_r + r_rel\n                abs_c = top_left_c + c_rel\n                # Check bounds before pasting\n                if 0 <= abs_r < target_h and 0 <= abs_c < target_w:\n                    target_grid[abs_r, abs_c] = shape_grid[r_rel, c_rel]\n\n# === Main Transformation Logic ===\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying key pixels within a blue frame,\n    matching them to corresponding colored shapes outside the frame, and\n    arranging these shapes in an output grid based on the relative positions\n    of the key pixels, separated by 1 white pixel.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Identify the Frame (largest blue component)\n    blue_components = find_connected_components(input_np, colors_to_find={1})\n    if not blue_components:\n        return np.array([[]]).tolist() # No frame found\n\n    frame_pixels = max(blue_components, key=lambda item: len(item[1]))[1]\n    frame_bb = get_bounding_box(frame_pixels)\n    if frame_bb is None:\n         return np.array([[]]).tolist() # Should not happen if frame_pixels exist\n    fr_min_r, fr_min_c, fr_max_r, fr_max_c = frame_bb\n    \n    # Define inner frame boundaries (where keys can exist)\n    inner_min_r, inner_min_c = fr_min_r + 1, fr_min_c + 1\n    inner_max_r, inner_max_c = fr_max_r - 1, fr_max_c - 1\n\n    # 2. Identify Key Pixels (inside the inner frame area)\n    key_pixels_data = []\n    for r in range(inner_min_r, inner_max_r + 1):\n        for c in range(inner_min_c, inner_max_c + 1):\n            color = input_np[r, c]\n            # Key condition: Inside inner bounds and not white (0) or blue (1)\n            if color not in [0, 1]:\n                 key_pixels_data.append({'color': color, 'abs_pos': (r, c)})\n\n    if not key_pixels_data:\n        return np.array([[]]).tolist() # No keys found\n\n    # 3. Identify Target Shapes (outside frame's bounding box)\n    outside_mask = np.ones_like(input_np, dtype=bool)\n    outside_mask[fr_min_r:fr_max_r+1, fr_min_c:fr_max_c+1] = False\n    \n    # Find all non-white components outside the frame\n    potential_target_components = find_connected_components(input_np, colors_to_find=None, mask=outside_mask)\n\n    target_shapes_data = []\n    for color, pixels in potential_target_components:\n        shape_grid, _, shape_h, shape_w = get_relative_shape(pixels, color)\n        if shape_grid is not None:\n            target_shapes_data.append({\n                'color': color,\n                'shape': shape_grid,\n                'height': shape_h,\n                'width': shape_w\n            })\n\n    # 4. Match Keys to Targets by color (one-to-one)\n    matched_keys = [] # Store key info along with matched shape data\n    available_targets = defaultdict(list)\n    for shape_data in target_shapes_data:\n        available_targets[shape_data['color']].append(shape_data)\n\n    key_colors_used = defaultdict(int)\n    for key in key_pixels_data:\n        key_color = key['color']\n        if key_color in available_targets and len(available_targets[key_color]) > key_colors_used[key_color]:\n            target_shape = available_targets[key_color][key_colors_used[key_color]]\n            matched_keys.append({\n                'abs_pos': key['abs_pos'],\n                'color': key_color,\n                'target': target_shape\n            })\n            key_colors_used[key_color] += 1 # Mark this target as used for this color\n\n    if not matched_keys:\n        return np.array([[]]).tolist() # No matches found\n\n    # 5. Determine Relative Key Positions (relative to inner frame top-left)\n    relative_key_info = []\n    for key in matched_keys:\n        abs_r, abs_c = key['abs_pos']\n        rel_r = abs_r - inner_min_r\n        rel_c = abs_c - inner_min_c\n        relative_key_info.append({\n            'rel_pos': (rel_r, rel_c),\n            'target': key['target']\n        })\n\n    # 6. Define Output Grid Structure based on relative positions\n    unique_rel_rows = sorted(list(set(r for r, c in [k['rel_pos'] for k in relative_key_info])))\n    unique_rel_cols = sorted(list(set(c for r, c in [k['rel_pos'] for k in relative_key_info])))\n\n    # Map relative row/col to grid index (0, 1, 2...)\n    rel_row_to_grid_idx = {r: i for i, r in enumerate(unique_rel_rows)}\n    rel_col_to_grid_idx = {c: i for i, c in enumerate(unique_rel_cols)}\n\n    num_grid_rows = len(unique_rel_rows)\n    num_grid_cols = len(unique_rel_cols)\n\n    # Store target shape by grid index for easy lookup\n    shape_by_grid_idx = {}\n    for key_info in relative_key_info:\n        rel_r, rel_c = key_info['rel_pos']\n        grid_r_idx = rel_row_to_grid_idx[rel_r]\n        grid_c_idx = rel_col_to_grid_idx[rel_c]\n        shape_by_grid_idx[(grid_r_idx, grid_c_idx)] = key_info['target']\n\n    # 7. Calculate Output Grid Dimensions\n    spacing = 1 # Space between shapes\n    max_h_per_grid_row = defaultdict(int)\n    max_w_per_grid_col = defaultdict(int)\n\n    for (grid_r_idx, grid_c_idx), target_data in shape_by_grid_idx.items():\n        max_h_per_grid_row[grid_r_idx] = max(max_h_per_grid_row[grid_r_idx], target_data['height'])\n        max_w_per_grid_col[grid_c_idx] = max(max_w_per_grid_col[grid_c_idx], target_data['width'])\n\n    # Calculate total height and width\n    total_h = sum(max_h_per_grid_row[i] for i in range(num_grid_rows)) + max(0, num_grid_rows - 1) * spacing\n    total_w = sum(max_w_per_grid_col[i] for i in range(num_grid_cols)) + max(0, num_grid_cols - 1) * spacing\n\n    # 8. Construct Output Grid\n    output_grid = np.zeros((total_h, total_w), dtype=int)\n\n    current_output_r = 0\n    for grid_r_idx in range(num_grid_rows):\n        current_output_c = 0\n        row_h = max_h_per_grid_row[grid_r_idx] # Max height for this conceptual row\n\n        for grid_c_idx in range(num_grid_cols):\n            col_w = max_w_per_grid_col[grid_c_idx] # Max width for this conceptual col\n\n            # Check if a shape belongs in this grid cell\n            if (grid_r_idx, grid_c_idx) in shape_by_grid_idx:\n                target_data = shape_by_grid_idx[(grid_r_idx, grid_c_idx)]\n                shape_to_paste = target_data['shape']\n                # Paste the shape at the current calculated top-left corner\n                paste_shape(output_grid, shape_to_paste, current_output_r, current_output_c)\n\n            # Move to the next column position, including spacing\n            current_output_c += col_w + spacing\n\n        # Move to the next row position, including spacing\n        current_output_r += row_h + spacing\n\n    # 9. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11160,
    "candidates_token_count": 3440,
    "total_token_count": 14600,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.307088,
  "retries": null
}