{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\n\n\"\"\"\nIdentifies distinct contiguous objects composed of non-background (non-zero) pixels \nusing side-adjacency. For each object found, it determines the set of unique \nnon-background colors present within it. If an object contains exactly two distinct \nnon-background colors, it iterates through the pixels of that object in the output \ngrid (initially a copy of the input) and swaps the two identified colors. Pixels \nthat are part of objects not containing exactly two non-background colors, or \nbackground pixels (color 0), remain unchanged.\n\"\"\"\n\ndef _find_objects(grid, height, width):\n    \"\"\"\n    Finds all distinct contiguous objects of non-background pixels using BFS.\n    \n    Args:\n        grid (list[list[int]]): The input grid.\n        height (int): The height of the grid.\n        width (int): The width of the grid.\n\n    Returns:\n        list[tuple[set[tuple[int, int]], set[int]]]: \n            A list of objects. Each object is represented as a tuple containing:\n            - A set of (row, col) tuples representing the coordinates of the pixels in the object.\n            - A set of integers representing the unique non-background colors present in the object.\n    \"\"\"\n    visited = [[False for _ in range(width)] for _ in range(height)]\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a non-background pixel (color != 0) that hasn't been visited\n            if grid[r][c] != 0 and not visited[r][c]:\n                object_pixels = set()\n                object_colors = set()\n                q = collections.deque([(r, c)])\n                visited[r][c] = True\n\n                # Perform BFS to find all connected non-background pixels\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    pixel_color = grid[curr_r][curr_c]\n\n                    # Record pixel coordinate\n                    object_pixels.add((curr_r, curr_c))\n                    # Only add non-background colors to the object's color set\n                    if pixel_color != 0:\n                        object_colors.add(pixel_color)\n\n                    # Explore neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if the neighbor is part of the same object (non-background) \n                            # and hasn't been visited yet\n                            if grid[nr][nc] != 0 and not visited[nr][nc]:\n                                visited[nr][nc] = True\n                                q.append((nr, nc))\n\n                # Once BFS for an object is complete, store its pixels and unique non-background colors\n                # Ensure the object is not empty (shouldn't happen with the check `grid[r][c] != 0` but good practice)\n                if object_pixels: \n                    objects.append((object_pixels, object_colors))\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping colors within objects that contain exactly two \n    distinct non-background colors.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list of integers representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    # Handle empty input grid scenario\n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input grid.\n    # This ensures that unchanged pixels and objects retain their original values.\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find all distinct contiguous objects of non-background pixels in the input grid.\n    # Each object contains its pixel coordinates and the set of unique non-background colors it holds.\n    objects = _find_objects(input_grid, height, width)\n\n    # Iterate through each identified object to apply the transformation rule.\n    for object_pixels, object_colors in objects:\n        \n        # Check if the object contains exactly two distinct non-background colors.\n        if len(object_colors) == 2:\n            # Extract the two colors to be swapped. Convert set to tuple or list.\n            color_a, color_b = tuple(object_colors)\n\n            # Iterate through each pixel belonging to the current object.\n            for r, c in object_pixels:\n                # IMPORTANT: Check the color in the *original* input_grid to decide the swap.\n                # Modify the corresponding pixel in the *output_grid*.\n                if input_grid[r][c] == color_a:\n                    output_grid[r][c] = color_b\n                elif input_grid[r][c] == color_b:\n                    output_grid[r][c] = color_a\n                # Pixels within the object that might somehow not match color_a or color_b \n                # (e.g., if the object definition included background accidentally, which it shouldn't)\n                # would remain unchanged in the output grid, matching the input grid.\n        \n        # Else (if the object has 1 or >2 unique non-background colors):\n            # No action is needed. The pixels for this object in the output_grid \n            # already hold the correct values copied from the input_grid.\n\n    # Background pixels (color 0) were never part of any object and remain unchanged \n    # because output_grid started as a copy of input_grid.\n\n    # Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14003,
    "candidates_token_count": 1387,
    "total_token_count": 15390,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.956048,
  "retries": null
}