{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Azure Regions:** Locate all contiguous regions of azure (8) pixels in the input grid. Pixels are considered part of the same region if they are adjacent horizontally or vertically.\n2.  **Find Region Center:** For each identified azure region, determine its center. The center is the pixel that is part of the longest horizontal line of pixels in the shape, and longest vertical line of pixels in the shape. If there are two equal maximum length, the center lies between them.\n3.  **Create Green Cross:** Transform the center pixel of each azure region to green (3). Extend the green color outwards from the center, creating a cross (+) shape. The extension continues only along connected azure pixels in each of the four cardinal directions (up, down, left, and right) until a non-azure pixel or the grid edge is encountered.\n4.  **Preserve Other Pixels:** All pixels that are not part of any azure region, or part of a generated green cross, retain their original color values.\n\"\"\"\n\nimport numpy as np\n\ndef find_contiguous_regions(grid, color):\n    # Find all pixels of the specified color.\n    pixels = np.argwhere(grid == color)\n    if len(pixels) == 0:\n        return []\n\n    regions = []\n    visited = set()\n\n    for start_pixel in pixels:\n        start_tuple = tuple(start_pixel)\n        if start_tuple in visited:\n            continue\n\n        region = [start_tuple]\n        queue = [start_tuple]\n        visited.add(start_tuple)\n\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                neighbor_tuple = (nx, ny)\n                if (0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1] and\n                    grid[nx, ny] == color and neighbor_tuple not in visited):\n                    region.append(neighbor_tuple)\n                    queue.append(neighbor_tuple)\n                    visited.add(neighbor_tuple)\n        regions.append(region)\n\n    return regions\n\ndef find_center(region):\n    # Find the longest horizontal and vertical lines within the region.\n    xs = [p[0] for p in region]\n    ys = [p[1] for p in region]\n\n    max_horizontal_length = 0\n    max_vertical_length = 0\n    horizontal_center = None\n    vertical_center = None\n\n    for x in sorted(list(set(xs))):\n        row = [p for p in region if p[0] == x]\n        row.sort(key=lambda p: p[1])  # Sort by y-coordinate\n        for i in range(len(row)):\n            current_length = 1\n            for j in range(i + 1, len(row)):\n                if row[j][1] == row[j-1][1] + 1:\n                    current_length += 1\n                else:\n                    break\n            if current_length > max_horizontal_length:\n                max_horizontal_length = current_length\n                center_y_index = i + current_length // 2\n                horizontal_center = (x, row[center_y_index][1])\n\n    for y in sorted(list(set(ys))):\n        col = [p for p in region if p[1] == y]\n        col.sort(key=lambda p: p[0])\n        for i in range(len(col)):\n            current_length = 1\n            for j in range(i + 1, len(col)):\n                if col[j][0] == col[j-1][0] + 1:\n                    current_length += 1\n                else:\n                    break\n            if current_length > max_vertical_length:\n                max_vertical_length = current_length\n                center_x_index = i + current_length // 2\n                vertical_center = (col[center_x_index][0], y)\n\n    #The intersection is the center.\n    if horizontal_center and vertical_center and horizontal_center[0] == vertical_center[0]:\n       return horizontal_center\n\n    if horizontal_center is None:\n        return vertical_center\n    if vertical_center is None:\n        return horizontal_center\n    #If they don't intersect, take closest.\n    min_dist = 10000\n    best_center = None\n    for x,y in region:\n       dist = abs(x- horizontal_center[0]) + abs(y - vertical_center[1])\n       if dist < min_dist:\n            min_dist = dist\n            best_center = (x,y)\n\n    return best_center\n\ndef create_cross(grid, center, region):\n    # Create the cross by extending outwards from the center.\n    if not center:\n      return\n    \n    x, y = center\n    grid[x, y] = 3  # Set center to green\n\n    # Extend up\n    for i in range(x - 1, -1, -1):\n        if (i, y) in region:\n            grid[i, y] = 3\n        else:\n            break\n\n    # Extend down\n    for i in range(x + 1, grid.shape[0]):\n        if (i, y) in region:\n            grid[i, y] = 3\n        else:\n            break\n\n    # Extend left\n    for j in range(y - 1, -1, -1):\n        if (x, j) in region:\n            grid[x, j] = 3\n        else:\n            break\n\n    # Extend right\n    for j in range(y + 1, grid.shape[1]):\n        if (x, j) in region:\n            grid[x, j] = 3\n        else:\n            break\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    # Find azure regions.\n    azure_regions = find_contiguous_regions(input_grid, 8)\n\n    # Process each azure region.\n    for region in azure_regions:\n        # Find the center of the region.\n        center = find_center(region)\n\n        # Create the green cross within the region.\n        create_cross(output_grid, center, region)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3697,
    "candidates_token_count": 1515,
    "total_token_count": 5212,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 12.751901,
  "response_file": "008-response.json"
}