{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nSimulates gravity acting on connected objects of the same color in a grid.\nNon-white objects (contiguous blocks of the same color, excluding white/0) fall \ndownwards into white space (pixels with value 0) step by step. \nIn each step, all objects that *can* fall one unit down without obstruction do so.\nAn object is obstructed if any pixel directly below any of its constituent pixels \nis either the grid boundary or a non-white pixel that is *not* part of the \nfalling object itself. The process repeats until no object can move further down, \nreaching a stable state. Objects maintain their shape throughout the process.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef transform(input_grid):\n    \"\"\"\n    Applies object-based gravity step-by-step to the input grid until stable.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the grid after gravity simulation.\n    \"\"\"\n    working_grid = np.array(input_grid, dtype=int)\n    height, width = working_grid.shape\n\n    while True:\n        moved_in_iteration = False\n        \n        # --- Identify all potential objects in the current grid state ---\n        objects_data = [] # List to store info about each object found\n        unique_colors = np.unique(working_grid[working_grid != 0])\n\n        for color in unique_colors:\n            mask = (working_grid == color)\n            # Find connected components for the current color\n            labeled_array, num_labels = label(mask) \n            \n            # Store coordinates for each distinct object of this color\n            for i in range(1, num_labels + 1):\n                coords = np.argwhere(labeled_array == i)\n                objects_data.append({'color': color, 'coords': coords})\n\n        # --- Determine which objects can move down one step ---\n        objects_to_move_this_step = [] # List of objects that will be moved\n        \n        # Create a temporary grid representing the current state\n        # Used for checking collisions below objects accurately\n        current_grid_state = working_grid.copy()\n\n        for obj in objects_data:\n            coords = obj['coords']\n            color = obj['color']\n            can_move_down = True # Assume it can move initially\n\n            # Check below each pixel of the object\n            for r, c in coords:\n                r_below = r + 1\n                \n                # Check 1: Is the space below the boundary?\n                if r_below >= height:\n                    can_move_down = False\n                    break # Obstructed by boundary\n\n                # Check 2: Is the space below occupied by a *different* object?\n                # We check against the current_grid_state. \n                # A pixel below is obstructing if it's non-white (not 0) AND \n                # it's not part of the current object itself (this handles cases \n                # where an object might have parts directly below other parts, e.g., an L-shape).\n                is_part_of_self = False\n                for r_obj, c_obj in coords:\n                    if r_below == r_obj and c == c_obj:\n                        is_part_of_self = True\n                        break\n                \n                if current_grid_state[r_below, c] != 0 and not is_part_of_self:\n                    can_move_down = False\n                    break # Obstructed by another pixel\n\n            # If after checking all pixels, it's still possible to move down\n            if can_move_down:\n                objects_to_move_this_step.append(obj)\n                moved_in_iteration = True # Mark that movement occurred\n\n        # --- If no objects moved in this pass, the grid is stable ---\n        if not moved_in_iteration:\n            break # Exit the while loop\n\n        # --- Perform the movement: Erase all moving objects first ---\n        # This prevents conflicts where one moving object would occupy the \n        # starting space of another moving object in the same step.\n        for obj in objects_to_move_this_step:\n             coords = obj['coords']\n             for r, c in coords:\n                 # Ensure we only erase pixels that currently match the object's color\n                 # (Precautionary, as state shouldn't change between finding and erasing)\n                 if working_grid[r, c] == obj['color']:\n                      working_grid[r, c] = 0\n\n        # --- Perform the movement: Draw all moving objects in their new positions ---\n        for obj in objects_to_move_this_step:\n             coords = obj['coords']\n             color = obj['color']\n             # Calculate new coordinates by shifting down by 1\n             new_coords = coords + np.array([1, 0]) \n             for r_new, c_new in new_coords:\n                 # Basic boundary check (should be safe due to can_move_down logic)\n                 if 0 <= r_new < height and 0 <= c_new < width:\n                     working_grid[r_new, c_new] = color\n                 # else: # Optional: Log or handle unexpected out-of-bounds attempt\n\n    # --- Convert the final NumPy array back to a list of lists ---\n    output_grid = working_grid.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4301,
    "candidates_token_count": 1278,
    "total_token_count": 5579,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 172.221021,
  "retries": null
}