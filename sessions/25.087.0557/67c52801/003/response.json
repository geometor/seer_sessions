{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nSimulates gravity acting on connected objects of the same color in a grid.\nNon-white objects (contiguous blocks of the same color) fall downwards \ninto white space (pixels with value 0). An object stops falling when any \npart of its bottom edge encounters a non-white pixel below it or reaches \nthe grid's bottom boundary. The process iterates, allowing objects to fall \nsequentially until no object can move further, reaching a stable state. \nObjects maintain their shape throughout the process.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies object-based gravity to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the grid after gravity simulation.\n    \"\"\"\n    working_grid = np.array(input_grid, dtype=int)\n    height, width = working_grid.shape\n\n    while True:\n        moved_in_iteration = False\n        \n        # Identify all current non-white objects based on the grid state at the start of this iteration\n        current_objects = []\n        # Use scipy.ndimage.label to find all connected components for each non-white color\n        unique_colors = np.unique(working_grid[working_grid != 0])\n        \n        object_pixels_this_iteration = [] # Store list of coords for each object found\n\n        for color in unique_colors:\n            mask = (working_grid == color)\n            # label assigns a unique integer to each connected component\n            labeled_array, num_labels = label(mask) \n            \n            # For each component found for this color\n            for i in range(1, num_labels + 1):\n                # Get all coordinates [(r1, c1), (r2, c2), ...] for this specific object\n                coords = np.argwhere(labeled_array == i)\n                object_pixels_this_iteration.append({'color': color, 'coords': coords})\n\n        # Sort objects by their highest point (minimum row index) to process top objects first.\n        # This helps ensure that objects fall in a more predictable order, though the iteration loop handles stabilization regardless.\n        object_pixels_this_iteration.sort(key=lambda obj: np.min(obj['coords'][:, 0]))\n        \n        # Create a copy of the grid state at the beginning of this iteration\n        # This is crucial for checking collisions, ensuring objects \"decide\" to fall based on the same snapshot\n        grid_before_moves = working_grid.copy()\n\n        # Attempt to move each identified object based on the grid_before_moves state\n        for obj in object_pixels_this_iteration:\n            color = obj['color']\n            coords = obj['coords'] # Original coordinates of the object in grid_before_moves\n\n            # --- Calculate the maximum distance this object can fall ---\n            max_fall_dist = height # Initialize with a large value (max possible fall)\n            possible_to_fall = True # Assume it can fall initially\n\n            # Create a temporary grid representing the state *without* the current object\n            # Used to check for collisions below the object's current position\n            temp_grid_without_obj = grid_before_moves.copy()\n            for r_obj, c_obj in coords:\n                 temp_grid_without_obj[r_obj, c_obj] = 0\n\n            # Check how far each pixel of the object *could* fall vertically before hitting something or the boundary\n            for r_orig, c_orig in coords:\n                dist_this_pixel = 0\n                # Look downwards from the pixel's original position + 1\n                for r_check in range(r_orig + 1, height):\n                    # Check for collision in the grid *without* the object itself\n                    if temp_grid_without_obj[r_check, c_orig] != 0:\n                        # Collision detected below this specific pixel\n                        break # Stop checking downwards for this pixel\n                    dist_this_pixel += 1\n                else: \n                    # Loop finished without break means no collision below this pixel until boundary\n                    # dist_this_pixel is now the distance from r_orig+1 to the boundary\n                    pass \n                \n                # The maximum distance the *entire object* can fall is limited by the \n                # *minimum* distance any single one of its constituent pixels can fall.\n                max_fall_dist = min(max_fall_dist, dist_this_pixel)\n\n                # Optimization: If any pixel cannot fall at all (hits something immediately below),\n                # then the entire object cannot fall.\n                if max_fall_dist == 0:\n                    possible_to_fall = False\n                    break # No need to check other pixels for this object\n\n            # --- Move the object if it can fall ---\n            if possible_to_fall and max_fall_dist > 0:\n                # Erase the object from its *current* position in the *actual working grid*\n                # Do this *before* drawing the object in its new position to handle 1-step falls correctly.\n                for r_erase, c_erase in coords:\n                    # Double-check: only erase if the pixel in the working_grid still belongs to this object\n                    # This handles cases where another object might have landed here earlier *in the same iteration*.\n                     if working_grid[r_erase, c_erase] == color:\n                          working_grid[r_erase, c_erase] = 0\n                \n                # Draw the object in its new, fallen position in the *actual working grid*\n                new_coords = coords + np.array([max_fall_dist, 0])\n                for r_new, c_new in new_coords:\n                    # Basic boundary check (should theoretically not be needed if logic is perfect)\n                    if 0 <= r_new < height and 0 <= c_new < width:\n                         working_grid[r_new, c_new] = color\n                    # else: Optional: Add warning for out-of-bounds draw attempt\n\n                # Mark that at least one object moved in this iteration\n                moved_in_iteration = True\n                # We continue checking the rest of the objects based on the grid_before_moves state.\n                # The effects of this move will be considered in the *next* iteration of the while loop.\n\n        # After checking/moving all objects identified at the start of the iteration,\n        # if no object moved at all, the grid has reached a stable state.\n        if not moved_in_iteration:\n            break # Exit the while loop\n\n    # Convert the final NumPy array back to a list of lists\n    output_grid = working_grid.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8288,
    "candidates_token_count": 1553,
    "total_token_count": 9841,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.48516,
  "retries": null
}