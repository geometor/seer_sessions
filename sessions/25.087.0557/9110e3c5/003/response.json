{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify all contiguous objects of non-background colors (Blue=1, Red=2, Green=3) \nwithin the input grid using 8-way connectivity. Calculate the size of each object. \nFind the object(s) with the maximum size. If there's a tie in size, select the \nobject with the numerically lowest color value (1 < 2 < 3). Based on the selected \ncolor, output a corresponding predefined 3x3 pattern: Pattern A for Blue (1), \nPattern B for Red (2), or Pattern C for Green (3).\n\"\"\"\n\nimport collections\nimport numpy as np\n\n# Define the output patterns as numpy arrays\nPATTERN_A = np.array([[0, 0, 8], [8, 8, 0], [0, 8, 0]], dtype=int)  # Corresponds to Blue (1)\nPATTERN_B = np.array([[0, 0, 0], [8, 8, 8], [0, 0, 0]], dtype=int)  # Corresponds to Red (2)\nPATTERN_C = np.array([[0, 8, 8], [0, 8, 0], [0, 8, 0]], dtype=int)  # Corresponds to Green (3)\n\n# Define 8-way connectivity offsets (including diagonals)\nOFFSETS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),           (0, 1),\n    (1, -1), (1, 0), (1, 1)\n]\n\ndef _find_largest_object_per_color(grid):\n    \"\"\"\n    Finds the size of the largest object for each relevant non-zero color (1, 2, 3) \n    in the grid using 8-way connectivity.\n\n    Args:\n        grid: A list of lists or numpy array representing the input grid.\n\n    Returns:\n        A dictionary mapping relevant color (1, 2, 3) -> max_object_size for that color.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    color_max_sizes = collections.defaultdict(int)\n    relevant_colors = {1, 2, 3} # Only consider Blue, Red, Green\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r][c]\n            # If pixel is a relevant color and hasn't been visited yet\n            if color in relevant_colors and (r, c) not in visited:\n                current_object_size = 0\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_size += 1\n\n                    # Check 8 neighbors\n                    for dr, dc in OFFSETS:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds, color match, and visited status\n                        if (0 <= nr < rows and\n                            0 <= nc < cols and\n                            grid[nr][nc] == color and\n                            (nr, nc) not in visited):\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Update the maximum size found for this color\n                color_max_sizes[color] = max(color_max_sizes[color], current_object_size)\n\n    return dict(color_max_sizes)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the color of the largest object (with tie-breaking).\n\n    Args:\n        input_grid: A list of lists or numpy array representing the 2D input grid.\n\n    Returns:\n        A 3x3 numpy array representing the output grid pattern, or None if no relevant \n        objects (colors 1, 2, 3) are found.\n    \"\"\"\n    # Ensure input is a numpy array for consistent access\n    input_grid_np = np.array(input_grid, dtype=int)\n\n    # 1 & 2: Identify objects and calculate their sizes (specifically max size per color)\n    color_max_sizes = _find_largest_object_per_color(input_grid_np)\n\n    # Handle case where no relevant objects are found\n    if not color_max_sizes:\n        # Return a default pattern or indicate error/unexpected input\n        # Based on problem description, this shouldn't happen with valid inputs.\n        # Returning an empty 3x3 or None might be options. Let's return None for now.\n        return None \n\n    # 3. Find the maximum size among all relevant objects\n    max_size = -1\n    for color in color_max_sizes:\n        max_size = max(max_size, color_max_sizes[color])\n\n    # 4 & 5. Determine the color(s) with max size and apply tie-breaking (lowest color index)\n    largest_color = -1\n    # Check colors in the specific tie-breaking order: 1, 2, 3\n    for color in sorted(color_max_sizes.keys()): \n        if color_max_sizes[color] == max_size:\n            largest_color = color\n            break # Found the lowest color index with the max size\n\n    # 6 & 7. Select the output pattern based on the determined largest color\n    if largest_color == 1:\n        output_grid = PATTERN_A\n    elif largest_color == 2:\n        output_grid = PATTERN_B\n    elif largest_color == 3:\n        output_grid = PATTERN_C\n    else:\n        # This case should ideally not be reached if input always contains 1, 2, or 3\n        print(f\"Warning: Could not determine a valid largest color. Max sizes: {color_max_sizes}\")\n        # Decide on fallback behavior, e.g., return a default pattern or None\n        return None # Indicate an issue\n\n    # 8. Return the determined 3x3 pattern as a numpy array\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4025,
    "candidates_token_count": 1440,
    "total_token_count": 5465,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.726455,
  "retries": null
}