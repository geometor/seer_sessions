{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nSimulate a gravity-like effect where non-red, non-white objects 'fall' towards \na static red object until they hit the red object, another object, or the \ngrid boundary. The direction of 'gravity' is determined by the relative \nposition of the red object(s) compared to the other colored objects. If the red \nobject is predominantly below the others, gravity is downwards. If it's to the \nleft, gravity is leftwards. If it's to the right, gravity is rightwards. \nObjects move one step at a time iteratively until no object can move further.\n\"\"\"\n\nimport numpy as np\n\ndef determine_direction(grid):\n    \"\"\"\n    Determines the direction of movement based on the relative positions of\n    red (2) pixels and other non-white (0) pixels.\n    Returns: tuple (delta_row, delta_col) representing the direction vector.\n             (1, 0) for down, (0, -1) for left, (0, 1) for right.\n             Returns (0, 0) if direction cannot be determined or no movement needed.\n    \"\"\"\n    height, width = grid.shape\n    red_pixels = np.argwhere(grid == 2)\n    other_pixels = np.argwhere((grid != 0) & (grid != 2))\n\n    if red_pixels.size == 0 or other_pixels.size == 0:\n        return (0, 0) # No barrier or nothing to move\n\n    # Calculate average positions\n    red_r_avg = np.mean(red_pixels[:, 0])\n    red_c_avg = np.mean(red_pixels[:, 1])\n    other_r_avg = np.mean(other_pixels[:, 0])\n    other_c_avg = np.mean(other_pixels[:, 1])\n\n    # Compare average positions to determine dominant direction\n    # Check vertical difference primarily first, then horizontal\n    if red_r_avg > other_r_avg + 0.5: # Red is significantly below others\n         # Check if red spans horizontally more than vertically, reinforcing 'down'\n         red_height = np.max(red_pixels[:, 0]) - np.min(red_pixels[:, 0]) + 1\n         red_width = np.max(red_pixels[:, 1]) - np.min(red_pixels[:, 1]) + 1\n         if red_width >= red_height or red_r_avg > height * 0.6 : # Bias towards down if low\n             return (1, 0) # Down\n             \n    # Check horizontal only if vertical wasn't conclusive or red isn't clearly below\n    if red_c_avg < other_c_avg - 0.5: # Red is significantly left of others\n        # Check if red spans vertically more than horizontally, reinforcing 'left'\n        red_height = np.max(red_pixels[:, 0]) - np.min(red_pixels[:, 0]) + 1\n        red_width = np.max(red_pixels[:, 1]) - np.min(red_pixels[:, 1]) + 1\n        if red_height >= red_width or red_c_avg < width * 0.4: # Bias towards left if far left\n            return (0, -1) # Left\n            \n    if red_c_avg > other_c_avg + 0.5: # Red is significantly right of others\n         # Check if red spans vertically more than horizontally, reinforcing 'right'\n         red_height = np.max(red_pixels[:, 0]) - np.min(red_pixels[:, 0]) + 1\n         red_width = np.max(red_pixels[:, 1]) - np.min(red_pixels[:, 1]) + 1\n         if red_height >= red_width or red_c_avg > width * 0.6: # Bias towards right if far right\n             return (0, 1) # Right\n\n    # Fallback / edge cases - e.g., objects surrounding barrier\n    # Use boundary proximity if averages are close\n    if np.any(red_pixels[:,0] == height - 1) and not np.any(red_pixels[:,0] == 0): return (1, 0) # Down if red touches bottom\n    if np.any(red_pixels[:,1] == 0) and not np.any(red_pixels[:,1] == width - 1): return (0, -1) # Left if red touches left\n    if np.any(red_pixels[:,1] == width - 1) and not np.any(red_pixels[:,0] == 0): return (0, 1) # Right if red touches right\n        \n    return (0, 0) # Default to no movement if unclear\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a gravity-like transformation to the input grid. Non-red, non-white\n    pixels move towards the static red pixels until blocked.\n    Args:\n        input_grid (list[list[int]]): The input grid.\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n    \n    # Determine the direction of movement\n    delta_r, delta_c = determine_direction(grid)\n\n    # If no direction determined, return the original grid\n    if delta_r == 0 and delta_c == 0:\n        return grid.tolist()\n\n    # Simulation loop: continue as long as any pixel moves\n    while True:\n        moved_in_iteration = False\n        pixels_to_move = [] # Store (old_r, old_c, new_r, new_c)\n\n        # Determine iteration order based on direction to handle dependencies correctly\n        # Process pixels that are \"further away\" from the barrier first in the direction of movement\n        if delta_r == 1: # Down\n            row_indices = range(height - 2, -1, -1) # Bottom-up (excluding last row)\n            col_indices = range(width)\n        elif delta_c == -1: # Left\n            row_indices = range(height)\n            col_indices = range(1, width) # Right-to-left (excluding first column)\n        elif delta_c == 1: # Right\n            row_indices = range(height)\n            col_indices = range(width - 2, -1, -1) # Left-to-right (excluding last column)\n        else: # Should not happen if direction is determined, but handle defensively\n             row_indices = range(height)\n             col_indices = range(width)\n\n        # Iterate through potentially moving pixels\n        for r in row_indices:\n            for c in col_indices:\n                pixel_color = grid[r, c]\n                \n                # Check if the pixel is a movable object (non-white, non-red)\n                if pixel_color != 0 and pixel_color != 2:\n                    # Calculate potential next position\n                    next_r, next_c = r + delta_r, c + delta_c\n\n                    # Check if the next position is valid\n                    # 1. Within grid boundaries\n                    if 0 <= next_r < height and 0 <= next_c < width:\n                        # 2. The target cell is currently empty (white)\n                        if grid[next_r, next_c] == 0:\n                            # Mark this pixel for movement\n                            pixels_to_move.append((r, c, next_r, next_c))\n                            moved_in_iteration = True\n                        # Else: Blocked by boundary, red barrier, or another object\n                    # Else: Blocked by grid boundary\n\n        # If no pixels moved in this iteration, the simulation is stable\n        if not moved_in_iteration:\n            break\n\n        # Apply the movements for this iteration\n        # Important: Clear old positions first, then fill new ones to avoid conflicts within the same step\n        \n        # Store colors before clearing\n        move_details = []\n        for r, c, nr, nc in pixels_to_move:\n             move_details.append({'color': grid[r,c], 'nr': nr, 'nc': nc})\n        \n        # Clear old positions\n        for r, c, _, _ in pixels_to_move:\n            grid[r, c] = 0\n            \n        # Fill new positions\n        for move in move_details:\n             grid[move['nr'], move['nc']] = move['color']\n\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = grid.tolist()\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3140,
    "candidates_token_count": 2012,
    "total_token_count": 5152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.187197,
  "retries": null
}