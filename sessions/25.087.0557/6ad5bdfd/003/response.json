{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nSimulates a gravity-like effect where non-red, non-white objects, treated as \nwhole units, 'fall' towards a static red barrier until they hit the red barrier, \nanother object, or the grid boundary. The direction of 'gravity' (Down, Left, \nor Right) is determined by the relative average position of the red barrier(s) \ncompared to the movable objects. Objects move one step at a time iteratively \nuntil no object can move further, maintaining their shape and integrity.\n\"\"\"\n\ndef find_objects(grid, colors_to_find):\n    \"\"\"\n    Finds all contiguous objects of specified colors in the grid.\n    Uses 8-way connectivity (including diagonals).\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of color values to find objects for.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary:\n              {'color': int, 'pixels': list of (r, c) tuples}.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color in colors_to_find and not visited[r, c]:\n                # Start BFS to find all connected pixels of the same color\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds, color match, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n                    \n    return objects\n\ndef determine_direction(grid, movable_objects, barrier_pixels):\n    \"\"\"\n    Determines the direction of movement based on the relative positions of\n    red (2) pixels and movable objects.\n\n    Args:\n        grid (np.array): The grid.\n        movable_objects (list): List of movable object dicts.\n        barrier_pixels (list): List of (r, c) tuples for red pixels.\n\n    Returns:\n        tuple: (delta_row, delta_col) representing the direction vector.\n               (1, 0) for down, (0, -1) for left, (0, 1) for right.\n               Returns (0, 0) if direction cannot be determined or no movement needed.\n    \"\"\"\n    height, width = grid.shape\n\n    if not barrier_pixels or not movable_objects:\n        return (0, 0) # No barrier or nothing to move\n\n    # Calculate average positions\n    barrier_r_coords = [p[0] for p in barrier_pixels]\n    barrier_c_coords = [p[1] for p in barrier_pixels]\n    barrier_r_avg = np.mean(barrier_r_coords)\n    barrier_c_avg = np.mean(barrier_c_coords)\n\n    all_object_pixels = [p for obj in movable_objects for p in obj['pixels']]\n    if not all_object_pixels:\n         return (0,0)\n         \n    object_r_coords = [p[0] for p in all_object_pixels]\n    object_c_coords = [p[1] for p in all_object_pixels]\n    object_r_avg = np.mean(object_r_coords)\n    object_c_avg = np.mean(object_c_coords)\n\n    # Determine direction based on average positions\n    # Prioritize vertical difference slightly\n    delta_r_diff = barrier_r_avg - object_r_avg\n    delta_c_diff = barrier_c_avg - object_c_avg\n\n    # Use a threshold to avoid ambiguity when averages are very close\n    threshold = 0.1 \n\n    # Check Down first\n    if delta_r_diff > threshold and delta_r_diff > abs(delta_c_diff):\n        return (1, 0) # Down\n        \n    # Check Left\n    if delta_c_diff < -threshold and abs(delta_c_diff) >= delta_r_diff :\n         return (0, -1) # Left\n\n    # Check Right\n    if delta_c_diff > threshold and delta_c_diff >= delta_r_diff:\n         return (0, 1) # Right\n\n    # Fallback: Check Down if red is mostly below, even if horizontal diff is larger\n    if delta_r_diff > threshold:\n         return (1,0)\n\n    # --- Refined Fallback / edge cases ---\n    # Check proximity to boundaries if averages are close or ambiguous\n    max_barrier_r = max(barrier_r_coords) if barrier_r_coords else -1\n    min_barrier_r = min(barrier_r_coords) if barrier_r_coords else height\n    max_barrier_c = max(barrier_c_coords) if barrier_c_coords else -1\n    min_barrier_c = min(barrier_c_coords) if barrier_c_coords else width\n\n    if max_barrier_r == height - 1 and min_barrier_r > 0 : return (1, 0) # Red touches bottom, not top -> Down\n    if min_barrier_c == 0 and max_barrier_c < width -1 : return (0, -1) # Red touches left, not right -> Left\n    if max_barrier_c == width - 1 and min_barrier_c > 0: return (0, 1) # Red touches right, not left -> Right\n    \n    # Default: If still unclear, favor Down if possible, otherwise no movement\n    if delta_r_diff > 0: # If red is generally below at all\n        return (1, 0)\n        \n    return (0, 0) # Default to no movement if unclear\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a gravity-like transformation to the input grid. Non-red, non-white\n    objects, treated as single units, move towards the static red pixels \n    (color 2) until blocked by the grid boundary, the red barrier, or another \n    settled object. Objects maintain their integrity.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Define movable colors (all except white 0 and red 2)\n    movable_colors = set(range(10)) - {0, 2}\n\n    # --- Initialization ---\n    # 1. Identify barrier pixels\n    barrier_pixels = list(zip(*np.where(grid == 2)))\n\n    # 2. Identify all movable objects\n    # We re-find objects in each iteration's grid state\n    \n    # 3. Determine the single global direction of gravity\n    initial_objects = find_objects(grid, movable_colors)\n    delta_r, delta_c = determine_direction(grid, initial_objects, barrier_pixels)\n\n    # If no direction determined, return the original grid\n    if delta_r == 0 and delta_c == 0:\n        return grid.tolist()\n\n    # Set to keep track of objects that have settled\n    settled_object_indices = set() \n    # Assign unique IDs to objects for tracking (indices in the list work)\n    \n    # --- Simulation Loop ---\n    while True:\n        moved_this_iteration = False\n        \n        # Find current objects in the grid - needed if objects merge etc.\n        # For this problem, shapes are static, so just tracking indices is likely ok,\n        # but re-finding is safer for complex interactions. Let's use initial objects for simplicity.\n        current_objects = find_objects(grid, movable_colors)\n        if not current_objects: # No objects left to move\n             break\n             \n        # Create mapping from pixel location to object index for quick lookup\n        pixel_to_object_idx = {}\n        for idx, obj in enumerate(current_objects):\n             for r, c in obj['pixels']:\n                  pixel_to_object_idx[(r, c)] = idx\n\n\n        objects_to_move_this_step = [] # Store tuples: (obj_idx, current_pixels, next_pixels)\n\n        # Determine iteration order based on gravity direction\n        # Sort by key: for Down -> max row desc, Left -> min col asc, Right -> max col desc\n        def sort_key(obj_idx_pair):\n            idx, obj = obj_idx_pair\n            if delta_r == 1: # Down\n                return max(p[0] for p in obj['pixels'])\n            elif delta_c == -1: # Left\n                return min(p[1] for p in obj['pixels'])\n            elif delta_c == 1: # Right\n                return max(p[1] for p in obj['pixels'])\n            return 0 # Should not happen\n\n        sorted_object_indices = sorted(enumerate(current_objects), \n                                     key=sort_key, \n                                     reverse=(delta_r == 1 or delta_c == 1)) # Reverse for Down and Right\n\n        # Check each object for potential movement\n        for obj_idx, obj in sorted_object_indices:\n            # Skip if already settled\n            if obj_idx in settled_object_indices:\n                continue\n\n            can_move = True\n            next_pixel_positions = []\n            current_pixels = obj['pixels']\n            obj_color = obj['color']\n\n            # Calculate potential next positions for all pixels in the object\n            for r, c in current_pixels:\n                next_r, next_c = r + delta_r, c + delta_c\n                next_pixel_positions.append((next_r, next_c))\n\n                # Check if the next position is valid\n                # 1. Out of bounds?\n                if not (0 <= next_r < height and 0 <= next_c < width):\n                    can_move = False\n                    break\n                # 2. Hits a red barrier?\n                if grid[next_r, next_c] == 2:\n                    can_move = False\n                    break\n                # 3. Hits another non-white pixel *not* part of the current object?\n                if grid[next_r, next_c] != 0 and (next_r, next_c) not in current_pixels:\n                     # Check if the blocking pixel belongs to an already settled object\n                     blocking_obj_idx = pixel_to_object_idx.get((next_r, next_c), -1)\n                     if blocking_obj_idx != -1 and blocking_obj_idx in settled_object_indices:\n                          can_move = False\n                          break\n                     # If it hits another *moving* object in this step, allow it for now\n                     # Conflict resolution happens implicitly by processing order or later checks\n                     # Simplest: if target is non-0 and not self -> block.\n                     can_move = False\n                     break\n\n            # If all pixels can move to valid empty spots\n            if can_move:\n                objects_to_move_this_step.append((obj_idx, obj_color, current_pixels, next_pixel_positions))\n                moved_this_iteration = True\n            else:\n                # Mark this object as settled for future iterations\n                settled_object_indices.add(obj_idx)\n\n        # If no objects moved in this iteration, the simulation is stable\n        if not moved_this_iteration:\n            break\n\n        # --- Apply Moves ---\n        # Create a temporary grid or update carefully\n        # 1. Erase old positions of moving objects\n        for _, _, current_pixels, _ in objects_to_move_this_step:\n            for r, c in current_pixels:\n                grid[r, c] = 0\n        \n        # 2. Draw new positions of moving objects\n        for obj_idx, color, _, next_pixels in objects_to_move_this_step:\n            for r, c in next_pixels:\n                # Check for conflicts again just before drawing (though sorting should handle most)\n                if grid[r,c] == 0: \n                     grid[r, c] = color\n                else:\n                     # This case indicates a potential issue in logic or simultaneous moves\n                     # For now, let the first object claim the spot based on sort order\n                     # Or potentially revert this object's move and mark as settled?\n                     # Let's assume sort order prevents direct conflict for now.\n                     # Mark the object as settled if conflict occurs? Best approach depends on desired interaction.\n                     # Fallback: If conflict, mark current obj as settled and don't draw it\n                     # This needs careful handling if reverting is desired.\n                     # Let's stick to overwriting based on sort order for simplicity here.\n                     grid[r, c] = color # Overwrite based on processing order\n                     \n            # Update the object's pixel list in the main structure if needed for next iter (if not re-finding)\n            # current_objects[obj_idx]['pixels'] = next_pixels # Requires obj_idx to be stable index\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = grid.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7827,
    "candidates_token_count": 3227,
    "total_token_count": 11054,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.295697,
  "retries": null
}