{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation rule involves splitting the input grid vertically into two parts based on the first column consisting entirely of white pixels (0). \n\n1. Identify the left part and the right part of the grid.\n2. Identify the background color of the left part (typically the color at [0, 0]).\n3. Find all contiguous regions of white pixels (0) in the left part. These are the \"holes\". For each hole, determine its shape represented by the relative coordinates of its pixels.\n4. Find all contiguous, non-white objects in the right part. For each object, determine its color and its shape (relative coordinates).\n5. Match each object from the right part to a hole in the left part based on identical shapes (relative coordinates).\n6. Create the output grid by copying the left part of the input grid.\n7. For each matched object-hole pair, fill the pixels corresponding to the hole in the output grid with the color of the matched object.\n\"\"\"\n\ndef find_objects(grid, target_color=None, background_color=None, connectivity=4):\n    \"\"\"\n    Finds contiguous regions (objects) of a specific color or any non-background color in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int, optional): The specific color to find objects of. Defaults to None.\n        background_color (int, optional): The color to ignore (treat as background).\n                                          If target_color is None, finds objects of any color\n                                          *not* equal to background_color. Defaults to None.\n        connectivity (int): 4 or 8 way connectivity. Defaults to 4.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object and contains:\n              'color': The color of the object.\n              'relative_coords': A frozenset of (row, col) tuples relative to the object's top-left corner.\n              'absolute_coords': A frozenset of (row, col) tuples in the original grid coordinates.\n              'bbox': A tuple (min_r, min_c, max_r, max_c) representing the bounding box.\n    \"\"\"\n    if target_color is None and background_color is None:\n         background_color = 0 # Default background color if nothing else specified\n\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n\n    for r in range(rows):\n        for c in range(cols):\n            if visited[r, c]:\n                continue\n\n            pixel_color = grid[r, c]\n            is_target = False\n\n            if target_color is not None:\n                # Looking for a specific color\n                if pixel_color == target_color:\n                    is_target = True\n            elif background_color is not None:\n                # Looking for anything not background\n                if pixel_color != background_color:\n                    is_target = True\n            \n            # If pixel is part of the background (and we are not specifically targeting it), skip\n            if background_color is not None and pixel_color == background_color and target_color != background_color :\n                 continue\n\n            if is_target:\n                # Start Breadth-First Search (BFS) to find the connected component\n                component_coords = []\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                current_color = pixel_color # The color of the component being traced\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors\n                    for dr, dc in deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Check if a component was actually found (size > 0)\n                if component_coords:\n                    # Calculate relative coordinates based on the bounding box top-left\n                    relative_coords = frozenset((rr - min_r, cc - min_c) for rr, cc in component_coords)\n                    absolute_coords = frozenset(component_coords)\n\n                    objects.append({\n                        'color': current_color,\n                        'relative_coords': relative_coords,\n                        'absolute_coords': absolute_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n                    \n    return objects\n\ndef split_grid(grid):\n    \"\"\"Splits the grid vertically based on the first all-white column.\"\"\"\n    rows, cols = grid.shape\n    split_col = -1\n    white_color = 0 # Define white color\n    for c in range(cols):\n        if np.all(grid[:, c] == white_color):\n            split_col = c\n            break\n            \n    if split_col == -1:\n        # If no split column found, maybe the pattern is different or it's the whole grid\n        # For this task, assume the split always exists as per examples.\n        # Alternatively, could return grid, None or raise error\n         raise ValueError(\"No separating white column found in the grid.\")\n\n    left_grid = grid[:, :split_col]\n    # Ensure there's content to the right of the split column before slicing\n    if split_col + 1 < cols:\n        right_grid = grid[:, split_col + 1:]\n    else:\n        right_grid = np.array([[]] * rows) # Empty grid if split is at the last column\n\n    return left_grid, right_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: identifies holes in the left part and objects\n    in the right part of the input grid based on a white separator column,\n    matches them by shape, and fills the holes with the corresponding object colors.\n    \"\"\"\n    # 1. Split the grid\n    left_grid, right_grid = split_grid(input_grid)\n    \n    # Initialize output grid as a copy of the left part\n    output_grid = np.copy(left_grid)\n    \n    # Define white color (holes) and background color for objects on the right\n    white_color = 0\n    \n    # 3. Find holes (white regions) in the left grid\n    # We are looking for contiguous regions of 'white_color'\n    holes = find_objects(left_grid, target_color=white_color)\n    \n    # 4. Find non-white objects in the right grid\n    # We are looking for anything that isn't 'white_color'\n    objects = find_objects(right_grid, background_color=white_color)\n\n    # 5. Match objects to holes based on shape (relative coordinates)\n    # Create a dictionary for holes based on their shape for faster lookup\n    holes_by_shape = {hole['relative_coords']: hole for hole in holes}\n\n    # 6. Fill holes in the output grid\n    for obj in objects:\n        obj_shape = obj['relative_coords']\n        obj_color = obj['color']\n        \n        # Find the matching hole by shape\n        if obj_shape in holes_by_shape:\n            matching_hole = holes_by_shape[obj_shape]\n            \n            # Iterate through the absolute coordinates of the hole and fill with object color\n            for r, c in matching_hole['absolute_coords']:\n                # Ensure coordinates are within the bounds of the output grid (should be)\n                if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                    output_grid[r, c] = obj_color\n            \n            # Optional: remove matched hole to prevent multiple matches if shapes were identical\n            # del holes_by_shape[obj_shape] \n        # else:\n            # Handle cases where an object shape doesn't match any hole shape (optional)\n            # print(f\"Warning: Object with color {obj_color} and shape {obj_shape} did not match any hole.\")\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1910,
    "candidates_token_count": 2103,
    "total_token_count": 4013,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 130.765665,
  "retries": null
}