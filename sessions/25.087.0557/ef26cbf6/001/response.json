{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule involves identifying horizontal regions separated by yellow lines (color 4). \nWithin these regions, blue objects (color 1) act as targets, and objects of other colors (excluding white 0 and yellow 4) act as sources.\n\n1.  **Region Identification**: Find horizontal lines of yellow pixels (color 4) that span the entire width of the grid. These lines, along with the top and bottom grid boundaries, define distinct horizontal regions.\n\n2.  **Object Identification**: Within each region, identify all contiguous objects of blue color (1) as 'target' objects and all contiguous objects of any color other than white (0), blue (1), or yellow (4) as 'source' objects. Store their color, pixel coordinates, bounding box, and the index of the region they belong to.\n\n3.  **Mapping Logic**: Determine how source colors map to target objects:\n    a.  **Same-Region Mapping**: If a region contains exactly one source object and one or more target objects, all target objects in that region take the color of that single source object. Mark these source and target objects as 'mapped'.\n    b.  **Cross-Region Mapping**: Consider all 'unmapped' source objects and 'unmapped' target objects from all regions. Sort the unmapped source objects from left to right based on their minimum column index. Sort the unmapped target objects similarly. If the number of unmapped sources equals the number of unmapped targets, map the color of the i-th sorted source object to the i-th sorted target object. Mark these objects as 'mapped'.\n\n4.  **Applying Transformation**:\n    a.  Create a copy of the input grid.\n    b.  For each mapping determined in step 3, change the color of all pixels belonging to the target object to the corresponding source object's color in the copied grid.\n    c.  For every source object that was used in a mapping (i.e., marked as 'mapped'), change the color of its original pixels to white (0) in the copied grid.\n\n5.  **Output**: Return the modified grid.\n\"\"\"\n\ndef find_objects(grid, colors_to_find, region_mask=None):\n    \"\"\"Finds contiguous objects of specified colors within a grid or masked region.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            # Skip if outside the specified region (if mask is provided)\n            if region_mask is not None and not region_mask[r, c]:\n                continue\n                \n            # Skip if visited or not a target color\n            if visited[r, c] or grid[r, c] not in colors_to_find:\n                continue\n\n            color = grid[r, c]\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check neighbors (4-connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       not visited[nr, nc] and grid[nr, nc] == color and \\\n                       (region_mask is None or region_mask[nr, nc]):\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n            \n            objects.append({\n                'color': color,\n                'pixels': obj_pixels,\n                'bbox': (min_r, min_c, max_r, max_c),\n                'mapped': False # Add mapped flag\n            })\n            \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify separators and define regions\n    separator_rows = [-1] # Start with a virtual separator above the grid\n    for r in range(height):\n        if np.all(input_grid[r, :] == 4):\n            separator_rows.append(r)\n    separator_rows.append(height) # Add a virtual separator below the grid\n\n    regions = []\n    for i in range(len(separator_rows) - 1):\n        start_row = separator_rows[i] + 1\n        end_row = separator_rows[i+1]\n        if start_row < end_row: # Ensure region has height > 0\n            regions.append({'index': i, 'rows': (start_row, end_row)})\n\n    # 2. Find all source and target objects and assign region index\n    all_source_objects = []\n    all_target_objects = []\n    source_colors = {2, 3, 5, 6, 7, 8, 9} # All colors except white, blue, yellow\n    target_color = {1}\n    \n    for region_info in regions:\n        region_idx = region_info['index']\n        start_row, end_row = region_info['rows']\n        \n        # Create a mask for the current region\n        region_mask = np.zeros_like(input_grid, dtype=bool)\n        region_mask[start_row:end_row, :] = True\n        \n        # Find sources in this region\n        region_sources = find_objects(input_grid, source_colors, region_mask)\n        for obj in region_sources:\n            obj['region_index'] = region_idx\n        all_source_objects.extend(region_sources)\n        \n        # Find targets in this region\n        region_targets = find_objects(input_grid, target_color, region_mask)\n        for obj in region_targets:\n            obj['region_index'] = region_idx\n        all_target_objects.extend(region_targets)\n\n    # 3. Determine mappings\n    mappings = [] # List of tuples: (source_color, target_pixels_set)\n    source_pixels_to_clear = set() # Collect pixels of source objects used in mapping\n\n    # 3a. Same-Region Mapping\n    objects_by_region = {}\n    for obj in all_source_objects + all_target_objects:\n        region_idx = obj['region_index']\n        if region_idx not in objects_by_region:\n            objects_by_region[region_idx] = {'sources': [], 'targets': []}\n        if obj['color'] == 1:\n            objects_by_region[region_idx]['targets'].append(obj)\n        else:\n            objects_by_region[region_idx]['sources'].append(obj)\n\n    for region_idx, groups in objects_by_region.items():\n        region_sources = groups['sources']\n        region_targets = groups['targets']\n        \n        if len(region_sources) == 1 and len(region_targets) > 0:\n            source_obj = region_sources[0]\n            if not source_obj['mapped']: # Check if source already mapped\n                source_color = source_obj['color']\n                source_pixels = source_obj['pixels']\n                \n                source_obj['mapped'] = True # Mark source as mapped\n                source_pixels_to_clear.update(source_pixels) # Add its pixels to clear list\n                \n                for target_obj in region_targets:\n                     if not target_obj['mapped']: # Check if target already mapped\n                        mappings.append((source_color, target_obj['pixels']))\n                        target_obj['mapped'] = True # Mark target as mapped\n\n    # 3b. Cross-Region Mapping\n    unmapped_sources = [obj for obj in all_source_objects if not obj['mapped']]\n    unmapped_targets = [obj for obj in all_target_objects if not obj['mapped']]\n\n    if len(unmapped_sources) > 0 and len(unmapped_sources) == len(unmapped_targets):\n        # Sort by horizontal position (min column index of bounding box)\n        unmapped_sources.sort(key=lambda obj: obj['bbox'][1])\n        unmapped_targets.sort(key=lambda obj: obj['bbox'][1])\n\n        for i in range(len(unmapped_sources)):\n            source_obj = unmapped_sources[i]\n            target_obj = unmapped_targets[i]\n            \n            source_color = source_obj['color']\n            source_pixels = source_obj['pixels']\n            target_pixels = target_obj['pixels']\n\n            mappings.append((source_color, target_pixels))\n            source_pixels_to_clear.update(source_pixels)\n            \n            # Mark as mapped (redundant if only processing unmapped, but good practice)\n            source_obj['mapped'] = True \n            target_obj['mapped'] = True\n\n    # 4. Apply transformations\n    # 4a. Apply color changes based on mappings\n    for source_color, target_pixels in mappings:\n        for r, c in target_pixels:\n            if 0 <= r < height and 0 <= c < width: # Bounds check just in case\n                 output_grid[r, c] = source_color\n\n    # 4c. Clear original source pixels\n    for r, c in source_pixels_to_clear:\n         if 0 <= r < height and 0 <= c < width: # Bounds check\n            output_grid[r, c] = 0 # Set to white\n\n    # 5. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3311,
    "candidates_token_count": 2373,
    "total_token_count": 5684,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.811148,
  "retries": null
}