{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies zones separated by yellow lines in a grid. Finds 'source' objects (non-white/blue/yellow) and 'target' objects (blue) within these zones. Maps sources to targets based on proximity rules (within the same zone, or in vertically/horizontally adjacent zones). Transfers the source object's color to its mapped target objects, leaving the original source objects unchanged.\n\n1.  **Analyze Grid Structure**: Identify all complete horizontal and vertical lines composed solely of yellow (4) pixels. These lines, along with the grid borders, define distinct rectangular zones.\n2.  **Identify Objects within Zones**:\n    *   For each zone:\n        *   Find all contiguous groups of pixels that are not white (0), blue (1), or yellow (4). These are 'source' objects. Record their color, constituent pixel coordinates, and the zone they belong to.\n        *   Find all contiguous groups of pixels that are blue (1). These are 'target' objects. Record their color (blue), constituent pixel coordinates, and the zone they belong to.\n3.  **Establish Mappings**: Determine which source objects provide color for which target objects according to the following prioritized rules. Once a source or target object is used in a mapping, it cannot be used again.\n    *   **Rule 1 (Intra-Zone)**: For each zone, if it contains exactly one *unmapped* source object and one or more *unmapped* target objects, map this source object to *all* those target objects within the same zone. Mark the source and target objects as mapped.\n    *   **Rule 2 (Inter-Zone Vertical)**: Check pairs of vertically adjacent zones. If one zone contains exactly one *unmapped* source object and the adjacent zone contains one or more *unmapped* target objects, map the source object to *all* those target objects in the adjacent zone. Perform this check for both directions (source above targets, source below targets). Mark the involved source and target objects as mapped.\n    *   **Rule 3 (Inter-Zone Horizontal)**: Check pairs of horizontally adjacent zones. If one zone contains exactly one *unmapped* source object and the adjacent zone contains one or more *unmapped* target objects, map the source object to *all* those target objects in the adjacent zone. Perform this check for both directions (source left of targets, source right of targets). Mark the involved source and target objects as mapped.\n4.  **Apply Transformations**: Create a copy of the input grid. For every mapping created in step 3:\n    *   Iterate through all the pixel coordinates associated with the target object(s) in the mapping.\n    *   Change the color of these pixels in the copied grid to the color of the corresponding source object.\n5.  **Output**: Return the modified grid. The original source objects and yellow separator lines remain unchanged from the input grid.\n\"\"\"\n\n\ndef find_objects(grid, colors_to_find, zone_mask):\n    \"\"\"\n    Finds contiguous objects of specified colors within a masked zone of the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of color values to search for.\n        zone_mask (np.array): A boolean mask of the same shape as grid,\n                               True for pixels within the current zone.\n\n    Returns:\n        list: A list of dictionaries, each representing an object found.\n              Each dictionary contains 'color', 'pixels', 'bbox', and 'mapped'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Skip if outside the specified zone or already visited\n            if not zone_mask[r, c] or visited[r, c]:\n                continue\n\n            # Skip if not a target color for this search\n            if grid[r, c] not in colors_to_find:\n                continue\n\n            color = grid[r, c]\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check neighbors (4-connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       zone_mask[nr, nc] and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            if obj_pixels: # Only add if pixels were found\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'mapped': False # Initialize mapped flag\n                })\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on zone mapping.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # Define object types and colors\n    source_colors = {2, 3, 5, 6, 7, 8, 9} # All colors except white(0), blue(1), yellow(4)\n    target_color = {1} # Blue\n    separator_color = 4 # Yellow\n    # background_color = 0 # White - Not needed for clearing sources anymore\n\n    # --- 1. Analyze Grid Structure (Identify Separators and Zones) ---\n    h_sep_rows = [-1] + [r for r in range(height) if np.all(input_grid_np[r, :] == separator_color)] + [height]\n    v_sep_cols = [-1] + [c for c in range(width) if np.all(input_grid_np[:, c] == separator_color)] + [width]\n\n    num_zone_rows = len(h_sep_rows) - 1\n    num_zone_cols = len(v_sep_cols) - 1\n\n    zones = {} # Store zone info: bounds, sources, targets\n\n    # --- 2. Identify Objects per Zone ---\n    # Iterate through potential zone locations based on separators\n    for zr in range(num_zone_rows):\n        for zc in range(num_zone_cols):\n            # Define zone boundaries based on separator indices\n            r_start, r_end = h_sep_rows[zr] + 1, h_sep_rows[zr+1]\n            c_start, c_end = v_sep_cols[zc] + 1, v_sep_cols[zc+1]\n\n            # Skip if zone has zero height or width (e.g., adjacent separators)\n            if r_start >= r_end or c_start >= c_end:\n                 continue\n\n            # Create a boolean mask for the current zone's pixels\n            zone_mask = np.zeros_like(input_grid_np, dtype=bool)\n            zone_mask[r_start:r_end, c_start:c_end] = True\n\n            # Find source and target objects within this specific zone using the mask\n            zone_sources = find_objects(input_grid_np, source_colors, zone_mask)\n            zone_targets = find_objects(input_grid_np, target_color, zone_mask)\n\n            # Store zone information if it contains any sources or targets\n            if zone_sources or zone_targets:\n                # Add zone coordinates and type to each found object for later reference\n                for obj in zone_sources:\n                    obj['zone_rc'] = (zr, zc)\n                    obj['type'] = 'source'\n                for obj in zone_targets:\n                    obj['zone_rc'] = (zr, zc)\n                    obj['type'] = 'target'\n\n                zones[(zr, zc)] = {'sources': zone_sources, 'targets': zone_targets}\n\n    # --- 3. Establish Mappings (Apply Rules) ---\n    mappings = [] # List to store successful mappings: (source_obj, list_of_target_objs)\n\n    # Rule 1: Intra-Zone Mapping (Apply first)\n    for zone_rc, zone_data in zones.items():\n        sources = zone_data['sources']\n        targets = zone_data['targets']\n\n        # Check condition: Exactly one source and one or more targets in the zone\n        if len(sources) == 1 and len(targets) > 0:\n            source_obj = sources[0]\n            # Ensure source and targets haven't already been used in a previous mapping\n            if not source_obj['mapped'] and all(not t['mapped'] for t in targets):\n                 mappings.append((source_obj, targets))\n                 # Mark objects as mapped to prevent reuse\n                 source_obj['mapped'] = True\n                 for t in targets:\n                     t['mapped'] = True\n\n    # Rule 2: Inter-Zone Vertical Mapping\n    for zc in range(num_zone_cols): # Iterate through columns\n        for zr in range(num_zone_rows - 1): # Iterate through adjacent row pairs\n            zone_above_rc = (zr, zc)\n            zone_below_rc = (zr + 1, zc)\n\n            # Check if both adjacent zones exist in our zones dictionary\n            if zone_above_rc in zones and zone_below_rc in zones:\n                sources_above = zones[zone_above_rc]['sources']\n                targets_above = zones[zone_above_rc]['targets']\n                sources_below = zones[zone_below_rc]['sources']\n                targets_below = zones[zone_below_rc]['targets']\n\n                # Check A: 1 unmapped source above, >=1 unmapped target below\n                unmapped_sources_above = [s for s in sources_above if not s['mapped']]\n                unmapped_targets_below = [t for t in targets_below if not t['mapped']]\n                if len(unmapped_sources_above) == 1 and len(unmapped_targets_below) > 0:\n                    source_obj = unmapped_sources_above[0]\n                    mappings.append((source_obj, unmapped_targets_below))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_below:\n                        t['mapped'] = True\n\n                # Check B: 1 unmapped source below, >=1 unmapped target above\n                # We MUST re-evaluate unmapped counts here because Check A might have just marked some objects\n                unmapped_sources_below_now = [s for s in sources_below if not s['mapped']]\n                unmapped_targets_above_now = [t for t in targets_above if not t['mapped']]\n                if len(unmapped_sources_below_now) == 1 and len(unmapped_targets_above_now) > 0:\n                    source_obj = unmapped_sources_below_now[0]\n                    mappings.append((source_obj, unmapped_targets_above_now))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_above_now:\n                        t['mapped'] = True\n\n\n    # Rule 3: Inter-Zone Horizontal Mapping\n    for zr in range(num_zone_rows): # Iterate through rows\n        for zc in range(num_zone_cols - 1): # Iterate through adjacent column pairs\n            zone_left_rc = (zr, zc)\n            zone_right_rc = (zr, zc + 1)\n\n            # Check if both adjacent zones exist\n            if zone_left_rc in zones and zone_right_rc in zones:\n                sources_left = zones[zone_left_rc]['sources']\n                targets_left = zones[zone_left_rc]['targets']\n                sources_right = zones[zone_right_rc]['sources']\n                targets_right = zones[zone_right_rc]['targets']\n\n                # Check A: 1 unmapped source left, >=1 unmapped target right\n                unmapped_sources_left = [s for s in sources_left if not s['mapped']]\n                unmapped_targets_right = [t for t in targets_right if not t['mapped']]\n                if len(unmapped_sources_left) == 1 and len(unmapped_targets_right) > 0:\n                    source_obj = unmapped_sources_left[0]\n                    mappings.append((source_obj, unmapped_targets_right))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_right:\n                        t['mapped'] = True\n\n                # Check B: 1 unmapped source right, >=1 unmapped target left\n                # Re-evaluate unmapped counts after Check A might have changed status\n                unmapped_sources_right_now = [s for s in sources_right if not s['mapped']]\n                unmapped_targets_left_now = [t for t in targets_left if not t['mapped']]\n                if len(unmapped_sources_right_now) == 1 and len(unmapped_targets_left_now) > 0:\n                    source_obj = unmapped_sources_right_now[0]\n                    mappings.append((source_obj, unmapped_targets_left_now))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_left_now:\n                        t['mapped'] = True\n\n\n    # --- 4. Apply Transformations (Color Targets) ---\n    # Iterate through the established mappings\n    for source_obj, target_objs in mappings:\n        source_color = source_obj['color']\n        # Apply the source color to all pixels of all target objects in this mapping\n        for target_obj in target_objs:\n            for r, c in target_obj['pixels']:\n                 # Basic bounds check (should always be true given how pixels were found)\n                 if 0 <= r < height and 0 <= c < width:\n                    # Modify the output grid directly\n                    output_grid[r, c] = source_color\n\n    # --- 5. Output ---\n    # Return the modified grid (converted back to list of lists)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9357,
    "candidates_token_count": 3437,
    "total_token_count": 12794,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.496918,
  "retries": null
}