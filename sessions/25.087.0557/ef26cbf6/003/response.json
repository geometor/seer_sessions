{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1.  **Identify Grid Structure:**\n    *   Find all rows consisting entirely of yellow (4) pixels. These are horizontal separators.\n    *   Find all columns consisting entirely of yellow (4) pixels. These are vertical separators.\n    *   Use the grid boundaries and these separators to partition the grid into rectangular zones. Assign each zone coordinates (zone_row, zone_col).\n2.  **Identify Objects:**\n    *   Within each zone, identify all distinct contiguous objects.\n    *   Classify objects as 'source' if their color is not white (0), blue (1), or yellow (4).\n    *   Classify objects as 'target' if their color is blue (1).\n    *   Store each object's color, pixels, and the zone it belongs to.\n3.  **Determine Mappings:** Create a list of mappings, where each mapping connects one source object to one or more target objects. Apply the following rules in order, ensuring a source object is used only once:\n    *   **Rule 1 (Intra-Zone):** For each zone, if it contains exactly one source object and one or more target objects, map that source object to all target objects within that same zone. Mark the source and targets as 'mapped'.\n    *   **Rule 2 (Inter-Zone Vertical):** Check pairs of zones (Z_above, Z_below) that are in the same zone column and are directly separated by a single horizontal separator. If Z_above contains exactly one 'unmapped' source object, and Z_below contains one or more 'unmapped' target objects, map the source to all those targets. Mark the source and targets as 'mapped'. (Apply similarly if source is below and targets are above).\n    *   **Rule 3 (Inter-Zone Horizontal):** Check pairs of zones (Z_left, Z_right) that are in the same zone row and are directly separated by a single vertical separator. If Z_left contains exactly one 'unmapped' source object, and Z_right contains one or more 'unmapped' target objects, map the source to all those targets. Mark the source and targets as 'mapped'. (Apply similarly if source is right and targets are left).\n4.  **Apply Transformation:**\n    *   Create a copy of the input grid.\n    *   For every determined mapping (source S -> targets T_list): Change the color of all pixels belonging to each target T in T_list to the color of source S in the copied grid.\n    *   For every source object S that was marked as 'mapped': Change the color of all pixels belonging to S to white (0) in the copied grid.\n5.  **Output:** Return the modified grid.\n\"\"\"\n\ndef find_objects(grid, colors_to_find, zone_mask):\n    \"\"\"\n    Finds contiguous objects of specified colors within a masked zone of the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of color values to search for.\n        zone_mask (np.array): A boolean mask of the same shape as grid,\n                               True for pixels within the current zone.\n\n    Returns:\n        list: A list of dictionaries, each representing an object found.\n              Each dictionary contains 'color', 'pixels', 'bbox', and 'mapped'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Skip if outside the specified zone or already visited\n            if not zone_mask[r, c] or visited[r, c]:\n                continue\n\n            # Skip if not a target color for this search\n            if grid[r, c] not in colors_to_find:\n                continue\n\n            color = grid[r, c]\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check neighbors (4-connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       zone_mask[nr, nc] and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            objects.append({\n                'color': color,\n                'pixels': obj_pixels,\n                'bbox': (min_r, min_c, max_r, max_c),\n                'mapped': False # Initialize mapped flag\n            })\n\n    return objects\n\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    source_colors = {2, 3, 5, 6, 7, 8, 9} # All colors except white, blue, yellow\n    target_color = {1} # Blue\n\n    # --- 1. Identify Grid Structure (Separators and Zones) ---\n    h_sep_rows = [-1] + [r for r in range(height) if np.all(input_grid[r, :] == 4)] + [height]\n    v_sep_cols = [-1] + [c for c in range(width) if np.all(input_grid[:, c] == 4)] + [width]\n\n    num_zone_rows = len(h_sep_rows) - 1\n    num_zone_cols = len(v_sep_cols) - 1\n\n    zones = {} # Store zone info: bounds and objects\n\n    # --- 2. Identify Objects per Zone ---\n    all_objects = [] # Keep a flat list for easy access later\n    for zr in range(num_zone_rows):\n        for zc in range(num_zone_cols):\n            r_start, r_end = h_sep_rows[zr] + 1, h_sep_rows[zr+1]\n            c_start, c_end = v_sep_cols[zc] + 1, v_sep_cols[zc+1]\n\n            if r_start >= r_end or c_start >= c_end: # Skip empty zones\n                 continue\n\n            zone_mask = np.zeros_like(input_grid, dtype=bool)\n            zone_mask[r_start:r_end, c_start:c_end] = True\n\n            zone_sources = find_objects(input_grid, source_colors, zone_mask)\n            zone_targets = find_objects(input_grid, target_color, zone_mask)\n\n            for obj in zone_sources:\n                obj['zone_rc'] = (zr, zc)\n                obj['type'] = 'source'\n            for obj in zone_targets:\n                obj['zone_rc'] = (zr, zc)\n                obj['type'] = 'target'\n\n            zones[(zr, zc)] = {'sources': zone_sources, 'targets': zone_targets}\n            all_objects.extend(zone_sources)\n            all_objects.extend(zone_targets)\n\n\n    # --- 3. Determine Mappings ---\n    mappings = [] # List of tuples: (source_obj, list_of_target_objs)\n    \n    # Rule 1: Intra-Zone Mapping\n    for zr in range(num_zone_rows):\n        for zc in range(num_zone_cols):\n            zone_rc = (zr, zc)\n            if zone_rc in zones:\n                zone_data = zones[zone_rc]\n                sources = zone_data['sources']\n                targets = zone_data['targets']\n\n                # Check for exactly one source and one or more targets\n                if len(sources) == 1 and len(targets) > 0:\n                    source_obj = sources[0]\n                    # Ensure source and targets haven't been mapped yet\n                    if not source_obj['mapped'] and all(not t['mapped'] for t in targets):\n                         mappings.append((source_obj, targets))\n                         source_obj['mapped'] = True\n                         for t in targets:\n                             t['mapped'] = True\n\n    # Rule 2: Inter-Zone Vertical Mapping\n    for zc in range(num_zone_cols): # Iterate through zone columns\n        for zr in range(num_zone_rows - 1): # Iterate through adjacent zone rows\n            zone_above_rc = (zr, zc)\n            zone_below_rc = (zr + 1, zc)\n\n            if zone_above_rc in zones and zone_below_rc in zones:\n                sources_above = zones[zone_above_rc]['sources']\n                targets_above = zones[zone_above_rc]['targets']\n                sources_below = zones[zone_below_rc]['sources']\n                targets_below = zones[zone_below_rc]['targets']\n\n                # Check: 1 unmapped source above, >=1 unmapped target below\n                unmapped_sources_above = [s for s in sources_above if not s['mapped']]\n                unmapped_targets_below = [t for t in targets_below if not t['mapped']]\n                if len(unmapped_sources_above) == 1 and len(unmapped_targets_below) > 0:\n                    source_obj = unmapped_sources_above[0]\n                    mappings.append((source_obj, unmapped_targets_below))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_below:\n                        t['mapped'] = True\n\n                # Check: 1 unmapped source below, >=1 unmapped target above\n                unmapped_sources_below = [s for s in sources_below if not s['mapped']]\n                unmapped_targets_above = [t for t in targets_above if not t['mapped']]\n                # Need fresh check as objects might have been mapped in previous check\n                if len(unmapped_sources_below) == 1 and len(unmapped_targets_above) > 0:\n                    # Re-fetch unmapped targets above, in case they were just mapped\n                    unmapped_targets_above_fresh = [t for t in targets_above if not t['mapped']]\n                    if len(unmapped_targets_above_fresh) > 0:\n                        source_obj = unmapped_sources_below[0]\n                        mappings.append((source_obj, unmapped_targets_above_fresh))\n                        source_obj['mapped'] = True\n                        for t in unmapped_targets_above_fresh:\n                            t['mapped'] = True\n\n\n    # Rule 3: Inter-Zone Horizontal Mapping\n    for zr in range(num_zone_rows): # Iterate through zone rows\n        for zc in range(num_zone_cols - 1): # Iterate through adjacent zone columns\n            zone_left_rc = (zr, zc)\n            zone_right_rc = (zr, zc + 1)\n\n            if zone_left_rc in zones and zone_right_rc in zones:\n                sources_left = zones[zone_left_rc]['sources']\n                targets_left = zones[zone_left_rc]['targets']\n                sources_right = zones[zone_right_rc]['sources']\n                targets_right = zones[zone_right_rc]['targets']\n\n                # Check: 1 unmapped source left, >=1 unmapped target right\n                unmapped_sources_left = [s for s in sources_left if not s['mapped']]\n                unmapped_targets_right = [t for t in targets_right if not t['mapped']]\n                if len(unmapped_sources_left) == 1 and len(unmapped_targets_right) > 0:\n                    source_obj = unmapped_sources_left[0]\n                    mappings.append((source_obj, unmapped_targets_right))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_right:\n                        t['mapped'] = True\n\n                # Check: 1 unmapped source right, >=1 unmapped target left\n                unmapped_sources_right = [s for s in sources_right if not s['mapped']]\n                unmapped_targets_left = [t for t in targets_left if not t['mapped']]\n                 # Need fresh check as objects might have been mapped\n                if len(unmapped_sources_right) == 1 and len(unmapped_targets_left) > 0:\n                    # Re-fetch unmapped targets left\n                    unmapped_targets_left_fresh = [t for t in targets_left if not t['mapped']]\n                    if len(unmapped_targets_left_fresh) > 0:\n                        source_obj = unmapped_sources_right[0]\n                        mappings.append((source_obj, unmapped_targets_left_fresh))\n                        source_obj['mapped'] = True\n                        for t in unmapped_targets_left_fresh:\n                            t['mapped'] = True\n\n\n    # --- 4. Apply Transformation ---\n    source_pixels_to_clear = set()\n\n    # Apply color changes to targets first\n    for source_obj, target_objs in mappings:\n        source_color = source_obj['color']\n        source_pixels_to_clear.update(source_obj['pixels']) # Collect pixels of mapped sources\n        for target_obj in target_objs:\n            for r, c in target_obj['pixels']:\n                 if 0 <= r < height and 0 <= c < width: # Bounds check\n                    output_grid[r, c] = source_color\n\n    # Clear original source pixels AFTER coloring targets\n    for r, c in source_pixels_to_clear:\n         if 0 <= r < height and 0 <= c < width: # Bounds check\n            output_grid[r, c] = 0 # Set to white\n\n    # --- 5. Output ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9478,
    "candidates_token_count": 3354,
    "total_token_count": 12832,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.747368,
  "retries": null
}