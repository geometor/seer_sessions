{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies zones separated by yellow lines in a grid. Finds 'source' objects (non-white/blue/yellow) and 'target' objects (blue) within these zones. Maps sources to targets based on proximity rules (within the same zone, or in vertically/horizontally adjacent zones). Transfers the source object's color to its mapped target objects. Finally, removes the original source object by changing its pixels to white (0).\n\n1.  **Identify Grid Structure:**\n    *   Locate all rows composed entirely of yellow (4) pixels (horizontal separators).\n    *   Locate all columns composed entirely of yellow (4) pixels (vertical separators).\n    *   Use grid boundaries and separators to define rectangular zones with coordinates (zone_row, zone_col).\n2.  **Identify Objects:**\n    *   Within each zone, find contiguous 'source' objects (color not 0, 1, or 4) and 'target' objects (color 1).\n    *   Record each object's color, pixels, zone, and initialize a 'mapped' status to false.\n3.  **Determine Mappings:** Create mappings from sources to targets based on rules, marking objects as 'mapped' once used.\n    *   **Rule 1 (Intra-Zone):** Map a single source to all targets within the same zone.\n    *   **Rule 2 (Inter-Zone Vertical):** Map a single unmapped source in one zone to all unmapped targets in a vertically adjacent zone. Check both directions (up/down).\n    *   **Rule 3 (Inter-Zone Horizontal):** Map a single unmapped source in one zone to all unmapped targets in a horizontally adjacent zone. Check both directions (left/right).\n4.  **Apply Transformation:**\n    *   Create a copy of the input grid.\n    *   For each mapping, color the target pixels with the source color in the copied grid.\n    *   For every source object that was successfully mapped, change its original pixels to white (0) in the copied grid.\n5.  **Output:** Return the modified grid.\n\"\"\"\n\ndef find_objects(grid, colors_to_find, zone_mask):\n    \"\"\"\n    Finds contiguous objects of specified colors within a masked zone of the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set): A set of color values to search for.\n        zone_mask (np.array): A boolean mask of the same shape as grid,\n                               True for pixels within the current zone.\n\n    Returns:\n        list: A list of dictionaries, each representing an object found.\n              Each dictionary contains 'color', 'pixels', 'bbox', and 'mapped'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Skip if outside the specified zone or already visited\n            if not zone_mask[r, c] or visited[r, c]:\n                continue\n\n            # Skip if not a target color for this search\n            if grid[r, c] not in colors_to_find:\n                continue\n\n            color = grid[r, c]\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check neighbors (4-connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       zone_mask[nr, nc] and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            if obj_pixels: # Only add if pixels were found\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'mapped': False # Initialize mapped flag\n                })\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on zone mapping.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    source_colors = {2, 3, 5, 6, 7, 8, 9} # All colors except white(0), blue(1), yellow(4)\n    target_color = {1} # Blue\n    separator_color = 4 # Yellow\n    background_color = 0 # White\n\n    # --- 1. Identify Grid Structure (Separators and Zones) ---\n    h_sep_rows = [-1] + [r for r in range(height) if np.all(input_grid_np[r, :] == separator_color)] + [height]\n    v_sep_cols = [-1] + [c for c in range(width) if np.all(input_grid_np[:, c] == separator_color)] + [width]\n\n    num_zone_rows = len(h_sep_rows) - 1\n    num_zone_cols = len(v_sep_cols) - 1\n\n    zones = {} # Store zone info: bounds, sources, targets\n\n    # --- 2. Identify Objects per Zone ---\n    # Populate zones dictionary with sources and targets found in each zone\n    for zr in range(num_zone_rows):\n        for zc in range(num_zone_cols):\n            # Define zone boundaries\n            r_start, r_end = h_sep_rows[zr] + 1, h_sep_rows[zr+1]\n            c_start, c_end = v_sep_cols[zc] + 1, v_sep_cols[zc+1]\n\n            # Skip if zone is effectively empty (e.g., adjacent separators)\n            if r_start >= r_end or c_start >= c_end:\n                 continue\n\n            # Create a mask for the current zone\n            zone_mask = np.zeros_like(input_grid_np, dtype=bool)\n            zone_mask[r_start:r_end, c_start:c_end] = True\n\n            # Find source and target objects within this zone\n            zone_sources = find_objects(input_grid_np, source_colors, zone_mask)\n            zone_targets = find_objects(input_grid_np, target_color, zone_mask)\n\n            # Store zone information if it contains objects\n            if zone_sources or zone_targets:\n                for obj in zone_sources:\n                    obj['zone_rc'] = (zr, zc)\n                    obj['type'] = 'source'\n                for obj in zone_targets:\n                    obj['zone_rc'] = (zr, zc)\n                    obj['type'] = 'target'\n\n                zones[(zr, zc)] = {'sources': zone_sources, 'targets': zone_targets}\n\n    # --- 3. Determine Mappings ---\n    mappings = [] # List of tuples: (source_obj, list_of_target_objs)\n\n    # Rule 1: Intra-Zone Mapping\n    for zone_rc, zone_data in zones.items():\n        sources = zone_data['sources']\n        targets = zone_data['targets']\n\n        # Condition: Exactly one source and one or more targets in the zone\n        if len(sources) == 1 and len(targets) > 0:\n            source_obj = sources[0]\n            # Check if source and targets are not already mapped\n            if not source_obj['mapped'] and all(not t['mapped'] for t in targets):\n                 mappings.append((source_obj, targets))\n                 source_obj['mapped'] = True\n                 for t in targets:\n                     t['mapped'] = True\n\n    # Rule 2: Inter-Zone Vertical Mapping\n    for zc in range(num_zone_cols): # Iterate through columns\n        for zr in range(num_zone_rows - 1): # Iterate through adjacent row pairs\n            zone_above_rc = (zr, zc)\n            zone_below_rc = (zr + 1, zc)\n\n            # Check if both adjacent zones exist in our zones dictionary\n            if zone_above_rc in zones and zone_below_rc in zones:\n                sources_above = zones[zone_above_rc]['sources']\n                targets_above = zones[zone_above_rc]['targets']\n                sources_below = zones[zone_below_rc]['sources']\n                targets_below = zones[zone_below_rc]['targets']\n\n                # Check: 1 unmapped source above, >=1 unmapped target below\n                unmapped_sources_above = [s for s in sources_above if not s['mapped']]\n                unmapped_targets_below = [t for t in targets_below if not t['mapped']]\n                if len(unmapped_sources_above) == 1 and len(unmapped_targets_below) > 0:\n                    source_obj = unmapped_sources_above[0]\n                    mappings.append((source_obj, unmapped_targets_below))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_below:\n                        t['mapped'] = True\n\n                # Check: 1 unmapped source below, >=1 unmapped target above\n                # We need to re-evaluate unmapped counts as the previous check might have changed 'mapped' status\n                unmapped_sources_below_now = [s for s in sources_below if not s['mapped']]\n                unmapped_targets_above_now = [t for t in targets_above if not t['mapped']]\n                if len(unmapped_sources_below_now) == 1 and len(unmapped_targets_above_now) > 0:\n                    source_obj = unmapped_sources_below_now[0]\n                    mappings.append((source_obj, unmapped_targets_above_now))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_above_now:\n                        t['mapped'] = True\n\n\n    # Rule 3: Inter-Zone Horizontal Mapping\n    for zr in range(num_zone_rows): # Iterate through rows\n        for zc in range(num_zone_cols - 1): # Iterate through adjacent column pairs\n            zone_left_rc = (zr, zc)\n            zone_right_rc = (zr, zc + 1)\n\n            # Check if both adjacent zones exist\n            if zone_left_rc in zones and zone_right_rc in zones:\n                sources_left = zones[zone_left_rc]['sources']\n                targets_left = zones[zone_left_rc]['targets']\n                sources_right = zones[zone_right_rc]['sources']\n                targets_right = zones[zone_right_rc]['targets']\n\n                # Check: 1 unmapped source left, >=1 unmapped target right\n                unmapped_sources_left = [s for s in sources_left if not s['mapped']]\n                unmapped_targets_right = [t for t in targets_right if not t['mapped']]\n                if len(unmapped_sources_left) == 1 and len(unmapped_targets_right) > 0:\n                    source_obj = unmapped_sources_left[0]\n                    mappings.append((source_obj, unmapped_targets_right))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_right:\n                        t['mapped'] = True\n\n                # Check: 1 unmapped source right, >=1 unmapped target left\n                # Re-evaluate unmapped counts\n                unmapped_sources_right_now = [s for s in sources_right if not s['mapped']]\n                unmapped_targets_left_now = [t for t in targets_left if not t['mapped']]\n                if len(unmapped_sources_right_now) == 1 and len(unmapped_targets_left_now) > 0:\n                    source_obj = unmapped_sources_right_now[0]\n                    mappings.append((source_obj, unmapped_targets_left_now))\n                    source_obj['mapped'] = True\n                    for t in unmapped_targets_left_now:\n                        t['mapped'] = True\n\n\n    # --- 4. Apply Transformation ---\n    source_pixels_to_clear = set()\n\n    # Apply color changes to targets first\n    for source_obj, target_objs in mappings:\n        source_color = source_obj['color']\n        # Collect pixels of this mapped source to be cleared later\n        source_pixels_to_clear.update(source_obj['pixels'])\n        # Apply source color to all target objects in this mapping\n        for target_obj in target_objs:\n            for r, c in target_obj['pixels']:\n                 # Basic bounds check (though pixels should be within grid)\n                 if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = source_color\n\n    # Clear original source pixels AFTER coloring targets\n    # Iterate through the collected set of all source pixels that were part of any mapping\n    for r, c in source_pixels_to_clear:\n         # Basic bounds check\n         if 0 <= r < height and 0 <= c < width:\n            output_grid[r, c] = background_color # Set to white\n\n    # --- 5. Output ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9389,
    "candidates_token_count": 3276,
    "total_token_count": 12665,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.88969,
  "retries": null
}