{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct connected objects composed of gray (5) pixels in the input grid.\nIf there are fewer than two gray objects, return the input grid unchanged.\nOtherwise, determine the leftmost gray object (the one containing the pixel with the minimum column index) and the rightmost gray object (the one containing the pixel with the maximum column index).\nFind all white (0) pixels that are adjacent (including diagonals) to any pixel of the leftmost gray object. Change these white pixels to orange (7) in the output grid.\nFind all white (0) pixels that are adjacent (including diagonals) to any pixel of the rightmost gray object. Change these white pixels to azure (8) in the output grid.\nIf a white pixel is adjacent to both the leftmost and rightmost objects, it should be changed to azure (8) (azure takes precedence).\nAll other pixels retain their original color.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid.\n\n    Args:\n        grid: The input grid (list of lists).\n        color: The color of the objects to find.\n\n    Returns:\n        A list of objects, where each object is a list of (row, col) tuples.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == color and (r, c) not in visited:\n                obj = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n                while q:\n                    row, col = q.popleft()\n                    obj.append((row, col))\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr][nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                if obj:\n                    objects.append(obj)\n    return objects\n\ndef get_object_bounds(obj):\n    \"\"\"\n    Calculates the minimum and maximum column index for an object.\n\n    Args:\n        obj: A list of (row, col) tuples representing an object.\n\n    Returns:\n        A tuple (min_col, max_col). Returns (float('inf'), float('-inf')) if obj is empty.\n    \"\"\"\n    if not obj:\n        return float('inf'), float('-inf')\n    min_c = min(c for r, c in obj)\n    max_c = max(c for r, c in obj)\n    return min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described rules.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the output grid.\n    \"\"\"\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # Find all gray objects\n    gray_objects = find_objects(input_grid, 5)\n\n    # If less than two objects, return the original grid\n    if len(gray_objects) < 2:\n        return output_grid\n\n    # Find the leftmost and rightmost objects\n    min_col_overall = float('inf')\n    max_col_overall = float('-inf')\n    leftmost_object = None\n    rightmost_object = None\n\n    object_bounds = []\n    for obj in gray_objects:\n        min_c, max_c = get_object_bounds(obj)\n        object_bounds.append({'object': obj, 'min_c': min_c, 'max_c': max_c})\n        if min_c < min_col_overall:\n            min_col_overall = min_c\n            leftmost_object = obj\n        if max_c > max_col_overall:\n            max_col_overall = max_c\n            # Need to find the object whose max_c is max_col_overall\n            # It might not be the same one that set the current max_col_overall if multiple objects share the max column\n\n    # Re-iterate to definitively find the rightmost object based on max_col_overall\n    for bounds in object_bounds:\n        if bounds['max_c'] == max_col_overall:\n            rightmost_object = bounds['object']\n            break # Assuming only one truly rightmost object matters if columns tie\n\n    # Find neighbors to color orange (leftmost)\n    orange_neighbors = set()\n    if leftmost_object:\n        for r_obj, c_obj in leftmost_object:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r_obj + dr, c_obj + dc\n                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:\n                        orange_neighbors.add((nr, nc))\n\n    # Find neighbors to color azure (rightmost)\n    azure_neighbors = set()\n    if rightmost_object:\n        for r_obj, c_obj in rightmost_object:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r_obj + dr, c_obj + dc\n                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:\n                        azure_neighbors.add((nr, nc))\n\n    # Apply color changes (orange first, then azure to handle precedence)\n    for r, c in orange_neighbors:\n        output_grid[r][c] = 7\n        \n    for r, c in azure_neighbors:\n        output_grid[r][c] = 8\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2246,
    "candidates_token_count": 1493,
    "total_token_count": 3739,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.12937,
  "retries": null
}