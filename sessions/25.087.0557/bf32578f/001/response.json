{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Identify the single connected group of non-background pixels (color C, ObjectPixels).\n2. Perform a flood fill starting from all border background pixels (0), marking reachable background pixels. Use 4-connectivity.\n3. Identify enclosed background pixels (EnclosedPixels) as those background pixels not reached by the flood fill.\n4. Initialize the output grid by copying the input grid.\n5. Fill the EnclosedPixels in the output grid with color C.\n6. Determine if the object forms a closed loop around the enclosed area by checking if every pixel in ObjectPixels is adjacent (4-connectivity) to at least one pixel in EnclosedPixels.\n7. If it forms a closed loop, set the ObjectPixels in the output grid to the background color (0). Otherwise, leave them as color C.\n\"\"\"\n\ndef find_object_pixels(grid):\n    \"\"\"Finds the coordinates and color of the single non-background object.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    object_pixels = set()\n    object_color = -1\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                object_color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels = set()\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == object_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                # Assuming only one object per grid based on examples\n                return current_object_pixels, object_color\n    \n    # Should not happen based on task description, but handle just in case\n    return set(), 0 \n\ndef find_enclosed_pixels(grid, object_pixels):\n    \"\"\"Finds background pixels enclosed by the object using a border flood fill.\"\"\"\n    rows, cols = grid.shape\n    background_color = 0\n    visited_background = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Start flood fill from all border background pixels\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == background_color and not visited_background[r, c] and (r, c) not in object_pixels:\n                visited_background[r, c] = True\n                q.append((r, c))\n    for c in range(cols):\n        for r in [0, rows - 1]:\n            # Avoid adding corners twice and check conditions again\n             if grid[r, c] == background_color and not visited_background[r, c] and (r, c) not in object_pixels:\n                visited_background[r, c] = True\n                q.append((r, c))\n\n    # Perform BFS flood fill on background pixels, avoiding object pixels\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and \\\n               not visited_background[nr, nc] and \\\n               (nr, nc) not in object_pixels:\n                visited_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify enclosed pixels (background pixels not visited)\n    enclosed_pixels = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == background_color and not visited_background[r, c] and (r,c) not in object_pixels:\n                 enclosed_pixels.add((r, c))\n                 \n    return enclosed_pixels\n\ndef is_closed_loop(object_pixels, enclosed_pixels, grid_shape):\n    \"\"\"Checks if every object pixel is adjacent to an enclosed pixel.\"\"\"\n    rows, cols = grid_shape\n    if not enclosed_pixels: # If nothing is enclosed, it can't be a closed loop around it\n        return False\n        \n    for r_obj, c_obj in object_pixels:\n        is_adjacent_to_enclosed = False\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_obj + dr, c_obj + dc\n            # Check bounds although neighbors of object pixels might be outside grid if object is at border\n            # We only care if a neighbor IS an enclosed pixel, which must be within bounds.\n            if (nr, nc) in enclosed_pixels:\n                is_adjacent_to_enclosed = True\n                break # Found an adjacent enclosed pixel, move to the next object pixel\n        \n        if not is_adjacent_to_enclosed:\n            return False # This object pixel has no adjacent enclosed pixel, so not a closed loop\n\n    return True # All object pixels had at least one adjacent enclosed pixel\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling the area enclosed by a non-background \n    object with the object's color. If the object forms a closed loop around \n    the enclosed area, the original object pixels are set to background color (0); \n    otherwise, they retain their original color.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    background_color = 0\n\n    # 1. Identify the non-background object pixels and color\n    object_pixels, object_color = find_object_pixels(grid_np)\n    if not object_pixels:\n        # Handle case where no object is found (e.g., all background)\n        return grid_np.tolist() # Return input as is\n\n    # 2. & 3. Find enclosed background pixels\n    enclosed_pixels = find_enclosed_pixels(grid_np, object_pixels)\n\n    # 4. Initialize output grid as a copy of the input\n    output_grid = np.copy(grid_np)\n\n    # 5. Fill enclosed pixels with the object color\n    for r, c in enclosed_pixels:\n        output_grid[r, c] = object_color\n\n    # 6. Check if the object forms a closed loop around the enclosed area\n    forms_closed_loop = is_closed_loop(object_pixels, enclosed_pixels, (rows, cols))\n\n    # 7. If it's a closed loop, set original object pixels to background color\n    if forms_closed_loop:\n        for r, c in object_pixels:\n            output_grid[r, c] = background_color\n    \n    # else: (Step 9 implicitly handled) Object pixels remain as they were after step 4 (object_color)\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3542,
    "candidates_token_count": 1777,
    "total_token_count": 5319,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.023637,
  "retries": null
}