{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation identifies three horizontal line segments in the input grid: \n1. A red line (color 2).\n2. A non-red, non-white 'top line' located above the red line.\n3. A non-red, non-white 'bottom line' located below the red line.\n\nIt then determines the horizontal intersection (common columns) between the top and bottom lines. \n\nFinally, it fills a rectangular area with yellow (color 4). The columns of this rectangle are defined by the intersection found earlier. The rows depend on the relative widths of the top and bottom lines:\n- If the bottom line is strictly narrower than the top line, the yellow rectangle fills the rows strictly between the top line and the red line.\n- Otherwise (if the top line is narrower than or equal in width to the bottom line), the yellow rectangle fills the rows strictly between the red line and the bottom line.\n\nThe original lines and background are preserved in the output.\n\"\"\"\n\ndef find_colored_line_details(grid, color, search_rows=None):\n    \"\"\"Finds the first horizontal line of a specific color within given rows.\"\"\"\n    num_rows, num_cols = grid.shape\n    rows_to_scan = search_rows if search_rows is not None else range(num_rows)\n\n    for r in rows_to_scan:\n        cols = {c for c in range(num_cols) if grid[r, c] == color}\n        if cols:\n            # Check if it's a single contiguous line (optional, assumed by problem structure)\n            # Assuming only one line of this color exists in the search range based on examples\n            return r, cols, len(cols)\n    return None, None, 0 # Not found\n\ndef find_non_bw_line_details(grid, search_rows, reverse_search=False):\n    \"\"\"\n    Finds the first horizontal line containing non-black/white/red pixels\n    within given rows. Searches top-down unless reverse_search is True.\n    \"\"\"\n    num_rows, num_cols = grid.shape\n    rows_to_scan = search_rows\n    if reverse_search:\n        rows_to_scan = reversed(search_rows)\n\n    for r in rows_to_scan:\n        # Find columns with colors other than 0 (white) and 2 (red)\n        cols = {c for c in range(num_cols) if grid[r, c] not in [0, 2]}\n        if cols:\n            # Check if all non-zero cells in this row have the same color (ensures it's one line)\n            line_colors = {grid[r, c] for c in cols}\n            if len(line_colors) == 1:\n                 return r, cols, len(cols)\n            else:\n                 # Handle cases where a row might have multiple colors if necessary\n                 # For this task, examples suggest a single color per line (other than red/white)\n                 # Taking the first one found for simplicity based on examples\n                 return r, cols, len(cols)\n\n    return None, None, 0 # Not found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    grid = np.array(input_grid, dtype=int)\n    num_rows, num_cols = grid.shape\n\n    # Initialize output grid as a copy of the input\n    output_grid = copy.deepcopy(grid)\n\n    # 1. Find the red line\n    red_row, red_cols, _ = find_colored_line_details(grid, 2)\n    if red_row is None:\n        print(\"Error: Red line not found.\")\n        return input_grid # Return original if structure is unexpected\n\n    # 2. Find the top line (non-red, non-white above red line)\n    # Search rows from 0 up to (but not including) red_row\n    top_row, top_cols, top_width = find_non_bw_line_details(grid, range(0, red_row), reverse_search=False)\n    if top_row is None:\n        print(\"Error: Top line not found.\")\n        return input_grid # Return original if structure is unexpected\n\n    # 3. Find the bottom line (non-red, non-white below red line)\n    # Search rows from red_row + 1 down to the last row\n    bottom_row, bottom_cols, bottom_width = find_non_bw_line_details(grid, range(red_row + 1, num_rows), reverse_search=False) # Task seems to take the *highest* below red, not lowest\n    # Let's adjust based on examples: search top-down below red line instead of bottom-up\n    # bottom_row, bottom_cols, bottom_width = find_non_bw_line_details(grid, range(red_row + 1, num_rows), reverse_search=False)\n    # Re-evaluating perception: The examples DO seem consistent with finding the *first* non-bw line below red when scanning top-down.\n\n    if bottom_row is None:\n       # Let's try searching bottom-up if top-down fails, based on train_3 and train_4 structures\n       bottom_row, bottom_cols, bottom_width = find_non_bw_line_details(grid, range(red_row + 1, num_rows), reverse_search=True)\n       if bottom_row is None:\n            print(\"Error: Bottom line not found.\")\n            return input_grid # Return original if structure is unexpected\n\n\n    # 4. Calculate the intersection of columns\n    intersection_cols = top_cols.intersection(bottom_cols)\n    if not intersection_cols:\n        # No overlap, no yellow rectangle to draw\n        return output_grid.tolist() # Return the copy which is same as input\n\n    # 5. Determine the target rows for the yellow fill\n    target_rows = []\n    if bottom_width < top_width:\n        # Fill rows between top line and red line (exclusive)\n        target_rows = range(top_row + 1, red_row)\n    else: # bottom_width >= top_width\n        # Fill rows between red line and bottom line (exclusive)\n        target_rows = range(red_row + 1, bottom_row)\n\n    # 6. Fill the yellow rectangle in the output grid\n    yellow_color = 4\n    for r in target_rows:\n        for c in intersection_cols:\n            output_grid[r, c] = yellow_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3531,
    "candidates_token_count": 1554,
    "total_token_count": 5085,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.463667,
  "retries": null
}