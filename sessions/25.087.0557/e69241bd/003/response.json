{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\nThis transformation performs a fill operation on a grid based on proximity to 'source' pixels, respecting 'barrier' pixels.\n\n1.  **Pixel Roles**:\n    *   Source Pixels: Colors 1 (blue), 3 (green), 4 (yellow), 6 (magenta), 7 (orange), 8 (azure). These are the colors that spread.\n    *   Barrier Pixels: Color 5 (gray). These block the spread of color.\n    *   Background Pixels: Color 0 (white). These are the pixels to be potentially filled.\n\n2.  **Filling Logic**:\n    *   Each background pixel determines its color based on the nearest source pixel(s).\n    *   Distance is measured using Chebyshev distance (max(|dx|, |dy|)), equivalent to the minimum number of steps on the grid including diagonals.\n    *   The path for distance calculation cannot pass through barrier pixels.\n\n3.  **Tie-breaking**:\n    *   If a background pixel is equidistant from multiple source pixels, it takes the color of the source pixel with the *lowest numerical color value*.\n\n4.  **Unreachable Pixels**:\n    *   If a background pixel cannot reach any source pixel due to being surrounded by barriers or if there are no source pixels, it remains a background pixel (color 0).\n\n5.  **Preservation**:\n    *   Original source pixels and barrier pixels retain their color in the output grid.\n\nThe process involves, for each background pixel, performing a search (like Breadth-First Search) outwards to find the nearest source(s), considering barriers as obstacles, and applying the tie-breaking rule if necessary.\n\"\"\"\n\ndef find_nearest_source_color_bfs(start_r, start_c, input_grid, source_locations, barrier_locations):\n    \"\"\"\n    Performs a Breadth-First Search from a background cell to find the nearest source(s).\n\n    Args:\n        start_r (int): Starting row of the background cell.\n        start_c (int): Starting column of the background cell.\n        input_grid (np.ndarray): The input grid.\n        source_locations (set): A set of (r, c) tuples for source pixel locations.\n        barrier_locations (set): A set of (r, c) tuples for barrier pixel locations.\n\n    Returns:\n        int: The color of the nearest source according to the rules (lowest color for ties),\n             or 0 if no source is reachable.\n    \"\"\"\n    height, width = input_grid.shape\n    queue = deque([(start_r, start_c, 0)]) # (r, c, distance)\n    visited = { (start_r, start_c) }\n    min_dist = float('inf')\n    # Stores colors of sources found at the current minimum distance\n    closest_sources_at_min_dist = []\n\n    while queue:\n        r, c, dist = queue.popleft()\n\n        # Optimization: If we have found sources and the current distance exceeds min_dist,\n        # we don't need to explore further from this point along this path.\n        if dist >= min_dist and min_dist != float('inf'):\n             continue\n\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n\n                nr, nc = r + dr, c + dc\n                neighbor_dist = dist + 1 # Chebyshev distance increments by 1 per step\n\n                # Check grid boundaries\n                if not (0 <= nr < height and 0 <= nc < width):\n                    continue\n\n                # Skip if barrier\n                if (nr, nc) in barrier_locations:\n                    continue # Cannot path through barriers\n\n                # Check if neighbor is a source\n                if (nr, nc) in source_locations:\n                    source_color = input_grid[nr, nc]\n                    # Found a source at this neighbor_dist\n                    if neighbor_dist < min_dist:\n                        # Found a closer source, reset list and update min_dist\n                        min_dist = neighbor_dist\n                        closest_sources_at_min_dist = [source_color]\n                    elif neighbor_dist == min_dist:\n                        # Found another source at the same minimum distance\n                        closest_sources_at_min_dist.append(source_color)\n                    # Do not add source location to queue, but mark visited to prevent re-processing\n                    # if reached via another path in later BFS stages (though pruning should handle this)\n                    visited.add((nr, nc))\n                    # Continue checking other neighbors at the current level `dist`\n\n                # If neighbor is not a source, not a barrier, and not visited, enqueue it for exploration\n                elif (nr, nc) not in visited:\n                     # Only add to queue if it's possible to find a source at <= min_dist from here.\n                     # Since we check sources *before* adding neighbors to the queue,\n                     # any path added is potentially optimal or part of finding all equidistant sources.\n                     if neighbor_dist <= min_dist : # Explore if distance is promising\n                        visited.add((nr, nc))\n                        queue.append((nr, nc, neighbor_dist))\n\n\n    # After BFS completes for the starting cell\n    if not closest_sources_at_min_dist:\n        return 0 # No reachable source, remains background color\n\n    # Apply tie-breaking: return the minimum color among the closest sources\n    return min(closest_sources_at_min_dist)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling background pixels (0) with the color\n    of the nearest source pixel (1, 3, 4, 6, 7, 8), respecting barriers (5).\n    Uses Chebyshev distance and breaks ties by choosing the lowest source color value.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define pixel roles by color\n    source_colors = {1, 3, 4, 6, 7, 8}\n    barrier_color = 5\n    background_color = 0\n\n    # Find locations of source, barrier, and background pixels\n    source_locations = set()\n    barrier_locations = set()\n    background_locations = []\n\n    for r in range(height):\n        for c in range(width):\n            color = input_grid[r, c]\n            if color in source_colors:\n                source_locations.add((r, c))\n            elif color == barrier_color:\n                barrier_locations.add((r, c))\n            elif color == background_color:\n                background_locations.append((r, c))\n\n    # If there are no source pixels, no filling can occur.\n    if not source_locations:\n        return output_grid # Return the original grid\n\n    # Iterate through each background pixel identified\n    for r, c in background_locations:\n        # Perform BFS starting from this background pixel to find the nearest source color\n        nearest_color = find_nearest_source_color_bfs(r, c, input_grid, source_locations, barrier_locations)\n        # Update the output grid with the determined color\n        output_grid[r, c] = nearest_color\n\n    # Return the fully transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5498,
    "candidates_token_count": 1745,
    "total_token_count": 7243,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 114.178478,
  "retries": null
}