{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFind all connected components of non-white pixels in the input grid using 4-connectivity. \nFor each component, determine its minimal bounding box. \nExtract the subgrid defined by each bounding box from the input grid.\nFilter these subgrids to keep only those that are \"dense\" (contain no white/zero pixels).\nAmong the dense subgrids found, identify the one with the *minimum area* (height * width).\nIf there is a unique smallest dense subgrid (or if multiple exist with the same minimum area, pick one, e.g., the first encountered), that subgrid is the output.\nIf no dense subgrids are found, return an empty list.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"\n    Finds all connected components of non-zero pixels in the grid using 4-connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is non-zero and hasn't been visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS to find all connected pixels in this component\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col))\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is non-zero and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found component to the list\n                components.append(component)\n                \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box (min_row, max_row, min_col, max_col) for a component.\n\n    Args:\n        component (list): A list of (row, col) tuples representing the component.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n    # Extract all row and column indices\n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    # Find the min and max row and column indices\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    # Convert input list of lists to a numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # Handle empty grid case\n    if grid.size == 0:\n        return [] # Return empty list for empty input\n\n    # 1. Identify all connected components (blocks) of non-white pixels\n    components = find_connected_components(grid)\n    \n    if not components:\n        return [] # No non-white pixels found, return empty list\n\n    # Store potential candidate dense subgrids and their areas\n    dense_subgrids_with_area = []\n\n    # 2. Iterate through components: get bbox, extract subgrid, check density\n    for component in components:\n        if not component:\n            continue\n\n        # 2a. Determine the bounding box\n        bbox = get_bounding_box(component)\n        min_row, max_row, min_col, max_col = bbox\n\n        # 2b. Extract the subgrid corresponding to the bounding box\n        # Numpy slicing is exclusive of the end index, so add 1 to max indices\n        subgrid = grid[min_row : max_row + 1, min_col : max_col + 1]\n\n        # 2c. Check if the subgrid is dense (contains no white pixels)\n        if np.all(subgrid != 0):\n            # 3. If dense, calculate its area and store it\n            area = subgrid.shape[0] * subgrid.shape[1]\n            dense_subgrids_with_area.append((area, subgrid))\n\n    # 4. Find the minimum area among the dense subgrids\n    if not dense_subgrids_with_area:\n        return [] # No dense subgrids found\n\n    min_area = min(area for area, subgrid in dense_subgrids_with_area)\n\n    # 5 & 6. Select the subgrid with the minimum area. \n    # If multiple exist, this arbitrarily picks the first one encountered during iteration.\n    smallest_dense_subgrid = None\n    for area, subgrid in dense_subgrids_with_area:\n        if area == min_area:\n            smallest_dense_subgrid = subgrid\n            break # Found one with the minimum area\n            \n    # 7. Convert the numpy subgrid back to a list of lists and return\n    if smallest_dense_subgrid is not None:\n        return smallest_dense_subgrid.tolist()\n    else:\n        # Should not be reached if dense_subgrids_with_area is not empty,\n        # but included for robustness.\n        return [] \n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17396,
    "candidates_token_count": 1371,
    "total_token_count": 18767,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 12.633624
}