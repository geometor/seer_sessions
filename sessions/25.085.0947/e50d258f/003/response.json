{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all contiguous blocks (components) of non-white (non-zero) pixels using 4-connectivity (horizontal/vertical adjacency). \nFor each component, determine its minimal bounding box. \nExtract the subgrid defined by each bounding box.\nFilter these subgrids to keep only those that are \"fully dense\" (contain no white pixels).\nAmong the fully dense subgrids found, identify the one with the *minimum area* (height * width).\nIf there is a unique smallest dense subgrid, that subgrid is the output.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"\n    Finds all connected components of non-zero pixels in the grid.\n    Uses 4-connectivity (horizontal/vertical).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is non-zero and hasn't been visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS to find all connected pixels in this component\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col))\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is non-zero and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found component to the list\n                components.append(component)\n                \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box (min_row, max_row, min_col, max_col) for a component.\n\n    Args:\n        component (list): A list of (row, col) tuples representing the component.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n    # Extract all row and column indices\n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    # Find the min and max row and column indices\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding and extracting the unique, smallest, dense subgrid\n    derived from the bounding box of a connected component of non-white pixels.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # Handle empty grid case\n    if grid.size == 0:\n        return []\n\n    # 1. Identify all connected components (blocks) of non-white pixels\n    components = find_connected_components(grid)\n    \n    if not components:\n        return [] # No non-white pixels found\n\n    # Store potential candidate dense subgrids and their areas\n    dense_subgrids = []\n\n    # 2-4. Iterate through components, get bounding box, extract subgrid, check density\n    for component in components:\n        if not component:\n            continue\n\n        # 2. Determine the bounding box for the current component\n        bbox = get_bounding_box(component)\n        min_row, max_row, min_col, max_col = bbox\n\n        # 3. Extract the subgrid corresponding to the bounding box\n        # Numpy slicing is exclusive of the end index, so add 1 to max indices\n        subgrid = grid[min_row : max_row + 1, min_col : max_col + 1]\n\n        # 4. Check if all pixels within this bounding box subgrid are non-zero (density is 1.0)\n        if np.all(subgrid != 0):\n            # If dense, calculate its area and store it with the subgrid\n            area = subgrid.shape[0] * subgrid.shape[1]\n            dense_subgrids.append((area, subgrid))\n\n    # 5. Find the minimum area among the dense subgrids\n    if not dense_subgrids:\n        return [] # No dense subgrids found\n\n    min_area = min(area for area, subgrid in dense_subgrids)\n\n    # 6. Select the subgrid with the minimum area\n    # Assuming uniqueness based on examples, we take the first one found with min_area\n    # If multiple smallest exist, this arbitrarily picks one.\n    smallest_dense_subgrid = None\n    for area, subgrid in dense_subgrids:\n        if area == min_area:\n            smallest_dense_subgrid = subgrid\n            break \n            \n    # 7. Convert the numpy subgrid back to a list of lists and return\n    if smallest_dense_subgrid is not None:\n        return smallest_dense_subgrid.tolist()\n    else:\n        # Should theoretically not be reached if dense_subgrids is not empty,\n        # but included for robustness.\n        return [] \n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5219,
    "candidates_token_count": 1373,
    "total_token_count": 6592,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 12.289798
}