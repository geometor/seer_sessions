{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef _find_pattern_row(grid_np):\n    \"\"\"\n    Finds the lowest row containing a contiguous segment of one non-background color (C_central)\n    flanked (not necessarily adjacently) by pixels of another non-background color (F_frame)\n    within the same row.\n\n    Returns:\n        tuple: (R_source, C_central, F_frame, central_segment_columns, framing_pixel_columns)\n               or None if no such row is found.\n    \"\"\"\n    height, width = grid_np.shape\n    for r in range(height - 1, -1, -1): # Iterate rows bottom-up\n        row = grid_np[r]\n        colors_data = defaultdict(list)\n        non_background_pixels = False\n        for c in range(width):\n            color = row[c]\n            if color != 0:\n                colors_data[color].append(c)\n                non_background_pixels = True\n\n        if not non_background_pixels or len(colors_data) < 2:\n            continue # Skip rows with no non-background pixels or only one non-background color\n\n        # Check each color as a potential C_central\n        for C_central, central_cols_list in colors_data.items():\n            central_cols = sorted(central_cols_list)\n            min_c = central_cols[0]\n            max_c = central_cols[-1]\n\n            # Check if the central segment is contiguous\n            is_contiguous = all(central_cols[i] == central_cols[0] + i for i in range(len(central_cols)))\n            if not is_contiguous:\n                continue # This color block isn't contiguous, cannot be the central one\n\n            # Check if it's flanked by any single other non-background color\n            found_flanker = False\n            F_frame = -1\n            framing_cols = []\n            for other_color, other_cols_list in colors_data.items():\n                if other_color == C_central:\n                    continue\n                \n                other_cols = sorted(other_cols_list)\n                has_left_flank = any(oc < min_c for oc in other_cols)\n                has_right_flank = any(oc > max_c for oc in other_cols)\n\n                if has_left_flank and has_right_flank:\n                    # Found a valid flanking color F_frame\n                    found_flanker = True\n                    F_frame = other_color\n                    framing_cols = other_cols # Use all pixels of this flanking color in the row\n                    break # Stop checking other colors once a valid flanker is found\n\n            if found_flanker:\n                # Found the pattern row and its components\n                return r, C_central, F_frame, central_cols, framing_cols\n\n    return None # No pattern row found\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies a specific horizontal pattern in the lowest possible row: a contiguous segment\n    of a central color (C) flanked by pixels of a framing color (F) (F...F C...C F...F).\n    For each framing pixel F in that row at column c_frame, calculates the minimum horizontal\n    distance (dist) to the central segment C. Adds a new pixel of color C at row\n    (source_row - dist - 1) and column c_frame.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Find the source pattern row and its characteristics\n    pattern_info = _find_pattern_row(input_grid_np)\n\n    if pattern_info is None:\n        # If no pattern row is found, return the original grid\n        return output_grid_np.tolist()\n\n    R_source, C_central, F_frame, central_segment_columns, framing_pixel_columns = pattern_info\n\n    # 2. Calculate and place the added pixels\n    for c_frame in framing_pixel_columns:\n        # Calculate the minimum horizontal distance to the central segment\n        min_dist = float('inf')\n        for c_central in central_segment_columns:\n            dist = abs(c_frame - c_central)\n            if dist < min_dist:\n                min_dist = dist\n\n        # Calculate the target row index\n        # The distance used seems to be the gap size, not direct distance?\n        # Let's re-check examples.\n        # Ex 1: F(0), C(1,2,3), F(4). R_source=4. C_central=1.\n        # F(0): Closest C is at 1. dist=1. R_output = 4 - 1 - 1 = 2. Correct.\n        # F(4): Closest C is at 3. dist=1. R_output = 4 - 1 - 1 = 2. Correct.\n        # Ex 2: F(0,1), C(2), F(3,4). R_source=4. C_central=3.\n        # F(0): Closest C is at 2. dist=2. R_output = 4 - 2 - 1 = 1. Correct.\n        # F(1): Closest C is at 2. dist=1. R_output = 4 - 1 - 1 = 2. Correct.\n        # F(3): Closest C is at 2. dist=1. R_output = 4 - 1 - 1 = 2. Correct.\n        # F(4): Closest C is at 2. dist=2. R_output = 4 - 2 - 1 = 1. Correct.\n        # Ex 4: F(0), C(1), F(2). R_source=2. C_central=4.\n        # F(0): Closest C is at 1. dist=1. R_output = 2 - 1 - 1 = 0. Correct.\n        # F(2): Closest C is at 1. dist=1. R_output = 2 - 1 - 1 = 0. Correct.\n        # Okay, the distance calculation `min(abs(c_frame - c_central))` seems correct.\n        \n        R_output = R_source - min_dist - 1\n\n        # Check if the target row is within grid bounds\n        if R_output >= 0:\n            # Check if the target column is within grid bounds (should always be true)\n            if 0 <= c_frame < width:\n                 # Place the pixel (overwriting if necessary, though examples show it lands on background)\n                 output_grid_np[R_output, c_frame] = C_central\n\n    # 3. Return the modified grid as a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3014,
    "candidates_token_count": 1669,
    "total_token_count": 4683,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.59188
}