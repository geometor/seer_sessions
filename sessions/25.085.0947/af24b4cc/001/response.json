{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies 6 distinct connected components (objects) of non-white pixels in the input grid using 8-way adjacency.\nSorts these components spatially (top-to-bottom, then left-to-right).\nFor each component, determines the most frequent non-white color.\nIf there's a tie in frequency, selects the color that appears first when scanning the component's pixels top-to-bottom, then left-to-right.\nConstructs a 4x5 output grid, placing the determined dominant colors from the 6 components into the cells (1,1) through (2,3) in their sorted order.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"\n    Finds all connected components of non-white pixels using 8-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of components. Each component is a list of (row, col, color) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n    \n    # Define 8-way connectivity neighbors (relative coordinates)\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 (0, -1),          (0, 1),\n                 (1, -1), (1, 0), (1, 1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-white and not visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                component_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    color = grid[row, col]\n                    component_pixels.append((row, col, color))\n                    \n                    # Check neighbors\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, if non-white, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Sort pixels within the component for consistent tie-breaking order later\n                component_pixels.sort() \n                components.append(component_pixels)\n                \n    return components\n\ndef get_dominant_color(component):\n    \"\"\"\n    Determines the dominant color in a component based on frequency,\n    with tie-breaking based on scan order (top-to-bottom, left-to-right).\n\n    Args:\n        component (list): A list of (row, col, color) tuples representing the component,\n                          pre-sorted by row, then column.\n\n    Returns:\n        int: The dominant color.\n    \"\"\"\n    if not component:\n        return 0 # Should not happen with non-empty components\n\n    # Count frequencies of colors\n    colors = [pixel[2] for pixel in component]\n    color_counts = Counter(colors)\n    \n    if not color_counts:\n         return 0 # Empty component case\n         \n    # Find the maximum frequency\n    max_freq = 0\n    for color in color_counts:\n        if color_counts[color] > max_freq:\n            max_freq = color_counts[color]\n\n    # Identify colors with the maximum frequency\n    tied_colors = {color for color, count in color_counts.items() if count == max_freq}\n\n    # If only one color has max frequency, return it\n    if len(tied_colors) == 1:\n        return tied_colors.pop()\n    else:\n        # Tie-breaking: iterate through sorted pixels and return the first color found that is in the tied set\n        for r, c, color in component:\n            if color in tied_colors:\n                return color\n        \n        # Fallback, should ideally not be reached if component is non-empty and tied_colors has elements\n        return component[0][2] \n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on finding dominant colors in connected components.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output grid (4x5, white)\n    output_grid = np.zeros((4, 5), dtype=int)\n\n    # Find connected components\n    components = find_connected_components(input_np)\n\n    # Sort components based on the top-most, then left-most pixel\n    def sort_key(component):\n        min_row = min(p[0] for p in component)\n        min_col = min(p[1] for p in component if p[0] == min_row)\n        return (min_row, min_col)\n\n    components.sort(key=sort_key)\n\n    # Determine dominant color for each component\n    dominant_colors = [get_dominant_color(comp) for comp in components]\n\n    # Populate the 2x3 area in the output grid\n    output_indices = [(1, 1), (1, 2), (1, 3), \n                      (2, 1), (2, 2), (2, 3)]\n    \n    for i, color in enumerate(dominant_colors):\n        if i < len(output_indices): # Ensure we don't exceed the 6 target cells\n            r, c = output_indices[i]\n            output_grid[r, c] = color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3294,
    "candidates_token_count": 1381,
    "total_token_count": 4675,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.20124
}