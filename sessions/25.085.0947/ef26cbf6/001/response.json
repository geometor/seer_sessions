{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies distinct rectangular sections bordered by yellow pixels (4) or grid edges.\nFor each section:\n1. If the section contains blue pixels (1):\n    a. Search within the section for a single pixel whose color is not white (0), blue (1), or yellow (4).\n    b. If exactly one such 'source' color is found, that color becomes the 'replacement color' for this section.\n    c. If no such 'source' color is found within, look at the section directly above it (sharing the same columns, separated by a horizontal yellow line).\n    d. Search within the 'above' section for a single pixel whose color is not white (0) or yellow (4).\n    e. If exactly one such 'source' color is found in the 'above' section, that color becomes the 'replacement color'.\n2. If a 'replacement color' was determined for a section, change all blue pixels (1) within that section to the 'replacement color'.\n3. Leave all other pixels unchanged.\n\"\"\"\n\ndef find_separator_indices(grid):\n    \"\"\"Finds the row and column indices of full yellow lines.\"\"\"\n    h, w = grid.shape\n    h_sep_rows = [r for r in range(h) if np.all(grid[r, :] == 4)]\n    v_sep_cols = [c for c in range(w) if np.all(grid[:, c] == 4)]\n    return h_sep_rows, v_sep_cols\n\ndef get_section_boundaries(h, w, h_sep_rows, v_sep_cols):\n    \"\"\"Determines section boundaries based on separators and grid edges.\"\"\"\n    # Add grid boundaries to separator lists\n    row_boundaries = sorted(list(set([-1] + h_sep_rows + [h])))\n    col_boundaries = sorted(list(set([-1] + v_sep_cols + [w])))\n\n    sections = []\n    # Iterate through potential section boundaries\n    for i in range(len(row_boundaries) - 1):\n        # Start row index is one below the upper boundary\n        r1 = row_boundaries[i] + 1\n        # End row index is the lower boundary (exclusive)\n        r2 = row_boundaries[i+1]\n        # Skip zero-height sections (e.g., between two adjacent separators)\n        if r1 >= r2: continue\n\n        for j in range(len(col_boundaries) - 1):\n            # Start col index is one right of the left boundary\n            c1 = col_boundaries[j] + 1\n            # End col index is the right boundary (exclusive)\n            c2 = col_boundaries[j+1]\n            # Skip zero-width sections\n            if c1 >= c2: continue\n\n            sections.append((r1, r2, c1, c2)) # (start_row, end_row_excl, start_col, end_col_excl)\n\n    return sections, row_boundaries, col_boundaries\n\ndef find_source_color_within(subgrid):\n    \"\"\"\n    Searches a subgrid for a unique pixel color that isn't 0 (white), 1 (blue), or 4 (yellow).\n    Returns the color if found and unique, otherwise None.\n    \"\"\"\n    source_colors = []\n    # Flatten the subgrid and find relevant colors\n    for val in subgrid.flat:\n        if val not in [0, 1, 4]:\n            source_colors.append(val)\n\n    # Count occurrences of each potential source color\n    counts = collections.Counter(source_colors)\n    unique_sources = [color for color, count in counts.items()] # Get list of unique colors found\n\n    # Return the color only if exactly one unique source color exists\n    if len(unique_sources) == 1:\n        return unique_sources[0]\n    return None\n\ndef find_source_color_above_section(above_subgrid):\n    \"\"\"\n    Searches the 'above' subgrid for a unique pixel color that isn't 0 (white) or 4 (yellow).\n    Note: Blue (1) *can* be a source color if it's in the 'above' section.\n    Returns the color if found and unique, otherwise None.\n    \"\"\"\n    source_colors = []\n    # Flatten the subgrid and find relevant colors\n    for val in above_subgrid.flat:\n        if val not in [0, 4]: # Only exclude white and yellow\n            source_colors.append(val)\n\n    # Count occurrences of each potential source color\n    counts = collections.Counter(source_colors)\n    unique_sources = [color for color, count in counts.items()] # Get list of unique colors found\n\n    # Return the color only if exactly one unique source color exists\n    if len(unique_sources) == 1:\n        return unique_sources[0]\n    return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    h, w = grid.shape\n    # Create a copy to modify, preserving the original structure\n    output_grid = grid.copy()\n\n    # 1. Identify separators\n    h_sep_rows, v_sep_cols = find_separator_indices(grid)\n\n    # 2. Define sections based on separators and grid boundaries\n    sections, row_boundaries, col_boundaries = get_section_boundaries(h, w, h_sep_rows, v_sep_cols)\n\n    # Memoization for section source colors to avoid redundant calculations\n    section_source_colors = {}\n    # Create a lookup for row boundary indices for finding 'above' section\n    row_bound_indices = {bound: i for i, bound in enumerate(row_boundaries)}\n\n    # 3. Determine the replacement color for each section containing blue\n    for r1, r2, c1, c2 in sections:\n        subgrid = grid[r1:r2, c1:c2]\n\n        # Only process sections containing blue pixels\n        if np.any(subgrid == 1):\n            # Check if source color already calculated\n            if (r1, r2, c1, c2) in section_source_colors:\n                continue\n\n            replacement_color = None\n\n            # 4a. Search for source color WITHIN the current section\n            replacement_color = find_source_color_within(subgrid)\n\n            # 4b. If not found within, search in the section ABOVE\n            if replacement_color is None:\n                # Check if there's a row above (r1 > 0)\n                # Check if the row immediately above is a horizontal separator\n                if r1 > 0 and np.all(grid[r1-1, c1:c2] == 4):\n                    # The separator row index\n                    sep_row_idx = r1 - 1\n                    # Check if this separator row index is in our list of boundaries\n                    if sep_row_idx in row_bound_indices:\n                        current_bound_idx = row_bound_indices[sep_row_idx]\n                        # Ensure there's a boundary *before* this separator in the list\n                        if current_bound_idx > 0:\n                            prev_bound_val = row_boundaries[current_bound_idx - 1]\n                            # Define the start row of the section above\n                            r0 = prev_bound_val + 1\n                            # Ensure the 'above' section has a positive height\n                            if r0 < r1:\n                                above_subgrid = grid[r0:r1, c1:c2]\n                                replacement_color = find_source_color_above_section(above_subgrid)\n\n            # Store the determined replacement color (could be None if no source found)\n            section_source_colors[(r1, r2, c1, c2)] = replacement_color\n\n    # 5. Apply the replacements to the output grid\n    for (r1, r2, c1, c2), replacement_color in section_source_colors.items():\n        if replacement_color is not None:\n            # Create a mask for blue pixels within the current section of the original grid\n            blue_mask = (grid[r1:r2, c1:c2] == 1)\n            # Apply the replacement color to the corresponding pixels in the output grid\n            output_grid[r1:r2, c1:c2][blue_mask] = replacement_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2972,
    "candidates_token_count": 1997,
    "total_token_count": 4969,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.50199
}