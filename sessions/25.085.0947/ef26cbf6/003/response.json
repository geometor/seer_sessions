{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies distinct rectangular sections bordered by yellow pixels (4) or grid edges.\nFor each section:\n1. Check if the section contains blue pixels (1).\n2. If it contains blue pixels, determine the 'replacement color' using a hierarchical search:\n    a. Search within the section: Look for a single unique pixel color C where C is not in {white(0), blue(1), yellow(4)}. If found, C is the replacement color.\n    b. Search within the row band: If not found in (a), identify the horizontal row band containing the section (bounded by horizontal yellow lines or grid top/bottom). Search the entire row band for a single unique pixel color C where C is not in {white(0), blue(1), yellow(4)}. If found, C is the replacement color.\n    c. Search section above: If not found in (a) or (b), look for a section directly above (sharing columns, separated by a horizontal yellow line). Search within the 'above' section for a single unique pixel color C where C is not in {white(0), yellow(4)}. If found, C is the replacement color.\n3. If a 'replacement color' was determined, change all blue pixels (1) within the original section to this replacement color.\n4. Leave all other pixels unchanged.\n\"\"\"\n\ndef find_separator_indices(grid):\n    \"\"\"Finds the row and column indices of full yellow lines.\"\"\"\n    h, w = grid.shape\n    h_sep_rows = [r for r in range(h) if np.all(grid[r, :] == 4)]\n    v_sep_cols = [c for c in range(w) if np.all(grid[:, c] == 4)]\n    return h_sep_rows, v_sep_cols\n\ndef get_section_boundaries(h, w, h_sep_rows, v_sep_cols):\n    \"\"\"Determines section boundaries based on separators and grid edges.\"\"\"\n    # Add grid boundaries to separator lists\n    row_boundaries = sorted(list(set([-1] + h_sep_rows + [h])))\n    col_boundaries = sorted(list(set([-1] + v_sep_cols + [w])))\n\n    sections = []\n    # Iterate through potential section boundaries\n    for i in range(len(row_boundaries) - 1):\n        # Start row index is one below the upper boundary\n        r1 = row_boundaries[i] + 1\n        # End row index is the lower boundary (exclusive)\n        r2 = row_boundaries[i+1]\n        # Skip zero-height sections\n        if r1 >= r2: continue\n\n        for j in range(len(col_boundaries) - 1):\n            # Start col index is one right of the left boundary\n            c1 = col_boundaries[j] + 1\n            # End col index is the right boundary (exclusive)\n            c2 = col_boundaries[j+1]\n            # Skip zero-width sections\n            if c1 >= c2: continue\n\n            sections.append((r1, r2, c1, c2)) # (start_row, end_row_excl, start_col, end_col_excl)\n\n    return sections, row_boundaries, col_boundaries\n\ndef find_unique_color(subgrid, exclude_colors):\n    \"\"\"\n    Searches a subgrid for a unique pixel color excluding specified colors.\n    Returns the color if found and unique, otherwise None.\n    \"\"\"\n    source_colors = []\n    # Flatten the subgrid and find relevant colors\n    for val in subgrid.flat:\n        if val not in exclude_colors:\n            source_colors.append(val)\n\n    # Count occurrences of each potential source color\n    counts = collections.Counter(source_colors)\n    # Filter to find colors that appear exactly once (or just find unique colors present)\n    # The task description implies finding the *only* unique color, not just any color that appears once.\n    unique_present_colors = list(counts.keys())\n\n    # Return the color only if exactly one unique color type exists in the search area meeting the criteria\n    if len(unique_present_colors) == 1:\n        return unique_present_colors[0]\n    return None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    h, w = grid.shape\n    # Create a copy to modify, preserving the original structure\n    output_grid = grid.copy()\n\n    # 1. Identify separators\n    h_sep_rows, v_sep_cols = find_separator_indices(grid)\n\n    # 2. Define sections based on separators and grid boundaries\n    sections, row_boundaries, col_boundaries = get_section_boundaries(h, w, h_sep_rows, v_sep_cols)\n\n    # Memoization for section and row band source colors\n    section_source_colors = {}\n    row_band_source_colors = {} # Key: (row_start, row_end)\n    # Create a lookup for row boundary indices for finding 'above' section\n    row_bound_indices = {bound: i for i, bound in enumerate(row_boundaries)}\n\n    # 3. Iterate through sections and determine replacement color\n    for r1, r2, c1, c2 in sections:\n        subgrid = grid[r1:r2, c1:c2]\n\n        # Only process sections containing blue pixels\n        if not np.any(subgrid == 1):\n            continue\n\n        # Check if source color already calculated (shouldn't happen with this structure, but good practice)\n        if (r1, r2, c1, c2) in section_source_colors:\n            continue\n\n        replacement_color = None\n\n        # 4a. Search WITHIN the current section\n        replacement_color = find_unique_color(subgrid, exclude_colors={0, 1, 4})\n\n        # 4b. Search WITHIN the ROW BAND (if not found within section)\n        if replacement_color is None:\n            # Determine row band boundaries\n            row_band_key = None\n            # Find the row boundaries indices that define this section's vertical extent\n            upper_bound_idx = -1\n            lower_bound_idx = -1\n            for idx, bound in enumerate(row_boundaries):\n                if bound == r1 - 1:\n                    upper_bound_idx = idx\n                if bound == r2: # r2 is exclusive end row, so boundary is at r2\n                    lower_bound_idx = idx\n                    break # Found both\n\n            if upper_bound_idx != -1 and lower_bound_idx != -1:\n                 band_r1 = row_boundaries[upper_bound_idx] + 1\n                 band_r2 = row_boundaries[lower_bound_idx] # Use the boundary value directly as exclusive end\n                 row_band_key = (band_r1, band_r2)\n\n                 # Check memoization for row band source color\n                 if row_band_key in row_band_source_colors:\n                     replacement_color = row_band_source_colors[row_band_key]\n                 else:\n                     # Search the entire row band\n                     row_band_subgrid = grid[band_r1:band_r2, 0:w]\n                     band_source_color = find_unique_color(row_band_subgrid, exclude_colors={0, 1, 4})\n                     # Store result (even if None)\n                     row_band_source_colors[row_band_key] = band_source_color\n                     replacement_color = band_source_color\n\n\n        # 4c. Search in the section ABOVE (if not found within section or row band)\n        if replacement_color is None:\n            # Check if there's a row above (r1 > 0)\n            # Check if the row immediately above is a horizontal separator\n            if r1 > 0 and (r1 - 1) in h_sep_rows:\n                # The separator row index\n                sep_row_idx = r1 - 1\n                # Check if this separator row index is in our list of boundaries\n                if sep_row_idx in row_bound_indices:\n                    current_bound_idx = row_bound_indices[sep_row_idx]\n                    # Ensure there's a boundary *before* this separator in the list\n                    if current_bound_idx > 0:\n                        prev_bound_val = row_boundaries[current_bound_idx - 1]\n                        # Define the start row of the section above\n                        r0 = prev_bound_val + 1\n                        # Ensure the 'above' section has a positive height and valid column range\n                        if r0 < sep_row_idx + 1: # Use sep_row_idx + 1 which equals r1\n                            # Get the actual subgrid for the section above\n                            above_subgrid = grid[r0:r1, c1:c2]\n                            # Search using different exclusion rules {0, 4}\n                            replacement_color = find_unique_color(above_subgrid, exclude_colors={0, 4})\n\n\n        # Store the determined replacement color for this specific section\n        section_source_colors[(r1, r2, c1, c2)] = replacement_color\n\n    # 5. Apply the replacements to the output grid\n    for (r1, r2, c1, c2), replacement_color in section_source_colors.items():\n        if replacement_color is not None:\n            # Create a mask for blue pixels within the current section coordinates\n            blue_mask = (grid[r1:r2, c1:c2] == 1)\n            # Apply the replacement color to the corresponding pixels in the output grid\n            # using the same section coordinates\n            output_grid[r1:r2, c1:c2][blue_mask] = replacement_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8589,
    "candidates_token_count": 2334,
    "total_token_count": 10923,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.158433
}