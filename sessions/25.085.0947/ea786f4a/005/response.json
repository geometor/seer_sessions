{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nTransforms the input grid based on Manhattan distance from a unique white pixel, with a special conditional rule for even distances when the background color is Green (3).\n\n1. Find the coordinates (r0, c0) of the unique white (0) pixel.\n2. Find the background color (bg), which is the non-white color present.\n3. Create an output grid of the same size.\n4. For each pixel (r, c):\n    a. Calculate the Manhattan distance d = |r - r0| + |c - c0|.\n    b. Determine the output color based on d and bg:\n        i.   If d == 0, the output color is white (0).\n        ii.  If d is odd, the output color is the background color (bg).\n        iii. If d is even and d > 0:\n             1. If bg is Green (3):\n                 - If (d // 2) is odd, the output color is Green (3).\n                 - If (d // 2) is even, the output color is white (0).\n             2. If bg is not Green (3):\n                 - The output color is white (0).\n5. Return the output grid.\n\"\"\"\n\ndef find_unique_pixel(grid: np.ndarray, color: int) -> Tuple[int, int]:\n    \"\"\"Finds the coordinates of the unique pixel with the specified color.\"\"\"\n    coords = np.argwhere(grid == color)\n    if coords.shape[0] != 1:\n        raise ValueError(f\"Expected exactly one pixel with color {color}, found {coords.shape[0]}\")\n    # Return as (row, col) tuple\n    return tuple(coords[0])\n\ndef get_background_color(grid: np.ndarray, exception_color: int) -> int:\n    \"\"\"Finds a color in the grid that is not the exception_color.\"\"\"\n    unique_colors = np.unique(grid)\n    for color in unique_colors:\n        if color != exception_color:\n            return color\n    # Handle case where only the exception color exists or grid is empty\n    raise ValueError(f\"Could not find a background color different from {exception_color}\")\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies a transformation based on Manhattan distance from a unique white pixel,\n    with a special rule for even distances depending on the background color.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient operations\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Handle edge case: Empty grid\n    if height == 0 or width == 0:\n        return []\n        \n    # Handle edge case: 1x1 grid - follows d=0 rule\n    if height == 1 and width == 1:\n        if grid_np[0,0] == 0:\n             return [[0]]\n        else:\n             # Input violates assumption of unique white pixel if not 0\n             raise ValueError(\"Input 1x1 grid does not contain the required white pixel.\")\n\n    # 1. Identify the coordinates of the unique white pixel (0).\n    try:\n        r0, c0 = find_unique_pixel(grid_np, 0)\n    except ValueError as e:\n        print(f\"Error finding unique white pixel: {e}\")\n        raise # Propagate error\n\n    # 2. Identify the background color.\n    try:\n        background_color = get_background_color(grid_np, 0)\n    except ValueError as e:\n        print(f\"Error finding background color: {e}\")\n        raise # Propagate error\n\n    # 3. Create a new output grid, initialized (e.g., with zeros).\n    output_grid = np.zeros_like(grid_np)\n\n    # 4. Iterate through each pixel in the grid.\n    for r in range(height):\n        for c in range(width):\n            # 4a. Calculate Manhattan distance to the white pixel.\n            distance = abs(r - r0) + abs(c - c0)\n\n            # 4b. Determine output color based on distance and background color rules.\n            output_color = -1 # Initialize with invalid value\n\n            # 4b.i: Rule for d = 0\n            if distance == 0:\n                output_color = 0\n            # 4b.ii: Rule for odd d\n            elif distance % 2 != 0:\n                output_color = background_color\n            # 4b.iii: Rule for even d > 0\n            else: # distance is even and > 0\n                # 4b.iii.1: Check if background is Green (3)\n                if background_color == 3:\n                    half_d = distance // 2\n                    # 4b.iii.1.a/b: Rule based on parity of half_d\n                    if half_d % 2 != 0: # half_d is odd\n                        output_color = background_color # Green (3)\n                    else: # half_d is even\n                        output_color = 0 # white\n                # 4b.iii.2: Rule if background is NOT Green (3)\n                else:\n                    output_color = 0 # white\n\n            # Assign the calculated color to the output grid\n            output_grid[r, c] = output_color\n\n    # 5. Convert the numpy array back to a list of lists for the final output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12317,
    "candidates_token_count": 1294,
    "total_token_count": 13611,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 12.899821
}