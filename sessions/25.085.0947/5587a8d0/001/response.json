{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nConstructs a nested square grid based on color frequency from the input grid.\n\n1.  Counts the occurrences of each unique color in the input grid.\n2.  Identifies the background color as the one with the highest frequency. If there's a tie in frequency, the color with the lower index is chosen as the background.\n3.  Identifies all other colors (non-background colors).\n4.  Sorts these non-background colors based on their frequency in descending order. If counts are tied, colors are sorted by their index in ascending order.\n5.  Determines the output grid size (S x S) where S = 2 * N - 1, and N is the number of unique non-background colors.\n6.  Constructs the output grid by creating nested square frames:\n    - The outermost frame uses the most frequent non-background color.\n    - The next inner frame uses the second most frequent non-background color.\n    - This continues inwards, with the least frequent non-background color filling the center.\n7.  Handles edge cases:\n    - Empty input grid returns an empty grid.\n    - Input grid with only one color returns a 1x1 grid of that color.\n    - Input grid where only the background color exists (after identifying it) returns a 1x1 grid of the background color.\n\"\"\"\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid based on color frequency and nested frame construction.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array if it isn't already\n    input_grid = np.array(input_grid)\n\n    # 1. Count colors\n    colors, counts = np.unique(input_grid, return_counts=True)\n    color_counts = dict(zip(colors, counts))\n\n    # Handle simple cases: empty grid or grid with only one color\n    if len(color_counts) == 0:\n         # Return empty grid for empty input\n         return np.array([[]])\n    if len(color_counts) == 1:\n         # Return 1x1 grid of the single color present\n         single_color = colors[0]\n         return np.array([[single_color]], dtype=int)\n\n    # 2. Determine background color (most frequent, lowest index tie-breaker)\n    max_count = 0\n    for count in color_counts.values():\n        if count > max_count:\n            max_count = count\n    \n    # Find all colors with the maximum count\n    potential_background_colors = [color for color, count in color_counts.items() if count == max_count]\n    # Choose the one with the smallest color index as background\n    background_color = min(potential_background_colors)\n\n    # 3. Identify non-background colors and their counts\n    non_background_colors = []\n    for color, count in color_counts.items():\n        if color != background_color:\n            non_background_colors.append((color, count))\n\n    # Handle case: only background color is present (no non-background colors)\n    if not non_background_colors:\n         # Return 1x1 grid of the background color\n         return np.array([[background_color]], dtype=int)\n\n    # N is the number of unique non-background colors\n    N = len(non_background_colors)\n\n    # 4. Sort non-background colors: by count descending, then by color index ascending\n    # The key uses a tuple: (-count, color) ensures descending count, ascending color for ties\n    sorted_colors_with_counts = sorted(non_background_colors, key=lambda item: (-item[1], item[0]))\n    # Extract just the sorted colors\n    sorted_colors = [item[0] for item in sorted_colors_with_counts]\n\n    # 5. Calculate output grid size\n    S = 2 * N - 1\n\n    # 6. Initialize output grid: create an S x S grid\n    # We will fill it layer by layer, starting from the outermost\n    # It's efficient to start with the outermost color filling the whole grid\n    output_grid = np.full((S, S), sorted_colors[0], dtype=int)\n\n    # 7. Fill nested frames\n    # Iterate from the second color (index 1) up to the last color (index N-1)\n    # 'k' represents the layer index (0 is outermost, N-1 is innermost)\n    for k in range(1, N):\n        color_to_fill = sorted_colors[k] # Get the color for the current layer\n\n        # Calculate the boundaries for the current layer's square region\n        # The k-th layer fills the square from (k, k) to (S-1-k, S-1-k)\n        top_left_row = k\n        top_left_col = k\n        bottom_right_row = S - 1 - k\n        bottom_right_col = S - 1 - k\n\n        # Ensure the indices are valid (should always be true if N >= 1)\n        if top_left_row <= bottom_right_row and top_left_col <= bottom_right_col:\n            # Fill the inner square region corresponding to this layer\n            # Numpy slicing uses exclusive end index for range, so add 1\n            output_grid[top_left_row : bottom_right_row + 1, top_left_col : bottom_right_col + 1] = color_to_fill\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2839,
    "candidates_token_count": 1301,
    "total_token_count": 4140,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.54844
}