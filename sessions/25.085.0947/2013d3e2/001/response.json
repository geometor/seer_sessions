{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms an input grid by extracting a 3x3 subgrid. \nThe top-left corner of the subgrid is determined as follows:\n1. If the input grid contains any blue pixels (color 1), the top-left corner is the location (row, column) of the uppermost, then leftmost blue pixel.\n2. If the input grid does not contain any blue pixels, the top-left corner is the location (row, column) of the uppermost, then leftmost non-white pixel (colors 1-9).\nThe 3x3 subgrid starting at this determined corner is then returned as the output.\n\"\"\"\n\ndef find_top_left_pixel(grid: np.ndarray, color: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates (row, col) of the first occurrence of a specific color,\n    searching row by row, then column by column (top-leftmost).\n\n    Args:\n        grid: The input NumPy array representing the grid.\n        color: The integer color value to search for.\n\n    Returns:\n        A tuple (row, col) if the color is found, otherwise None.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                return r, c\n    return None\n\ndef find_non_white_bounding_box_top_left(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the top-left corner coordinates (min_row, min_col) of the\n    bounding box containing all non-white pixels.\n\n    Args:\n        grid: The input NumPy array representing the grid.\n\n    Returns:\n        A tuple (min_row, min_col) if non-white pixels exist, otherwise None.\n    \"\"\"\n    non_white_pixels = np.argwhere(grid != 0) # Find indices where grid is not 0\n    if non_white_pixels.size == 0:\n        return None # No non-white pixels found\n    \n    min_row = np.min(non_white_pixels[:, 0])\n    min_col = np.min(non_white_pixels[:, 1])\n    return min_row, min_col\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the 3x3 extracted output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    \n    start_row, start_col = -1, -1\n\n    # 1. Check for blue pixels (color 1)\n    blue_coords = find_top_left_pixel(grid_np, 1)\n\n    # 2. Determine the starting coordinates for extraction\n    if blue_coords is not None:\n        # If blue is present, use its top-leftmost coordinates\n        start_row, start_col = blue_coords\n        # print(f\"Blue found at: ({start_row}, {start_col})\") # Debugging\n    else:\n        # If blue is not present, find the top-left of the non-white bounding box\n        non_white_coords = find_non_white_bounding_box_top_left(grid_np)\n        if non_white_coords is not None:\n            start_row, start_col = non_white_coords\n            # print(f\"Non-white bounding box top-left: ({start_row}, {start_col})\") # Debugging\n        else:\n            # Handle edge case where the grid is entirely white (though unlikely based on task)\n            # Defaulting to top-left 0,0 and hoping it fits, or raise error?\n            # Based on examples, extraction always seems possible.\n            # If this case happens, returning a 3x3 of white might be safest.\n            # Let's assume valid inputs mean extraction is always possible based on rules.\n            # If we hit this, something is wrong with the assumptions or input.\n             print(\"Warning: Grid has no blue and no non-white pixels. Cannot determine start point.\")\n             # Returning a default or raising an error might be needed depending on requirements.\n             # For now, let's assume valid input means one of the conditions will find coordinates.\n             # If start_row/col remain -1, slicing below will fail. Add explicit check.\n             if start_row == -1 or start_col == -1:\n                 raise ValueError(\"Could not determine the starting point for extraction.\")\n\n\n    # 3. Extract the 3x3 subgrid\n    # Ensure the slice indices are valid\n    grid_height, grid_width = grid_np.shape\n    end_row = min(start_row + 3, grid_height)\n    end_col = min(start_col + 3, grid_width)\n    \n    # Perform the extraction\n    output_grid_np = grid_np[start_row:end_row, start_col:end_col]\n\n    # Check if the extracted grid is indeed 3x3, pad if necessary (though problem implies it fits)\n    # Based on problem description, we expect a 3x3 output. If extraction is smaller,\n    # it might indicate an issue or require padding, but let's stick to direct extraction first.\n    if output_grid_np.shape != (3, 3):\n         print(f\"Warning: Extracted grid is not 3x3. Actual shape: {output_grid_np.shape}\")\n         # Consider padding logic here if required by future examples.\n         # For now, proceed with the potentially smaller grid.\n         # Re-evaluating: The examples strictly show 3x3 output. The slicing should guarantee this\n         # unless the start point is too close to the edge. Let's assume valid inputs allow 3x3 extraction.\n\n    # 4. Convert the output numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2539,
    "candidates_token_count": 1449,
    "total_token_count": 3988,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.476615
}