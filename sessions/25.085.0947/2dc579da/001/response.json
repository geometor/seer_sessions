{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies horizontal and vertical lines partitioning the input grid. Finds a single unique 'target' pixel located in one of the four quadrants defined by these lines. Extracts and returns the subgrid corresponding to the quadrant containing the target pixel.\n\n1.  Identify the primary background color (most frequent).\n2.  Find the row index of the single horizontal line (all same color, different from background).\n3.  Find the column index of the single vertical line (all same color, different from background).\n4.  Find the coordinates (row, col) of the single 'target' pixel whose color is different from the background color and the line colors.\n5.  Determine the quadrant (Top-Left, Top-Right, Bottom-Left, Bottom-Right) containing the target pixel based on its position relative to the lines.\n6.  Define the row and column ranges corresponding to the target quadrant.\n7.  Extract the subgrid from the input grid using these ranges.\n8.  Return the extracted subgrid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assuming background is the most frequent color\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_lines(grid, background_color):\n    \"\"\"Finds the indices of the horizontal and vertical lines.\"\"\"\n    rows, cols = grid.shape\n    h_line_idx = -1\n    v_line_idx = -1\n    h_line_color = -1\n    v_line_color = -1\n\n    # Find horizontal line\n    for r in range(rows):\n        row = grid[r, :]\n        first_color = row[0]\n        if first_color != background_color and np.all(row == first_color):\n            h_line_idx = r\n            h_line_color = first_color\n            break # Assume only one horizontal line\n\n    # Find vertical line\n    for c in range(cols):\n        col = grid[:, c]\n        first_color = col[0]\n        if first_color != background_color and np.all(col == first_color):\n            v_line_idx = c\n            v_line_color = first_color\n            break # Assume only one vertical line\n\n    if h_line_idx == -1 or v_line_idx == -1:\n        raise ValueError(\"Could not find both horizontal and vertical lines.\")\n\n    # In case line colors are needed later, return them too\n    # Return line colors as a set to handle cases where they might be the same\n    line_colors = {h_line_color, v_line_color}\n\n    return h_line_idx, v_line_idx, line_colors\n\n\ndef find_target_pixel(grid, background_color, line_colors):\n    \"\"\"Finds the coordinates of the unique target pixel.\"\"\"\n    rows, cols = grid.shape\n    target_r, target_c = -1, -1\n    found = False\n\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = grid[r, c]\n            if pixel_color != background_color and pixel_color not in line_colors:\n                if found:\n                     # This assumes exactly one such pixel exists per the problem description\n                     raise ValueError(\"Found more than one potential target pixel.\")\n                target_r, target_c = r, c\n                found = True\n\n    if not found:\n        raise ValueError(\"Could not find the target pixel.\")\n\n    return target_r, target_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on quadrant selection guided by a unique pixel.\n    \"\"\"\n    # Convert input list of lists to a numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # 1. Identify background color\n    background_color = find_background_color(grid_np)\n\n    # 2. & 3. Identify horizontal and vertical lines\n    h_line_idx, v_line_idx, line_colors = find_lines(grid_np, background_color)\n\n    # 4. Identify the target pixel\n    target_r, target_c = find_target_pixel(grid_np, background_color, line_colors)\n\n    # 5. Determine the target quadrant\n    # Define quadrant boundaries (exclusive of lines)\n    row_start, row_end = 0, 0\n    col_start, col_end = 0, 0\n\n    if target_r < h_line_idx and target_c < v_line_idx:\n        # Top-Left quadrant\n        row_start, row_end = 0, h_line_idx\n        col_start, col_end = 0, v_line_idx\n    elif target_r < h_line_idx and target_c > v_line_idx:\n        # Top-Right quadrant\n        row_start, row_end = 0, h_line_idx\n        col_start, col_end = v_line_idx + 1, cols\n    elif target_r > h_line_idx and target_c < v_line_idx:\n        # Bottom-Left quadrant\n        row_start, row_end = h_line_idx + 1, rows\n        col_start, col_end = 0, v_line_idx\n    elif target_r > h_line_idx and target_c > v_line_idx:\n        # Bottom-Right quadrant\n        row_start, row_end = h_line_idx + 1, rows\n        col_start, col_end = v_line_idx + 1, cols\n    else:\n        # Should not happen if target pixel is not on a line\n        raise ValueError(\"Target pixel appears to be on a line.\")\n\n    # 6. & 7. Extract the subgrid\n    output_grid_np = grid_np[row_start:row_end, col_start:col_end]\n\n    # 8. Convert back to list of lists and return\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2945,
    "candidates_token_count": 1444,
    "total_token_count": 4389,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.718127
}