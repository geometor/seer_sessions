{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Any, Set\n\n\"\"\"\nIdentifies all distinct non-white objects in the input grid using 8-connectivity.\nCalculates properties for each object: area, bounding box (bbox), bbox area, and density (area / bbox_area).\nSelects the object based on the following criteria, applied sequentially:\n1. Maximum density.\n2. Maximum area (among objects tied for maximum density).\n3. Earliest top-left corner (minimum row, then minimum column) of the bbox (among objects tied for maximum density and maximum area).\nReturns the subgrid corresponding to the bounding box of the selected object.\n\"\"\"\n\ndef get_neighbors_8_conn(r: int, c: int, height: int, width: int) -> List[Tuple[int, int]]:\n    \"\"\"Gets the valid 8-connectivity neighbors (orthogonal and diagonal) of a cell.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue  # Skip the cell itself\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects_8_conn(grid: np.ndarray) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds all distinct contiguous objects (using 8-connectivity) of non-white color.\n\n    Args:\n        grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'color', 'pixels' (set of (r, c) tuples), 'area',\n        'bbox' (min_r, max_r, min_c, max_c), 'bbox_area', and 'density'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS from a non-white pixel that hasn't been visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels: Set[Tuple[int, int]] = set()\n                q: List[Tuple[int, int]] = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # Use a set to quickly check if a neighbor is already queued or processed for *this* object\n                processed_in_this_obj: Set[Tuple[int, int]] = set([(r,c)]) \n\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n                    \n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for nr, nc in get_neighbors_8_conn(curr_r, curr_c, height, width):\n                        # Check if neighbor is same color, not globally visited, and not already processed for this object\n                        if grid[nr, nc] == color and not visited[nr, nc] and (nr, nc) not in processed_in_this_obj:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            processed_in_this_obj.add((nr, nc))\n                \n                # Calculate properties for the found object\n                area = len(obj_pixels)\n                if area > 0: # Should always be true if we start BFS correctly\n                    bbox = (min_r, max_r, min_c, max_c)\n                    bbox_h = max_r - min_r + 1\n                    bbox_w = max_c - min_c + 1\n                    bbox_area = bbox_h * bbox_w\n                    # Avoid division by zero, although bbox_area should be > 0 if area > 0\n                    density = area / bbox_area if bbox_area > 0 else 0 \n\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'area': area,\n                        'bbox': bbox,         # (min_r, max_r, min_c, max_c)\n                        'bbox_area': bbox_area,\n                        'density': density\n                    })\n\n    return objects\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    \n    # 1. Find all distinct non-white objects using 8-connectivity and calculate properties\n    objects = find_objects_8_conn(input_grid)\n\n    # Handle case where no non-white objects are found\n    if not objects:\n        # Return an empty grid or a default grid as appropriate.\n        # Based on ARC tasks, this is unlikely for valid inputs, but good practice.\n        # Returning a 1x1 white grid might be safer than an empty array.\n        return np.zeros((1, 1), dtype=int) \n\n    # 2. Find the maximum density\n    max_density = -1.0\n    for obj in objects:\n        if obj['density'] > max_density:\n            max_density = obj['density']\n\n    # 3. Filter objects to get candidates with maximum density\n    # Use a small tolerance for floating point comparison\n    density_candidates = [obj for obj in objects if abs(obj['density'] - max_density) < 1e-9]\n\n    # 4. Apply tie-breaker 1: Maximum Area\n    selected_object = None\n    if len(density_candidates) == 1:\n        selected_object = density_candidates[0]\n    else:\n        max_area = -1\n        for obj in density_candidates:\n            if obj['area'] > max_area:\n                max_area = obj['area']\n        \n        area_candidates = [obj for obj in density_candidates if obj['area'] == max_area]\n\n        # 5. Apply tie-breaker 2: Earliest Top-Left BBox Corner\n        if len(area_candidates) == 1:\n            selected_object = area_candidates[0]\n        else:\n            # Sort by min_row (bbox[0]), then min_col (bbox[2])\n            area_candidates.sort(key=lambda o: (o['bbox'][0], o['bbox'][2]))\n            selected_object = area_candidates[0] # Select the first one after sorting\n\n    # Should have a selected object if the initial objects list was not empty\n    if selected_object is None:\n         # This case should ideally not be reached if input has objects\n         return np.zeros((1, 1), dtype=int)\n\n    # 6. Extract the output subgrid based on the selected object's bounding box\n    min_r, max_r, min_c, max_c = selected_object['bbox']\n    output_grid = input_grid[min_r:max_r+1, min_c:max_c+1]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10693,
    "candidates_token_count": 1763,
    "total_token_count": 12456,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.456098
}