"""
The output grid is generated by processing each column of the input grid independently. For each column, identify any non-white pixels. If no non-white pixels are present in that column, the output column is all white (0). If non-white pixels exist in the column, fill the entire output column from top to bottom with the color of the non-white pixel that has the smallest row index (i.e., is closest to the top of the input grid). If multiple pixels in the column share the smallest row index, their color will overwrite from top to bottom, so the pixel that occurs later/lower will dominate.
"""

import numpy as np

def transform(input_grid):
    """
    Transforms the input grid based on column-wise dominance of the top-most non-white pixel.
    """
    rows, cols = input_grid.shape
    output_grid = np.zeros((rows, cols), dtype=int)

    # Iterate through each column
    for c in range(cols):
        # Find non-white pixels in the current column
        non_white_pixels = []
        for r in range(rows):
            if input_grid[r, c] != 0:
                non_white_pixels.append((r, input_grid[r, c]))

        # If non-white pixels exist, fill the column
        if non_white_pixels:
            # Get the color of the top-most non-white pixel
            top_most_pixel = min(non_white_pixels, key=lambda x: x[0])
            color = top_most_pixel[1]

            # Fill the entire column with that color
            for r in range(rows):
                output_grid[r, c] = color

    return output_grid