{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Azure Regions:** Locate all contiguous regions of color 8 (azure) within the input grid.\n2.  **Horizontal Span Calculation:** For each azure region, and for regions that are horizontally adjacent, calculate the combined horizontal span.\n3. **Conditional Replacement:** For any combined azure region:\n    *   If the horizontal span is less than 5, no replacement occurs.\n    *   If the horizontal span is 5 or greater, examine each pixel:\n        1.  Check for a pixel directly above.\n        2.  If a pixel exists directly above, replace the azure pixel with the color of the pixel above.\n        3.  If there's no pixel directly above, retain the original azure color (8).\n4. For other colours, no action.\n\"\"\"\n\nimport numpy as np\n\ndef find_contiguous_regions(grid, color):\n    \"\"\"Finds contiguous regions of a specific color in the grid.\"\"\"\n    regions = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def dfs(row, col, current_region):\n        \"\"\"Depth-first search to find contiguous region.\"\"\"\n        if (row < 0 or row >= grid.shape[0] or col < 0 or col >= grid.shape[1] or\n                visited[row, col] or grid[row, col] != color):\n            return\n        visited[row, col] = True\n        current_region.append((row, col))\n        dfs(row + 1, col, current_region)\n        dfs(row - 1, col, current_region)\n        dfs(row, col + 1, current_region)\n        dfs(row, col - 1, current_region)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if grid[row, col] == color and not visited[row, col]:\n                current_region = []\n                dfs(row, col, current_region)\n                regions.append(current_region)\n    return regions\n\ndef get_horizontal_span(region):\n    \"\"\"Calculates the horizontal span of a region, assuming region is sorted.\"\"\"\n    if not region:\n        return 0\n    \n    # Group cells by row\n    rows = {}\n    for r, c in region:\n        if r not in rows:\n            rows[r] = []\n        rows[r].append((r,c))\n\n    total_span = 0\n    for row, cells in rows.items():\n        total_span += len(cells)\n    \n    return total_span\n\ndef combine_horizontally_adjacent_regions(regions):\n    \"\"\"Combines horizontally adjacent regions.\"\"\"\n    combined_regions = []\n    processed = [False] * len(regions)\n\n    for i in range(len(regions)):\n        if processed[i]:\n            continue\n\n        current_combined_region = list(regions[i])  # Start with the current region\n        processed[i] = True\n\n        for j in range(i + 1, len(regions)):\n             if processed[j]:\n                continue\n             #get rows for region i\n             rows_i = set()\n             for r, c in regions[i]:\n                rows_i.add(r)\n            #get rows for region j\n             rows_j = set()\n             for r, c in regions[j]:\n                rows_j.add(r)\n\n             if rows_i.intersection(rows_j): #check if regions on same row\n                #sort by row, col\n                regions[i].sort(key=lambda x: (x[0], x[1]))\n                regions[j].sort(key=lambda x: (x[0], x[1]))\n\n                #get last col of region i, and first col of region j on any common row\n                last_col_i = {}\n                for r,c in regions[i]:\n                    if r in rows_i.intersection(rows_j):\n                        last_col_i[r] = c\n                \n                first_col_j = {}\n                for r,c in regions[j]:\n                    if r in rows_i.intersection(rows_j):\n                        first_col_j[r] = c\n                \n                adjacent = False\n                for r in rows_i.intersection(rows_j):\n                    if first_col_j[r] - last_col_i[r] == 1:\n                        adjacent = True\n\n                if adjacent:\n                    current_combined_region.extend(regions[j])\n                    processed[j] = True\n\n        combined_regions.append(current_combined_region)\n\n    #add any regions that were not processed (ie not horizontally adjacent to any other)\n    for i in range(len(regions)):\n        if not processed[i]:\n            combined_regions.append(regions[i])\n    \n    return combined_regions\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the specified rule.\"\"\"\n    output_grid = np.copy(input_grid)\n    azure_regions = find_contiguous_regions(input_grid, 8)\n\n    # Combine horizontally adjacent regions\n    combined_regions = combine_horizontally_adjacent_regions(azure_regions)\n\n    for region in combined_regions:\n        # Sort by row and then by column\n        region.sort(key=lambda x: (x[0], x[1]))\n        span = get_horizontal_span(region)\n\n        if span >= 5:\n            for r, c in region:\n                if r > 0:  # Check if there's a pixel above\n                    output_grid[r, c] = input_grid[r - 1, c]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4417,
    "candidates_token_count": 1318,
    "total_token_count": 5735,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.736421,
  "response_file": "010-response.json"
}