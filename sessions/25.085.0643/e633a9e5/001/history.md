
## train_1

**input:**
```
1 3 5
1 2 8
8 3 8
```


**output:**
```
1 1 3 5 5
1 1 3 5 5
1 1 2 8 8
8 8 3 8 8
8 8 3 8 8
```


## train_2

**input:**
```
6 5 5
5 1 7
4 5 2
```


**output:**
```
6 6 5 5 5
6 6 5 5 5
5 5 1 7 7
4 4 5 2 2
4 4 5 2 2
```


## train_3

**input:**
```
2 3 7
2 1 6
1 5 7
```


**output:**
```
2 2 3 7 7
2 2 3 7 7
2 2 1 6 6
1 1 5 7 7
1 1 5 7 7
```

Okay, let's analyze the task examples.

**Perception of Elements:**

1.  **Input/Output Grids:** The task involves transforming an input grid into an output grid. In all provided examples, the input grid is 3x3 and the output grid is 5x5.
2.  **Pixel Values:** The pixel values (colors) from the input grid are preserved in the output grid, but their spatial arrangement and coverage change.
3.  **Expansion Pattern:** Observing the relationship between input and output pixels reveals a pattern of expansion.
    *   Pixels in the corners of the input grid (e.g., top-left, top-right, bottom-left, bottom-right) seem to expand into 2x2 blocks in the output grid.
    *   Pixels on the edges but not corners (e.g., top-center, bottom-center, left-center, right-center) seem to expand into 1x2 (for horizontal edges) or 2x1 (for vertical edges) blocks.
    *   The pixel in the absolute center of the 3x3 input grid seems to map to a single 1x1 pixel in the output grid.
4.  **Positional Dependency:** The amount and direction of expansion depend on the pixel's position within the input grid, specifically whether it lies on a boundary (first/last row or column).
5.  **Dimension Change:** The output grid's dimensions (H', W') appear related to the input dimensions (H, W) based on this boundary expansion. For an HxW input, rows 0 and H-1 seem to contribute 2 rows each to the output height (if H>1), while other rows contribute 1 row. Similarly, columns 0 and W-1 contribute 2 columns each to the output width (if W>1), while others contribute 1 column.

**Facts (YAML):**


```yaml
task_description: Expands an input grid by scaling pixels based on their position relative to the grid boundaries. Pixels on the first or last row/column are duplicated along that axis.

definitions:
  - object: grid
    properties:
      - height: H
      - width: W
      - pixels: 2D array of color values
  - object: pixel
    properties:
      - position: (row, col)
      - value: color
      - is_boundary_row: boolean (true if row is 0 or H-1, and H > 1)
      - is_boundary_col: boolean (true if col is 0 or W-1, and W > 1)

input_grid:
  type: grid
  properties:
    - height: H_in
    - width: W_in

output_grid:
  type: grid
  properties:
    - height: H_out
    - width: W_out
    - relationship_to_input: Generated by mapping each input pixel to an expanded block in the output.

transformation_rules:
  - rule: calculate_scale_factors
    for_each: input pixel at (r, c)
    condition: H_in > 1 and (r == 0 or r == H_in - 1)
    output: row_scale_factor = 2
    default: row_scale_factor = 1
  - rule: calculate_scale_factors
    for_each: input pixel at (r, c)
    condition: W_in > 1 and (c == 0 or c == W_in - 1)
    output: col_scale_factor = 2
    default: col_scale_factor = 1

  - rule: calculate_output_dimensions
    inputs: [H_in, W_in]
    outputs: [H_out, W_out]
    logic: |
      H_out is the sum of row_scale_factors for all rows r from 0 to H_in-1.
      W_out is the sum of col_scale_factors for all columns c from 0 to W_in-1.

  - rule: map_pixels
    for_each: input pixel p at (r, c) with value v
    actions:
      - Determine row_scale_factor (rf) and col_scale_factor (cf) for p.
      - Calculate start row in output: R_start = sum of row_scale_factors for rows 0 to r-1.
      - Calculate start column in output: C_start = sum of col_scale_factors for columns 0 to c-1.
      - Fill the output grid block from (R_start, C_start) to (R_start + rf - 1, C_start + cf - 1) with value v.
```


**Natural Language Program:**

1.  **Analyze Input:** Get the input grid's dimensions: height `H_in` and width `W_in`.
2.  **Determine Scaling:** For each input row `r`, determine its vertical scale factor: `row_factor` is 2 if `H_in > 1` and `r` is the first (0) or last (`H_in - 1`) row, otherwise `row_factor` is 1. Similarly, for each input column `c`, determine its horizontal scale factor: `col_factor` is 2 if `W_in > 1` and `c` is the first (0) or last (`W_in - 1`) column, otherwise `col_factor` is 1.
3.  **Calculate Output Size:** Calculate the output grid height `H_out` by summing all `row_factors` for rows 0 to `H_in - 1`. Calculate the output grid width `W_out` by summing all `col_factors` for columns 0 to `W_in - 1`.
4.  **Compute Offsets:** Calculate cumulative row offsets (`row_starts`) where `row_starts[r]` is the sum of `row_factors` for rows 0 to `r-1`. Calculate cumulative column offsets (`col_starts`) where `col_starts[c]` is the sum of `col_factors` for columns 0 to `c-1`.
5.  **Construct Output:** Create a new grid `output_grid` of size `H_out` x `W_out`. Iterate through each pixel `(r, c)` in the `input_grid` with value `v`:
    a. Retrieve the pre-calculated `row_factor` and `col_factor` for this pixel's position.
    b. Retrieve the pre-calculated start row `R_start = row_starts[r]` and start column `C_start = col_starts[c]`.
    c. Fill the rectangular region in `output_grid` defined by rows `R_start` to `R_start + row_factor - 1` and columns `C_start` to `C_start + col_factor - 1` with the input pixel value `v`.
6.  **Return Output:** The completed `output_grid` is the result.
