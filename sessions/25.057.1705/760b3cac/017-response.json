{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Azure Objects:** Locate all contiguous blocks of azure (color 8) pixels in the input grid.\n2.  **Prioritize Top-Right Object**: If there are multiple azure objects and any has pixels where x > 5, consider *only* the object at the top-right of the input grid.\n3.  **Apply the shift, if any:** If the remaining object consists of single pixels (i.e many small objects), shift each azure pixel down by one row and combine them to adjacent pixels on that row.\n4.  **Apply Horizontal Translation:** If the selected object has a width greater than it's height, translate the entire object to the right edge, then shift left 3 units.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid, color):\n    coords = np.argwhere(grid == color)\n    if len(coords) == 0:\n        return []  # Return empty list if no objects of specified color\n    # Group contiguous pixels into objects\n    objects = []\n    visited = set()\n    for x, y in coords:\n        if (x, y) not in visited:\n            object_coords = []\n            stack = [(x, y)]\n            while stack:\n                curr_x, curr_y = stack.pop()\n                if (curr_x, curr_y) in visited:\n                    continue\n                visited.add((curr_x, curr_y))\n                object_coords.append((curr_x, curr_y))\n                # Check adjacent pixels (up, down, left, right)\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    new_x, new_y = curr_x + dx, curr_y + dy\n                    if (0 <= new_x < grid.shape[0] and 0 <= new_y < grid.shape[1] and\n                            grid[new_x, new_y] == color and (new_x, new_y) not in visited):\n                        stack.append((new_x, new_y))\n            objects.append(object_coords)\n    return objects\n\ndef get_object_extents(obj):\n    \"\"\"returns xmin, xmax, ymin, ymax\"\"\"\n    xmin = min(x for x, y in obj)\n    xmax = max(x for x, y in obj)\n    ymin = min(y for x, y in obj)\n    ymax = max(y for x, y in obj)\n    return xmin, xmax, ymin, ymax\n\ndef transform(input_grid):\n    # Initialize output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find all azure objects\n    azure_objects = find_objects(input_grid, 8)\n\n    # Prioritize Top-Right object, if it exists\n    if len(azure_objects) > 1:\n        top_right_object = None\n        for obj in azure_objects:\n            xmin, xmax, ymin, ymax = get_object_extents(obj)\n            if xmax > 5: # Check for pixels in the top-right area\n                if top_right_object == None:\n                     top_right_object = obj\n                else:\n                    #pick the object farthest to the right\n                    tr_xmin, tr_xmax, tr_ymin, tr_ymax = get_object_extents(top_right_object)\n                    if xmax > tr_xmax:\n                        top_right_object = obj\n\n        if top_right_object != None:\n            #clear all objects\n            for obj in azure_objects:\n                 for x, y in obj:\n                    output_grid[x, y] = 0  # Clear\n            azure_objects = [top_right_object] #keep only this object\n            for x, y in top_right_object:\n                output_grid[x,y] = 8\n\n\n\n    if len(azure_objects) == 1: #we have only one azure object\n        obj = azure_objects[0]\n        xmin, xmax, ymin, ymax = get_object_extents(obj)\n        width = xmax - xmin + 1\n        height = ymax - ymin + 1\n        #clear the object\n        for x, y in obj:\n             output_grid[x,y] = 0\n\n        if width > height:  # Rule for horizontal translation\n            #translate to right edge, then three units to the left\n            new_ymin = input_grid.shape[1] - width -3 #right edge\n            for x, y in obj:\n                output_grid[x, new_ymin + (y - ymin )] = 8\n        else: #single pixels\n             #shift down one row\n            for x, y in obj:\n                new_x = x+1\n                if new_x < output_grid.shape[0]:\n                    #find nearest open spot to the right\n                    for i in range(output_grid.shape[1]):\n                        if output_grid[new_x, min(y+i, output_grid.shape[1]-1)] == 0:\n                            output_grid[new_x, min(y+i, output_grid.shape[1]-1)] = 8\n                            break\n                        elif output_grid[new_x, max(y-i, 0)] == 0:\n                            output_grid[new_x, max(y-i, 0)] = 8\n                            break\n    elif len(azure_objects) > 1 : #we have only single pixels\n        #clear all objects\n        for obj in azure_objects:\n            for x, y in obj:\n                output_grid[x, y] = 0  # Clear\n\n        for obj in azure_objects: #should only be single points here\n            for x, y in obj:\n                new_x = x+1\n                if new_x < output_grid.shape[0]:\n                    #find nearest open spot to the right\n                    for i in range(output_grid.shape[1]):\n                        if output_grid[new_x, min(y+i, output_grid.shape[1]-1)] == 0:\n                            output_grid[new_x, min(y+i, output_grid.shape[1]-1)] = 8\n                            break\n                        elif output_grid[new_x, max(y-i, 0)] == 0:\n                            output_grid[new_x, max(y-i, 0)] = 8\n                            break\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4839,
    "candidates_token_count": 1532,
    "total_token_count": 6371,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 12.405123,
  "response_file": "017-response.json"
}