{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis program transforms an input grid based on the properties of a single \nnon-background colored object found within it.\n\n1.  **Identify Background and Object:** \n    Determine the background color (most common color). Find the single \n    contiguous non-background object, its color (C), height (H), and width (W).\n2.  **Initialize Output:** Copy the input grid to the output grid.\n3.  **Apply Shape-Specific Rules:**\n    *   **Vertical Line (W=1):**\n        *   If H=5: Add horizontal lines of length H and color C at the top-left \n          (row 0, cols 0 to H-1) and bottom-left (last row, cols 0 to H-1).\n        *   If H=2: Add specific horizontal (length H) and vertical (length H) \n          lines of color C at fixed/relative positions based on example 3.\n           - Horizontal: [0, 1:3], [0, 5:7], [6, 0:2], [6, 4:6]\n           - Vertical:   [1:3, 8], [5:7, 8] \n           (Assuming grid size 7x9, adjustments might be needed for other sizes)\n    *   **Rectangle (H>1, W>1):**\n        *   Add a copy of the object (color C, size HxW) to the top-right \n          corner (rows 0 to H-1, cols GridWidth-W to GridWidth-1).\n        *   Add a horizontal line of color C and length W+1 centered on the \n          bottom row (last row).\n4.  **Return:** The modified output grid.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid.\n    Uses a simple flood fill (BFS) approach.\n    \"\"\"\n    objects = []\n    visited = np.zeros(grid.shape, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                bounding_box = {\n                    'top': min_r, \n                    'left': min_c, \n                    'height': max_r - min_r + 1, \n                    'width': max_c - min_c + 1\n                }\n                objects.append({\n                    'color': color, \n                    'pixels': obj_pixels, \n                    'bounding_box': bounding_box\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on the detected object.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    grid_h, grid_w = input_np.shape\n\n    # 1. Identify Background and Object\n    colors, counts = np.unique(input_np, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n    \n    objects = find_objects(input_np, background_color)\n    \n    # Expecting exactly one non-background object based on examples\n    if not objects or len(objects) > 1:\n        # If no object or multiple objects, return copy (or handle error)\n        print(f\"Warning: Found {len(objects)} objects, expected 1. Returning copy.\")\n        return output_grid.tolist() \n        \n    obj = objects[0]\n    obj_color = obj['color']\n    bbox = obj['bounding_box']\n    H = bbox['height']\n    W = bbox['width']\n    top = bbox['top']\n    left = bbox['left']\n\n    # 3. Apply Shape-Specific Rule\n    if W == 1: # Vertical Line\n        if H == 5: # Rule from train_1\n            # Add horizontal line top-left\n            if 0 + H <= grid_w:\n                 output_grid[0, 0:H] = obj_color\n            # Add horizontal line bottom-left\n            if 0 + H <= grid_w:\n                 output_grid[grid_h - 1, 0:H] = obj_color\n                 \n        elif H == 2: # Rule from train_3 (specific to 7x9 grid?)\n             # Add shapes based on fixed/relative positions observed in example 3\n             # Check boundaries before drawing\n             # Horizontal lines (length H=2)\n             if 1 + H <= grid_w: output_grid[0, 1:1+H] = obj_color # row 0, cols 1-2\n             if 5 + H <= grid_w: output_grid[0, 5:5+H] = obj_color # row 0, cols 5-6\n             if 0 + H <= grid_w: output_grid[grid_h-1, 0:0+H] = obj_color # row 6, cols 0-1\n             if 4 + H <= grid_w: output_grid[grid_h-1, 4:4+H] = obj_color # row 6, cols 4-5\n             # Vertical lines (length H=2)\n             if 1 + H <= grid_h and grid_w > 0: output_grid[1:1+H, grid_w-1] = obj_color # col 8, rows 1-2\n             if 5 + H <= grid_h and grid_w > 0: output_grid[5:5+H, grid_w-1] = obj_color # col 8, rows 5-6\n        else:\n             # Handle other vertical line heights if necessary, or default behavior\n             print(f\"Warning: Unhandled vertical line height H={H}. Returning copy.\")\n             # pass # No specific rule defined for other heights yet\n             \n    elif H > 1 and W > 1: # Rectangle (Rule from train_2)\n        # Add copy of object at top-right\n        if 0 + H <= grid_h and grid_w - W >= 0:\n            # Ensure we only copy the object pixels, not the background within the bbox\n            # This simpler version copies the whole bbox area. Refine if needed.\n            # output_grid[0:H, grid_w-W:grid_w] = input_np[top:top+H, left:left+W] \n            # More precisely, color only the non-background pixels from the original object's bbox\n             object_slice = input_np[top:top+H, left:left+W]\n             target_slice = output_grid[0:H, grid_w-W:grid_w]\n             mask = (object_slice == obj_color)\n             target_slice[mask] = obj_color\n\n\n        # Add horizontal line of length W+1 at bottom-center\n        line_len = W + 1\n        if line_len <= grid_w:\n            start_col = (grid_w - line_len) // 2\n            output_grid[grid_h - 1, start_col : start_col + line_len] = obj_color\n            \n    # elif H == 1: # Horizontal Line (Inferred, no example)\n        # print(\"Warning: Horizontal line case not explicitly defined by examples.\")\n        # pass # Add rules here if needed based on future examples or inference\n\n    else:\n        # Handle other cases or single pixel objects if necessary\n        print(f\"Warning: Unhandled object shape H={H}, W={W}. Returning copy.\")\n        # pass \n\n    # 4. Final Output - convert back to list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4183,
    "candidates_token_count": 2108,
    "total_token_count": 6291,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.575975,
  "retries": 1
}