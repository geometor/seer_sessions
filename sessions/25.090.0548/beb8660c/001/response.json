{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Initialize an output grid with the same dimensions as the input grid, filled with the background color (white, 0).\n2.  Locate the horizontal line of azure (8) pixels in the input grid. Copy this azure line to the exact same position in the output grid. Record the row index immediately above the azure line as the starting `stack_row`. If no azure line exists, the behavior is undefined by the examples, but we might assume stacking starts from the bottom row.\n3.  Identify all distinct horizontal contiguous segments (lines) of pixels in the input grid that are *not* white (0) or azure (8). These are the \"movable objects\". For each object, record its color, its length (number of pixels), its original top row index, and its original start and end column indices.\n4.  Create a list of these identified movable objects.\n5.  Sort this list of objects based on the following criteria:\n    *   Primary key: Sort by object length in descending order (longest objects first).\n    *   Secondary key (for tie-breaking when lengths are equal): Sort by the original top row index in ascending order (objects that were originally higher in the input grid come first in case of a tie).\n6.  Iterate through the sorted list of objects:\n    *   For the current object, retrieve its color, start column index, and end column index.\n    *   Place the pixels of this object into the output grid at the current `stack_row`, spanning from its start column index to its end column index.\n    *   Decrement the `stack_row` by 1 (move up one row for the next object to be placed).\n7.  The output grid now contains the transformed arrangement. Return the output grid.\n\"\"\"\n\ndef find_movable_objects(input_grid: np.ndarray) -> List[Dict]:\n    \"\"\"\n    Finds all horizontal contiguous lines of non-background (0) and non-base (8) colors.\n\n    Args:\n        input_grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys: 'color', 'length', 'row', 'col_start', 'col_end'.\n    \"\"\"\n    objects = []\n    height, width = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if visited[r, c]:\n                continue\n\n            color = input_grid[r, c]\n            # Ignore background (0) and base (8) colors\n            if color == 0 or color == 8:\n                visited[r, c] = True\n                continue\n\n            # Found the start of a potential horizontal object\n            col_start = c\n            col_end = c\n            # Extend to the right as long as the color is the same\n            while col_end + 1 < width and input_grid[r, col_end + 1] == color and not visited[r, col_end + 1]:\n                col_end += 1\n\n            # Mark all pixels of this object as visited\n            visited[r, col_start:col_end + 1] = True\n\n            # Calculate length and store object details\n            length = col_end - col_start + 1\n            objects.append({\n                'color': color,\n                'length': length,\n                'row': r,\n                'col_start': col_start,\n                'col_end': col_end\n            })\n\n    return objects\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rearranges horizontal colored lines (objects) above a fixed azure (8) base line.\n    Objects are sorted primarily by length (descending) and secondarily by original\n    row position (ascending - topmost first) before being stacked vertically\n    above the base line, maintaining their original horizontal positions.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # Find the azure base line (color 8)\n    azure_row = -1\n    for r in range(height - 1, -1, -1):\n        if np.all(input_np[r, :] == 8):\n             azure_row = r\n             # Copy the azure line to the output\n             output_grid[azure_row, :] = 8\n             break\n        # Optimization: if we see a mix of 8 and non-8, it's not the full base line\n        elif 8 in input_np[r,:]:\n            # Handle cases where 8 might be part of movable objects or partial lines\n            # Check if the entire row is azure\n             is_full_azure_row = True\n             azure_indices = []\n             for c_idx, val in enumerate(input_np[r,:]):\n                 if val == 8:\n                     azure_indices.append(c_idx)\n                 else:\n                     is_full_azure_row = False\n                     # break # No need to break if we need indices later\n\n             if is_full_azure_row:\n                 azure_row = r\n                 output_grid[azure_row, :] = 8\n                 break\n             # else: # if not a full row, treat the azure segments as potentially movable\n             # This part is tricky based on provided examples. The examples only show\n             # full azure base lines. Assuming the task implies a single, full-width\n             # base line at the bottom if present. Let's find the *last* row containing any 8.\n             if azure_row == -1 and len(azure_indices) > 0:\n                 # Check if *all* 8s are in this bottom-most row containing 8s\n                 all_8s_in_input = np.argwhere(input_np == 8)\n                 max_row_with_8 = np.max(all_8s_in_input[:, 0]) if len(all_8s_in_input) > 0 else -1\n\n                 if r == max_row_with_8 and is_full_azure_row: # It must be a full line at the bottom-most position of any 8\n                     azure_row = r\n                     output_grid[azure_row, :] = 8\n                     break\n                 # If not a full row or not the bottom-most row with 8s, treat 8s as movable unless\n                 # specified otherwise. The current implementation of find_movable_objects\n                 # excludes 8, aligning with the examples.\n\n    # Determine the starting row for stacking objects\n    # If an azure line was found, stack above it. Otherwise, stack from the bottom.\n    stack_row = azure_row - 1 if azure_row != -1 else height - 1\n\n    # Find all movable objects (horizontal lines not 0 or 8)\n    movable_objects = find_movable_objects(input_np)\n\n    # Sort the objects:\n    # 1. By length (descending)\n    # 2. By original row index (ascending - topmost first)\n    sorted_objects = sorted(movable_objects, key=lambda obj: (-obj['length'], obj['row']))\n\n    # Place the sorted objects onto the output grid\n    for obj in sorted_objects:\n        if stack_row < 0:\n            # Should not happen if grid dimensions are sufficient, but safety check\n            print(f\"Warning: Not enough space to stack object: {obj}\")\n            continue\n\n        # Place the object in the current stack_row at its original horizontal position\n        output_grid[stack_row, obj['col_start']:obj['col_end'] + 1] = obj['color']\n\n        # Move the stack_row up for the next object\n        stack_row -= 1\n\n    # Convert back to list of lists format for the expected output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3053,
    "candidates_token_count": 1905,
    "total_token_count": 4958,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.617118,
  "retries": 1
}