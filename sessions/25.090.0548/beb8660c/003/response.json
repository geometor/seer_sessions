{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Create a new output grid with the same dimensions as the input grid, filled entirely with the background color (white, 0).\n2.  Search the input grid, starting from the bottom row and moving upwards, to find the first row composed entirely of azure (8) pixels. If found, copy this azure line to the exact same row in the output grid and record its row index as `base_row`. If no such line is found, set `base_row` to be the total height of the grid (effectively placing the base just below the last row).\n3.  Identify all distinct horizontal, contiguous lines of pixels in the input grid that are *not* white (0) and *not* azure (8). For each such line (object), record its color, its length (number of pixels), and its original row index in the input grid.\n4.  Create a list of these identified objects.\n5.  Sort this list of objects based on two criteria:\n    *   Primary criterion: Sort by object length in descending order (longest objects first).\n    *   Secondary criterion (for ties in length): Sort by the original row index in ascending order (objects that were originally higher in the input grid come first).\n6.  Determine the width of the grid.\n7.  Initialize a `current_stack_row` variable to `base_row - 1`.\n8.  Iterate through the sorted list of objects:\n    *   For the current object, retrieve its color and length.\n    *   Calculate the starting column for placing the object in the output grid: `start_column = grid_width - object_length`.\n    *   Place the object's color into the output grid at the `current_stack_row`, filling the cells from `start_column` up to the last column (inclusive).\n    *   Decrement the `current_stack_row` by 1 (to move up one row for the next object).\n9.  Return the completed output grid.\n\"\"\"\n\ndef find_movable_objects(input_grid: np.ndarray) -> List[Dict]:\n    \"\"\"\n    Finds all horizontal contiguous lines of non-background (0) and non-base (8) colors.\n\n    Args:\n        input_grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys: 'color', 'length', 'row', 'col_start', 'col_end'.\n    \"\"\"\n    objects = []\n    height, width = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if visited[r, c]:\n                continue\n\n            color = input_grid[r, c]\n            # Ignore background (0) and base (8) colors\n            if color == 0 or color == 8:\n                visited[r, c] = True\n                continue\n\n            # Found the start of a potential horizontal object\n            col_start = c\n            col_end = c\n            # Extend to the right as long as the color is the same in the same row\n            while col_end + 1 < width and input_grid[r, col_end + 1] == color and not visited[r, col_end + 1]:\n                col_end += 1\n\n            # Mark all pixels of this object as visited\n            visited[r, col_start:col_end + 1] = True\n\n            # Calculate length and store object details\n            length = col_end - col_start + 1\n            objects.append({\n                'color': int(color),\n                'length': int(length),\n                'row': int(r),\n                'col_start': int(col_start), # Store original columns for potential future use, though not used for placement here\n                'col_end': int(col_end)\n            })\n\n    return objects\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # 2. Find the azure base line (color 8) and copy it\n    base_row = -1\n    for r in range(height - 1, -1, -1):\n        is_azure_line = True\n        has_azure = False\n        for c in range(width):\n            if input_np[r, c] != 8:\n                is_azure_line = False\n            else:\n                has_azure = True\n        # The base must be a full row of 8s\n        if is_azure_line and has_azure:\n            base_row = r\n            output_grid[base_row, :] = 8\n            break\n        # If we encounter non-8s in a row after seeing 8s lower down,\n        # it confirms the lower rows weren't the base.\n        # If we hit the top without finding a full line, base_row remains -1.\n\n    # 3. Identify all movable objects (horizontal lines not 0 or 8)\n    movable_objects = find_movable_objects(input_np)\n\n    # 5. Sort the objects:\n    #    - Primary: length (descending)\n    #    - Secondary: original row (ascending)\n    sorted_objects = sorted(movable_objects, key=lambda obj: (-obj['length'], obj['row']))\n\n    # 7. Initialize the starting row for stacking\n    # If a base was found, stack above it. Otherwise, stack from the bottom edge.\n    stack_row = base_row - 1 if base_row != -1 else height - 1\n\n    # 8. Iterate through sorted objects and place them right-aligned in the output grid\n    for obj in sorted_objects:\n        if stack_row < 0:\n            # Grid is full, cannot place more objects (edge case)\n            print(f\"Warning: Not enough space to stack object: {obj}\")\n            continue\n\n        # Retrieve object properties\n        color = obj['color']\n        length = obj['length']\n\n        # Calculate target columns for right-alignment\n        target_col_start = width - length\n        target_col_end = width - 1 # Inclusive index for numpy slicing\n\n        # Place the object\n        if target_col_start >= 0: # Ensure start column is valid\n             output_grid[stack_row, target_col_start : target_col_end + 1] = color\n\n        # Decrement stack_row for the next object\n        stack_row -= 1\n\n    # 9. Return the completed output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12887,
    "candidates_token_count": 1610,
    "total_token_count": 14497,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.938257,
  "retries": 1
}