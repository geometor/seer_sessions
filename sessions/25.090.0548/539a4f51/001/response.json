{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Create an output grid twice the height and width of the input.\n2. Copy the input grid to the top-left (TL) quadrant of the output.\n3. Determine a 'characteristic color' for each input row (R_i) and column (C_j):\n   - It's the most frequent non-white color.\n   - Ties are broken by the color appearing earliest (topmost for columns, leftmost for rows).\n   - If a row/column is all white (all zeros), its characteristic color defaults to the characteristic color of the first row (for rows) or the first column (for columns). It's assumed the first row and first column are never all white.\n4. Fill the top-right (TR) quadrant: Each column j is filled entirely with the characteristic color C_j.\n5. Fill the bottom-left (BL) quadrant: Each row i is filled entirely with the characteristic color R_i.\n6. Fill the bottom-right (BR) quadrant: For a cell at relative coordinates (i, j) within this quadrant, set its color to R_i if i >= j, otherwise set it to C_j.\n\"\"\"\n\ndef _get_characteristic_color(line):\n    \"\"\"\n    Helper function to find the characteristic color of a single row or column (passed as a 1D numpy array or list).\n    \n    Args:\n        line: A list or 1D numpy array representing a row or column.\n\n    Returns:\n        The characteristic color (int) based on frequency and tie-breaking rules,\n        or None if the line contains only white (0) pixels.\n    \"\"\"\n    # Filter out white pixels (value 0)\n    non_white_pixels = [p for p in line if p != 0]\n\n    # If no non-white pixels, return None\n    if not non_white_pixels:\n        return None\n\n    # Count frequencies of non-white colors\n    counts = Counter(non_white_pixels)\n    \n    # Find the maximum frequency\n    max_freq = 0\n    # Iterate through unique non-white colors found\n    for color in counts:\n         if counts[color] > max_freq:\n             max_freq = counts[color]\n\n    # Find all colors that have the maximum frequency\n    candidates = [color for color, freq in counts.items() if freq == max_freq]\n\n    # If only one color has the max frequency, return it\n    if len(candidates) == 1:\n        return candidates[0]\n    else:\n        # Tie-breaking: find the first occurrence in the original line\n        # Store the index of the first time we see each candidate color\n        first_occurrence_index = {}\n        for idx, pixel in enumerate(line):\n             # Check if the pixel is one of the tied candidates\n             # and if we haven't recorded its first occurrence yet\n             if pixel in candidates and pixel not in first_occurrence_index:\n                 first_occurrence_index[pixel] = idx\n        \n        # Find the candidate color with the minimum first occurrence index\n        best_candidate = -1 # Placeholder, should be overwritten\n        min_idx = float('inf')\n        for color in candidates:\n            idx = first_occurrence_index[color]\n            if idx < min_idx:\n                 min_idx = idx\n                 best_candidate = color\n        return best_candidate\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape # Get height and width\n\n    # Initialize the output grid with zeros, twice the dimensions\n    output_grid = np.zeros((2 * H, 2 * W), dtype=int)\n\n    # Step 1: Copy input grid to the Top-Left quadrant\n    output_grid[0:H, 0:W] = input_np\n\n    # Step 2: Calculate characteristic row colors (R)\n    R = [0] * H # Initialize list to store characteristic colors for rows\n    \n    # Calculate characteristic color for the first row (R[0])\n    # This is needed as the default for any subsequent all-white rows.\n    # Assumption: The first row is guaranteed to have non-white pixels.\n    R[0] = _get_characteristic_color(input_np[0, :])\n    if R[0] is None:\n        # This case should ideally not happen based on problem constraints/examples.\n        # If it did, the definition of the default rule is ambiguous.\n        # For now, raise an error, or potentially default to 0.\n         raise ValueError(\"First row cannot be all white based on task description interpretation.\")\n\n    # Calculate characteristic colors for the remaining rows\n    for i in range(1, H):\n        row_color = _get_characteristic_color(input_np[i, :])\n        # If the row is all white, use the default (R[0])\n        if row_color is None:\n            R[i] = R[0]\n        else:\n            R[i] = row_color\n\n    # Step 3: Calculate characteristic column colors (C)\n    C = [0] * W # Initialize list for column colors\n    \n    # Calculate for the first column (C[0]) - needed as default\n    # Assumption: The first column is guaranteed to have non-white pixels.\n    C[0] = _get_characteristic_color(input_np[:, 0])\n    if C[0] is None:\n         raise ValueError(\"First column cannot be all white based on task description interpretation.\")\n\n    # Calculate for the remaining columns\n    for j in range(1, W):\n        col_color = _get_characteristic_color(input_np[:, j])\n        # If the column is all white, use the default (C[0])\n        if col_color is None:\n            C[j] = C[0]\n        else:\n            C[j] = col_color\n\n    # Step 4: Fill Top-Right quadrant\n    # Each column j in the TR quadrant is filled with C[j]\n    for j in range(W):\n        output_grid[0:H, W + j] = C[j]\n\n    # Step 5: Fill Bottom-Left quadrant\n    # Each row i in the BL quadrant is filled with R[i]\n    for i in range(H):\n        output_grid[H + i, 0:W] = R[i]\n\n    # Step 6: Fill Bottom-Right quadrant\n    # Color depends on relative row/column index (i, j) within the quadrant\n    for i in range(H): # Relative row index within BR quadrant\n        for j in range(W): # Relative column index within BR quadrant\n            # Calculate actual indices in the full output grid\n            output_row = H + i\n            output_col = W + j\n            # Apply the comparison rule\n            if i >= j:\n                output_grid[output_row, output_col] = R[i]\n            else:\n                output_grid[output_row, output_col] = C[j]\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3633,
    "candidates_token_count": 1733,
    "total_token_count": 5366,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.280976,
  "retries": 1
}