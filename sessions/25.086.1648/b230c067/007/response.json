{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid containing white (0) and azure (8) pixels into an output grid of the same dimensions.\n\n1.  Initialize an output grid with the same dimensions as the input grid, filled entirely with white (0).\n2.  Identify all distinct connected objects composed of azure (8) pixels in the input grid. Use 8-way connectivity (including diagonals). If no azure objects are found, return the initial white output grid.\n3.  Precompute the set of all white (0) pixels that are connected to the grid border (exterior white pixels).\n4.  For each identified azure object, determine its properties:\n    *   The set of pixel coordinates `(row, col)` belonging to the object.\n    *   The bounding box containing the object: `(min_row, min_col, max_row, max_col)`.\n    *   Whether the object contains or borders an internal \"hole\" (a contiguous area of white pixels not connected to the grid exterior). This is checked by seeing if any pixel of the object is adjacent (8-way) to a white pixel that is *not* part of the precomputed exterior white pixels.\n5.  Count the total number of azure objects that possess a hole (`hole_count`).\n6.  Determine which objects (if any) will be colored red (2) and blue (1) based on `hole_count`:\n    *   **If `hole_count` is exactly 1:**\n        *   Designate the single object *with* the hole to be colored blue (1).\n        *   Among the objects *without* holes, identify the \"top-right-most\" one. Designate this object to be colored red (2). (The \"top-right-most\" object is the one with the minimum `min_row`; if there's a tie, it's the one among the tied objects with the maximum `max_col`).\n        *   Designate all *other* objects (those without holes that were not chosen to be red) to be colored blue (1).\n    *   **If `hole_count` is 0:**\n        *   Among *all* azure objects, identify the \"top-right-most\" one (using the same definition as above). Designate this object to be colored red (2).\n        *   Designate all *other* azure objects to be colored blue (1).\n    *   **If `hole_count` is greater than 1:**\n        *   No objects are designated to be colored red or blue. The output grid remains white.\n7.  Populate the output grid: For every pixel `(r, c)` belonging to an object designated red, set `output_grid[r, c]` to 2. For every pixel `(r, c)` belonging to an object designated blue, set `output_grid[r, c]` to 1.\n8.  Return the final output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\" Helper to get valid neighbors for a pixel. \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if connectivity == 4 and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_connected_components(grid, target_color, connectivity=8):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n    Uses BFS and specified connectivity (4 or 8).\n    Returns a list of sets, where each set contains (row, col) tuples for an object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new component\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_pixels.add((curr_r, curr_c))\n\n                    for nr, nc in _get_neighbors(curr_r, curr_c, height, width, connectivity):\n                        if grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if current_object_pixels:\n                     objects.append(current_object_pixels)\n\n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not obj_pixels:\n        return None, None, None, None # Return None for each value\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_exterior_white_pixels(grid):\n    \"\"\" Finds all white (0) pixels connected to the grid border using BFS. \"\"\"\n    height, width = grid.shape\n    exterior_white = set()\n    q = deque()\n    visited_white = set() # Keep track of visited white pixels to avoid cycles/redundancy\n\n    # Add all border white pixels to the queue and visited set\n    for r in range(height):\n        for c in [0, width - 1] if width > 0 else []: # Check left/right borders\n             if grid[r, c] == 0 and (r,c) not in visited_white:\n                 q.append((r, c))\n                 visited_white.add((r,c))\n                 exterior_white.add((r,c))\n                 \n    for c in range(width):\n        for r in [0, height-1] if height > 0 else []: # Check top/bottom borders\n            # Avoid adding corners twice\n             if grid[r, c] == 0 and (r,c) not in visited_white:\n                 q.append((r, c))\n                 visited_white.add((r,c))\n                 exterior_white.add((r,c))\n\n    # Perform BFS from border white pixels\n    while q:\n        curr_r, curr_c = q.popleft()\n        \n        # Use 8-way connectivity for checking adjacent white pixels\n        for nr, nc in _get_neighbors(curr_r, curr_c, height, width, connectivity=8):\n            if grid[nr, nc] == 0 and (nr, nc) not in visited_white:\n                 visited_white.add((nr, nc))\n                 exterior_white.add((nr, nc))\n                 q.append((nr, nc))\n\n    return exterior_white\n\ndef check_for_hole(obj_pixels, grid, exterior_white_pixels):\n    \"\"\"\n    Checks if an object is adjacent to any white pixel not connected to the exterior.\n    \"\"\"\n    height, width = grid.shape\n    for r, c in obj_pixels:\n        # Check 8 neighbors\n        for nr, nc in _get_neighbors(r, c, height, width, connectivity=8):\n            # If neighbor is white AND it's NOT an exterior white pixel\n            if grid[nr, nc] == 0 and (nr, nc) not in exterior_white_pixels:\n                return True # Found a hole pixel adjacent to the object\n    return False # No adjacent hole pixels found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying azure objects, checking for holes,\n    and applying coloring rules based on hole count and object position.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # Step 1: Initialize output_grid with the same dimensions, filled with white (0)\n    output_grid = np.zeros_like(input_grid_np)\n\n    # Step 2: Identify all azure (8) objects using 8-way connectivity\n    azure_objects_pixels = find_connected_components(input_grid_np, 8, connectivity=8)\n\n    # If no azure objects found, return the white grid\n    if not azure_objects_pixels:\n        return output_grid.tolist() \n\n    # Step 3: Precompute exterior white pixels\n    exterior_white = find_exterior_white_pixels(input_grid_np)\n\n    # Step 4: Analyze objects: calculate properties\n    objects_data = []\n    for obj_pixels in azure_objects_pixels:\n        if not obj_pixels: continue # Skip if somehow an empty object was found\n        min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n        # Check if min_r is None, indicating an empty object set passed checks\n        if min_r is None: continue \n        \n        has_hole_flag = check_for_hole(obj_pixels, input_grid_np, exterior_white)\n        \n        objects_data.append({\n            \"pixels\": obj_pixels,\n            \"min_row\": min_r, # Top edge row index\n            \"max_col\": max_c, # Right edge column index\n            \"has_hole\": has_hole_flag\n        })\n\n    # Step 5: Count objects with holes\n    hole_objects = [obj for obj in objects_data if obj[\"has_hole\"]]\n    non_hole_objects = [obj for obj in objects_data if not obj[\"has_hole\"]]\n    hole_count = len(hole_objects)\n\n    # Initialize variables to store which objects get which color\n    red_object_data = None\n    blue_objects_data = []\n\n    # Step 6: Apply coloring logic based on hole count\n    if hole_count == 1:\n        # Case: Exactly one object has a hole\n        # Rule 6.a.i: The object with the hole becomes blue\n        blue_objects_data.append(hole_objects[0]) \n        \n        # Rule 6.a.ii: Find top-right-most among non-hole objects to become red\n        if non_hole_objects:\n            # Find the minimum 'min_row' among non-hole objects\n            min_row_non_hole = min(obj[\"min_row\"] for obj in non_hole_objects)\n            # Filter to get all non-hole objects at that top-most row\n            top_non_hole = [obj for obj in non_hole_objects if obj[\"min_row\"] == min_row_non_hole]\n            \n            # Among those top-most objects, find the one with the maximum 'max_col' (right-most)\n            max_col_top_non_hole = max(obj[\"max_col\"] for obj in top_non_hole)\n            # Select the first object that matches both criteria\n            red_object_data = next((obj for obj in top_non_hole if obj[\"max_col\"] == max_col_top_non_hole), None)\n\n            # Rule 6.a.iii: All other non-hole objects become blue\n            blue_objects_data.extend([obj for obj in non_hole_objects if obj != red_object_data])\n        # If there were no non-hole objects, red_object_data remains None, and only the hole object is blue\n\n    elif hole_count == 0:\n        # Case: No objects have holes\n        # Rule 6.b.i: Find top-right-most among *all* objects to become red\n        if objects_data: # Check if there are any objects at all\n            # Find the minimum 'min_row' among all objects\n            min_row_all = min(obj[\"min_row\"] for obj in objects_data)\n            # Filter to get all objects at that top-most row\n            top_all = [obj for obj in objects_data if obj[\"min_row\"] == min_row_all]\n            \n            # Among those top-most objects, find the one with the maximum 'max_col' (right-most)\n            max_col_top_all = max(obj[\"max_col\"] for obj in top_all)\n            # Select the first object matching both criteria\n            red_object_data = next((obj for obj in top_all if obj[\"max_col\"] == max_col_top_all), None)\n\n            # Rule 6.b.ii: All other objects become blue\n            blue_objects_data.extend([obj for obj in objects_data if obj != red_object_data])\n            \n    # Step 6.c: If hole_count > 1, red_object_data remains None and blue_objects_data remains empty. \n    # The output grid will remain white as initialized.\n\n    # Step 7: Populate the output grid based on determined colors\n    # Color the designated red object (if one was found) with red (2)\n    if red_object_data:\n        for r, c in red_object_data[\"pixels\"]:\n             # Basic boundary check (though coordinates should be valid)\n             if 0 <= r < height and 0 <= c < width:\n                 output_grid[r, c] = 2 # Red color\n\n    # Color the designated blue objects (if any were found) with blue (1)\n    for blue_obj_data in blue_objects_data:\n        for r, c in blue_obj_data[\"pixels\"]:\n             # Basic boundary check\n             if 0 <= r < height and 0 <= c < width:\n                 # Check if the pixel is still white (0) before coloring it blue.\n                 # This prevents overwriting a red pixel if an object somehow got designated both \n                 # (should not happen with current logic, but adds robustness).\n                 if output_grid[r, c] == 0: \n                     output_grid[r, c] = 1 # Blue color\n\n    # Step 8: Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6796,
    "candidates_token_count": 3351,
    "total_token_count": 10147,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.750862,
  "retries": null
}