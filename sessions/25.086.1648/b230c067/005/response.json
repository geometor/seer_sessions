{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid containing white (0) and azure (8) pixels into an output grid of the same dimensions.\n\n1.  Initialize an output grid with the same dimensions as the input grid, filled entirely with white (0).\n2.  Identify all distinct connected objects composed of azure (8) pixels in the input grid. Use 8-way connectivity (including diagonals). If no azure objects are found, return the initial white output grid.\n3.  For each identified azure object, determine its properties:\n    *   The set of pixel coordinates `(row, col)` belonging to the object.\n    *   The bounding box containing the object: `(min_row, min_col, max_row, max_col)`.\n    *   Whether the object contains an internal \"hole\" (a contiguous area of white pixels fully enclosed by the object and not connected to the grid exterior relative to the object's boundary).\n4.  Count the total number of azure objects that possess a hole (`hole_count`).\n5.  Determine which objects (if any) will be colored red (2) and blue (1) based on `hole_count`:\n    *   **If `hole_count` is exactly 1:**\n        *   Designate the single object *with* the hole to be colored blue (1).\n        *   Among the objects *without* holes, identify the \"top-right-most\" one. Designate this object to be colored red (2). (The \"top-right-most\" object is the one with the minimum `min_row`; if there's a tie, it's the one among the tied objects with the maximum `max_col`).\n        *   Designate all *other* objects (those without holes that were not chosen to be red) to be colored blue (1).\n    *   **If `hole_count` is 0:**\n        *   Among *all* azure objects, identify the \"top-right-most\" one (using the same definition as above). Designate this object to be colored red (2).\n        *   Designate all *other* azure objects to be colored blue (1).\n    *   **If `hole_count` is greater than 1:**\n        *   No objects are designated to be colored red or blue. The output grid remains white.\n6.  Populate the output grid: For every pixel `(r, c)` belonging to an object designated red, set `output_grid[r, c]` to 2. For every pixel `(r, c)` belonging to an object designated blue, set `output_grid[r, c]` to 1.\n7.  Return the final output grid.\n\"\"\"\n\nimport numpy as np\ntry:\n    # Use scipy.ndimage for connected components analysis\n    from scipy import ndimage\nexcept ImportError:\n    print(\"Error: scipy library is required. Please install it.\")\n    # Define dummy functions or raise an error if scipy is unavailable\n    # For this exercise, we assume scipy is installed. If not, the program will fail later.\n    ndimage = None \n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n    Uses 8-connectivity (including diagonals).\n    Returns a list of sets, where each set contains (row, col) tuples for an object.\n    \"\"\"\n    if ndimage is None:\n        raise ImportError(\"scipy.ndimage is required but not available.\")\n        \n    binary_grid = (grid == color)\n    # Define 8-connectivity structure\n    structure = np.array([[1, 1, 1], \n                          [1, 1, 1], \n                          [1, 1, 1]], dtype=bool)\n                          \n    # Label connected components\n    labeled_grid, num_labels = ndimage.label(binary_grid, structure=structure)\n    \n    objects = []\n    if num_labels > 0:\n        # Extract coordinates for each label\n        for i in range(1, num_labels + 1):\n            # Find where the labeled grid equals the current label index\n            coords = np.argwhere(labeled_grid == i)\n            # Convert coords from [[r1, c1], [r2, c2], ...] to set of {(r1, c1), (r2, c2), ...}\n            obj_pixels = set(tuple(coord) for coord in coords)\n            if obj_pixels: # Ensure the component has pixels\n                 objects.append(obj_pixels) \n            \n    return objects\n\ndef get_bounding_box(obj_pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not obj_pixels:\n        return None\n    rows = [r for r, c in obj_pixels]\n    cols = [c for r, c in obj_pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef has_hole(obj_pixels, grid_shape):\n    \"\"\"\n    Checks if an object, defined by its pixels, encloses a hole of background (0).\n    Uses background labeling within a padded bounding box.\n    \"\"\"\n    if not obj_pixels or ndimage is None:\n        return False\n\n    min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n    height, width = grid_shape\n\n    # Define the padded bounding box coordinates, clamped to grid boundaries\n    pad_min_r = max(0, min_r - 1)\n    pad_min_c = max(0, min_c - 1)\n    pad_max_r = min(height - 1, max_r + 1)\n    pad_max_c = min(width - 1, max_c + 1)\n\n    # Create a boolean subgrid representing the padded bounding box area\n    # True indicates background (0) or outside the original grid, False indicates object (8) pixel\n    subgrid_height = pad_max_r - pad_min_r + 1\n    subgrid_width = pad_max_c - pad_min_c + 1\n    # Initially assume all is background (True)\n    background_mask = np.ones((subgrid_height, subgrid_width), dtype=bool)\n\n    # Mark object pixels as False within the subgrid\n    for r_obj, c_obj in obj_pixels:\n        # Map object coordinates to subgrid coordinates\n        sr, sc = r_obj - pad_min_r, c_obj - pad_min_c\n        # Check if the pixel falls within the subgrid dimensions before indexing\n        if 0 <= sr < subgrid_height and 0 <= sc < subgrid_width:\n             background_mask[sr, sc] = False\n\n    # Label connected components of the background (True values) in the subgrid\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool) # 8-connectivity\n    labeled_background, num_labels = ndimage.label(background_mask, structure=structure)\n\n    if num_labels <= 1:\n        # If there's 0 or 1 background component, no enclosed hole is possible\n        return False\n\n    # Identify the background component connected to the border of the subgrid (the \"outside\")\n    outer_label = 0 # 0 means not connected to any labeled background component\n    border_indices = set()\n    # Collect indices along the border of the subgrid\n    if subgrid_height > 0:\n        border_indices.update((0, c) for c in range(subgrid_width)) # Top\n        border_indices.update((subgrid_height - 1, c) for c in range(subgrid_width)) # Bottom\n    if subgrid_width > 0:\n        border_indices.update((r, 0) for r in range(subgrid_height)) # Left\n        border_indices.update((r, subgrid_width - 1) for r in range(subgrid_height)) # Right\n\n    for r_sub, c_sub in border_indices:\n        # Check bounds again just in case shape is 1xN or Nx1 etc.\n        if 0 <= r_sub < subgrid_height and 0 <= c_sub < subgrid_width:\n            label_val = labeled_background[r_sub, c_sub]\n            if label_val > 0: # If it's part of a labeled background component\n                outer_label = label_val\n                break # Found the label connected to the outside, no need to check further\n\n    # If outer_label is still 0 after checking the border, it means either:\n    # 1. The object completely filled the padded box (no background at all - num_labels would be 0, handled above).\n    # 2. The object formed a perfect frame touching the padded box border everywhere, enclosing background.\n    #    In this case, any labeled background component (num_labels > 0) must be a hole.\n    # 3. The background is fragmented, and none touches the border (e.g. checkerboard within the object).\n    # Let's check if any background component exists that is NOT the outer label.\n    has_internal_component = False\n    for i in range(1, num_labels + 1):\n        if i != outer_label:\n            # Found a component not connected to the outside. We consider this a hole.\n            # We could add an extra check here to ensure this component has at least one pixel\n            # *strictly inside* the original object's bounding box (not just in the padding area),\n            # but the current logic implies that if it's separated from the outer border by the object,\n            # it must be enclosed.\n            has_internal_component = True\n            break\n\n    return has_internal_component\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying azure objects, checking for holes,\n    and applying coloring rules based on hole count and object position.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # Step 1: Initialize output_grid with the same dimensions, filled with white (0)\n    output_grid = np.zeros_like(input_grid_np)\n    grid_shape = input_grid_np.shape\n\n    # Step 2: Identify all azure (8) objects\n    azure_objects_pixels = find_connected_components(input_grid_np, 8)\n\n    # If no azure objects found, return the white grid\n    if not azure_objects_pixels:\n        return output_grid.tolist() \n\n    # Step 3: Analyze objects: calculate properties\n    objects_data = []\n    for obj_pixels in azure_objects_pixels:\n        if not obj_pixels: continue # Skip if somehow an empty object was found\n        min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n        hole = has_hole(obj_pixels, grid_shape)\n        objects_data.append({\n            \"pixels\": obj_pixels,\n            \"min_row\": min_r, # Top edge row index\n            \"max_col\": max_c, # Right edge column index\n            \"has_hole\": hole\n        })\n\n    # Step 4: Count objects with holes\n    hole_objects = [obj for obj in objects_data if obj[\"has_hole\"]]\n    non_hole_objects = [obj for obj in objects_data if not obj[\"has_hole\"]]\n    hole_count = len(hole_objects)\n\n    # Initialize variables to store which objects get which color\n    red_object_data = None\n    blue_objects_data = []\n\n    # Step 5: Apply coloring logic based on hole count\n    if hole_count == 1:\n        # Case: Exactly one object has a hole\n        # Rule 5.a.i: The object with the hole becomes blue\n        blue_objects_data.append(hole_objects[0]) \n        \n        # Rule 5.a.ii: Find top-right-most among non-hole objects to become red\n        if non_hole_objects:\n            # Find the minimum 'min_row' among non-hole objects\n            min_row_non_hole = min(obj[\"min_row\"] for obj in non_hole_objects)\n            # Filter to get all non-hole objects at that top-most row\n            top_non_hole = [obj for obj in non_hole_objects if obj[\"min_row\"] == min_row_non_hole]\n            \n            # Among those top-most objects, find the one with the maximum 'max_col' (right-most)\n            max_col_top_non_hole = max(obj[\"max_col\"] for obj in top_non_hole)\n            # Select the first object that matches both criteria (should be unique based on logic)\n            red_object_data = next((obj for obj in top_non_hole if obj[\"max_col\"] == max_col_top_non_hole), None)\n\n            # Rule 5.a.iii: All other non-hole objects become blue\n            blue_objects_data.extend([obj for obj in non_hole_objects if obj != red_object_data])\n        # If there were no non-hole objects, red_object_data remains None, and only the hole object is blue\n\n    elif hole_count == 0:\n        # Case: No objects have holes\n        # Rule 5.b.i: Find top-right-most among *all* objects to become red\n        if objects_data: # Check if there are any objects at all\n            # Find the minimum 'min_row' among all objects\n            min_row_all = min(obj[\"min_row\"] for obj in objects_data)\n            # Filter to get all objects at that top-most row\n            top_all = [obj for obj in objects_data if obj[\"min_row\"] == min_row_all]\n            \n            # Among those top-most objects, find the one with the maximum 'max_col' (right-most)\n            max_col_top_all = max(obj[\"max_col\"] for obj in top_all)\n            # Select the first object matching both criteria\n            red_object_data = next((obj for obj in top_all if obj[\"max_col\"] == max_col_top_all), None)\n\n            # Rule 5.b.ii: All other objects become blue\n            blue_objects_data.extend([obj for obj in objects_data if obj != red_object_data])\n            \n    # Step 5.c: If hole_count > 1, red_object_data remains None and blue_objects_data remains empty. \n    # The output grid will remain white as initialized.\n\n    # Step 6: Populate the output grid based on determined colors\n    # Color the designated red object (if one was found)\n    if red_object_data:\n        for r, c in red_object_data[\"pixels\"]:\n            # Basic boundary check (though coordinates should be valid)\n            if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                output_grid[r, c] = 2 # Red color\n\n    # Color the designated blue objects (if any were found)\n    for blue_obj_data in blue_objects_data:\n        for r, c in blue_obj_data[\"pixels\"]:\n             # Basic boundary check\n             if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                 # Important: Check if the pixel is still white (0) before coloring it blue.\n                 # This prevents overwriting a red pixel if an object somehow got designated both \n                 # (should not happen with current logic, but adds robustness).\n                 if output_grid[r, c] == 0: \n                     output_grid[r, c] = 1 # Blue color\n\n    # Step 7: Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6946,
    "candidates_token_count": 3738,
    "total_token_count": 10684,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.174746,
  "retries": null
}