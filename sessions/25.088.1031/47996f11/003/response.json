{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by replacing each magenta pixel (6) with the \ncolor of its nearest non-magenta neighbor. \nDistance is measured using Manhattan distance (|row1 - row2| + |col1 - col2|).\nIf multiple non-magenta neighbors are equidistant, a tie-breaking rule based \non direction relative to the magenta pixel is applied: Up is preferred, \nthen Left, then Down, then Right. \nIf there's still a tie (e.g., only equidistant diagonal neighbors), \nthe one with the smallest row index is chosen, and finally the one with the \nsmallest column index.\nNon-magenta pixels remain unchanged in the output grid.\n\nThis implementation uses Breadth-First Search (BFS) for efficient neighbor finding.\n\"\"\"\n\ndef get_sort_key(coord, center_r, center_c):\n    \"\"\"\n    Generates a sort key for a candidate coordinate based on its position \n    relative to a center point (the magenta pixel) for tie-breaking.\n    \n    The key prioritizes directions: Up (0), Left (1), Down (2), Right (3).\n    Other relative positions (like diagonals) get a lower priority (4).\n    Secondary sorting uses row index, and tertiary sorting uses column index.\n    \n    Args:\n        coord (tuple): The (row, column) of the candidate neighbor.\n        center_r (int): The row index of the center pixel (magenta).\n        center_c (int): The column index of the center pixel (magenta).\n\n    Returns:\n        tuple: A sort key (priority, row, column).\n    \"\"\"\n    nr, nc = coord\n    r, c = center_r, center_c\n    \n    # Calculate relative position\n    dr = nr - r\n    dc = nc - c\n\n    # Assign priority based on cardinal direction relative to center\n    if dr < 0 and dc == 0: priority = 0  # Directly Up\n    elif dr == 0 and dc < 0: priority = 1  # Directly Left\n    elif dr > 0 and dc == 0: priority = 2  # Directly Down\n    elif dr == 0 and dc > 0: priority = 3  # Directly Right\n    else: priority = 4 # Others (diagonal or non-cardinal aligned)\n\n    # Return tuple for sorting: (priority, absolute_row, absolute_col)\n    return (priority, nr, nc)\n\ndef find_closest_non_magenta_bfs(grid, start_r, start_c):\n    \"\"\"\n    Finds the color of the nearest non-magenta pixel to (start_r, start_c)\n    using Breadth-First Search (BFS) and the specified tie-breaking rules.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): The row index of the magenta pixel.\n        start_c (int): The column index of the magenta pixel.\n\n    Returns:\n        int: The color value of the selected nearest non-magenta neighbor.\n             Returns the original magenta color (6) if no non-magenta neighbor is found.\n    \"\"\"\n    rows, cols = grid.shape\n    # Queue stores tuples: (row, col, distance)\n    queue = deque([(start_r, start_c, 0)]) \n    # Visited set stores tuples: (row, col) to prevent cycles and redundant work\n    visited = set([(start_r, start_c)])\n    \n    min_dist_found = float('inf')\n    # Candidates stores tuples: (row, col) of non-magenta pixels found at min_dist_found\n    candidates = [] \n\n    # --- BFS Execution ---\n    while queue:\n        r, c, dist = queue.popleft()\n\n        # Pruning Optimization: If the current path's distance already exceeds the best distance found, \n        # we don't need to explore further from here or process this node.\n        if dist > min_dist_found:\n            continue \n\n        # Check if the current pixel (r, c) is a potential candidate (non-magenta).\n        # We exclude the starting pixel itself from being a candidate.\n        if (r, c) != (start_r, start_c) and grid[r, c] != 6:\n            # Found a non-magenta pixel.\n            if dist < min_dist_found:\n                # This is the first candidate found, or closer than previous candidates.\n                min_dist_found = dist\n                candidates = [(r, c)] # Reset candidates with this new best one\n            elif dist == min_dist_found:\n                # Found another candidate at the same minimum distance. Add it to the list.\n                candidates.append((r, c))\n            \n            # Important: Once a non-magenta pixel is found, we don't need to explore *from* it.\n            # We only care about the shortest path *to* a non-magenta pixel from the start.\n            # The pruning check 'dist > min_dist_found' handles stopping exploration \n            # on paths that are guaranteed to be longer.\n            continue \n\n        # Explore neighbors (Up, Down, Left, Right) if current path is still potentially optimal.\n        # The order of exploration here (e.g., Up, Down, Left, Right) does not affect correctness\n        # for finding the minimum distance due to BFS layer-by-layer nature.\n        # The tie-breaking order is applied *after* collecting all candidates at min_dist.\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: \n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid bounds and hasn't been visited.\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                new_dist = dist + 1\n                # Add neighbor to the queue only if it's potentially on a path\n                # leading to a candidate at or better than the current min_dist_found.\n                # If candidates have already been found (min_dist_found is not infinity), \n                # only explore neighbors if new_dist <= min_dist_found.\n                if new_dist <= min_dist_found: \n                    visited.add((nr, nc))\n                    queue.append((nr, nc, new_dist))\n\n    # --- Post-BFS Processing: Determine the final color ---\n    \n    if not candidates:\n        # No non-magenta pixels were found reachable from the start point.\n        # This could happen if the grid consists only of magenta pixels, \n        # or if the start pixel is surrounded only by magenta pixels.\n        # Return the original color in this case.\n        return grid[start_r, start_c] \n\n    if len(candidates) == 1:\n        # Only one closest candidate was found, so no tie-breaking is needed.\n        best_nr, best_nc = candidates[0]\n        return grid[best_nr, best_nc]\n    else:\n        # Multiple candidates exist at the same minimum distance. Apply tie-breaking.\n        # Sort the candidates using the custom sort key which prioritizes \n        # direction (Up > Left > Down > Right), then row index, then column index.\n        candidates.sort(key=lambda coord: get_sort_key(coord, start_r, start_c))\n        # The best candidate according to the rules is the first one after sorting.\n        best_nr, best_nc = candidates[0]\n        return grid[best_nr, best_nc]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replacing each magenta pixel (6) with the \n    color of its nearest non-magenta neighbor using Manhattan distance and \n    a specific tie-breaking rule (Up > Left > Down > Right > Row > Col). \n    Non-magenta pixels remain unchanged. Uses BFS for efficiency.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient indexing and operations\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy of the grid to store the output. Non-magenta pixels are correct initially.\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Check for edge case: If the grid contains *only* magenta pixels, \n    # no transformation is possible/needed. Return the original grid.\n    if np.all(grid == 6):\n         return input_grid # Return the input format (list of lists)\n\n    # Find the coordinates (row, column) of all magenta pixels (value 6)\n    magenta_coords = np.argwhere(grid == 6)\n\n    # Iterate through each magenta pixel identified\n    for r, c in magenta_coords:\n        # For the current magenta pixel at (r, c), find the color of its \n        # nearest non-magenta neighbor using the BFS-based search function.\n        replacement_color = find_closest_non_magenta_bfs(grid, r, c)\n        # Update the corresponding pixel in the output grid with the found color.\n        output_grid[r, c] = replacement_color\n                \n    # Convert the final NumPy array back to the required list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5028,
    "candidates_token_count": 2172,
    "total_token_count": 7200,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 68.381754,
  "retries": null
}