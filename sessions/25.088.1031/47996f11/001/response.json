{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid by replacing each magenta pixel (6) with the \ncolor of its nearest non-magenta neighbor. \nDistance is measured using Manhattan distance (|row1 - row2| + |col1 - col2|).\nIf multiple non-magenta neighbors are equidistant, a tie-breaking rule based \non direction is applied: Up is preferred, then Left, then Down, then Right. \nIf there's still a tie (e.g., two equidistant 'Up' neighbors, though unlikely \nwith Manhattan distance unless they are the same point relative to the center), \nthe one with the smallest row index is chosen, and finally the one with the \nsmallest column index.\nNon-magenta pixels remain unchanged in the output grid.\n\"\"\"\n\ndef get_sort_key(coord, center_r, center_c):\n    \"\"\"\n    Generates a sort key for a candidate coordinate based on its position \n    relative to a center point (the magenta pixel).\n    The key prioritizes directions: Up (0), Left (1), Down (2), Right (3).\n    Other relative positions (like diagonals) get a lower priority (4).\n    Secondary and tertiary sorting uses row and column index for stability.\n    \n    Args:\n        coord (tuple): The (row, column) of the candidate neighbor.\n        center_r (int): The row index of the center pixel (magenta).\n        center_c (int): The column index of the center pixel (magenta).\n\n    Returns:\n        tuple: A sort key (priority, row, column).\n    \"\"\"\n    nr, nc = coord\n    r, c = center_r, center_c\n    \n    # Calculate relative position\n    dr = nr - r\n    dc = nc - c\n\n    # Assign priority based on cardinal direction relative to center\n    if dr < 0 and dc == 0:  # Up\n        priority = 0\n    elif dr == 0 and dc < 0:  # Left\n        priority = 1\n    elif dr > 0 and dc == 0:  # Down\n        priority = 2\n    elif dr == 0 and dc > 0:  # Right\n        priority = 3\n    else: # Diagonal or other relative position (less preferred than cardinal)\n        priority = 4 \n\n    # Return tuple for sorting: (priority, absolute_row, absolute_col)\n    return (priority, nr, nc)\n\n\ndef find_closest_non_magenta(grid, r, c):\n    \"\"\"\n    Finds the color of the nearest non-magenta pixel to the given (r, c).\n\n    Iterates through the grid, calculates Manhattan distances to non-magenta\n    pixels, finds the minimum distance, collects all candidates at that minimum\n    distance, and then sorts them using the directional priority rule defined\n    in `get_sort_key`.\n\n    Args:\n        grid (np.array): The input grid.\n        r (int): The row index of the magenta pixel.\n        c (int): The column index of the magenta pixel.\n\n    Returns:\n        int: The color value of the selected nearest non-magenta neighbor.\n    \"\"\"\n    rows, cols = grid.shape\n    min_dist = float('inf')\n    candidates = [] # Stores tuples of (nr, nc) for pixels at min_dist\n\n    # Step 1: Find the minimum distance to any non-magenta pixel\n    for nr in range(rows):\n        for nc in range(cols):\n            # Check if the pixel is non-magenta (color != 6)\n            if grid[nr, nc] != 6: \n                # Calculate Manhattan distance\n                dist = abs(r - nr) + abs(c - nc)\n                \n                # Update minimum distance found so far\n                if dist < min_dist:\n                    min_dist = dist\n    \n    # If min_dist remains infinity, it means the grid has no non-magenta pixels\n    # (or is empty). Return the original color (magenta) as a fallback.\n    if min_dist == float('inf'):\n        return grid[r,c] \n\n    # Step 2: Collect all non-magenta pixels exactly at the minimum distance\n    for nr in range(rows):\n        for nc in range(cols):\n            if grid[nr, nc] != 6:\n                dist = abs(r - nr) + abs(c - nc)\n                if dist == min_dist:\n                    candidates.append((nr, nc))\n\n    # Step 3: Apply tie-breaking sort based on directional priority\n    # The sort key uses Up(0)/Left(1)/Down(2)/Right(3) priority, then row, then col.\n    candidates.sort(key=lambda coord: get_sort_key(coord, r, c)) \n    \n    # Step 4: The first candidate after sorting is the chosen one\n    best_nr, best_nc = candidates[0]\n    \n    # Return the color of the chosen neighbor\n    return grid[best_nr, best_nc]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to store the output, preserving non-magenta pixels initially\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Find coordinates of all magenta pixels that need processing\n    magenta_coords = np.argwhere(grid == 6)\n\n    # Iterate only through the magenta pixels found\n    for r, c in magenta_coords:\n        # For each magenta pixel, find the color of its prioritized nearest neighbor\n        replacement_color = find_closest_non_magenta(grid, r, c)\n        # Update the corresponding pixel in the output grid\n        output_grid[r, c] = replacement_color\n                \n    # Convert the final numpy array back to a list of lists format for the output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16727,
    "candidates_token_count": 1413,
    "total_token_count": 18140,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.092249,
  "retries": null
}