{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by replacing each magenta pixel (6) with the \ncolor of its nearest non-magenta neighbor. \nDistance is measured using Manhattan distance (|row1 - row2| + |col1 - col2|).\nIf multiple non-magenta neighbors are equidistant, a tie-breaking rule based \non the relative direction of the neighbor to the magenta pixel is applied: \nUp is preferred, then Left, then Down, then Right. \nIf there's still a tie (e.g., equidistant diagonal neighbors), \nthe one with the smallest row index is chosen, and finally the one with the \nsmallest column index.\nNon-magenta pixels remain unchanged in the output grid.\n\nThis implementation uses a multi-source Breadth-First Search (BFS) starting\nfrom all non-magenta pixels simultaneously for efficiency.\n\"\"\"\n\ndef get_sort_key(candidate_coord, center_r, center_c):\n    \"\"\"\n    Generates a sort key for a candidate source coordinate based on its position \n    relative to a center point (the target magenta pixel) for tie-breaking.\n    \n    The key prioritizes directions relative to the center: \n    Up (0), Left (1), Down (2), Right (3).\n    Other relative positions (like diagonals) get a lower priority (4).\n    Secondary sorting uses the candidate's row index, and tertiary sorting uses \n    the candidate's column index.\n    \n    Args:\n        candidate_coord (tuple): The (row, column) of the candidate source pixel.\n        center_r (int): The row index of the center pixel (magenta).\n        center_c (int): The column index of the center pixel (magenta).\n\n    Returns:\n        tuple: A sort key (priority, candidate_row, candidate_col).\n    \"\"\"\n    nr, nc = candidate_coord\n    r, c = center_r, center_c\n    \n    # Calculate relative position of candidate w.r.t center\n    dr = nr - r\n    dc = nc - c\n\n    # Assign priority based on cardinal direction relative to center\n    if dr < 0 and dc == 0: priority = 0  # Directly Up\n    elif dr == 0 and dc < 0: priority = 1  # Directly Left\n    elif dr > 0 and dc == 0: priority = 2  # Directly Down\n    elif dr == 0 and dc > 0: priority = 3  # Directly Right\n    else: priority = 4 # Others (diagonal or non-cardinal aligned)\n\n    # Return tuple for sorting: (priority, absolute_candidate_row, absolute_candidate_col)\n    return (priority, nr, nc)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid using a multi-source BFS approach.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    output_grid = np.copy(grid)\n\n    # Find coordinates of source (non-magenta) and target (magenta) pixels\n    source_coords = []\n    target_coords = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 6:\n                target_coords.append((r, c))\n            else:\n                source_coords.append(((r, c), grid[r, c])) # Store (pos, color)\n\n    # Handle edge cases\n    if not target_coords: # No magenta pixels\n        return input_grid \n    if not source_coords: # Only magenta pixels\n        return input_grid \n\n    # Initialize distance grid and candidate grid\n    # distance_grid stores the minimum Manhattan distance found so far to reach a cell\n    distance_grid = np.full((rows, cols), float('inf'), dtype=float)\n    # candidates_grid stores a list of potential source pixels (pos, color) \n    # that can reach this cell with the minimum distance found so far.\n    # Using object dtype because we need lists in cells.\n    candidates_grid = np.empty((rows, cols), dtype=object)\n    for r in range(rows):\n        for c in range(cols):\n            candidates_grid[r, c] = [] # Initialize with empty lists\n\n    # Initialize the queue for BFS with all source pixels\n    queue = deque()\n    for (sr, sc), color in source_coords:\n        distance_grid[sr, sc] = 0\n        # Each source cell is reached by itself at distance 0\n        candidates_grid[sr, sc] = [((sr, sc), color)] \n        queue.append((sr, sc))\n\n    # --- Multi-Source BFS Execution ---\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance_grid[r, c]\n        \n        # Explore neighbors (Up, Down, Left, Right)\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_dist = current_dist + 1\n                \n                # If we found a shorter path to the neighbor:\n                if new_dist < distance_grid[nr, nc]:\n                    distance_grid[nr, nc] = new_dist\n                    # The sources reaching (r,c) optimally are now the best for (nr,nc)\n                    candidates_grid[nr, nc] = candidates_grid[r, c] \n                    queue.append((nr, nc))\n                # If we found an equally short path:\n                elif new_dist == distance_grid[nr, nc]:\n                    # Add the sources reaching (r,c) to the existing candidates for (nr,nc)\n                    # Use a temporary set to merge and remove duplicates efficiently\n                    existing_sources = set(candidates_grid[nr, nc])\n                    new_sources = set(candidates_grid[r, c])\n                    candidates_grid[nr, nc] = list(existing_sources.union(new_sources))\n                    # No need to re-add (nr, nc) to queue if already visited/queued at this distance\n\n    # --- Post-BFS Processing: Assign colors to target pixels ---\n    for tr, tc in target_coords:\n        # Get the list of candidate sources (pos, color) for this target pixel\n        candidates = candidates_grid[tr, tc]\n        \n        if not candidates:\n            # Should not happen if there's at least one source pixel, \n            # but handle defensively. Keep original color.\n            continue \n        \n        if len(candidates) == 1:\n            # Only one closest source, no tie-breaking needed\n            winning_color = candidates[0][1] # Get color from (pos, color) tuple\n        else:\n            # Multiple equidistant sources found, apply tie-breaking\n            # Sort candidates based on relative position to the target (tr, tc)\n            # item[0] is the source position (sr, sc)\n            candidates.sort(key=lambda item: get_sort_key(item[0], tr, tc))\n            # The best candidate according to the rules is the first one after sorting\n            winning_color = candidates[0][1] # Get color from the winning (pos, color) tuple\n            \n        # Update the output grid\n        output_grid[tr, tc] = winning_color\n                \n    # Convert the final NumPy array back to the required list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6713,
    "candidates_token_count": 1792,
    "total_token_count": 8505,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.625059,
  "retries": null
}