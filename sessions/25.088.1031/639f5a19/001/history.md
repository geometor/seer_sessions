
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 4 4 4 4 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 4 4 4 4 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 4 4 4 4 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 4 4 4 4 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0
0 0 0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0
0 0 0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0
0 0 0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0
0 0 0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0
0 0 0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0 0 0
0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0 0 0
0 0 0 0 0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0 0 0
0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0 0 0
0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0 0 0
0 0 0 0 0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
0 6 6 6 6 6 6 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0 0 0 0 0 0 0
0 6 6 4 4 4 4 4 4 4 4 1 1 0 0 0 0 0 0 0 0 0 0
0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0 0 0 0 0 0 0
0 2 2 4 4 4 4 4 4 4 4 3 3 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

## Perception

1.  **Input Structure:** The input grids contain one or more solid rectangular blocks of azure (8) pixels against a white (0) background. The blocks can have different dimensions and positions.
2.  **Output Structure:** The output grids retain the white background. The areas previously occupied by the azure blocks are now filled with patterns composed of multiple colors: magenta (6), blue (1), red (2), green (3), and yellow (4). The shape and position of the original azure blocks are preserved in the output patterns.
3.  **Transformation:** The core transformation applies a specific coloring pattern rule to each azure block independently.
4.  **Pattern Details:** Within each transformed block:
    *   There's a central rectangular region colored yellow (4).
    *   The border region around the yellow center is divided into four quadrants.
    *   The top-left border quadrant is magenta (6).
    *   The top-right border quadrant is blue (1).
    *   The bottom-left border quadrant is red (2).
    *   The bottom-right border quadrant is green (3).
5.  **Pattern Geometry:**
    *   The division into quadrants seems based on the horizontal and vertical center lines of the block.
    *   The central yellow rectangle appears to be defined by excluding a border of fixed thickness (seems like 2 pixels) from all four sides of the original block. If the block is too small (less than 5x5), the yellow region might not exist.

## Facts


```yaml
elements:
  - element: grid
    role: background
    color: white (0)
    properties:
      - unchanged between input and output
  - element: rectangle
    role: object
    color: azure (8)
    properties:
      - solid fill
      - variable dimensions (height H, width W)
      - variable position
      - exists only in input
      - always aligned with grid axes
  - element: pattern
    role: object_replacement
    colors: [magenta (6), blue (1), red (2), green (3), yellow (4)]
    properties:
      - occupies the exact same area as a corresponding input azure rectangle
      - internal structure depends on position within the block area
      - exists only in output
relationships:
  - relationship: replacement
    subject: azure rectangle (input)
    object: multi-color pattern (output)
    details: Each azure rectangle is replaced by a pattern.
actions:
  - action: identify_blocks
    input: input grid
    output: list of azure rectangles (location, dimensions)
  - action: apply_pattern
    input: azure rectangle (location, dimensions HxW)
    output: patterned block (same location and dimensions)
    details:
      - calculate center point: mid_row = H // 2, mid_col = W // 2 (relative indices)
      - calculate central yellow region boundaries (relative indices):
          r_start_yellow = 2
          r_end_yellow = H - 3
          c_start_yellow = 2
          c_end_yellow = W - 3
      - for each pixel (r, c) within the block's relative coordinates:
          - if (r_start_yellow <= r <= r_end_yellow) and (c_start_yellow <= c <= c_end_yellow):
              color = yellow (4)
          - else (pixel is in the border region):
              - if r < mid_row and c < mid_col: color = magenta (6)
              - if r < mid_row and c >= mid_col: color = blue (1)
              - if r >= mid_row and c < mid_col: color = red (2)
              - if r >= mid_row and c >= mid_col: color = green (3)
  - action: reconstruct_output
    input: original grid, list of patterned blocks
    output: output grid
    details: Copy the input grid, then overwrite the areas corresponding to the original azure blocks with their respective generated patterns.

```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Find all distinct, contiguous rectangular blocks composed solely of azure (8) pixels in the input grid. Record the top-left corner coordinates (row `R`, column `C`) and dimensions (height `H`, width `W`) of each block.
3.  For each identified azure block:
    a.  Determine the relative row and column midpoints for division: `mid_row = H // 2`, `mid_col = W // 2`.
    b.  Determine the relative row and column indices defining the central yellow (4) region:
        i.  `r_start_yellow = 2`
        ii. `r_end_yellow = H - 3`
        iii. `c_start_yellow = 2`
        iv. `c_end_yellow = W - 3`
    c.  Iterate through each cell within the block's boundaries in the output grid, using absolute grid coordinates `(r_abs, c_abs)` where `R <= r_abs < R + H` and `C <= c_abs < C + W`.
    d.  Calculate the relative coordinates within the block: `r_rel = r_abs - R`, `c_rel = c_abs - C`.
    e.  Check if the relative coordinates `(r_rel, c_rel)` fall within the central yellow region: `r_start_yellow <= r_rel <= r_end_yellow` AND `c_start_yellow <= c_rel <= c_end_yellow`.
        i.  If TRUE, set the color of the output grid cell `(r_abs, c_abs)` to yellow (4).
        ii. If FALSE, determine the quadrant based on the relative coordinates and the midpoints:
            *   If `r_rel < mid_row` and `c_rel < mid_col` (Top-Left quadrant), set the color to magenta (6).
            *   If `r_rel < mid_row` and `c_rel >= mid_col` (Top-Right quadrant), set the color to blue (1).
            *   If `r_rel >= mid_row` and `c_rel < mid_col` (Bottom-Left quadrant), set the color to red (2).
            *   If `r_rel >= mid_row` and `c_rel >= mid_col` (Bottom-Right quadrant), set the color to green (3).
4.  Return the modified output grid.
