{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by finding all rectangular blocks of azure (8) pixels. \nEach azure block is replaced with a patterned block of the same dimensions. \nThe pattern consists of a central yellow (4) rectangle (if the block is large enough) \nsurrounded by a border region divided into four quadrants: top-left is magenta (6), \ntop-right is blue (1), bottom-left is red (2), and bottom-right is green (3). \nThe central yellow region starts at relative row/column index 2 and ends at relative \nrow/column index H-3/W-3. The quadrants are divided based on the integer division \nmidpoints of the block's height and width. Pixels outside the azure blocks remain unchanged.\n\"\"\"\n\ndef find_azure_blocks(grid):\n    \"\"\"\n    Finds all contiguous rectangular blocks of a specific color (azure=8).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a block\n              and contains 'r', 'c' (top-left coordinates), 'h' (height),\n              and 'w' (width).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    target_color = 8 # Azure\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Found the start of a potential block\n                q = deque([(r, c)])\n                visited[r, c] = True\n                block_pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Use BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            block_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Check if the found region is a solid rectangle\n                block_h = max_r - min_r + 1\n                block_w = max_c - min_c + 1\n                is_rectangle = True\n                if len(block_pixels) != block_h * block_w:\n                    is_rectangle = False\n                else:\n                    # Double check all pixels within the bounding box are the target color\n                    for br in range(min_r, max_r + 1):\n                        for bc in range(min_c, max_c + 1):\n                            if grid[br, bc] != target_color:\n                                is_rectangle = False\n                                break\n                        if not is_rectangle:\n                            break\n                \n                if is_rectangle:\n                    blocks.append({'r': min_r, 'c': min_c, 'h': block_h, 'w': block_w})\n\n    return blocks\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the patterned transformation to azure blocks in the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all azure rectangular blocks\n    azure_blocks = find_azure_blocks(input_grid)\n\n    # Define colors\n    magenta = 6\n    blue = 1\n    red = 2\n    green = 3\n    yellow = 4\n\n    # Process each block\n    for block in azure_blocks:\n        R, C = block['r'], block['c']\n        H, W = block['h'], block['w']\n\n        # Calculate relative midpoints for quadrant division\n        mid_row_rel = H // 2 \n        mid_col_rel = W // 2\n\n        # Calculate relative boundaries for the central yellow region\n        # Note: indices are 0-based\n        r_start_yellow = 2\n        r_end_yellow = H - 1 - 2  # Inclusive end index relative to block start\n        c_start_yellow = 2\n        c_end_yellow = W - 1 - 2  # Inclusive end index relative to block start\n\n        # Iterate through each cell within the block's area\n        for r_rel in range(H):\n            for c_rel in range(W):\n                # Absolute coordinates in the grid\n                r_abs = R + r_rel\n                c_abs = C + c_rel\n\n                # Determine the color based on relative position\n                color = 0 # Default color (should be overwritten)\n\n                # Check if within the central yellow region\n                if (r_start_yellow <= r_rel <= r_end_yellow) and \\\n                   (c_start_yellow <= c_rel <= c_end_yellow):\n                    color = yellow\n                else:\n                    # Determine quadrant for border region\n                    if r_rel < mid_row_rel: # Top half\n                        if c_rel < mid_col_rel: # Left half\n                            color = magenta\n                        else: # Right half\n                            color = blue\n                    else: # Bottom half\n                        if c_rel < mid_col_rel: # Left half\n                            color = red\n                        else: # Right half\n                            color = green\n\n                # Update the output grid\n                output_grid[r_abs, c_abs] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6812,
    "candidates_token_count": 1404,
    "total_token_count": 8216,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.396073,
  "retries": null
}