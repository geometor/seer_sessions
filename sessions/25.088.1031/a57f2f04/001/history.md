
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 0 0 0 8 8 8 8 8
8 8 0 2 2 0 0 0 8 8 8 8 8
8 8 2 0 2 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 0 2 2 0 2 2 8 8 8 8 8
8 8 2 0 2 2 0 2 8 8 8 8 8
8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 0 2 2 0 2 2 8 8 8 8 8
8 8 2 0 2 2 0 2 8 8 8 8 8
8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 0 2 2 0 2 2 8 8 8 8 8
8 8 2 0 2 2 0 2 8 8 8 8 8
8 8 2 2 2 2 2 2 8 8 8 8 8
8 8 0 2 2 0 2 2 8 8 8 8 8
8 8 2 0 2 2 0 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 1 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 0 3 0 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 3 0 3 8 8 8
8 8 8 8 8 8 8 0 0 0 0 0 0 3 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8
8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8
8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8
8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 0 3 0 0 3 0 0 3 0 8 8 8
8 8 8 8 8 8 8 3 0 3 3 0 3 3 0 3 8 8 8
8 8 8 8 8 8 8 3 3 3 3 3 3 3 3 3 8 8 8
8 8 8 8 8 8 8 0 3 0 0 3 0 0 3 0 8 8 8
8 8 8 8 8 8 8 3 0 3 3 0 3 3 0 3 8 8 8
8 8 8 8 8 8 8 3 3 3 3 3 3 3 3 3 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 2 0 2 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 2 2 0 2 2 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 2 2 2 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8
8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8
8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8
8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8
8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8
8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8
8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8
8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8
8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8
8 8 8 0 4 0 0 4 0 0 4 0 0 4 0 0 4 0 8 8 8
8 8 8 4 0 4 4 0 4 4 0 4 4 0 4 4 0 4 8 8 8
8 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8
8 8 8 0 4 0 0 4 0 0 4 0 0 4 0 0 4 0 8 8 8
8 8 8 4 0 4 4 0 4 4 0 4 4 0 4 4 0 4 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's analyze the task.

**Perception**

1.  **Input Structure:** The input grids contain one or more distinct rectangular regions bounded by an azure (8) border. Inside these regions, there are areas of white (0) pixels and a small "pattern kernel" composed of non-white, non-azure pixels.
2.  **Output Structure:** The output grids retain the azure borders. The areas inside the borders, which were mostly white in the input, are now filled with a repeating pattern.
3.  **Transformation:** The core transformation involves identifying the small pattern kernel within each bounded region in the input and then tiling this pattern across the entire corresponding region in the output.
4.  **Pattern Kernel:** The kernel seems to be the smallest rectangular subgrid within the bounded area that contains all the non-white, non-azure pixels. This rectangular subgrid, including any white pixels within it, serves as the repeating unit.
5.  **Tiling:** The tiling starts from the top-left corner of the bounded region (the first non-azure pixel encountered). The kernel pattern is repeated horizontally and vertically to fill the entire region. The modulo operator based on the kernel's dimensions determines which part of the kernel pattern applies to each cell in the output region.
6.  **Multiple Regions:** Some examples (like train\_2 and train\_3) have multiple, separate bordered regions. The tiling process is applied independently to each region using its specific kernel.
7.  **Color Preservation:** The colors used in the kernel (red, blue, green, yellow) are preserved and replicated in the output tiling. The azure border color is also preserved. White pixels within the original kernel's bounding box are also part of the repeating pattern.

**Facts**


```yaml
facts:
  - grid_elements:
      - background: color 8 (azure) forms borders/frames.
      - enclosed_regions: areas within the azure borders, initially mostly color 0 (white).
      - pattern_kernels: small, non-contiguous or contiguous groups of pixels with colors other than white (0) or azure (8), located within an enclosed_region.
  - properties:
      - enclosed_regions are rectangular or composed of rectangular sub-parts.
      - pattern_kernels define a repeating unit.
      - the size and shape of the enclosed_regions vary.
      - the size, shape, and colors of the pattern_kernels vary.
      - multiple independent enclosed_regions can exist in one grid.
  - actions:
      - identify: locate the azure background/borders.
      - identify: locate the regions enclosed by the background.
      - identify: find the non-white, non-azure "seed" pixels within each enclosed region.
      - determine: find the minimal bounding box containing all seed pixels within a region. This defines the pattern_kernel area.
      - extract: capture the pixel values within the pattern_kernel's bounding box from the input grid.
      - tile/fill: repeat the extracted pattern_kernel across the entire corresponding enclosed_region in the output grid.
      - preserve: maintain the azure background in the output.
  - relationships:
      - each enclosed_region contains exactly one pattern_kernel definition (even if it's just one pixel).
      - the pattern_kernel dictates the fill pattern for its corresponding enclosed_region.
      - the tiling origin is the top-left corner of the enclosed_region.
      - the tiling repeats based on the dimensions of the pattern_kernel's bounding box.
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the background color, which is azure (8).
3.  Find all distinct contiguous regions within the grid that are *not* the background color.
4.  For each distinct non-background region found:
    a.  Find all pixels within this region that are *not* white (0). Call these the "seed" pixels.
    b.  If no seed pixels exist in the region, skip to the next region.
    c.  Determine the minimum row (`min_r_kernel`), maximum row (`max_r_kernel`), minimum column (`min_c_kernel`), and maximum column (`max_c_kernel`) coordinates of these seed pixels. This defines the bounding box of the pattern kernel.
    d.  Calculate the height (`kernel_h = max_r_kernel - min_r_kernel + 1`) and width (`kernel_w = max_c_kernel - min_c_kernel + 1`) of the kernel.
    e.  Extract the kernel pattern: create a `kernel_h` x `kernel_w` grid by copying the pixels from the input grid from `input[min_r_kernel:max_r_kernel+1, min_c_kernel:max_c_kernel+1]`.
    f.  Determine the top-left corner (`region_min_r`, `region_min_c`) of the entire contiguous non-background region identified in step 4.
    g.  Iterate through all pixels (`r`, `c`) belonging to this contiguous non-background region.
    h.  For each pixel (`r`, `c`), calculate its corresponding position within the kernel pattern using the region's top-left corner and the kernel dimensions:
        i.  `kernel_row_index = (r - region_min_r) % kernel_h`
        ii. `kernel_col_index = (c - region_min_c) % kernel_w`
    i.  Get the color from the extracted kernel pattern at `kernel[kernel_row_index][kernel_col_index]`.
    j.  Update the output grid at `output[r][c]` with this retrieved color.
5.  Return the final output grid.
