{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the pixels within a gray rectangular frame based on adjacency rules and the presence of internal gray pixels.\n\n1.  Identify the gray (5) rectangular frame and the area it encloses.\n2.  Check if any gray (5) pixels exist within the enclosed area (excluding the frame itself).\n3.  If no internal gray pixels exist (Case 1):\n    a.  Initialize the first layer of pixels adjacent to the frame (inside) as red (2).\n    b.  Iteratively fill inwards: pixels adjacent (8-connectivity) to the last colored layer are colored with the alternate color (gray (5) if the last was red, red (2) if the last was gray).\n    c.  This continues until no more white (0) pixels inside the frame can be colored.\n4.  If internal gray pixels exist (Case 2):\n    a.  Change white (0) pixels inside the frame that are adjacent (8-connectivity) to *any* gray pixel (frame or internal) to red (2).\n    b.  Leave all other pixels unchanged (including internal grays).\n5.  If no gray frame is found, return the input grid unchanged.\n\"\"\"\n\ndef _find_frame_and_internal_gray(input_array):\n    \"\"\"\n    Finds the bounding box of gray pixels and checks for internal grays.\n\n    Args:\n        input_array (np.array): The input grid.\n\n    Returns:\n        tuple: (frame_coords, has_internal_gray)\n               frame_coords is (min_r, max_r, min_c, max_c) or None if no frame.\n               has_internal_gray is bool.\n    \"\"\"\n    height, width = input_array.shape\n    gray_pixels = np.argwhere(input_array == 5)\n\n    if gray_pixels.size == 0:\n        return None, False # No gray pixels at all\n\n    min_r = np.min(gray_pixels[:, 0])\n    max_r = np.max(gray_pixels[:, 0])\n    min_c = np.min(gray_pixels[:, 1])\n    max_c = np.max(gray_pixels[:, 1])\n\n    # Basic check: does it look like a frame boundary?\n    # A more robust check could verify all boundary pixels are gray,\n    # but min/max might be sufficient for this task's examples.\n    is_plausible_frame = (np.any(gray_pixels[:, 0] == min_r) and\n                         np.any(gray_pixels[:, 0] == max_r) and\n                         np.any(gray_pixels[:, 1] == min_c) and\n                         np.any(gray_pixels[:, 1] == max_c))\n\n    if not is_plausible_frame:\n         # It might be scattered gray pixels, not a frame boundary\n         # Check if ALL gray pixels lie *only* on the boundary box lines\n         is_only_boundary = True\n         for r, c in gray_pixels:\n             if not (r == min_r or r == max_r or c == min_c or c == max_c):\n                 is_only_boundary = False\n                 break\n         if not is_only_boundary:\n             # Found gray pixels inside the bounding box defined by gray pixels,\n             # treat this as Case 2 even if not a perfect frame.\n             # Find all white pixels adjacent to any gray pixel.\n             pass # Logic handled in main transform function's Case 2 path\n         else:\n              # Grays only on boundary lines, but maybe not a full frame.\n              # For this problem, let's assume if gray exists, it forms the intended frame.\n              # If required, add stricter frame validation here.\n              pass\n\n\n    frame_coords = (min_r, max_r, min_c, max_c)\n\n    # --- Check for Internal Grays ---\n    has_internal_gray = False\n    if max_r > min_r + 1 and max_c > min_c + 1: # Check if there's a potential inside\n        internal_area = input_array[min_r + 1:max_r, min_c + 1:max_c]\n        if np.any(internal_area == 5):\n            has_internal_gray = True\n\n    return frame_coords, has_internal_gray\n\n\ndef _get_adjacent_white_pixels(grid, target_coords_set, internal_coords):\n    \"\"\"\n    Finds white pixels within internal_coords adjacent to pixels in target_coords_set.\n\n    Args:\n        grid (np.array): The current state of the grid.\n        target_coords_set (set): Set of (r, c) tuples to check adjacency against.\n        internal_coords (tuple): (min_r, max_r, min_c, max_c) defining the internal area boundaries.\n\n    Returns:\n        set: Set of (r, c) tuples of adjacent white pixels found.\n    \"\"\"\n    height, width = grid.shape\n    adjacent_white_pixels = set()\n    min_r, max_r, min_c, max_c = internal_coords\n\n    # Iterate through the bounding box of the target coordinates for efficiency\n    if not target_coords_set:\n        return adjacent_white_pixels\n\n    # Calculate bounds of potential neighbours to check\n    rows_to_check = set()\n    cols_to_check = set()\n    for r,c in target_coords_set:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                nr, nc = r + dr, c + dc\n                # Check if neighbour is within the internal area bounds\n                if min_r < nr < max_r and min_c < nc < max_c:\n                     rows_to_check.add(nr)\n                     cols_to_check.add(nc)\n\n    # Check only the relevant internal pixels\n    for r in rows_to_check:\n         for c in cols_to_check:\n              # Ensure it's strictly inside\n              if not (min_r < r < max_r and min_c < c < max_c):\n                  continue\n                  \n              if grid[r, c] == 0: # Check if it's white\n                   # Check 8 neighbours\n                   is_adj = False\n                   for dr in [-1, 0, 1]:\n                       for dc in [-1, 0, 1]:\n                           if dr == 0 and dc == 0:\n                               continue\n                           nr, nc = r + dr, c + dc\n                           if (nr, nc) in target_coords_set:\n                               is_adj = True\n                               break\n                       if is_adj:\n                           break\n                   if is_adj:\n                       adjacent_white_pixels.add((r, c))\n\n    return adjacent_white_pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the iterative fill or single-layer red fill based on internal grays.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # --- 1. Identify Frame and Internal Grays ---\n    frame_coords, has_internal_gray = _find_frame_and_internal_gray(input_array)\n\n    if frame_coords is None:\n        # No gray pixels found, or couldn't determine a frame\n        return input_grid # Return original grid\n\n    min_r, max_r, min_c, max_c = frame_coords\n    internal_bounds = (min_r, max_r, min_c, max_c) # Use frame coords for internal area boundary checks\n\n    # --- 2. Apply Transformation based on Case ---\n\n    if has_internal_gray:\n        # --- Case 2: Internal Grays Exist ---\n        # Find all gray pixel coordinates (frame and internal)\n        all_gray_coords_set = set(tuple(coord) for coord in np.argwhere(input_array == 5))\n\n        # Find white pixels inside the frame adjacent to *any* gray pixel\n        pixels_to_red = set()\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                if input_array[r, c] == 0: # Only consider white pixels\n                    is_adj_to_gray = False\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue\n                            nr, nc = r + dr, c + dc\n                            # Check bounds implicitly via set lookup\n                            if (nr, nc) in all_gray_coords_set:\n                                is_adj_to_gray = True\n                                break\n                        if is_adj_to_gray:\n                            break\n                    if is_adj_to_gray:\n                        pixels_to_red.add((r,c))\n\n        # Apply the changes\n        for r, c in pixels_to_red:\n            output_array[r, c] = 2 # Red\n\n    else:\n        # --- Case 1: No Internal Grays ---\n        # Get initial frame coordinates\n        frame_pixels_set = set()\n        for r in range(min_r, max_r + 1):\n             for c in range(min_c, max_c + 1):\n                  if input_array[r,c] == 5:\n                      # Check if it's actually part of the boundary frame lines\n                      if r == min_r or r == max_r or c == min_c or c == max_c:\n                           frame_pixels_set.add((r,c))\n        \n        if not frame_pixels_set: # Should not happen if frame_coords is not None, but safety check\n             return output_array.tolist()\n\n        last_colored_pixels_set = frame_pixels_set\n        color_to_place = 2 # Start with Red\n\n        while True:\n            # Find white pixels inside the frame adjacent to the last colored layer\n            current_pixels_to_color = _get_adjacent_white_pixels(\n                output_array, # Check against the current state of the output grid\n                last_colored_pixels_set,\n                internal_bounds\n            )\n\n            # If no more white pixels can be colored, stop\n            if not current_pixels_to_color:\n                break\n\n            # Color the found pixels\n            for r, c in current_pixels_to_color:\n                output_array[r, c] = color_to_place\n\n            # Prepare for the next iteration\n            last_colored_pixels_set = current_pixels_to_color\n            color_to_place = 5 if color_to_place == 2 else 2 # Toggle color\n\n    # Convert back to list of lists for the expected output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24672,
    "candidates_token_count": 2555,
    "total_token_count": 27227,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.577314,
  "retries": null
}