{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the pixels within a gray rectangular frame based on adjacency rules and the presence of internal gray pixels.\n\n1.  Identify the gray (5) rectangular frame by finding the bounding box of all gray pixels.\n2.  Check if any gray (5) pixels exist within the area strictly enclosed by the frame's bounding box.\n3.  If no internal gray pixels exist (Case 1):\n    a.  Perform a layered fill starting from the frame boundary inwards.\n    b.  The first layer adjacent to the frame is colored red (2).\n    c.  The next layer adjacent to the red layer is colored gray (5).\n    d.  Subsequent layers alternate between red (2) and gray (5).\n    e.  This continues until no more white (0) pixels inside the frame can be colored by adjacent layers.\n4.  If internal gray pixels exist (Case 2):\n    a.  Find all white (0) pixels strictly inside the frame's bounding box that are adjacent (8-connectivity) to *any* gray pixel (either on the frame or internal).\n    b.  Change these adjacent white pixels to red (2).\n    c.  Leave all other pixels unchanged (including internal grays and non-adjacent whites).\n5.  If no gray pixels are found in the input, return the input grid unchanged.\n\"\"\"\n\ndef _find_frame_and_internal_gray(input_array):\n    \"\"\"\n    Finds the bounding box of gray pixels and checks for internal grays.\n\n    Args:\n        input_array (np.array): The input grid.\n\n    Returns:\n        tuple: (frame_coords, has_internal_gray)\n               frame_coords is (min_r, max_r, min_c, max_c) or None if no gray pixels.\n               has_internal_gray is bool.\n    \"\"\"\n    gray_pixels = np.argwhere(input_array == 5)\n\n    if gray_pixels.size == 0:\n        return None, False # No gray pixels at all\n\n    min_r = np.min(gray_pixels[:, 0])\n    max_r = np.max(gray_pixels[:, 0])\n    min_c = np.min(gray_pixels[:, 1])\n    max_c = np.max(gray_pixels[:, 1])\n\n    frame_coords = (min_r, max_r, min_c, max_c)\n\n    # --- Check for Internal Grays ---\n    has_internal_gray = False\n    # Check only if there's a potential internal area\n    if max_r > min_r + 1 and max_c > min_c + 1:\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                if input_array[r, c] == 5:\n                    has_internal_gray = True\n                    break\n            if has_internal_gray:\n                break\n\n    return frame_coords, has_internal_gray\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the iterative fill or single-layer red fill based on internal grays.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # --- 1. Identify Frame and Internal Grays ---\n    frame_coords, has_internal_gray = _find_frame_and_internal_gray(input_array)\n\n    if frame_coords is None:\n        # No gray pixels found, return original grid\n        return input_grid\n\n    min_r, max_r, min_c, max_c = frame_coords\n\n    # --- 2. Apply Transformation based on Case ---\n\n    if has_internal_gray:\n        # --- Case 2: Internal Grays Exist ---\n        # Find coordinates of all gray pixels (frame and internal)\n        all_gray_coords_set = set(tuple(coord) for coord in np.argwhere(input_array == 5))\n\n        # Iterate through pixels strictly inside the frame bounds\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                if output_array[r, c] == 0: # Check only white pixels\n                    is_adj_to_gray = False\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue\n                            nr, nc = r + dr, c + dc\n                            # Check bounds implicitly via set lookup efficiency\n                            if (nr, nc) in all_gray_coords_set:\n                                is_adj_to_gray = True\n                                break\n                        if is_adj_to_gray:\n                            break # Break outer loop too once adjacency found\n                    # Color red if adjacent to any gray\n                    if is_adj_to_gray:\n                        output_array[r, c] = 2 # Red\n\n    else:\n        # --- Case 1: No Internal Grays ---\n        # Use BFS for layered coloring\n        q = deque()\n        visited = set() # Keep track of visited internal cells to avoid cycles and re-coloring\n        initial_color = 2 # Start with Red\n\n        # Find initial layer: white cells inside adjacent to the frame\n        frame_pixels_set = set()\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                 if input_array[r,c] == 5:\n                      # Check if it's actually part of the boundary frame lines\n                      if r == min_r or r == max_r or c == min_c or c == max_c:\n                           frame_pixels_set.add((r,c))\n\n        current_layer_coords = set()\n        for r_frame, c_frame in frame_pixels_set:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0: continue\n                    nr, nc = r_frame + dr, c_frame + dc\n\n                    # Check if neighbor is strictly inside the frame and is white\n                    if min_r < nr < max_r and min_c < nc < max_c and output_array[nr, nc] == 0:\n                        coord = (nr, nc)\n                        if coord not in visited:\n                           current_layer_coords.add(coord)\n\n        # Add initial layer to queue and color them\n        for r, c in current_layer_coords:\n             output_array[r, c] = initial_color\n             visited.add((r, c))\n             q.append(((r, c), initial_color)) # Store coordinate and its color\n\n        # Perform BFS\n        while q:\n            (r, c), current_color = q.popleft()\n            next_color = 5 if current_color == 2 else 2 # Toggle color for the next layer\n\n            # Explore neighbors\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0: continue\n                    nr, nc = r + dr, c + dc\n\n                    # Check if neighbor is strictly inside, is white, and not visited\n                    if (min_r < nr < max_r and\n                        min_c < nc < max_c and\n                        output_array[nr, nc] == 0 and\n                        (nr, nc) not in visited):\n\n                        visited.add((nr, nc))\n                        output_array[nr, nc] = next_color\n                        q.append(((nr, nc), next_color))\n\n\n    # Convert back to list of lists for the expected output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16717,
    "candidates_token_count": 1890,
    "total_token_count": 18607,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.945706,
  "retries": null
}