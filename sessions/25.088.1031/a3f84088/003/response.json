{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the pixels within a gray rectangular frame based on adjacency rules and the presence of internal gray pixels.\n\n1.  Identify the gray (5) rectangular frame and the area it encloses.\n2.  Check if any gray (5) pixels exist within the enclosed area (excluding the frame itself).\n3.  If no internal gray pixels exist (Case 1):\n    a.  Change white (0) pixels inside the frame that are adjacent (8-connectivity) to the frame pixels (gray=5) to red (2).\n    b.  Change remaining white (0) pixels inside the frame that are adjacent (8-connectivity) to the newly colored red (2) pixels to gray (5).\n    c.  Leave other pixels unchanged.\n4.  If internal gray pixels exist (Case 2):\n    a.  Change white (0) pixels inside the frame that are adjacent (8-connectivity) to *any* gray pixel (frame or internal) to red (2).\n    b.  Leave all other pixels unchanged (including internal grays).\n5.  If no gray frame is found, return the input grid unchanged.\n\"\"\"\n\ndef is_adjacent(grid, r, c, target_color):\n    \"\"\"\n    Checks 8 neighbors (including diagonals) of the pixel at (r, c)\n    in the grid for the target_color.\n\n    Args:\n        grid (np.array): The grid to check within.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n        target_color (int): The color value to look for in neighbors.\n\n    Returns:\n        bool: True if any neighbor has the target_color, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center pixel itself\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check bounds and color\n            if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] == target_color:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on the presence of internal gray pixels\n    within a gray frame.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # --- 1. Identify the Frame ---\n    gray_pixels = np.argwhere(input_array == 5)\n    if gray_pixels.size == 0:\n        # Edge Case: No gray pixels, return original grid\n        return input_grid\n\n    # Assume the frame defines the min/max boundaries of all gray pixels\n    min_r = np.min(gray_pixels[:, 0])\n    max_r = np.max(gray_pixels[:, 0])\n    min_c = np.min(gray_pixels[:, 1])\n    max_c = np.max(gray_pixels[:, 1])\n\n    # --- 2. Define Internal Area ---\n    # Ensure ranges are valid even for thin frames (max could be min+1)\n    internal_rows = range(min_r + 1, max_r)\n    internal_cols = range(min_c + 1, max_c)\n\n    # --- 3. Check for Internal Grays ---\n    has_internal_gray = False\n    for r in internal_rows:\n        for c in internal_cols:\n            if input_array[r, c] == 5:\n                has_internal_gray = True\n                break\n        if has_internal_gray:\n            break\n\n    # --- 4/5. Apply Transformation ---\n\n    if has_internal_gray:\n        # --- Case 2: Internal Grays Exist ---\n        pixels_to_red = []\n        # Iterate through the defined internal area\n        for r in internal_rows:\n            for c in internal_cols:\n                # Target only white pixels\n                if input_array[r, c] == 0:\n                    # Check adjacency to ANY gray pixel (frame or internal) in the original input\n                    if is_adjacent(input_array, r, c, 5):\n                        pixels_to_red.append((r, c))\n\n        # Apply the changes to the output grid\n        for r, c in pixels_to_red:\n            output_array[r, c] = 2\n            \n        # Other pixels (internal grays, non-adjacent whites) remain unchanged by default\n\n    else:\n        # --- Case 1: No Internal Grays ---\n        pixels_to_red = []\n        pixels_to_gray = []\n\n        # --- Pass 1: Find white pixels adjacent to the frame (which are the only grays) ---\n        for r in internal_rows:\n            for c in internal_cols:\n                if input_array[r, c] == 0:\n                    # Check adjacency to frame pixels (color 5) in the original input\n                    if is_adjacent(input_array, r, c, 5):\n                        pixels_to_red.append((r, c))\n\n        # Create a temporary grid reflecting the red changes for the next adjacency check\n        temp_output_after_red = np.copy(output_array)\n        for r, c in pixels_to_red:\n            temp_output_after_red[r, c] = 2\n\n        # --- Pass 2: Find remaining white pixels adjacent to the NEWLY red pixels ---\n        for r in internal_rows:\n            for c in internal_cols:\n                # Check if it was originally white AND wasn't marked to become red\n                is_original_white = (input_array[r, c] == 0)\n                # Check if the coordinate pair is not in the list of pixels to turn red\n                # Converting list to set for faster lookup if necessary, but for typical ARC sizes, list search is fine.\n                is_not_red = ((r,c) not in pixels_to_red) \n\n                if is_original_white and is_not_red:\n                    # Check adjacency to RED pixels (2) in the grid *after* the first pass\n                    if is_adjacent(temp_output_after_red, r, c, 2):\n                         pixels_to_gray.append((r, c))\n\n        # --- Apply all changes to the final output grid ---\n        for r, c in pixels_to_red:\n            output_array[r, c] = 2\n        for r, c in pixels_to_gray:\n            output_array[r, c] = 5\n            \n        # White pixels not adjacent to frame or new red pixels remain white by default\n\n    # Convert back to list of lists for the expected output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9107,
    "candidates_token_count": 1600,
    "total_token_count": 10707,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.204105,
  "retries": null
}