{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\nimport itertools\n\n\"\"\"\nIdentifies all distinct non-white objects in the input grid. \nFor each color, it considers all pairs of objects of that color. \nIf a pair of objects is aligned either horizontally or vertically, \nand the rectangular area directly between them consists entirely of white pixels (0), \nthat area is filled with azure pixels (8) in the output grid. \nThe original objects remain unchanged.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-white color.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'color', 'coords' (a set of (row, col) tuples), \n        and 'bbox' (a tuple: min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'bbox': (min_r, max_r, min_c, max_c)\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling white gaps between same-colored objects\n    with azure pixels.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all non-white objects\n    objects = find_objects(input_grid)\n    \n    # Group objects by color\n    objects_by_color = defaultdict(list)\n    for obj in objects:\n        objects_by_color[obj['color']].append(obj)\n        \n    # Iterate through each color group with 2 or more objects\n    for color, group in objects_by_color.items():\n        if len(group) < 2:\n            continue\n            \n        # Iterate through all unique pairs of objects of the same color\n        for obj1, obj2 in itertools.combinations(group, 2):\n            bbox1 = obj1['bbox']\n            bbox2 = obj2['bbox']\n            \n            # Ensure object 1 is consistently \"first\" (leftmost or topmost)\n            # This simplifies gap calculation logic\n            if bbox1[2] > bbox2[2]: # obj1 is right of obj2\n                obj1, obj2 = obj2, obj1\n                bbox1, bbox2 = bbox2, bbox1\n            elif bbox1[2] == bbox2[2] and bbox1[0] > bbox2[0]: # Same column start, obj1 below obj2\n                obj1, obj2 = obj2, obj1\n                bbox1, bbox2 = bbox2, bbox1\n\n            r1_min, r1_max, c1_min, c1_max = bbox1\n            r2_min, r2_max, c2_min, c2_max = bbox2\n\n            # --- Horizontal Check ---\n            # Check for row overlap\n            overlap_r_min = max(r1_min, r2_min)\n            overlap_r_max = min(r1_max, r2_max)\n            \n            if overlap_r_min <= overlap_r_max:\n                # Define potential horizontal gap columns\n                gap_c_min = c1_max + 1\n                gap_c_max = c2_min - 1\n                \n                if gap_c_min <= gap_c_max:\n                    # Check if the gap area is entirely white\n                    gap_area = input_grid[overlap_r_min : overlap_r_max + 1, gap_c_min : gap_c_max + 1]\n                    if np.all(gap_area == 0):\n                        # Fill the gap with azure (8)\n                        output_grid[overlap_r_min : overlap_r_max + 1, gap_c_min : gap_c_max + 1] = 8\n                        \n            # --- Vertical Check ---\n            # Check for column overlap\n            overlap_c_min = max(c1_min, c2_min)\n            overlap_c_max = min(c1_max, c2_max)\n\n            if overlap_c_min <= overlap_c_max:\n                 # Define potential vertical gap rows (ensure obj1 is above obj2 for this check)\n                 # Re-assign temporarily if needed just for vertical check logic\n                 temp_obj1, temp_obj2 = obj1, obj2\n                 temp_bbox1, temp_bbox2 = bbox1, bbox2\n                 if temp_bbox1[0] > temp_bbox2[0]: # obj1 is below obj2\n                     temp_obj1, temp_obj2 = temp_obj2, temp_obj1\n                     temp_bbox1, temp_bbox2 = temp_bbox2, temp_bbox1\n                 \n                 tr1_min, tr1_max, tc1_min, tc1_max = temp_bbox1\n                 tr2_min, tr2_max, tc2_min, tc2_max = temp_bbox2\n\n                 gap_r_min = tr1_max + 1\n                 gap_r_max = tr2_min - 1\n\n                 if gap_r_min <= gap_r_max:\n                     # Check if the gap area is entirely white\n                     gap_area = input_grid[gap_r_min : gap_r_max + 1, overlap_c_min : overlap_c_max + 1]\n                     if np.all(gap_area == 0):\n                         # Fill the gap with azure (8)\n                         output_grid[gap_r_min : gap_r_max + 1, overlap_c_min : overlap_c_max + 1] = 8\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12155,
    "candidates_token_count": 1718,
    "total_token_count": 13873,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.3818,
  "retries": null
}