{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by performing the following steps:\n1.  Initializes an output grid potentially larger than the input, filled with white (0).\n2.  Identifies all distinct contiguous non-white objects in the input grid.\n3.  For each object, calculates the maximum possible downward shift (delta_r >= 0) such that the space directly below the shifted object's final position is either occupied by a non-white pixel in the *original input grid* or is the bottom edge of the original input grid. Essentially, the object \"falls\" until it lands on something or the original floor.\n4.  Determines the required height of the output grid to accommodate both the original content and all the shifted object copies.\n5.  Copies the non-white pixels from the original input grid into the correctly sized output grid.\n6.  Copies the pixels of each original object to their calculated shifted positions (original_row + delta_r, original_col) in the output grid.\n\"\"\"\n\ndef _find_objects(grid_np):\n    \"\"\"\n    Finds contiguous non-white objects in the grid using BFS.\n\n    Args:\n        grid_np (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'pixels' (list of (r, c) tuples).\n              Returns empty list if no non-white pixels are found.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from a non-white, unvisited pixel\n            if grid_np[r, c] != 0 and not visited[r, c]:\n                color = grid_np[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds and if neighbor is same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the found object to the list\n                if obj_pixels:\n                    # Sort pixels for consistency (e.g., by row then column)\n                    objects.append({'color': int(color), 'pixels': sorted(obj_pixels)}) \n\n    # Sort objects primarily by top-most row, then left-most column for deterministic processing order\n    objects.sort(key=lambda obj: obj['pixels'][0])\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the gravity transformation: copies objects downwards until they hit \n    an obstacle in the original grid or the original grid's floor.\n    Keeps the original objects in place as well. Resizes grid if necessary.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    input_rows, input_cols = input_np.shape\n\n    # 1. Find all non-white objects\n    objects = _find_objects(input_np)\n\n    # If no objects, return the original grid\n    if not objects:\n        return input_grid\n\n    object_shifts = []\n    max_shifted_row = input_rows - 1 # Track the max row index needed for shifted objects\n\n    # 2. For each object, determine its downward shift (delta_r)\n    for obj in objects:\n        obj_pixels = obj['pixels']\n        delta_r = 0\n        while True:\n            is_stable = False\n            current_max_r_for_obj = -1 # Track max row for this object at current delta_r\n            \n            # Check if the position below the object (at current delta_r) is blocked or is the floor\n            for r, c in obj_pixels:\n                current_max_r_for_obj = max(current_max_r_for_obj, r + delta_r)\n                \n                check_r = r + delta_r + 1 # Row below the pixel's potential shifted position\n                check_c = c\n\n                # Condition to stop falling:\n                # a) Reached or exceeded the original grid's bottom boundary\n                # b) The cell directly below in the *original* grid is non-white\n                if check_r >= input_rows or \\\n                   (0 <= check_r < input_rows and 0 <= check_c < input_cols and input_np[check_r, check_c] != 0):\n                    is_stable = True\n                    break # Found an obstacle or floor below this pixel, object is stable at current delta_r\n            \n            if is_stable:\n                # Found the final resting position (delta_r) for this object\n                object_shifts.append({'object': obj, 'delta_r': delta_r})\n                # Update the overall maximum row needed based on this object's final position\n                max_shifted_row = max(max_shifted_row, current_max_r_for_obj) \n                break # Move to the next object\n            else:\n                # Object can fall further, increment shift and check again\n                delta_r += 1\n\n    # 3. Determine final output grid size\n    # Required rows = max(original rows, max row reached by any shifted pixel + 1)\n    required_rows = max(input_rows, max_shifted_row + 1)\n    \n    # 4. Create the output grid, initialized to white (0)\n    output_np = np.zeros((required_rows, input_cols), dtype=int)\n\n    # 5. Copy original non-white pixels to the output grid\n    # Iterate through original grid and copy non-white cells\n    for r in range(input_rows):\n        for c in range(input_cols):\n            if input_np[r, c] != 0:\n                output_np[r, c] = input_np[r, c]\n\n    # 6. Place the shifted copies of objects onto the output grid\n    for item in object_shifts:\n        obj = item['object']\n        delta_r = item['delta_r']\n        color = obj['color']\n        \n        for r, c in obj['pixels']:\n            target_r = r + delta_r\n            target_c = c\n            # Check bounds just in case, though resizing should prevent out-of-bounds\n            if 0 <= target_r < required_rows and 0 <= target_c < input_cols:\n                 output_np[target_r, target_c] = color # Overwrite if necessary\n\n    # 7. Convert back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5485,
    "candidates_token_count": 1719,
    "total_token_count": 7204,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.518945,
  "retries": null
}