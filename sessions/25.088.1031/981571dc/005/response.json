{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by performing the following steps:\n1. Identifies all distinct contiguous non-white objects (patterns) in the input grid.\n2. For each pattern, determines the minimum required downward vertical shift (delta_r > 0) such that all pixels of the shifted pattern land on white (0) cells relative to the *original* input grid state or outside the original grid's bottom boundary.\n3. Calculates the maximum row index required to accommodate both the original grid content and all the shifted patterns.\n4. If necessary, resizes the output grid vertically, padding with white pixels, to meet the required height.\n5. Copies the pixels of each original pattern to their calculated shifted positions in the (potentially resized) output grid. The original patterns remain in place.\n\"\"\"\n\ndef _find_objects(grid_np):\n    \"\"\"\n    Finds contiguous non-white objects in the grid using BFS.\n\n    Args:\n        grid_np (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'pixels' (list of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid_np[r, c] != 0 and not visited[r, c]:\n                color = grid_np[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append({'color': int(color), 'pixels': sorted(obj_pixels)}) # Sort pixels for consistency\n\n    # Sort objects primarily by top-most row, then left-most column for deterministic processing order (though order shouldn't affect outcome here)\n    objects.sort(key=lambda obj: obj['pixels'][0])\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy() # Start with a copy\n    input_rows, input_cols = input_np.shape\n    \n    # 1. Find all non-white objects in the input\n    objects = _find_objects(input_np)\n    \n    if not objects:\n        return input_grid # No objects to move, return original\n\n    object_shifts = []\n    max_required_row = input_rows - 1 # Track the max row index needed\n\n    # 2. For each object, determine its minimum downward shift\n    for obj in objects:\n        obj_pixels = obj['pixels']\n        delta_r = 1\n        while True:\n            can_place = True\n            current_max_r_for_copy = -1 # Track max row for *this* potential copy\n            for r, c in obj_pixels:\n                target_r = r + delta_r\n                target_c = c\n                current_max_r_for_copy = max(current_max_r_for_copy, target_r)\n\n                # Check if the target location is within the *original* grid bounds\n                # AND if it lands on a non-white pixel in the *original* grid\n                if target_r < input_rows and input_np[target_r, target_c] != 0:\n                    can_place = False\n                    break # This delta_r is invalid for this object\n\n            if can_place:\n                # Found the minimum valid shift for this object\n                object_shifts.append({'object': obj, 'delta_r': delta_r})\n                # Update the overall maximum row needed for the final grid\n                max_required_row = max(max_required_row, current_max_r_for_copy)\n                break # Move to the next object\n\n            # If placement wasn't possible, try the next shift distance\n            delta_r += 1\n\n    # 3. Determine final grid size and resize if needed\n    required_rows = max_required_row + 1\n    current_rows = output_np.shape[0]\n\n    if required_rows > current_rows:\n        # Create a new larger grid filled with white (0)\n        resized_output = np.zeros((required_rows, input_cols), dtype=int)\n        # Copy the existing content into the top part\n        resized_output[:current_rows, :] = output_np\n        output_np = resized_output\n\n    # 4. Apply the shifts to copy objects onto the output grid\n    for item in object_shifts:\n        obj = item['object']\n        delta_r = item['delta_r']\n        color = obj['color']\n        \n        for r, c in obj['pixels']:\n            target_r = r + delta_r\n            target_c = c\n            # Ensure target is within the (potentially resized) output grid bounds\n            # This check should technically be redundant due to resizing, but good practice\n            if 0 <= target_r < output_np.shape[0] and 0 <= target_c < output_np.shape[1]:\n                 output_np[target_r, target_c] = color\n\n    # 5. Convert back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15683,
    "candidates_token_count": 1456,
    "total_token_count": 17139,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.422144,
  "retries": null
}