{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom itertools import combinations\n\n\"\"\"\nIdentifies all distinct 2x2 blocks of non-white pixels (Azure 8 or Red 2) in the input grid.\nFor every unique pair of these blocks:\n1. Checks if they are perfectly aligned either horizontally (same starting row) or vertically (same starting column).\n2. If aligned, checks if the rectangular region directly between them (along the alignment axis, 2 pixels thick) consists only of white (0) background pixels in the original input grid.\n3. If both conditions (alignment and clear path) are met, fills the connecting path region in the output grid with orange (7) pixels.\nThe output grid starts as a copy of the input grid and is modified by adding these orange paths.\n\"\"\"\n\ndef find_2x2_blocks(grid):\n    \"\"\"\n    Finds the top-left coordinates (r, c) of all distinct 2x2 blocks \n    formed by the same non-zero color in the grid.\n    \n    Args:\n        grid (np.ndarray): The input grid.\n        \n    Returns:\n        list: A list of tuples, where each tuple is the (row, col) \n              coordinate of the top-left corner of a 2x2 block.\n    \"\"\"\n    blocks = []\n    height, width = grid.shape\n    # Iterate through all possible top-left positions for a 2x2 block\n    for r in range(height - 1):\n        for c in range(width - 1):\n            color = grid[r, c]\n            # Check if it's a non-background color and forms a solid 2x2 block\n            if color != 0 and \\\n               grid[r + 1, c] == color and \\\n               grid[r, c + 1] == color and \\\n               grid[r + 1, c + 1] == color:\n                # Add the top-left coordinate of this block\n                blocks.append((r, c))\n    return blocks\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by drawing orange paths between aligned \n    2x2 blocks if the path between them is clear (background color).\n\n    Args:\n        input_grid (np.ndarray): The input 2D numpy array.\n\n    Returns:\n        np.ndarray: The transformed 2D numpy array.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Find all 2x2 blocks in the input grid\n    blocks = find_2x2_blocks(input_grid)\n    \n    # Define the path color\n    path_color = 7 # Orange\n\n    # Iterate through all unique pairs of blocks\n    for (r1, c1), (r2, c2) in combinations(blocks, 2):\n        \n        # Check for Vertical Alignment\n        if c1 == c2:\n            # Determine which block is on top and which is at the bottom\n            top_r = min(r1, r2)\n            bottom_r = max(r1, r2)\n            \n            # Check if there's space between the blocks vertically (more than adjacent)\n            if bottom_r > top_r + 1 + 1: # Need space of at least one row between them (top_r+2 to bottom_r-1)\n                # Define the path region coordinates (excluding the blocks themselves)\n                path_start_row = top_r + 2\n                path_end_row = bottom_r # Slicing is exclusive at the end\n                path_start_col = c1\n                path_end_col = c1 + 2 # Slicing is exclusive at the end\n                \n                # Extract the region from the original input grid\n                path_region = input_grid[path_start_row:path_end_row, path_start_col:path_end_col]\n                \n                # Check if the entire path region is background color (0)\n                if path_region.size > 0 and np.all(path_region == 0):\n                    # Draw the vertical path in the output grid\n                    output_grid[path_start_row:path_end_row, path_start_col:path_end_col] = path_color\n\n        # Check for Horizontal Alignment\n        elif r1 == r2:\n            # Determine which block is left and which is right\n            left_c = min(c1, c2)\n            right_c = max(c1, c2)\n            \n            # Check if there's space between the blocks horizontally (more than adjacent)\n            if right_c > left_c + 1 + 1: # Need space of at least one col between them (left_c+2 to right_c-1)\n                 # Define the path region coordinates (excluding the blocks themselves)\n                path_start_row = r1\n                path_end_row = r1 + 2 # Slicing is exclusive at the end\n                path_start_col = left_c + 2\n                path_end_col = right_c # Slicing is exclusive at the end\n\n                # Extract the region from the original input grid\n                path_region = input_grid[path_start_row:path_end_row, path_start_col:path_end_col]\n\n                # Check if the entire path region is background color (0)\n                if path_region.size > 0 and np.all(path_region == 0):\n                     # Draw the horizontal path in the output grid\n                    output_grid[path_start_row:path_end_row, path_start_col:path_end_col] = path_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10910,
    "candidates_token_count": 1335,
    "total_token_count": 12245,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.03505,
  "retries": null
}