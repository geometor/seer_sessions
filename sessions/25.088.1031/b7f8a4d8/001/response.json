{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple, Any\n\n\"\"\"\nIdentifies horizontally adjacent \"framed square\" objects in the input grid that share the same center color. \nFor each such qualifying pair (Square1 on the left, Square2 on the right):\n1. Fills the background pixels (color 0) between the two squares, on the same row(s) as their centers, with the shared center color.\n2. Fills a rectangular block of background pixels below the center of Square1 with the shared center color. The height of this block is 3 if the horizontal gap between the squares is exactly 3 pixels wide, otherwise the height is 2. The width of the block matches the width of the square's center. The block starts 2 rows below the square's center row(s).\n\"\"\"\n\ndef _find_framed_squares(grid: np.ndarray) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds all framed square objects (3x3 or 4x4) in the grid.\n\n    Returns:\n        A list of dictionaries, each representing a square with its properties:\n        'frame_color', 'center_color', 'center_rows', 'center_cols', 'bbox'.\n    \"\"\"\n    squares = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Check for 3x3 square starting at (r, c)\n                if r + 2 < height and c + 2 < width:\n                    subgrid = grid[r:r+3, c:c+3]\n                    frame_color = subgrid[0, 0]\n                    center_color = subgrid[1, 1]\n                    is_3x3 = True\n                    if frame_color == 0 or center_color == 0 or frame_color == center_color:\n                        is_3x3 = False\n                    else:\n                        # Check frame\n                        for i in range(3):\n                            if subgrid[0, i] != frame_color or subgrid[2, i] != frame_color or \\\n                               subgrid[i, 0] != frame_color or subgrid[i, 2] != frame_color:\n                                is_3x3 = False\n                                break\n                    \n                    if is_3x3:\n                        squares.append({\n                            'frame_color': frame_color,\n                            'center_color': center_color,\n                            'center_rows': [r + 1],\n                            'center_cols': [c + 1],\n                            'bbox': (r, c, r + 2, c + 2) # min_r, min_c, max_r, max_c (inclusive)\n                        })\n                        visited[r:r+3, c:c+3] = True\n                        continue # Found 3x3, skip 4x4 check starting here\n\n                # Check for 4x4 square starting at (r, c)\n                if r + 3 < height and c + 3 < width:\n                    subgrid = grid[r:r+4, c:c+4]\n                    frame_color = subgrid[0, 0]\n                    center_color = subgrid[1, 1]\n                    is_4x4 = True\n                    if frame_color == 0 or center_color == 0 or frame_color == center_color:\n                        is_4x4 = False\n                    else:\n                         # Check frame\n                        for i in range(4):\n                            if subgrid[0, i] != frame_color or subgrid[3, i] != frame_color or \\\n                               subgrid[i, 0] != frame_color or subgrid[i, 3] != frame_color:\n                                is_4x4 = False\n                                break\n                        # Check center 2x2\n                        if is_4x4:\n                            for i in range(1, 3):\n                                for j in range(1, 3):\n                                    if subgrid[i, j] != center_color:\n                                        is_4x4 = False\n                                        break\n                                if not is_4x4: break\n                                \n                    if is_4x4:\n                         squares.append({\n                            'frame_color': frame_color,\n                            'center_color': center_color,\n                            'center_rows': list(range(r + 1, r + 3)),\n                            'center_cols': list(range(c + 1, c + 3)),\n                            'bbox': (r, c, r + 3, c + 3) # min_r, min_c, max_r, max_c (inclusive)\n                        })\n                         visited[r:r+4, c:c+4] = True\n                         \n    # Sort squares by top-left corner (row, then column) for consistent pairing\n    squares.sort(key=lambda s: (s['bbox'][0], s['bbox'][1]))\n    return squares\n\ndef _are_horizontally_adjacent(grid: np.ndarray, sq1: Dict[str, Any], sq2: Dict[str, Any]) -> bool:\n    \"\"\"Checks if two squares are horizontally adjacent with only background in between.\"\"\"\n    bbox1 = sq1['bbox']\n    bbox2 = sq2['bbox']\n\n    # Must be in the same row span\n    if bbox1[0] != bbox2[0] or bbox1[2] != bbox2[2]:\n        return False\n\n    # sq1 must be strictly to the left of sq2\n    if bbox1[3] >= bbox2[1]:\n        return False\n\n    # Check the gap between them\n    min_r, max_r = bbox1[0], bbox1[2]\n    start_c = bbox1[3] + 1\n    end_c = bbox2[1] # Exclusive index for range\n\n    if start_c >= end_c: # No gap or touching\n        return False\n        \n    gap_slice = grid[min_r : max_r + 1, start_c : end_c]\n    \n    # Check if all cells in the gap are background (0)\n    return np.all(gap_slice == 0)\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule based on adjacent, same-center-color squares.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Step 1: Find all framed squares\n    squares = _find_framed_squares(grid)\n\n    # Step 2: Iterate through pairs of squares\n    num_squares = len(squares)\n    for i in range(num_squares):\n        for j in range(i + 1, num_squares): # Only consider pairs where sq2 is potentially to the right of sq1\n            sq1 = squares[i]\n            sq2 = squares[j]\n\n            # Step 3: Check conditions: horizontally adjacent and same center color\n            if sq1['center_color'] == sq2['center_color'] and \\\n               _are_horizontally_adjacent(grid, sq1, sq2):\n\n                fill_color = sq1['center_color']\n                bbox1 = sq1['bbox']\n                bbox2 = sq2['bbox']\n                center_rows = sq1['center_rows'] # Same as sq2's center rows due to adjacency check\n                \n                # Step 4a: Fill between the squares\n                gap_start_col = bbox1[3] + 1\n                gap_end_col = bbox2[1] # Exclusive\n                for r in center_rows:\n                    for c in range(gap_start_col, gap_end_col):\n                         # Check bounds just in case, though adjacency check should cover this\n                         if 0 <= r < height and 0 <= c < width and output_grid[r, c] == 0:\n                            output_grid[r, c] = fill_color\n\n                # Step 4b: Fill below the first square (sq1)\n                gap_width = gap_end_col - gap_start_col\n                fill_height = 3 if gap_width == 3 else 2\n                \n                S1_center_cols = sq1['center_cols']\n                fill_start_row = max(center_rows) + 2 # Start 2 rows below the center\n\n                for r_offset in range(fill_height):\n                    target_r = fill_start_row + r_offset\n                    if 0 <= target_r < height: # Check row bounds\n                        for c in S1_center_cols:\n                             if 0 <= c < width and output_grid[target_r, c] == 0: # Check column bounds and background\n                                output_grid[target_r, c] = fill_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11153,
    "candidates_token_count": 2103,
    "total_token_count": 13256,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 114.361559,
  "retries": null
}