{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by processing each distinct non-background object. For each object, it identifies its nested layers sequentially from outermost to innermost. It then swaps the colors of these layers symmetrically, assigning the innermost layer's original color to the outermost layer in the output, the second innermost color to the second outermost layer, and so on.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Identify all distinct connected components (objects) formed by non-white (0) pixels using 4-way adjacency.\n3. For each identified object:\n    a. Initialize an empty list `layers_data` to store pairs of (layer_pixels, layer_color).\n    b. Initialize `remaining_pixels` with the coordinates of all pixels in the current object.\n    c. **Iteratively Identify Layers:**\n        i. If it's the first layer, find all pixels in `remaining_pixels` that are adjacent to a background pixel (0). These form `current_layer_pixels`.\n        ii. If it's not the first layer, find all pixels in `remaining_pixels` that are adjacent to any pixel in the *previously* found layer (`layers_data[-1][0]`). These form `current_layer_pixels`.\n        iii. If `current_layer_pixels` is empty and `remaining_pixels` is not empty (e.g., the innermost core), set `current_layer_pixels` to be all `remaining_pixels`.\n        iv. If `current_layer_pixels` is empty and `remaining_pixels` is also empty, stop layer identification for this object.\n        v. Determine the `layer_color` from any pixel in `current_layer_pixels` (assuming uniform color per layer).\n        vi. Append the tuple (`current_layer_pixels`, `layer_color`) to `layers_data`.\n        vii. Remove `current_layer_pixels` from `remaining_pixels`.\n        viii. Repeat from step c.i (or c.ii).\n    d. **Swap Colors:**\n        i. Extract the sequence of original colors from `layers_data`: `original_colors = [color for _, color in layers_data]`.\n        ii. Create a reversed sequence: `reversed_colors = original_colors[::-1]`.\n        iii. Iterate through the `layers_data` and `reversed_colors`. For the i-th layer (`layer_pixels`, _) in `layers_data`, get the i-th color from `reversed_colors`.\n        iv. Update the `output_grid`: For each pixel (r, c) in `layer_pixels`, set `output_grid[r, c]` to the corresponding `reversed_color`.\n4. Return the modified `output_grid`.\n\"\"\"\n\ndef get_neighbors(r, c, h, w):\n    \"\"\" Get valid 4-way neighbors for a cell \"\"\"\n    neighbors = []\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dr, dc in moves:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects(grid):\n    \"\"\" Finds connected components of non-background (0) pixels using BFS \"\"\"\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c)) # Add the starting pixel\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    for nr, nc in get_neighbors(curr_r, curr_c, h, w):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc)) # Add connected pixel\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by swapping the colors of symmetric layers within each object.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1. Identify all distinct objects\n    objects = find_objects(input_grid)\n\n    # 2. Process each object\n    for obj_coords in objects:\n        layers_data = [] # Stores tuples: (set_of_layer_pixels, layer_color)\n        remaining_pixels = obj_coords.copy()\n\n        # 3. Identify layers sequentially\n        while remaining_pixels:\n            current_layer_pixels = set()\n\n            if not layers_data: # Finding Layer 1 (adjacent to background)\n                for r, c in remaining_pixels:\n                    is_outer_layer_pixel = False\n                    for nr, nc in get_neighbors(r, c, h, w):\n                        # Check if neighbor is outside the object OR is background\n                        if (nr, nc) not in obj_coords or input_grid[nr, nc] == 0:\n                           is_outer_layer_pixel = True\n                           break\n                    if is_outer_layer_pixel:\n                        current_layer_pixels.add((r, c))\n            else: # Finding Layer k > 1 (adjacent to previous layer)\n                previous_layer_pixels = layers_data[-1][0]\n                # Candidate pixels are those remaining\n                candidates = remaining_pixels\n                # Check adjacency to the *exact* set of previous layer pixels\n                for r, c in candidates:\n                    is_adjacent_to_prev = False\n                    for nr, nc in get_neighbors(r, c, h, w):\n                        if (nr, nc) in previous_layer_pixels:\n                            is_adjacent_to_prev = True\n                            break\n                    if is_adjacent_to_prev:\n                        current_layer_pixels.add((r, c))\n\n            # Handle the innermost core if layer finding yields empty but pixels remain\n            if not current_layer_pixels and remaining_pixels:\n                 current_layer_pixels = remaining_pixels.copy()\n\n            if not current_layer_pixels:\n                 # No more layers can be found\n                 break\n\n            # Determine layer color (assuming uniform color per layer)\n            # Take color from the first pixel found for this layer\n            layer_color = input_grid[list(current_layer_pixels)[0]]\n\n            # Store layer data\n            layers_data.append((current_layer_pixels, layer_color))\n\n            # Update remaining pixels\n            remaining_pixels -= current_layer_pixels\n\n        # 4. Swap colors if layers were found\n        if layers_data:\n            original_colors = [color for _, color in layers_data]\n            reversed_colors = original_colors[::-1]\n\n            if len(layers_data) == len(reversed_colors):\n                for i, (layer_pixels, _) in enumerate(layers_data):\n                    new_color = reversed_colors[i]\n                    for r, c in layer_pixels:\n                        output_grid[r, c] = new_color\n            else:\n                 # This case indicates an issue in layer detection\n                 print(f\"Warning: Mismatch between detected layers ({len(layers_data)}) and reversed colors ({len(reversed_colors)}). Skipping transformation for this object.\")\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12474,
    "candidates_token_count": 1803,
    "total_token_count": 14277,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.721995,
  "retries": null
}