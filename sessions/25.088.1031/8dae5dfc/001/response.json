{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nProcesses multi-colored objects composed of nested rectangular layers by swapping the colors of symmetric layers.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Identify all distinct connected components (objects) formed by non-white (0) pixels in the input grid.\n3. For each identified object:\n    a. Determine the sequence of layers and their corresponding colors, starting from the outermost layer and proceeding inwards. This is done by iteratively identifying and \"peeling\" the boundary pixels of the remaining object part.\n    b. Extract the sequence of colors corresponding to these layers.\n    c. Create a reversed sequence of these layer colors.\n    d. Iterate through the identified layers (from outermost to innermost) and the reversed color sequence simultaneously.\n    e. For each layer, update the color of all pixels belonging to that layer in the output grid using the corresponding color from the reversed sequence.\n4. Return the modified output grid.\n\"\"\"\n\ndef get_neighbors(r, c, h, w, connectivity=4):\n    \"\"\" Get valid neighbors for a cell \"\"\"\n    neighbors = []\n    if connectivity == 4:\n        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    # Add connectivity=8 if needed later\n    # elif connectivity == 8:\n    #     moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    else:\n        raise ValueError(\"Unsupported connectivity\")\n\n    for dr, dc in moves:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects(grid):\n    \"\"\" Finds connected components of non-background (0) pixels \"\"\"\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_coords.add((curr_r, curr_c))\n                    for nr, nc in get_neighbors(curr_r, curr_c, h, w):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by swapping the colors of symmetric layers within each object.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # Find all distinct objects (connected components of non-zero pixels)\n    objects = find_objects(input_grid)\n\n    for obj_coords in objects:\n        # Process each object to find its layers and swap colors\n\n        # Make a working copy of the object's pixel coordinates\n        current_object_pixels = obj_coords.copy()\n        layers_data = [] # Stores tuples: (set_of_layer_pixels, layer_color)\n\n        while current_object_pixels:\n            # Identify boundary pixels of the *remaining* object part\n            # Boundary pixels are adjacent (4-way) to a pixel NOT in current_object_pixels\n            boundary_pixels = set()\n            for r, c in current_object_pixels:\n                is_boundary = False\n                for nr, nc in get_neighbors(r, c, h, w):\n                    if (nr, nc) not in current_object_pixels:\n                        is_boundary = True\n                        break\n                if is_boundary:\n                    boundary_pixels.add((r, c))\n            \n            if not boundary_pixels:\n                 # This might happen if the remaining object is fully contained\n                 # Or if it's the very last pixel(s)\n                 boundary_pixels = current_object_pixels.copy() # Treat remaining as the last layer\n\n\n            # Assume layer has uniform color (as per examples)\n            # Get color from one of the boundary pixels\n            if boundary_pixels:\n              layer_color = input_grid[list(boundary_pixels)[0]]\n              layers_data.append((boundary_pixels, layer_color))\n              # Remove the found layer pixels for the next iteration\n              current_object_pixels -= boundary_pixels\n            else:\n              # Should not happen with the fix above, but as a safeguard\n              break\n\n\n        # Now we have layers_data = [(layer1_pixels, color1), (layer2_pixels, color2), ...]\n        # Extract colors and reverse them\n        layer_colors = [color for _, color in layers_data]\n        reversed_layer_colors = layer_colors[::-1]\n\n        # Apply the reversed colors back to the layers in the output grid\n        if len(layers_data) == len(reversed_layer_colors):\n            for i, (layer_pixels, _) in enumerate(layers_data):\n                new_color = reversed_layer_colors[i]\n                for r, c in layer_pixels:\n                    output_grid[r, c] = new_color\n        else:\n            # This case indicates an issue in layer detection or assumptions\n            print(\"Warning: Mismatch between detected layers and reversed colors. Skipping transformation for this object.\")\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7320,
    "candidates_token_count": 1361,
    "total_token_count": 8681,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.704772,
  "retries": null
}