{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by processing each distinct non-background object. For each object, it identifies its nested layers by iteratively \"peeling\" from the outermost layer inwards based on adjacency to pixels outside the currently remaining part of the object. It then swaps the colors of these layers symmetrically, assigning the innermost layer's original color to the outermost layer in the output, the second innermost color to the second outermost layer, and so on.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Identify all distinct connected components (objects) formed by non-white (0) pixels using 4-way adjacency.\n3. For each identified object:\n    a. Initialize an empty list `layers_data` to store pairs of (set_of_layer_pixels, layer_color).\n    b. Initialize `remaining_object_pixels` with the coordinates of all pixels in the current object.\n    c. **Iteratively Identify Layers (Peeling):**\n        i. While `remaining_object_pixels` is not empty:\n            A. Find all pixels in `remaining_object_pixels` that have at least one neighbor (4-way adjacent) which is *not* currently in `remaining_object_pixels`. These neighbors can be background pixels (0) or pixels belonging to previously identified layers of the *same* object.\n            B. Store these identified pixels as `current_layer_pixels`.\n            C. If `current_layer_pixels` is empty but `remaining_object_pixels` is not (e.g., disconnected inner core after peeling), treat all remaining pixels as the last layer.\n            D. If `current_layer_pixels` is empty (and `remaining_object_pixels` is also empty), break the inner loop.\n            E. Determine the `layer_color` from the first pixel in `current_layer_pixels` (assuming uniform color per layer based on examples).\n            F. Append the tuple (`current_layer_pixels`, `layer_color`) to `layers_data`.\n            G. Remove `current_layer_pixels` from `remaining_object_pixels`.\n    d. **Swap Colors:**\n        i. Extract the sequence of original colors from `layers_data`: `original_colors = [color for _, color in layers_data]`.\n        ii. Create a reversed sequence: `reversed_colors = original_colors[::-1]`.\n        iii. Iterate through the `layers_data` and `reversed_colors`. For the i-th layer (`layer_pixels`, _) in `layers_data`, get the i-th color from `reversed_colors`.\n        iv. Update the `output_grid`: For each pixel (r, c) in `layer_pixels`, set `output_grid[r, c]` to the corresponding `reversed_color`.\n4. Return the modified `output_grid`.\n\"\"\"\n\ndef get_neighbors(r, c, h, w):\n    \"\"\" Get valid 4-way neighbors for a cell (coordinates only) \"\"\"\n    neighbors = []\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dr, dc in moves:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects(grid):\n    \"\"\" Finds connected components of non-background (0) pixels using BFS \"\"\"\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = [] # List to store sets of coordinates for each object\n\n    for r in range(h):\n        for c in range(w):\n            # Start BFS if we find an unvisited non-background pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_coords.add((curr_r, curr_c)) # Add the pixel to the current object\n\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(curr_r, curr_c, h, w):\n                        # Add neighbor to queue if it's part of the object and not visited\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the completed object's coordinates to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by swapping the colors of symmetric layers within each object,\n    identifying layers using an iterative peeling method.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1. Identify all distinct objects (connected components of non-background pixels)\n    objects = find_objects(input_grid)\n\n    # 2. Process each identified object independently\n    for obj_coords in objects:\n        layers_data = [] # Stores tuples: (set_of_layer_pixels, layer_color)\n        remaining_object_pixels = obj_coords.copy() # Keep track of pixels not yet assigned to a layer\n\n        # 3. Iteratively Identify Layers by \"Peeling\" from the outside in\n        while remaining_object_pixels:\n            current_layer_pixels = set()\n            \n            # Identify pixels in the remaining set that are adjacent to pixels *outside* the remaining set\n            for r, c in remaining_object_pixels:\n                is_boundary_pixel = False\n                for nr, nc in get_neighbors(r, c, h, w):\n                    # A pixel is on the boundary if any neighbor is not in the remaining set\n                    if (nr, nc) not in remaining_object_pixels:\n                        is_boundary_pixel = True\n                        break\n                if is_boundary_pixel:\n                    current_layer_pixels.add((r, c))\n\n            # If peeling doesn't find boundary pixels but pixels remain, they form the innermost core(s).\n            # Assign all remaining pixels to the current (last) layer.\n            if not current_layer_pixels and remaining_object_pixels:\n                 current_layer_pixels = remaining_object_pixels.copy()\n\n            # If no pixels were identified for the layer (and none remain), stop peeling.\n            if not current_layer_pixels:\n                 break\n\n            # Determine the color of the layer (assuming uniform color per layer based on examples)\n            # Take the color of the first pixel found in this layer.\n            try:\n                # Get an arbitrary pixel from the set to determine the layer's color\n                first_pixel_r, first_pixel_c = next(iter(current_layer_pixels))\n                layer_color = input_grid[first_pixel_r, first_pixel_c]\n            except StopIteration:\n                 # This should not happen if current_layer_pixels is not empty. Safety break.\n                 print(f\"Warning: Could not determine layer color for object containing {obj_coords}. Skipping object.\")\n                 break \n\n            # Store the identified layer's pixels and original color\n            layers_data.append((current_layer_pixels, layer_color))\n\n            # Remove the identified layer's pixels from the set of remaining pixels\n            remaining_object_pixels -= current_layer_pixels\n\n        # 4. Swap colors symmetrically if layers were successfully identified\n        if layers_data:\n            original_colors = [color for _, color in layers_data]\n            reversed_colors = original_colors[::-1]\n\n            # Ensure the number of layers matches the number of reversed colors\n            # This check might fail for complex shapes with holes, but examples seem simpler\n            if len(layers_data) == len(reversed_colors):\n                # Iterate through the identified layers and apply the corresponding reversed color\n                for i, (layer_pixels, _) in enumerate(layers_data):\n                    new_color = reversed_colors[i]\n                    for r, c in layer_pixels:\n                        # Update the output grid with the new color\n                        output_grid[r, c] = new_color\n            else:\n                 # Handle potential mismatch (e.g., complex shapes), though not expected based on examples\n                 print(f\"Warning: Layer count ({len(layers_data)}) mismatch with reversed colors ({len(reversed_colors)}). Applying partial transformation.\")\n                 min_len = min(len(layers_data), len(reversed_colors))\n                 for i in range(min_len):\n                     layer_pixels = layers_data[i][0]\n                     new_color = reversed_colors[i]\n                     for r, c in layer_pixels:\n                         output_grid[r, c] = new_color\n\n    # Convert the final grid back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10632,
    "candidates_token_count": 2079,
    "total_token_count": 12711,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 67.976735,
  "retries": null
}