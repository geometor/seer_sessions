{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# Define colors based on the problem description (mapping integers to names for clarity)\n# COLOR_MAP = {0: 'white', 1: 'blue', 2: 'red', 3: 'green', 4: 'yellow', 5: 'gray', 6: 'magenta', 7: 'orange', 8: 'azure', 9: 'maroon'}\nWHITE = 0\nBLUE = 1\nGREEN = 3\nAZURE = 8\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all distinct connected objects of a given color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[list[tuple[int, int]]]: A list of objects, where each object\n                                      is a list of its coordinate tuples (row, col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start BFS to find a new object\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_coords:\n                    objects.append(obj_coords)\n                    \n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box of an object.\n\n    Args:\n        obj_coords (list[tuple[int, int]]): List of coordinates for the object.\n\n    Returns:\n        tuple[int, int, int, int]: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    if not obj_coords:\n        return None # Or raise an error\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef is_bottom_heavy(obj_coords, bbox):\n    \"\"\"Checks if the object touches the bottom edge but not the top edge of its bounding box.\"\"\"\n    min_r, _, max_r, _ = bbox\n    touches_bottom = any(r == max_r for r, c in obj_coords)\n    touches_top = any(r == min_r for r, c in obj_coords)\n    return touches_bottom and not touches_top\n\ndef has_hole(grid, obj_coords, bbox):\n    \"\"\"Checks if the object encloses any background (white) pixels.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    rows, cols = grid.shape\n    \n    # Quick check: if bbox is too small to have an interior, no hole\n    if max_r - min_r < 2 or max_c - min_c < 2:\n        return False\n\n    obj_set = set(obj_coords)\n    visited = set()\n    q = deque()\n\n    # Start BFS from all background pixels on the bounding box border\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if r == min_r or r == max_r or c == min_c or c == max_c:\n                 # Consider only background pixels within the actual grid bounds\n                if 0 <= r < rows and 0 <= c < cols and grid[r, c] == WHITE:\n                    if (r,c) not in visited:\n                        q.append((r, c))\n                        visited.add((r, c))\n                # Also consider pixels just outside the bounding box as starting points for the \"outside\" region\n                # Check direct neighbors of bbox border pixels\n                for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n                    nr, nc = r+dr, c+dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == WHITE:\n                         if (nr, nc) not in visited:\n                             q.append((nr, nc))\n                             visited.add((nr, nc))\n\n\n    # Also start BFS from the grid edges if they are close to the bbox\n    # This ensures we capture the full 'outside' region connectivity\n    for r in range(rows):\n        if grid[r, 0] == WHITE and (r, 0) not in visited: q.append((r, 0)); visited.add((r,0))\n        if grid[r, cols-1] == WHITE and (r, cols-1) not in visited: q.append((r, cols-1)); visited.add((r, cols-1))\n    for c in range(cols):\n        if grid[0, c] == WHITE and (0, c) not in visited: q.append((0, c)); visited.add((0,c))\n        if grid[rows-1, c] == WHITE and (rows-1, c) not in visited: q.append((rows-1, c)); visited.add((rows-1, c))\n\n\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check neighbor validity (within grid, is background, not object, not visited)\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == WHITE and \\\n               (nr, nc) not in obj_set and \\\n               (nr, nc) not in visited:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    # Check for any background pixel inside the bounding box that wasn't visited\n    # These are pixels disconnected from the outside -> hole\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            if grid[r, c] == WHITE and (r, c) not in visited and (r,c) not in obj_set:\n                return True\n                \n    return False\n\n\ndef has_stem(obj_coords, bbox):\n    \"\"\"Checks if the object touches the bottom edge of its bounding box with 1 or 2 pixels.\"\"\"\n    _, _, max_r, _ = bbox\n    bottom_pixels = [ (r,c) for r,c in obj_coords if r == max_r ]\n    count = len(bottom_pixels)\n    return count == 1 or count == 2\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies green objects in the input grid, analyzes their shape properties \n    (bottom-heavy, has hole, has stem), and creates a copy of each object. \n    The copy's color (blue or azure) and position (below or right of the original) \n    are determined by these properties.\n\n    1. Initialize the output grid as a copy of the input grid.\n    2. Find all distinct green objects.\n    3. For each green object:\n        a. Calculate its bounding box.\n        b. Check if it's bottom-heavy (touches bottom bbox edge but not top).\n        c. Check if it has an internal hole (enclosed white pixels).\n        d. Check if it has a stem (1 or 2 pixels touching bottom bbox edge).\n        e. Determine copy position: Below if bottom-heavy, Right otherwise (with 1px gap).\n        f. Determine copy color:\n            - Right -> Blue\n            - Below: Blue if (has_hole and has_stem), Azure otherwise.\n        g. Draw the copy onto the output grid.\n    4. Return the modified output grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # Find all green objects\n    green_objects = find_objects(input_grid, GREEN)\n\n    # Process each object\n    for obj_coords in green_objects:\n        # Calculate properties\n        bbox = get_bounding_box(obj_coords)\n        min_r, min_c, max_r, max_c = bbox\n        \n        bottom_heavy = is_bottom_heavy(obj_coords, bbox)\n        # Note: Use input_grid for has_hole check as output_grid might be modified\n        hole = has_hole(input_grid, obj_coords, bbox) \n        stem = has_stem(obj_coords, bbox)\n\n        # Determine copy placement and color\n        copy_color = -1 # Initialize with invalid color\n        offset_r, offset_c = 0, 0 # Offset from original top-left to copy top-left\n\n        if bottom_heavy:\n            # Place Below\n            offset_r = (max_r - min_r) + 2 # Start row is max_r + 2, relative to min_r\n            offset_c = 0                  # Start col is min_c, relative to min_c\n            if hole and stem:\n                copy_color = BLUE\n            else:\n                copy_color = AZURE\n        else:\n            # Place Right\n            offset_r = 0                  # Start row is min_r, relative to min_r\n            offset_c = (max_c - min_c) + 2 # Start col is max_c + 2, relative to min_c\n            copy_color = BLUE\n            \n        # Create the copy if color is valid\n        if copy_color != -1:\n            for r, c in obj_coords:\n                # Calculate relative position within the object's bounding box\n                rel_r = r - min_r\n                rel_c = c - min_c\n                \n                # Calculate target position in the output grid\n                target_r = min_r + offset_r + rel_r\n                target_c = min_c + offset_c + rel_c\n                \n                # Draw the pixel if within grid bounds\n                if 0 <= target_r < rows and 0 <= target_c < cols:\n                    # Important: Check if target location is currently background (white)\n                    # This prevents overwriting parts of other original objects if copies overlap originals slightly\n                    # Based on examples, copies don't seem to overwrite originals, but might overwrite background\n                    # Let's assume copies can overwrite background but not existing colored pixels from originals.\n                    # Example 1 output shows the '8' copy starting near the original 'T'.\n                    # Example 3 output shows '1' copy near original 'G'.\n                    # Example 2 output shows '1' near 'C' and '8' near 'G'.\n                    # It seems safe to draw the copy regardless of what's there, as long as it's within bounds.\n                    # The problem doesn't specify behavior for overlapping copies - assume last one drawn wins.\n                    output_grid[target_r, target_c] = copy_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7312,
    "candidates_token_count": 2735,
    "total_token_count": 10047,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.463678,
  "retries": null
}