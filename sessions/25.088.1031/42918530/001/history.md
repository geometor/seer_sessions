
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 0 8 8 8 8 8 0 4 4 4 4 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 0 4 0 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 4 4 4 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 0 4 0 4 0
0 3 3 3 3 3 0 8 8 8 8 8 0 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 4 4 4 0 2 2 2 2 2 0 7 7 7 7 7 0
0 4 0 0 0 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 0 0 0 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 0 0 0 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 4 4 4 4 0 2 2 2 2 2 0 7 7 7 7 7 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 0 8 8 8 8 8 0 4 4 4 4 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 0 4 0 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 4 4 4 4 0
0 3 0 0 0 3 0 8 0 0 0 8 0 4 0 4 0 4 0
0 3 3 3 3 3 0 8 8 8 8 8 0 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 4 4 4 0 2 2 2 2 2 0 7 7 7 7 7 0
0 4 0 4 0 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 4 4 4 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 0 4 0 4 0 2 0 0 0 2 0 7 0 0 0 7 0
0 4 4 4 4 4 0 2 2 2 2 2 0 7 7 7 7 7 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 4 4 4 4 4 0 8 8 8 8 8 0
0 2 0 2 0 2 0 4 0 0 0 4 0 8 0 0 0 8 0
0 2 2 2 0 2 0 4 0 0 0 4 0 8 0 8 0 8 0
0 2 0 0 0 2 0 4 0 0 0 4 0 8 0 0 0 8 0
0 2 2 2 2 2 0 4 4 4 4 4 0 8 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 3 3 3 3 3 0 1 1 1 1 1 0
0 8 0 0 0 8 0 3 0 0 0 3 0 1 0 0 0 1 0
0 8 0 0 0 8 0 3 0 3 3 3 0 1 0 0 0 1 0
0 8 0 0 0 8 0 3 0 3 0 3 0 1 0 0 0 1 0
0 8 8 8 8 8 0 3 3 3 3 3 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 1 1 1 1 1 0 2 2 2 2 2 0
0 2 0 0 0 2 0 1 0 0 0 1 0 2 0 0 0 2 0
0 2 0 0 0 2 0 1 0 0 0 1 0 2 0 0 0 2 0
0 2 0 0 0 2 0 1 0 0 0 1 0 2 0 0 0 2 0
0 2 2 2 2 2 0 1 1 1 1 1 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 4 4 4 4 4 0 8 8 8 8 8 0
0 2 0 2 0 2 0 4 0 0 0 4 0 8 0 0 0 8 0
0 2 2 2 0 2 0 4 0 0 0 4 0 8 0 8 0 8 0
0 2 0 0 0 2 0 4 0 0 0 4 0 8 0 0 0 8 0
0 2 2 2 2 2 0 4 4 4 4 4 0 8 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 3 3 3 3 3 0 1 1 1 1 1 0
0 8 0 0 0 8 0 3 0 0 0 3 0 1 0 0 0 1 0
0 8 0 8 0 8 0 3 0 3 3 3 0 1 0 0 0 1 0
0 8 0 0 0 8 0 3 0 3 0 3 0 1 0 0 0 1 0
0 8 8 8 8 8 0 3 3 3 3 3 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 1 1 1 1 1 0 2 2 2 2 2 0
0 2 0 2 0 2 0 1 0 0 0 1 0 2 0 2 0 2 0
0 2 2 2 0 2 0 1 0 0 0 1 0 2 2 2 0 2 0
0 2 0 0 0 2 0 1 0 0 0 1 0 2 0 0 0 2 0
0 2 2 2 2 2 0 1 1 1 1 1 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 6 6 6 6 6 0 2 2 2 2 2 0
0 2 0 2 0 2 0 6 0 0 0 6 0 2 0 0 0 2 0
0 2 2 2 2 2 0 6 0 0 0 6 0 2 0 0 0 2 0
0 2 0 0 0 2 0 6 0 0 0 6 0 2 0 0 0 2 0
0 2 2 2 2 2 0 6 6 6 6 6 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 3 3 3 3 3 0 8 8 8 8 8 0
0 8 0 0 0 8 0 3 0 0 0 3 0 8 0 0 0 8 0
0 8 0 8 8 8 0 3 3 3 3 3 0 8 0 0 0 8 0
0 8 0 8 0 8 0 3 0 0 0 3 0 8 0 0 0 8 0
0 8 8 8 8 8 0 3 3 3 3 3 0 8 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 6 6 6 0 2 2 2 2 2 0 4 4 4 4 4 0
0 6 0 6 0 6 0 2 0 0 0 2 0 4 0 0 0 4 0
0 6 0 6 0 6 0 2 0 0 0 2 0 4 0 4 0 4 0
0 6 0 0 0 6 0 2 0 0 0 2 0 4 0 0 0 4 0
0 6 6 6 6 6 0 2 2 2 2 2 0 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 0 5 5 5 5 5 0 2 2 2 2 2 0
0 1 0 1 0 1 0 5 0 0 0 5 0 2 0 0 0 2 0
0 1 0 1 0 1 0 5 0 0 0 5 0 2 0 0 0 2 0
0 1 1 0 1 1 0 5 0 0 0 5 0 2 0 0 0 2 0
0 1 1 1 1 1 0 5 5 5 5 5 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 6 6 6 6 6 0 2 2 2 2 2 0
0 2 0 2 0 2 0 6 0 6 0 6 0 2 0 2 0 2 0
0 2 2 2 2 2 0 6 0 6 0 6 0 2 2 2 2 2 0
0 2 0 0 0 2 0 6 0 0 0 6 0 2 0 0 0 2 0
0 2 2 2 2 2 0 6 6 6 6 6 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 3 3 3 3 3 0 8 8 8 8 8 0
0 8 0 0 0 8 0 3 0 0 0 3 0 8 0 0 0 8 0
0 8 0 8 8 8 0 3 3 3 3 3 0 8 0 8 8 8 0
0 8 0 8 0 8 0 3 0 0 0 3 0 8 0 8 0 8 0
0 8 8 8 8 8 0 3 3 3 3 3 0 8 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 6 6 6 0 2 2 2 2 2 0 4 4 4 4 4 0
0 6 0 6 0 6 0 2 0 2 0 2 0 4 0 0 0 4 0
0 6 0 6 0 6 0 2 2 2 2 2 0 4 0 4 0 4 0
0 6 0 0 0 6 0 2 0 0 0 2 0 4 0 0 0 4 0
0 6 6 6 6 6 0 2 2 2 2 2 0 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 0 5 5 5 5 5 0 2 2 2 2 2 0
0 1 0 1 0 1 0 5 0 0 0 5 0 2 0 2 0 2 0
0 1 0 1 0 1 0 5 0 0 0 5 0 2 2 2 2 2 0
0 1 1 0 1 1 0 5 0 0 0 5 0 2 0 0 0 2 0
0 1 1 1 1 1 0 5 5 5 5 5 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 0 3 3 3 3 3 0 2 2 2 2 2 0
0 3 0 0 0 3 0 3 0 0 0 3 0 2 0 0 0 2 0
0 3 0 0 0 3 0 3 0 3 0 3 0 2 0 0 0 2 0
0 3 0 0 0 3 0 3 0 0 0 3 0 2 0 0 0 2 0
0 3 3 3 3 3 0 3 3 3 3 3 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 8 8 8 8 8 0 1 1 1 1 1 0
0 2 0 0 0 2 0 8 0 0 0 8 0 1 0 1 0 1 0
0 2 0 0 0 2 0 8 8 8 8 8 0 1 1 1 0 1 0
0 2 0 0 0 2 0 8 0 0 0 8 0 1 0 0 0 1 0
0 2 2 2 2 2 0 8 8 8 8 8 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 2 2 2 2 2 0 1 1 1 1 1 0
0 8 0 0 0 8 0 2 0 2 0 2 0 1 0 0 0 1 0
0 8 0 0 0 8 0 2 2 2 2 2 0 1 0 0 0 1 0
0 8 0 0 0 8 0 2 0 2 0 2 0 1 0 0 0 1 0
0 8 8 8 8 8 0 2 2 2 2 2 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 0 3 3 3 3 3 0 2 2 2 2 2 0
0 3 0 0 0 3 0 3 0 0 0 3 0 2 0 2 0 2 0
0 3 0 3 0 3 0 3 0 3 0 3 0 2 2 2 2 2 0
0 3 0 0 0 3 0 3 0 0 0 3 0 2 0 2 0 2 0
0 3 3 3 3 3 0 3 3 3 3 3 0 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 0 8 8 8 8 8 0 1 1 1 1 1 0
0 2 0 2 0 2 0 8 0 0 0 8 0 1 0 1 0 1 0
0 2 2 2 2 2 0 8 8 8 8 8 0 1 1 1 0 1 0
0 2 0 2 0 2 0 8 0 0 0 8 0 1 0 0 0 1 0
0 2 2 2 2 2 0 8 8 8 8 8 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 0 2 2 2 2 2 0 1 1 1 1 1 0
0 8 0 0 0 8 0 2 0 2 0 2 0 1 0 1 0 1 0
0 8 8 8 8 8 0 2 2 2 2 2 0 1 1 1 0 1 0
0 8 0 0 0 8 0 2 0 2 0 2 0 1 0 0 0 1 0
0 8 8 8 8 8 0 2 2 2 2 2 0 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception:**

The input grids consist of a white (0) background containing multiple distinct rectangular objects. Each object is defined by a solid colored border (colors vary: green, azure, yellow, red, orange, magenta, blue, gray) enclosing a pattern of internal white pixels. The objects are separated from each other by at least one row/column of white pixels.

The transformation modifies the *interior* of these colored objects. Specifically, it identifies contiguous areas of white pixels that are completely surrounded by the object's colored border (i.e., these white pixels are not reachable from the main white background outside the object without crossing the colored border). These "enclosed" or "internal hole" white areas are then filled with the color of the object's border. White pixels within an object that *are* connected to the external background remain white. The colored borders themselves and the external white background remain unchanged.

**Facts:**


```yaml
elements:
  - object: grid
    description: A 2D array of pixels with integer values 0-9 representing colors.
  - object: background
    description: The main area of the grid, typically represented by white pixels (0).
  - object: shape
    description: A contiguous block of non-white pixels forming a border, often rectangular.
    properties:
      - color: The color of the border pixels (non-zero value).
      - location: Position within the grid.
      - boundary: The pixels forming the outer edge of the shape.
      - interior: The area enclosed by the boundary.
  - object: internal_white_area
    description: A contiguous area of white pixels (0) located within the interior of a shape.
    properties:
      - location: Position within a shape's interior.
      - connectivity: Whether the area is connected to the external background via a path of white pixels.
  - object: enclosed_white_area (hole)
    description: An internal_white_area that is not connected to the external background. It is completely surrounded by the shape's colored pixels.

relationships:
  - type: containment
    subject: internal_white_area
    object: shape
    description: Internal white areas exist within the boundaries of shapes.
  - type: adjacency
    subject: internal_white_area
    object: background
    description: Some internal white areas may be adjacent to (connected to) the external background through paths of white pixels.
  - type: separation
    subject: enclosed_white_area
    object: background
    description: Enclosed white areas are separated from the external background by the shape's colored pixels.

actions:
  - action: identify
    subject: shapes
    description: Locate all distinct colored shapes within the input grid.
  - action: identify
    subject: internal_white_areas
    within: each shape
    description: Locate all areas of white pixels inside each identified shape.
  - action: check_connectivity
    subject: internal_white_areas
    target: background
    description: Determine if each internal white area has a path of white pixels connecting it to the main background outside the shape.
  - action: fill
    subject: enclosed_white_areas
    color: Use the color of the surrounding shape's border.
    description: Change the color of pixels belonging to enclosed white areas (those not connected to the background) to match the color of the shape's border.

transformation:
  - step: Iterate through each pixel of the input grid.
  - step: If a white pixel (0) is found, check if it belongs to an enclosed area.
  - step: To check for enclosure, perform a reachability analysis (e.g., flood fill or BFS) starting from that white pixel, only moving through other white pixels.
  - step: If the reachability analysis cannot reach any pixel on the absolute border of the grid (meaning it's trapped within a colored shape), then this white pixel belongs to an enclosed area.
  - step: Identify the color of the adjacent non-white pixels (this will be the color of the enclosing shape).
  - step: In the output grid, change the color of this pixel (and all other white pixels identified as part of the same enclosed area) to the color of the enclosing shape.
  - step: If a white pixel *can* reach the grid border, or if the pixel is non-white, copy its color directly from the input to the output grid.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all contiguous areas of white pixels (0) in the input grid.
3.  For each distinct white area:
    a.  Determine if this area touches the outer border of the entire grid (row 0, last row, column 0, or last column).
    b.  If the white area *does not* touch the grid border, it means it is potentially enclosed within a shape.
    c.  Find a non-white pixel adjacent to any pixel in this enclosed white area. This adjacent pixel's color is the "fill color".
    d.  Change the color of all pixels belonging to this enclosed white area in the output grid to the determined "fill color".
4.  White areas that *do* touch the grid border remain unchanged (they keep the color 0).
5.  Non-white pixels remain unchanged.
6.  Return the modified output grid.
