{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Find the unique 3x3 block in the input grid that contains the color yellow (4). This is the 'source pattern', and note its top-left coordinate.\n2. Initialize an empty list to store the coordinates of 'destination blocks' and a variable to track the maximum similarity found so far (initialized to -1).\n3. Iterate through all possible top-left coordinates (r, c) for a 3x3 block in the input grid.\n4. For each potential block at (r, c):\n    a. Check if (r, c) is the coordinate of the source pattern block. If it is, skip this block.\n    b. Extract the 3x3 block starting at (r, c).\n    c. Calculate the similarity between this block and the source pattern. Similarity is defined as the number of cells that have the same color in the same position within the 3x3 block.\n    d. Compare the calculated similarity with the current maximum similarity:\n        i. If the current similarity is greater than the maximum similarity, update the maximum similarity to this value and reset the list of destination coordinates to contain only the current (r, c).\n        ii. If the current similarity is equal to the maximum similarity, add the current (r, c) to the list of destination coordinates.\n5. Create the output grid by making a copy of the input grid.\n6. Iterate through the list of destination coordinates identified in step 4.\n7. For each destination coordinate (dest_r, dest_c), overwrite the 3x3 region starting at (dest_r, dest_c) in the output grid with the source pattern found in step 1.\n8. Return the modified output grid.\n\"\"\"\n\ndef find_3x3_block_containing_color(grid, color_value):\n    \"\"\"\n    Finds the first 3x3 block in the grid containing the specified color.\n\n    Args:\n        grid (np.array): The input grid.\n        color_value (int): The color value to search for within a 3x3 block.\n\n    Returns:\n        tuple: A tuple containing the content (np.array) of the 3x3 block\n               and its top-left coordinates (row, col). Returns (None, None)\n               if no such block is found.\n    \"\"\"\n    height, width = grid.shape\n    # Iterate through all possible top-left corners of a 3x3 block\n    for r in range(height - 2):\n        for c in range(width - 2):\n            block = grid[r:r+3, c:c+3]\n            # Check if the color exists within the current block\n            if np.any(block == color_value):\n                return block, (r, c)\n    return None, None # Should not happen based on task examples\n\ndef calculate_similarity(block1, block2):\n    \"\"\"\n    Calculates the similarity between two 3x3 blocks.\n    Similarity is the number of cells with the same value at the same position.\n\n    Args:\n        block1 (np.array): The first 3x3 block.\n        block2 (np.array): The second 3x3 block.\n\n    Returns:\n        int: The similarity score (0 to 9).\n    \"\"\"\n    if block1 is None or block2 is None or block1.shape != (3, 3) or block2.shape != (3, 3):\n       # Handle potential errors gracefully, though constraints suggest valid blocks\n       return 0\n    return np.sum(block1 == block2)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding a source pattern (containing yellow)\n    and replacing the 3x3 blocks most similar to it (excluding itself)\n    with the source pattern.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # 1. Find the source pattern (unique 3x3 block containing yellow - 4)\n    source_pattern, source_coord = find_3x3_block_containing_color(input_np, 4)\n\n    # Handle the unlikely case where the source pattern isn't found\n    if source_pattern is None:\n        print(\"Warning: Source pattern (containing yellow) not found.\")\n        return input_grid # Return original grid if no source found\n\n    # 2. Find all destination locations (blocks most similar to source_pattern)\n    max_similarity = -1\n    destination_coords = []\n\n    # 3. Iterate through all possible top-left corners of a 3x3 block\n    for r in range(height - 2):\n        for c in range(width - 2):\n            # 4a. Skip the source block itself\n            if (r, c) == source_coord:\n                continue\n\n            # 4b. Get the current block\n            current_block = input_np[r:r+3, c:c+3]\n\n            # 4c. Calculate similarity\n            similarity = calculate_similarity(source_pattern, current_block)\n\n            # 4d. Update max similarity and destination list\n            if similarity > max_similarity:\n                max_similarity = similarity\n                destination_coords = [(r, c)] # Start a new list with this coord\n            elif similarity == max_similarity:\n                # Only add if max_similarity is not -1 (meaning we've found at least one similar block)\n                if max_similarity != -1:\n                    destination_coords.append((r, c)) # Add to existing list\n\n    # 6. & 7. Perform the copy-paste onto destination locations\n    if destination_coords: # Check if any destinations were found\n        for dest_r, dest_c in destination_coords:\n            # Overwrite the 3x3 area at the destination with the source pattern\n            output_grid[dest_r:dest_r+3, dest_c:dest_c+3] = source_pattern\n\n    # 8. Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14180,
    "candidates_token_count": 1470,
    "total_token_count": 15650,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.026153,
  "retries": null
}