{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\n\n\"\"\"\nThis transformation identifies distinct connected objects of green pixels (value 3)\nin the input grid using 8-way adjacency. If two or more such objects exist,\nit draws straight lines (using Bresenham's algorithm) between every pair of \npixels (p1, p2) where p1 belongs to one object and p2 belongs to a different \nobject. All pixels lying on these lines are colored green in the output grid. \nThe original green pixels are preserved. If there are zero or one green objects \nin the input, the output grid is identical to the input grid.\n\nNote: This rule is derived primarily from examples train_1 and train_3. \nExample train_2, which contains only one object, exhibits a different output \npattern not fully explained by this rule. This implementation follows the \nrule derived from the multi-object examples.\n\"\"\"\n\ndef bresenham_line(r0, c0, r1, c1):\n    \"\"\"\n    Generates pixel coordinates for a line segment between (r0, c0) and (r1, c1)\n    using Bresenham's line algorithm.\n    \n    Args:\n        r0, c0: Coordinates of the starting point.\n        r1, c1: Coordinates of the ending point.\n        \n    Returns:\n        A list of (row, col) tuples representing the pixels on the line segment.\n    \"\"\"\n    points = []\n    dr = abs(r1 - r0)\n    dc = abs(c1 - c0)\n    # Determine step direction\n    sr = 1 if r0 < r1 else -1\n    sc = 1 if c0 < c1 else -1\n    # Initialize error term\n    err = dr - dc\n\n    # Current position starts at (r0, c0)\n    cr, cc = r0, c0 \n\n    while True:\n        points.append((cr, cc))\n        # Stop when the end point is reached\n        if cr == r1 and cc == c1:\n            break\n        \n        # Calculate error adjustments for next step\n        e2 = 2 * err\n        if e2 > -dc: # Check if step in row direction is needed\n            err -= dc\n            cr += sr\n        if e2 < dr:  # Check if step in column direction is needed\n            err += dr\n            cc += sc\n            \n    return points\n\ndef find_objects(grid, target_color):\n    \"\"\"\n    Identifies connected components (objects) of a specified color in a grid.\n    Uses 8-way connectivity (pixels touching sides or corners are connected).\n    \n    Args:\n        grid: The input numpy array grid.\n        target_color: The integer color value to find objects of.\n        \n    Returns:\n        A list of sets. Each set contains the (row, col) tuples of pixels \n        belonging to one distinct connected object. Returns an empty list if\n        no objects are found.\n    \"\"\"\n    # Create a binary mask where target_color pixels are True\n    binary_grid = (grid == target_color)\n    \n    # Define the connectivity structure (8-way)\n    # [[True, True, True],\n    #  [True, True, True],\n    #  [True, True, True]]\n    structure = generate_binary_structure(rank=2, connectivity=2) \n    \n    # Label the connected components in the binary grid\n    # labeled_grid assigns a unique integer ID (starting from 1) to each component\n    # num_labels is the total number of components found\n    labeled_grid, num_labels = label(binary_grid, structure=structure)\n    \n    objects = []\n    if num_labels > 0:\n        # Extract the coordinates for each labeled component\n        # np.argwhere returns an array of [row, col] pairs for each label\n        # We iterate from label 1 up to num_labels\n        object_coords = [np.argwhere(labeled_grid == i) for i in range(1, num_labels + 1)]\n        \n        # Convert the coordinates for each object into a set of (row, col) tuples\n        objects = [set(map(tuple, coords)) for coords in object_coords]\n        \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds green objects and draws lines between\n    pixels of different objects if multiple objects exist.\n    \n    Args:\n        input_grid: A numpy array representing the input grid.\n        \n    Returns:\n        A numpy array representing the output grid after applying the transformation.\n    \"\"\"\n    \n    # Define the color of interest\n    green_color = 3\n    \n    # Find all distinct connected green objects\n    objects = find_objects(input_grid, green_color)\n    num_objects = len(objects)\n    \n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # --- Transformation Logic ---\n    \n    # Only proceed if there are 2 or more objects\n    if num_objects >= 2:\n        \n        # Iterate through all unique pairs of distinct objects\n        # Example: If objects are [O1, O2, O3], pairs are (O1, O2), (O1, O3), (O2, O3)\n        for i in range(num_objects):\n            for j in range(i + 1, num_objects):\n                # Get the sets of pixels for the two objects in the current pair\n                object1_pixels = objects[i]\n                object2_pixels = objects[j]\n                \n                # Iterate through every pixel p1 in the first object\n                for p1 in object1_pixels:\n                    # Iterate through every pixel p2 in the second object\n                    for p2 in object2_pixels:\n                        # Get coordinates for the pair of pixels\n                        r1, c1 = p1\n                        r2, c2 = p2\n                        \n                        # Calculate the pixels forming the line segment between p1 and p2\n                        line_pixels = bresenham_line(r1, c1, r2, c2)\n                        \n                        # Color each pixel on the calculated line segment green\n                        for r, c in line_pixels:\n                            # Ensure coordinates are within grid bounds (safety check)\n                            if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                                output_grid[r, c] = green_color\n                                \n    # If num_objects is 0 or 1, no lines are drawn between objects,\n    # so the output_grid remains the initial copy of input_grid.\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17556,
    "candidates_token_count": 1565,
    "total_token_count": 19121,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.518332,
  "retries": null
}