{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies hollow rectangular frames in the input grid and fills their interior.\nFor each frame found:\n1. Determine the color of the frame.\n2. Define the rectangular region strictly inside the frame.\n3. For every pixel within this interior region:\n    If the pixel's original color (from the input grid) is not white (0), \n    change its color in the output grid to the frame's color.\nPixels on the frame itself or outside any frame remain unchanged.\nWhite pixels inside frames also remain unchanged.\n\"\"\"\n\ndef _find_frames(grid):\n    \"\"\"\n    Finds all hollow rectangular frames made of a single non-white color in the grid.\n\n    A hollow rectangular frame is defined as:\n    - A connected component of a single non-white color.\n    - The component's pixels perfectly form the perimeter of its bounding box.\n    - The bounding box must have height > 1 and width > 1.\n    - The area strictly inside the bounding box must contain at least one pixel\n      that is *not* the frame's color (ensuring hollowness).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a frame:\n              (frame_color, min_row, min_col, max_row, max_col)\n    \"\"\"\n    frames = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool) # Keep track of pixels already assigned to a component\n\n    for r in range(height):\n        for c in range(width):\n            # Start search if pixel is non-white and not part of a previously found component\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_pixels = set() # Store pixels belonging to this component\n                q = deque([(r, c)])      # Queue for BFS\n                visited[r, c] = True     # Mark starting pixel as visited\n                min_r, min_c = r, c      # Initialize bounding box\n                max_r, max_c = r, c\n\n                # --- Step 1: Find the connected component using BFS ---\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_pixels.add((curr_r, curr_c))\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, color match, and if visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True # Mark neighbor visited\n                            q.append((nr, nc))     # Add to queue\n\n                # --- Step 2: Validate if the component is a hollow rectangular frame ---\n                \n                # Basic dimension check: must be larger than a line\n                if not ((max_r - min_r) > 0 and (max_c - min_c) > 0):\n                    continue # Not a potential frame with an interior\n\n                is_perfect_perimeter = True\n                is_hollow = False\n                \n                # Check all pixels within the bounding box\n                for i in range(min_r, max_r + 1):\n                    for j in range(min_c, max_c + 1):\n                        is_on_perimeter = (i == min_r or i == max_r or j == min_c or j == max_c)\n                        \n                        if is_on_perimeter:\n                            # Check 1: All perimeter pixels must be part of the component\n                            if (i, j) not in component_pixels:\n                                is_perfect_perimeter = False\n                                break\n                        else: # Pixel is in the interior\n                            # Check 2: Interior pixels must NOT be part of the component\n                            if (i, j) in component_pixels:\n                                is_perfect_perimeter = False\n                                break\n                            # Check 3: At least one interior pixel must differ from frame color for hollowness\n                            if grid[i,j] != color:\n                                is_hollow = True\n                                \n                    if not is_perfect_perimeter:\n                        break # Exit outer loop if perfection check fails\n\n                # If it forms a perfect perimeter and is hollow, it's a valid frame\n                if is_perfect_perimeter and is_hollow:\n                    frames.append((color, min_r, min_c, max_r, max_c))\n\n    return frames\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies hollow rectangular frames in the input grid and fills their interior.\n    For each frame found: determines the frame's color, defines the interior region,\n    and changes any non-white pixel within that interior region to the frame's color.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid_np = np.copy(input_grid_np)\n\n    # Find all valid hollow rectangular frames in the input grid\n    frames = _find_frames(input_grid_np)\n\n    # Process each found frame\n    for frame_color, r1, c1, r2, c2 in frames:\n        # Iterate through the coordinates strictly *inside* the frame's perimeter\n        # Interior rows: r1 + 1 to r2 (exclusive of r2)\n        # Interior columns: c1 + 1 to c2 (exclusive of c2)\n        for r in range(r1 + 1, r2):\n            for c in range(c1 + 1, c2):\n                # Check the color of the pixel in the *original* input grid\n                original_color = input_grid_np[r, c]\n                \n                # If the original pixel was not white (0)\n                if original_color != 0:\n                    # Change the corresponding pixel in the output grid to the frame's color\n                    output_grid_np[r, c] = frame_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7865,
    "candidates_token_count": 1601,
    "total_token_count": 9466,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 54.970241,
  "retries": null
}