{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies solid-color rectangular frames and fills their interiors based on specific rules.\n1. Find all rectangular frames: A frame is a connected component of a single non-white color where all its pixels lie exactly on the perimeter of its bounding box, and the bounding box has both height > 1 and width > 1.\n2. Sort frames by area: Calculate the area of each frame's bounding box and sort the frames from smallest area to largest.\n3. Fill interiors sequentially: Iterate through the sorted frames (smallest first). For each frame, iterate through the pixels strictly inside its bounding box (the interior). If an interior pixel's color in the *original* input grid was not white (0), change its color in the *output* grid to the color of the current frame being processed. This allows smaller, inner frames to determine the color first, which might then be overwritten by larger, outer frames if the pixel is also inside the larger frame's interior.\n4. Preserve original pixels: Pixels on the frames themselves, white pixels inside frames, and pixels outside all frames retain their original colors.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_frames(grid):\n    \"\"\"\n    Finds all rectangular frames made of a single non-white color in the grid.\n\n    A rectangular frame is defined as:\n    - A connected component of a single non-white color.\n    - The component's pixels perfectly form the perimeter of its bounding box.\n    - The bounding box must have height > 1 and width > 1.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a frame:\n              (frame_color, min_row, min_col, max_row, max_col)\n    \"\"\"\n    frames = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool) # Keep track of pixels already assigned to a component\n\n    for r in range(height):\n        for c in range(width):\n            # Start search if pixel is non-white and not part of a previously found component\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_pixels = set() # Store pixels belonging to this component\n                q = deque([(r, c)])      # Queue for BFS\n                visited[r, c] = True     # Mark starting pixel as visited\n                min_r, min_c = r, c      # Initialize bounding box\n                max_r, max_c = r, c\n\n                # --- Step 1: Find the connected component using BFS ---\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_pixels.add((curr_r, curr_c))\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, color match, and if visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True # Mark neighbor visited\n                            q.append((nr, nc))     # Add to queue\n\n                # --- Step 2: Validate if the component is a rectangular frame ---\n\n                # Basic dimension check: must be larger than a line\n                frame_height = max_r - min_r + 1\n                frame_width = max_c - min_c + 1\n                if not (frame_height > 1 and frame_width > 1):\n                    continue # Not a potential frame (must have interior space)\n\n                is_perfect_perimeter = True\n                # Check all pixels within the bounding box\n                for i in range(min_r, max_r + 1):\n                    for j in range(min_c, max_c + 1):\n                        is_on_perimeter = (i == min_r or i == max_r or j == min_c or j == max_c)\n\n                        if is_on_perimeter:\n                            # Check 1: All perimeter pixels must be part of the component\n                            if (i, j) not in component_pixels:\n                                is_perfect_perimeter = False\n                                break\n                        else: # Pixel is in the interior\n                            # Check 2: Interior pixels must NOT be part of the component\n                            if (i, j) in component_pixels:\n                                is_perfect_perimeter = False\n                                break\n                    if not is_perfect_perimeter:\n                        break # Exit outer loop if perfection check fails\n\n                # Check 3: Ensure the number of pixels matches the perimeter calculation\n                # (This is a redundant check if the above loops complete successfully, but can catch edge cases)\n                # expected_perimeter_pixels = 2 * (frame_width + frame_height - 2) # 2*w + 2*(h-2)\n                # Simplified: 2 * (width difference + height difference) = 2 * ((max_c-min_c) + (max_r-min_r))\n                expected_perimeter_pixels = 2 * ( (max_c-min_c) + (max_r-min_r) )\n                if len(component_pixels) != expected_perimeter_pixels:\n                     is_perfect_perimeter = False # Mismatch in pixel count vs perimeter size\n\n\n                # If it forms a perfect perimeter, it's a valid frame\n                if is_perfect_perimeter:\n                    frames.append({\n                        'color': color,\n                        'r1': min_r, 'c1': min_c, 'r2': max_r, 'c2': max_c,\n                        'area': frame_width * frame_height # Use bounding box area for sorting\n                    })\n\n    return frames\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the frame filling transformation to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input grid for checks\n    output_grid_np = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # Find all valid rectangular frames in the input grid\n    frames = _find_frames(input_grid_np)\n\n    # Sort frames by area, smallest first\n    frames.sort(key=lambda f: f['area'])\n\n    # Process each found frame in sorted order\n    for frame in frames:\n        frame_color = frame['color']\n        r1, c1, r2, c2 = frame['r1'], frame['c1'], frame['r2'], frame['c2']\n\n        # Iterate through the coordinates strictly *inside* the frame's perimeter\n        # Interior rows: r1 + 1 to r2 (exclusive) -> range(r1 + 1, r2)\n        # Interior columns: c1 + 1 to c2 (exclusive) -> range(c1 + 1, c2)\n        for r in range(r1 + 1, r2):\n            for c in range(c1 + 1, c2):\n                # Check bounds just in case (should be guaranteed by frame definition)\n                if 0 <= r < height and 0 <= c < width:\n                    # Check the color of the pixel in the *original* input grid\n                    original_color = input_grid_np[r, c]\n\n                    # If the original pixel was not white (0)\n                    if original_color != 0:\n                        # Change the corresponding pixel in the output grid to the frame's color\n                        output_grid_np[r, c] = frame_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15776,
    "candidates_token_count": 1955,
    "total_token_count": 17731,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.183734,
  "retries": null
}