{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nFill an expanded bounding box area around a central figure with a specific color derived from the figure's center, where the expansion amount depends on the figure's outer frame color.\n\n1.  Identify all non-white (color > 0) pixels in the input grid.\n2.  Calculate the minimal bounding box enclosing these pixels.\n3.  Determine the 'fill_color' from the pixel at the geometric center of the bounding box.\n4.  Determine the 'frame_color' - the non-white color adjacent to the background (0).\n5.  Determine the 'expansion_amount' (N) based on the 'frame_color' using a specific mapping {1:1, 3:1, 4:2, 5:3, 6:2}.\n6.  Calculate the expanded bounding box by extending the minimal box by N pixels outwards, clamped to grid boundaries.\n7.  Create a copy of the input grid.\n8.  Fill all pixels within the expanded bounding box that were originally white (0) in the input grid with the 'fill_color'.\n9.  Return the modified grid.\n\"\"\"\n\ndef find_non_white_pixels(grid):\n    \"\"\"Finds coordinates (row, col) of all pixels with value > 0.\"\"\"\n    non_white_coords = np.argwhere(grid > 0)\n    if non_white_coords.size == 0:\n        return None\n    return non_white_coords\n\ndef find_bounding_box(non_white_coords):\n    \"\"\"Calculates the min/max row/col for the bounding box.\"\"\"\n    if non_white_coords is None or non_white_coords.size == 0:\n        return None\n    min_r = np.min(non_white_coords[:, 0])\n    max_r = np.max(non_white_coords[:, 0])\n    min_c = np.min(non_white_coords[:, 1])\n    max_c = np.max(non_white_coords[:, 1])\n    return min_r, max_r, min_c, max_c\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid 8-directional neighbor coordinates within grid bounds.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_fill_color(grid, bbox):\n    \"\"\"Determines the fill color from the center of the bounding box.\"\"\"\n    if bbox is None:\n        return 0 # Default to background if no figure\n    min_r, max_r, min_c, max_c = bbox\n    center_r = (min_r + max_r) / 2\n    center_c = (min_c + max_c) / 2\n    # Use floor to get the top-left pixel if center is between pixels\n    center_pixel_r = int(np.floor(center_r))\n    center_pixel_c = int(np.floor(center_c))\n    # Ensure coordinates are within bounds (though they should be if bbox is valid)\n    height, width = grid.shape\n    center_pixel_r = max(0, min(center_pixel_r, height - 1))\n    center_pixel_c = max(0, min(center_pixel_c, width - 1))\n    \n    return grid[center_pixel_r, center_pixel_c]\n\ndef find_frame_color(grid, non_white_coords):\n    \"\"\"Determines the color touching the background.\"\"\"\n    if non_white_coords is None:\n        return None \n        \n    height, width = grid.shape\n    frame_colors = set()\n    \n    for r, c in non_white_coords:\n        color = grid[r,c]\n        # Optimization: if this color is already found, skip checking its neighbors again\n        if color in frame_colors:\n             continue\n             \n        is_frame_pixel = False\n        for nr, nc in get_neighbors(r, c, height, width):\n            if grid[nr, nc] == 0: # Check if any neighbor is background\n                is_frame_pixel = True\n                break\n        if is_frame_pixel:\n            frame_colors.add(color)\n\n    if len(frame_colors) == 1:\n        return list(frame_colors)[0]\n    elif len(frame_colors) == 0:\n         # This case might happen if the non-white object fills the whole grid\n         # or if there's only one color which doesn't touch the edges.\n         # Based on examples, we expect exactly one frame color.\n         # If no color touches the *outer* background, maybe it's the most frequent *outer* color?\n         # For now, return None or a default if ambiguity arises.\n         # Let's find the most frequent color among non-white as a fallback?\n         if non_white_coords.size > 0:\n             colors, counts = np.unique(grid[non_white_coords[:,0], non_white_coords[:,1]], return_counts=True)\n             return colors[np.argmax(counts)] # Return most frequent non-white color\n         return None # No non-white pixels at all\n    else: # More than one frame color found - ambiguity\n         # Fallback: return the most frequent frame color among the candidates.\n         candidate_counts = {}\n         all_colors = grid[non_white_coords[:,0], non_white_coords[:,1]]\n         for color in frame_colors:\n             candidate_counts[color] = np.sum(all_colors == color)\n         most_frequent_frame_color = max(candidate_counts, key=candidate_counts.get)\n         # print(f\"Warning: Multiple frame colors {frame_colors}. Using most frequent: {most_frequent_frame_color}\")\n         return most_frequent_frame_color\n\ndef get_expansion_amount(frame_color):\n    \"\"\"Gets the expansion amount N based on the frame color.\"\"\"\n    expansion_map = {\n        1: 1, # Blue\n        3: 1, # Green\n        4: 2, # Yellow\n        5: 3, # Gray\n        6: 2  # Magenta\n    }\n    # Default to 1 if color not in map or frame_color is None/0\n    return expansion_map.get(frame_color, 1) \n\ndef transform(input_grid):\n    # Convert input to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Find all non-white pixels\n    non_white_coords = find_non_white_pixels(input_np)\n\n    # If no object pixels found, return the original grid\n    if non_white_coords is None:\n        return input_grid\n\n    # 2. Calculate the minimal bounding box\n    bbox = find_bounding_box(non_white_coords)\n    if bbox is None: # Should not happen if non_white_coords is not None\n         return input_grid \n    min_r, max_r, min_c, max_c = bbox\n\n    # 3. Determine the 'fill_color' from the center\n    fill_color = find_fill_color(input_np, bbox)\n    # If center somehow lands on background, need a fallback.\n    # Let's use the most frequent non-white color in the bounding box as fallback.\n    if fill_color == 0:\n         box_pixels = input_np[min_r:max_r+1, min_c:max_c+1]\n         colors, counts = np.unique(box_pixels[box_pixels > 0], return_counts=True)\n         if colors.size > 0:\n             fill_color = colors[np.argmax(counts)]\n         else: # Should not happen if bbox is valid\n             fill_color = 1 # Absolute fallback\n\n    # 4. Determine the 'frame_color'\n    frame_color = find_frame_color(input_np, non_white_coords)\n    # Handle case where frame_color couldn't be determined (e.g., solid block)\n    if frame_color is None:\n        # Maybe default expansion if frame color cannot be found?\n        # Let's try using the fill_color to determine expansion as a fallback.\n        frame_color = fill_color # Use fill_color as substitute to get an expansion value\n        # print(\"Warning: Could not determine unique frame color. Using fill color for expansion.\")\n\n\n    # 5. Determine the 'expansion_amount' (N)\n    expansion_amount = get_expansion_amount(frame_color)\n\n    # 6. Calculate the expanded bounding box coordinates, clamped to grid bounds\n    exp_min_r = max(0, min_r - expansion_amount)\n    exp_max_r = min(height - 1, max_r + expansion_amount)\n    exp_min_c = max(0, min_c - expansion_amount)\n    exp_max_c = min(width - 1, max_c + expansion_amount)\n\n    # 7. Create a copy of the input grid for modification\n    output_np = np.copy(input_np)\n\n    # 8. & 9. Iterate within expanded bounding box and fill white pixels\n    for r in range(exp_min_r, exp_max_r + 1):\n        for c in range(exp_min_c, exp_max_c + 1):\n            # Check original pixel color at this location\n            if input_np[r, c] == 0:\n                # If it was white, fill with fill_color in the output\n                output_np[r, c] = fill_color\n\n    # 10. Return the result, converted back to list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23290,
    "candidates_token_count": 2369,
    "total_token_count": 25659,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.413262,
  "retries": null
}