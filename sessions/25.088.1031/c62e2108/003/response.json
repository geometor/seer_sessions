{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTiles patterns across the grid based on instructions provided by aligned blue markers.\n\n1. Identifies \"patterns\" (contiguous non-white, non-blue shapes) and their bounding boxes.\n2. Identifies \"markers\" (4-pixel blue 1x4 or 4x1 lines) and their orientation/bounding boxes.\n3. Creates a working copy of the grid.\n4. Removes markers from the working grid (changes their pixels to white).\n5. Extracts the \"tile\" (content within the pattern's bounding box) for each pattern from the marker-removed working grid.\n6. Associates markers with patterns based on alignment:\n    - Horizontal marker aligns if its column span matches the pattern's bbox column span. Direction is 'up' if marker is above pattern, 'down' if below.\n    - Vertical marker aligns if its row span matches the pattern's bbox row span. Direction is 'left' if marker is left of pattern, 'right' if right.\n7. For each pattern and its associated direction(s), tiles the extracted pattern tile repeatedly in that direction, starting from the pattern's edge, until the grid boundary is reached. Handles partial tiles at boundaries.\n8. Returns the modified working grid.\n\"\"\"\n\ndef _find_connected_components(grid, ignore_colors=None):\n    \"\"\"Finds all connected components of the same color, ignoring specified colors.\"\"\"\n    if ignore_colors is None:\n        ignore_colors = set()\n    \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] not in ignore_colors:\n                color = grid[r, c]\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component_pixels:\n                    components.append({'color': color, 'pixels': component_pixels})\n    return components\n\ndef _get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols) # r_min, c_min, r_max, c_max\n\ndef _is_marker(component):\n    \"\"\"Checks if a blue component is a 1x4 or 4x1 marker.\"\"\"\n    if component['color'] != 1 or len(component['pixels']) != 4:\n        return False, None, None # Not a potential marker\n\n    bbox = _get_bounding_box(component['pixels'])\n    if not bbox:\n         return False, None, None\n\n    r_min, c_min, r_max, c_max = bbox\n    height = r_max - r_min + 1\n    width = c_max - c_min + 1\n    \n    # Check for 1x4 horizontal marker\n    if height == 1 and width == 4:\n         # Extra check for contiguity just in case bbox calculation hides gaps, though unlikely with BFS\n         is_contiguous = all((r_min, c) in component['pixels'] for c in range(c_min, c_max + 1))\n         if is_contiguous:\n             return True, 'horizontal', bbox\n\n    # Check for 4x1 vertical marker\n    if height == 4 and width == 1:\n        # Extra check for contiguity\n        is_contiguous = all((r, c_min) in component['pixels'] for r in range(r_min, r_max + 1))\n        if is_contiguous:\n             return True, 'vertical', bbox\n\n    return False, None, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern tiling transformation based on aligned markers.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # --- 1. Object Identification ---\n    # Find all connected components, initially ignoring only white background\n    all_components = _find_connected_components(input_np, ignore_colors={0}) \n\n    patterns = []\n    markers = []\n    # Identify patterns and markers from the components\n    for comp in all_components:\n        is_marker_flag, orientation, marker_bbox = _is_marker(comp)\n        if is_marker_flag:\n            comp['orientation'] = orientation\n            comp['bbox'] = marker_bbox\n            markers.append(comp)\n        elif comp['color'] != 1: # Pattern if not white (ignored) and not blue (marker candidate)\n            bbox = _get_bounding_box(comp['pixels'])\n            if bbox:\n                comp['bbox'] = bbox\n                patterns.append(comp)\n\n    # --- 2. Marker Removal ---\n    # Modify the output grid by changing marker pixels to white\n    for marker in markers:\n        for r, c in marker['pixels']:\n            if 0 <= r < rows and 0 <= c < cols: # Bounds check just in case\n                output_np[r, c] = 0 \n\n    # --- 3. Tile Extraction ---\n    # Extract tiles *after* markers are removed\n    pattern_tiles = {}\n    for i, pattern in enumerate(patterns):\n        r_min, c_min, r_max, c_max = pattern['bbox']\n        # Ensure slicing is within bounds if bbox touches edge\n        r_start, r_end = max(0, r_min), min(rows, r_max + 1)\n        c_start, c_end = max(0, c_min), min(cols, c_max + 1)\n        if r_start < r_end and c_start < c_end: # Check if valid dimensions remain\n            pattern_tiles[i] = np.copy(output_np[r_start:r_end, c_start:c_end])\n        else:\n             pattern_tiles[i] = None # Handle edge case where pattern might be off-grid? (unlikely)\n\n    # --- 4. Association and Tiling ---\n    for i, pattern in enumerate(patterns):\n        if pattern_tiles[i] is None: # Skip if tile couldn't be extracted\n            continue\n            \n        p_r_min, p_c_min, p_r_max, p_c_max = pattern['bbox']\n        tile_to_copy = pattern_tiles[i]\n        pattern_h, pattern_w = tile_to_copy.shape\n        \n        # Find associated directions based on alignment\n        associated_directions = set()\n        for marker in markers:\n            m_r_min, m_c_min, m_r_max, m_c_max = marker['bbox']\n            \n            # Check Horizontal Marker Alignment (Up/Down)\n            if marker['orientation'] == 'horizontal':\n                 # Check if column spans align\n                 if m_c_min == p_c_min and m_c_max == p_c_max:\n                     # Check relative row position\n                     if m_r_min < p_r_min: # Marker is above pattern\n                         associated_directions.add('up')\n                     elif m_r_min > p_r_max: # Marker is below pattern\n                         associated_directions.add('down')\n\n            # Check Vertical Marker Alignment (Left/Right)\n            elif marker['orientation'] == 'vertical':\n                 # Check if row spans align\n                 if m_r_min == p_r_min and m_r_max == p_r_max:\n                     # Check relative column position\n                     if m_c_min < p_c_min: # Marker is left of pattern\n                         associated_directions.add('left')\n                     elif m_c_min > p_c_max: # Marker is right of pattern\n                         associated_directions.add('right')\n\n        # Perform tiling for each associated direction\n        \n        # Up Tiling\n        if 'up' in associated_directions:\n            curr_r = p_r_min - pattern_h # Start row for the top-left corner of the first tile *above*\n            while curr_r + pattern_h > 0: # While *any part* of the tile is potentially on grid upwards\n                target_r_start = max(0, curr_r)\n                target_r_end = min(rows, curr_r + pattern_h)\n                tile_r_start = max(0, -curr_r) # Which part of the source tile to copy\n                tile_r_end = tile_r_start + (target_r_end - target_r_start)\n\n                if target_r_start < target_r_end: # If there's vertical space to copy into\n                     output_np[target_r_start : target_r_end, p_c_min : p_c_min + pattern_w] = \\\n                         tile_to_copy[tile_r_start : tile_r_end, :]\n                \n                if curr_r < 0: # Optimization: if we started partially off grid, we are done upwards\n                    break\n                    \n                curr_r -= pattern_h # Move to the next position above\n\n        # Down Tiling\n        if 'down' in associated_directions:\n            curr_r = p_r_max + 1 # Start row for the top-left corner of the first tile *below*\n            while curr_r < rows: # While the starting row is within the grid\n                target_r_start = curr_r\n                target_r_end = min(rows, curr_r + pattern_h)\n                tile_r_end = target_r_end - target_r_start # How much vertical height to copy from tile\n\n                if tile_r_end > 0:\n                    output_np[target_r_start : target_r_end, p_c_min : p_c_min + pattern_w] = \\\n                        tile_to_copy[0 : tile_r_end, :]\n                \n                curr_r += pattern_h # Move to the next position below\n                if target_r_end == rows: # Optimization: if we hit the bottom edge, we are done\n                    break\n\n        # Left Tiling\n        if 'left' in associated_directions:\n            curr_c = p_c_min - pattern_w # Start col for the top-left corner of the first tile *left*\n            while curr_c + pattern_w > 0: # While *any part* of the tile is potentially on grid leftwards\n                target_c_start = max(0, curr_c)\n                target_c_end = min(cols, curr_c + pattern_w)\n                tile_c_start = max(0, -curr_c) # Which part of the source tile to copy\n                tile_c_end = tile_c_start + (target_c_end - target_c_start)\n\n                if target_c_start < target_c_end: # If there's horizontal space to copy into\n                     output_np[p_r_min : p_r_min + pattern_h, target_c_start : target_c_end] = \\\n                         tile_to_copy[:, tile_c_start : tile_c_end]\n                \n                if curr_c < 0: # Optimization\n                    break\n                    \n                curr_c -= pattern_w # Move to the next position left\n\n        # Right Tiling\n        if 'right' in associated_directions:\n            curr_c = p_c_max + 1 # Start col for the top-left corner of the first tile *right*\n            while curr_c < cols: # While the starting col is within the grid\n                target_c_start = curr_c\n                target_c_end = min(cols, curr_c + pattern_w)\n                tile_c_end = target_c_end - target_c_start # How much horizontal width to copy\n\n                if tile_c_end > 0:\n                    output_np[p_r_min : p_r_min + pattern_h, target_c_start : target_c_end] = \\\n                        tile_to_copy[:, 0 : tile_c_end]\n                \n                curr_c += pattern_w # Move to the next position right\n                if target_c_end == cols: # Optimization\n                    break\n\n\n    # --- 5. Output ---\n    # Convert final numpy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17119,
    "candidates_token_count": 3100,
    "total_token_count": 20219,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.778882,
  "retries": null
}