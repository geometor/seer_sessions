{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on pattern tiling rules indicated by blue markers.\n\n1.  Identifies contiguous blocks of non-white (0) and non-blue (1) pixels (\"patterns\").\n2.  Identifies horizontal (1x4) and vertical (4x1) lines of blue (1) pixels (\"markers\").\n3.  Determines the association between markers and patterns: a marker is associated if it lies immediately adjacent to and perfectly aligned with one side of a pattern's bounding box.\n4.  Initializes the output grid as a copy of the input grid.\n5.  Removes all blue markers from the output grid by changing their color to white (0).\n6.  For each pattern, based on its associated markers, tiles (repeats) the pattern's bounding box content (including background pixels within the box) in the indicated direction(s) (up, down, left, right).\n7.  Tiling extends from the pattern's edge towards the grid boundary along the rows/columns defined by the pattern's bounding box.\n8.  Returns the modified grid.\n\"\"\"\n\ndef _find_connected_components(grid, ignore_colors=None):\n    \"\"\"Finds all connected components of the same color, ignoring specified colors.\"\"\"\n    if ignore_colors is None:\n        ignore_colors = set()\n    \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] not in ignore_colors:\n                color = grid[r, c]\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component_pixels:\n                    components.append({'color': color, 'pixels': component_pixels})\n    return components\n\ndef _get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef _is_marker(component):\n    \"\"\"Checks if a blue component is a 1x4 or 4x1 marker.\"\"\"\n    if component['color'] != 1 or len(component['pixels']) != 4:\n        return False, None # Not a potential marker\n\n    pixels = sorted(list(component['pixels']))\n    rows = sorted(list(set(r for r, c in pixels)))\n    cols = sorted(list(set(c for r, c in pixels)))\n\n    # Check for 1x4 horizontal marker\n    if len(rows) == 1 and len(cols) == 4 and cols[-1] - cols[0] == 3:\n         # Check contiguity\n        expected_pixels = set((rows[0], c) for c in range(cols[0], cols[0] + 4))\n        if component['pixels'] == expected_pixels:\n             return True, 'horizontal'\n            \n    # Check for 4x1 vertical marker\n    if len(rows) == 4 and len(cols) == 1 and rows[-1] - rows[0] == 3:\n        # Check contiguity\n        expected_pixels = set((r, cols[0]) for r in range(rows[0], rows[0] + 4))\n        if component['pixels'] == expected_pixels:\n            return True, 'vertical'\n\n    return False, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern tiling transformation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # Find all connected components\n    all_components = _find_connected_components(input_np, ignore_colors={0}) # Ignore white initially\n\n    # Identify patterns and markers\n    patterns = []\n    markers = []\n    for comp in all_components:\n        is_marker_flag, orientation = _is_marker(comp)\n        if is_marker_flag:\n            comp['orientation'] = orientation\n            markers.append(comp)\n        elif comp['color'] != 1: # Pattern if not white (ignored) and not blue (marker)\n            bbox = _get_bounding_box(comp['pixels'])\n            if bbox:\n                comp['bbox'] = bbox\n                patterns.append(comp)\n\n    # --- State Change 1: Remove markers from the output grid ---\n    for marker in markers:\n        for r, c in marker['pixels']:\n            output_np[r, c] = 0 # Set marker pixels to white\n\n    # Store initial pattern tiles (after marker removal)\n    initial_tiles = {}\n    for i, pattern in enumerate(patterns):\n        r_min, c_min, r_max, c_max = pattern['bbox']\n        initial_tiles[i] = np.copy(output_np[r_min:r_max+1, c_min:c_max+1])\n\n\n    # --- State Change 2: Tile patterns based on associated markers ---\n    for i, pattern in enumerate(patterns):\n        r_min, c_min, r_max, c_max = pattern['bbox']\n        pattern_h = r_max - r_min + 1\n        pattern_w = c_max - c_min + 1\n        \n        # Use the stored initial tile for copying\n        tile_to_copy = initial_tiles[i] \n\n        # Check for associated markers and perform tiling\n        associated_directions = set()\n\n        for marker in markers:\n            marker_pixels = marker['pixels']\n            \n            # Check Up Association\n            if marker['orientation'] == 'horizontal':\n                 marker_row = list(marker_pixels)[0][0] # All rows are the same\n                 marker_cols = set(c for r,c in marker_pixels)\n                 if marker_row == r_min - 1 and \\\n                    min(marker_cols) == c_min and max(marker_cols) == c_max:\n                     associated_directions.add('up')\n\n            # Check Down Association\n            if marker['orientation'] == 'horizontal':\n                 marker_row = list(marker_pixels)[0][0] \n                 marker_cols = set(c for r,c in marker_pixels)\n                 if marker_row == r_max + 1 and \\\n                    min(marker_cols) == c_min and max(marker_cols) == c_max:\n                     associated_directions.add('down')\n            \n            # Check Left Association\n            if marker['orientation'] == 'vertical':\n                 marker_col = list(marker_pixels)[0][1] # All cols are the same\n                 marker_rows = set(r for r,c in marker_pixels)\n                 if marker_col == c_min - 1 and \\\n                    min(marker_rows) == r_min and max(marker_rows) == r_max:\n                     associated_directions.add('left')\n\n            # Check Right Association\n            if marker['orientation'] == 'vertical':\n                 marker_col = list(marker_pixels)[0][1]\n                 marker_rows = set(r for r,c in marker_pixels)\n                 if marker_col == c_max + 1 and \\\n                    min(marker_rows) == r_min and max(marker_rows) == r_max:\n                     associated_directions.add('right')\n\n\n        # Perform tiling based on associated directions\n        \n        # Up Tiling\n        if 'up' in associated_directions:\n            curr_r = r_min - pattern_h\n            while curr_r >= 0:\n                # Check if target area is within bounds (redundant due to while condition?)\n                if curr_r + pattern_h > 0:\n                   # Ensure slicing doesn't go out of bounds upwards (curr_r could be negative if pattern_h large)\n                   copy_start_row = max(0, curr_r)\n                   tile_start_row = max(0, -curr_r)\n                   copy_height = min(pattern_h, rows - copy_start_row) \n                   \n                   # Adjust height if copy starts partway into the tile zone\n                   copy_height = min(copy_height, pattern_h - tile_start_row) \n\n                   if copy_height > 0:\n                       output_np[copy_start_row : copy_start_row + copy_height, c_min : c_min + pattern_w] = \\\n                           tile_to_copy[tile_start_row : tile_start_row + copy_height, :]\n                curr_r -= pattern_h\n                \n        # Down Tiling\n        if 'down' in associated_directions:\n            curr_r = r_min + pattern_h # Start position for the *next* tile\n            while curr_r < rows:\n                # Check bounds for target area\n                if curr_r + pattern_h <= rows: # Full tile fits\n                    output_np[curr_r : curr_r + pattern_h, c_min : c_min + pattern_w] = tile_to_copy\n                else: # Partial tile fits\n                    copy_height = rows - curr_r\n                    if copy_height > 0:\n                       output_np[curr_r : curr_r + copy_height, c_min : c_min + pattern_w] = \\\n                           tile_to_copy[0 : copy_height, :]\n                    break # No more space below\n                curr_r += pattern_h\n\n        # Left Tiling\n        if 'left' in associated_directions:\n            curr_c = c_min - pattern_w\n            while curr_c >= 0:\n                 if curr_c + pattern_w > 0:\n                    copy_start_col = max(0, curr_c)\n                    tile_start_col = max(0, -curr_c)\n                    copy_width = min(pattern_w, cols - copy_start_col)\n                    copy_width = min(copy_width, pattern_w - tile_start_col)\n                    \n                    if copy_width > 0:\n                        output_np[r_min : r_min + pattern_h, copy_start_col : copy_start_col + copy_width] = \\\n                           tile_to_copy[:, tile_start_col : tile_start_col + copy_width]\n                 curr_c -= pattern_w\n\n        # Right Tiling\n        if 'right' in associated_directions:\n            curr_c = c_min + pattern_w # Start position for the *next* tile\n            while curr_c < cols:\n                if curr_c + pattern_w <= cols: # Full tile fits\n                    output_np[r_min : r_min + pattern_h, curr_c : curr_c + pattern_w] = tile_to_copy\n                else: # Partial tile fits\n                    copy_width = cols - curr_c\n                    if copy_width > 0:\n                       output_np[r_min : r_min + pattern_h, curr_c : curr_c + copy_width] = \\\n                           tile_to_copy[:, 0 : copy_width]\n                    break # No more space right\n                curr_c += pattern_w\n\n\n    # Convert final numpy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7426,
    "candidates_token_count": 2836,
    "total_token_count": 10262,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 54.893502,
  "retries": null
}