{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom skimage import measure\nimport math\nfrom collections import defaultdict\n\n\"\"\"\nIdentifies significant connected components (objects) of non-background colors in the input grid, filtering out smaller objects likely representing noise.\nDetermines the relative spatial arrangement (rows and columns) of these significant objects based on their center coordinates.\nConstructs an output grid containing the colors of these objects, arranged according to their derived row and column positions.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> list:\n    \"\"\"\n    Finds all connected components (objects) of non-background colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background (default: 0).\n\n    Returns:\n        list: A list of dictionaries, each representing an object:\n              {'color': int, 'pixels': list of (r, c) tuples,\n               'bounds': (min_r, min_c, max_r, max_c),\n               'center': (center_y, center_x), 'size': int}\n    \"\"\"\n    objects = []\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color and not visited[r, c]:\n                # Found a new potential object, start BFS\n                component_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                pixel_sum_r, pixel_sum_c = 0, 0\n\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n\n                    component_pixels.append((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    pixel_sum_r += curr_r\n                    pixel_sum_c += curr_c\n\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                size = len(component_pixels)\n                # Calculate center based on average pixel coordinates\n                center_y = pixel_sum_r / size\n                center_x = pixel_sum_c / size\n                \n                objects.append({\n                    'color': color,\n                    'pixels': component_pixels,\n                    'bounds': (min_r, min_c, max_r, max_c),\n                    'center': (center_y, center_x),\n                    'size': size\n                })\n    return objects\n\ndef filter_objects(objects: list, min_size: int) -> list:\n    \"\"\"Filters objects based on a minimum size threshold.\"\"\"\n    return [obj for obj in objects if obj['size'] >= min_size]\n\ndef group_and_sort_objects(objects: list, y_tolerance_factor: float = 0.5) -> list:\n    \"\"\"\n    Groups objects into rows based on center y-coordinate and sorts them.\n\n    Args:\n        objects (list): List of object dictionaries (must contain 'center').\n        y_tolerance_factor (float): A factor multiplied by object height \n                                     to determine y-grouping tolerance.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row\n              of object colors, sorted top-to-bottom and left-to-right.\n              Returns empty list if no objects.\n    \"\"\"\n    if not objects:\n        return []\n\n    # Sort primarily by center y, then by center x\n    objects.sort(key=lambda o: (o['center'][0], o['center'][1]))\n\n    rows_of_objects = []\n    current_row = []\n\n    for obj in objects:\n        obj_height = obj['bounds'][2] - obj['bounds'][0] + 1\n        # Dynamically calculate tolerance based on object height\n        y_tolerance = obj_height * y_tolerance_factor \n\n        if not current_row:\n            # Start the first row\n            current_row.append(obj)\n        else:\n            # Compare with the *average* y-center of the current row for stability\n            avg_row_y = sum(o['center'][0] for o in current_row) / len(current_row)\n            \n            # Check if the current object's y-center is close enough\n            if abs(obj['center'][0] - avg_row_y) <= y_tolerance:\n                 # Also check against the first object's Y for cases where avg drifts\n                 first_obj_in_row_height = current_row[0]['bounds'][2] - current_row[0]['bounds'][0] + 1\n                 y_tolerance_first = first_obj_in_row_height * y_tolerance_factor\n                 if abs(obj['center'][0] - current_row[0]['center'][0]) <= y_tolerance_first:\n                     current_row.append(obj)\n                 else: # If it fails the check against the first object, start new row\n                    current_row.sort(key=lambda o: o['center'][1]) # Sort completed row by x\n                    rows_of_objects.append(current_row)\n                    current_row = [obj] # Start new row\n            else:\n                # Y-center is too different, start a new row\n                # Sort the completed row by x-coordinate before adding\n                current_row.sort(key=lambda o: o['center'][1])\n                rows_of_objects.append(current_row)\n                current_row = [obj]\n\n    # Add the last row after sorting it\n    if current_row:\n        current_row.sort(key=lambda o: o['center'][1])\n        rows_of_objects.append(current_row)\n\n    # Extract colors\n    output_rows_colors = []\n    for row in rows_of_objects:\n        output_rows_colors.append([obj['color'] for obj in row])\n\n    return output_rows_colors\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by finding significant objects, arranging them\n    spatially, and outputting a grid of their colors.\n    \"\"\"\n    # 1. Find all connected components (objects)\n    all_objects = find_objects(input_grid)\n    if not all_objects:\n        return np.array([[]], dtype=int) # Handle empty input or no objects found\n\n    # 2. Filter out small objects (noise)\n    # Determine a dynamic threshold: e.g., keep objects larger than 1/Xth of the largest object?\n    # Or a fixed threshold? Let's try fixed first based on examples. Size > 5 seems plausible for key objects.\n    # Maybe calculate sizes and filter relative to max size?\n    sizes = [obj['size'] for obj in all_objects]\n    max_size = max(sizes) if sizes else 0\n    \n    # Let's try filtering objects that are significantly smaller than the largest ones.\n    # For instance, keep objects with size >= 10% of the max size, or a minimum absolute size (e.g., 5)\n    # min_size_threshold = max(5, max_size * 0.1) # Example dynamic threshold\n    min_size_threshold = 5 # Fixed threshold seems simpler to start\n    \n    key_objects = filter_objects(all_objects, min_size_threshold)\n\n    if not key_objects:\n         # Fallback: if filtering removed everything, maybe the threshold was wrong\n         # or the task involves small objects. Revert to all objects? Or return empty?\n         # Let's try returning empty grid for now.\n         print(\"Warning: Filtering removed all objects. Check threshold or object finding.\")\n         # Alternative: use all_objects if key_objects is empty\n         # key_objects = all_objects \n         # if not key_objects: # Still no objects\n         return np.array([[]], dtype=int)\n\n\n    # 3. Group objects into rows and sort within rows\n    # Use a tolerance factor for grouping based on object height\n    grouped_sorted_colors = group_and_sort_objects(key_objects, y_tolerance_factor=0.75) # Adjusted tolerance factor\n\n    # 4. Construct the output grid\n    if not grouped_sorted_colors:\n        return np.array([[]], dtype=int)\n\n    num_rows = len(grouped_sorted_colors)\n    # Find the maximum number of columns across all rows\n    num_cols = 0\n    if num_rows > 0:\n       num_cols = max(len(row) for row in grouped_sorted_colors) if grouped_sorted_colors else 0\n       \n    if num_cols == 0: # Handle cases where rows might be empty after filtering/grouping\n        return np.array([[]], dtype=int)\n\n    # Create the output grid, initializing with a placeholder (e.g., -1 or background 0)\n    # Using background color 0 seems reasonable.\n    output_grid = np.zeros((num_rows, num_cols), dtype=int)\n\n    for r_idx, row_colors in enumerate(grouped_sorted_colors):\n        # Place colors in the grid. If a row has fewer items than num_cols,\n        # the remaining cells will keep the initial value (0).\n        if len(row_colors) <= num_cols:\n            output_grid[r_idx, :len(row_colors)] = row_colors\n        else:\n            # This case shouldn't happen if num_cols is calculated correctly, but for safety:\n            output_grid[r_idx, :] = row_colors[:num_cols]\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10173,
    "candidates_token_count": 2443,
    "total_token_count": 12616,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 124.430016,
  "retries": null
}