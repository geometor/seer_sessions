{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by:\n1. Identifying all distinct contiguous objects of non-background (white, 0) colors.\n2. Calculating properties for each object: color, size (pixel count), and geometric center.\n3. Filtering out objects smaller than a specified minimum size threshold (e.g., 5 pixels).\n4. Grouping the remaining significant objects into rows based on the proximity of their vertical center coordinates. A tolerance, potentially related to object height, is used. Objects within a group (row) are considered vertically aligned.\n5. Sorting the objects within each identified row based on their horizontal center coordinates (left-to-right).\n6. Constructing an output grid where the colors of the significant objects are placed according to their determined row and column layout. The output grid dimensions are determined by the number of rows found and the maximum number of objects in any row. Empty spaces in rows with fewer objects than the maximum are filled with the background color (white, 0).\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> list:\n    \"\"\"\n    Finds all connected components (objects) of non-background colors using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background (default: 0).\n\n    Returns:\n        list: A list of dictionaries, each representing an object:\n              {'color': int, 'pixels': list of (r, c) tuples,\n               'bounds': (min_r, min_c, max_r, max_c),\n               'center': (center_y, center_x), 'size': int}\n              Returns empty list if grid is empty or no objects are found.\n    \"\"\"\n    objects = []\n    if grid.size == 0:\n        return objects\n        \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if it's a non-background color and hasn't been visited yet\n            if color != background_color and not visited[r, c]:\n                # Start BFS to find the connected component (object)\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                pixel_sum_r, pixel_sum_c = 0, 0\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    component_pixels.append((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    pixel_sum_r += curr_r\n                    pixel_sum_c += curr_c\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, same color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                size = len(component_pixels)\n                if size > 0:\n                    # Calculate center based on average pixel coordinates\n                    center_y = pixel_sum_r / size\n                    center_x = pixel_sum_c / size\n                    \n                    objects.append({\n                        'color': color,\n                        'pixels': component_pixels,\n                        'bounds': (min_r, min_c, max_r, max_c),\n                        'center': (center_y, center_x),\n                        'size': size\n                    })\n    return objects\n\ndef filter_objects(objects: list, min_size: int) -> list:\n    \"\"\"Filters objects based on a minimum size threshold.\"\"\"\n    return [obj for obj in objects if obj['size'] >= min_size]\n\ndef group_and_sort_objects(objects: list, y_tolerance_factor: float = 0.75) -> list:\n    \"\"\"\n    Groups objects into rows based on center y-coordinate proximity relative\n    to the first object in the potential row, and sorts them horizontally.\n\n    Args:\n        objects (list): List of object dictionaries (must contain 'center', 'bounds').\n        y_tolerance_factor (float): A factor multiplied by the height of the \n                                     first object in a row to determine the \n                                     vertical grouping tolerance.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row\n              of object colors, sorted top-to-bottom (implicitly by grouping)\n              and left-to-right (explicitly by center x).\n              Returns empty list if no objects.\n    \"\"\"\n    if not objects:\n        return []\n\n    # Sort primarily by center y, then by center x as a secondary sort key\n    # This helps process objects generally from top-to-bottom, left-to-right.\n    objects.sort(key=lambda o: (o['center'][0], o['center'][1]))\n\n    rows_of_objects = []\n    current_row = []\n\n    for obj in objects:\n        if not current_row:\n            # Start the first row with the first object encountered\n            current_row.append(obj)\n        else:\n            # Compare the current object's y-center with the y-center \n            # of the *first* object added to the current potential row.\n            first_obj_in_row = current_row[0]\n            first_obj_height = first_obj_in_row['bounds'][2] - first_obj_in_row['bounds'][0] + 1\n            # Calculate tolerance based on the height of the first object in the row\n            y_tolerance = first_obj_height * y_tolerance_factor\n            \n            # Check if the current object's y-center is close enough to the first object's y-center\n            if abs(obj['center'][0] - first_obj_in_row['center'][0]) <= y_tolerance:\n                # Object is vertically aligned enough, add it to the current row\n                current_row.append(obj)\n            else:\n                # Y-center is too different, finalize the previous row\n                # Sort the completed row by x-coordinate before adding\n                current_row.sort(key=lambda o: o['center'][1])\n                rows_of_objects.append(current_row)\n                # Start a new row with the current object\n                current_row = [obj]\n\n    # Add the last row being built after the loop finishes\n    if current_row:\n        # Sort the last row by x-coordinate\n        current_row.sort(key=lambda o: o['center'][1])\n        rows_of_objects.append(current_row)\n\n    # Extract just the colors for the final output structure\n    output_rows_colors = []\n    for row in rows_of_objects:\n        output_rows_colors.append([obj['color'] for obj in row])\n\n    return output_rows_colors\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by finding significant objects, arranging them\n    spatially based on centers, and outputting a grid of their colors.\n    \"\"\"\n    # Define parameters (these might need tuning based on task examples)\n    background_color = 0\n    min_size_threshold = 5  # Filter out objects smaller than this size\n    y_tolerance_factor = 0.75 # Factor for grouping objects into rows vertically\n\n    # 1. Find all connected components (objects)\n    all_objects = find_objects(input_grid, background_color)\n    if not all_objects:\n        # Handle cases with no non-background pixels\n        return np.array([[]], dtype=int) \n\n    # 2. Filter out small objects (likely noise)\n    key_objects = filter_objects(all_objects, min_size_threshold)\n\n    if not key_objects:\n        # If filtering removed all objects, return empty grid\n        # Consider if fallback logic (e.g., using all_objects) is needed for specific tasks\n        # print(\"Warning: Filtering removed all objects.\") \n        return np.array([[]], dtype=int)\n\n    # 3. Group objects into rows based on vertical center proximity \n    #    and sort objects within each row by horizontal center position.\n    grouped_sorted_colors = group_and_sort_objects(key_objects, y_tolerance_factor)\n\n    # 4. Construct the output grid\n    if not grouped_sorted_colors:\n        # Should not happen if key_objects was not empty, but check for safety\n        return np.array([[]], dtype=int)\n\n    # Determine the dimensions of the output grid\n    num_rows = len(grouped_sorted_colors)\n    # Find the maximum number of columns needed across all rows\n    num_cols = 0\n    if num_rows > 0:\n       # Guard against empty inner lists, though group_and_sort should prevent this\n       num_cols = max(len(row) for row in grouped_sorted_colors if row) if grouped_sorted_colors else 0\n       \n    if num_cols == 0: \n        # Handle cases where rows might be empty after filtering/grouping (unlikely here)\n         return np.array([[]], dtype=int)\n\n    # Create the output grid, initialized with the background color\n    output_grid = np.full((num_rows, num_cols), background_color, dtype=int)\n\n    # Populate the output grid with the sorted colors\n    for r_idx, row_colors in enumerate(grouped_sorted_colors):\n        if row_colors: # Ensure row is not empty\n             output_grid[r_idx, :len(row_colors)] = row_colors\n        # Cells beyond len(row_colors) remain background_color due to np.full initialization\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4834,
    "candidates_token_count": 2427,
    "total_token_count": 7261,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.183156,
  "retries": null
}