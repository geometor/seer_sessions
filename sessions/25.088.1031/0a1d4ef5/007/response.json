{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by:\n1. Finding all contiguous objects of non-background colors (white, 0).\n2. Calculating the size (pixel count), bounding box (min/max row/col), and \n   center coordinates for each object.\n3. Sorting all found objects by size in descending order.\n4. Examining the colors of the 9 largest objects.\n5. Determining the number of objects to select (N) and the output grid shape:\n   - If the number of *unique* colors among the 9 largest objects is 6 or more, \n     select the top N=6 largest objects, and the output shape is 2x3.\n   - Otherwise, select the top N=9 largest objects, and the output shape is 3x3.\n6. Taking the selected N largest objects.\n7. Sorting these N objects based on their spatial position: primarily by their \n   topmost row coordinate (minimum row index of the bounding box) and \n   secondarily by their horizontal center coordinate (average column index).\n8. Extracting the colors of these spatially sorted N objects in order.\n9. Reshaping this list of N colors into the determined output grid shape (2x3 or 3x3).\n10. Returning the resulting grid. If fewer than N objects are found initially,\n    an empty grid may be returned depending on intermediate steps.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> list:\n    \"\"\"\n    Finds all connected components (objects) of non-background colors using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background (default: 0).\n\n    Returns:\n        list: A list of dictionaries, each representing an object:\n              {'color': int, 'pixels': list of (r, c) tuples,\n               'bounds': (min_r, min_c, max_r, max_c),\n               'center': (center_y, center_x), 'size': int}\n              Returns empty list if grid is empty or no objects are found.\n    \"\"\"\n    objects = []\n    if grid.size == 0:\n        return objects\n        \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if it's a non-background color and hasn't been visited yet\n            if color != background_color and not visited[r, c]:\n                # Start BFS to find the connected component (object)\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                pixel_sum_r, pixel_sum_c = 0, 0\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    component_pixels.append((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    pixel_sum_r += curr_r\n                    pixel_sum_c += curr_c\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, same color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                size = len(component_pixels)\n                if size > 0:\n                    # Calculate center based on average pixel coordinates\n                    center_y = pixel_sum_r / size\n                    center_x = pixel_sum_c / size\n                    \n                    objects.append({\n                        'color': int(color), # Ensure color is standard int\n                        'pixels': component_pixels,\n                        'bounds': (min_r, min_c, max_r, max_c),\n                        'center': (center_y, center_x),\n                        'size': size\n                    })\n    return objects\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid based on the size and spatial arrangement \n    of the largest objects.\n    \"\"\"\n    # 1. Find all objects\n    all_objects = find_objects(input_grid, background_color=0)\n\n    # Handle edge case: no objects found\n    if not all_objects:\n        return np.array([[]], dtype=int) # Return empty grid\n\n    # 2. Sort objects by size (descending)\n    all_objects_sorted_by_size = sorted(all_objects, key=lambda o: o['size'], reverse=True)\n\n    # 3. Determine N and output shape based on unique colors of top 9 (or fewer if less exist)\n    num_top_objects_to_consider = min(9, len(all_objects_sorted_by_size))\n    top_9_or_fewer_objects = all_objects_sorted_by_size[:num_top_objects_to_consider]\n    \n    # Handle case where fewer than 6 objects exist \n    if len(top_9_or_fewer_objects) == 0 :\n         return np.array([[]], dtype=int) # Return empty grid\n    \n    unique_colors_top_9 = set(obj['color'] for obj in top_9_or_fewer_objects)\n    \n    if len(unique_colors_top_9) >= 6:\n        N = 6\n        output_shape = (2, 3)\n    else:\n        N = 9\n        output_shape = (3, 3)\n        \n    # Ensure we don't try to select more objects than available\n    N = min(N, len(all_objects_sorted_by_size))\n    \n    # Check if we have enough objects for the target shape\n    if N < output_shape[0] * output_shape[1]:\n       # This case might need specific handling based on task requirements.\n       # For now, we might not be able to form the target grid.\n       # Let's return an empty grid or handle based on observed behavior if this occurs.\n       # It seems the examples always provide enough large objects.\n       # If N is 0 (because unique check above failed), return empty.\n       if N == 0:\n           return np.array([[]], dtype=int) \n       # If N is positive but less than required, maybe fill with background?\n       # Or maybe the logic for N selection needs refinement. \n       # Given the examples worked, let's assume N objects will be available.\n       pass # Assume we have N objects\n\n\n    # 4. Select the top N largest objects\n    top_n_objects = all_objects_sorted_by_size[:N]\n\n    # 5. Sort these N objects spatially: by min_r (top boundary), then center_x\n    #    min_r is obj['bounds'][0]\n    #    center_x is obj['center'][1]\n    top_n_sorted_spatially = sorted(top_n_objects, key=lambda o: (o['bounds'][0], o['center'][1]))\n\n    # 6. Extract the colors in the spatial order\n    output_colors = [obj['color'] for obj in top_n_sorted_spatially]\n    \n    # 7. Reshape the colors into the target grid\n    #    Ensure we have the exact number of colors needed for the shape\n    if len(output_colors) == output_shape[0] * output_shape[1]:\n        output_grid = np.array(output_colors, dtype=int).reshape(output_shape)\n    else:\n        # Fallback if the number of selected objects doesn't match the expected grid size\n        # This might indicate an issue with the N determination or sorting logic,\n        # or an edge case not covered by examples. Returning empty for now.\n        # print(f\"Warning: Number of colors ({len(output_colors)}) doesn't match shape {output_shape}\")\n        return np.array([[]], dtype=int) \n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24668,
    "candidates_token_count": 2039,
    "total_token_count": 26707,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.875184,
  "retries": null
}