{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport math\n\n\"\"\"\nIdentifies maximal, solid, monochromatic rectangular blocks (excluding white/0) in the input grid.\nCalculates the center of each block.\nGroups blocks into rows based on similar center y-coordinates.\nSorts the rows from top to bottom based on their average center y-coordinate.\nSorts the blocks within each row from left to right based on their center x-coordinate.\nConstructs an output grid where each cell contains the color of a block, arranged according to the sorted row and column structure.\n\"\"\"\n\ndef find_maximal_solid_rectangles(grid):\n    \"\"\"\n    Finds all maximal solid monochromatic rectangles in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each containing info about a found rectangle:\n              {'color': int, 'bounds': (min_r, min_c, max_r, max_c), 'center': (center_y, center_x)}\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the pixel is not background and not visited\n            if color != background_color and not visited[r, c]:\n                # Start BFS to find the connected component\n                q = [(r, c)]\n                visited[r, c] = True\n                component_pixels = [(r, c)]\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_pixels.append((nr, nc))\n                \n                # Check if the component forms a solid rectangle\n                rect_rows = max_r - min_r + 1\n                rect_cols = max_c - min_c + 1\n                is_solid_rectangle = True\n                if len(component_pixels) != rect_rows * rect_cols:\n                    # If pixel count doesn't match bounding box area, not a solid rect\n                    is_solid_rectangle = False\n                else:\n                    # Verify all pixels within the bounding box have the same color\n                    for rr in range(min_r, max_r + 1):\n                        for cc in range(min_c, max_c + 1):\n                            if grid[rr, cc] != color:\n                                is_solid_rectangle = False\n                                break\n                        if not is_solid_rectangle:\n                            break\n                \n                # If it's a solid rectangle, store its properties\n                if is_solid_rectangle:\n                    center_y = min_r + (rect_rows - 1) / 2.0\n                    center_x = min_c + (rect_cols - 1) / 2.0\n                    rectangles.append({\n                        'color': color,\n                        'bounds': (min_r, min_c, max_r, max_c),\n                        'center': (center_y, center_x)\n                    })\n                    # Mark all pixels within the verified rectangle bounds as visited\n                    # This handles cases where BFS might not cover the entire conceptual rectangle\n                    # if the shape is unusual initially but fits a rect bbox. Redundant marking is fine.\n                    for rr in range(min_r, max_r + 1):\n                        for cc in range(min_c, max_c + 1):\n                           visited[rr, cc] = True\n\n\n    return rectangles\n\n\ndef group_and_sort_rectangles(rectangles):\n    \"\"\"\n    Groups rectangles into rows based on center y-coordinate and sorts them.\n\n    Args:\n        rectangles (list): List of rectangle dictionaries.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row\n              of rectangle colors, sorted top-to-bottom and left-to-right.\n    \"\"\"\n    if not rectangles:\n        return []\n\n    # Sort primarily by center y, then by center x\n    rectangles.sort(key=lambda r: (r['center'][0], r['center'][1]))\n\n    rows_of_rects = []\n    current_row = []\n    if rectangles:\n        current_row.append(rectangles[0])\n\n    # Group by similar center y (using a small tolerance or comparing to the first element of the row)\n    # A simple approach: if y-center is 'close enough' to the first rect in the current row, add it.\n    y_tolerance = 1.0 # Allow for slight vertical variations within a row\n\n    for i in range(1, len(rectangles)):\n        rect = rectangles[i]\n        first_rect_in_row = current_row[0]\n        # Check if the current rectangle's y-center is close to the first rectangle's y-center in the current row\n        if abs(rect['center'][0] - first_rect_in_row['center'][0]) <= y_tolerance:\n            current_row.append(rect)\n        else:\n            # Start a new row\n            # Sort the completed row by x-coordinate before adding\n            current_row.sort(key=lambda r: r['center'][1])\n            rows_of_rects.append(current_row)\n            current_row = [rect]\n\n    # Add the last row after sorting it\n    if current_row:\n        current_row.sort(key=lambda r: r['center'][1])\n        rows_of_rects.append(current_row)\n\n    # Extract colors\n    output_rows = []\n    for row in rows_of_rects:\n        output_rows.append([rect['color'] for rect in row])\n\n    return output_rows\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by finding solid rectangular blocks,\n    arranging them by row and column based on their spatial positions,\n    and outputting a grid of their colors.\n    \"\"\"\n    # 1. Find all maximal solid rectangular blocks (non-background)\n    rectangles = find_maximal_solid_rectangles(input_grid)\n\n    # 2. Group rectangles into rows (based on y-center) and sort\n    #    - Rows are sorted top-to-bottom (implicitly by sorting rects first)\n    #    - Rectangles within rows are sorted left-to-right (based on x-center)\n    grouped_sorted_colors = group_and_sort_rectangles(rectangles)\n\n    # 3. Construct the output grid\n    if not grouped_sorted_colors:\n        return np.array([[]], dtype=int) # Return empty grid if no rects found\n\n    num_rows = len(grouped_sorted_colors)\n    # Ensure all rows have the same length for a rectangular output grid.\n    # This task's examples suggest rows can have different lengths, \n    # which numpy arrays don't directly support without padding or object dtype.\n    # Let's assume the task implies a rectangular output matching the structure.\n    # The examples show rectangular outputs, implying consistent columns per task.\n    num_cols = 0\n    if num_rows > 0:\n        num_cols = len(grouped_sorted_colors[0]) # Assume consistent columns based on first row\n        # Verify assumption (optional, but good practice)\n        # for row in grouped_sorted_colors:\n        #     if len(row) != num_cols:\n        #         # Handle inconsistency if needed, maybe pad or raise error\n        #         print(f\"Warning: Inconsistent number of columns found. {len(row)} vs {num_cols}\")\n        #         # For now, let's trust the examples imply rectangular structure\n        #         pass\n\n\n    # Create the output grid\n    output_grid = np.zeros((num_rows, num_cols), dtype=int)\n    for r_idx, row_colors in enumerate(grouped_sorted_colors):\n         # Ensure the row length matches expected columns before assignment\n        if len(row_colors) == num_cols:\n            output_grid[r_idx, :] = row_colors\n        else:\n             # Handle potential inconsistencies, e.g., pad or truncate if necessary\n             # For this task, seems safe to assume consistency based on examples\n             print(f\"Error: Row {r_idx} has {len(row_colors)} columns, expected {num_cols}\")\n             # Fallback: Pad with a default value (like 0) or truncate\n             padded_row = row_colors[:num_cols] + [0] * (num_cols - len(row_colors))\n             output_grid[r_idx, :] = padded_row\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7494,
    "candidates_token_count": 2245,
    "total_token_count": 9739,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.635107,
  "retries": null
}