{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis module transforms an input grid characterized by a repeating pattern (tile) \npartially obscured by white pixels (0) into an output grid where the pattern \nis perfectly tiled across the entire grid dimensions.\n\nThe transformation involves three main steps:\n1. Identify the dimensions (height H_tile, width W_tile) of the fundamental repeating tile.\n2. Determine the correct color for each cell within the fundamental tile by finding \n   the most frequent non-white color across all corresponding cells in the input grid.\n3. Construct the output grid by repeating the determined fundamental tile across \n   the grid's dimensions.\n\"\"\"\n\ndef find_tile_dimensions(grid):\n    \"\"\"\n    Finds the dimensions (height H, width W) of the repeating tile.\n\n    Analyzes horizontal and vertical repetitions, ignoring white pixels (0), \n    to find the smallest repeating unit dimensions.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: A tuple (H_tile, W_tile) representing the height and width \n               of the fundamental tile. Returns (H_grid, W_grid) if no smaller\n               periodicity is found.\n    \"\"\"\n    H_grid, W_grid = grid.shape\n    H_tile = H_grid\n    W_tile = W_grid\n\n    # Find Height (H_tile)\n    for H in range(1, H_grid):\n        is_periodic_h = True\n        # Check if rows repeat with period H, ignoring white pixels\n        for r in range(H_grid - H):\n            for c in range(W_grid):\n                val1 = grid[r, c]\n                val2 = grid[r + H, c]\n                # If both are non-white, they must match for periodicity\n                if val1 != 0 and val2 != 0 and val1 != val2:\n                    is_periodic_h = False\n                    break\n            if not is_periodic_h:\n                break\n        \n        # Check if we actually found non-white comparisons to confirm periodicity\n        if is_periodic_h:\n            found_non_white_pair_h = False\n            for r_check in range(H_grid - H):\n                 for c_check in range(W_grid):\n                      if grid[r_check, c_check] != 0 and grid[r_check + H, c_check] != 0:\n                          found_non_white_pair_h = True\n                          break\n                 if found_non_white_pair_h:\n                     break\n            \n            if found_non_white_pair_h: # Only confirm if we had non-white evidence\n                H_tile = H\n                break # Found smallest height\n\n    # Find Width (W_tile)\n    for W in range(1, W_grid):\n        is_periodic_w = True\n        # Check if columns repeat with period W, ignoring white pixels\n        for c in range(W_grid - W):\n            for r in range(H_grid):\n                val1 = grid[r, c]\n                val2 = grid[r, c + W]\n                # If both are non-white, they must match for periodicity\n                if val1 != 0 and val2 != 0 and val1 != val2:\n                    is_periodic_w = False\n                    break\n            if not is_periodic_w:\n                break\n\n        # Check if we actually found non-white comparisons to confirm periodicity\n        if is_periodic_w:\n            found_non_white_pair_w = False\n            for c_check in range(W_grid - W):\n                for r_check in range(H_grid):\n                    if grid[r_check, c_check] != 0 and grid[r_check, c_check + W] != 0:\n                        found_non_white_pair_w = True\n                        break\n                if found_non_white_pair_w:\n                    break\n\n            if found_non_white_pair_w: # Only confirm if we had non-white evidence\n                W_tile = W\n                break # Found smallest width\n\n    return H_tile, W_tile\n\n\ndef determine_tile_content(grid, H_tile, W_tile):\n    \"\"\"\n    Determines the content of the fundamental tile.\n\n    For each cell (tr, tc) in the tile, finds the most frequent non-white color \n    among all corresponding cells (R, C) in the input grid where \n    R % H_tile == tr and C % W_tile == tc.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        H_tile (int): The height of the tile.\n        W_tile (int): The width of the tile.\n\n    Returns:\n        np.ndarray: A grid representing the fundamental tile pattern.\n    \"\"\"\n    H_grid, W_grid = grid.shape\n    tile_grid = np.zeros((H_tile, W_tile), dtype=int)\n\n    for tr in range(H_tile):\n        for tc in range(W_tile):\n            # Collect colors from all corresponding positions in the input grid\n            colors_at_position = []\n            for R in range(tr, H_grid, H_tile):\n                for C in range(tc, W_grid, W_tile):\n                    color = grid[R, C]\n                    # Only consider non-white colors for determining the pattern\n                    if color != 0:\n                        colors_at_position.append(color)\n\n            # Determine the most frequent non-white color\n            if colors_at_position:\n                # Use Counter to find the most common element\n                most_common_color = Counter(colors_at_position).most_common(1)[0][0]\n                tile_grid[tr, tc] = most_common_color\n            else:\n                # If all corresponding cells were white, default to white (0).\n                # This might need adjustment based on more complex tasks, but fits examples.\n                tile_grid[tr, tc] = 0\n\n    return tile_grid\n\n\ndef generate_output(tile_grid, H_grid, W_grid):\n    \"\"\"\n    Generates the output grid by tiling the fundamental tile pattern.\n\n    Args:\n        tile_grid (np.ndarray): The fundamental tile grid.\n        H_grid (int): The desired height of the output grid.\n        W_grid (int): The desired width of the output grid.\n\n    Returns:\n        np.ndarray: The output grid.\n    \"\"\"\n    H_tile, W_tile = tile_grid.shape\n    output_grid = np.zeros((H_grid, W_grid), dtype=int)\n\n    # Fill the output grid by repeating the tile\n    for R in range(H_grid):\n        for C in range(W_grid):\n            output_grid[R, C] = tile_grid[R % H_tile, C % W_tile]\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying its underlying repeating pattern,\n    filtering out white pixel noise, and reconstructing the grid using the\n    perfectly tiled pattern.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Get the dimensions of the input grid\n    H_grid, W_grid = input_grid.shape\n\n    # 1. Identify the dimensions of the repeating tile\n    H_tile, W_tile = find_tile_dimensions(input_grid)\n\n    # 2. Determine the content of the fundamental tile\n    tile_grid = determine_tile_content(input_grid, H_tile, W_tile)\n\n    # 3. Generate the output grid by tiling the fundamental tile\n    output_grid = generate_output(tile_grid, H_grid, W_grid)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8142,
    "candidates_token_count": 1847,
    "total_token_count": 9989,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.14861,
  "retries": null
}