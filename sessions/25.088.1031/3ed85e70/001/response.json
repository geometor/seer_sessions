{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify template patterns in the upper green-background region (rows 0-6).\nIdentify fragment objects (contiguous blocks of a single non-white color) in the lower white-background region (rows 7-29).\nFor each fragment in the lower region, check if its color matches the outer border color of any template found in the upper region.\nIf a match is found, replace the area in the output grid starting at the fragment's top-left corner with the complete pattern of the matching template.\nThe upper region (rows 0-6) remains unchanged from input to output.\n\"\"\"\n\ndef find_connected_components(grid, start_r, start_c, target_color, visited):\n    \"\"\"Finds a connected component of a specific color using BFS.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    component_pixels = set()\n    visited[start_r, start_c] = True\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n\n    while q:\n        r, c = q.popleft()\n        component_pixels.add((r, c))\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-way connectivity\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not visited[nr, nc] and grid[nr, nc] == target_color:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n                \n    return component_pixels, (min_r, min_c, max_r, max_c)\n\ndef find_template_components(grid, start_r, start_c, background_color, visited):\n    \"\"\"Finds a connected component of non-background colors using BFS.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    component_pixels = set()\n    visited[start_r, start_c] = True\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n    \n    border_pixels = set() # Pixels adjacent to the background\n\n    while q:\n        r, c = q.popleft()\n        component_pixels.add((r, c))\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n        \n        is_border = False\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]: # 8-way adjacency check for border\n            nr, nc = r + dr, c + dc\n            # Check if adjacent pixel is background\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == background_color:\n                 is_border = True\n            # Check neighbors for component continuation (4-way)\n            if abs(dr) + abs(dc) == 1: # Only consider 4-way neighbors for component growth\n                if 0 <= nr < nc < cols and \\\n                   not visited[nr, nc] and grid[nr, nc] != background_color:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n\n        if is_border:\n             border_pixels.add((r, c))\n             \n    # Determine the primary border color (assuming it's uniform or taking one example)\n    border_color = -1 # Default if no border found / single pixel component not touching background\n    if border_pixels:\n        # Simple approach: take color of one border pixel\n        br, bc = next(iter(border_pixels))\n        border_color = grid[br, bc]\n        # # More robust: find most frequent color among border pixels (if needed)\n        # border_colors = [grid[r, c] for r, c in border_pixels]\n        # if border_colors:\n        #     counts = np.bincount(border_colors)\n        #     border_color = np.argmax(counts)\n\n    return component_pixels, border_color, (min_r, min_c, max_r, max_c)\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on template matching.\n\n    1. Identifies templates (non-green shapes) in the upper region (rows 0-6). Stores their\n       outer border color and the rectangular pattern containing the shape.\n    2. Identifies fragments (non-white shapes) in the lower region (rows 7-end). Stores their\n       color and top-left position.\n    3. Creates a copy of the input grid.\n    4. Iterates through fragments. If a fragment's color matches a template's border color,\n       pastes the template's pattern onto the output grid at the fragment's top-left position.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- 1. Identify Templates (Upper Region: Rows 0-6) ---\n    template_map = {} # Maps border_color -> pattern_array\n    upper_region = input_grid[0:7, :]\n    upper_rows, upper_cols = upper_region.shape\n    visited_upper = np.zeros_like(upper_region, dtype=bool)\n    template_background_color = 3 # green\n\n    for r in range(upper_rows):\n        for c in range(upper_cols):\n            if upper_region[r, c] != template_background_color and not visited_upper[r, c]:\n                component_pixels, border_color, bbox = find_template_components(upper_region, r, c, template_background_color, visited_upper)\n                \n                if border_color != -1: # Found a valid template with a border\n                    min_r, min_c, max_r, max_c = bbox\n                    # Extract the pattern as the rectangular bounding box of the component\n                    pattern = upper_region[min_r:max_r+1, min_c:max_c+1]\n                    \n                    # Check if this border color is already mapped, maybe prioritize larger patterns?\n                    # For now, simply overwrite if encountered again.\n                    template_map[border_color] = pattern\n                    \n                    # Mark component as visited (redundant as find_template_components updates visited_upper)\n                    # for pr, pc in component_pixels:\n                    #      visited_upper[pr, pc] = True # Ensure component pixels are marked\n\n\n    # --- 2. Identify Fragments (Lower Region: Rows 7 onwards) ---\n    fragments = [] # List of (color, top_left_coord (r,c))\n    lower_region_start_row = 7\n    if rows <= lower_region_start_row: # Handle case where grid is too small\n         return output_grid.tolist() \n         \n    lower_region = input_grid[lower_region_start_row:, :]\n    lower_rows, lower_cols = lower_region.shape\n    visited_lower = np.zeros_like(lower_region, dtype=bool)\n    fragment_background_color = 0 # white\n\n    for r in range(lower_rows):\n        for c in range(lower_cols):\n            if lower_region[r, c] != fragment_background_color and not visited_lower[r, c]:\n                frag_color = lower_region[r, c]\n                # Find the component using the fragment's specific color\n                component_pixels, bbox = find_connected_components(lower_region, r, c, frag_color, visited_lower)\n                \n                min_r, min_c, _, _ = bbox\n                # Store fragment color and its top-left relative to the lower region\n                # Adjust top-left coordinate to be relative to the *full* grid\n                fragments.append((frag_color, (min_r + lower_region_start_row, min_c)))\n\n\n    # Sort fragments by top-left coordinate (row then column) for deterministic pasting\n    fragments.sort(key=lambda x: x[1])\n\n    # --- 3. & 4. Apply Transformations ---\n    for frag_color, (r_anchor, c_anchor) in fragments:\n        if frag_color in template_map:\n            pattern_array = template_map[frag_color]\n            h, w = pattern_array.shape\n\n            # Define target slice boundaries\n            r_end = r_anchor + h\n            c_end = c_anchor + w\n\n            # Check if the pattern fits within the grid boundaries\n            if r_end <= rows and c_end <= cols:\n                # Paste the pattern onto the output grid\n                output_grid[r_anchor:r_end, c_anchor:c_end] = pattern_array\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13360,
    "candidates_token_count": 2240,
    "total_token_count": 15600,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 127.911438,
  "retries": null
}