{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the repeating horizontal and vertical grid lines and their color. \nThese lines divide the grid into equal-sized rectangular cell blocks. \nFind the single contiguous pattern object within one of these cell blocks whose \ncolor is neither the background (white, 0) nor the grid line color. \nRecord the pattern's shape (relative coordinates within its block) and color. \nCreate an output grid identical to the input. \nThen, copy the recorded pattern into every cell block in the output grid, \nmaintaining its relative position within each block.\n\"\"\"\n\ndef find_grid_lines(grid):\n    \"\"\"\n    Finds the color, row indices, and column indices of the grid lines.\n    Assumes lines are single pixel thick and span the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    h_lines = []\n    v_lines = []\n    grid_line_color = None\n\n    # Check rows for horizontal lines\n    for r in range(rows):\n        row_colors = np.unique(grid[r, :])\n        if len(row_colors) == 1 and row_colors[0] != 0:\n            grid_line_color = row_colors[0]\n            h_lines.append(r)\n            break # Assume all lines are the same color\n\n    # Check columns for vertical lines (using the determined grid_line_color)\n    if grid_line_color is not None:\n        for c in range(cols):\n            col_colors = np.unique(grid[:, c])\n            if len(col_colors) == 1 and col_colors[0] == grid_line_color:\n                v_lines.append(c)\n\n    # If no horizontal line found, try vertical first\n    if grid_line_color is None:\n        for c in range(cols):\n             col_colors = np.unique(grid[:, c])\n             if len(col_colors) == 1 and col_colors[0] != 0:\n                 grid_line_color = col_colors[0]\n                 v_lines.append(c)\n                 break # Assume all lines are the same color\n        \n        # Now check rows using the found color\n        if grid_line_color is not None:\n            for r in range(rows):\n                 row_colors = np.unique(grid[r, :])\n                 if len(row_colors) == 1 and row_colors[0] == grid_line_color:\n                     h_lines.append(r)\n                     \n    # Ensure lines were found\n    if grid_line_color is None or not h_lines or not v_lines:\n        # Fallback: Find the most frequent non-zero color if lines aren't full spans\n        # This is less robust but handles cases where patterns might touch edges\n        non_zero_colors = grid[grid != 0]\n        if non_zero_colors.size > 0:\n             count = Counter(non_zero_colors)\n             grid_line_color = count.most_common(1)[0][0]\n             \n             h_lines = [r for r in range(rows) if np.all(grid[r,:] == grid_line_color)]\n             v_lines = [c for c in range(cols) if np.all(grid[:,c] == grid_line_color)]\n             if not h_lines or not v_lines:\n                 raise ValueError(\"Could not reliably determine grid lines.\")\n        else:\n             raise ValueError(\"Could not determine grid line color.\")\n\n\n    return grid_line_color, sorted(h_lines), sorted(v_lines)\n\ndef get_cell_blocks(rows, cols, h_lines, v_lines):\n    \"\"\"\n    Calculates the boundaries of cell blocks based on grid lines.\n    Returns a list of tuples: (r_start, r_end, c_start, c_end)\n    Note: end indices are exclusive (like slicing).\n    \"\"\"\n    blocks = []\n    row_starts = [0] + [r + 1 for r in h_lines]\n    row_ends = [r for r in h_lines] + [rows]\n    col_starts = [0] + [c + 1 for c in v_lines]\n    col_ends = [c for c in v_lines] + [cols]\n\n    for rs, re in zip(row_starts, row_ends):\n        for cs, ce in zip(col_starts, col_ends):\n             # Skip blocks that are just grid lines themselves\n             if re > rs and ce > cs: \n                 blocks.append((rs, re, cs, ce))\n    return blocks\n\n\ndef find_pattern(grid, blocks, grid_line_color):\n    \"\"\"\n    Finds the unique pattern in one of the blocks.\n    Returns the pattern color and a list of relative (dr, dc) coordinates.\n    \"\"\"\n    pattern_coords = []\n    pattern_color = None\n    source_block_origin = None\n\n    for r_start, r_end, c_start, c_end in blocks:\n        block = grid[r_start:r_end, c_start:c_end]\n        found_pattern = False\n        current_pattern_coords = []\n        current_pattern_color = None\n\n        for r in range(block.shape[0]):\n            for c in range(block.shape[1]):\n                pixel = block[r, c]\n                if pixel != 0 and pixel != grid_line_color:\n                    if not found_pattern:\n                        current_pattern_color = pixel\n                        found_pattern = True\n                    elif pixel != current_pattern_color:\n                         # Handle potential errors if multiple non-grid/bg colors exist\n                         print(f\"Warning: Found unexpected color {pixel} in block starting at ({r_start},{c_start})\")\n                         continue # Skip this pixel if it doesn't match the first pattern color found in this block\n\n                    current_pattern_coords.append((r, c))\n        \n        if found_pattern:\n            # Found the block with the pattern\n            pattern_color = current_pattern_color\n            pattern_coords = current_pattern_coords\n            source_block_origin = (r_start, c_start)\n            break # Assume only one block contains the initial pattern\n\n    if pattern_color is None:\n        raise ValueError(\"Could not find a pattern object in any block.\")\n\n    return pattern_color, pattern_coords\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies a grid structure and a unique pattern within one cell of the grid.\n    Replicates this pattern across all cells defined by the grid structure.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.copy(input_np)\n\n    # 1. Identify grid structure\n    try:\n        grid_line_color, h_lines, v_lines = find_grid_lines(input_np)\n    except ValueError as e:\n        print(f\"Error finding grid lines: {e}\")\n        # Handle cases without clear grid lines? For this task, assume they exist.\n        return input_grid # Return original if structure is unclear\n\n    # 2. Define cell blocks\n    blocks = get_cell_blocks(rows, cols, h_lines, v_lines)\n    if not blocks:\n        print(\"Error: No cell blocks defined by grid lines.\")\n        return input_grid\n\n    # 3. Find the unique pattern and its relative coordinates\n    try:\n        pattern_color, pattern_relative_coords = find_pattern(input_np, blocks, grid_line_color)\n    except ValueError as e:\n        print(f\"Error finding pattern: {e}\")\n        return input_grid # Return original if no pattern found\n\n    # 4. Replicate the pattern in all blocks\n    for r_start, r_end, c_start, c_end in blocks:\n        # Iterate through the relative coordinates of the pattern\n        for dr, dc in pattern_relative_coords:\n            # Calculate absolute coordinates in the target block\n            abs_r = r_start + dr\n            abs_c = c_start + dc\n            # Ensure coordinates are within the grid bounds (safety check)\n            if 0 <= abs_r < rows and 0 <= abs_c < cols:\n                 # Check if the target location is not a grid line itself\n                 if output_grid[abs_r, abs_c] != grid_line_color:\n                    output_grid[abs_r, abs_c] = pattern_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9552,
    "candidates_token_count": 1996,
    "total_token_count": 11548,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.298954,
  "retries": null
}