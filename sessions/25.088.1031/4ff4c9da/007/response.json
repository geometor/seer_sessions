{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies unique template shapes formed by contiguous blocks of azure (8) pixels in the \ninput grid, considering 8-way adjacency (orthogonal and diagonal). These templates \nare characterized by their normalized shape (relative coordinates) and bounding box \ndimensions. \n\nThen, searches the input grid for contiguous blocks of red (2) pixels, also using \n8-way adjacency. \n\nIf a red block exactly matches the shape and bounding box dimensions of any identified \nazure template shape, that red block is recolored entirely to azure (8) in the output \ngrid. All other pixels retain their original color.\n\"\"\"\n\ndef find_contiguous_blocks(grid, color):\n    \"\"\"\n    Finds all contiguous blocks of a specified color in the grid using BFS.\n    Considers 8-way adjacency (orthogonal and diagonal neighbors).\n\n    Args:\n        grid (np.array): The input grid (2D NumPy array).\n        color (int): The color of the blocks to find.\n\n    Returns:\n        list: A list of blocks, where each block is a list of (row, col) tuples\n              representing the coordinates of the pixels in that block.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    blocks = []\n\n    # Define 8 directions for neighbors (orthogonal + diagonal)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), \n                  (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) to find the entire contiguous block\n                current_block = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_block.append((row, col))\n                    \n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if the neighbor has the same color and hasn't been visited\n                            if not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                # Add the found block to the list if it's not empty\n                if current_block:\n                    blocks.append(current_block)\n    return blocks\n\ndef get_shape_and_bbox(block):\n    \"\"\"\n    Calculates the normalized shape, bounding box dimensions, and top-left \n    corner of a block. The shape is represented as a frozenset of relative \n    coordinates (dr, dc) from the top-left corner.\n\n    Args:\n        block (list): A list of (row, col) tuples representing the block.\n\n    Returns:\n        tuple: (shape_frozenset, bbox_height, bbox_width)\n               shape_frozenset: A frozenset of relative (dr, dc) coordinates.\n               bbox_height: Height of the bounding box.\n               bbox_width: Width of the bounding box.\n               Returns (frozenset(), 0, 0) for an empty block.\n    \"\"\"\n    if not block:\n        return frozenset(), 0, 0\n\n    # Extract all row and column coordinates\n    rows, cols = zip(*block)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    # Calculate bounding box dimensions\n    bbox_height = max_r - min_r + 1\n    bbox_width = max_c - min_c + 1\n    \n    # Normalize coordinates relative to the top-left corner (min_r, min_c)\n    # This creates a representation of the shape independent of its position\n    relative_coords = frozenset((r - min_r, c - min_c) for r, c in block)\n    \n    return relative_coords, bbox_height, bbox_width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring specific red blocks to azure.\n    \n    1. Find all contiguous blocks (using 8-way adjacency) of azure (8) pixels \n       to identify source patterns (templates).\n    2. Store the unique shapes (relative coordinates) and bounding box dimensions \n       of these azure source patterns.\n    3. Find all contiguous blocks (using 8-way adjacency) of red (2) pixels \n       (potential target patterns).\n    4. For each red block, calculate its shape and bounding box dimensions.\n    5. Compare the shape and bounding box of each red block to the stored set of \n       azure source patterns.\n    6. If a red block's shape and bounding box exactly match any source pattern, \n       recolor all pixels of that red block to azure (8) in the output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # --- Step 1 & 2: Identify unique source patterns (Azure=8) using 8-way adjacency ---\n    # Use a set to store unique (shape, bbox_h, bbox_w) tuples\n    source_patterns = set() \n    # Find all contiguous blocks of azure pixels\n    azure_blocks = find_contiguous_blocks(input_grid, 8) \n    # Process each azure block\n    for block in azure_blocks:\n        # Get its normalized shape and bounding box dimensions\n        # The original top-left corner coordinates (min_r, min_c) are not needed for the pattern definition\n        shape, bbox_h, bbox_w = get_shape_and_bbox(block)\n        # Add the shape and dimensions to the set if the shape is not empty\n        if shape: \n             source_patterns.add((shape, bbox_h, bbox_w))\n\n    # --- Step 3, 4 & 5: Find red blocks (Red=2) using 8-way adjacency and check against source patterns ---\n    target_color = 2 # Specifically look for red blocks\n    # Find all contiguous blocks of red pixels\n    potential_target_blocks = find_contiguous_blocks(input_grid, target_color)\n    \n    # Process each potential red target block\n    for block in potential_target_blocks:\n        # Get its normalized shape and bounding box dimensions\n        # The original top-left corner coordinates are not needed for comparison\n        shape, bbox_h, bbox_w = get_shape_and_bbox(block) \n        \n        # Check if this red block's shape and bounding box match any source pattern\n        if shape and (shape, bbox_h, bbox_w) in source_patterns:\n            # --- Step 6: Recolor matched red blocks in the output grid ---\n            # Iterate through the actual coordinates of the matched block\n            for r, c in block:\n                 # Modify the pixel in the output grid\n                 # No need for bounds check here as coordinates come directly from find_contiguous_blocks\n                 output_grid[r, c] = 8 # Recolor the pixel to Azure\n            \n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10637,
    "candidates_token_count": 1783,
    "total_token_count": 12420,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 137.114491,
  "retries": null
}