{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nFill the interior of two hollow rectangles with checkerboard patterns derived from the colors of scattered pixels found outside the rectangles, after removing those scattered pixels.\n\nThe assignment of the fill color depends on the count of scattered pixels: the first rectangle found (by top-left border coordinate) is filled with the color that has fewer scattered pixels, and the second rectangle is filled with the color that has more scattered pixels.\n\n1.  Identify all connected objects of non-white pixels.\n2.  Identify exactly two objects that are hollow rectangles (1-pixel border, white interior, min 3x3 size).\n3.  Sort these two rectangles based on their top-left border coordinate (row-major).\n4.  Identify all single-pixel objects (scattered pixels) that lie outside the border and interior of the two rectangles.\n5.  Verify there are exactly two distinct colors among these valid scattered pixels.\n6.  Count the occurrences of each of the two scattered colors.\n7.  Create a copy of the input grid.\n8.  Remove the valid scattered pixels from the copied grid (set to white).\n9.  Assign fill colors: The color with the smaller count fills the first rectangle; the color with the larger count fills the second rectangle.\n10. Fill the interior of the first rectangle with a checkerboard pattern using its assigned fill color.\n11. Fill the interior of the second rectangle with a checkerboard pattern using its assigned fill color.\n12. Return the modified grid.\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0}):\n    \"\"\"\n    Finds connected components (objects) of the same color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of colors to ignore (typically background).\n\n    Returns:\n        list: A list of objects, where each object is a tuple:\n              (color, set of (row, col) coordinates).\n              The list is implicitly ordered by the top-left coordinate of each object found during the scan.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                color = grid[r, c]\n                if color in ignore_colors:\n                    visited.add((r, c))\n                    continue\n                \n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n                \n                # Find the top-left coordinate for this object during BFS start\n                min_r_obj, min_c_obj = r, c \n                \n                while q:\n                    row, col = q.popleft()\n                    \n                    # Update top-left if necessary (should only happen at start)\n                    if row < min_r_obj or (row == min_r_obj and col < min_c_obj):\n                         min_r_obj, min_c_obj = row, col\n\n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    # Store object with its top-left coord for sorting later if needed\n                    objects.append({'color': color, 'coords': obj_coords, 'top_left': (min_r_obj, min_c_obj)})\n                    \n    # Sort objects primarily by row, then column of their top-left coordinate\n    objects.sort(key=lambda obj: obj['top_left'])\n                    \n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    max_r = max(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_hollow_rectangle(grid, coords):\n    \"\"\"\n    Checks if a set of coordinates forms a hollow rectangle with a 1-pixel border.\n    Returns True, bbox, interior_coords if it is, otherwise False, None, None.\n    \"\"\"\n    if not coords:\n        return False, None, None\n\n    bbox = get_bounding_box(coords)\n    if bbox is None:\n        return False, None, None\n    min_r, min_c, max_r, max_c = bbox\n\n    # Check minimal size for a hollow rectangle (at least 3x3)\n    if max_r - min_r < 2 or max_c - min_c < 2:\n        return False, None, None\n\n    # Get color from any coord in the set (they should all be the same)\n    border_color = grid[next(iter(coords))] \n    interior_coords = set()\n    expected_border_coords = set()\n\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_perimeter = (r == min_r or r == max_r or c == min_c or c == max_c)\n            \n            if is_perimeter:\n                # Perimeter pixels must match the border color and be in coords\n                if grid[r, c] != border_color or (r, c) not in coords:\n                    return False, None, None\n                expected_border_coords.add((r,c))\n            else:\n                # Interior pixels must be white (0)\n                if grid[r, c] != 0:\n                     # Check if the interior pixel is part of the original object coords\n                     # This handles cases where the \"object\" includes internal non-white pixels, disqualifying it\n                     if (r, c) in coords:\n                         return False, None, None\n                     # Allow non-white pixels in the bounding box interior *if* they are NOT part of the object being tested\n                     # But for a hollow rectangle, the *defined* interior must be white (0)\n                     pass # This pixel is not part of the border object, ignore its color for now\n                \n                # Add potential interior coord regardless of color initially\n                # We'll check later if *all* these expected interior pixels are white in the grid\n                interior_coords.add((r, c))\n\n\n    # Verify the found coordinates exactly match the expected perimeter\n    if coords != expected_border_coords:\n         return False, None, None\n\n    # Verify all coordinates within the interior bounding box are actually white (0) in the *original* grid\n    for r_int, c_int in interior_coords:\n        if grid[r_int, c_int] != 0:\n            return False, None, None # Found a non-white pixel in the required interior space\n\n    # Must have an interior\n    if not interior_coords:\n        return False, None, None # Solid rectangle\n\n    return True, bbox, interior_coords\n\n\ndef find_hollow_rectangles(objects, grid):\n    \"\"\"\n    Identifies hollow rectangles from a list of objects.\n    Returns rectangles sorted by top-left border coordinate.\n    \"\"\"\n    rectangles = []\n    all_rect_coords = set() # Store border and interior coords for exclusion\n\n    # Objects are already sorted by top-left coord from find_objects\n    for obj in objects:\n        color = obj['color']\n        coords = obj['coords']\n        is_rect, bbox, interior_coords = is_hollow_rectangle(grid, coords)\n        if is_rect:\n            min_r_border, min_c_border, _, _ = bbox\n            # Calculate top-left interior coordinate\n            min_interior_r = min(r for r, c in interior_coords)\n            min_interior_c = min(c for r, c in interior_coords if r == min_interior_r)\n            top_left_interior = (min_interior_r, min_interior_c)\n\n            rect_info = {\n                'border_color': color,\n                'border_coords': coords,\n                'bbox': bbox,\n                'interior_coords': interior_coords,\n                'top_left_interior': top_left_interior,\n                'top_left_border': (min_r_border, min_c_border) # Store for sorting check if needed\n            }\n            rectangles.append(rect_info)\n            all_rect_coords.update(coords)\n            all_rect_coords.update(interior_coords) # Include interior for exclusion check\n\n    # Rectangles should already be sorted because input `objects` were sorted\n    # Double-check sorting (optional, relies on find_objects sorting)\n    # rectangles.sort(key=lambda r: r['top_left_border'])\n\n    return rectangles, all_rect_coords\n\n\ndef find_scattered_pixels_and_counts(objects, excluded_coords):\n    \"\"\"Identifies single pixels outside the excluded coordinates and counts them by color.\"\"\"\n    scattered_pixels_map = defaultdict(list)\n    scattered_counts = defaultdict(int)\n    pixels_to_remove = set()\n\n    for obj in objects:\n        coords = obj['coords']\n        color = obj['color']\n        if len(coords) == 1:\n            coord = list(coords)[0]\n            if coord not in excluded_coords:\n                scattered_pixels_map[color].append(coord)\n                scattered_counts[color] += 1\n                pixels_to_remove.add(coord)\n\n    # Convert counts to a list of (color, count) tuples for sorting\n    scattered_colors_with_counts = list(scattered_counts.items())\n\n    return scattered_pixels_map, scattered_colors_with_counts, pixels_to_remove\n\n\ndef fill_checkerboard(grid, interior_coords, top_left_interior, fill_color):\n    \"\"\"Fills the specified interior coordinates with a checkerboard pattern.\"\"\"\n    if not interior_coords:\n        return # No interior to fill\n\n    r_start, c_start = top_left_interior\n    for r, c in interior_coords:\n        # Calculate checkerboard index relative to the top-left interior cell\n        checker_index = (r - r_start) + (c - c_start)\n        \n        if checker_index % 2 == 0:\n            # Even index gets the fill color\n            grid[r, c] = fill_color\n        else:\n            # Odd index gets the background color (white)\n            grid[r, c] = 0\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding two hollow rectangles, identifying two\n    types of scattered pixels outside them, removing the scattered pixels, and\n    filling the rectangles' interiors with checkerboard patterns. The fill color\n    assignment depends on the count of scattered pixels: the first rectangle (by \n    top-left border coord) gets the color with fewer pixels, the second gets \n    the color with more pixels.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find all colored objects, sorted by top-left coordinate\n    objects = find_objects(output_grid, ignore_colors={0})\n\n    # 2. Identify the two hollow rectangles and their properties.\n    #    The list will be sorted by top-left border coordinate because `objects` was sorted.\n    rectangles, rect_covered_coords = find_hollow_rectangles(objects, output_grid)\n\n    # 3. Check if exactly two rectangles were found\n    if len(rectangles) != 2:\n        # print(f\"Error: Found {len(rectangles)} rectangles, expected 2.\")\n        return input_grid # Return original grid if condition not met\n\n    # 4. Identify scattered pixels outside rectangle areas and count them by color\n    scattered_map, scattered_colors_with_counts, pixels_to_remove = find_scattered_pixels_and_counts(\n        objects, rect_covered_coords\n    )\n\n    # 5. Check if exactly two scattered colors were found\n    if len(scattered_colors_with_counts) != 2:\n        # print(f\"Error: Found {len(scattered_colors_with_counts)} scattered colors, expected 2.\")\n        return input_grid # Return original grid if condition not met\n\n    # 6. Remove scattered pixels from the output grid\n    for r, c in pixels_to_remove:\n        if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n             output_grid[r, c] = 0 # Set to white\n\n    # 7. Assign fill colors based on counts\n    # Sort the scattered colors by their counts (ascending)\n    scattered_colors_with_counts.sort(key=lambda item: item[1])\n    \n    # Color with fewer pixels (first in sorted list)\n    color_fewer_pixels = scattered_colors_with_counts[0][0] \n    # Color with more pixels (second in sorted list)\n    color_more_pixels = scattered_colors_with_counts[1][0] \n\n    # The first rectangle (index 0 in the sorted `rectangles` list) gets the color with fewer pixels\n    fill_color_rect1 = color_fewer_pixels\n    # The second rectangle (index 1) gets the color with more pixels\n    fill_color_rect2 = color_more_pixels\n\n    # 8. Fill interiors with checkerboard pattern\n    # Fill the first rectangle identified (smaller count color)\n    fill_checkerboard(\n        output_grid, \n        rectangles[0]['interior_coords'], \n        rectangles[0]['top_left_interior'], \n        fill_color_rect1\n    )\n    # Fill the second rectangle identified (larger count color)\n    fill_checkerboard(\n        output_grid, \n        rectangles[1]['interior_coords'], \n        rectangles[1]['top_left_interior'], \n        fill_color_rect2\n    )\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6508,
            "end_index": 6673,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11770,
    "candidates_token_count": 3395,
    "total_token_count": 15165,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.612255,
  "retries": null
}