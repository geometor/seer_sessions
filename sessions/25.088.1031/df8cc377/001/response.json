{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nIdentifies two hollow rectangles in the input grid based on their border color.\nIdentifies two distinct colors of scattered single pixels located outside these rectangles.\nRemoves the scattered pixels from the grid (turns them white).\nFills the interior of each rectangle with a checkerboard pattern. \nThe color used to fill the first rectangle is the color of the second scattered pixel type found.\nThe color used to fill the second rectangle is the color of the first scattered pixel type found.\nThe checkerboard pattern starts with the fill color at the top-left interior cell, alternating with white.\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0}):\n    \"\"\"\n    Finds connected components (objects) of the same color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of colors to ignore (typically background).\n\n    Returns:\n        list: A list of objects, where each object is a tuple:\n              (color, set of (row, col) coordinates).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                color = grid[r, c]\n                if color in ignore_colors:\n                    visited.add((r, c))\n                    continue\n                \n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    \n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    objects.append((color, obj_coords))\n                    \n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    max_r = max(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_hollow_rectangle(grid, coords, border_color):\n    \"\"\"\n    Checks if a set of coordinates forms a hollow rectangle with a specific border color.\n    It assumes the coordinates form a single connected component of border_color.\n    \"\"\"\n    if not coords:\n        return False\n        \n    rows, cols = grid.shape\n    bbox = get_bounding_box(coords)\n    if bbox is None:\n        return False\n    min_r, min_c, max_r, max_c = bbox\n\n    # Check if all coords are on the perimeter of the bounding box\n    on_perimeter = True\n    for r, c in coords:\n        if not (r == min_r or r == max_r or c == min_c or c == max_c):\n            on_perimeter = False\n            break\n    if not on_perimeter:\n        return False # Some border pixels are inside the bbox perimeter\n\n    # Check if the perimeter is fully covered (no gaps) and 1 pixel thick\n    # Check if interior is all white (0)\n    interior_coords = set()\n    all_perimeter_pixels = set()\n\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check perimeter pixels\n            if r == min_r or r == max_r or c == min_c or c == max_c:\n                 all_perimeter_pixels.add((r,c))\n                 # If a perimeter pixel is not in coords, it's a gap or wrong color\n                 if (r, c) not in coords:\n                     return False # Gap in border or includes non-border color pixels mistakenly\n            # Check interior pixels\n            else:\n                if grid[r, c] != 0:\n                    return False # Interior is not white\n                interior_coords.add((r,c))\n\n    # Verify that the object coords exactly match the perimeter pixels\n    if coords != all_perimeter_pixels:\n        return False\n\n    # Ensure there's an interior\n    if not interior_coords:\n        return False # Solid rectangle, not hollow\n\n    return True, bbox, interior_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding two hollow rectangles, identifying two\n    types of scattered pixels outside them, removing the scattered pixels, and\n    filling the rectangles' interiors with checkerboard patterns using the\n    swapped scattered pixel colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Find all colored objects\n    objects = find_objects(output_grid, ignore_colors={0})\n\n    # 2. Identify the two hollow rectangles and their properties\n    rectangles = []\n    all_rect_coords = set()\n    for color, coords in objects:\n        is_rect, bbox, interior_coords = is_hollow_rectangle(output_grid, coords, color)\n        if is_rect:\n            # Make sure interior coords are valid\n            if interior_coords:\n                 min_interior_r = min(r for r, c in interior_coords)\n                 min_interior_c = min(c for r, c in interior_coords if r == min_interior_r)\n                 top_left_interior = (min_interior_r, min_interior_c)\n\n                 rectangles.append({\n                    'border_color': color,\n                    'border_coords': coords,\n                    'bbox': bbox,\n                    'interior_coords': interior_coords,\n                    'top_left_interior': top_left_interior\n                 })\n                 all_rect_coords.update(coords)\n            \n            # Basic check for exactly two rectangles\n            if len(rectangles) > 2: \n                # This case shouldn't happen based on examples, handle defensively\n                print(\"Warning: More than two hollow rectangles found.\")\n                # Maybe return input or raise error depending on desired strictness\n                # For now, proceed with the first two found\n                break \n\n    if len(rectangles) != 2:\n        # Handle error: Didn't find exactly two rectangles\n        print(f\"Error: Found {len(rectangles)} rectangles, expected 2.\")\n        return output_grid # Or raise an error\n\n    # 3. Identify scattered pixels and their colors\n    scattered_pixels = defaultdict(list)\n    scattered_colors_ordered = []\n\n    # Iterate through the original objects found\n    for color, coords in objects:\n        # Check if the entire object is outside the rectangle borders\n        if coords.isdisjoint(all_rect_coords):\n            # Assuming scattered pixels are single pixels based on examples\n            if len(coords) == 1:\n                 coord = list(coords)[0]\n                 scattered_pixels[color].append(coord)\n                 if color not in scattered_colors_ordered:\n                     scattered_colors_ordered.append(color)\n\n                 # 4. Remove scattered pixels from the output grid\n                 r, c = coord\n                 output_grid[r, c] = 0 # Set to white\n\n    if len(scattered_colors_ordered) != 2:\n         # Handle error: Didn't find exactly two scattered colors\n         print(f\"Error: Found {len(scattered_colors_ordered)} scattered colors, expected 2.\")\n         # Decide how to proceed - maybe assign default fill colors or return?\n         # For now, let's try to proceed if possible, might fail later\n         # If only one color found, maybe use it for both? If zero, use default?\n         # Let's stick to the strict interpretation for now.\n         return output_grid # Return modified grid with pixels removed but no fill\n\n\n    # 5. Assign fill colors (swap the scattered colors)\n    fill_color_map = {}\n    # Assign the second scattered color found to fill the first rectangle found\n    fill_color_map[rectangles[0]['border_color']] = scattered_colors_ordered[1]\n    # Assign the first scattered color found to fill the second rectangle found\n    fill_color_map[rectangles[1]['border_color']] = scattered_colors_ordered[0]\n\n\n    # 6. Fill interiors with checkerboard pattern\n    for rect_info in rectangles:\n        fill_color = fill_color_map[rect_info['border_color']]\n        r_start, c_start = rect_info['top_left_interior']\n\n        for r, c in rect_info['interior_coords']:\n            # Calculate checkerboard index relative to the top-left interior cell\n            checker_index = (r - r_start) + (c - c_start)\n            \n            if checker_index % 2 == 0:\n                # Even index gets the fill color\n                output_grid[r, c] = fill_color\n            else:\n                # Odd index gets the background color (white)\n                # Ensure it's white (it should be already, but explicit is safer)\n                output_grid[r, c] = 0\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 7355,
            "end_index": 7520,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6531,
    "candidates_token_count": 2277,
    "total_token_count": 8808,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.657269,
  "retries": null
}