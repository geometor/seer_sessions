{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nFill the interior of two hollow rectangles with checkerboard patterns derived \nfrom swapped colors of scattered pixels found outside the rectangles.\n\n1. Identify two hollow rectangles based on their single-pixel-thick borders.\n2. Identify two distinct colors of single, scattered pixels located outside \n   the rectangles.\n3. Remove the scattered pixels from the grid (set to white).\n4. Fill the interior of the first rectangle found with a checkerboard pattern \n   using the color of the second scattered pixel type found.\n5. Fill the interior of the second rectangle found with a checkerboard pattern \n   using the color of the first scattered pixel type found.\n6. The checkerboard pattern starts with the fill color at the top-left interior cell, \n   alternating with white based on relative position (row_delta + col_delta).\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0}):\n    \"\"\"\n    Finds connected components (objects) of the same color in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of colors to ignore (typically background).\n\n    Returns:\n        list: A list of objects, where each object is a tuple:\n              (color, set of (row, col) coordinates).\n              The list is implicitly ordered by the top-left coordinate of each object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                color = grid[r, c]\n                if color in ignore_colors:\n                    visited.add((r, c))\n                    continue\n                \n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    objects.append((color, obj_coords))\n                    \n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    max_r = max(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef is_hollow_rectangle(grid, coords):\n    \"\"\"\n    Checks if a set of coordinates forms a hollow rectangle with a 1-pixel border.\n    Returns True, bbox, interior_coords if it is, otherwise False, None, None.\n    \"\"\"\n    if not coords:\n        return False, None, None\n\n    bbox = get_bounding_box(coords)\n    if bbox is None:\n        return False, None, None\n    min_r, min_c, max_r, max_c = bbox\n\n    # Check minimal size for a hollow rectangle (at least 3x3)\n    if max_r - min_r < 2 or max_c - min_c < 2:\n        return False, None, None\n\n    border_color = grid[min(coords)] # Get color from any coord\n    interior_coords = set()\n    expected_border_coords = set()\n\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_perimeter = (r == min_r or r == max_r or c == min_c or c == max_c)\n            \n            if is_perimeter:\n                # Perimeter pixels must match the border color and be in coords\n                if grid[r, c] != border_color or (r, c) not in coords:\n                    return False, None, None\n                expected_border_coords.add((r,c))\n            else:\n                # Interior pixels must be white (0)\n                if grid[r, c] != 0:\n                    return False, None, None\n                interior_coords.add((r, c))\n\n    # Verify the found coordinates exactly match the expected perimeter\n    if coords != expected_border_coords:\n         # This can happen if a pixel *inside* the bounding box has the border color\n         return False, None, None\n\n    # Must have an interior\n    if not interior_coords:\n        return False, None, None # Solid rectangle\n\n    return True, bbox, interior_coords\n\n\ndef find_hollow_rectangles(objects, grid):\n    \"\"\"Identifies hollow rectangles from a list of objects.\"\"\"\n    rectangles = []\n    all_rect_coords = set() # Store border and interior coords\n\n    for color, coords in objects:\n        is_rect, bbox, interior_coords = is_hollow_rectangle(grid, coords)\n        if is_rect:\n            # Calculate top-left interior coordinate\n            min_interior_r = min(r for r, c in interior_coords)\n            min_interior_c = min(c for r, c in interior_coords if r == min_interior_r)\n            top_left_interior = (min_interior_r, min_interior_c)\n\n            rect_info = {\n                'border_color': color,\n                'border_coords': coords,\n                'bbox': bbox,\n                'interior_coords': interior_coords,\n                'top_left_interior': top_left_interior\n            }\n            rectangles.append(rect_info)\n            all_rect_coords.update(coords)\n            all_rect_coords.update(interior_coords) # Include interior for exclusion check\n\n    return rectangles, all_rect_coords\n\n\ndef find_scattered_pixels(objects, excluded_coords):\n    \"\"\"Identifies single pixels outside the excluded coordinates.\"\"\"\n    scattered_pixels_map = defaultdict(list)\n    scattered_colors_ordered = []\n    pixels_to_remove = set()\n\n    for color, coords in objects:\n        if len(coords) == 1:\n            coord = list(coords)[0]\n            if coord not in excluded_coords:\n                if color not in scattered_colors_ordered:\n                    scattered_colors_ordered.append(color)\n                scattered_pixels_map[color].append(coord)\n                pixels_to_remove.add(coord)\n\n    return scattered_pixels_map, scattered_colors_ordered, pixels_to_remove\n\n\ndef fill_checkerboard(grid, interior_coords, top_left_interior, fill_color):\n    \"\"\"Fills the specified interior coordinates with a checkerboard pattern.\"\"\"\n    if not interior_coords:\n        return # No interior to fill\n\n    r_start, c_start = top_left_interior\n    for r, c in interior_coords:\n        # Calculate checkerboard index relative to the top-left interior cell\n        checker_index = (r - r_start) + (c - c_start)\n        \n        if checker_index % 2 == 0:\n            # Even index gets the fill color\n            grid[r, c] = fill_color\n        else:\n            # Odd index gets the background color (white)\n            grid[r, c] = 0\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding two hollow rectangles, identifying two\n    types of scattered pixels outside them, removing the scattered pixels, and\n    filling the rectangles' interiors with checkerboard patterns using the\n    swapped scattered pixel colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find all colored objects (implicitly ordered by scan)\n    objects = find_objects(output_grid, ignore_colors={0})\n\n    # 2. Identify the two hollow rectangles and their properties\n    # The order in `rectangles` list depends on the order from `find_objects`\n    rectangles, rect_covered_coords = find_hollow_rectangles(objects, output_grid)\n\n    # Check if exactly two rectangles were found\n    if len(rectangles) != 2:\n        # print(f\"Error: Found {len(rectangles)} rectangles, expected 2.\")\n        return input_grid # Return original grid if condition not met\n\n    # 3. Identify scattered pixels and their colors (outside rectangle areas)\n    # The order in `scattered_colors_ordered` depends on scan order of first pixel of each color\n    scattered_map, scattered_colors_ordered, pixels_to_remove = find_scattered_pixels(\n        objects, rect_covered_coords\n    )\n\n    # Check if exactly two scattered colors were found\n    if len(scattered_colors_ordered) != 2:\n        # print(f\"Error: Found {len(scattered_colors_ordered)} scattered colors, expected 2.\")\n        return input_grid # Return original grid if condition not met\n\n    # 4. Remove scattered pixels from the output grid\n    for r, c in pixels_to_remove:\n        if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n             output_grid[r, c] = 0 # Set to white\n\n    # 5. Assign fill colors (swap the scattered colors based on order found)\n    # Fill first rectangle found with second scattered color found\n    fill_color_rect1 = scattered_colors_ordered[1]\n    # Fill second rectangle found with first scattered color found\n    fill_color_rect2 = scattered_colors_ordered[0]\n\n    # 6. Fill interiors with checkerboard pattern\n    # Fill the first rectangle identified\n    fill_checkerboard(\n        output_grid, \n        rectangles[0]['interior_coords'], \n        rectangles[0]['top_left_interior'], \n        fill_color_rect1\n    )\n    # Fill the second rectangle identified\n    fill_checkerboard(\n        output_grid, \n        rectangles[1]['interior_coords'], \n        rectangles[1]['top_left_interior'], \n        fill_color_rect2\n    )\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 7073,
            "end_index": 7238,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5018,
    "candidates_token_count": 2508,
    "total_token_count": 7526,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.844021,
  "retries": null
}