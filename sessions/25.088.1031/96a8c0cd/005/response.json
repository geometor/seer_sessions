{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nPerforms a bounded flood fill originating from the single red (color 2) pixel \nin the input grid. The fill uses red (color 2) and expands into adjacent \n(non-diagonal) white (color 0) pixels. The expansion is stopped by boundaries \ndefined by blue (color 1) pixels, green (color 3) pixels, or the edges of the \ngrid. Only the reachable white pixels are colored red; all other pixels \n(original red, blue, green, non-reachable white) retain their original color.\n\"\"\"\n\ndef find_seed_point(grid, color):\n    \"\"\"\n    Finds the coordinates (row, col) of the first pixel with the specified color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        tuple or None: The (row, col) coordinates of the first matching pixel,\n                       or None if no pixel with that color is found.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                return (r, c)\n    return None # Should not happen if a seed pixel always exists as per task examples\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a bounded flood fill originating from the red pixel (2), filling\n    reachable white pixels (0) with red (2). The fill is bounded by blue (1), \n    green (3) pixels, and the grid edges.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    # Initialize output_grid as a copy of the input. This ensures that\n    # original pixels (seed, boundaries, unreachable white) are preserved\n    # unless explicitly changed by the fill.\n    output_grid = np.copy(input_grid)\n\n    # Define color constants based on the problem description\n    background_color = 0 # White - the medium to be filled\n    boundary_color_1 = 1 # Blue - stops the fill\n    seed_color = 2       # Red - the starting point of the fill\n    fill_color = 2       # Red - the color used to fill\n    boundary_color_2 = 3 # Green - stops the fill\n    boundary_colors = {boundary_color_1, boundary_color_2}\n\n    # 1. Find the starting point for the flood fill (the single red pixel)\n    seed_coords = find_seed_point(input_grid, seed_color)\n\n    # If no seed point is found (e.g., if input doesn't follow assumptions),\n    # return the original grid unchanged.\n    if not seed_coords:\n        return output_grid\n\n    # 2. Perform a Breadth-First Search (BFS) to find all white cells\n    #    reachable from the seed without crossing boundaries.\n    \n    # Set to store coordinates (r, c) of white cells that are reachable\n    # and should be filled with the fill_color.\n    reachable_white_cells = set() \n    \n    # Queue for BFS, initialized with the starting seed coordinate.\n    queue = deque([seed_coords])     \n    \n    # Set to keep track of all visited coordinates (seed, reachable white,\n    # boundary neighbors) to avoid redundant processing and infinite loops.\n    # Start with the seed already visited.\n    visited = {seed_coords}          \n\n    while queue:\n        # Get the next coordinate from the front of the queue\n        r, c = queue.popleft()\n\n        # Explore the 4 adjacent neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within the grid boundaries\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue # Neighbor is outside the grid, acts as a boundary\n\n            # Check if the neighbor has already been visited\n            if (nr, nc) in visited:\n                continue # Skip if already processed or currently in the queue\n\n            # Mark the neighbor as visited *before* processing its color\n            # to prevent it being added multiple times to the queue.\n            visited.add((nr, nc))\n\n            # Get the color of the neighbor in the *original* input grid\n            neighbor_color = input_grid[nr, nc]\n\n            # Check the neighbor's color:\n            if neighbor_color == background_color:\n                # If the neighbor is white (background), it's part of the area \n                # to be filled. Add it to our set of reachable white cells \n                # and add it to the queue to explore from it later.\n                reachable_white_cells.add((nr, nc))\n                queue.append((nr, nc))\n            elif neighbor_color in boundary_colors:\n                # If the neighbor is a boundary color (blue or green), the fill\n                # stops along this path. Do not add to queue. It's already marked \n                # visited, so we won't try to enter it again from another path.\n                pass \n            else:\n                # If the neighbor is any other color (e.g., the seed color itself,\n                # or potentially other colors not mentioned), treat it like a boundary.\n                # The fill stops here. Do not add to queue. Marked as visited.\n                # (This case covers revisiting the seed's neighbors if the seed itself was white initially,\n                # or handling unexpected colors in the input grid gracefully by treating them as barriers).\n                 pass\n\n    # 3. Modify the output grid: Change the color of all identified \n    #    reachable white cells to the fill color (red).\n    for r_fill, c_fill in reachable_white_cells:\n        output_grid[r_fill, c_fill] = fill_color\n\n    # 4. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8680,
    "candidates_token_count": 1416,
    "total_token_count": 10096,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 149.107621,
  "retries": null
}