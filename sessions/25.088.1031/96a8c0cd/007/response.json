{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by filling enclosed regions of white pixels (0) with \nred pixels (2). A region is considered enclosed if it is surrounded by blue (1) \npixels, green (3) pixels, or the grid boundaries, such that no white pixel \nwithin the region can reach the edge of the grid by moving only through other \nwhite pixels. The original blue, green, and single red pixels remain unchanged.\n\"\"\"\n\ndef find_enclosed_white_regions(input_grid):\n    \"\"\"\n    Identifies all contiguous regions of white pixels (0) and determines which \n    ones are enclosed by boundaries (blue=1, green=3, or grid edges).\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples \n                   representing the coordinates of pixels in an enclosed white region.\n    \"\"\"\n    rows, cols = input_grid.shape\n    white = 0\n    boundary_colors = {1, 3} # Blue and Green\n    fill_color = 2 # Red (used internally for marking during check, not final fill)\n\n    # Create a padded grid to handle edge cases easily. \n    # Pad with a temporary value (-1) distinct from colors 0-9.\n    padded_grid = np.pad(input_grid, pad_width=1, mode='constant', constant_values=-1)\n    \n    # Use the fill color (red=2) as a temporary marker for flood fill from the outside.\n    # We will revert these changes later. We choose red because it's unlikely to be \n    # the padding value or a boundary value. The original red pixel's location is\n    # irrelevant for *finding* enclosed regions.\n    \n    q = deque()\n    \n    # Start flood fill from all points on the padded border (virtual outside area)\n    # Add all border cells of the *padded* grid to the queue if they are not boundaries.\n    # This simulates filling from the \"outside\" inwards.\n    \n    # Top and bottom rows\n    for c in range(cols + 2):\n        if padded_grid[0, c] == white:\n            padded_grid[0, c] = fill_color\n            q.append((0, c))\n        if padded_grid[rows + 1, c] == white:\n             padded_grid[rows + 1, c] = fill_color\n             q.append((rows + 1, c))\n             \n    # Left and right columns (excluding corners already done)\n    for r in range(1, rows + 1):\n        if padded_grid[r, 0] == white:\n            padded_grid[r, 0] = fill_color\n            q.append((r, 0))\n        if padded_grid[r, cols + 1] == white:\n             padded_grid[r, cols + 1] = fill_color\n             q.append((r, cols + 1))\n             \n    # Perform flood fill (BFS) from the outside\n    while q:\n        r, c = q.popleft()\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds of the padded grid\n            if not (0 <= nr < rows + 2 and 0 <= nc < cols + 2):\n                continue\n                \n            # If the neighbor is white, fill it and add to queue\n            if padded_grid[nr, nc] == white:\n                padded_grid[nr, nc] = fill_color # Mark as reachable from outside\n                q.append((nr, nc))\n                \n    # Now, iterate through the *original* grid area within the padded grid.\n    # Any remaining white pixels were not reachable from the outside,\n    # meaning they belong to enclosed regions.\n    enclosed_regions = []\n    visited_enclosed = set()\n\n    for r in range(1, rows + 1):\n        for c in range(1, cols + 1):\n            # If it's a white pixel in the padded grid AND not yet visited as part of an enclosed region\n            if padded_grid[r, c] == white and (r - 1, c - 1) not in visited_enclosed:\n                # Found the start of a new enclosed region. Find all its connected white pixels.\n                current_region = set()\n                region_q = deque([(r, c)])\n                \n                # Mark the starting padded cell as visited *internally* for this BFS\n                # to avoid infinite loops within this specific region find.\n                # Also add the *original* coordinate to the main visited set.\n                padded_grid[r,c] = -2 # Temporarily mark to avoid re-adding to region_q\n                original_coord = (r - 1, c - 1)\n                current_region.add(original_coord)\n                visited_enclosed.add(original_coord)\n\n                while region_q:\n                    curr_r, curr_c = region_q.popleft()\n                    \n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check bounds (should be within padded grid)\n                        if not (1 <= nr < rows + 1 and 1 <= nc < cols + 1):\n                           continue # Should not happen if boundary check is correct, but safety first\n\n                        # If neighbor is also an untouched white pixel (meaning enclosed)\n                        if padded_grid[nr, nc] == white:\n                             padded_grid[nr, nc] = -2 # Mark as visited for this region BFS\n                             original_coord_neighbor = (nr - 1, nc - 1)\n                             current_region.add(original_coord_neighbor)\n                             visited_enclosed.add(original_coord_neighbor)\n                             region_q.append((nr, nc))\n\n                if current_region: # Should always be true if we entered the if block\n                    enclosed_regions.append(current_region)\n\n    return enclosed_regions\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills enclosed white regions of the input grid with red (2).\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input.\n    output_grid = np.copy(input_grid)\n    \n    # Define colors\n    white = 0\n    fill_color = 2 # Red\n\n    # 1. Find all enclosed white regions using the helper function\n    #    This function uses a flood-fill from the outside approach.\n    regions_to_fill = find_enclosed_white_regions(input_grid)\n\n    # 2. Fill the identified enclosed regions in the output grid\n    for region in regions_to_fill:\n        for r, c in region:\n            # Double check we are only changing white pixels, though the logic\n            # in find_enclosed_white_regions should guarantee this.\n            if output_grid[r, c] == white:\n                output_grid[r, c] = fill_color\n\n    # 3. Return the modified grid. Non-white pixels and non-enclosed white\n    #    pixels were preserved from the initial copy.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18089,
    "candidates_token_count": 1754,
    "total_token_count": 19843,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.935931,
  "retries": null
}