{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Dict, Optional\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies the largest contiguous component (blob) for each non-white color \npresent in the input grid. Determines the maximum size among these largest blobs.\nFilters these largest blobs, keeping only those whose size is at least half of \nthe maximum size found. Changes the color of all pixels within these filtered \nblobs to yellow (4). A component is defined as a group of connected pixels \nof the same color, where connectivity includes adjacent pixels (up, down, \nleft, right).\n\"\"\"\n\ndef find_blobs(grid: np.ndarray, color: int) -> List[Set[Tuple[int, int]]]:\n    \"\"\"\n    Finds all contiguous blobs of a given color using BFS.\n\n    Args:\n        grid: The input grid as a NumPy array.\n        color: The target color to search for.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) tuples\n        of pixels belonging to a single blob. Returns an empty list if no\n        pixels of the specified color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blobs = []\n    # Directions for 4-way connectivity (right, left, down, up)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] \n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited yet,\n            # it's the start of a new potential blob.\n            if grid[r, c] == color and not visited[r, c]:\n                # Start Breadth-First Search (BFS) for this blob\n                current_blob_pixels = set()\n                queue = deque([(r, c)])\n                visited[r, c] = True # Mark the starting pixel as visited\n\n                while queue:\n                    # Get the next pixel from the queue\n                    row, col = queue.popleft()\n                    # Add it to the set of pixels for the current blob\n                    current_blob_pixels.add((row, col))\n\n                    # Explore neighbors\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if the neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                # Mark the neighbor as visited and add it to the queue\n                                visited[nr, nc] = True\n                                queue.append((nr, nc))\n\n                # After the BFS completes for this starting pixel, \n                # add the found blob (set of pixels) to our list of blobs.\n                if current_blob_pixels: \n                    blobs.append(current_blob_pixels)\n\n    return blobs\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by finding the largest blob for each non-white \n    color, determining a size threshold based on the maximum size found, and \n    changing only those largest blobs meeting the threshold to yellow (4).\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    \n    # Convert input list of lists to a NumPy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = input_grid_np.copy()\n    height, width = input_grid_np.shape\n    \n    # Find all unique colors present in the grid\n    unique_colors = np.unique(input_grid_np)\n    # Filter out the white color (0)\n    non_white_colors = [c for c in unique_colors if c != 0]\n\n    # Store information about the largest blob for each color\n    # List of dictionaries: [{'color': c, 'size': s, 'pixels': {(r,c),...}}, ...]\n    largest_blobs_info = []\n\n    # Find the largest blob for each non-white color\n    for color in non_white_colors:\n        # Find all distinct contiguous blobs of the current color\n        blobs = find_blobs(input_grid_np, color)\n        \n        # If blobs of this color were found\n        if blobs:\n            # Find the largest blob based on the number of pixels it contains\n            largest_blob = max(blobs, key=len)\n            # Store its information\n            largest_blobs_info.append({\n                'color': color,\n                'size': len(largest_blob),\n                'pixels': largest_blob\n            })\n\n    # If no non-white blobs were found at all, return the original grid\n    if not largest_blobs_info:\n        return output_grid.tolist()\n\n    # Determine the overall maximum size among the largest blobs found\n    max_size = 0\n    for blob_info in largest_blobs_info:\n        if blob_info['size'] > max_size:\n            max_size = blob_info['size']\n            \n    # If max_size is 0 (only possible if all found blobs were empty, which shouldn't happen with current find_blobs),\n    # or if no largest blobs were recorded, return original grid\n    if max_size == 0:\n         return output_grid.tolist()\n\n    # Calculate the size threshold (half of the maximum size)\n    # Using math.ceil ensures that if max_size is odd, the threshold leans towards inclusivity\n    # Example: max_size=5, threshold=3. A blob of size 3 would meet >= 2.5 threshold.\n    # Using simple division should also work due to >= comparison.\n    threshold = max_size / 2.0 \n\n    # Identify all pixels that need to be recolored based on the threshold\n    pixels_to_recolor = set()\n    for blob_info in largest_blobs_info:\n        # If the size of this largest blob (for its color) meets the threshold\n        if blob_info['size'] >= threshold:\n            # Add all its pixels to the set for recoloring\n            pixels_to_recolor.update(blob_info['pixels'])\n\n    # Recolor the identified pixels in the output grid\n    for r, c in pixels_to_recolor:\n        # Check bounds just to be safe, although find_blobs should only return valid coords.\n        if 0 <= r < height and 0 <= c < width: \n             # Change the color of the pixel in the output grid to yellow (4)\n             output_grid[r, c] = 4\n        \n    # Convert the final NumPy array back to a list of lists format for the return value\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13651,
    "candidates_token_count": 1637,
    "total_token_count": 15288,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 133.534355,
  "retries": null
}