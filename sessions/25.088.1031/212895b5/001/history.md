
## train_1

**input:**
```
0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 5 0 5 0 0 0 0 0 0 0 5 0 0 0 0 0 0 5
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8 0 0 0 0 5 0 5 0 0 0
0 0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 5 0 5 0 0 0 0 0 5
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0
0 0 0 5 0 0 0 5 0 0 0 0 5 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 5 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 0 5 0 5 0 0 0 0 0 4 4 5 2 0 0 0 0 0 5
0 0 0 5 2 0 0 0 0 0 4 0 2 0 0 0 0 5 0 0
0 0 0 4 0 2 0 0 4 4 4 2 0 0 0 5 0 0 0 0
0 0 0 4 4 4 2 0 4 0 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 8 8 8 0 0 0 0 5 0 5 0 0 0
0 0 0 0 0 4 4 8 8 8 4 4 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 8 8 8 0 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 0 4 0 2 5 0 5 0 0 0 0 0 5
5 0 0 0 0 2 4 4 4 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 2 0 4 0 5 0 0 0 2 0 0 0 0 0 0 0
0 0 0 2 4 4 4 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 2 0 4 0 0 0 0 0 0 0 0 0 2 5 0 0 0 0
0 2 0 5 4 0 0 5 0 0 0 0 5 0 0 2 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 5 0 5 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 5 0 0 5 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 0 8 8 8 0 0 5 0 0
0 0 0 0 0 0 0 5 0 8 8 8 0 5 0 0 0
0 0 5 0 0 0 0 0 0 8 8 8 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0 0 5 0 0 0
0 0 0 0 0 0 0 0 0 5 0 5 0 0 5 0 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 5 0 0 0 0 0 0 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 5 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 5 2
0 0 0 0 0 5 0 0 5 5 0 0 4 4 4 2 0
0 0 0 0 5 0 2 0 0 0 0 0 4 0 2 0 0
0 0 0 0 0 0 0 2 0 0 4 4 4 2 0 0 0
0 0 0 0 0 0 0 0 2 0 4 0 2 0 0 0 0
0 0 0 5 0 0 0 0 0 8 8 8 0 0 5 0 0
0 0 0 0 0 0 0 5 4 8 8 8 4 5 0 0 0
0 0 5 0 0 0 0 0 0 8 8 8 0 0 0 0 0
0 0 0 0 5 0 0 0 2 0 4 0 2 5 0 0 0
0 0 0 0 0 0 0 2 0 5 4 5 0 2 5 0 0
0 0 0 5 0 0 2 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 2 0 0 0 0 0 0 5 0 0 2 0
0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 2
0 0 5 2 0 0 0 0 0 0 5 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 2 5 0 0 0 0 0 0 0 0 0 0 0 5 0 0
2 0 0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0 5 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0
0 5 0 5 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 5 0 0 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 8 8 8 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 5 0 0 5 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 5 0 5 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 5 0 0 0 0 5 0 0 0 0 0 0 0
```


**output:**
```
0 0 5 0 0 0 0 0 0 0 0 0 0 0 4 4 5 0 0
0 0 0 0 0 0 0 0 0 5 0 0 0 0 4 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 5 4 4 4 0 0 5 0
0 0 0 5 4 4 0 0 0 0 0 0 4 0 5 0 0 0 0
0 5 0 5 0 4 0 5 0 0 4 4 4 2 0 0 0 0 0
0 0 0 0 0 4 4 4 2 0 4 0 2 0 0 0 5 0 0
0 0 0 0 0 0 5 4 0 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 5 0 4 4 8 8 8 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 2 0 4 0 5 0 0 0 0 0 5
0 0 0 0 0 0 0 2 0 0 5 0 0 5 0 0 5 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 5 0 5
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 5 0
0 5 0 5 2 0 0 0 0 0 0 0 0 0 0 5 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 5 0 0 5 0 0 0 0 5 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception**

1.  **Input Grid Structure**: The input grids consist of a white (0) background, scattered gray (5) pixels (some single, some forming small groups), and usually one larger block of azure (8) pixels (typically 3x3).
2.  **Output Grid Structure**: The output grids retain the original gray (5) and azure (8) pixels in their exact positions. The white (0) background pixels are partially replaced by red (2) and yellow (4) pixels. Some white pixels remain unchanged.
3.  **Transformation Focus**: The core transformation happens to the white (0) pixels based on their proximity to the gray (5) pixels.
4.  **Red Pixel Placement (2)**: Red pixels appear in the output where there were white pixels in the input. Their placement seems strongly correlated with *diagonal* adjacency to gray (5) pixels. If a white pixel in the input has one or more gray pixels diagonally adjacent to it, it becomes red in the output.
5.  **Yellow Pixel Placement (4)**: Yellow pixels also replace white pixels from the input. They appear to fill contiguous areas of white pixels that are *orthogonally adjacent* to the newly placed red (2) pixels. This filling process seems bounded by the original gray (5) and azure (8) pixels, the newly placed red (2) pixels, and the grid edges. It behaves like a flood fill originating from the "white side" of the red pixels.
6.  **Static Elements**: Gray (5) and azure (8) pixels act as static obstacles or boundaries that are not modified and constrain the placement of new colors.

**Facts**


```yaml
facts:
  - object: grid
    properties:
      - background_color: white (0)
      - contains: gray_pixels (5)
      - contains: azure_pixels (8)
      - contains: white_pixels (0)
  - object: gray_pixel
    properties:
      - color: 5
      - role: static_obstacle
      - role: trigger_for_red
      - role: boundary_for_yellow
  - object: azure_pixel
    properties:
      - color: 8
      - role: static_obstacle
      - role: boundary_for_yellow
  - object: white_pixel
    properties:
      - color: 0
      - role: background
      - role: potential_transformation_target
  - object: red_pixel
    properties:
      - color: 2
      - role: generated_pixel
      - role: trigger_for_yellow
      - role: boundary_for_yellow
  - object: yellow_pixel
    properties:
      - color: 4
      - role: generated_pixel
      - role: filled_area
  - relationship: red_generation
    condition: A white (0) pixel in the input becomes red (2) if it has at least one diagonally adjacent gray (5) neighbor in the input grid.
  - relationship: yellow_generation
    condition: >
      Yellow (4) pixels are generated via a flood fill process.
      The fill starts from all white (0) pixels that are orthogonally adjacent
      to any red (2) pixel (after all red pixels have been determined).
      The fill propagates orthogonally through contiguous white (0) pixels.
      The fill is bounded by grid edges, gray (5) pixels, azure (8) pixels,
      and red (2) pixels.
  - action: copy_static_pixels
    description: Gray (5) and Azure (8) pixels from the input are copied directly to the output grid in the same locations.
  - action: determine_red_pixels
    description: Identify all white (0) input pixels that meet the red_generation condition and mark their corresponding output locations as red (2).
  - action: flood_fill_yellow
    description: Perform the flood fill described in yellow_generation, changing eligible white (0) pixels to yellow (4) in the output grid.
```


**Natural Language Program**

1.  Create a new grid identical in size to the input grid, initially filled with the same values as the input grid. This will become the output grid.
2.  Iterate through each cell `(row, col)` of the input grid.
3.  If the input cell `(row, col)` has the color white (0):
    a.  Check its eight diagonal neighbors in the input grid.
    b.  Count how many of these diagonal neighbors have the color gray (5).
    c.  If this count is greater than zero, change the color of the cell `(row, col)` in the *output* grid to red (2).
4.  After checking all cells and placing all red (2) pixels in the output grid, initiate a flood fill process for yellow (4) pixels.
5.  Create a queue and add the coordinates `(row, col)` of all white (0) cells in the *output* grid that are orthogonally adjacent (up, down, left, right) to any red (2) cell in the *output* grid.
6.  While the queue is not empty:
    a.  Remove a coordinate `(r, c)` from the front of the queue.
    b.  If the cell `(r, c)` in the *output* grid is still white (0):
        i.  Change the color of cell `(r, c)` in the *output* grid to yellow (4).
        ii. Check the four orthogonal neighbors `(nr, nc)` of `(r, c)`.
        iii. For each neighbor `(nr, nc)` that is within the grid boundaries and whose color in the *output* grid is currently white (0), add `(nr, nc)` to the queue.
7.  Return the modified output grid.
