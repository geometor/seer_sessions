{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies distinct, solid, rectangular objects composed solely of azure (8) and green (3) pixels against a white (0) background in the input grid.\nFrom these valid objects, selects the one with the highest ratio of green pixels to the total number of pixels (green + azure) within the object's bounding box.\nThe output grid is an exact copy of the selected object's pixels.\nIf multiple objects share the maximum ratio, the first one encountered during the scan (typically top-to-bottom, left-to-right) is selected.\nIf no such valid objects are found, returns a 1x1 white (0) grid.\n\nNote: This rule correctly predicts the output for 3 out of 4 provided training examples. It fails on Example 4, where the object with the *minimum* green ratio is the expected output. Further refinement of the selection criteria might be needed if this discrepancy represents a consistent pattern rather than an anomaly.\n\"\"\"\n\ndef find_valid_objects(grid):\n    \"\"\"\n    Finds all distinct, solid, rectangular objects composed only of azure (8) and green (3) pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a valid object\n              and contains keys: 'grid', 'area', 'green_count', 'azure_count',\n              'green_ratio', 'bbox' (min_r, min_c, max_r, max_c), 'height', 'width'.\n              Returns empty list if no valid objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    valid_objects = []\n    valid_colors = {3, 8} # Green and Azure\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a potential object pixel that hasn't been visited\n            if grid[r, c] in valid_colors and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                # Use a set for visited nodes *within this specific BFS*\n                current_component_visited = set([(r,c)])\n                visited[r,c] = True # Mark globally visited\n\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                # Assume component is valid color-wise until a non-valid color is found\n                is_valid_colors_only = True\n\n                # Perform BFS to find all connected non-background pixels\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n\n                    # Check if the current pixel's color is valid (3 or 8)\n                    if grid[curr_r, curr_c] not in valid_colors:\n                        is_valid_colors_only = False\n                        # Continue BFS to mark the entire connected component as visited,\n                        # but know it's not a candidate object due to invalid color.\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, if it's not background (0), and not visited in this BFS\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and \\\n                           (nr, nc) not in current_component_visited:\n\n                            # Mark globally visited and locally for this component\n                            visited[nr, nc] = True\n                            current_component_visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # After BFS, validate the found component\n                if is_valid_colors_only:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    expected_area = height * width\n\n                    # Check 1: Is the component perfectly rectangular?\n                    # Does the number of pixels found match the bounding box area?\n                    is_solid_rectangle = (len(component_coords) == expected_area)\n\n                    # Check 2: (Double-check) Ensure all pixels *within* the bounding box\n                    # belong to the component (ruling out holes or background pixels inside).\n                    if is_solid_rectangle:\n                         for br in range(min_r, max_r + 1):\n                            for bc in range(min_c, max_c + 1):\n                                if (br, bc) not in component_coords:\n                                    # Found a pixel within bbox not in component\n                                    is_solid_rectangle = False\n                                    break\n                                # Redundant check as is_valid_colors_only already checked this\n                                # if grid[br, bc] not in valid_colors:\n                                #    is_solid_rectangle = False\n                                #    break\n                            if not is_solid_rectangle:\n                                break\n\n                    # If it's a solid rectangle of only valid colors, add it\n                    if is_solid_rectangle:\n                        object_grid_data = grid[min_r:max_r+1, min_c:max_c+1]\n                        green_count = np.sum(object_grid_data == 3)\n                        azure_count = np.sum(object_grid_data == 8)\n\n                        # Final verification: counts must match area\n                        if green_count + azure_count == expected_area:\n                             green_ratio = green_count / expected_area if expected_area > 0 else 0.0\n                             valid_objects.append({\n                                'grid': object_grid_data.copy(),\n                                'area': expected_area,\n                                'green_count': green_count,\n                                'azure_count': azure_count,\n                                'green_ratio': green_ratio,\n                                'bbox': (min_r, min_c, max_r, max_c),\n                                'height': height,\n                                'width': width\n                             })\n\n    return valid_objects\n\n\ndef select_object(objects):\n    \"\"\"\n    Selects the object with the highest ratio of green pixels to total area (G/T).\n    Handles tie-breaking by selecting the first object encountered with the max ratio.\n\n    Args:\n        objects (list): A list of valid object dictionaries from find_valid_objects.\n\n    Returns:\n        dict: The dictionary of the selected object, or None if the list is empty.\n    \"\"\"\n    if not objects:\n        return None\n\n    best_object = None\n    # Initialize max_ratio to a value lower than any possible ratio (0.0)\n    max_ratio = -1.0\n\n    # Iterate through found objects\n    for obj in objects:\n        # If this object's ratio is higher than the current max, update\n        if obj['green_ratio'] > max_ratio:\n            max_ratio = obj['green_ratio']\n            best_object = obj\n        # If ratio is equal, the first object encountered (implicit from list order) remains best_object\n\n    return best_object\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the identified rule.\n\n    Args:\n        input_grid_list (list): The input grid as a list of lists.\n\n    Returns:\n        list: The output grid (pixels of the selected object) as a list of lists.\n              Returns [[0]] if no valid object is found or selected.\n    \"\"\"\n    # Convert list of lists to numpy array for easier processing\n    input_grid = np.array(input_grid_list, dtype=int)\n\n    # 1. Find all valid rectangular objects made of green (3) and azure (8)\n    valid_objects = find_valid_objects(input_grid)\n\n    # 2. Select the object based on the maximum green density rule\n    selected_object = select_object(valid_objects)\n\n    # 3. Generate output grid from the selected object\n    if selected_object:\n        # Get the grid data from the selected object dictionary\n        output_grid = selected_object['grid']\n    else:\n        # Handle case where no valid object was found or selected\n        # Return a default 1x1 white grid as specified\n        output_grid = np.array([[0]], dtype=int)\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23251,
    "candidates_token_count": 2044,
    "total_token_count": 25295,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.158056,
  "retries": null
}