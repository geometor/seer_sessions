{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies distinct rectangular objects composed solely of azure (8) and green (3) pixels against a white (0) background in the input grid.\nCounts the number of such valid objects found (n).\n\nIf n = 4:\n  Selects the object with the highest ratio of green pixels to total pixels (green + azure).\n\nIf n = 3:\n  Calculates the ratio of green pixels to azure pixels for each object (handling division by zero).\n  Selects the object whose ratio is closest to 0.5 (minimizes abs(Ratio - 0.5)).\n  (Note: Examples do not show ties for the minimum difference.)\n\nThe output grid is an exact copy of the selected object's pixels.\n\"\"\"\n\n\ndef find_valid_objects(grid):\n    \"\"\"\n    Finds all distinct, rectangular objects composed only of azure (8) and green (3) pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a valid object\n              and contains keys like 'grid', 'area', 'green_count', 'azure_count',\n              'bbox' (min_r, min_c, max_r, max_c). Returns empty list if no valid objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    valid_objects = []\n    valid_colors = {3, 8} # Green and Azure\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background, not visited, and is a potentially valid color\n            if grid[r, c] in valid_colors and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                is_potentially_valid = True # Assume valid colors until proven otherwise\n                \n                # Use BFS to find connected component of non-background pixels\n                bfs_q = deque([(r,c)])\n                current_component_visited_in_bfs = set([(r,c)]) # Track pixels visited in *this specific* BFS\n\n                while bfs_q:\n                    curr_r, curr_c = bfs_q.popleft()\n                    component_coords.add((curr_r, curr_c))\n                    \n                    # Check if the pixel color is valid *for the object*\n                    if grid[curr_r, curr_c] not in valid_colors:\n                        is_potentially_valid = False # Mark component as having invalid colors\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and \\\n                           (nr, nc) not in current_component_visited_in_bfs:\n                            visited[nr, nc] = True # Mark globally visited\n                            current_component_visited_in_bfs.add((nr,nc))\n                            bfs_q.append((nr, nc))\n\n                # After BFS, check if the identified component meets all criteria\n                if is_potentially_valid:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    expected_area = height * width\n                    \n                    # Check 1: Is the component perfectly rectangular (fills its bounding box)?\n                    # Check 2: Does it contain only valid colors (already checked by is_potentially_valid)?\n                    is_solid_rectangle = True\n                    if len(component_coords) != expected_area:\n                        is_solid_rectangle = False\n                    else:\n                        # Double check all pixels within the bbox are part of the component\n                        # (Handles cases where BFS might not have reached a background pixel inside)\n                        for br in range(min_r, max_r + 1):\n                           for bc in range(min_c, max_c + 1):\n                               if (br, bc) not in component_coords:\n                                    # This indicates a hole or non-rectangular shape within the bbox\n                                    is_solid_rectangle = False\n                                    break\n                               if grid[br, bc] == 0: # Should not happen if component_coords is correct, but safety check\n                                   is_solid_rectangle = False\n                                   break\n                           if not is_solid_rectangle:\n                               break\n                    \n                    if is_solid_rectangle:\n                         # Extract the object grid and calculate properties\n                        object_grid_data = grid[min_r:max_r+1, min_c:max_c+1]\n                        green_count = np.sum(object_grid_data == 3)\n                        azure_count = np.sum(object_grid_data == 8)\n\n                        # Final verification: all extracted pixels must be green or azure\n                        if green_count + azure_count == expected_area:\n                            valid_objects.append({\n                                'grid': object_grid_data.copy(),\n                                'area': expected_area,\n                                'green_count': green_count,\n                                'azure_count': azure_count,\n                                'bbox': (min_r, min_c, max_r, max_c),\n                                'height': height,\n                                'width': width\n                            })\n    return valid_objects\n\n\ndef select_object_rule_4(objects):\n    \"\"\"Selects object based on rule for n=4: max (green / total area).\"\"\"\n    best_object = None\n    max_ratio = -1.0\n\n    for obj in objects:\n        if obj['area'] == 0: \n             continue\n        ratio = obj['green_count'] / obj['area']\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_object = obj\n        # Tie-breaking not explicitly defined; first object with max ratio is selected.\n\n    return best_object\n\ndef select_object_rule_3(objects):\n    \"\"\"Selects object based on rule for n=3: min abs( (green/azure) - 0.5 ).\"\"\"\n    best_object = None\n    min_diff = float('inf')\n    target_ratio = 0.5\n\n    for obj in objects:\n        green_count = obj['green_count']\n        azure_count = obj['azure_count']\n        \n        # Calculate ratio Green/Azure, handling division by zero\n        if azure_count == 0:\n            # If azure is 0, ratio is effectively infinite if green > 0, or 0 if green is also 0.\n            # Infinite ratio is infinitely far from 0.5, unless green is also 0 (ratio=0).\n            ratio = float('inf') if green_count > 0 else 0.0\n        else:\n            ratio = green_count / azure_count\n\n        # Calculate difference from the target ratio 0.5\n        diff = abs(ratio - target_ratio)\n\n        # Update best object if this one is closer\n        if diff < min_diff:\n            min_diff = diff\n            best_object = obj\n        # Tie-breaking: Examples don't show ties. If diff == min_diff, the first object\n        # encountered with that minimum difference remains selected.\n            \n    return best_object\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on identifying and selecting specific rectangular objects.\n\n    Args:\n        input_grid_list (list): The input grid as a list of lists.\n\n    Returns:\n        list: The output grid (pixels of the selected object) as a list of lists.\n              Returns [[0]] if no object is selected or an error occurs.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n\n    # 1. Find all valid rectangular objects made of green (3) and azure (8)\n    valid_objects = find_valid_objects(input_grid)\n    num_objects = len(valid_objects)\n\n    selected_object = None\n\n    # 2. Apply selection logic based on the number of objects\n    if num_objects == 4:\n        selected_object = select_object_rule_4(valid_objects)\n    elif num_objects == 3:\n        selected_object = select_object_rule_3(valid_objects)\n    # else: No rule defined for other counts based on examples\n\n    # 3. Generate output grid from the selected object\n    if selected_object:\n        output_grid = selected_object['grid']\n    else:\n        # Handle case where no object was selected (e.g., unexpected object count)\n        # Return a minimal 1x1 black grid as an indicator of failure/no selection.\n        # print(f\"Warning/Error: Found {num_objects} objects, expected 3 or 4, or no object met selection criteria.\")\n        output_grid = np.array([[0]], dtype=int) \n\n    return output_grid.tolist() # Convert back to list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12206,
    "candidates_token_count": 2218,
    "total_token_count": 14424,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.268474,
  "retries": null
}