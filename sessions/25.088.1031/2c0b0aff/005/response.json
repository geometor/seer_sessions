{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies distinct rectangular objects composed solely of azure (8) and green (3) pixels against a white (0) background in the input grid.\nFrom these valid objects, selects the one with the highest ratio of green pixels to the total number of pixels (green + azure) in the object.\nThe output grid is an exact copy of the selected object's pixels.\nIf multiple objects share the maximum ratio, the behavior is currently undefined by the examples, but the implementation will select the first one encountered during the scan (typically top-to-bottom, left-to-right).\nIf no such valid objects are found, returns a 1x1 white (0) grid.\n\"\"\"\n\ndef find_valid_objects(grid):\n    \"\"\"\n    Finds all distinct, rectangular objects composed only of azure (8) and green (3) pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a valid object\n              and contains keys like 'grid', 'area', 'green_count', 'azure_count',\n              'bbox' (min_r, min_c, max_r, max_c), 'height', 'width'. \n              Returns empty list if no valid objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    valid_objects = []\n    valid_colors = {3, 8} # Green and Azure\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is a potential object color and not visited yet\n            if grid[r, c] in valid_colors and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                # Need to track visited status *within this specific BFS* to correctly identify components\n                # that might be adjacent but separated by background\n                current_component_visited = set([(r,c)]) \n                visited[r,c] = True # Mark globally visited too\n                \n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                is_potentially_valid_color_wise = True # Assume valid colors until proven otherwise\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n\n                    # Check if the pixel color is valid *for the object*\n                    if grid[curr_r, curr_c] not in valid_colors:\n                        is_potentially_valid_color_wise = False \n                        # We can potentially break early here if strict validity is needed during BFS,\n                        # but it's safer to find the full component first, then validate.\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-directional) using the grid value check\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and \\\n                           (nr, nc) not in current_component_visited:\n                            \n                            # Check if the neighbor has a valid color *before* adding to queue\n                            if grid[nr, nc] not in valid_colors:\n                                is_potentially_valid_color_wise = False # Mark component as having invalid colors\n\n                            visited[nr, nc] = True # Mark globally visited\n                            current_component_visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # After BFS, check if the identified component meets all criteria\n                if is_potentially_valid_color_wise:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    expected_area = height * width\n\n                    # Check 1: Is the component perfectly rectangular (fills its bounding box)?\n                    # Check 2: Does it contain only valid colors (already checked by is_potentially_valid_color_wise)?\n                    is_solid_rectangle = True\n                    if len(component_coords) != expected_area:\n                        is_solid_rectangle = False\n                    else:\n                        # Double check all pixels within the bbox are part of the component\n                        # and have the correct color. This ensures no background pixels inside\n                        # the bounding box and confirms the shape.\n                        for br in range(min_r, max_r + 1):\n                           for bc in range(min_c, max_c + 1):\n                               if (br, bc) not in component_coords:\n                                    is_solid_rectangle = False\n                                    break\n                               # This check should be redundant due to is_potentially_valid_color_wise\n                               # and the BFS condition `grid[nr, nc] != 0`, but kept for safety.\n                               if grid[br, bc] not in valid_colors: \n                                   is_solid_rectangle = False\n                                   break\n                           if not is_solid_rectangle:\n                               break\n\n                    if is_solid_rectangle:\n                         # Extract the object grid and calculate properties\n                        object_grid_data = grid[min_r:max_r+1, min_c:max_c+1]\n                        green_count = np.sum(object_grid_data == 3)\n                        azure_count = np.sum(object_grid_data == 8)\n\n                        # Final verification: all extracted pixels must be green or azure\n                        # and their sum must equal the area.\n                        if green_count + azure_count == expected_area:\n                            valid_objects.append({\n                                'grid': object_grid_data.copy(),\n                                'area': expected_area,\n                                'green_count': green_count,\n                                'azure_count': azure_count,\n                                'bbox': (min_r, min_c, max_r, max_c),\n                                'height': height,\n                                'width': width\n                            })\n                        # else: # Debugging - print if counts don't match area\n                        #     print(f\"Warning: Object at {min_r},{min_c} failed final count check. G={green_count}, A={azure_count}, Area={expected_area}\")\n\n    return valid_objects\n\n\ndef select_object(objects):\n    \"\"\"\n    Selects the object with the highest ratio of green pixels to total area (G/T).\n\n    Args:\n        objects (list): A list of valid object dictionaries found by find_valid_objects.\n\n    Returns:\n        dict: The dictionary of the selected object, or None if the input list is empty.\n    \"\"\"\n    if not objects:\n        return None\n\n    best_object = None\n    max_ratio = -1.0 # Initialize with a value lower than any possible ratio (0)\n\n    for obj in objects:\n        # Prevent division by zero if an object somehow has zero area (shouldn't happen with valid objects)\n        if obj['area'] == 0: \n             continue \n        \n        # Calculate the ratio of green pixels to total area\n        ratio = obj['green_count'] / obj['area']\n\n        # Update best object if this one has a higher ratio\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_object = obj\n        # Tie-breaking: If ratio == max_ratio, the first object encountered with \n        # that maximum ratio remains selected (based on scan order in find_valid_objects).\n\n    return best_object\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by finding rectangular green/azure objects \n    and selecting the one with the highest density of green pixels.\n\n    Args:\n        input_grid_list (list): The input grid as a list of lists.\n\n    Returns:\n        list: The output grid (pixels of the selected object) as a list of lists.\n              Returns [[0]] if no valid object is found or selected.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n\n    # 1. Find all valid rectangular objects made of green (3) and azure (8)\n    valid_objects = find_valid_objects(input_grid)\n    \n    # 2. Select the object based on the maximum green density rule\n    selected_object = select_object(valid_objects)\n\n    # 3. Generate output grid from the selected object\n    if selected_object:\n        output_grid = selected_object['grid']\n    else:\n        # Handle case where no valid object was found\n        output_grid = np.array([[0]], dtype=int) # Return 1x1 white grid\n\n    return output_grid.tolist() # Convert back to list of lists\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8775,
    "candidates_token_count": 2100,
    "total_token_count": 10875,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 67.376558,
  "retries": null
}