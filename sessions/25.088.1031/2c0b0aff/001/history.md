
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 3 8 8 8 3 8 0 0 0 8 8 3 3 8 8 8 0 0 0
0 0 8 3 3 3 8 3 3 3 0 0 0 3 8 8 8 8 8 3 0 0 0
0 0 8 8 3 8 8 8 3 8 0 0 0 8 8 8 3 8 8 8 0 0 0
0 0 8 8 8 8 3 8 8 8 0 0 0 8 8 3 3 3 8 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 3 8 8 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 3 8 8 8 8 8 0 0 0
0 8 3 8 8 8 8 8 3 8 0 0 0 8 8 8 8 3 8 8 0 0 0
0 8 8 3 8 8 8 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 3 3 3 8 3 8 3 8 0 8 3 8 8 8 8 8 3 0 0 0 0
0 8 8 3 8 8 8 8 8 8 0 3 3 3 8 8 3 8 8 0 0 0 0
0 8 8 8 8 8 8 8 8 8 0 8 3 8 8 3 3 3 8 0 0 0 0
0 8 3 8 8 8 3 8 8 8 0 8 8 8 8 8 3 8 8 0 0 0 0
0 8 8 8 8 3 3 3 8 8 0 8 3 8 8 8 8 3 8 0 0 0 0
0 8 3 8 8 8 3 8 3 8 0 3 3 3 8 8 3 3 3 0 0 0 0
0 3 8 8 8 8 8 8 8 3 0 8 3 8 8 8 8 3 8 0 0 0 0
0 8 8 3 8 8 8 3 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 3 8 8 8 8 8 3
3 3 3 8 8 3 8 8
8 3 8 8 3 3 3 8
8 8 8 8 8 3 8 8
8 3 8 8 8 8 3 8
3 3 3 8 8 3 3 3
8 3 8 8 8 8 3 8
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 8 8 3 8 8 8 3 8 0 0 3 8 8 8 3 8 8 8 3 8 0 0
0 8 8 3 3 3 8 8 8 3 0 0 8 8 3 8 8 8 8 3 3 3 0 0
0 8 8 8 3 8 8 8 8 8 0 0 8 3 3 3 8 8 8 8 3 8 0 0
0 8 3 8 8 8 8 3 8 8 0 0 8 8 3 8 3 8 3 8 8 8 0 0
0 8 8 8 3 8 3 3 3 8 0 0 8 8 8 8 8 8 8 8 3 3 0 0
0 3 8 8 8 8 8 3 8 8 0 0 8 3 8 3 8 8 3 8 8 8 0 0
0 8 8 3 8 8 8 8 3 8 0 0 8 8 8 8 8 3 3 3 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 8 8 3 8 8 8 3 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 3 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 3 8 8 8 8 3 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 3 3 3 8 8 3 3 3 0 8 8 3 8 8 8 8 8 8 8 8 0 0
0 8 8 3 8 8 8 8 3 8 0 8 8 8 3 8 8 8 8 3 3 8 0 0
0 3 8 8 8 3 8 8 8 8 0 8 8 3 3 3 8 8 8 8 8 8 0 0
0 8 3 8 8 8 8 3 8 3 0 8 8 8 3 8 8 8 3 8 8 3 0 0
0 3 3 3 8 8 3 3 3 8 0 3 8 8 8 8 8 3 3 3 8 8 0 0
0 8 3 8 8 8 8 3 8 8 0 8 8 3 8 3 8 8 3 8 8 8 0 0
0 8 8 8 8 3 8 8 8 8 0 8 3 3 3 8 8 8 8 8 3 8 0 0
0 0 0 0 0 0 0 0 0 0 0 8 8 3 8 8 8 3 3 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 3 8 8 8 8 3 8
8 3 3 3 8 8 3 3 3
8 8 3 8 8 8 8 3 8
3 8 8 8 3 8 8 8 8
8 3 8 8 8 8 3 8 3
3 3 3 8 8 3 3 3 8
8 3 8 8 8 8 3 8 8
8 8 8 8 3 8 8 8 8
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 3 8 8 0 0 8 8 3 8 8 3 8 8 0 0 0 0
0 0 8 3 8 8 8 8 8 8 0 0 8 3 3 3 8 8 3 8 0 0 0 0
0 0 8 8 8 3 8 8 8 3 0 0 8 8 3 8 8 3 3 3 0 0 0 0
0 0 8 8 3 3 3 8 8 3 0 0 8 8 8 8 8 8 3 8 0 0 0 0
0 0 8 8 8 3 8 8 8 8 0 0 3 8 8 8 3 8 8 3 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 8 8 8 3 3 3 8 8 0 0 0 0
0 0 8 3 8 8 8 8 8 8 0 0 8 3 8 8 3 8 8 8 0 0 0 0
0 0 8 8 8 8 8 3 8 8 0 0 8 8 8 8 8 8 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 3 8 8 8 3 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 3 3 3 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 3 8 8 8 8 8 3 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 3 3 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 3 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 3 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 3 8 8 3 8 8
8 3 3 3 8 8 3 8
8 8 3 8 8 3 3 3
8 8 8 8 8 8 3 8
3 8 8 8 3 8 8 3
8 8 8 3 3 3 8 8
8 3 8 8 3 8 8 8
8 8 8 8 8 8 3 3
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 3 8 8 8 3 8 0 0 0 3 8 8 3 8 8 3 8
0 0 3 3 3 8 3 3 3 0 0 0 8 8 3 8 8 3 3 3
0 0 8 3 8 8 8 3 8 0 0 0 8 3 3 3 8 8 3 8
0 0 8 8 8 3 8 8 8 0 0 0 8 8 3 8 8 8 8 8
0 0 8 3 8 8 8 8 8 0 0 0 3 8 8 8 8 3 8 8
0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 3 3 3 8
0 0 0 0 0 0 0 0 0 0 0 0 8 8 3 8 8 3 8 8
0 0 0 0 0 0 0 0 0 0 0 0 3 3 8 8 8 8 8 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 0 8 8 8 3 8 8 3 8 8 8 8 0 0 0 0 0 0 0
0 0 8 8 3 3 3 8 8 8 3 8 8 0 0 0 0 0 0 0
0 0 8 8 8 3 8 8 8 3 3 3 8 0 0 0 0 0 0 0
0 0 8 3 8 8 8 8 8 8 3 8 8 0 0 0 0 0 0 0
0 0 3 3 3 8 8 3 8 8 8 8 8 0 0 0 0 0 0 0
0 0 8 3 8 8 3 3 3 8 8 3 8 0 0 0 0 0 0 0
0 0 8 8 8 8 8 3 8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 8 8 8 8 8 8 8 8 8 8
8 8 8 3 8 8 3 8 8 8 8
8 8 3 3 3 8 8 8 3 8 8
8 8 8 3 8 8 8 3 3 3 8
8 3 8 8 8 8 8 8 3 8 8
3 3 3 8 8 3 8 8 8 8 8
8 3 8 8 3 3 3 8 8 3 8
8 8 8 8 8 3 8 8 8 8 8
```

**Perception of Task Elements:**

1.  **Input:** The input is a grid containing a white background (color 0) and several distinct "objects".
2.  **Objects:** These objects are rectangular regions composed solely of azure (color 8) and green (color 3) pixels. They are separated from each other by the white background.
3.  **Output:** The output is a smaller grid, which is an exact copy of one of the rectangular objects found in the input grid.
4.  **Transformation Goal:** The core task is to identify all valid rectangular azure/green objects within the input grid and then apply a specific selection criterion to choose exactly one of them to be the output.
5.  **Selection Logic:** The selection criterion appears to depend on the *number* of valid objects found in the input.
    *   If there are four objects, the object with the highest ratio of green pixels to total pixels (green + azure) is selected.
    *   If there are three objects, a comparison is made between the object with the smallest total area and the object with the largest total area. The object whose ratio of green pixels to azure pixels is closest to 1/3 is selected. In case of a tie in closeness, the object with the larger area is chosen.

**YAML Fact Sheet:**


```yaml
Grid:
  background_color: white (0)
  contains:
    - Objects
    - Background

Objects:
  type: Rectangular regions
  composition:
    - Pixels
  pixel_colors:
    - azure (8)
    - green (3)
  separation: Separated by background_color
  properties:
    - location: (top_left_x, top_left_y)
    - dimensions: (height, width)
    - area: height * width
    - green_pixel_count: count of green (3) pixels
    - azure_pixel_count: count of azure (8) pixels
    - green_total_ratio: green_pixel_count / area
    - green_azure_ratio: green_pixel_count / azure_pixel_count (handle azure_pixel_count = 0)
  count: The number of distinct objects in the input grid.

Transformation:
  action: Identify Objects
  input: Input Grid
  output: List of Objects
  constraints:
    - Must be rectangular.
    - Must contain only azure (8) and green (3) pixels.

  action: Select Object
  input: List of Objects
  output: Single Selected Object
  logic: Based on object count and properties
    - rule_1:
        condition: object count == 4
        criterion: Maximize green_total_ratio
        tie_breaker: (Not observed in examples, assume max area if needed)
    - rule_2:
        condition: object count == 3
        comparison_objects:
          - ObjMinArea (object with minimum area)
          - ObjMaxArea (object with maximum area)
        criterion: Minimize abs(green_azure_ratio - 1/3)
        selection:
          - if abs(Ratio(ObjMinArea) - 1/3) < abs(Ratio(ObjMaxArea) - 1/3): select ObjMinArea
          - else: select ObjMaxArea # Covers > and == cases

  action: Output Grid Generation
  input: Selected Object
  output: Output Grid (copy of the Selected Object)
```


**Natural Language Program:**

1.  Scan the input grid to identify all distinct connected regions (objects) composed of non-white (non-0) pixels.
2.  Filter these regions to retain only those that are perfect rectangles and contain exclusively azure (8) and green (3) pixels. Record these valid objects.
3.  Count the number of valid objects found (`n`).
4.  **If `n` is equal to 4:**
    a.  For each of the four objects, calculate its total number of pixels (area) and the number of green (3) pixels.
    b.  Calculate the ratio of green pixels to total pixels (Green/Total ratio) for each object.
    c.  Select the object that has the highest Green/Total ratio. (Assume unique maximum based on examples).
5.  **If `n` is equal to 3:**
    a.  Identify the object with the smallest total area (`ObjMinArea`) and the object with the largest total area (`ObjMaxArea`).
    b.  For `ObjMinArea` and `ObjMaxArea`, calculate their respective counts of green (3) pixels and azure (8) pixels.
    c.  Calculate the Green/Azure ratio for both objects: `RatioMin = GreenCount(ObjMinArea) / AzureCount(ObjMinArea)` and `RatioMax = GreenCount(ObjMaxArea) / AzureCount(ObjMaxArea)`. (If AzureCount is 0, treat the ratio appropriately, e.g., as infinity or handle as a special case, though not seen in examples).
    d.  Calculate the absolute difference between each ratio and the target value 1/3: `DiffMin = abs(RatioMin - 1/3)` and `DiffMax = abs(RatioMax - 1/3)`.
    e.  Compare the differences:
        i.  If `DiffMin` is strictly less than `DiffMax`, select `ObjMinArea`.
        ii. If `DiffMin` is greater than or equal to `DiffMax`, select `ObjMaxArea`.
6.  Create the output grid by copying the pixels of the selected object exactly, maintaining its dimensions and pixel arrangement.
