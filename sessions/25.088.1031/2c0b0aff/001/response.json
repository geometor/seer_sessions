{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct rectangular objects composed solely of azure (8) and green (3) pixels against a white (0) background in the input grid.\nCounts the number of such valid objects found (n).\n\nIf n = 4:\n  Selects the object with the highest ratio of green pixels to total pixels (green + azure).\n\nIf n = 3:\n  Compares the object with the smallest total area (ObjMinArea) and the object with the largest total area (ObjMaxArea).\n  Calculates the ratio of green pixels to azure pixels for both (RatioMin, RatioMax).\n  Selects the object whose ratio is closest to 1/3 (minimizes abs(Ratio - 1/3)).\n  In case of a tie in closeness, selects the object with the larger area (ObjMaxArea).\n\nThe output grid is an exact copy of the selected object's pixels.\n\"\"\"\n\ndef find_valid_objects(grid):\n    \"\"\"\n    Finds all distinct, rectangular objects composed only of azure (8) and green (3) pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a valid object\n              and contains keys like 'grid', 'area', 'green_count', 'azure_count',\n              'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    valid_objects = []\n    valid_colors = {3, 8} # Green and Azure\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background, not visited, and is a valid color (optimization)\n            if grid[r, c] in valid_colors and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                is_potentially_valid = True\n                \n                # Use BFS to find connected component\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Check if the color is valid for an object\n                    if grid[curr_r, curr_c] not in valid_colors:\n                        is_potentially_valid = False\n                        # Continue BFS to mark all connected non-background pixels as visited,\n                        # but don't add this component as valid later.\n                        # We only need to mark neighbors that haven't been visited yet.\n                        \n                    component_coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != 0: # Connects to any non-background\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # After BFS, check if the component found is a valid object\n                if is_potentially_valid:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    expected_area = height * width\n                    \n                    # Check 1: Is the number of pixels in the component equal to the bounding box area? (Rectangular check)\n                    # Check 2: Do all pixels *within the bounding box* belong to the component? (No holes of background color)\n                    # Check 3: Do all pixels in the component have valid colors (3 or 8)? (Already ensured by is_potentially_valid)\n                    is_rectangular = (len(component_coords) == expected_area)\n                    all_bbox_pixels_in_component = True\n                    \n                    if is_rectangular:\n                        object_grid_data = grid[min_r:max_r+1, min_c:max_c+1]\n                        green_count = np.sum(object_grid_data == 3)\n                        azure_count = np.sum(object_grid_data == 8)\n\n                        # Verify all pixels in the extracted grid are either green or azure\n                        if green_count + azure_count == expected_area:\n                             valid_objects.append({\n                                'grid': object_grid_data.copy(),\n                                'area': expected_area,\n                                'green_count': green_count,\n                                'azure_count': azure_count,\n                                'bbox': (min_r, min_c, max_r, max_c),\n                                'height': height,\n                                'width': width\n                            })\n                        # else: # This handles cases where the bounding box included pixels not part of the component (not perfectly rectangular *or* contained invalid colors within bbox)\n                            # The component itself was only 3s and 8s, but the bounding box wasn't filled correctly.\n                            # print(f\"Debug: Component starting at ({r},{c}) had valid colors but wasn't perfectly rectangular or bbox mismatch.\")\n\n                    # else: # Component wasn't rectangular in shape\n                         # print(f\"Debug: Component starting at ({r},{c}) was not rectangular.\")\n                # else: # Component contained colors other than 3 or 8\n                     # print(f\"Debug: Component starting at ({r},{c}) contained invalid colors.\")\n\n\n    return valid_objects\n\n\ndef select_object_rule_4(objects):\n    \"\"\"Selects object based on rule for n=4: max (green / total area).\"\"\"\n    best_object = None\n    max_ratio = -1.0\n\n    for obj in objects:\n        if obj['area'] == 0: # Avoid division by zero, though unlikely for valid objects\n             continue\n        ratio = obj['green_count'] / obj['area']\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_object = obj\n        # Tie-breaking not explicitly defined in description/examples for this rule.\n        # Assuming unique max based on examples or first max found is sufficient.\n\n    return best_object\n\ndef select_object_rule_3(objects):\n    \"\"\"Selects object based on rule for n=3: compare min/max area objects by closeness of green/azure ratio to 1/3.\"\"\"\n    if len(objects) != 3:\n        return None # Should not happen if called correctly\n\n    # Find min and max area objects\n    objects_sorted_by_area = sorted(objects, key=lambda x: x['area'])\n    obj_min_area = objects_sorted_by_area[0]\n    obj_max_area = objects_sorted_by_area[-1]\n\n    target_ratio = 1/3.0\n\n    # Calculate ratio and difference for min area object\n    if obj_min_area['azure_count'] == 0:\n        # Handle division by zero: Treat ratio as effectively infinite or very large if green_count > 0\n        ratio_min = float('inf') if obj_min_area['green_count'] > 0 else 0.0\n    else:\n        ratio_min = obj_min_area['green_count'] / obj_min_area['azure_count']\n    diff_min = abs(ratio_min - target_ratio)\n\n    # Calculate ratio and difference for max area object\n    if obj_max_area['azure_count'] == 0:\n        ratio_max = float('inf') if obj_max_area['green_count'] > 0 else 0.0\n    else:\n        ratio_max = obj_max_area['green_count'] / obj_max_area['azure_count']\n    diff_max = abs(ratio_max - target_ratio)\n\n    # Select based on minimum difference, breaking ties with max area\n    # print(f\"Debug Rule 3: MinArea(A:{obj_min_area['area']}, R:{ratio_min:.3f}, D:{diff_min:.3f}) | MaxArea(A:{obj_max_area['area']}, R:{ratio_max:.3f}, D:{diff_max:.3f})\")\n    if diff_min < diff_max:\n        # print(\"Debug Rule 3: Selecting Min Area Object\")\n        return obj_min_area\n    else: # Includes diff_min >= diff_max (tie goes to max area)\n        # print(\"Debug Rule 3: Selecting Max Area Object\")\n        return obj_max_area\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying and selecting specific rectangular objects.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The output grid, containing the pixels of the selected object.\n    \"\"\"\n    # 1. Find all valid rectangular objects made of green (3) and azure (8)\n    valid_objects = find_valid_objects(np.array(input_grid))\n    num_objects = len(valid_objects)\n\n    selected_object = None\n\n    # 2. Apply selection logic based on the number of objects\n    if num_objects == 4:\n        selected_object = select_object_rule_4(valid_objects)\n    elif num_objects == 3:\n        selected_object = select_object_rule_3(valid_objects)\n    # Add handling for other counts if necessary, though examples only show 3 and 4.\n    # else:\n        # print(f\"Warning: Found {num_objects} valid objects, expected 3 or 4. No selection rule defined.\")\n        # Potentially return an empty grid or raise an error, depending on requirements.\n\n\n    # 3. Generate output grid from the selected object\n    if selected_object:\n        output_grid = selected_object['grid']\n    else:\n        # Handle case where no object was selected (e.g., unexpected object count)\n        # Returning an empty grid or the input might be options.\n        # Based on ARC, usually an error implies something went wrong.\n        # Let's return a minimal 1x1 black grid as an indicator of failure.\n        print(\"Error: No object selected.\")\n        output_grid = np.array([[0]], dtype=int) \n\n    return output_grid.tolist() # Convert back to list of lists for ARC standard format if needed\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7172,
    "candidates_token_count": 2504,
    "total_token_count": 9676,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 119.396555,
  "retries": null
}