{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nHandles transformations within a grid structure defined by lines of a specific color (C_grid).\nThe transformation rules depend on the color of the pattern found within specific cells:\n1. Identify the grid structure (lines and cells).\n2. Extract the content (block) and determine the primary pattern color for relevant input cells:\n   - For Green (3) rule: Top-Left (TL), Middle-Left (ML), Middle-Center (MC).\n   - For Blue (1) rule: Bottom-Middle (BM), Bottom-Right (BR), Extra-Bottom-Right (ExtraBR - cell below BR).\n3. Initialize the output grid as a copy of the input grid.\n4. Clear the content of cells involved in transformations in the output grid.\n5. Apply transformations based on pattern color:\n   - Green (3): Cyclically shift patterns: TL -> ML, ML -> MC, MC -> TM (Top-Middle).\n   - Blue (1): Rearrange patterns: BM -> BM, BR -> BR, ExtraBR -> ExtraBM (cell below BM), BM -> ExtraBR (copy).\n6. Return the modified output grid. Cells not involved in these specific color transformations remain unchanged.\n\"\"\"\n\ndef find_grid_lines(grid):\n    \"\"\"Finds the most frequent non-background color and its line coordinates.\"\"\"\n    height, width = grid.shape\n    non_background_colors = grid[grid != 0]\n\n    if non_background_colors.size == 0:\n        # Empty grid or all background\n        return None, [], []\n\n    # Find the most frequent non-background color, likely the grid color\n    color_counts = Counter(non_background_colors)\n    grid_color = color_counts.most_common(1)[0][0]\n\n    h_lines = []\n    v_lines = []\n\n    # Find horizontal lines (rows consisting mainly of grid_color or background)\n    for r in range(height):\n        row = grid[r, :]\n        if np.all((row == grid_color) | (row == 0)):\n             # Basic check: if the row *only* contains grid or background color\n             # A more robust check might count non-grid/non-bg colors\n             if np.any(row == grid_color): # Ensure it's not an all-background row\n                 h_lines.append(r)\n\n    # Find vertical lines (columns consisting mainly of grid_color or background)\n    for c in range(width):\n        col = grid[:, c]\n        if np.all((col == grid_color) | (col == 0)):\n            if np.any(col == grid_color):\n                v_lines.append(c)\n\n    # Refine lines: Sometimes corners cause extra lines to be detected.\n    # Assume major lines define roughly equal cells. We expect 2 horizontal and 2 vertical lines for a 3x3 grid structure.\n    # A more sophisticated approach would involve looking at line thickness or spacing,\n    # but for these examples, let's assume the first few detected lines are the main ones.\n    # This part might need adjustment for grids with different structures.\n\n    # Simplification: Find the indices that *separate* the grid sections.\n    # Find indices where the *next* row/col is a grid line\n    h_separators = [r for r in h_lines if r + 1 < height]\n    v_separators = [c for c in v_lines if c + 1 < width]\n\n    # Basic assumption: 2 main horizontal and 2 main vertical lines define the 3x3 core\n    # Let's find the indices bounding the central cell as a heuristic\n    if len(h_lines) >= 2 and len(v_lines) >= 2:\n         # Take the lines that seem to bound the central area\n         h_lines_final = sorted(list(set(h_lines))) # Unique sorted\n         v_lines_final = sorted(list(set(v_lines))) # Unique sorted\n\n         # Heuristic: Assume the lines defining the 3x3 grid are the most prominent\n         # Find pairs of lines with significant gaps between them\n         h_gaps = np.diff(h_lines_final)\n         v_gaps = np.diff(v_lines_final)\n\n         if len(h_gaps) > 0 and len(v_gaps) > 0:\n             # Find the indices of the largest gaps, suggesting cell boundaries\n             # This is still fragile. A better way is needed for general cases.\n             # For now, let's assume the first two lines found are the main ones for simplicity\n             # based on the examples structure (e.g., row 4 and 9, col 4 and 9/14).\n\n             # Let's try finding the lines that bound the largest non-grid areas\n             h_boundaries = [0] + h_lines_final + [height]\n             v_boundaries = [0] + v_lines_final + [width]\n\n             h_cell_dims = np.diff(h_boundaries)\n             v_cell_dims = np.diff(v_boundaries)\n\n             # Assume the first two grid lines define the main structure\n             final_h = h_lines_final[:2] if len(h_lines_final) >=2 else h_lines_final\n             final_v = v_lines_final[:2] if len(v_lines_final) >=2 else v_lines_final\n\n             # Check if there's a third horizontal line for the extra rows\n             if len(h_lines_final) > 2:\n                 final_h.append(h_lines_final[2])\n\n             # Check if there's a third vertical line for the extra columns (less common)\n             if len(v_lines_final) > 2:\n                  final_v.append(v_lines_final[2])\n\n             return grid_color, final_h, final_v\n\n\n    # Fallback if structure isn't clear\n    return grid_color, sorted(list(set(h_lines))), sorted(list(set(v_lines)))\n\n\ndef get_cell_coords(grid_shape, h_lines, v_lines):\n    \"\"\"Calculates the coordinates (r_start, r_end, c_start, c_end) for each cell.\"\"\"\n    coords = {}\n    height, width = grid_shape\n\n    # Define row boundaries (start_inclusive, end_exclusive)\n    row_starts = [0] + [h + 1 for h in h_lines]\n    row_ends = [h for h in h_lines] + [height]\n\n    # Define column boundaries\n    col_starts = [0] + [v + 1 for v in v_lines]\n    col_ends = [v for v in v_lines] + [width]\n\n    # Check if dimensions make sense (enough boundaries for cells)\n    if len(row_starts) < 1 or len(row_ends) < 1 or len(col_starts) < 1 or len(col_ends) < 1:\n         return {} # Cannot define cells\n\n    # Define the 3x3 main grid cells\n    cell_names_3x3 = [\n        [\"TL\", \"TM\", \"TR\"],\n        [\"ML\", \"MC\", \"MR\"],\n        [\"BL\", \"BM\", \"BR\"]\n    ]\n\n    for r_idx in range(min(3, len(row_starts))):\n        for c_idx in range(min(3, len(col_starts))):\n            # Ensure indices are valid\n             if r_idx < len(row_ends) and c_idx < len(col_ends):\n                r_start, r_end = row_starts[r_idx], row_ends[r_idx]\n                c_start, c_end = col_starts[c_idx], col_ends[c_idx]\n                if r_start < r_end and c_start < c_end: # Valid cell dimensions\n                    coords[cell_names_3x3[r_idx][c_idx]] = (r_start, r_end, c_start, c_end)\n\n    # Define potential extra cells below the main 3x3 grid\n    if len(row_starts) > 3 and len(row_ends) > 3:\n        r_start, r_end = row_starts[3], row_ends[3]\n        # Check columns corresponding to BM and BR\n        if \"BM\" in coords:\n            _, _, c_start, c_end = coords[\"BM\"]\n            if r_start < r_end and c_start < c_end:\n                 coords[\"ExtraBM\"] = (r_start, r_end, c_start, c_end)\n        if \"BR\" in coords:\n            _, _, c_start, c_end = coords[\"BR\"]\n            if r_start < r_end and c_start < c_end:\n                 coords[\"ExtraBR\"] = (r_start, r_end, c_start, c_end)\n\n    return coords\n\ndef extract_cell_block(grid, coords):\n    \"\"\"Extracts the subgrid corresponding to the cell coordinates.\"\"\"\n    if coords is None:\n        return None\n    r_start, r_end, c_start, c_end = coords\n    return grid[r_start:r_end, c_start:c_end]\n\ndef get_pattern_color(cell_block, C_grid, background_color=0):\n    \"\"\"Finds the primary color in the cell block, excluding grid and background.\"\"\"\n    if cell_block is None or cell_block.size == 0:\n        return None\n\n    unique_colors = np.unique(cell_block)\n    pattern_colors = [c for c in unique_colors if c != C_grid and c != background_color]\n\n    if not pattern_colors:\n        return None\n    # If multiple pattern colors exist, this simple logic might fail.\n    # Assume only one significant pattern color per cell for this task.\n    return pattern_colors[0]\n\ndef clear_cell(grid, coords, background_color=0):\n    \"\"\"Sets the pixels within the cell boundaries to the background color.\"\"\"\n    if coords is None:\n        return\n    r_start, r_end, c_start, c_end = coords\n    grid[r_start:r_end, c_start:c_end] = background_color\n\ndef place_cell_block(grid, cell_block, coords):\n    \"\"\"Copies the cell_block into the grid at the specified coordinates.\"\"\"\n    if coords is None or cell_block is None:\n        return\n    r_start, r_end, c_start, c_end = coords\n    # Ensure the block fits (it should if coords are correct)\n    block_h, block_w = cell_block.shape\n    target_h = r_end - r_start\n    target_w = c_end - c_start\n    if block_h == target_h and block_w == target_w:\n         grid[r_start:r_end, c_start:c_end] = cell_block\n    else:\n        # Handle potential size mismatch (e.g., clip the block if too large)\n        h = min(block_h, target_h)\n        w = min(block_w, target_w)\n        grid[r_start:r_start+h, c_start:c_start+w] = cell_block[:h, :w]\n        # print(f\"Warning: Size mismatch placing block at {coords}. Block: {block_h}x{block_w}, Target: {target_h}x{target_w}\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies color-dependent cell transformations based on Green(3) and Blue(1) rules.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Identify Grid Structure\n    C_grid, h_lines, v_lines = find_grid_lines(input_grid)\n    if C_grid is None or not h_lines or not v_lines:\n        # Cannot determine grid structure, return copy\n        print(\"Warning: Could not determine grid structure.\")\n        return output_grid\n\n    # 2. Get Cell Coordinates\n    cell_coords = get_cell_coords((height, width), h_lines, v_lines)\n    if not cell_coords:\n        print(\"Warning: Could not determine cell coordinates.\")\n        return output_grid\n\n    # 3. Store Input Cell Contents and Colors for relevant cells\n    input_blocks = {}\n    input_colors = {}\n    green_cells = [\"TL\", \"ML\", \"MC\"]\n    blue_cells = [\"BM\", \"BR\", \"ExtraBR\"] # Note: ExtraBM is a target, not a source\n\n    for cell_name in green_cells + blue_cells:\n        coords = cell_coords.get(cell_name)\n        if coords:\n            block = extract_cell_block(input_grid, coords)\n            input_blocks[cell_name] = block\n            input_colors[cell_name] = get_pattern_color(block, C_grid)\n\n    # --- Apply Transformations ---\n\n    # 4. Process Green (3) Transformation: TL -> ML, ML -> MC, MC -> TM\n    tm_coords = cell_coords.get(\"TM\")\n    tl_coords = cell_coords.get(\"TL\")\n    ml_coords = cell_coords.get(\"ML\")\n    mc_coords = cell_coords.get(\"MC\")\n\n    # Check which input cells have Green patterns\n    tl_is_green = input_colors.get(\"TL\") == 3\n    ml_is_green = input_colors.get(\"ML\") == 3\n    mc_is_green = input_colors.get(\"MC\") == 3\n\n    # Clear target cells if any source cell is green\n    if tl_is_green or ml_is_green or mc_is_green:\n        clear_cell(output_grid, tl_coords)\n        clear_cell(output_grid, tm_coords)\n        clear_cell(output_grid, ml_coords)\n        clear_cell(output_grid, mc_coords)\n\n    # Place patterns in new locations\n    if tl_is_green:\n        place_cell_block(output_grid, input_blocks.get(\"TL\"), ml_coords) # TL -> ML\n    if ml_is_green:\n        place_cell_block(output_grid, input_blocks.get(\"ML\"), mc_coords) # ML -> MC\n    if mc_is_green:\n        place_cell_block(output_grid, input_blocks.get(\"MC\"), tm_coords) # MC -> TM\n\n    # 5. Process Blue (1) Transformation: BM -> BM, BR -> BR, ExtraBR -> ExtraBM, BM -> ExtraBR\n    bm_coords = cell_coords.get(\"BM\")\n    br_coords = cell_coords.get(\"BR\")\n    extra_bm_coords = cell_coords.get(\"ExtraBM\")\n    extra_br_coords = cell_coords.get(\"ExtraBR\")\n\n    # Check which input cells have Blue patterns\n    bm_is_blue = input_colors.get(\"BM\") == 1\n    br_is_blue = input_colors.get(\"BR\") == 1\n    extra_br_is_blue = input_colors.get(\"ExtraBR\") == 1\n\n    # Clear target cells if any source cell is blue\n    if bm_is_blue or br_is_blue or extra_br_is_blue:\n        clear_cell(output_grid, bm_coords)\n        clear_cell(output_grid, br_coords)\n        clear_cell(output_grid, extra_bm_coords)\n        clear_cell(output_grid, extra_br_coords)\n\n    # Place patterns in new locations\n    if bm_is_blue:\n        place_cell_block(output_grid, input_blocks.get(\"BM\"), bm_coords)      # BM -> BM\n        place_cell_block(output_grid, input_blocks.get(\"BM\"), extra_br_coords) # BM -> ExtraBR (copy)\n    if br_is_blue:\n        place_cell_block(output_grid, input_blocks.get(\"BR\"), br_coords)      # BR -> BR\n    if extra_br_is_blue:\n        place_cell_block(output_grid, input_blocks.get(\"ExtraBR\"), extra_bm_coords) # ExtraBR -> ExtraBM\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5430,
    "candidates_token_count": 3837,
    "total_token_count": 9267,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.525817,
  "retries": null
}