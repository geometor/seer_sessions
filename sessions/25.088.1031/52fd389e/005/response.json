{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFor each connected yellow (4) object in the input grid:\n1. Find its bounding box.\n2. Identify the unique non-white (0), non-yellow (4) 'internal color' pixel(s) contained strictly within that bounding box in the input grid.\n3. Count the number of pixels having this 'internal color' within the bounding box. This count determines the 'frame thickness'.\n4. Calculate an expanded bounding box by extending the original bounding box outwards by 'frame thickness' pixels in all directions (up, down, left, right), clamped to the grid boundaries.\n5. Initialize the output grid as a copy of the input grid.\n6. Fill the area *between* the original bounding box and the expanded bounding box in the output grid with the 'internal color'. Specifically, any pixel within the expanded bounding box that is *outside* the original bounding box is colored with the 'internal color', overwriting the existing pixel value. The content inside the original bounding box remains unchanged from the input unless overwritten by the frame.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all connected objects of a given color in the grid using 8-way connectivity.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check boundaries and if neighbor has the target color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(list(obj_coords)) # Store as list of tuples\n    return objects\n\ndef get_bounding_box(object_coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\"\"\"\n    if not object_coords:\n        return None\n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_internal_color_and_count(grid, bounding_box):\n    \"\"\"\n    Finds the non-background (0), non-yellow (4) color and counts its occurrences \n    within a bounding box in the input grid. Assumes only one such color type per box.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    internal_color = None\n    count = 0\n    \n    # First pass: find the color type\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            color = grid[r, c]\n            if color != 0 and color != 4:\n                internal_color = color\n                break # Found the color type\n        if internal_color is not None:\n            break\n\n    if internal_color is None:\n        return None, 0 # No internal color found\n\n    # Second pass: count occurrences of that specific color\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r, c] == internal_color:\n                count += 1\n                \n    return internal_color, count\n\ndef transform(input_grid):\n    # 1. Initialize output_grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Find all distinct Yellow Objects in input_grid.\n    yellow_objects = find_objects(input_grid, 4)\n\n    # 3. Process each Yellow Object found\n    for obj_coords in yellow_objects:\n        if not obj_coords:\n            continue\n\n        # 3a. Get its bounding_box.\n        bbox = get_bounding_box(obj_coords)\n        if bbox is None:\n            continue\n        min_r, min_c, max_r, max_c = bbox\n\n        # 3b. Find its internal_color and internal_count (thickness).\n        frame_color, thickness = find_internal_color_and_count(input_grid, bbox)\n\n        # 3c. If internal_color exists and thickness is positive:\n        if frame_color is not None and thickness > 0:\n            # i. Calculate the expanded_bounding_box.\n            exp_min_r = max(0, min_r - thickness)\n            exp_min_c = max(0, min_c - thickness)\n            exp_max_r = min(rows - 1, max_r + thickness)\n            exp_max_c = min(cols - 1, max_c + thickness)\n\n            # ii. Draw the frame: Color pixels in the expanded box BUT outside the original box.\n            for r in range(exp_min_r, exp_max_r + 1):\n                for c in range(exp_min_c, exp_max_c + 1):\n                    # Check if the current pixel (r, c) is outside the original bounding box\n                    is_outside_original_box = not (min_r <= r <= max_r and min_c <= c <= max_c)\n                    \n                    if is_outside_original_box:\n                        output_grid[r, c] = frame_color\n\n    # 4. Return the final modified grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20421,
    "candidates_token_count": 1481,
    "total_token_count": 21902,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.760732,
  "retries": null
}