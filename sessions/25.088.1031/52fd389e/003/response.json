{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies connected components of yellow (4) pixels in the input grid. \nFor each yellow component:\n1. Determines its bounding box.\n2. Finds the unique non-yellow, non-white color pixel located within that bounding box in the input grid. This is the 'frame_color'.\n3. Calculates an expanded bounding box by extending the original one pixel outwards in all directions (including diagonals).\n4. Colors the pixels lying on the *perimeter* of this expanded bounding box with the 'frame_color', overwriting any existing color in the output grid. The interior of the frame (including the original yellow shape and its internal colored pixels) remains unchanged from the input, unless overwritten by a frame pixel.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all connected objects of a given color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) for a new object\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check boundaries and if neighbor has the target color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(list(obj_coords)) # Store as list of tuples\n    return objects\n\ndef get_bounding_box(object_coords):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\"\"\"\n    if not object_coords:\n        return None\n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_internal_color(grid, bounding_box):\n    \"\"\"Finds the first non-background (0), non-yellow (4) color within a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            color = grid[r, c]\n            # Check if the color is neither white (0) nor yellow (4)\n            if color != 0 and color != 4:\n                return color\n    # Fallback if no such color is found (should not happen based on examples)\n    return None \n\ndef transform(input_grid):\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Find all distinct yellow objects (connected components)\n    yellow_objects = find_objects(input_grid, 4)\n\n    # 2. Process each yellow object found\n    for obj_coords in yellow_objects:\n        if not obj_coords:\n            continue\n            \n        # 2a. Determine the bounding box of the current yellow object\n        bbox = get_bounding_box(obj_coords)\n        if bbox is None:\n            continue\n        min_r, min_c, max_r, max_c = bbox\n\n        # 2b. Find the 'frame color' associated with this object\n        # Search within the bounding box in the input grid for a non-white, non-yellow pixel\n        frame_color = find_internal_color(input_grid, bbox)\n        if frame_color is None:\n            # If no internal color found (unexpected based on examples), skip this object\n            continue\n\n        # 2c. Calculate the coordinates of the expanded bounding box (frame boundaries)\n        # Extend by one pixel outwards, clamping to grid boundaries\n        exp_min_r = max(0, min_r - 1)\n        exp_min_c = max(0, min_c - 1)\n        exp_max_r = min(rows - 1, max_r + 1)\n        exp_max_c = min(cols - 1, max_c + 1)\n\n        # 2d. Iterate through all cells within the expanded bounding box\n        for r in range(exp_min_r, exp_max_r + 1):\n            for c in range(exp_min_c, exp_max_c + 1):\n                # 2e. Check if the current cell (r, c) lies on the perimeter of the expanded box\n                is_perimeter = (r == exp_min_r or r == exp_max_r or\n                                c == exp_min_c or c == exp_max_c)\n\n                # 2f. If it's on the perimeter, update the output grid pixel with the frame color\n                if is_perimeter:\n                    output_grid[r, c] = frame_color\n\n    # 3. Return the final modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15666,
    "candidates_token_count": 1329,
    "total_token_count": 16995,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.118501,
  "retries": null
}