
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0
0 0 6 6 6 6 6 6 0 0 6 6 6 6 3 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 3 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 3 0 0 0
0 3 8 8 3 3 8 8 0 0 8 8 3 3 8 3 0 0 0 3 0 0
0 3 8 8 3 3 8 8 0 0 8 8 3 3 8 8 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 6 6 0 0 6 6 3 6 6 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 3 8 3 3 8 3 0 3 0 0 0 3
0 0 8 8 3 3 3 8 0 0 3 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 3 3 3 3 8 0 0 0 0 0 0
3 3 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0
0 0 6 6 3 6 6 6 0 3 6 6 6 3 6 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 3 0
0 0 8 3 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 6 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 6 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 6 6 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 8 8 3 3 8 8 0 0 8 8 3 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 3 0 0 0 3 3 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 1 1 1 2 3 3 0 3 0 0
0 1 1 3 3 3 0 1 1 2 3 3 0 1 1 2 3 3 3 0 3 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 1 3 3 0 0 0 3
0 1 3 3 3 1 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 1 3 3 3 0 3 1 2 3 3 0 1 1 2 3 3 0 0 3 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 3 2 1 3 0 1 1 2 3 3 0 0 0 0
1 1 1 2 3 3 0 1 1 2 3 3 3 1 3 2 3 3 0 0 0 0
0 8 1 8 8 3 0 8 8 8 8 8 0 1 8 8 8 8 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 3 0
0 1 1 3 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 1 3 3 0 1 1 2 3 1 0 0 0 0
1 1 1 2 3 3 0 1 1 2 3 1 0 1 1 2 3 3 0 0 0 0
3 8 8 8 3 3 1 8 8 8 8 8 0 8 8 8 8 8 0 0 1 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 0 3 0 3 0 1 1 0 3 0 0 0 0 0 0 0 0 0 1
0 0 3 0 0 1 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 1 1 2 3 3 0 1 1 2 3 3 0 1 1 2 3 3 0 0 0 0
0 8 8 8 8 8 0 8 8 8 8 8 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3
0 2 2 2 2 2 0 2 2 2 2 0 0 2 2 2 2 0 0 0 0 3
0 3 2 2 3 0 0 3 2 2 3 0 3 3 2 2 3 0 0 3 0 0
0 2 3 3 3 0 0 3 3 3 3 0 0 3 3 3 3 0 0 0 0 0
0 2 3 1 3 0 0 2 2 1 2 0 0 3 1 1 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0
0 2 2 2 2 3 0 2 2 2 2 0 0 2 2 2 2 2 0 0 0 0
0 3 2 2 3 0 0 3 2 2 3 0 3 3 2 2 3 2 0 0 0 0
0 3 3 3 3 0 0 3 3 3 3 0 0 3 3 3 3 0 0 0 0 0
0 3 3 1 3 0 0 3 1 1 3 0 0 3 1 1 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0
0 2 2 2 2 0 0 3 2 3 2 0 0 2 3 2 2 0 0 0 0 0
0 3 2 2 3 0 0 3 2 3 3 0 0 3 2 3 3 0 0 0 0 0
3 3 3 3 3 0 0 3 3 3 3 0 0 3 2 3 3 0 0 2 0 0
0 3 1 1 3 0 3 3 1 1 3 0 0 3 1 1 3 0 0 0 0 0
0 2 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 2 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 0 0
0 0 0 3 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 0 2 2 2 2 0 0 2 2 2 2 0 0 0 0 0
0 3 2 2 3 0 0 3 2 2 3 0 0 3 2 2 3 0 0 0 0 0
0 3 3 3 3 0 0 3 3 3 3 0 0 3 3 3 3 0 0 0 0 0
0 3 1 1 3 0 0 3 1 1 3 0 0 3 1 1 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 0 2 2 2 2 0 0 2 2 2 2 0 0 0 0 0
0 3 2 2 3 0 0 3 2 2 3 0 0 3 2 2 3 0 0 0 0 0
0 3 3 3 3 0 0 3 3 3 3 0 0 3 3 3 3 0 0 0 0 0
0 3 1 1 3 0 0 3 1 1 3 0 0 3 1 1 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 0 0 2 2 2 2 0 0 2 2 2 2 0 0 0 0 0
0 3 2 2 3 0 0 3 2 2 3 0 0 3 2 2 3 0 0 0 0 0
0 3 3 3 3 0 0 3 3 3 3 0 0 3 3 3 3 0 0 0 0 0
0 3 1 1 3 0 0 3 1 1 3 0 0 3 1 1 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided training examples.

**Perception of Task Elements**

1.  **Grid Structure:** The input and output are 2D grids of colored pixels (represented by integers 0-9). White (0) acts as the background.
2.  **Objects:** The inputs contain distinct, repeating non-background shapes or patterns. These patterns are composed of various colors.
3.  **Noise/Corruption:** Green pixels (color 3) appear frequently in the input grids. Some green pixels seem randomly scattered (noise), while others appear *within* the non-background patterns, seemingly replacing the "correct" color for that position within the pattern (corruption). However, in some examples (like train\_2 and train\_3), green is also a legitimate part of the repeating pattern itself.
4.  **Transformation Goal:** The transformation aims to "clean up" the input grid. This involves two main actions:
    *   Removing the scattered green noise pixels (changing them to white background).
    *   Restoring the corrupted patterns to their "ideal" or most common form. This means replacing green pixels that are deviations from the ideal pattern with the correct color for that position, while *preserving* green pixels that are part of the ideal pattern structure.
5.  **Pattern Identification:** The core challenge is to identify the repeating "ideal" pattern(s) and distinguish between green pixels that are part of this ideal pattern versus those that represent noise or corruption. The ideal pattern seems to be discoverable by observing multiple instances of the pattern within the input grid and identifying the most frequent color at each relative position.

**YAML Facts**


```yaml
task_context:
  description: Clean up noise and restore corrupted patterns in a grid.
  background_color: 0 (white)
  noise_color: 3 (green)
  action_primary: pattern_restoration
  action_secondary: noise_removal

grid_elements:
  - type: background
    color: 0 (white)
    role: Empty space

  - type: pattern
    description: Repeating non-background shapes composed of multiple colors. May appear multiple times in the input.
    properties:
      - size: Varies (e.g., 6x6 in train_1, 6x5 in train_2, 5x4 in train_3 - dimensions based on core colored area)
      - colors: Multiple non-background colors, potentially including green (3).
      - structure: Specific spatial arrangement of colors defining the "ideal" form.
    state_in_input: Can be "ideal" or "corrupted".
    state_in_output: Always "ideal".

  - type: corruption_pixel
    color: 3 (green)
    location: Within a pattern instance, replacing the expected color for that position.
    role: Element to be replaced during restoration.

  - type: noise_pixel
    color: 3 (green)
    location: Outside of any pattern instance, often isolated or in small clusters.
    role: Element to be removed (replaced with background).

transformation:
  - step: Identify repeating non-background patterns and their locations.
  - step: Determine the "ideal" structure for each pattern type by finding the most frequent color at each relative position across all identified instances.
  - step: Create an output grid initialized with the background color.
  - step: For each location where a pattern instance was identified in the input, draw the corresponding "ideal" pattern onto the output grid.
  - result: Output grid contains only ideal patterns on a clean background; noise and corruption green pixels are eliminated or corrected.
```


**Natural Language Program**

1.  Scan the input grid to identify all distinct, multi-pixel, non-background (non-white) connected components or repeating rectangular blocks. These are potential instances of underlying patterns.
2.  Group these instances based on their shape and size to identify recurring pattern types.
3.  For each pattern type, determine its "ideal" template:
    a.  Align all identified instances of this pattern type.
    b.  For each relative position within the aligned patterns, find the color that appears most frequently at that position across all instances.
    c.  Construct the "ideal" template using these most frequent colors for each position.
4.  Create a new output grid of the same dimensions as the input grid, filled entirely with the background color (white, 0).
5.  Iterate through the locations where pattern instances were identified in the input grid.
6.  For each identified location, copy the corresponding *ideal* pattern template (determined in step 3) onto the output grid at that same location.
7.  The final output grid contains the restored patterns, with all noise and corruption (green pixels not part of an ideal pattern) effectively removed, replaced by either the correct pattern color or the background color.
