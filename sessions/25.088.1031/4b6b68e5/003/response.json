{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nThe transformation identifies enclosed regions of white pixels (color 0) within the input grid. \nFor each enclosed white region, it identifies \"marker\" pixels. A marker pixel is defined as a non-white, non-boundary pixel that is 8-directionally adjacent to at least one pixel of the white region. The boundary pixels are the non-white pixels 4-directionally adjacent to the white region.\nIf the number of unique marker pixel positions found for an enclosed region is greater than 1, the transformation proceeds. \nIt counts the occurrences of each color among these unique marker pixels. \nThe most frequent marker color is determined. In case of a tie in frequency, the color with the lowest numerical index is chosen.\nFinally, all the white pixels belonging to that specific enclosed region are recolored to this most frequent marker color in the output grid. \nIf an enclosed white region has 1 or 0 unique marker pixels, or if a white region is not fully enclosed, it remains unchanged. \nThe boundary pixels surrounding the regions also remain unchanged.\n\"\"\"\n\ndef find_connected_white_region(grid, start_pos, global_visited):\n    \"\"\"\n    Performs a BFS starting from start_pos to find a connected region of white pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_pos (tuple): The starting (row, col) for the BFS (must be white).\n        global_visited (np.ndarray): A boolean grid tracking visited pixels across all searches.\n\n    Returns:\n        tuple: (region_pixels, boundary_pixels, is_enclosed)\n               region_pixels (set): Set of (row, col) tuples for the white region.\n               boundary_pixels (set): Set of (row, col) tuples for non-white pixels 4-directionally adjacent to the region.\n               is_enclosed (bool): True if the region does not touch the grid border.\n    \"\"\"\n    H, W = grid.shape\n    q = deque([start_pos])\n    region_pixels = set()\n    boundary_pixels = set() # Pixels defining the immediate boundary\n    is_enclosed = True\n    local_visited = set([start_pos]) # Track visited within this BFS to avoid cycles\n\n    while q:\n        r, c = q.popleft()\n\n        # Check if pixel is on the border\n        if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n            is_enclosed = False # Touched edge\n\n        region_pixels.add((r, c))\n        global_visited[r, c] = True # Mark globally visited\n\n        # Explore neighbors (4-directional for region connectivity and boundary definition)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_color = grid[nr, nc]\n                neighbor_pos = (nr, nc)\n\n                if neighbor_color == 0: # Neighbor is white\n                    if neighbor_pos not in local_visited:\n                        local_visited.add(neighbor_pos)\n                        q.append(neighbor_pos)\n                else: # Neighbor is non-white (part of a boundary)\n                    boundary_pixels.add(neighbor_pos) # Collect boundary pixel position\n            # else: neighbor is out of bounds, which means the region touches the edge if we are near it.\n\n    return region_pixels, boundary_pixels, is_enclosed\n\n\ndef find_adjacent_markers(grid, region_pixels, boundary_pixels):\n    \"\"\"\n    Finds marker pixels adjacent (8-directionally) to the region's white pixels,\n    excluding the immediate 4-directional boundary pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        region_pixels (set): Set of (row, col) for the enclosed white region.\n        boundary_pixels (set): Set of (row, col) for the 4-directional boundary pixels.\n\n    Returns:\n        list: A list of dictionaries, each {'pos': (r, c), 'color': color} for a unique marker pixel.\n    \"\"\"\n    H, W = grid.shape\n    found_markers = {} # Use dict {pos: color} to store unique marker positions and their colors\n\n    # Iterate through each white pixel in the region\n    for r, c in region_pixels:\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < H and 0 <= nc < W:\n                    neighbor_pos = (nr, nc)\n                    neighbor_color = grid[nr, nc]\n\n                    # Check if the neighbor is a potential marker:\n                    # 1. It must not be white (color 0).\n                    # 2. It must not be part of the immediate 4-directional boundary.\n                    if neighbor_color != 0 and neighbor_pos not in boundary_pixels:\n                        # Add to found_markers. If position exists, it's overwritten, ensuring uniqueness by position.\n                        found_markers[neighbor_pos] = neighbor_color\n\n    # Convert the dictionary of unique markers into the desired list format\n    marker_list = [{'pos': pos, 'color': color} for pos, color in found_markers.items()]\n    return marker_list\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies enclosed white regions in the input grid. If a region has more than one unique \n    adjacent non-boundary, non-white marker pixel, it finds the most frequent marker color \n    (lowest index wins ties) and fills the region with that color.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool) # Track visited white pixels globally\n\n    # Iterate through each pixel to find starting points for white regions\n    for r in range(H):\n        for c in range(W):\n            # If it's a white pixel and hasn't been visited by any previous region search\n            if input_grid[r, c] == 0 and not visited[r, c]:\n                \n                # Find the connected white region and its properties using BFS\n                region_pixels, boundary_pixels, is_enclosed = find_connected_white_region(input_grid, (r, c), visited)\n\n                # Process only if the region is fully enclosed and non-empty\n                if is_enclosed and region_pixels:\n                    \n                    # Find unique marker pixels adjacent (8-dir) to the region, excluding the boundary\n                    markers = find_adjacent_markers(input_grid, region_pixels, boundary_pixels)\n                    \n                    # Check if the number of unique markers is greater than 1\n                    if len(markers) > 1:\n                        # Count the colors of the unique markers\n                        marker_colors = [m['color'] for m in markers]\n                        color_counts = Counter(marker_colors)\n                        \n                        # Find the most frequent color, with tie-breaking (lowest color index wins)\n                        max_count = 0\n                        most_common_color = -1 # Default (should be overwritten if counts exist)\n                        \n                        # Sort colors by index to ensure lowest index wins ties\n                        sorted_colors = sorted(color_counts.keys()) \n                        \n                        for color in sorted_colors:\n                            count = color_counts[color]\n                            if count > max_count:\n                                max_count = count\n                                most_common_color = color\n                            # Implicit else: if count == max_count, the lower color index (already processed) remains the choice.\n\n                        fill_color = most_common_color\n\n                        # Fill the identified white region in the output grid with the determined fill color\n                        for pr, pc in region_pixels:\n                            output_grid[pr, pc] = fill_color\n                            \n                # If not enclosed, or <= 1 marker, the region remains white (as copied initially)\n                # The 'visited' array ensures we don't re-process white pixels of already found regions.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10818,
    "candidates_token_count": 1941,
    "total_token_count": 12759,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.346737,
  "retries": null
}