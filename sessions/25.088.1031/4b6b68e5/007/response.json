{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies non-black objects (contiguous regions of the same color 1-9).\nFor each object that does not touch the grid border, it determines the region enclosed by it.\nAn enclosed region consists of all pixels (white or non-boundary color) reachable from the white pixels immediately adjacent (4-directionally) to the object, without crossing the object's pixels and without reaching the grid border.\nIt collects all non-black pixels within this enclosed region that are *not* part of the boundary object itself ('internal markers').\nIf there is more than one unique color among these internal markers, the transformation proceeds.\nIt calculates the frequency of each internal marker color. The fill color is the color with the highest frequency. Ties are broken by choosing the color with the lowest numerical index (e.g., Red(2) wins over Green(3) if both appear the most times).\nAll originally white pixels within the identified enclosed region are then recolored to this fill color in the output grid.\nIf an object touches the border, or its enclosed region touches the border, or there are 1 or 0 unique internal marker colors, the enclosed white pixels remain unchanged. All other pixels (boundary object pixels, internal markers, pixels outside enclosures) also remain unchanged.\n\"\"\"\n\ndef find_object(grid, start_pos, visited_objects):\n    \"\"\"\n    Finds a connected component of a single non-black color using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_pos (tuple): The starting (row, col) for the BFS (must be non-black).\n        visited_objects (np.ndarray): Boolean grid tracking pixels already part of a found object.\n\n    Returns:\n        tuple: (object_color, object_pixels, touches_border)\n               object_color (int): The color index of the object found.\n               object_pixels (set): Set of (row, col) tuples for the object.\n               touches_border (bool): True if any pixel of the object is on the grid border.\n    \"\"\"\n    H, W = grid.shape\n    q = deque([start_pos])\n    object_color = grid[start_pos]\n    object_pixels = set()\n    touches_border = False\n    \n    # Check if start_pos itself is on border\n    r_start, c_start = start_pos\n    if r_start == 0 or r_start == H - 1 or c_start == 0 or c_start == W - 1:\n        touches_border = True\n\n    visited_objects[start_pos] = True\n    object_pixels.add(start_pos)\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (4-directional for connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_pos = (nr, nc)\n                # Check if neighbor is part of the same object and not visited yet\n                if grid[neighbor_pos] == object_color and not visited_objects[neighbor_pos]:\n                    visited_objects[neighbor_pos] = True\n                    object_pixels.add(neighbor_pos)\n                    q.append(neighbor_pos)\n                    # Check if this neighbor touches the border\n                    if nr == 0 or nr == H - 1 or nc == 0 or nc == W - 1:\n                        touches_border = True\n            # Out of bounds neighbors don't matter for object connectivity itself\n            # but border touching is checked via pixel coordinates inside the loop.\n            \n    return object_color, object_pixels, touches_border\n\ndef find_adjacent_white(grid, object_pixels):\n    \"\"\"\n    Finds all white pixels (color 0) 4-directionally adjacent to the object pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        object_pixels (set): Set of (row, col) for the boundary object.\n\n    Returns:\n        set: Set of (row, col) tuples for adjacent white pixels.\n    \"\"\"\n    H, W = grid.shape\n    adjacent_white = set()\n    for r, c in object_pixels:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_pos = (nr, nc)\n                # Check if neighbor is white and not part of the object itself (shouldn't happen with non-black objects)\n                if grid[neighbor_pos] == 0 and neighbor_pos not in object_pixels:\n                     adjacent_white.add(neighbor_pos)\n    return adjacent_white\n\ndef check_enclosure_and_find_markers(grid, start_pixels, boundary_color, boundary_pixels):\n    \"\"\"\n    Performs a flood fill starting from start_pixels to check for enclosure\n    and identify the enclosed region and internal markers.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_pixels (set): Set of (r,c) white pixels adjacent to the boundary to start fill from.\n        boundary_color (int): The color of the boundary object (to avoid crossing).\n        boundary_pixels (set): Set of (r,c) pixels of the boundary object.\n\n    Returns:\n        tuple: (is_enclosed, region_pixels, internal_markers)\n               is_enclosed (bool): True if the region does not touch the border.\n               region_pixels (set): Set of (r, c) tuples for all pixels in the enclosed region.\n               internal_markers (list): List of color indices for non-black, non-boundary pixels found.\n    \"\"\"\n    H, W = grid.shape\n    q = deque(list(start_pixels))\n    visited_region = set(start_pixels)\n    internal_markers = []\n    is_enclosed = True\n\n    while q:\n        r, c = q.popleft()\n\n        # Check if current pixel touches the border\n        if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n            is_enclosed = False\n            # Continue flood fill to find all connected pixels, but mark as not enclosed.\n\n        pixel_color = grid[r, c]\n        # If it's a non-black, non-boundary pixel, add its color to markers\n        if pixel_color != 0 and pixel_color != boundary_color:\n            internal_markers.append(pixel_color)\n\n        # Explore neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                # Check if neighbor is valid to explore:\n                # 1. Not already visited in *this* flood fill.\n                # 2. Not part of the boundary object.\n                if neighbor_pos not in visited_region and neighbor_pos not in boundary_pixels:\n                    visited_region.add(neighbor_pos)\n                    q.append(neighbor_pos)\n            # else: # Neighbor is out of bounds - this implicitly means the region touches the border\n                 # Handled by the check at the start of the loop for (r,c). If a neighbor is out of bounds,\n                 # the pixel (r,c) from which we are exploring must be on the border.\n                 # is_enclosed = False # Redundant due to check at start of loop iteration\n\n    return is_enclosed, visited_region, internal_markers\n\n\ndef determine_fill_color(marker_colors):\n    \"\"\"\n    Determines the fill color based on frequency and tie-breaking rules.\n\n    Args:\n        marker_colors (list): List of color indices of internal markers.\n\n    Returns:\n        int: The determined fill color index, or -1 if no markers.\n    \"\"\"\n    if not marker_colors:\n        return -1 # Should not happen if called correctly, but safe check\n\n    color_counts = Counter(marker_colors)\n    unique_colors = list(color_counts.keys())\n\n    if len(unique_colors) <= 1:\n        return -1 # Condition for filling not met\n\n    max_count = 0\n    most_common_color = -1\n\n    # Sort unique colors by index to ensure lowest index wins ties\n    sorted_colors = sorted(unique_colors)\n\n    for color in sorted_colors:\n        count = color_counts[color]\n        if count > max_count:\n            max_count = count\n            most_common_color = color\n        # If count == max_count, the lower color index (already processed or current) remains the choice.\n\n    return most_common_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding boundary objects, checking for enclosed regions,\n    analyzing internal markers, and filling based on frequency rules.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    visited_objects = np.zeros_like(input_grid, dtype=bool) # Track pixels belonging to processed objects\n\n    # Iterate through each pixel to find potential starting points for boundary objects\n    for r in range(H):\n        for c in range(W):\n            pixel_color = input_grid[r, c]\n            # If it's a non-black pixel and hasn't been visited as part of an object yet\n            if pixel_color != 0 and not visited_objects[r, c]:\n\n                # Find the connected non-black object and its properties\n                boundary_color, boundary_pixels, touches_border = find_object(input_grid, (r, c), visited_objects)\n\n                # Only proceed if the object itself does not touch the border\n                if not touches_border:\n\n                    # Find white pixels adjacent to this potential boundary\n                    adjacent_white_pixels = find_adjacent_white(input_grid, boundary_pixels)\n\n                    # If there are adjacent white pixels, check if they form an enclosed region\n                    if adjacent_white_pixels:\n                        # Perform flood fill from these white pixels to find the region, markers, and check enclosure\n                        is_enclosed, region_pixels, internal_markers = check_enclosure_and_find_markers(\n                            input_grid, adjacent_white_pixels, boundary_color, boundary_pixels\n                        )\n\n                        # Process only if the region is fully enclosed\n                        if is_enclosed:\n                            # Determine the fill color based on internal markers\n                            # (handles the >1 unique color check and tie-breaking internally)\n                            fill_color = determine_fill_color(internal_markers)\n\n                            # If a valid fill color was determined (meaning >1 unique markers existed)\n                            if fill_color != -1:\n                                # Fill the *originally white* pixels within the identified enclosed region\n                                for pr, pc in region_pixels:\n                                    if input_grid[pr, pc] == 0: # Only change pixels that were originally white\n                                        output_grid[pr, pc] = fill_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14731,
    "candidates_token_count": 2643,
    "total_token_count": 17374,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.323549,
  "retries": null
}