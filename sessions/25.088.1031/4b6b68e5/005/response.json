{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nThe transformation identifies enclosed regions of white pixels (color 0) within the input grid. An enclosed region is one that does not touch the grid border.\nFor each enclosed white region, it identifies \"marker\" pixels. A marker pixel is defined as a non-white pixel that is 8-directionally adjacent to at least one pixel of the white region, but is *not* part of the immediate 4-directional boundary of that region. The 4-directional boundary consists of the non-white pixels directly adjacent (up, down, left, right) to the white region pixels.\nThe transformation counts the occurrences of each unique color among these marker pixels.\nIf the number of *unique marker colors* found for an enclosed region is greater than 1, the transformation proceeds to fill that region.\nThe fill color is determined by finding the most frequent color among the markers. In case of a tie in frequency, the color with the lowest numerical index (e.g., red (2) wins over green (3) if both appear twice and that's the max frequency) is chosen.\nAll the white pixels belonging to that specific enclosed region are then recolored to this chosen fill color in the output grid.\nIf an enclosed white region has 1 or 0 unique marker colors, or if a white region is not fully enclosed, its white pixels remain unchanged. Non-white pixels in the input always remain unchanged in the output.\n\"\"\"\n\ndef find_connected_white_region(grid, start_pos, global_visited):\n    \"\"\"\n    Performs a BFS starting from start_pos to find a connected region of white pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_pos (tuple): The starting (row, col) for the BFS (must be white).\n        global_visited (np.ndarray): A boolean grid tracking visited pixels across all searches.\n\n    Returns:\n        tuple: (region_pixels, boundary_pixels, is_enclosed)\n               region_pixels (set): Set of (row, col) tuples for the white region.\n               boundary_pixels (set): Set of (row, col) tuples for non-white pixels 4-directionally adjacent to the region.\n               is_enclosed (bool): True if the region does not touch the grid border.\n    \"\"\"\n    H, W = grid.shape\n    q = deque([start_pos])\n    region_pixels = set()\n    boundary_pixels = set() # Pixels defining the immediate 4-directional boundary\n    is_enclosed = True\n    local_visited = set([start_pos]) # Track visited within this BFS to avoid cycles\n\n    while q:\n        r, c = q.popleft()\n\n        # Check if pixel is on the border\n        if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n            is_enclosed = False # Touched edge, cannot be filled later\n\n        region_pixels.add((r, c))\n        global_visited[r, c] = True # Mark globally visited\n\n        # Explore neighbors (4-directional for region connectivity and boundary definition)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_color = grid[nr, nc]\n                neighbor_pos = (nr, nc)\n\n                if neighbor_color == 0: # Neighbor is white\n                    if neighbor_pos not in local_visited:\n                        local_visited.add(neighbor_pos)\n                        q.append(neighbor_pos)\n                else: # Neighbor is non-white (part of a 4-dir boundary)\n                    boundary_pixels.add(neighbor_pos) # Collect boundary pixel position\n            # If neighbor is out of bounds, the region touches the edge. The is_enclosed flag handles this.\n\n    return region_pixels, boundary_pixels, is_enclosed\n\n\ndef find_adjacent_markers(grid, region_pixels, boundary_pixels):\n    \"\"\"\n    Finds marker pixels adjacent (8-directionally) to the region's white pixels,\n    excluding the immediate 4-directional boundary pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        region_pixels (set): Set of (row, col) for the enclosed white region.\n        boundary_pixels (set): Set of (row, col) for the 4-directional boundary pixels.\n\n    Returns:\n        list: A list of dictionaries, each {'pos': (r, c), 'color': color} for a unique marker pixel position.\n    \"\"\"\n    H, W = grid.shape\n    found_markers = {} # Use dict {pos: color} to store unique marker positions and their colors\n\n    # Iterate through each white pixel in the region\n    for r, c in region_pixels:\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < H and 0 <= nc < W:\n                    neighbor_pos = (nr, nc)\n                    neighbor_color = grid[nr, nc]\n\n                    # Check if the neighbor is a potential marker:\n                    # 1. It must not be white (color 0).\n                    # 2. It must not be part of the immediate 4-directional boundary.\n                    if neighbor_color != 0 and neighbor_pos not in boundary_pixels:\n                        # Add to found_markers. If position exists, it's overwritten, ensuring uniqueness by position.\n                        found_markers[neighbor_pos] = neighbor_color\n\n    # Convert the dictionary of unique markers into the desired list format\n    marker_list = [{'pos': pos, 'color': color} for pos, color in found_markers.items()]\n    return marker_list\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding enclosed white regions and filling them based on adjacent marker colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool) # Track visited white pixels globally\n\n    # Iterate through each pixel to find starting points for white regions\n    for r in range(H):\n        for c in range(W):\n            # If it's a white pixel and hasn't been visited by any previous region search\n            if input_grid[r, c] == 0 and not visited[r, c]:\n                \n                # Find the connected white region and its properties using BFS\n                region_pixels, boundary_pixels, is_enclosed = find_connected_white_region(input_grid, (r, c), visited)\n\n                # Process only if the region is fully enclosed and non-empty\n                if is_enclosed and region_pixels:\n                    \n                    # Find unique marker pixels adjacent (8-dir) to the region, excluding the 4-dir boundary\n                    markers = find_adjacent_markers(input_grid, region_pixels, boundary_pixels)\n                    \n                    # Collect the colors of the found markers\n                    marker_colors = [m['color'] for m in markers]\n                    \n                    # Only proceed if there are any markers found\n                    if marker_colors:\n                        # Count the frequency of each marker color\n                        color_counts = Counter(marker_colors)\n                        unique_colors = list(color_counts.keys())\n                        \n                        # Check if the number of unique marker colors is greater than 1\n                        if len(unique_colors) > 1:\n                            # Find the most frequent color, with tie-breaking (lowest color index wins)\n                            max_count = 0\n                            most_common_color = -1 \n                            \n                            # Sort unique colors by index to ensure lowest index wins ties\n                            sorted_colors = sorted(unique_colors) \n                            \n                            for color in sorted_colors:\n                                count = color_counts[color]\n                                if count > max_count:\n                                    max_count = count\n                                    most_common_color = color\n                                # If count == max_count, the lower color index (already processed or current) remains the choice.\n                                # Since we iterate sorted colors, the first one encountered with max_count is kept.\n\n                            fill_color = most_common_color\n\n                            # Fill the identified white region in the output grid with the determined fill color\n                            for pr, pc in region_pixels:\n                                output_grid[pr, pc] = fill_color\n                                \n                # If not enclosed, or <= 1 unique marker color, the region remains white (as copied initially)\n                # The 'visited' array ensures we don't re-process white pixels of already found regions.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9276,
    "candidates_token_count": 2058,
    "total_token_count": 11334,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 231.663092,
  "retries": null
}