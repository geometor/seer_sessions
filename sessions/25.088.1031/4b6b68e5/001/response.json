{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nThe transformation identifies enclosed regions of white pixels (color 0) within the input grid. \nFor each enclosed white region, it finds any non-white, non-boundary pixels (\"marker pixels\") located strictly inside that region. \nIt then counts the occurrences of each color among these marker pixels. \nThe most frequent marker color is determined. \nFinally, all the white pixels belonging to that specific enclosed region are recolored to this most frequent marker color in the output grid. \nIf an enclosed white region contains no marker pixels, or if a white region is not fully enclosed, it remains unchanged.\nThe boundary pixels surrounding the regions also remain unchanged.\n\"\"\"\n\ndef find_connected_white_region(grid, start_pos, global_visited):\n    \"\"\"\n    Performs a BFS starting from start_pos to find a connected region of white pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_pos (tuple): The starting (row, col) for the BFS (must be white).\n        global_visited (np.ndarray): A boolean grid tracking visited pixels across all searches.\n\n    Returns:\n        tuple: (region_pixels, boundary_pixels, is_enclosed)\n               region_pixels (set): Set of (row, col) tuples for the white region.\n               boundary_pixels (set): Set of (row, col) tuples for non-white pixels adjacent to the region.\n               is_enclosed (bool): True if the region does not touch the grid border.\n    \"\"\"\n    H, W = grid.shape\n    q = deque([start_pos])\n    region_pixels = set()\n    boundary_pixels = set()\n    is_enclosed = True\n    local_visited = set([start_pos]) # Track visited within this BFS to avoid cycles\n\n    while q:\n        r, c = q.popleft()\n\n        # Check if pixel is on the border\n        if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n            is_enclosed = False # Touched edge\n\n        region_pixels.add((r, c))\n        global_visited[r, c] = True # Mark globally\n\n        # Explore neighbors (4-directional adjacency is sufficient for region finding)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_color = grid[nr, nc]\n                neighbor_pos = (nr, nc)\n\n                if neighbor_color == 0: # Neighbor is white\n                    if neighbor_pos not in local_visited:\n                        local_visited.add(neighbor_pos)\n                        q.append(neighbor_pos)\n                else: # Neighbor is non-white (part of a boundary)\n                    boundary_pixels.add(neighbor_pos) # Collect boundary pixel position\n            # else: neighbor is out of bounds, implicitly means region touches edge if we started near edge\n\n    return region_pixels, boundary_pixels, is_enclosed\n\n\ndef find_markers_inside(grid, region_pixels, boundary_pixels):\n    \"\"\"\n    Finds marker pixels located 'inside' the enclosed region, meaning reachable from\n    the region's white pixels without crossing the identified boundary pixels.\n    This implementation uses BFS starting from within the region and collects\n    non-boundary, non-white pixels encountered.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        region_pixels (set): Set of (row, col) for the enclosed white region.\n        boundary_pixels (set): Set of (row, col) for the boundary pixels surrounding the region.\n\n    Returns:\n        list: A list of dictionaries, each {'pos': (r, c), 'color': color} for a marker.\n              Returns an empty list if no markers are found.\n    \"\"\"\n    if not region_pixels:\n        return []\n\n    H, W = grid.shape\n    start_node = next(iter(region_pixels)) # Get an arbitrary starting point within the white region\n    \n    q = deque([start_node])\n    visited_internal = set(region_pixels) # Mark all white pixels as visited initially for this search\n    found_markers = []\n    \n    processed_markers = set() # Track marker positions we've added to the queue\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (8-directional needed to find diagonally connected markers)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                \n                nr, nc = r + dr, c + dc\n                \n                # Check bounds\n                if 0 <= nr < H and 0 <= nc < W:\n                    neighbor_pos = (nr, nc)\n                    \n                    if neighbor_pos not in visited_internal:\n                        neighbor_color = grid[nr, nc]\n                        \n                        if neighbor_pos in boundary_pixels:\n                            # Hit the known boundary, mark visited but don't explore further from here\n                            visited_internal.add(neighbor_pos)\n                        elif neighbor_color != 0: # It's non-white and not the boundary -> marker!\n                            # Check if we already processed this marker to avoid duplicates if reachable from multiple paths\n                            if neighbor_pos not in processed_markers:\n                                found_markers.append({'pos': neighbor_pos, 'color': neighbor_color})\n                                processed_markers.add(neighbor_pos)\n                                visited_internal.add(neighbor_pos)\n                                q.append(neighbor_pos) # Explore from the marker pixel\n                        else: # It's a white pixel within the region (should have been in region_pixels)\n                           # This case should ideally not happen if region_pixels are correct,\n                           # but if it does, add to visited and queue if not already\n                           if neighbor_pos in region_pixels: # double check it belongs to our region\n                                visited_internal.add(neighbor_pos)\n                                q.append(neighbor_pos)\n                           # If it's a white pixel NOT in region_pixels, it means our initial region finding\n                           # might have missed something or there's another white region touching. Ignore.\n                            \n    return found_markers\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies enclosed white regions in the input grid, finds the most frequent \n    marker color within each, and fills the region with that color.\n\n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate through each pixel to find starting points for white regions\n    for r in range(H):\n        for c in range(W):\n            # If it's a white pixel and hasn't been visited by any previous region search\n            if input_grid[r, c] == 0 and not visited[r, c]:\n                # Find the connected white region and its properties\n                region_pixels, boundary_pixels, is_enclosed = find_connected_white_region(input_grid, (r, c), visited)\n\n                # If the region is fully enclosed\n                if is_enclosed and region_pixels:\n                    # Find marker pixels inside this enclosed region\n                    markers = find_markers_inside(input_grid, region_pixels, boundary_pixels)\n\n                    if markers:\n                        # Count the colors of the markers\n                        marker_colors = [m['color'] for m in markers]\n                        color_counts = Counter(marker_colors)\n                        \n                        # Find the most frequent color\n                        if color_counts:\n                             # Find the color with the maximum count. If ties, behavior is based on Counter's most_common,\n                             # which often returns items in arbitrary order for ties unless specified.\n                             # Let's ensure deterministic tie-breaking: choose the lowest color index in case of a tie.\n                             max_count = 0\n                             most_common_color = -1 # Default if no markers found\n                             # Sort colors to ensure lowest index wins ties\n                             sorted_colors = sorted(color_counts.keys())\n                             for color in sorted_colors:\n                                 count = color_counts[color]\n                                 if count > max_count:\n                                     max_count = count\n                                     most_common_color = color\n                                 # If count == max_count, the lower color index (already processed due to sort) remains the choice.\n\n                             fill_color = most_common_color\n\n                             # Fill the region in the output grid\n                             for pr, pc in region_pixels:\n                                 output_grid[pr, pc] = fill_color\n                # No need for an else clause: if not enclosed or no markers, the region remains white (as copied initially)\n                \n                # Note: The 'visited' array is updated within find_connected_white_region for the white pixels.\n                # Boundary pixels and marker pixels are not marked as 'visited' globally,\n                # allowing them to be part of other boundaries or act as markers for different regions if applicable.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6047,
    "candidates_token_count": 2166,
    "total_token_count": 8213,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 213.299433,
  "retries": null
}