{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1.  Identify a single, continuous horizontal or vertical separator line of azure (8) pixels that spans the grid.\n2.  Initialize the output grid as a copy of the input grid.\n3.  Identify source pixels: yellow (4) and red (2) pixels in the input grid.\n4.  For each yellow source pixel found in the input, change its color to green (3) in the output grid at the corresponding location. Red source pixels remain red in the output grid.\n5.  For each location corresponding to an original yellow or red source pixel:\n    a.  Determine the direct orthogonal path from the pixel adjacent to the source pixel's location towards the separator line.\n    b.  The path stops just before reaching the separator line (it does not include or overwrite the separator).\n    c.  Iterate through the cells along this calculated path.\n    d.  For each cell on the path, if its current color in the output grid is white (0), change its color to azure (8). Otherwise, leave the cell's color unchanged.\n\"\"\"\n\ndef find_separator(grid: np.ndarray) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"\n    Identifies the azure separator line/column.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple (orientation, index) where orientation is 'h' (horizontal)\n        or 'v' (vertical), and index is the row or column index of the\n        separator. Returns (None, None) if no single full separator is found.\n    \"\"\"\n    rows, cols = grid.shape\n    # Check for horizontal separator\n    for r in range(rows):\n        if np.all(grid[r, :] == 8):\n            # Check if it's the only one\n            is_unique = True\n            for r2 in range(rows):\n                if r != r2 and np.all(grid[r2, :] == 8):\n                    is_unique = False\n                    break\n            if is_unique:\n                 # Check if columns might also be separators\n                 for c in range(cols):\n                     if np.all(grid[:, c] == 8):\n                         # Found both H and V separators, ambiguous or complex case not handled\n                         return None, None\n                 return 'h', r\n\n    # Check for vertical separator\n    for c in range(cols):\n        if np.all(grid[:, c] == 8):\n             # Check if it's the only one\n            is_unique = True\n            for c2 in range(cols):\n                if c != c2 and np.all(grid[:, c2] == 8):\n                    is_unique = False\n                    break\n            if is_unique:\n                 # Already checked for H separators, so this must be the one if unique\n                 return 'v', c\n\n    return None, None\n\n\ndef draw_projection_path(output_grid: np.ndarray, r_start: int, c_start: int, sep_orientation: str, sep_index: int):\n    \"\"\"\n    Draws the azure projection path from a source pixel towards the separator,\n    only overwriting white (0) pixels in the output_grid. Modifies output_grid in place.\n\n    Args:\n        output_grid: The numpy array representing the output grid (modified in place).\n        r_start: The row index of the source pixel's original location.\n        c_start: The column index of the source pixel's original location.\n        sep_orientation: 'h' or 'v' for the separator orientation.\n        sep_index: The row or column index of the separator.\n    \"\"\"\n    if sep_orientation == 'h':\n        # Project vertically towards the horizontal separator at row sep_index\n        if r_start < sep_index: # Project down from above\n            for r in range(r_start + 1, sep_index):\n                # Check if the path pixel is currently white (0) before drawing\n                if output_grid[r, c_start] == 0:\n                    output_grid[r, c_start] = 8\n        elif r_start > sep_index: # Project up from below\n            # Iterate from r_start-1 down to sep_index+1\n            for r in range(r_start - 1, sep_index, -1):\n                 # Check if the path pixel is currently white (0) before drawing\n                 if output_grid[r, c_start] == 0:\n                    output_grid[r, c_start] = 8\n    elif sep_orientation == 'v':\n        # Project horizontally towards the vertical separator at column sep_index\n        if c_start < sep_index: # Project right from left\n            for c in range(c_start + 1, sep_index):\n                 # Check if the path pixel is currently white (0) before drawing\n                 if output_grid[r_start, c] == 0:\n                    output_grid[r_start, c] = 8\n        elif c_start > sep_index: # Project left from right\n            # Iterate from c_start-1 down to sep_index+1\n            for c in range(c_start - 1, sep_index, -1):\n                 # Check if the path pixel is currently white (0) before drawing\n                 if output_grid[r_start, c] == 0:\n                    output_grid[r_start, c] = 8\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify Separator\n    separator_orientation, separator_index = find_separator(input_np)\n\n    # If no valid separator is found, return the original grid (or handle as error)\n    # Based on task structure, a separator is expected.\n    if separator_orientation is None:\n        # This case might indicate an unexpected input format or multiple separators.\n        # Returning the input might be a safe default for ARC, but could be wrong.\n        # Let's assume a separator always exists per the pattern.\n        # If this fails tests, we might need to reconsider this assumption.\n         return input_grid # Or raise an error, or return empty?\n\n    # 2. Initialize Output grid as a copy\n    output_np = input_np.copy()\n\n    # 3. Identify Source Pixels and perform initial Color Changes\n    source_pixel_locations = []\n    for r in range(rows):\n        for c in range(cols):\n            # Skip pixels on the separator line itself\n            if separator_orientation == 'h' and r == separator_index:\n                continue\n            if separator_orientation == 'v' and c == separator_index:\n                continue\n\n            pixel_value = input_np[r, c]\n            if pixel_value == 4: # Yellow pixel\n                # Change yellow to green in the output grid\n                output_np[r, c] = 3\n                # Record its location as a source for projection\n                source_pixel_locations.append((r, c))\n            elif pixel_value == 2: # Red pixel\n                # Red remains red (already copied), just record its location\n                source_pixel_locations.append((r, c))\n\n    # 4. Draw Projection Paths for each identified source pixel\n    for r_source, c_source in source_pixel_locations:\n        draw_projection_path(output_np, r_source, c_source, separator_orientation, separator_index)\n\n    # Convert the final NumPy array back to a list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4338,
    "candidates_token_count": 1822,
    "total_token_count": 6160,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.026187,
  "retries": null
}