{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Initialize the output grid as an identical copy of the input grid.\n2. Find a single, continuous line (horizontal or vertical) of azure (8) pixels that fully spans the grid's width or height. Record its orientation and index. Assume such a unique separator exists.\n3. Identify the locations of all yellow (4) and red (2) source pixels in the *input* grid that are not on the separator line.\n4. For each identified *yellow* source pixel location `(r, c)`, change the color in the *output* grid at `(r, c)` to green (3). Red source pixels remain red in the output grid initially (due to the copy).\n5. For *each* identified source pixel location `(r_source, c_source)` (both original yellow and red):\n    a. Determine the direct orthogonal path from the cell adjacent to `(r_source, c_source)` towards the separator line.\n    b. The path extends up to, but does not include, the separator line itself.\n    c. Iterate through each cell `(r_path, c_path)` along this path.\n    d. Change the color of the cell `(r_path, c_path)` in the *output* grid to azure (8), overwriting any existing color at that location.\n\"\"\"\n\ndef find_separator(grid: np.ndarray) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"\n    Identifies the unique azure separator line/column.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple (orientation, index) where orientation is 'h' (horizontal)\n        or 'v' (vertical), and index is the row or column index of the\n        separator. Returns (None, None) if no single full separator is found,\n        or if both horizontal and vertical separators exist.\n    \"\"\"\n    rows, cols = grid.shape\n    h_sep_index = None\n    v_sep_index = None\n    azure_color = 8\n\n    # Check for horizontal separator\n    for r in range(rows):\n        if np.all(grid[r, :] == azure_color):\n            if h_sep_index is None: # Found the first one\n                 h_sep_index = r\n            else: # Found more than one horizontal separator\n                 return None, None # Ambiguous case\n\n    # Check for vertical separator\n    for c in range(cols):\n        if np.all(grid[:, c] == azure_color):\n             if v_sep_index is None: # Found the first one\n                 v_sep_index = c\n             else: # Found more than one vertical separator\n                 return None, None # Ambiguous case\n\n    # Determine result based on findings\n    if h_sep_index is not None and v_sep_index is None:\n        return 'h', h_sep_index\n    elif v_sep_index is not None and h_sep_index is None:\n        return 'v', v_sep_index\n    else:\n        # Either none found, or both types found, or multiple of one type\n        return None, None\n\n\ndef draw_projection_path(output_grid: np.ndarray, r_start: int, c_start: int, sep_orientation: str, sep_index: int):\n    \"\"\"\n    Draws the azure projection path from a source pixel's original location\n    towards the separator, overwriting existing pixels in the output_grid.\n    Modifies output_grid in place.\n\n    Args:\n        output_grid: The numpy array representing the output grid (modified in place).\n        r_start: The row index of the source pixel's original location.\n        c_start: The column index of the source pixel's original location.\n        sep_orientation: 'h' or 'v' for the separator orientation.\n        sep_index: The row or column index of the separator.\n    \"\"\"\n    azure_color = 8\n\n    if sep_orientation == 'h':\n        # Project vertically towards the horizontal separator at row sep_index\n        if r_start < sep_index: # Project down from above\n            # Path starts one step below the source, ends just before the separator\n            for r in range(r_start + 1, sep_index):\n                # Check bounds just in case, though path should be within grid\n                if 0 <= r < output_grid.shape[0]:\n                    output_grid[r, c_start] = azure_color # Overwrite with azure\n        elif r_start > sep_index: # Project up from below\n            # Path starts one step above the source, ends just after the separator\n            # Iterate from r_start-1 down to sep_index+1\n            for r in range(r_start - 1, sep_index, -1):\n                 # Check bounds\n                 if 0 <= r < output_grid.shape[0]:\n                     output_grid[r, c_start] = azure_color # Overwrite with azure\n    elif sep_orientation == 'v':\n        # Project horizontally towards the vertical separator at column sep_index\n        if c_start < sep_index: # Project right from left\n            # Path starts one step right of the source, ends just before the separator\n            for c in range(c_start + 1, sep_index):\n                 # Check bounds\n                 if 0 <= c < output_grid.shape[1]:\n                     output_grid[r_start, c] = azure_color # Overwrite with azure\n        elif c_start > sep_index: # Project left from right\n            # Path starts one step left of the source, ends just after the separator\n            # Iterate from c_start-1 down to sep_index+1\n            for c in range(c_start - 1, sep_index, -1):\n                 # Check bounds\n                 if 0 <= c < output_grid.shape[1]:\n                     output_grid[r_start, c] = azure_color # Overwrite with azure\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid: finds an azure separator,\n    identifies red/yellow sources, changes yellow sources to green, and projects\n    azure paths from all sources towards the separator.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Initialize Output grid as a copy\n    output_np = input_np.copy()\n\n    # 2. Find Separator\n    separator_orientation, separator_index = find_separator(input_np)\n\n    # Handle cases where no unique separator is found\n    # Based on the previous timeout, maybe the assumption of a separator isn't always true,\n    # or the implementation needs refinement. For now, returning the copy if no separator.\n    if separator_orientation is None:\n        return output_np.tolist()\n\n    # Define source colors and target color for yellow sources\n    yellow_color = 4\n    red_color = 2\n    green_color = 3\n    source_colors = {yellow_color, red_color}\n\n    # 3. Identify Source Pixels (locations only for now)\n    source_pixel_locations = []\n    for r in range(rows):\n        for c in range(cols):\n            # Determine if the current pixel is on the separator line\n            is_on_separator = False\n            if separator_orientation == 'h' and r == separator_index:\n                is_on_separator = True\n            elif separator_orientation == 'v' and c == separator_index:\n                is_on_separator = True\n\n            # If not on the separator and is a source color, record its location\n            if not is_on_separator:\n                pixel_value = input_np[r, c]\n                if pixel_value in source_colors:\n                    source_pixel_locations.append((r, c))\n\n    # 4. Perform Initial Color Transformation for Yellow Sources\n    # Iterate through the identified source locations\n    for r_source, c_source in source_pixel_locations:\n        # Check the color in the *original* input grid\n        if input_np[r_source, c_source] == yellow_color:\n            # Change the color in the *output* grid\n            output_np[r_source, c_source] = green_color\n\n    # 5. Draw Projection Paths for ALL identified source locations\n    # This happens *after* initial color changes. Paths are drawn onto the output grid.\n    for r_source, c_source in source_pixel_locations:\n        draw_projection_path(output_np, r_source, c_source, separator_orientation, separator_index)\n\n    # Convert the final NumPy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4647,
    "candidates_token_count": 2065,
    "total_token_count": 6712,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.926245,
  "retries": null
}