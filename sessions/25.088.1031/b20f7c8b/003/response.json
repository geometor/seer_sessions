{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport copy\n\n\"\"\"\nIdentifies two types of primary objects:\n1.  'Targets': Objects with a Red (2) frame perfectly enclosing a connected Blue (1) interior.\n2.  'Sources': Solid, single-color objects (including potentially solid Blue objects), excluding Red frames that aren't targets, and excluding Green frames if an anomaly condition is met.\n\nTransformation Rules:\n1.  Find all Targets and potential Sources.\n2.  Handle Anomaly Case (if present): If a Green (3) framed Blue (1) object exists *and* a solid Green (3) object exists:\n    a.  Change the pixels of the solid Green object to Blue (1).\n    b.  Exclude both the Green frame and the original solid Green object from the list of Sources.\n3.  Create the final list of Sources by excluding non-source objects (Red frames that didn't qualify as Targets, the Green frame in the anomaly case).\n4.  Sort Targets by their top-left bounding box coordinate (row, then column).\n5.  Sort the final Sources by their top-left bounding box coordinate (row, then column).\n6.  Pair the sorted Targets and Sources index-wise.\n7.  For each matched pair, replace the Blue (1) interior pixels of the Target object with the color of its paired Source object.\n8.  All other pixels (background, frames, unused sources, etc.) remain unchanged.\n\"\"\"\n\ndef find_objects(grid, ignore_colors=None):\n    \"\"\"\n    Finds all connected objects of non-ignored colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_colors (set): Set of colors to ignore (e.g., background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'pixels' (set of (r, c) tuples), and 'bbox'.\n    \"\"\"\n    if ignore_colors is None:\n        ignore_colors = {0, 8} # Default background colors\n\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if not visited[r, c] and color not in ignore_colors:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c, max_r, max_c = r, c, r, c\n                current_color = color # Color of the object being traced\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds, color match, and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == current_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                objects.append({\n                    'color': current_color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_interior_pixels(grid, frame_pixels, frame_color, interior_color):\n    \"\"\"\n    Identifies the connected interior pixels of a potential frame.\n\n    Args:\n        grid (np.array): The grid.\n        frame_pixels (set): Set of (r, c) tuples for the frame.\n        frame_color (int): The color of the frame.\n        interior_color (int): The potential color of the interior.\n\n    Returns:\n        set: Set of (r,c) tuples for the interior pixels if it's a single,\n             connected component fully enclosed by the frame, otherwise None.\n    \"\"\"\n    height, width = grid.shape\n    potential_interior_starts = set()\n\n    # 1. Find potential starting points for the interior (adjacent to the frame)\n    for r_frame, c_frame in frame_pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r_frame + dr, c_frame + dc\n                # Check bounds, is interior color, and not part of the frame itself\n                if 0 <= nr < height and 0 <= nc < width and \\\n                   grid[nr, nc] == interior_color and \\\n                   (nr, nc) not in frame_pixels:\n                    potential_interior_starts.add((nr, nc))\n\n    if not potential_interior_starts:\n        return None # No pixels of interior_color adjacent to the frame\n\n    # 2. Perform BFS from one start point to find a single connected component\n    start_node = next(iter(potential_interior_starts)) # Pick one starting point\n    q = deque([start_node])\n    visited_interior = {start_node}\n    found_interior_pixels = {start_node}\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors for more interior pixels or boundaries\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if not (0 <= nr < height and 0 <= nc < width):\n                    # Interior pixel touches the edge of the grid - not enclosed\n                    return None\n\n                neighbor_pixel = (nr, nc)\n                neighbor_color = grid[nr, nc]\n\n                # If it's an interior pixel and not visited, add it\n                if neighbor_color == interior_color and neighbor_pixel not in visited_interior:\n                    visited_interior.add(neighbor_pixel)\n                    q.append(neighbor_pixel)\n                    found_interior_pixels.add(neighbor_pixel)\n                # If it's NOT interior and NOT frame, then it's not enclosed\n                elif neighbor_color != interior_color and neighbor_pixel not in frame_pixels:\n                    return None # Touches something other than frame or self\n\n    # 3. Verify that *all* potential starting points were part of this single component\n    #    This ensures there isn't a separate blob of interior_color also adjacent to the frame.\n    if not potential_interior_starts.issubset(found_interior_pixels):\n         # This can happen if the 'frame' doesn't fully enclose all adjacent interior pixels\n         return None\n\n    # 4. Final check: Ensure all found interior pixels only touch frame or other interior pixels\n    #    (This is partially covered by check 2, but double-check boundaries)\n    for r_int, c_int in found_interior_pixels:\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 if dr == 0 and dc == 0:\n                     continue\n                 nr, nc = r_int + dr, c_int + dc\n                 neighbor_pixel = (nr, nc)\n                 # If a neighbor is outside the grid (should have been caught earlier)\n                 if not (0 <= nr < height and 0 <= nc < width):\n                      return None # Should not happen if check 2 worked\n                 # If neighbor is not part of the frame and not part of the found interior\n                 if neighbor_pixel not in frame_pixels and neighbor_pixel not in found_interior_pixels:\n                      return None # Touches something unexpected\n\n    return found_interior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying framed objects (targets)\n    and solid objects (sources), handling a green/green anomaly.\n    Replaces the interior color of targets with the color of paired sources.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    all_objects = find_objects(output_grid, ignore_colors={0, 8}) # Find non-background objects\n\n    targets = []\n    potential_sources = []\n    green_frame_blue_interior_obj = None\n    solid_green_objects = []\n    anomaly_green_to_change = None # Store the specific solid green object if anomaly occurs\n\n    # --- Categorize all found objects ---\n    for obj in all_objects:\n        color = obj['color']\n        pixels = obj['pixels']\n        bbox = obj['bbox']\n\n        is_target = False\n        is_green_frame = False\n        is_solid_green = False\n\n        # Check if it's a Red frame around Blue\n        if color == 2: # Red\n            interior = get_interior_pixels(output_grid, pixels, frame_color=2, interior_color=1)\n            if interior:\n                targets.append({'frame_pixels': pixels, 'interior_pixels': interior, 'bbox': bbox})\n                is_target = True\n        # Check if it's a Green frame around Blue OR a solid Green object\n        elif color == 3: # Green\n            interior = get_interior_pixels(output_grid, pixels, frame_color=3, interior_color=1)\n            if interior:\n                # Found the Green frame potentially involved in the anomaly\n                green_frame_blue_interior_obj = {'frame_pixels': pixels, 'interior_pixels': interior, 'bbox': bbox, 'obj_ref': obj}\n                is_green_frame = True\n            else:\n                # It's a solid Green object\n                solid_green_objects.append(obj)\n                is_solid_green = True\n\n        # Add to potential sources if it's not a target and not a green frame\n        # Solid green objects are added here initially, but might be removed later if anomaly occurs\n        if not is_target and not is_green_frame:\n            potential_sources.append(obj)\n\n    # --- Handle Anomaly (Green frame + Solid Green) ---\n    anomaly_handled = False\n    if green_frame_blue_interior_obj and solid_green_objects:\n        # Anomaly condition met. Choose the first solid green object found.\n        anomaly_green_to_change = solid_green_objects[0]\n\n        # Change its color in the output grid\n        for r, c in anomaly_green_to_change['pixels']:\n            output_grid[r, c] = 1 # Change to Blue\n\n        # Mark anomaly as handled\n        anomaly_handled = True\n        # print(f\"Anomaly handled: Changed solid green object {anomaly_green_to_change['bbox']} to blue.\")\n\n\n    # --- Filter Sources ---\n    final_sources = []\n    for src in potential_sources:\n        # Exclude the green frame object if it exists\n        if green_frame_blue_interior_obj and src['pixels'] == green_frame_blue_interior_obj['obj_ref']['pixels']:\n            # print(f\"Excluding green frame {src['bbox']} from sources.\")\n            continue\n        # Exclude the solid green object that was changed in the anomaly\n        if anomaly_handled and src['pixels'] == anomaly_green_to_change['pixels']:\n            # print(f\"Excluding anomaly-changed green object {src['bbox']} from sources.\")\n            continue\n        # Exclude Red objects that were not identified as Targets (i.e., solid Red or invalid frames)\n        # Note: get_interior_pixels already determined valid targets, so any remaining Red object is not a target.\n        # However, the prompt implies red objects are *only* frames, never sources. Let's exclude them.\n        if src['color'] == 2:\n             # print(f\"Excluding non-target red object {src['bbox']} from sources.\")\n             continue\n\n        final_sources.append(src)\n\n\n    # --- Pair Targets and Final Sources ---\n    targets.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n    final_sources.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n\n    # --- Perform Transformation ---\n    num_targets = len(targets)\n    num_sources = len(final_sources)\n\n    if num_targets == num_sources:\n        # print(f\"Matching {num_targets} targets to {num_sources} sources.\")\n        for i in range(num_targets):\n            target = targets[i]\n            source = final_sources[i]\n            new_color = source['color']\n            # print(f\"  Target {i} (bbox {target['bbox']}) <- Source {i} (color {new_color}, bbox {source['bbox']})\")\n\n            for r, c in target['interior_pixels']:\n                # Check if pixel still exists and is blue (in case of overlaps?)\n                if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1] and output_grid[r,c] == 1:\n                     output_grid[r, c] = new_color\n    # else:\n        # print(f\"Warning: Mismatch between number of targets ({num_targets}) and final sources ({num_sources}). No transformation applied.\")\n        # print(\"Targets:\", [t['bbox'] for t in targets])\n        # print(\"Sources:\", [(s['color'], s['bbox']) for s in final_sources])\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11851,
    "candidates_token_count": 3245,
    "total_token_count": 15096,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.051194,
  "retries": null
}