{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport copy\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Object Identification:**\n    *   Identify all distinct connected objects in the input grid using 4-way adjacency. Ignore background colors White (0) and Azure (8). Each object has a color, a set of pixel coordinates, and a bounding box.\n\n2.  **Object Categorization:** Classify each identified object:\n    *   **Potential Targets:** Red (2) objects.\n    *   **Potential Anomaly Frames:** Green (3) objects.\n    *   **Potential Sources:** All other objects (initially includes solid Green, Blue, Yellow, etc., but excludes Red).\n\n3.  **Interior Analysis (for Red and Green frames):**\n    *   For each Red(2) and Green(3) object (potential frame), determine the pixels it encloses using a flood-fill algorithm starting from the grid borders.\n    *   Mark the frame pixels themselves as 'visited'.\n    *   Flood-fill (4-way adjacency) from all border pixels that are not part of the frame, marking reachable pixels as 'visited'.\n    *   Any pixel *not* visited by the flood fill is considered enclosed by *some* frame.\n    *   Filter these enclosed pixels to find those spatially inside the bounding box of the specific Red/Green frame being analyzed.\n    *   Verify the contents of this enclosed area:\n        *   If all non-background (non-0, non-8) pixels within this enclosed area are Blue (1), then the frame is valid for its type.\n        *   Store the set of enclosed Blue (1) pixels as the 'interior'.\n\n4.  **Target Finalization:**\n    *   A Red (2) object is confirmed as a 'Target' if the interior analysis (Step 3) finds it encloses only Blue (1) pixels (besides background). Store the Target along with its frame pixels and interior blue pixels.\n\n5.  **Anomaly Detection and Handling:**\n    *   Identify if there is exactly one Green (3) object confirmed as an 'Anomaly Frame' (encloses only Blue(1) pixels, per Step 3).\n    *   Identify if there are one or more 'Solid Green' objects (Green objects *not* identified as Anomaly Frames).\n    *   If both an Anomaly Frame and at least one Solid Green object exist:\n        *   Select the Solid Green object with the topmost, then leftmost bounding box coordinate.\n        *   In the *output grid*, change the color of all pixels belonging to this selected Solid Green object to Blue (1).\n        *   Mark this specific Solid Green object as 'anomaly-modified'.\n        *   Mark the Anomaly Frame (Green frame) as 'consumed-by-anomaly'.\n        *   Set an 'anomaly_handled' flag.\n\n6.  **Source Finalization:**\n    *   Start with the list of 'Potential Sources'.\n    *   Filter out (remove) the following:\n        *   Any Red (2) objects (cannot be sources).\n        *   Any Blue (1) objects (cannot be sources).\n        *   If `anomaly_handled` is true:\n            *   Remove the Green frame object ('consumed-by-anomaly').\n            *   Remove the Solid Green object ('anomaly-modified').\n\n7.  **Sorting:**\n    *   Sort the finalized 'Targets' based on their bounding box's top-left coordinate (row, then column).\n    *   Sort the finalized 'Sources' based on their bounding box's top-left coordinate (row, then column).\n\n8.  **Transformation (Filling):**\n    *   Check if the number of Targets equals the number of Sources, and is greater than zero.\n    *   If the counts match:\n        *   Pair the i-th Target with the i-th Source from the sorted lists.\n        *   For each pair, replace the color of the 'interior' Blue (1) pixels of the Target with the *original* color of the paired Source object. Perform this change in the *output grid*.\n\n9.  **Output:**\n    *   Return the modified output grid. If the anomaly occurred, it includes the Green-to-Blue change. If the target/source counts matched, it includes the interior filling. Otherwise, it might return the initial grid (if no targets/sources) or the anomaly-modified grid (if anomaly occurred but counts didn't match).\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\nimport copy\n\ndef find_objects(grid, ignore_colors=None):\n    \"\"\"\n    Finds all connected objects of non-ignored colors using BFS with 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_colors (set): Set of colors to ignore (e.g., background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'pixels' (set of (r, c) tuples), and 'bbox'.\n    \"\"\"\n    if ignore_colors is None:\n        ignore_colors = {0, 8} # Default background colors\n\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the pixel is already visited or if it's an ignored color\n            if visited[r, c] or color in ignore_colors:\n                continue\n\n            # Start BFS for a new object\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c, max_r, max_c = r, c, r, c\n            current_color = color # Color of the object being traced\n\n            while q:\n                row, col = q.popleft()\n                obj_pixels.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check 4 neighbors (orthogonal)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    # Check bounds, color match, and not visited\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       grid[nr, nc] == current_color and not visited[nr, nc]:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            objects.append({\n                'color': current_color,\n                'pixels': obj_pixels,\n                'bbox': (min_r, min_c, max_r, max_c)\n            })\n    return objects\n\n\ndef get_enclosed_pixels(grid, frame_pixels):\n    \"\"\"\n    Identifies all pixels enclosed by a given set of frame pixels using flood fill from outside.\n    Does NOT check the color of the enclosed pixels at this stage.\n\n    Args:\n        grid (np.array): The grid.\n        frame_pixels (set): Set of (r, c) tuples for the potential frame.\n\n    Returns:\n        set: Set of (r,c) tuples for all pixels enclosed by the frame.\n             Returns an empty set if the frame is incomplete or touches the border implicitly.\n    \"\"\"\n    height, width = grid.shape\n    visited_outside = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Mark frame pixels as visited to act as barriers\n    for r, c in frame_pixels:\n        if 0 <= r < height and 0 <= c < width:\n            visited_outside[r, c] = True\n        else: # Should not happen if frame_pixels come from find_objects\n             return set() # Invalid frame pixel\n\n    # Start flood fill from all border cells that are not part of the frame\n    for r in range(height):\n        if not visited_outside[r, 0]:\n            q.append((r, 0))\n            visited_outside[r, 0] = True\n        if not visited_outside[r, width - 1]:\n            q.append((r, width - 1))\n            visited_outside[r, width - 1] = True\n    for c in range(1, width - 1): # Avoid double-adding corners\n        if not visited_outside[0, c]:\n            q.append((0, c))\n            visited_outside[0, c] = True\n        if not visited_outside[height - 1, c]:\n            q.append((height - 1, c))\n            visited_outside[height - 1, c] = True\n\n    # Perform BFS (flood fill) from the outside/borders\n    while q:\n        r, c = q.popleft()\n        # Use 4-way adjacency for flood fill\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width and not visited_outside[nr, nc]:\n                visited_outside[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify interior pixels: any non-frame pixel that was NOT visited by the flood fill\n    interior_pixels = set()\n    for r in range(height):\n        for c in range(width):\n            # Not visited by outside flood AND not part of the original frame\n            if not visited_outside[r, c] and (r, c) not in frame_pixels:\n                 interior_pixels.add((r,c))\n\n    return interior_pixels\n\ndef check_interior_and_get_blue(grid, enclosed_pixels):\n    \"\"\"\n    Checks if all non-background pixels in a set are Blue (1).\n    Returns the set of Blue pixels if condition met, otherwise None.\n    \"\"\"\n    blue_interior_pixels = set()\n    only_blue_or_background = True\n    found_any_blue = False\n\n    for r_int, c_int in enclosed_pixels:\n        pixel_color = grid[r_int, c_int]\n        if pixel_color == 1:\n            blue_interior_pixels.add((r_int, c_int))\n            found_any_blue = True\n        elif pixel_color not in {0, 8}: # Background colors\n            only_blue_or_background = False\n            break # Found a non-blue, non-background color\n\n    if found_any_blue and only_blue_or_background:\n        return blue_interior_pixels\n    else:\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying framed targets (Red frame/Blue interior)\n    and solid sources, handling a Green/Green anomaly. Replaces the interior\n    color of targets with the color of paired sources.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all potential objects using 4-way connectivity\n    all_objects = find_objects(output_grid, ignore_colors={0, 8})\n\n    targets = []\n    potential_sources = []\n    green_frame_objects = [] # Store green objects identified as frames\n    solid_green_objects = [] # Store green objects NOT identified as frames\n    \n    # Keep track of original object references for filtering later\n    anomaly_frame_ref = None\n    anomaly_solid_green_ref = None\n\n    # --- 2 & 3. Categorize objects and Analyze Interiors ---\n    for obj in all_objects:\n        color = obj['color']\n        pixels = obj['pixels']\n        bbox = obj['bbox']\n\n        is_frame_candidate = (color == 2 or color == 3) # Red or Green\n        is_confirmed_frame = False\n        blue_interior = None\n\n        if is_frame_candidate:\n            # Find all pixels potentially enclosed by this frame\n            enclosed_pixels = get_enclosed_pixels(input_grid, pixels)\n\n            if enclosed_pixels:\n                # Check if the enclosed area contains only Blue (1) or background (0, 8)\n                blue_interior = check_interior_and_get_blue(input_grid, enclosed_pixels)\n\n                if blue_interior:\n                    is_confirmed_frame = True\n                    # --- 4. Target Finalization ---\n                    if color == 2: # Red Frame\n                        targets.append({\n                            'frame_pixels': pixels,\n                            'interior_pixels': blue_interior,\n                            'bbox': bbox,\n                            'obj_ref': obj # Keep ref if needed later\n                        })\n                    # --- Green Anomaly Frame Identification ---\n                    elif color == 3: # Green Frame\n                         green_frame_objects.append({\n                             'frame_pixels': pixels,\n                             'interior_pixels': blue_interior,\n                             'bbox': bbox,\n                             'obj_ref': obj\n                         })\n\n        # --- Categorize non-frames or failed frames ---\n        if not is_confirmed_frame:\n            if color == 3: # Green object, but not a valid frame\n                solid_green_objects.append(obj)\n                potential_sources.append(obj) # Add solid green to potential sources initially\n            elif color != 2: # Any other color except Red (which can only be frames)\n                potential_sources.append(obj) # Add to potential sources\n\n    # --- 5. Anomaly Detection and Handling ---\n    anomaly_handled = False\n    # Check conditions: exactly one green frame and at least one solid green\n    if len(green_frame_objects) == 1 and len(solid_green_objects) > 0:\n        anomaly_handled = True\n        anomaly_frame_ref = green_frame_objects[0]['obj_ref'] # The green frame object\n\n        # Select the solid green object with the topmost, then leftmost bbox\n        solid_green_objects.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n        anomaly_solid_green_ref = solid_green_objects[0] # The solid green object to change\n\n        # Change its color to Blue (1) in the output grid\n        for r, c in anomaly_solid_green_ref['pixels']:\n            if 0"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12272,
    "candidates_token_count": 3324,
    "total_token_count": 15596,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 252.52794,
  "retries": null
}