{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport copy\n\n\"\"\"\nIdentifies two types of primary objects:\n1.  'Targets': Objects with a Red (2) frame perfectly enclosing a connected Blue (1) interior. Connectivity is based on 4-way adjacency (up, down, left, right). The enclosure check uses 8-way adjacency.\n2.  'Sources': Solid, single-color objects (connected components based on 4-way adjacency), excluding Red objects and potentially excluding Green objects based on an anomaly condition. Background colors (White 0, Azure 8) are ignored.\n\nTransformation Rules:\n1.  Find all connected components (objects) in the grid using 4-way adjacency, ignoring background colors.\n2.  Categorize objects:\n    a.  Identify 'Targets' by checking Red (2) objects. For each Red object, verify if it perfectly encloses a single connected component of Blue (1) pixels using the `get_interior_pixels` helper function. Store valid targets.\n    b.  Identify potential 'Sources'. Initially, consider all non-Red objects as potential sources. Keep track of any Green (3) object that frames a Blue (1) interior (`green_frame_blue_interior_obj`) and any solid Green (3) objects (`solid_green_objects`).\n3.  Handle Anomaly Case (if present): If both `green_frame_blue_interior_obj` and at least one `solid_green_objects` exist:\n    a.  Select the first found solid Green object (`anomaly_green_to_change`).\n    b.  Change the pixels of this selected solid Green object to Blue (1) in the output grid.\n    c.  Mark the anomaly as handled.\n4.  Create the final list of Sources: Start with all potential sources found in step 2b. Then filter out:\n    a.  Any Red (2) objects (these can only be frames, not sources).\n    b.  If the anomaly was handled:\n        i.  Exclude the Green object that acted as the frame (`green_frame_blue_interior_obj`).\n        ii. Exclude the solid Green object that was modified (`anomaly_green_to_change`).\n5.  Sort Targets by their top-left bounding box coordinate (row, then column).\n6.  Sort the final Sources by their top-left bounding box coordinate (row, then column).\n7.  Pair the sorted Targets and Sources index-wise. If the number of targets and sources does not match, no transformation is performed.\n8.  For each matched pair, replace the Blue (1) interior pixels of the Target object with the color of its paired Source object in the output grid.\n9.  All other pixels (background, frames, unused sources, etc.) remain unchanged from the (potentially anomaly-modified) grid.\n\"\"\"\n\ndef find_objects(grid, ignore_colors=None):\n    \"\"\"\n    Finds all connected objects of non-ignored colors using BFS with 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_colors (set): Set of colors to ignore (e.g., background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'pixels' (set of (r, c) tuples), and 'bbox'.\n    \"\"\"\n    if ignore_colors is None:\n        ignore_colors = {0, 8} # Default background colors\n\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if not visited[r, c] and color not in ignore_colors:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c, max_r, max_c = r, c, r, c\n                current_color = color # Color of the object being traced\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (orthogonal)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == current_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'color': current_color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_interior_pixels(grid, frame_pixels, frame_color, interior_color):\n    \"\"\"\n    Identifies the connected interior pixels of a potential frame.\n    Uses 8-way adjacency for checking neighborhood relationships for enclosure.\n\n    Args:\n        grid (np.array): The grid.\n        frame_pixels (set): Set of (r, c) tuples for the frame.\n        frame_color (int): The color of the frame (unused in logic, but good for context).\n        interior_color (int): The potential color of the interior.\n\n    Returns:\n        set: Set of (r,c) tuples for the interior pixels if it's a single,\n             connected component fully enclosed by the frame, otherwise None.\n    \"\"\"\n    height, width = grid.shape\n    potential_interior_starts = set()\n\n    # 1. Find potential starting points for the interior (adjacent to the frame, including diagonals)\n    for r_frame, c_frame in frame_pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r_frame + dr, c_frame + dc\n                # Check bounds, is interior color, and not part of the frame itself\n                if 0 <= nr < height and 0 <= nc < width and \\\n                   grid[nr, nc] == interior_color and \\\n                   (nr, nc) not in frame_pixels:\n                    potential_interior_starts.add((nr, nc))\n\n    if not potential_interior_starts:\n        return None # No pixels of interior_color adjacent to the frame\n\n    # 2. Perform BFS from one start point to find a single connected component (using 8-way for interior connectivity)\n    start_node = next(iter(potential_interior_starts)) # Pick one starting point\n    q = deque([start_node])\n    visited_interior = {start_node}\n    found_interior_pixels = {start_node}\n    is_enclosed = True # Assume enclosed until proven otherwise\n\n    while q:\n        r, c = q.popleft()\n\n        # Check 8 neighbors (including diagonals) for boundaries or more interior pixels\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                neighbor_pixel = (nr, nc)\n\n                # Check if neighbor is outside the grid bounds\n                if not (0 <= nr < height and 0 <= nc < width):\n                    is_enclosed = False\n                    # print(f\"Interior pixel ({r},{c}) touches grid edge ({nr},{nc})\")\n                    break # Stop checking neighbors for this pixel\n\n                neighbor_color = grid[nr, nc]\n\n                # If it's an interior pixel and not visited, add it\n                if neighbor_color == interior_color and neighbor_pixel not in visited_interior:\n                    visited_interior.add(neighbor_pixel)\n                    q.append(neighbor_pixel)\n                    found_interior_pixels.add(neighbor_pixel)\n                # If it's NOT interior and NOT part of the frame, then it's not enclosed\n                elif neighbor_color != interior_color and neighbor_pixel not in frame_pixels:\n                    is_enclosed = False\n                    # print(f\"Interior pixel ({r},{c}) touches non-frame/non-interior ({nr},{nc}) color {neighbor_color}\")\n                    break # Stop checking neighbors for this pixel\n            if not is_enclosed:\n                break # Stop BFS if enclosure broken\n\n    if not is_enclosed:\n        return None\n\n    # 3. Verify that *all* potential starting points were part of this single component\n    #    This ensures there isn't a separate blob of interior_color also adjacent to the frame.\n    if not potential_interior_starts.issubset(found_interior_pixels):\n         # This means the BFS didn't reach all pixels adjacent to the frame,\n         # implying either multiple disjoint interiors or an incomplete enclosure.\n         # print(f\"Not all potential starts {potential_interior_starts} were in found interior {found_interior_pixels}\")\n         return None\n\n    # 4. (Implicitly covered by BFS checks) Ensure all found interior pixels only touch frame or other interior pixels\n\n    return found_interior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying framed objects (targets)\n    and solid objects (sources), handling a green/green anomaly.\n    Replaces the interior color of targets with the color of paired sources.\n    \"\"\"\n    # Make a copy to modify\n    output_grid = np.copy(input_grid)\n    \n    # Find all potential objects using 4-way connectivity\n    all_objects = find_objects(output_grid, ignore_colors={0, 8})\n\n    targets = []\n    potential_sources = []\n    green_frame_blue_interior_obj = None\n    solid_green_objects = []\n    anomaly_green_to_change = None # Store the specific solid green object if anomaly occurs\n\n    # --- Categorize all found objects ---\n    for obj in all_objects:\n        color = obj['color']\n        pixels = obj['pixels']\n        bbox = obj['bbox']\n\n        is_target = False\n        is_green_frame_anomaly_candidate = False\n        is_solid_green = False\n\n        # Check if it's a Red frame around Blue (potential target)\n        if color == 2: # Red\n            # Use the original grid for checking interior properties\n            interior = get_interior_pixels(input_grid, pixels, frame_color=2, interior_color=1)\n            if interior:\n                targets.append({'frame_pixels': pixels, 'interior_pixels': interior, 'bbox': bbox})\n                is_target = True\n        \n        # Check Green objects for anomaly condition or being a potential source\n        elif color == 3: # Green\n            # Check if it frames a Blue interior\n            # Use the original grid for checking interior properties\n            interior = get_interior_pixels(input_grid, pixels, frame_color=3, interior_color=1)\n            if interior:\n                # Found the Green frame potentially involved in the anomaly\n                green_frame_blue_interior_obj = {'frame_pixels': pixels, 'interior_pixels': interior, 'bbox': bbox, 'obj_ref': obj}\n                is_green_frame_anomaly_candidate = True\n                # Green frames are never sources, regardless of anomaly\n            else:\n                # It's a solid Green object (or other complex shape)\n                solid_green_objects.append(obj)\n                is_solid_green = True\n                # Add solid green to potential sources for now, might be removed by anomaly\n                potential_sources.append(obj)\n\n        # Add other non-Red, non-Green-frame objects to potential sources\n        # Blue objects *are* potential sources if they are solid\n        if not is_target and color != 2 and not is_green_frame_anomaly_candidate and not is_solid_green:\n             potential_sources.append(obj)\n\n    # --- Handle Anomaly (Green frame + Solid Green) ---\n    anomaly_handled = False\n    if green_frame_blue_interior_obj and solid_green_objects:\n        # Anomaly condition met. Choose the first solid green object found.\n        anomaly_green_to_change = solid_green_objects[0]\n\n        # Change its color in the output grid\n        for r, c in anomaly_green_to_change['pixels']:\n            output_grid[r, c] = 1 # Change to Blue\n\n        # Mark anomaly as handled\n        anomaly_handled = True\n        # print(f\"Anomaly handled: Changed solid green object {anomaly_green_to_change['bbox']} to blue.\")\n\n\n    # --- Filter Sources ---\n    final_sources = []\n    # Iterate through the initially collected potential sources\n    for src in potential_sources:\n        # Exclude the solid green object that was changed in the anomaly\n        # Need to compare by pixels as the object reference might be stale if list was copied\n        if anomaly_handled and src['pixels'] == anomaly_green_to_change['pixels']:\n            # print(f\"Excluding anomaly-changed green object {src['bbox']} from sources.\")\n            continue\n        # Exclude any remaining Red objects (shouldn't be in potential_sources anyway, but double check)\n        if src['color'] == 2:\n             # print(f\"Excluding red object {src['bbox']} from sources.\")\n             continue\n        # Note: The green frame object was never added to potential_sources if identified correctly\n\n        final_sources.append(src)\n\n\n    # --- Pair Targets and Final Sources ---\n    # Sort targets by top-left corner (row, then column)\n    targets.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n    # Sort sources by top-left corner (row, then column)\n    final_sources.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n\n    # --- Perform Transformation ---\n    num_targets = len(targets)\n    num_sources = len(final_sources)\n\n    # Only proceed if the counts match\n    if num_targets > 0 and num_targets == num_sources:\n        # print(f\"Matching {num_targets} targets to {num_sources} sources.\")\n        # Pair them index-wise based on the sorted lists\n        for i in range(num_targets):\n            target = targets[i]\n            source = final_sources[i]\n            new_color = source['color'] # Get the color of the matched source\n            \n            # Ensure the source color isn't the anomaly-changed one (it should be the original color)\n            # If the source IS the object that got changed by anomaly, its color is now BLUE (1)\n            # The description isn't 100% clear if the *original* green color or the *new* blue color should be used IF it were a source.\n            # However, the description says \"Exclude [...] the original solid Green object from the list of Sources.\"\n            # The filtering logic above *should* prevent the anomaly-changed object from being in final_sources.\n\n            # print(f\"  Target {i} (bbox {target['bbox']}) <- Source {i} (color {new_color}, bbox {source['bbox']})\")\n\n            # Fill the interior of the target with the source color\n            for r, c in target['interior_pixels']:\n                # Double check bounds and that it's still blue (might be redundant)\n                if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]: # and output_grid[r,c] == 1: (Removed check in case interior overlaps somehow)\n                     output_grid[r, c] = new_color\n    # else:\n        # Optional: Add debugging print for mismatch cases\n        # if num_targets != num_sources:\n        #      print(f\"Warning: Mismatch between number of targets ({num_targets}) and final sources ({num_sources}). No transformation applied.\")\n        #      print(\"Targets:\", [t['bbox'] for t in targets])\n        #      print(\"Sources:\", [(s['color'], s['bbox']) for s in final_sources])\n        # elif num_targets == 0:\n        #      print(\"No targets found.\")\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11668,
    "candidates_token_count": 3843,
    "total_token_count": 15511,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 67.436387,
  "retries": null
}