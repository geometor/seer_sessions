{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify objects in the input grid, specifically focusing on:\n1. \"Target\" objects: Red (2) frames surrounding a Blue (1) interior.\n2. \"Source\" objects: Solid, single-color shapes (not Red frames, often Green, Yellow, Gray, Magenta, etc.).\n3. Anomaly case (seen in train_2): A solid Green (3) object and a Green (3) framed Blue (1) object.\n\nTransformation rules:\n1. General rule: For each Target object (Red frame, Blue interior), find a corresponding Source object. Replace the Blue (1) interior pixels of the Target with the color of the paired Source object. The pairing is done by sorting Targets and Sources by their top-left bounding box coordinates and matching them index-wise.\n2. Anomaly rule: If both a solid Green (3) object and a Green (3) framed Blue (1) object exist, change the solid Green object's pixels to Blue (1) and leave the Green-framed object untouched. This Green object is then not considered a Source for the general rule.\n3. All other pixels (background, frames, other shapes not involved in the above) remain unchanged.\n\nHelper functions needed:\n- find_objects: Locates connected components (objects) of non-background colors.\n- get_bounding_box: Calculates the bounding box of an object.\n- identify_framed_objects: Specifically finds objects with a frame of one color surrounding an interior of another color.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected objects of non-background colors (0 and 8).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'pixels' (set of (r, c) tuples), and 'bbox'.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    background_colors = {0, 8}\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if not visited[r, c] and color not in background_colors:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef identify_framed_object(grid, frame_pixels, frame_color, interior_color):\n    \"\"\"\n    Checks if a set of frame_pixels perfectly encloses a single connected\n    component of interior_color.\n\n    Args:\n        grid (np.array): The input grid.\n        frame_pixels (set): Set of (r, c) tuples for the potential frame.\n        frame_color (int): The color of the frame.\n        interior_color (int): The color of the potential interior.\n\n    Returns:\n        set: Set of (r,c) tuples for the interior pixels if it's a valid framed object,\n             otherwise None.\n    \"\"\"\n    if not frame_pixels:\n        return None\n\n    height, width = grid.shape\n    q = deque()\n    potential_interior = set()\n    visited_interior = set()\n\n    # Find starting points for interior search (neighbors of frame pixels)\n    for r_frame, c_frame in frame_pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if abs(dr) + abs(dc) != 1: # Only check cardinal neighbors initially\n                    continue\n                r_adj, c_adj = r_frame + dr, c_frame + dc\n                # Check bounds, if it's the interior color, and not part of the frame\n                if 0 <= r_adj < height and 0 <= c_adj < width and \\\n                   grid[r_adj, c_adj] == interior_color and \\\n                   (r_adj, c_adj) not in frame_pixels:\n                    potential_interior.add((r_adj, c_adj))\n                    if not q and (r_adj, c_adj) not in visited_interior:\n                         q.append((r_adj, c_adj))\n                         visited_interior.add((r_adj, c_adj))\n\n\n    if not q: # No potential interior pixels found adjacent to frame\n        return None\n\n    # Perform BFS on potential interior pixels starting from one point\n    actual_interior = set()\n    start_r, start_c = q[0] # Use the first discovered potential interior pixel\n\n    # Re-initialize queue and visited for clean BFS of the single component\n    q = deque([(start_r, start_c)])\n    visited_interior = {(start_r, start_c)}\n    actual_interior.add((start_r, start_c))\n\n\n    while q:\n        r_int, c_int = q.popleft()\n\n        # Check neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 if dr == 0 and dc == 0:\n                     continue\n                 nr, nc = r_int + dr, c_int + dc\n\n                 if 0 <= nr < height and 0 <= nc < width:\n                     neighbor_pixel = (nr, nc)\n                     neighbor_color = grid[nr, nc]\n\n                     # If neighbor is interior color and not visited, add to queue\n                     if neighbor_color == interior_color and neighbor_pixel not in visited_interior:\n                         visited_interior.add(neighbor_pixel)\n                         q.append(neighbor_pixel)\n                         actual_interior.add(neighbor_pixel)\n                     # If neighbor is NOT interior and NOT frame, then it's not fully enclosed\n                     elif neighbor_color != interior_color and neighbor_pixel not in frame_pixels:\n                          # Check if this non-interior, non-frame neighbor is outside the bounding box of the frame\n                          min_r_frame = min(r for r, c in frame_pixels)\n                          min_c_frame = min(c for r, c in frame_pixels)\n                          max_r_frame = max(r for r, c in frame_pixels)\n                          max_c_frame = max(c for r, c in frame_pixels)\n                          if not (min_r_frame <= nr <= max_r_frame and min_c_frame <= nc <= max_c_frame):\n                              # If it touches something other than the frame or itself, and that thing is outside the frame's bbox,\n                              # it might still be enclosed if the frame is concave, but simple check fails.\n                              # A more robust check would be needed, but let's assume frames are simple enough for now.\n                              # For now, we assume if it touches non-frame/non-interior within bbox, it's okay, but outside it's leaking.\n                              # Let's refine: if ANY interior pixel touches a non-frame color pixel, it's invalid.\n                              return None # Touches something other than frame or self\n\n    # Check if all potential interior pixels were covered by the single BFS\n    # This check might be redundant if the frame integrity check is good\n    # if potential_interior != actual_interior:\n        # print(f\"Potential interior {potential_interior} != Actual {actual_interior}\")\n        # return None # Interior is not a single connected component\n\n    # Final check: ensure all interior pixels only touch frame or other interior pixels\n    for r_int, c_int in actual_interior:\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 if dr == 0 and dc == 0:\n                     continue\n                 nr, nc = r_int + dr, c_int + dc\n                 if 0 <= nr < height and 0 <= nc < width:\n                     neighbor_pixel = (nr, nc)\n                     if neighbor_pixel not in frame_pixels and neighbor_pixel not in actual_interior:\n                          # Touches something that is neither frame nor interior\n                          # print(f\"Interior pixel {(r_int, c_int)} touches non-frame/non-interior at {(nr, nc)}\")\n                          return None\n\n    return actual_interior\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying framed objects and source objects.\n    Replaces the interior color of framed objects with the color of corresponding source objects.\n    Handles a special case involving green-framed and solid green objects.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    all_objects = find_objects(output_grid)\n\n    targets = []\n    potential_sources = []\n    green_frame_blue_interior_obj = None\n    solid_green_objects = []\n\n    # --- Categorize objects ---\n    for obj in all_objects:\n        color = obj['color']\n        pixels = obj['pixels']\n\n        if color == 2: # Red - potential target frame\n            interior_pixels = identify_framed_object(output_grid, pixels, frame_color=2, interior_color=1)\n            if interior_pixels:\n                targets.append({'frame_pixels': pixels, 'interior_pixels': interior_pixels, 'bbox': obj['bbox']})\n            else:\n                potential_sources.append(obj) # Red object, but not a frame for blue\n        elif color == 3: # Green - potential anomaly frame or solid object\n             interior_pixels = identify_framed_object(output_grid, pixels, frame_color=3, interior_color=1)\n             if interior_pixels:\n                 green_frame_blue_interior_obj = {'frame_pixels': pixels, 'interior_pixels': interior_pixels, 'bbox': obj['bbox']}\n                 # This green frame object is NOT a source\n             else:\n                 # It's a solid green object (or green but not framing blue)\n                 solid_green_objects.append(obj)\n                 potential_sources.append(obj) # Initially add solid green as potential source\n        else:\n            potential_sources.append(obj) # Other colors are potential sources\n\n\n    # --- Handle Anomaly (train_2 case) ---\n    anomaly_handled = False\n    if green_frame_blue_interior_obj and solid_green_objects:\n        # Find the specific solid green object to change (if multiple, take the first found)\n        # We need to remove *this specific* green object from potential_sources\n        obj_to_change = solid_green_objects[0]\n        \n        # Check if obj_to_change is actually in potential_sources before removing\n        original_sources_count = len(potential_sources)\n        potential_sources = [s for s in potential_sources if s['pixels'] != obj_to_change['pixels']]\n        \n        if len(potential_sources) < original_sources_count: # Check if removal happened\n            # Change the color of the solid green object to blue in the output grid\n            for r, c in obj_to_change['pixels']:\n                output_grid[r, c] = 1 # Change to Blue\n            anomaly_handled = True\n            # print(f\"Anomaly handled: Changed solid green object to blue. Removed from sources.\")\n        # else:\n            # print(f\"Anomaly condition met, but solid green object not found in potential sources? obj: {obj_to_change}\")\n\n\n    # --- Handle Standard Transformations ---\n    # Sort targets and remaining sources by bounding box (top-row, then left-col)\n    targets.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n    potential_sources.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n\n    # Filter out the green frame if it existed (it was never added or already removed if anomaly triggered)\n    # This filtering step might be redundant given the logic above, but ensures correctness.\n    final_sources = []\n    for src in potential_sources:\n        is_green_frame = green_frame_blue_interior_obj and src['pixels'] == green_frame_blue_interior_obj['frame_pixels']\n        # Also ensure the anomaly-swapped green object isn't reconsidered as a source if logic failed above\n        is_swapped_green = anomaly_handled and src['color'] == 3 and src['pixels'] == solid_green_objects[0]['pixels']\n\n        if not is_green_frame and not is_swapped_green:\n             final_sources.append(src)\n\n\n    # Perform the color replacement based on sorted lists\n    if len(targets) == len(final_sources):\n        # print(f\"Matching {len(targets)} targets to {len(final_sources)} sources.\")\n        for i in range(len(targets)):\n            target = targets[i]\n            source = final_sources[i]\n            new_color = source['color']\n            # print(f\"Target {i} (bbox {target['bbox']}) paired with Source {i} (color {new_color}, bbox {source['bbox']})\")\n\n            for r, c in target['interior_pixels']:\n                # Check if the pixel is still blue (relevant if multiple targets overlap?)\n                if output_grid[r,c] == 1:\n                    output_grid[r, c] = new_color\n    # else:\n        # print(f\"Warning: Mismatch between number of targets ({len(targets)}) and final sources ({len(final_sources)}).\")\n        # print(\"Targets:\", [t['bbox'] for t in targets])\n        # print(\"Sources:\", [(s['color'], s['bbox']) for s in final_sources])\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6268,
    "candidates_token_count": 3425,
    "total_token_count": 9693,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 242.259387,
  "retries": null
}