
## train_1

**input:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 2 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0
2 0 2 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 2 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 2 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 3 3 3 3 3 3 3 2 0 0 0
0 0 0 0 0 0 0 0 3 3 2 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 3 3 3 2 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 3 2 3 3 3 3 3 3 3 2 0 0
```


**output:**
```
0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 1 1 1 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 3 1 2 1 3 3 1 1 1 3 3 3 0 0 0 0 0
0 0 0 3 1 1 1 3 3 1 2 1 3 1 1 1 0 0 0 0
0 0 0 3 3 3 3 3 3 1 1 1 3 1 2 1 0 0 0 0
2 0 2 1 1 1 3 3 3 3 3 3 3 1 1 1 0 0 0 0
0 0 0 1 2 1 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 1 1 1 3 3 3 3 3 3 3 3 3 0 2 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 1 2 1 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 2 0 1 1 1 3 3 3 3 3 1 1 1 0 0
0 0 0 0 0 0 2 0 3 1 1 1 3 3 3 1 2 1 0 0
0 0 0 0 0 0 0 0 3 1 2 1 1 3 3 1 1 1 0 0
0 0 0 0 0 0 0 0 3 1 1 2 1 3 3 3 3 0 0 0
0 0 0 0 0 2 0 0 1 1 1 1 1 3 3 3 3 0 0 0
0 0 0 0 0 0 2 0 1 2 1 3 3 3 3 3 3 2 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 0 0 3 3 3 3 3
0 0 2 3 3 3 3 3 3 2 3 0 0 0 2 3 3 2 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 2
0 0 3 2 3 3 3 3 3 3 3 0 0 0 0 3 3 3 3 3
0 0 3 3 3 3 3 2 3 3 3 0 0 2 0 2 3 3 3 3
0 0 2 3 3 3 3 3 3 3 3 0 2 0 0 3 3 3 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 2 3 3 3 0 2 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 2 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 2 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 2 3 3 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 3 3
0 1 1 1 3 3 1 2 1 1 1 0 0 0 0 3 1 1 1 3
0 1 2 1 3 3 1 1 1 2 1 0 0 0 2 3 1 2 1 3
0 1 1 1 3 3 1 1 1 1 1 0 0 0 0 3 1 1 1 3
0 0 3 3 3 3 1 2 1 3 3 0 2 0 0 3 3 3 3 3
0 0 3 3 3 3 1 1 1 3 3 0 0 0 0 3 3 3 1 1
0 0 1 1 1 3 3 3 3 3 3 0 0 0 0 3 3 3 1 2
0 0 1 2 1 3 1 1 1 3 3 0 0 0 1 1 1 3 1 1
0 1 1 1 1 3 1 2 1 3 3 0 0 2 1 2 1 3 3 3
0 1 2 1 3 3 1 1 1 3 3 0 2 0 1 1 1 3 3 3
0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 3 3 3 3 3
0 2 0 3 3 3 3 3 1 1 1 3 3 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 1 2 1 1 1 0 2 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 1 2 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 2 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 3 3 3 1 1 1 1 2 1 3 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 2 0 0 0 0 3 3 3 3 3 2 0 0
0 3 3 3 3 0 0 0 0 3 3 3 3 3 3 0 0
0 3 3 3 3 0 0 0 0 3 2 2 3 3 3 0 0
0 2 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 2 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 3 3 1 1 1 0 0 0 0 0 0 0 1 1 1 0
0 3 3 1 2 1 0 0 0 3 3 3 3 1 2 1 0
0 3 3 1 1 1 0 0 0 1 1 1 1 1 1 1 0
0 3 3 3 3 0 0 0 0 1 2 2 1 3 3 0 0
0 2 0 0 0 0 0 0 0 1 1 1 1 3 3 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0
```

**Perception:**

The task involves modifying grids containing primarily green (3) regions dotted with red (2) pixels against a white (0) background. The output grids show that some of the green pixels have been changed to blue (1), while the red pixels and the background remain unchanged. The transformation appears localized around the red pixels. Specifically, green pixels that are directly adjacent (orthogonally or diagonally) to any red pixel in the input grid are changed to blue in the output grid. All other pixels, including the red pixels themselves and green pixels not adjacent to red pixels, keep their original color.

**YAML Facts:**


```yaml
elements:
  - type: background
    color: white (0)
  - type: region
    color: green (3)
    description: Contiguous or semi-contiguous areas of green pixels.
  - type: point
    color: red (2)
    description: Individual or small groups of red pixels, often located within or near green regions.
  - type: point
    color: blue (1)
    description: Appears only in the output grid, replacing some green pixels.

relationships:
  - type: adjacency
    description: Pixels are considered adjacent if they share an edge or a corner (orthogonal or diagonal neighbors).
  - type: spatial_proximity
    description: Red pixels are located near or within green regions.

transformation:
  - action: color_change
    input_object: green (3) pixel
    condition: The green pixel is adjacent (orthogonally or diagonally) to at least one red (2) pixel in the input grid.
    output_object: blue (1) pixel
  - action: preserve_color
    input_object: Any pixel (white, red, or green)
    condition: The pixel is NOT a green (3) pixel adjacent to a red (2) pixel.
    output_object: The pixel retains its original color.
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the output grid.
2.  Iterate through each pixel (cell) of the input grid using its row and column index.
3.  For the current pixel, check if its color is green (3).
4.  If the current pixel is green, examine all its 8 neighbors (orthogonal and diagonal).
5.  Check if any of these neighbors in the *input* grid has the color red (2).
6.  If the current green pixel has at least one red neighbor, change the color of the corresponding pixel in the *output* grid to blue (1).
7.  If the current pixel is not green, or if it is green but has no red neighbors, the corresponding pixel in the output grid retains the original color from the input grid.
8.  After checking all pixels, the modified output grid is the result.
