{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-background connected components (objects) in the input grid.\nDetermines the 'primary color' for each object (color of its top-leftmost pixel).\nClassifies objects into 'sources' (contain pixels different from primary color) and 'targets' (contain only primary color pixels).\nGroups objects by primary color.\nFor groups with exactly one source and one or more targets:\n  Iterates through the pixels within the source object.\n  If a pixel in the source belongs to the source component and its color is NOT the primary color (i.e., it's part of the internal pattern):\n    Calculates its relative position within the source's bounding box.\n    Determines the corresponding absolute position within each target object's bounding box.\n    Crucially, checks if this target position actually belongs to the target object's pixel set.\n    If it does, copies the source pattern pixel's color to that target pixel location in the output grid.\nThe output grid starts as a copy of the input grid and is modified only where internal pattern pixels are copied onto valid target pixels.\n\"\"\"\n\ndef find_component_bfs(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component of non-background pixels using BFS,\n    starting from (start_r, start_c). Determines the component's\n    bounding box and the set of pixels belonging to it.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): Boolean array tracking visited pixels.\n\n    Returns:\n        tuple: (component_pixels, bbox)\n               component_pixels: set of (r, c) tuples for pixels in the component.\n               bbox: (min_r, min_c, max_r, max_c) bounding box.\n               Returns (None, None) if the start pixel is background or already visited.\n    \"\"\"\n    rows, cols = grid.shape\n    # Check if the starting point is valid (within bounds, not background, not visited)\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or visited[start_r, start_c] or grid[start_r, start_c] == 0:\n        return None, None\n\n    # Initialize BFS queue and component properties\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n    component_pixels = set([(start_r, start_c)])\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n\n        # Update bounding box\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-directional: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within grid, not visited, and not background\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc] and grid[nr, nc] != 0:\n                 visited[nr, nc] = True\n                 q.append((nr, nc))\n                 component_pixels.add((nr, nc))\n\n    bbox = (min_r, min_c, max_r, max_c)\n    return component_pixels, bbox\n\ndef get_top_left_pixel(pixel_set):\n    \"\"\"Finds the top-leftmost pixel in a set of (row, col) tuples.\"\"\"\n    if not pixel_set:\n        return None\n    min_r = min(r for r, c in pixel_set)\n    min_c = min(c for r, c in pixel_set if r == min_r)\n    return (min_r, min_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the source-target pattern copy transformation.\n    \"\"\"\n    # 1. Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n    objects_data = []\n\n    # 2. Find all distinct objects (connected components)\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-background and not yet visited (part of a found component)\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                # 3a. Find the component pixels and bounding box using BFS\n                component_pixels, bbox = find_component_bfs(input_grid, r, c, visited)\n\n                if component_pixels:\n                    # 3b. Determine the primary color from the top-left pixel of the component\n                    tl_pixel = get_top_left_pixel(component_pixels)\n                    primary_color = input_grid[tl_pixel]\n\n                    # 3c. Classify as source or target\n                    is_source = False\n                    for rr, cc in component_pixels:\n                        if input_grid[rr, cc] != primary_color:\n                            is_source = True\n                            break\n\n                    # Store object info\n                    obj_info = {\n                        'bbox': bbox,\n                        'pixels': component_pixels,\n                        'primary_color': primary_color,\n                        'is_source': is_source # True if source, False if target\n                    }\n                    objects_data.append(obj_info)\n\n    # 4. Group objects by primary color.\n    objects_by_color = {}\n    for obj in objects_data:\n        color = obj['primary_color']\n        if color not in objects_by_color:\n            objects_by_color[color] = []\n        objects_by_color[color].append(obj)\n\n    # 5. Iterate through each color group.\n    for color, object_list in objects_by_color.items():\n        sources = [obj for obj in object_list if obj['is_source']]\n        targets = [obj for obj in object_list if not obj['is_source']]\n\n        # 6. If a group has exactly one source and >= 1 target:\n        if len(sources) == 1 and len(targets) > 0:\n            src_obj = sources[0]\n            P = src_obj['primary_color'] # Primary color of the group\n            min_r_src, min_c_src, _, _ = src_obj['bbox']\n            src_pixels = src_obj['pixels'] # Set of (r, c) tuples for the source\n\n            # 6a. For each target object T in the group:\n            for tgt_obj in targets:\n                min_r_tgt, min_c_tgt, _, _ = tgt_obj['bbox']\n                target_pixels = tgt_obj['pixels'] # Set of (r, c) tuples for the target\n\n                # 6b. Iterate through each pixel *belonging to the source object*.\n                for sr, sc in src_pixels:\n                    src_color = input_grid[sr, sc]\n\n                    # 6c. If the source pixel is part of the internal pattern (not primary color):\n                    if src_color != P:\n                        # 6d. Calculate relative coordinates within the source bounding box.\n                        dr = sr - min_r_src\n                        dc = sc - min_c_src\n\n                        # 6e. Calculate corresponding absolute target coordinates.\n                        tr = min_r_tgt + dr\n                        tc = min_c_tgt + dc\n\n                        # 6f. **Crucial Check**: Ensure the target coordinate is valid *and* part of the target object's shape.\n                        if (tr, tc) in target_pixels:\n                             # 6g. Copy the pattern color to the output grid at the valid target location.\n                             output_grid[tr, tc] = src_color\n\n    # 7. Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21434,
    "candidates_token_count": 1958,
    "total_token_count": 23392,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.69168,
  "retries": null
}