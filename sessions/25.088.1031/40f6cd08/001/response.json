{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-background rectangular objects in the input grid.\nGroups these objects based on their primary color (the color of the first pixel encountered during object detection).\nWithin each color group, finds a unique 'pattern source' object (containing pixels of colors other than its primary color and background within its bounding box) \nand one or more 'target' objects (containing only the primary color or background within their bounding box).\nCopies the entire content of the source object's bounding box onto the bounding box area of each target object, provided their dimensions match.\n\"\"\"\n\ndef find_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component of non-background pixels using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): Boolean array tracking visited pixels.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) bounding box of the component.\n               Returns None if the start pixel is background or already visited.\n    \"\"\"\n    rows, cols = grid.shape\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or visited[start_r, start_c] or grid[start_r, start_c] == 0:\n        return None\n\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n\n    while q:\n        r, c = q.popleft()\n\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying patterns from source objects to target objects.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n    \n    objects_data = []\n\n    # 1. Identify all distinct non-background components and their properties\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                primary_color = input_grid[r, c] # Use the color of the first pixel found as the primary color\n                bbox = find_component(input_grid, r, c, visited)\n                \n                if bbox:\n                    min_r, min_c, max_r, max_c = bbox\n                    \n                    # Determine if the object has an internal pattern within its bounding box\n                    has_pattern = False\n                    for rr in range(min_r, max_r + 1):\n                        for cc in range(min_c, max_c + 1):\n                            # Check for colors other than primary or background *within* the bounding box\n                            if input_grid[rr, cc] != primary_color and input_grid[rr, cc] != 0:\n                                has_pattern = True\n                                break\n                        if has_pattern:\n                            break\n                            \n                    obj_info = {'bbox': bbox, 'primary_color': primary_color, 'has_pattern': has_pattern}\n                    objects_data.append(obj_info)\n\n    # 2. Group objects by primary color\n    objects_by_color = {}\n    for obj in objects_data:\n        color = obj['primary_color']\n        if color not in objects_by_color:\n            objects_by_color[color] = []\n        objects_by_color[color].append(obj)\n\n    # 3. Process each color group to find source and targets, then copy patterns\n    for color, object_list in objects_by_color.items():\n        sources = [obj for obj in object_list if obj['has_pattern']]\n        targets = [obj for obj in object_list if not obj['has_pattern']]\n\n        # Check if there is exactly one source and at least one target\n        if len(sources) == 1 and len(targets) > 0:\n            src_obj = sources[0]\n            min_r_src, min_c_src, max_r_src, max_c_src = src_obj['bbox']\n            height_src = max_r_src - min_r_src + 1\n            width_src = max_c_src - min_c_src + 1\n\n            # Iterate through targets and copy the pattern if dimensions match\n            for tgt_obj in targets:\n                min_r_tgt, min_c_tgt, max_r_tgt, max_c_tgt = tgt_obj['bbox']\n                height_tgt = max_r_tgt - min_r_tgt + 1\n                width_tgt = max_c_tgt - min_c_tgt + 1\n\n                if height_src == height_tgt and width_src == width_tgt:\n                    # Copy the entire bounding box content from source to target\n                    for dr in range(height_src):\n                        for dc in range(width_src):\n                            r_src_idx = min_r_src + dr\n                            c_src_idx = min_c_src + dc\n                            r_tgt_idx = min_r_tgt + dr\n                            c_tgt_idx = min_c_tgt + dc\n                            \n                            # Ensure indices are within grid bounds (should be if bbox is correct)\n                            if 0 <= r_tgt_idx < rows and 0 <= c_tgt_idx < cols:\n                                output_grid[r_tgt_idx, c_tgt_idx] = input_grid[r_src_idx, c_src_idx]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12557,
    "candidates_token_count": 1572,
    "total_token_count": 14129,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.575733,
  "retries": null
}