{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-background connected components (objects) in the input grid.\nFor each object, determines its 'primary color' (color of the first pixel found during detection).\nClassifies objects into 'sources' and 'targets' based on their content:\n  - A 'source' object contains at least one pixel whose color is different from its primary color.\n  - A 'target' object contains only pixels of its primary color.\nGroups objects by their primary color.\nWithin each color group, if there is exactly one source object and one or more target objects:\n  - Extracts the rectangular pattern defined by the bounding box of the source object from the input grid.\n  - Copies this pattern onto the output grid, positioning the top-left corner of the pattern at the top-left corner of each target object's bounding box. The pattern overwrites any existing pixels in the target area.\nThe output grid initially mirrors the input grid and is modified by these copy operations.\n\"\"\"\n\ndef find_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component of non-background pixels using BFS,\n    starting from (start_r, start_c). Determines the component's\n    bounding box, the set of pixels belonging to it, and its primary color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): Boolean array tracking visited pixels.\n\n    Returns:\n        tuple: (bbox, component_pixels, primary_color)\n               bbox: (min_r, min_c, max_r, max_c) bounding box.\n               component_pixels: set of (r, c) tuples for pixels in the component.\n               primary_color: The color of the starting pixel (start_r, start_c).\n               Returns (None, None, None) if the start pixel is background or already visited.\n    \"\"\"\n    rows, cols = grid.shape\n    # Check if the starting point is valid\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or visited[start_r, start_c] or grid[start_r, start_c] == 0:\n        return None, None, None\n\n    # Initialize BFS queue and component properties\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n    component_pixels = set([(start_r, start_c)])\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n    primary_color = grid[start_r, start_c] # Use starting pixel's color as primary\n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n\n        # Update bounding box\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-directional: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within grid, not visited, and not background\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc] and grid[nr, nc] != 0:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n                component_pixels.add((nr, nc))\n\n    bbox = (min_r, min_c, max_r, max_c)\n    return bbox, component_pixels, primary_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying source and target objects\n    and copying the source pattern onto the targets.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    # Keep track of visited pixels during component finding\n    visited = np.zeros_like(input_grid, dtype=bool)\n    \n    objects_data = []\n\n    # 1. Find all distinct non-background components (objects)\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-background and not yet visited, start BFS\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                bbox, component_pixels, primary_color = find_component(input_grid, r, c, visited)\n                \n                # If a valid component was found\n                if bbox:\n                    # 2. Determine if the object is a 'source' or 'target'\n                    is_source = False\n                    # Check if any pixel *within the component* has a different color\n                    for rr, cc in component_pixels:\n                        # Note: component pixels are guaranteed non-zero by find_component\n                        if input_grid[rr, cc] != primary_color: \n                            is_source = True\n                            break\n                            \n                    # Store object information\n                    obj_info = {\n                        'bbox': bbox, \n                        'pixels': component_pixels, \n                        'primary_color': primary_color, \n                        'is_source': is_source # True if source, False if target\n                    }\n                    objects_data.append(obj_info)\n\n    # 3. Group objects by their primary color\n    objects_by_color = {}\n    for obj in objects_data:\n        color = obj['primary_color']\n        if color not in objects_by_color:\n            objects_by_color[color] = []\n        objects_by_color[color].append(obj)\n\n    # 4. Process each color group\n    for color, object_list in objects_by_color.items():\n        # Separate sources and targets within the group\n        sources = [obj for obj in object_list if obj['is_source']]\n        targets = [obj for obj in object_list if not obj['is_source']]\n\n        # 5. Apply transformation if exactly one source and at least one target exists\n        if len(sources) == 1 and len(targets) > 0:\n            src_obj = sources[0]\n            min_r_src, min_c_src, max_r_src, max_c_src = src_obj['bbox']\n            \n            # Extract the pattern from the source object's bounding box\n            pattern = input_grid[min_r_src : max_r_src + 1, min_c_src : max_c_src + 1]\n            height_src, width_src = pattern.shape\n\n            # Iterate through each target object\n            for tgt_obj in targets:\n                # Get the top-left corner of the target's bounding box\n                min_r_tgt, min_c_tgt, _, _ = tgt_obj['bbox'] \n\n                # Define the destination slice in the output grid\n                end_r_tgt = min_r_tgt + height_src\n                end_c_tgt = min_c_tgt + width_src\n                \n                # Determine the actual portion of the pattern that fits within the grid boundaries\n                effective_height = min(height_src, rows - min_r_tgt)\n                effective_width = min(width_src, cols - min_c_tgt)\n\n                # Copy the (potentially clipped) pattern if it has positive dimensions\n                if effective_height > 0 and effective_width > 0:\n                     # Slice the pattern to match the effective dimensions\n                     pattern_slice = pattern[0:effective_height, 0:effective_width]\n                     # Place the pattern slice onto the output grid, overwriting existing content\n                     output_grid[min_r_tgt : min_r_tgt + effective_height, min_c_tgt : min_c_tgt + effective_width] = pattern_slice\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18528,
    "candidates_token_count": 1932,
    "total_token_count": 20460,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.740955,
  "retries": null
}