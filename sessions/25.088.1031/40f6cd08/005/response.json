{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-background connected components (objects) in the input grid.\nDetermines the 'primary color' for each object (color of the first pixel found).\nClassifies objects into 'sources' (contain pixels different from primary color) and 'targets' (contain only primary color pixels).\nGroups objects by primary color.\nFor groups with exactly one source and one or more targets:\n  Iterates through the pixels within the source object's bounding box.\n  If a pixel in the source belongs to the source component and its color is NOT the primary color (i.e., it's part of the internal pattern):\n    Copies this pixel's color to the corresponding relative position within each target object's bounding box in the output grid.\nThe output grid starts as a copy of the input grid and is modified only where internal pattern pixels are copied into targets.\n\"\"\"\n\ndef find_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component of non-background pixels using BFS,\n    starting from (start_r, start_c). Determines the component's\n    bounding box, the set of pixels belonging to it, and its primary color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): Boolean array tracking visited pixels.\n\n    Returns:\n        tuple: (bbox, component_pixels, primary_color)\n               bbox: (min_r, min_c, max_r, max_c) bounding box.\n               component_pixels: set of (r, c) tuples for pixels in the component.\n               primary_color: The color of the starting pixel (start_r, start_c).\n               Returns (None, None, None) if the start pixel is background or already visited.\n    \"\"\"\n    rows, cols = grid.shape\n    # Check if the starting point is valid\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or visited[start_r, start_c] or grid[start_r, start_c] == 0:\n        return None, None, None\n\n    # Initialize BFS queue and component properties\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n    component_pixels = set([(start_r, start_c)])\n    min_r, min_c = start_r, start_c\n    max_r, max_c = start_r, start_c\n    primary_color = grid[start_r, start_c] # Use starting pixel's color as primary\n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n\n        # Update bounding box\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-directional: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within grid, not visited, and not background\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc] and grid[nr, nc] != 0:\n                 # Check if the neighbor has the *same* color for component definition\n                 # Updated based on refined understanding: component is connected non-background, not necessarily same-color\n                 #if grid[nr, nc] == primary_color: # Original constraint - might be too strict for multi-color objects\n                 # Relaxing constraint: any non-background neighbour belongs to the component\n                 visited[nr, nc] = True\n                 q.append((nr, nc))\n                 component_pixels.add((nr, nc))\n\n\n    bbox = (min_r, min_c, max_r, max_c)\n    return bbox, component_pixels, primary_color\n\n\ndef transform(input_grid):\n    # 1. Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n    objects_data = []\n\n    # 2. Identify all distinct connected components (objects)\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                # 3. Determine primary color, bounding box, and pixel set for each object.\n                bbox, component_pixels, primary_color = find_component(input_grid, r, c, visited)\n                \n                if bbox:\n                    # 4. Classify each object as source or target.\n                    is_source = False\n                    for rr, cc in component_pixels:\n                        if input_grid[rr, cc] != primary_color:\n                            is_source = True\n                            break\n                            \n                    obj_info = {\n                        'bbox': bbox, \n                        'pixels': component_pixels, \n                        'primary_color': primary_color, \n                        'is_source': is_source # True if source, False if target\n                    }\n                    objects_data.append(obj_info)\n\n    # 5. Group objects by primary color.\n    objects_by_color = {}\n    for obj in objects_data:\n        color = obj['primary_color']\n        if color not in objects_by_color:\n            objects_by_color[color] = []\n        objects_by_color[color].append(obj)\n\n    # 6. Iterate through each color group.\n    for color, object_list in objects_by_color.items():\n        sources = [obj for obj in object_list if obj['is_source']]\n        targets = [obj for obj in object_list if not obj['is_source']]\n\n        # 7. If a group has exactly one source and >= 1 target:\n        if len(sources) == 1 and len(targets) > 0:\n            src_obj = sources[0]\n            P = src_obj['primary_color'] # Primary color of the group\n            min_r_src, min_c_src, max_r_src, max_c_src = src_obj['bbox']\n            src_pixels = src_obj['pixels']\n            height_src = max_r_src - min_r_src + 1\n            width_src = max_c_src - min_c_src + 1\n\n            # 7a. For each target object T in the group:\n            for tgt_obj in targets:\n                min_r_tgt, min_c_tgt, _, _ = tgt_obj['bbox'] \n\n                # 7b. Iterate through relative coordinates within the source bounding box.\n                for dr in range(height_src):\n                    for dc in range(width_src):\n                        # 7c. Calculate absolute source coordinates.\n                        sr = min_r_src + dr\n                        sc = min_c_src + dc\n\n                        # 7d. Calculate absolute target coordinates.\n                        tr = min_r_tgt + dr\n                        tc = min_c_tgt + dc\n                        \n                        # 7e. Check if source pixel is part of the component AND is internal pattern.\n                        # Make sure the source coordinate is actually part of the *component* pixels,\n                        # not just within the bounding box but outside the actual shape.\n                        if (sr, sc) in src_pixels and input_grid[sr, sc] != P:\n                             # 7f. If it's internal pattern AND target coords are valid, copy to output.\n                             if 0 <= tr < rows and 0 <= tc < cols:\n                                 output_grid[tr, tc] = input_grid[sr, sc]\n\n    # 8. Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20659,
    "candidates_token_count": 1889,
    "total_token_count": 22548,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.106506,
  "retries": null
}