{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis program transforms an input grid based on the presence or absence of magenta (6) pixels.\n\n1.  **Check for Magenta:** Determine if any magenta pixels exist in the input grid.\n\n2.  **If Magenta is Absent:**\n    a.  Calculate a horizontal shift: `shift_col = width // 2 - 1`. Vertical shift is 0.\n    b.  Identify all non-white objects fully contained within the left half of the grid (columns 0 to `width // 2 - 1`).\n    c.  Copy each of these objects, applying the calculated shift `(0, shift_col)` to each pixel's coordinates.\n    d.  Draw the copied objects onto the output grid (initialized as a copy of the input).\n\n3.  **If Magenta is Present:**\n    a.  Identify all non-white objects and find the one with the largest area (most pixels).\n    b.  Identify all distinct magenta objects.\n    c.  Determine the top-left coordinate for each magenta object.\n    d.  Sort these top-left coordinates first by row, then by column.\n    e.  Select the coordinates of the *second* magenta object in the sorted list. These coordinates `(shift_row, shift_col)` define the shift vector.\n    f.  Copy the largest non-white object, applying the shift vector `(shift_row, shift_col)` to each of its pixels.\n    g.  Draw the copied largest object onto the output grid.\n\nThe output grid starts as a copy of the input grid, and the copied objects overwrite existing pixels at their new locations.\n\"\"\"\n\ndef find_objects(grid, target_color=None):\n    \"\"\"\n    Finds all contiguous objects of non-background pixels (or a specific color).\n    Includes diagonal connectivity.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int, optional): If specified, only find objects of this color.\n                                      Otherwise, find all non-zero colored objects.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary:\n              {'coords': set((r, c), ...), 'color': int, 'size': int}\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) in visited:\n                continue\n\n            color = grid[r, c]\n\n            # Skip background or non-target colors\n            if color == background_color:\n                visited.add((r,c)) # Mark background as visited too\n                continue\n            if target_color is not None and color != target_color:\n                continue # Skip if looking for specific color and this isn't it\n\n            # Start BFS for a new object\n            q = deque([(r, c)])\n            current_object_coords = set()\n            visited.add((r, c))\n            obj_color = color # All pixels in an object have the same color\n\n            while q:\n                row, col = q.popleft()\n                current_object_coords.add((row, col))\n\n                # Check 8 neighbors (including diagonals)\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = row + dr, col + dc\n\n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            neighbor_color = grid[nr, nc]\n                            # Check if neighbor is part of the same object and not visited\n                            if (nr, nc) not in visited and neighbor_color == obj_color:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n\n            if current_object_coords:\n                objects.append({\n                    'coords': current_object_coords,\n                    'color': obj_color,\n                    'size': len(current_object_coords)\n                })\n\n    return objects\n\ndef get_top_left(obj_coords):\n    \"\"\"Calculates the top-left coordinate of an object.\"\"\"\n    if not obj_coords:\n        return None\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords if r == min_r) # Find min col among min rows\n    # Refined: find global min_r and global min_c independently\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    return (min_r, min_c)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the presence/absence of magenta pixels.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # Check for magenta pixels (color 6)\n    magenta_present = np.any(input_np == 6)\n\n    if not magenta_present:\n        # --- Case 1: No Magenta ---\n        shift_row = 0\n        shift_col = cols // 2 - 1 # As derived from example 1\n\n        # Check if shift is valid (e.g., for very narrow grids)\n        if shift_col < 0:\n             shift_col = 0 # Avoid negative shift, perhaps just copy in place or no copy? Adjust as needed.\n\n        all_objects = find_objects(input_np)\n        left_half_boundary = cols // 2\n\n        for obj in all_objects:\n            # Check if the entire object is within the left half\n            is_in_left_half = True\n            for r, c in obj['coords']:\n                if c >= left_half_boundary:\n                    is_in_left_half = False\n                    break\n\n            if is_in_left_half:\n                # Copy the object with the calculated shift\n                obj_color = obj['color']\n                for r, c in obj['coords']:\n                    nr, nc = r + shift_row, c + shift_col\n                    # Draw pixel if within bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        output_grid[nr, nc] = obj_color\n\n    else:\n        # --- Case 2: Magenta Present ---\n        # Find all non-white objects\n        all_objects = find_objects(input_np)\n\n        if not all_objects:\n             return output_grid.tolist() # No objects to move\n\n        # Find the largest object\n        largest_object = max(all_objects, key=lambda obj: obj['size'])\n\n        # Find all magenta objects\n        magenta_objects = find_objects(input_np, target_color=6)\n\n        if len(magenta_objects) < 2:\n             # Handle cases with 0 or 1 magenta object - behavior undefined by examples.\n             # Let's assume no copy happens in this edge case.\n             return output_grid.tolist()\n\n        # Get top-left coordinates of magenta objects\n        magenta_top_lefts = []\n        for m_obj in magenta_objects:\n            tl = get_top_left(m_obj['coords'])\n            if tl:\n                magenta_top_lefts.append(tl)\n\n        # Sort coordinates (row first, then column)\n        magenta_top_lefts.sort()\n\n        # Get the shift vector from the second magenta object's top-left coordinate\n        shift_row, shift_col = magenta_top_lefts[1] # Index 1 for the second item\n\n        # Copy the largest object using the shift vector\n        largest_obj_color = largest_object['color']\n        for r, c in largest_object['coords']:\n            nr, nc = r + shift_row, c + shift_col\n            # Draw pixel if within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = largest_obj_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4241,
    "candidates_token_count": 1935,
    "total_token_count": 6176,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.284442,
  "retries": null
}