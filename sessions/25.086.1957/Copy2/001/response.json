{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct non-background objects in the input grid: a 'Pattern Object' and an 'Azure Frame Object'.\nThe Azure Frame Object (color 8) must contain a fully enclosed rectangular region of background pixels (color 0), referred to as the 'Hole'.\nThe Pattern Object is extracted, including its background pixels within its bounding box.\nThis extracted Pattern (subgrid) is then copied/pasted into the Hole within the Azure Frame in the output grid, aligning the top-left corner of the Pattern's bounding box with the top-left corner of the Hole's bounding box.\nThe original Pattern Object and the Azure Frame Object remain in their original positions in the output grid.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all connected components (objects) of non-ignored colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_color (int): The color to treat as background/ignore.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int), 'pixels' (set of (r, c) tuples),\n              and 'bbox' (dict with 'min_row', 'min_col', 'max_row', 'max_col').\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals) for same color\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store primary color (first one found, good enough if object is one color)\n                # For multi-color objects, need refinement if needed, but task seems to have single-color or pattern/frame separation\n                first_pixel_color = grid[r,c]\n\n                objects.append({\n                    'pixels': obj_pixels,\n                    'color': first_pixel_color, # Store the specific color of this component\n                    'bbox': {'min_row': min_r, 'min_col': min_c, 'max_row': max_r, 'max_col': max_c}\n                })\n                \n    # Check if any object is multi-colored, adjust 'color' if needed (maybe set to -1 or specific logic)\n    final_objects = []\n    for obj in objects:\n         colors_in_obj = set(grid[r,c] for r,c in obj['pixels'])\n         if len(colors_in_obj) > 1:\n              obj['color'] = -1 # Mark as multi-color pattern object\n         else:\n              obj['color'] = colors_in_obj.pop() # Should be single color\n         final_objects.append(obj)\n         \n    return final_objects\n\n\ndef find_hole(grid, frame_bbox):\n    \"\"\"\n    Finds the rectangular hole (area of background color 0) inside a frame's bounding box.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        frame_bbox (dict): Bounding box of the frame object.\n\n    Returns:\n        dict: Bounding box dictionary {'min_row', 'min_col', 'max_row', 'max_col'}\n              of the hole, or None if no hole is found.\n    \"\"\"\n    height, width = grid.shape\n    min_r_frame, min_c_frame = frame_bbox['min_row'], frame_bbox['min_col']\n    max_r_frame, max_c_frame = frame_bbox['max_row'], frame_bbox['max_col']\n\n    hole_pixels = set()\n    visited_hole = np.zeros((height, width), dtype=bool)\n    start_pixel = None\n\n    # Find a starting background pixel within the frame's bbox, skipping the border\n    for r in range(min_r_frame + 1, max_r_frame):\n        for c in range(min_c_frame + 1, max_c_frame):\n            if grid[r, c] == 0:\n                start_pixel = (r, c)\n                break\n        if start_pixel:\n            break\n\n    if start_pixel is None:\n        return None # No background pixel found inside\n\n    # BFS from the starting pixel to find all connected background pixels *within* the frame's bbox\n    q = deque([start_pixel])\n    visited_hole[start_pixel[0], start_pixel[1]] = True\n    min_r_hole, min_c_hole = start_pixel[0], start_pixel[1]\n    max_r_hole, max_c_hole = start_pixel[0], start_pixel[1]\n\n    while q:\n        r, c = q.popleft()\n        \n        # Check if pixel is truly inside (not touching outside boundary via background)\n        # If any neighbor is outside frame bbox and is background, this isn't a contained hole start point.\n        is_truly_inside = True\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 nr, nc = r + dr, c + dc\n                 if not (min_r_frame <= nr <= max_r_frame and min_c_frame <= nc <= max_c_frame):\n                      if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] == 0:\n                           # This search started from a pixel connected to the outside background. Reset and find another start.\n                           # This check should ideally be done before starting BFS, but is complex.\n                           # A simpler approach relies on task structure: the hole is fully contained.\n                           pass # Assuming valid task structure for now.\n\n        hole_pixels.add((r, c))\n        min_r_hole = min(min_r_hole, r)\n        min_c_hole = min(min_c_hole, c)\n        max_r_hole = max(max_r_hole, r)\n        max_c_hole = max(max_c_hole, c)\n\n        # Check 4 cardinal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Stay within frame bbox, look for background color, and ensure not visited\n            if min_r_frame < nr < max_r_frame and min_c_frame < nc < max_c_frame and \\\n               grid[nr, nc] == 0 and not visited_hole[nr, nc]:\n                visited_hole[nr, nc] = True\n                q.append((nr, nc))\n\n    if not hole_pixels:\n         return None\n\n    # Verify it's rectangular - check if all pixels within the derived bbox are in hole_pixels\n    # hole_height = max_r_hole - min_r_hole + 1\n    # hole_width = max_c_hole - min_c_hole + 1\n    # if len(hole_pixels) != hole_height * hole_width:\n        # Could implement stricter check if needed, but task examples suggest rectangular holes.\n        # pass\n\n    return {'min_row': min_r_hole, 'min_col': min_c_hole, 'max_row': max_r_hole, 'max_col': max_c_hole}\n\n\ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts the subgrid defined by the bounding box.\n\n    Args:\n        grid (np.ndarray): The source grid.\n        bbox (dict): Bounding box dictionary.\n\n    Returns:\n        np.ndarray: The extracted subgrid.\n    \"\"\"\n    return grid[bbox['min_row']:bbox['max_row']+1, bbox['min_col']:bbox['max_col']+1]\n\n\ndef paste_subgrid(target_grid, subgrid, top_left_coord, ignore_color=None):\n    \"\"\"\n    Pastes a subgrid onto a target grid at the specified top-left coordinate.\n    Optionally ignores pasting pixels of a specific color from the subgrid.\n\n    Args:\n        target_grid (np.ndarray): The grid to paste onto (modified in place).\n        subgrid (np.ndarray): The subgrid to paste.\n        top_left_coord (tuple): (row, col) for the top-left corner of the paste location.\n        ignore_color (int, optional): If specified, pixels of this color in the\n                                       subgrid will not be pasted. Defaults to None.\n    \"\"\"\n    start_row, start_col = top_left_coord\n    sub_height, sub_width = subgrid.shape\n    target_height, target_width = target_grid.shape\n\n    for r in range(sub_height):\n        for c in range(sub_width):\n            target_r, target_c = start_row + r, start_col + c\n            # Check bounds\n            if 0 <= target_r < target_height and 0 <= target_c < target_width:\n                pixel_to_paste = subgrid[r, c]\n                if ignore_color is None or pixel_to_paste != ignore_color:\n                    target_grid[target_r, target_c] = pixel_to_paste\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds a pattern and an azure frame with a hole,\n    then copies the pattern into the hole.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all distinct objects (connected components of non-zero colors)\n    objects = find_objects(input_grid, ignore_color=0)\n\n    frame_object = None\n    pattern_object = None\n    hole_bbox = None\n\n    # Identify the frame (color 8) and the pattern (other non-zero object)\n    for obj in objects:\n        # Check if the object consists *only* of color 8\n        is_azure_frame = all(input_grid[r, c] == 8 for r, c in obj['pixels'])\n        \n        if is_azure_frame:\n             # Attempt to find a hole within this potential frame's bounding box\n             potential_hole_bbox = find_hole(input_grid, obj['bbox'])\n             if potential_hole_bbox:\n                  # Found a valid azure frame with a hole\n                  frame_object = obj\n                  hole_bbox = potential_hole_bbox\n        else:\n             # Assume any other non-background object is the pattern\n             pattern_object = obj\n\n    # Check if we found both necessary components\n    if frame_object is None or pattern_object is None or hole_bbox is None:\n        # If components aren't found as expected, return the original grid\n        # or handle error appropriately based on task requirements for missing elements.\n        print(\"Warning: Could not find pattern, frame, or hole. Returning input.\")\n        return output_grid \n\n    # Extract the pattern subgrid based on its bounding box\n    pattern_subgrid = extract_subgrid(input_grid, pattern_object['bbox'])\n\n    # Determine the top-left coordinate where the pattern should be pasted (top-left of the hole)\n    paste_coord = (hole_bbox['min_row'], hole_bbox['min_col'])\n\n    # Paste the pattern subgrid into the output grid at the hole's location\n    # We ignore pasting the background color (0) from the pattern subgrid,\n    # effectively overlaying the non-background parts of the pattern onto the hole.\n    paste_subgrid(output_grid, pattern_subgrid, paste_coord, ignore_color=0)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3433,
    "candidates_token_count": 3023,
    "total_token_count": 6456,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.996876,
  "retries": null
}