{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies an azure (color 8) frame containing a rectangular background (color 0) hole.\nIdentifies a pattern area defined by the bounding box of all non-background, non-azure pixels.\nExtracts the subgrid corresponding to the pattern area (including background pixels within it).\nCopies the input grid to the output grid, then pastes the extracted pattern subgrid into the hole location in the output grid, overwriting existing pixels.\n\"\"\"\n\ndef find_azure_frame_and_hole(grid):\n    \"\"\"\n    Finds the azure frame pixels and the bounding box of the enclosed background hole.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (frame_bbox, hole_bbox) dictionaries, or (None, None) if not found.\n               Bounding boxes are {'min_row', 'min_col', 'max_row', 'max_col'}.\n    \"\"\"\n    height, width = grid.shape\n    # Find all pixels with the frame color (8)\n    azure_pixels = set((r, c) for r in range(height) for c in range(width) if grid[r, c] == 8)\n\n    if not azure_pixels:\n        # Return None if no frame pixels exist\n        return None, None \n\n    # Calculate the bounding box of the frame pixels\n    min_r_frame = min(r for r, c in azure_pixels)\n    max_r_frame = max(r for r, c in azure_pixels)\n    min_c_frame = min(c for r, c in azure_pixels)\n    max_c_frame = max(c for r, c in azure_pixels)\n    frame_bbox = {'min_row': min_r_frame, 'min_col': min_c_frame, 'max_row': max_r_frame, 'max_col': max_c_frame}\n\n    # Search for a rectangular hole (background color 0) within the frame's bounding box\n    hole_bbox = None\n    # Use a visited array to track pixels checked during hole search\n    visited_hole_search = np.zeros((height, width), dtype=bool)\n\n    # Iterate through pixels strictly inside the frame's bounding box\n    for r_start in range(min_r_frame + 1, max_r_frame):\n        for c_start in range(min_c_frame + 1, max_c_frame):\n            # If a background pixel is found that hasn't been visited yet\n            if grid[r_start, c_start] == 0 and not visited_hole_search[r_start, c_start]:\n                # Start Breadth-First Search (BFS) from this pixel to find connected background area\n                q = deque([(r_start, c_start)])\n                visited_hole_search[r_start, c_start] = True\n                current_hole_pixels = set([(r_start, c_start)])\n                # Track the bounds of this connected background area\n                min_r_hole, max_r_hole = r_start, r_start\n                min_c_hole, max_c_hole = c_start, c_start\n\n                while q:\n                    r, c = q.popleft()\n                    # Update the bounds\n                    min_r_hole = min(min_r_hole, r)\n                    max_r_hole = max(max_r_hole, r)\n                    min_c_hole = min(min_c_hole, c)\n                    max_c_hole = max(max_c_hole, c)\n\n                    # Check 4 cardinal neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        # Check if neighbor is strictly inside the frame, is background, and hasn't been visited\n                        if min_r_frame < nr < max_r_frame and \\\n                           min_c_frame < nc < max_c_frame and \\\n                           grid[nr, nc] == 0 and \\\n                           not visited_hole_search[nr, nc]:\n                            visited_hole_search[nr, nc] = True\n                            current_hole_pixels.add((nr, nc))\n                            q.append((nr, nc))\n\n                # After BFS, check if the found connected component forms a solid rectangle\n                hole_height = max_r_hole - min_r_hole + 1\n                hole_width = max_c_hole - min_c_hole + 1\n                is_rectangular = True\n                # Check if the number of pixels found matches the area of the bounding box\n                if len(current_hole_pixels) != hole_height * hole_width:\n                     is_rectangular = False\n                else:\n                    # Verify all pixels within the calculated bounding box are indeed background pixels found in this component\n                    for r_check in range(min_r_hole, max_r_hole + 1):\n                         for c_check in range(min_c_hole, max_c_hole + 1):\n                              if grid[r_check, c_check] != 0 or (r_check, c_check) not in current_hole_pixels:\n                                   is_rectangular = False\n                                   break\n                         if not is_rectangular:\n                              break\n                              \n                if is_rectangular:\n                    # If it is a solid rectangle, store its bounding box\n                    hole_bbox = {'min_row': min_r_hole, 'min_col': min_c_hole, 'max_row': max_r_hole, 'max_col': max_c_hole}\n                    # Assuming only one hole based on task examples, return immediately\n                    return frame_bbox, hole_bbox\n\n    # If the loops complete without finding a valid rectangular hole\n    return frame_bbox, None\n\n\ndef find_pattern_area(grid):\n    \"\"\"\n    Finds the minimal bounding box enclosing all pattern pixels (non-0, non-8).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        dict: Bounding box dictionary {'min_row', 'min_col', 'max_row', 'max_col'}\n              of the pattern area, or None if no pattern pixels are found.\n    \"\"\"\n    height, width = grid.shape\n    # Identify all pixels that are not background (0) and not frame color (8)\n    pattern_pixels = set((r, c) for r in range(height) for c in range(width) if grid[r, c] != 0 and grid[r, c] != 8)\n\n    if not pattern_pixels:\n        # Return None if no such pixels exist\n        return None \n\n    # Calculate the minimal bounding box containing all pattern pixels\n    min_r_pattern = min(r for r, c in pattern_pixels)\n    max_r_pattern = max(r for r, c in pattern_pixels)\n    min_c_pattern = min(c for r, c in pattern_pixels)\n    max_c_pattern = max(c for r, c in pattern_pixels)\n    pattern_bbox = {'min_row': min_r_pattern, 'min_col': min_c_pattern, 'max_row': max_r_pattern, 'max_col': max_c_pattern}\n\n    return pattern_bbox\n\n\ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts the subgrid defined by the bounding box. Includes all pixels within the box.\n\n    Args:\n        grid (np.ndarray): The source grid.\n        bbox (dict): Bounding box dictionary {'min_row', 'min_col', 'max_row', 'max_col'}.\n\n    Returns:\n        np.ndarray: The extracted subgrid. Returns None if bbox is None.\n    \"\"\"\n    if bbox is None:\n        return None\n    # Slice the grid using bounding box coordinates\n    return grid[bbox['min_row']:bbox['max_row']+1, bbox['min_col']:bbox['max_col']+1]\n\n\ndef paste_subgrid(target_grid, subgrid, top_left_coord):\n    \"\"\"\n    Pastes a subgrid onto a target grid at the specified top-left coordinate,\n    overwriting existing pixels. Handles boundary checks.\n\n    Args:\n        target_grid (np.ndarray): The grid to paste onto (modified in place).\n        subgrid (np.ndarray): The subgrid to paste.\n        top_left_coord (tuple): (row, col) for the top-left corner of the paste location.\n    \"\"\"\n    # Check for invalid inputs\n    if subgrid is None or top_left_coord is None:\n        print(\"Warning: Subgrid or paste coordinate is None. Skipping paste.\")\n        return\n\n    start_row, start_col = top_left_coord\n    sub_height, sub_width = subgrid.shape\n    target_height, target_width = target_grid.shape\n\n    # Iterate through each pixel in the subgrid\n    for r in range(sub_height):\n        for c in range(sub_width):\n            # Calculate the corresponding coordinates in the target grid\n            target_r, target_c = start_row + r, start_col + c\n            # Check if the target coordinates are within the bounds of the target grid\n            if 0 <= target_r < target_height and 0 <= target_c < target_width:\n                # Overwrite the target grid pixel with the subgrid pixel\n                target_grid[target_r, target_c] = subgrid[r, c]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds an azure frame with a hole,\n    finds the pattern area (bounding box of non-0, non-8 pixels),\n    extracts the pattern subgrid, and pastes it into the hole.\n    \"\"\"\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Step 1: Find the azure frame and the rectangular background hole inside it.\n    frame_bbox, hole_bbox = find_azure_frame_and_hole(input_grid)\n\n    # Step 2: Find the minimal bounding box containing all pattern pixels (non-0, non-8).\n    pattern_bbox = find_pattern_area(input_grid)\n\n    # Step 3: Check if the frame, hole, and pattern area were all successfully found.\n    if frame_bbox is None or hole_bbox is None or pattern_bbox is None:\n        # If any component is missing, return the original grid without modification.\n        # print(\"Warning: Could not find frame, hole, or pattern area. Returning input.\")\n        return output_grid\n\n    # Step 4: Extract the rectangular subgrid corresponding to the pattern area.\n    # This includes all pixels (including background) within the pattern's bounding box.\n    pattern_subgrid = extract_subgrid(input_grid, pattern_bbox)\n\n    # Step 5: Check if pattern subgrid was extracted (should be valid if pattern_bbox was found).\n    if pattern_subgrid is None:\n        #  print(\"Warning: Failed to extract pattern subgrid. Returning input.\")\n         return output_grid # Should not happen if pattern_bbox is not None\n         \n    # Step 6: Determine the top-left coordinate for pasting (the top-left corner of the hole).\n    paste_coord = (hole_bbox['min_row'], hole_bbox['min_col'])\n\n    # Step 7: Check if the dimensions of the pattern subgrid match the hole dimensions (as observed in examples).\n    hole_height = hole_bbox['max_row'] - hole_bbox['min_row'] + 1\n    hole_width = hole_bbox['max_col'] - hole_bbox['min_col'] + 1\n    pattern_height, pattern_width = pattern_subgrid.shape\n\n    # This check is based on observations from examples; if sizes don't match, the task might be different.\n    if pattern_height != hole_height or pattern_width != hole_width:\n        print(f\"Warning: Pattern subgrid ({pattern_height}x{pattern_width}) dimensions do not match hole ({hole_height}x{hole_width}). Behavior may be unexpected.\")\n        # Proceeding with paste anyway, aligned at top-left.\n\n    # Step 8: Paste the extracted pattern subgrid onto the output grid.\n    # The paste starts at the top-left corner of the hole.\n    # All pixels from pattern_subgrid (including background 0s) overwrite the hole area.\n    paste_subgrid(output_grid, pattern_subgrid, paste_coord)\n\n    # Step 9: Return the modified grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10295,
    "candidates_token_count": 2954,
    "total_token_count": 13249,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 48.529464,
  "retries": null
}