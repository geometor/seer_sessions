{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n# -*- coding: utf-8 -*-\n\"\"\"\nIdentifies pairs of objects where one object (container) fully encloses another (content) without touching. The containment is checked using a flood fill from the grid border: if the background reachable from the border cannot touch the content object, it is considered enclosed.\n\nThen, finds other objects (targets) in the grid that are identical in shape, size, and color to the content object but located outside the container.\n\nFor each unique target found (meaning a target object is only replaced once, even if it matches content from multiple container pairs), copies the corresponding container and content structure and pastes it onto the grid. The pasting is done such that the copied content perfectly aligns with and replaces the original target object, maintaining the relative spatial position of the container around the content.\n\nThe original container/content pairs remain untouched in the input. The output grid reflects the pasted copies. Objects are defined as contiguous regions of the same non-background color, using 8-way connectivity (including diagonals).\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid using 8-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int), 'coords' (set of (r, c) tuples),\n              and 'bbox' (tuple: min_r, min_c, max_r, max_c).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    if not (0 <= curr_r < height and 0 <= curr_c < width) or \\\n                       visited[curr_r, curr_c] or \\\n                       grid[curr_r, curr_c] != current_color:\n                        continue\n\n                    visited[curr_r, curr_c] = True\n                    coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Add neighbors (8-way connectivity)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            # Check bounds before adding to queue\n                            if 0 <= nr < height and 0 <= nc < width:\n                                q.append((nr, nc))\n\n                if coords:\n                    objects.append({\n                        'color': current_color,\n                        'coords': coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef get_relative_mask(obj):\n    \"\"\"\n    Calculates the relative coordinates (mask) of an object's pixels\n    with respect to its bounding box top-left corner.\n\n    Args:\n        obj (dict): An object dictionary from find_objects.\n\n    Returns:\n        dict: Contains 'mask' (set of (rel_r, rel_c) tuples) and\n              'size' (tuple: height, width).\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    mask = set()\n    for r, c in obj['coords']:\n        mask.add((r - min_r, c - min_c))\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return {'mask': mask, 'size': (height, width)}\n\ndef check_containment(container_obj, content_obj, grid):\n    \"\"\"\n    Checks if container_obj fully encloses content_obj using flood fill from border.\n    Requires that the content is not adjacent (8-way) to any background reachable\n    from the grid border, and also not adjacent to the border itself.\n\n    Args:\n        container_obj (dict): Potential container object.\n        content_obj (dict): Potential content object.\n        grid (np.array): The input grid.\n\n    Returns:\n        bool: True if containment is confirmed, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    content_bbox = content_obj['bbox']\n    container_bbox = container_obj['bbox']\n\n    # Basic checks: Bounding box inclusion and color difference.\n    if not (content_bbox[0] > container_bbox[0] and # Strict inequality implies no touching border\n            content_bbox[1] > container_bbox[1] and\n            content_bbox[2] < container_bbox[2] and\n            content_bbox[3] < container_bbox[3]):\n        return False\n    if container_obj['color'] == content_obj['color']:\n        return False\n    # Ensure no overlap between container and content coords\n    if content_obj['coords'].intersection(container_obj['coords']):\n        return False\n\n    # --- Flood fill from border to find reachable background ---\n    reachable_background = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Add border background cells to the queue\n    for r in range(height):\n        if grid[r, 0] == 0 and not reachable_background[r, 0]:\n            q.append((r, 0))\n            reachable_background[r, 0] = True\n        if grid[r, width - 1] == 0 and not reachable_background[r, width - 1]:\n            q.append((r, width - 1))\n            reachable_background[r, width - 1] = True\n    for c in range(1, width - 1): # Avoid double-adding corners\n        if grid[0, c] == 0 and not reachable_background[0, c]:\n            q.append((0, c))\n            reachable_background[0, c] = True\n        if grid[height - 1, c] == 0 and not reachable_background[height - 1, c]:\n            q.append((height - 1, c))\n            reachable_background[height - 1, c] = True\n\n    # BFS to find all background reachable from the border\n    while q:\n        r, c = q.popleft()\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                # Check if neighbor is within bounds, is background, and not yet visited\n                if 0 <= nr < height and 0 <= nc < width and \\\n                   not reachable_background[nr, nc] and \\\n                   grid[nr, nc] == 0:\n                    reachable_background[nr, nc] = True\n                    q.append((nr, nc))\n\n    # --- Check if content is adjacent to reachable background or grid border ---\n    for r_cont, c_cont in content_obj['coords']:\n        # Check 8 neighbors of each content pixel\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r_cont + dr, c_cont + dc\n\n                # Check if neighbor is out of bounds (adjacent to border)\n                if not (0 <= nr < height and 0 <= nc < width):\n                     return False # Content adjacent to grid border\n\n                # Check if neighbor is a background pixel reachable from the border\n                if reachable_background[nr, nc]:\n                     return False # Content adjacent to background reachable from border\n\n    # If no content pixel is adjacent to reachable background or the border, it's contained.\n    return True\n\n\ndef are_identical(obj1_mask, obj2_mask):\n    \"\"\"\n    Checks if two objects are identical based on their relative masks.\n\n    Args:\n        obj1_mask (dict): Relative mask dict for object 1.\n        obj2_mask (dict): Relative mask dict for object 2.\n\n    Returns:\n        bool: True if identical shape and size, False otherwise.\n    \"\"\"\n    # Check size first for quick exit\n    if obj1_mask['size'] != obj2_mask['size']:\n        return False\n    # Check the set of relative coordinates\n    return obj1_mask['mask'] == obj2_mask['mask']\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: identifies container/content/target triplets\n    and copies the container/content structure to replace the target.\n    Uses 8-way connectivity for object detection and containment checks.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all objects in the input grid using 8-way connectivity\n    objects = find_objects(input_grid)\n    if not objects:\n        return output_grid # Return copy if no objects found\n\n    # Pre-calculate relative masks for all objects\n    object_masks = {i: get_relative_mask(obj) for i, obj in enumerate(objects)}\n\n    # 2. Identify containment pairs (container, content)\n    containment_pairs = []\n    for i in range(len(objects)):\n        for j in range(len(objects)):\n            if i == j: continue # An object cannot contain itself\n            container_candidate = objects[i]\n            content_candidate = objects[j]\n            # Use the containment check function\n            if check_containment(container_candidate, content_candidate, input_grid):\n                containment_pairs.append({'container_idx': i, 'content_idx': j})\n\n    # 3. Identify triplets (container, content, target)\n    triplets = []\n    # Keep track of targets already assigned to a content type to avoid ambiguity\n    # Key: content_idx, Value: set of target_idx that match this content\n    found_targets_for_content = {}\n\n    for pair in containment_pairs:\n        container_idx = pair['container_idx']\n        content_idx = pair['content_idx']\n        content_obj = objects[content_idx]\n        content_mask = object_masks[content_idx]\n        container_bbox = objects[container_idx]['bbox'] # Bbox of the original container\n\n        # Initialize set for this content index if not present\n        if content_idx not in found_targets_for_content:\n             found_targets_for_content[content_idx] = set()\n\n        # Iterate through all objects to find potential targets\n        for k in range(len(objects)):\n            # Target cannot be the container or content of the current pair\n            if k == container_idx or k == content_idx: continue\n\n            target_candidate = objects[k]\n            target_bbox = target_candidate['bbox'] # Bbox of the potential target\n\n            # Check if target candidate has the same color and shape/size as the content\n            if target_candidate['color'] == content_obj['color']:\n                target_mask = object_masks[k]\n                if are_identical(content_mask, target_mask):\n                    # Check if target is outside the original container (using bbox check for simplicity)\n                    # Check for non-overlap: target ends before container starts OR target starts after container ends\n                    is_outside = (target_bbox[2] < container_bbox[0] or # Target above container\n                                  target_bbox[0] > container_bbox[2] or # Target below container\n                                  target_bbox[3] < container_bbox[1] or # Target left of container\n                                  target_bbox[1] > container_bbox[3])    # Target right of container\n\n                    if is_outside:\n                        # Check if this specific target object (k) has already been claimed\n                        # by *any* content object (across all pairs).\n                        is_new_target = True\n                        for c_idx, assigned_targets in found_targets_for_content.items():\n                            if k in assigned_targets:\n                                is_new_target = False\n                                break # Target k already assigned\n\n                        if is_new_target:\n                            # If it's a valid, outside, and unclaimed target, record the triplet\n                            triplets.append({\n                                'container_idx': container_idx,\n                                'content_idx': content_idx,\n                                'target_idx': k\n                            })\n                            # Mark this target (k) as assigned to this content type (content_idx)\n                            found_targets_for_content[content_idx].add(k)\n\n\n    # 4. Perform replacements based on identified triplets\n    # Keep track of targets that have been processed to ensure each is replaced only once\n    processed_targets = set()\n    for triplet in triplets:\n        target_idx = triplet['target_idx']\n        # Skip if this target has already been used for a replacement\n        if target_idx in processed_targets: continue\n        processed_targets.add(target_idx) # Mark target as processed\n\n        # Get the original container, content, and target objects\n        container = objects[triplet['container_idx']]\n        content = objects[triplet['content_idx']]\n        target = objects[triplet['target_idx']]\n\n        # Calculate the relative offset of the content's top-left corner\n        # within the container's bounding box.\n        cont_min_r, cont_min_c, _, _ = content['bbox']\n        cr_min_r, cr_min_c, _, _ = container['bbox']\n        offset_r = cont_min_r - cr_min_r\n        offset_c = cont_min_c - cr_min_c\n\n        # Determine the top-left corner where the *new container* should be pasted.\n        # This is based on the target's top-left corner minus the content's offset\n        # relative to its container. This ensures the copied content aligns with the target.\n        target_min_r, target_min_c, _, _ = target['bbox']\n        paste_cr_top_left_r = target_min_r - offset_r\n        paste_cr_top_left_c = target_min_c - offset_c\n\n        # --- Perform the pasting onto the output grid ---\n\n        # a) Paste the container pixels\n        container_color = container['color']\n        cr_mask = object_masks[triplet['container_idx']]['mask']\n        for rel_r, rel_c in cr_mask:\n            out_r = paste_cr_top_left_r + rel_r\n            out_c = paste_cr_top_left_c + rel_c\n            # Ensure pasted pixel is within grid bounds\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = container_color\n\n        # b) Paste the content pixels (overwriting container pixels if necessary)\n        content_color = content['color']\n        cont_mask = object_masks[triplet['content_idx']]['mask']\n        # Align content with the original target position\n        for rel_r, rel_c in cont_mask:\n            out_r = target_min_r + rel_r\n            out_c = target_min_c + rel_c\n            # Ensure pasted pixel is within grid bounds\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = content_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6946,
    "candidates_token_count": 3794,
    "total_token_count": 10740,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.733259,
  "retries": null
}