{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies pairs of objects where one object (container) encloses another (content).\nFinds other objects (targets) in the grid that are identical in shape and color to the content object but located outside the container.\nFor each target found, copies the corresponding container and content structure and pastes it onto the grid such that the copied content perfectly replaces the target object, maintaining the relative position of the container around the content.\nThe original container/content pairs remain untouched.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int), 'coords' (set of (r, c) tuples),\n              and 'bbox' (tuple: min_r, min_c, max_r, max_c).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    if not (0 <= curr_r < height and 0 <= curr_c < width) or \\\n                       visited[curr_r, curr_c] or \\\n                       grid[curr_r, curr_c] != current_color:\n                        continue\n\n                    visited[curr_r, curr_c] = True\n                    coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Add neighbors (4-way sufficient for connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        q.append((nr, nc))\n\n                if coords:\n                    objects.append({\n                        'color': current_color,\n                        'coords': coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef get_relative_mask(obj):\n    \"\"\"\n    Calculates the relative coordinates (mask) of an object's pixels\n    with respect to its bounding box top-left corner.\n\n    Args:\n        obj (dict): An object dictionary from find_objects.\n\n    Returns:\n        dict: Contains 'mask' (set of (rel_r, rel_c) tuples) and\n              'size' (tuple: height, width).\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    mask = set()\n    for r, c in obj['coords']:\n        mask.add((r - min_r, c - min_c))\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return {'mask': mask, 'size': (height, width)}\n\ndef check_containment(container_obj, content_obj, grid):\n    \"\"\"\n    Checks if container_obj fully encloses content_obj using flood fill.\n\n    Args:\n        container_obj (dict): Potential container object.\n        content_obj (dict): Potential content object.\n        grid (np.array): The input grid.\n\n    Returns:\n        bool: True if containment is confirmed, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    content_bbox = content_obj['bbox']\n    container_bbox = container_obj['bbox']\n\n    # Basic checks\n    if not (content_bbox[0] >= container_bbox[0] and\n            content_bbox[1] >= container_bbox[1] and\n            content_bbox[2] <= container_bbox[2] and\n            content_bbox[3] <= container_bbox[3]):\n        return False # Bbox not inside\n    if container_obj['color'] == content_obj['color']:\n        return False # Must be different colors\n    if content_obj['coords'].intersection(container_obj['coords']):\n         return False # Cannot overlap\n\n\n    # Flood fill background from border\n    reachable_background = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Add border background cells\n    for r in range(height):\n        for c in [0, width - 1]:\n             if grid[r, c] == 0 and not reachable_background[r, c]:\n                q.append((r, c))\n                reachable_background[r, c] = True\n    for c in range(width): # Use range(width) instead of range(1, width-1) to catch all border pixels\n         for r in [0, height - 1]:\n             if grid[r, c] == 0 and not reachable_background[r, c]:\n                 q.append((r, c))\n                 reachable_background[r, c] = True\n\n\n    # BFS for reachable background\n    while q:\n        r, c = q.popleft()\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                if 0 <= nr < height and 0 <= nc < width and \\\n                   not reachable_background[nr, nc] and \\\n                   grid[nr, nc] == 0: # Only spread through background\n                    reachable_background[nr, nc] = True\n                    q.append((nr, nc))\n\n    # Check if any content pixel is adjacent to reachable background or border\n    for r, c in content_obj['coords']:\n        # Check 8 neighbors\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                if not (0 <= nr < height and 0 <= nc < width):\n                     return False # Content adjacent to grid border\n                if reachable_background[nr, nc]:\n                     return False # Content adjacent to background reachable from border\n\n    # If no such adjacency found, it's contained\n    return True\n\n\ndef are_identical(obj1_mask, obj2_mask):\n    \"\"\"\n    Checks if two objects are identical based on their relative masks.\n\n    Args:\n        obj1_mask (dict): Relative mask dict for object 1.\n        obj2_mask (dict): Relative mask dict for object 2.\n\n    Returns:\n        bool: True if identical shape and size, False otherwise.\n    \"\"\"\n    return obj1_mask['size'] == obj2_mask['size'] and \\\n           obj1_mask['mask'] == obj2_mask['mask']\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: identifies container/content/target triplets\n    and copies the container/content structure to replace the target.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    objects = find_objects(input_grid)\n\n    if not objects:\n        return output_grid\n\n    object_masks = {i: get_relative_mask(obj) for i, obj in enumerate(objects)}\n\n    # 1. Identify containment pairs (container, content)\n    containment_pairs = []\n    for i in range(len(objects)):\n        for j in range(len(objects)):\n            if i == j: continue\n            container_candidate = objects[i]\n            content_candidate = objects[j]\n            if check_containment(container_candidate, content_candidate, input_grid):\n                containment_pairs.append({'container_idx': i, 'content_idx': j})\n\n    # 2. Identify triplets (container, content, target)\n    triplets = []\n    found_targets_for_content = {} # key: content_idx, value: set of target_idx\n\n    for pair in containment_pairs:\n        container_idx = pair['container_idx']\n        content_idx = pair['content_idx']\n        content_obj = objects[content_idx]\n        content_mask = object_masks[content_idx]\n        container_bbox = objects[container_idx]['bbox']\n\n        if content_idx not in found_targets_for_content:\n             found_targets_for_content[content_idx] = set()\n\n        for k in range(len(objects)):\n            if k == container_idx or k == content_idx: continue\n\n            target_candidate = objects[k]\n            target_bbox = target_candidate['bbox']\n\n            # Check if target is identical to content\n            if target_candidate['color'] == content_obj['color']:\n                target_mask = object_masks[k]\n                if are_identical(content_mask, target_mask):\n                    # Check if target is outside the container (non-overlapping bounding box)\n                    overlap = not (target_bbox[2] < container_bbox[0] or\n                                   target_bbox[0] > container_bbox[2] or\n                                   target_bbox[3] < container_bbox[1] or\n                                   target_bbox[1] > container_bbox[3])\n\n                    if not overlap:\n                        # Ensure this target hasn't been assigned to this content type via another container\n                        is_new_target = True\n                        for c_idx, assigned_targets in found_targets_for_content.items():\n                            if k in assigned_targets:\n                                is_new_target = False\n                                break\n                        \n                        if is_new_target:\n                            triplets.append({\n                                'container_idx': container_idx,\n                                'content_idx': content_idx,\n                                'target_idx': k\n                            })\n                            found_targets_for_content[content_idx].add(k)\n\n\n    # 3. Perform replacements\n    processed_targets = set()\n    for triplet in triplets:\n        target_idx = triplet['target_idx']\n        if target_idx in processed_targets: continue # Ensure each target is replaced only once\n        processed_targets.add(target_idx)\n\n        container = objects[triplet['container_idx']]\n        content = objects[triplet['content_idx']]\n        target = objects[triplet['target_idx']]\n\n        # Calculate offset of content within container\n        cont_min_r, cont_min_c, _, _ = content['bbox']\n        cr_min_r, cr_min_c, _, _ = container['bbox']\n        offset_r = cont_min_r - cr_min_r\n        offset_c = cont_min_c - cr_min_c\n\n        # Calculate target paste location for the *container's* top-left corner\n        target_min_r, target_min_c, _, _ = target['bbox']\n        paste_cr_top_left_r = target_min_r - offset_r\n        paste_cr_top_left_c = target_min_c - offset_c\n\n        # Clear the area where the new structure will be pasted?\n        # No, the examples show overwriting. Example 1 overwrites background.\n\n        # Paste container pixels relative to the new container top-left\n        container_color = container['color']\n        for r, c in container['coords']:\n            rel_r = r - cr_min_r\n            rel_c = c - cr_min_c\n            out_r = paste_cr_top_left_r + rel_r\n            out_c = paste_cr_top_left_c + rel_c\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = container_color\n\n        # Paste content pixels relative to the *target's* top-left (to ensure alignment)\n        content_color = content['color']\n        for r, c in content['coords']:\n            rel_r = r - cont_min_r\n            rel_c = c - cont_min_c\n            out_r = target_min_r + rel_r # Align content with original target position\n            out_c = target_min_c + rel_c\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = content_color # Overwrites container pixels if needed\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3653,
    "candidates_token_count": 3064,
    "total_token_count": 6717,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 133.135913,
  "retries": null
}