{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Find Rectangles:** Locate all maroon (9) colored rectangles within the input grid.\n2.  **Top-Left Outline:** Create a 1-pixel thick green (3) outline around the rectangle whose top-left corner is closest to the top-left corner of the grid.\n3.  **Right Rectangle Complex Outline:** Create a 1-pixel green outline only on the top, and create a 3-pixel green outline only on the right of the rectangle. Prioritize the rectangle furthest to the right.\n4.  **Largest Rectangle Gapped Outline:** Identify the largest maroon rectangle (by area). Create a 1-pixel thick blue (1) outline around it, maintaining a 1-pixel gap between the outline and the rectangle.\n5.  **Conditional Flood Fill:** Starting from the top-left corner (0, 0) of the grid, flood fill the white (0) regions with green (3). Stop the flood fill when encountering any pixel that is blue (1), green (3), or maroon (9).\n\"\"\"\n\nimport numpy as np\n\ndef find_rectangles(grid, color):\n    rectangles = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                width = 0\n                height = 0\n                # Find width\n                for i in range(c, cols):\n                    if grid[r, i] == color:\n                        width += 1\n                        visited[r, i] = True\n                    else:\n                        break\n                # Find height\n                for j in range(r + 1, rows):\n                    if all(grid[j, c:c+width] == color):\n                        for i in range(c, c + width):\n                            visited[j, i] = True\n                        height += 1\n                    else:\n                        break\n                rectangles.append((r, c, width, height + 1))\n    return rectangles\n\ndef outline_top_left_rectangle(grid, rectangles, color):\n    if not rectangles:\n        return\n    top_left_rectangle = min(rectangles, key=lambda x: (x[0], x[1]))\n    r, c, width, height = top_left_rectangle\n    # Top\n    for i in range(c, c + width):\n        if r - 1 >= 0:\n            grid[r-1, i] = color\n    # Bottom\n    for i in range(c, c + width):\n        if r + height < grid.shape[0]:\n            grid[r + height, i] = color\n    # Left\n    for i in range(r, r + height):\n        if c - 1 >= 0:\n            grid[i, c - 1] = color\n    # Right\n    for i in range(r, r + height):\n      if c + width < grid.shape[1]:\n        grid[i, c + width] = color\n\ndef outline_right_rectangle_complex(grid, rectangles, color_top, thickness_top, color_right, thickness_right):\n    if not rectangles:\n        return\n    right_rectangle = max(rectangles, key=lambda x: x[1])\n    r, c, width, height = right_rectangle\n\n    # Top outline\n    for i in range(c, c + width):\n        for t in range(thickness_top):\n            if r - 1 - t >= 0:\n                grid[r - 1 - t, i] = color_top\n\n    # Right outline\n    for i in range(r, r + height):\n        for t in range(thickness_right):\n            if c + width + t < grid.shape[1]:\n                grid[i, c + width + t] = color_right\n\n\ndef outline_largest_rectangle_gapped(grid, rectangles, color, gap):\n    if not rectangles:\n      return\n    largest_rectangle = max(rectangles, key=lambda x: x[2] * x[3])\n    r, c, width, height = largest_rectangle\n\n    # Iterate over the potential outline area with the gap\n    for i in range(r - gap - 1, r + height + gap + 1):\n        for j in range(c - gap - 1, c + width + gap + 1):\n            # Check bounds\n            if 0 <= i < grid.shape[0] and 0 <= j < grid.shape[1]:\n                # Check if it's on the outline perimeter\n                if (i == r - gap - 1 or i == r + height + gap or\n                    j == c - gap - 1 or j == c + width + gap):\n                    # Ensure it's not inside the rectangle and not immediately adjacent\n                    if not (r <= i < r + height and c <= j < c + width):\n\n                        grid[i,j] = color\n\n\n\ndef conditional_flood_fill(grid, r, c, target_color, replacement_color, boundary_colors):\n    if r < 0 or r >= grid.shape[0] or c < 0 or c >= grid.shape[1] or grid[r, c] != target_color or grid[r,c] in boundary_colors:\n        return\n    grid[r, c] = replacement_color\n    conditional_flood_fill(grid, r + 1, c, target_color, replacement_color, boundary_colors)\n    conditional_flood_fill(grid, r - 1, c, target_color, replacement_color, boundary_colors)\n    conditional_flood_fill(grid, r, c + 1, target_color, replacement_color, boundary_colors)\n    conditional_flood_fill(grid, r, c - 1, target_color, replacement_color, boundary_colors)\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n\n    # Find Rectangles\n    rectangles = find_rectangles(output_grid, 9)\n\n    # Top-Left Outline\n    outline_top_left_rectangle(output_grid, rectangles, 3)\n\n    # Right Rectangle Complex Outline\n    outline_right_rectangle_complex(output_grid, rectangles, 3, 1, 3, 3)\n\n    # Largest Rectangle Gapped Outline\n    outline_largest_rectangle_gapped(output_grid, rectangles, 1, 1)\n\n    # Conditional Flood Fill\n    conditional_flood_fill(output_grid, 0, 0, 0, 3, [1, 3, 9])\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11302,
    "candidates_token_count": 1549,
    "total_token_count": 12851,
    "cached_content_token_count": 0
  },
  "response_time": 13.238266,
  "response_file": "018-response.json"
}