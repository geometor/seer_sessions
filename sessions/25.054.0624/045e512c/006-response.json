{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all distinct objects in the input grid. An object\n    is a contiguous block of pixels of the same color.\n2.  **Azure Rectangle:** Azure rectangles remain unchanged.\n3.  **Green Pixel:** Each green pixel is replicated horizontally to the right\n    edge of the grid. The replication alternates between a green pixel and a\n    blank space (color 0). The green pixel comes first.\n4.  **Red Rectangle:** Each red rectangle is replicated vertically downwards. The\n    replication alternates between a full rectangle and a hollow version. The\n    hollow version has the same bounding box, but the center pixels are set to\n    color 0 (blank). The full rectangle comes first.\n5.  **Yellow and Blue Pixels and Rectangles:**\n   - find the bounding box that contains all yellow and blue objects.\n   - replicate yellow and blue, alternating, in a complex diagonal shape until the bounding box is filled.\n   - if a blue rectangle exists, replicate it vertically downward, inserting an empty row between.\n6.  **Magenta Shapes:** Replicate diagonally.\n7. **Gray Shapes:** Gray objects remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all distinct objects in the grid.\n    Returns a dictionary of objects keyed by color,\n    where each object is a list of (row, col) coordinates.\n    \"\"\"\n    objects = {}\n    visited = set()\n    rows, cols = grid.shape\n\n    def bfs(start_row, start_col, color):\n        obj = []\n        queue = deque([(start_row, start_col)])\n        visited.add((start_row, start_col))\n\n        while queue:\n            row, col = queue.popleft()\n            obj.append((row, col))\n\n            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < rows and 0 <= new_col < cols and \\\n                   grid[new_row, new_col] == color and (new_row, new_col) not in visited:\n                    queue.append((new_row, new_col))\n                    visited.add((new_row, new_col))\n        return obj\n\n    for row in range(rows):\n        for col in range(cols):\n            color = grid[row, col]\n            if color != 0 and (row, col) not in visited:\n                obj = bfs(row, col, color)\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(obj)\n    return objects\n\ndef get_object_bounds(obj):\n  rows = [r for r, c in obj]\n  cols = [c for r, c in obj]\n  return min(rows), min(cols), max(rows), max(cols)\n\ndef replicate_green_horizontal_alternate(grid, green_objects):\n    output_grid = np.copy(grid)\n    for obj in green_objects:\n      #since it is a pixel, use the first\n      r, c = obj[0]\n      current_col = c + 1\n\n      while current_col < output_grid.shape[1]:\n        output_grid[r,current_col] = 3\n        current_col += 1\n        if current_col < output_grid.shape[1]:\n          output_grid[r,current_col] = 0\n          current_col += 1\n\n    return output_grid\n\ndef replicate_red_vertical_alternate_hollow(grid, red_objects):\n    output_grid = np.copy(grid)\n    for obj in red_objects:\n        min_row, min_col, max_row, max_col = get_object_bounds(obj)\n        height = max_row - min_row + 1\n        width = max_col - min_col + 1\n        row_cursor = max_row + 1\n\n        while row_cursor + height <= output_grid.shape[0]:\n            # Full rectangle\n            for r in range(min_row, min_row + height):\n                for c in range(min_col, min_col + width):\n                    output_grid[row_cursor + (r - min_row), c] = 2\n\n            row_cursor += height\n            if row_cursor + height > output_grid.shape[0]:\n                break\n\n            # Hollow rectangle\n            for r in range(min_row, min_row + height):\n                for c in range(min_col, min_col + width):\n                    curr_r = row_cursor + (r-min_row)\n                    curr_c = c\n                    if (height > 2 and width > 2 and  # Make sure it has center to remove\n                        r > min_row and r < max_row and\n                        c > min_col and c < max_col):\n                      output_grid[curr_r,curr_c] = 0\n\n                    else:\n                        output_grid[curr_r, curr_c] = 2\n\n\n            row_cursor += height\n    return output_grid\n\ndef replicate_blue_rectangle_vertical(grid, blue_objects):\n    output_grid = np.copy(grid)\n\n    for obj in blue_objects:\n      #check if it's rectangle\n      min_row, min_col, max_row, max_col = get_object_bounds(obj)\n      if len(obj) == (max_row - min_row + 1) * (max_col - min_col + 1):\n\n        row_cursor = max_row + 2\n\n        while row_cursor + (max_row - min_row)  < output_grid.shape[0]:\n          for r,c in obj:\n            output_grid[r + row_cursor - min_row, c] = 1\n\n          row_cursor += (max_row - min_row) + 2\n\n\n    return output_grid\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    objects = find_objects(input_grid)\n\n    # Azure Rectangle - do nothing\n    # Green Pixel\n    if 3 in objects:\n        output_grid = replicate_green_horizontal_alternate(output_grid, objects[3])\n    # Red Rectangle\n    if 2 in objects:\n        output_grid = replicate_red_vertical_alternate_hollow(output_grid, objects[2])\n    # Yellow and Blue\n\n    # Blue Rectangle\n    if 1 in objects:\n      output_grid = replicate_blue_rectangle_vertical(output_grid, objects[1])\n    # Magenta\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11726,
    "candidates_token_count": 1584,
    "total_token_count": 13310,
    "cached_content_token_count": 0
  },
  "response_time": 13.299931,
  "response_file": "006-response.json"
}