{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by expanding colored shapes based on their adjacency to other shapes.\n\n1.  **Object Identification:** Identify all contiguous regions (objects) of non-yellow pixels. Each object is characterized by its color (1, 2, 3, 6, or 8). Adjacency is defined as 8-connectivity (including diagonals).\n\n2.  **Blue (1) Expansion:**\n    *   If a blue object is adjacent to any object of a *different* color, then extend blue color into all yellow cells immediately adjacent to *any* blue cells in the object.\n    *    If blue is not adjacent to any objects of a different color - do not change anything.\n\n3.  **Red (2) Expansion:**\n    *   If a red object is adjacent to another object of a *different* color. Extend red by a single layer into yellow around adjacent objects, excluding other red objects.\n\n4.  **Magenta (6) Expansion:**\n    *   If a magenta object is adjacent to a yellow cell, fill the yellow cell with the magenta color.\n\n5. **Green(3) and Azure(8):** These colors do not expand.\n\n6.  **Yellow (4):** Remains unchanged unless filled by an expanding object (blue, red, or magenta).\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Finds all contiguous regions of non-yellow pixels, identifying them as distinct objects.\n    \"\"\"\n    objects = {}\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_id):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or visited[r, c] or grid[r, c] != color):\n            return\n        visited[r, c] = True\n        objects[obj_id]['pixels'].append((r, c))\n        dfs(r + 1, c, color, obj_id)\n        dfs(r - 1, c, color, obj_id)\n        dfs(r, c + 1, color, obj_id)\n        dfs(r, c - 1, color, obj_id)\n        dfs(r + 1, c + 1, color, obj_id)\n        dfs(r - 1, c - 1, color, obj_id)\n        dfs(r + 1, c - 1, color, obj_id)\n        dfs(r - 1, c + 1, color, obj_id)\n\n\n    obj_id_counter = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 4 and not visited[r, c]:\n                objects[obj_id_counter] = {'color': grid[r, c], 'pixels': []}\n                dfs(r, c, grid[r, c], obj_id_counter)\n                obj_id_counter += 1\n    return objects\n\ndef get_neighbors(grid, r, c):\n    \"\"\"Returns a list of (row, col) tuples for all 8 neighbors of a pixel.\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef expand_blue(grid, output_grid, objects):\n    \"\"\"Expands blue shapes based on adjacency to different colored shapes.\"\"\"\n    for obj_id, obj_data in objects.items():\n        if obj_data['color'] == 1:  # Blue object\n            adjacent_to_other_color = False\n            for r, c in obj_data['pixels']:\n                neighbors = get_neighbors(grid, r, c)\n                for nr, nc in neighbors:\n                    if grid[nr, nc] != 1 and grid[nr,nc] != 4:\n                        adjacent_to_other_color = True\n                        break\n                if adjacent_to_other_color:\n                    break\n\n            if adjacent_to_other_color:\n                for r, c in obj_data['pixels']:\n                    neighbors = get_neighbors(grid, r,c)\n                    for nr, nc in neighbors:\n                        if output_grid[nr,nc] == 4:\n                            output_grid[nr,nc] = 1\n\n\ndef expand_red(grid, output_grid, objects):\n    \"\"\"Expands red shapes to create a perimeter around adjacent objects.\"\"\"\n    for obj_id, obj_data in objects.items():\n        if obj_data['color'] == 2:\n            new_red_pixels = []\n            for r, c in obj_data['pixels']:\n                neighbors = get_neighbors(grid, r, c)\n\n                for nr, nc in neighbors:\n                    if grid[nr,nc] != 2 and grid[nr,nc] != 4: #neighbor is a different object\n                        target_object = None\n                        for other_obj_id, other_obj_data in objects.items():\n                            if (nr,nc) in other_obj_data['pixels']:\n                                target_object = other_obj_data\n                                break\n\n                        if target_object:\n                            target_neighbors = get_neighbors(grid, nr, nc)\n                            for tnr, tnc in target_neighbors:\n                                if grid[tnr, tnc] == 4:\n                                    new_red_pixels.append((tnr,tnc))\n            for r,c in new_red_pixels:\n                output_grid[r,c] = 2\n\n\ndef expand_magenta(grid, output_grid, objects):\n    \"\"\"Expands magenta shapes by filling immediately adjacent yellow cells.\"\"\"\n    for obj_id, obj_data in objects.items():\n        if obj_data['color'] == 6:  # Magenta object\n            for r, c in obj_data['pixels']:\n                neighbors = get_neighbors(grid, r, c)\n                for nr, nc in neighbors:\n                    if grid[nr, nc] == 4:  # Adjacent to yellow\n                        output_grid[nr, nc] = 6\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    objects = get_objects(input_grid)\n\n    # change output pixels\n    expand_blue(input_grid, output_grid, objects)\n    expand_red(input_grid, output_grid, objects)\n    expand_magenta(input_grid, output_grid, objects)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11485,
    "candidates_token_count": 1566,
    "total_token_count": 13051,
    "cached_content_token_count": 0
  },
  "response_time": 13.503545,
  "response_file": "010-response.json"
}