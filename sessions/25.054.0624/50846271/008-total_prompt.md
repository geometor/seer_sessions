# 50846271 • 008 • example_2 • investigate_coder

---

## Example 2

**input:**
```
0 5 0 5 0 0 0 5 5 0 5 5 0 0 0 5 5 0 5 5
5 5 0 5 5 5 0 5 5 0 5 0 0 5 0 0 0 5 5 0
0 5 0 5 5 0 5 5 0 5 0 0 5 0 0 5 0 0 5 5
5 0 0 5 5 0 2 5 0 5 0 5 0 0 0 5 5 5 5 5
0 5 0 5 2 5 2 2 2 0 5 5 0 5 0 5 5 0 0 0
5 5 0 0 5 5 2 5 5 5 0 5 0 0 5 5 0 0 0 0
0 0 5 5 0 0 5 5 0 0 5 5 0 0 5 0 0 5 0 5
0 0 0 5 0 5 0 5 5 5 0 5 5 5 0 0 5 5 0 5
5 0 0 0 5 0 0 5 5 5 5 0 5 5 5 0 0 5 0 5
5 0 0 5 0 5 5 5 0 5 5 0 5 0 5 5 5 5 5 5
5 0 5 5 0 5 5 5 5 5 0 5 2 5 2 2 2 0 0 5
0 0 5 0 0 0 0 0 0 5 5 5 0 0 5 0 0 5 0 5
0 0 5 0 0 5 0 5 5 0 5 5 5 5 5 5 5 5 5 0
5 5 0 0 5 5 0 5 0 0 5 5 5 0 0 0 0 0 0 0
5 5 0 0 0 5 5 5 0 5 5 0 5 5 5 5 0 0 5 5
0 0 5 0 5 5 5 2 2 5 5 0 0 5 0 0 5 5 0 0
0 5 5 0 0 5 5 2 5 0 5 5 0 0 5 0 5 5 0 0
0 0 5 0 5 0 5 5 0 5 5 5 0 0 5 0 0 0 5 0
0 0 5 0 5 5 0 5 5 5 0 5 5 5 0 5 0 0 5 5
5 5 5 0 5 0 5 0 5 5 0 0 5 5 0 0 0 0 0 5
```

<PIL.Image.Image image mode=RGB size=1280x1280 at 0x70FFF4DABBB0>

**output:**
```
0 5 0 5 0 0 0 5 5 0 5 5 0 0 0 5 5 0 5 5
5 5 0 5 5 5 0 5 5 0 5 0 0 5 0 0 0 5 5 0
0 5 0 5 5 0 8 5 0 5 0 0 5 0 0 5 0 0 5 5
5 0 0 5 5 0 2 5 0 5 0 5 0 0 0 5 5 5 5 5
0 5 0 5 2 8 2 2 2 0 5 5 0 5 0 5 5 0 0 0
5 5 0 0 5 5 2 5 5 5 0 5 0 0 5 5 0 0 0 0
0 0 5 5 0 0 8 5 0 0 5 5 0 0 5 0 0 5 0 5
0 0 0 5 0 5 0 5 5 5 0 5 5 5 0 0 5 5 0 5
5 0 0 0 5 0 0 5 5 5 5 0 5 5 8 0 0 5 0 5
5 0 0 5 0 5 5 5 0 5 5 0 5 0 8 5 5 5 5 5
5 0 5 5 0 5 5 5 5 5 0 5 2 8 2 2 2 0 0 5
0 0 5 0 0 0 0 0 0 5 5 5 0 0 8 0 0 5 0 5
0 0 5 0 0 5 0 5 5 0 5 5 5 5 8 5 5 5 5 0
5 5 0 0 5 5 0 8 0 0 5 5 5 0 0 0 0 0 0 0
5 5 0 0 0 5 5 8 0 5 5 0 5 5 5 5 0 0 5 5
0 0 5 0 5 8 8 2 2 8 5 0 0 5 0 0 5 5 0 0
0 5 5 0 0 5 5 2 5 0 5 5 0 0 5 0 5 5 0 0
0 0 5 0 5 0 5 8 0 5 5 5 0 0 5 0 0 0 5 0
0 0 5 0 5 5 0 5 5 5 0 5 5 5 0 5 0 0 5 5
5 5 5 0 5 0 5 0 5 5 0 0 5 5 0 0 0 0 0 5
```

<PIL.Image.Image image mode=RGB size=1280x1280 at 0x70FFF0F76350>
Okay, here's my analysis of the provided example, focusing on elements, facts, and a natural language program describing the transformation.

**Perception of Elements:**

The task involves a grid of pixels, each with a numerical value representing a color. The primary colors observed are gray (5), white (0), red (2), and azure (8). The input and output grids are identical except for the introduction of azure pixels. The azure pixels appear to be related to the pre-existing red pixels.

**YAML Block (Facts):**


```yaml
objects:
  - type: grid
    properties:
      dimensions: 20x20
      cells: pixels
      colors: [white, gray, red, azure]
  - type: pixel
    properties:
      color:
        white: 0
        gray: 5
        red: 2
        azure: 8
      location: [row, column]
  - type: object
    properties:
       color: gray, red
       shape: not defined, but probably contiguous regions.

actions:
  - type: change_color
    properties:
      original_color: gray
      new_color: azure
      location: Based on proximity to red objects

relationships:
  - type: proximity
    description: Azure pixels appear near red pixels.
    details: Appears to replace some gray pixels that are cardinally adjacent (not diagonally) to red pixels.
```


**Natural Language Program:**

1.  **Identify Red Objects:** Locate all red (value 2) pixels within the input grid. Consider contiguous regions of red pixels as single objects.

2.  **Identify Target Gray Pixels:** Find gray (value 5) pixels that are cardinally adjacent (up, down, left, or right, *not* diagonally) to any red pixel.

3.  **Conditional Color Change:** For each *gray* pixel from those found in step two, check the input grid. IF the *gray* pixel found in step 2 is gray, change it to azure (8) in the output grid.

4. **Preserve Other Pixels:** All other pixels in the input grid retain their original color in the output grid. In other words. If it is not a gray pixel next to a red pixel, as defined above, copy its value to the same coordinates in the output grid.

**INSTRUCTIONS**

- generate a Python module to represent the natural language program 
- follow the template below
- all common math and science libraries are available
- create docstring only at top - but comment the workflow in the function
- use helper functions for common operations like finding objects, counting,
  measuring, moving, etc. 

remember - we are working iteratively - so this code will inform your future
self as we converge on the solution

*template:*

```python
"""
{{ natural language description of the transformation rule }}
"""

{{ imports }}

def transform(input_grid):
    # initialize output_grid

    # change output pixels 

    return output_grid

```
