{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all contiguous regions (objects) of the same color in the input grid.\n\n2.  **Object Interaction - Yellow and Blue:**\n    * If a yellow object is directly adjacent (up, down, left, or right, but *not* diagonally) to any pixel of a blue object, change all pixels in the *entire* yellow object to blue in the output grid.\n    * If there is a blue region and a yellow region is directly to the left of the blue region, generate new blue pixels that extend to the left of the blue, and aligned with the rows of the yellow object. The existing yellow pixels are removed.\n    * If there is a blue region and a yellow region is directly above the blue region, generate new blue pixels that extend above of the blue, aligned with the columns of the yellow object. The existing yellow pixels are removed.\n\n3.  **Preserve Existing Blue:** Existing blue objects remain blue, and the new adjacent regions.\n\n4. **Other Colors:** If a pixel is not adjacent to a blue object, then it stays as its original color.\n\n5.  **Background:** All pixels that are not affected by an interaction rule will become or remain background/black (0).\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Finds contiguous regions of the same color.\"\"\"\n    objects = {}\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, current_object):\n        if (r, c) in visited or not (0 <= r < rows and 0 <= c < cols) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        current_object.append((r, c))\n        dfs(r + 1, c, color, current_object)\n        dfs(r - 1, c, color, current_object)\n        dfs(r, c + 1, color, current_object)\n        dfs(r, c - 1, color, current_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if (r, c) not in visited:\n                current_object = []\n                dfs(r, c, color, current_object)\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(current_object)\n    return objects\n\ndef is_adjacent(object1, object2):\n    \"\"\"Checks if two objects are directly adjacent (not diagonally).\"\"\"\n    for r1, c1 in object1:\n        for r2, c2 in object2:\n            if (abs(r1 - r2) == 1 and c1 == c2) or (abs(c1 - c2) == 1 and r1 == r2):\n                return True\n    return False\n\ndef transform(input_grid):\n    # initialize output_grid as a copy of input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # Find all objects\n    objects = find_objects(input_grid)\n\n    # Handle Yellow and Blue interactions\n    if 1 in objects and 4 in objects:  # If both blue and yellow exist\n        blue_objects = objects[1]\n        yellow_objects = objects[4]\n\n        for yellow_obj in yellow_objects:\n            adjacent_to_blue = False\n            for blue_obj in blue_objects:\n                if is_adjacent(yellow_obj, blue_obj):\n                    # Change all yellow pixels in the object to blue\n                    for r, c in yellow_obj:\n                        output_grid[r, c] = 1\n                    adjacent_to_blue = True\n                    break  # Move to the next yellow object\n\n            if not adjacent_to_blue:\n                #check for expansion cases\n                for blue_obj in blue_objects:\n                    #check left expansion\n                    leftmost_yellow_col = min(c for r,c in yellow_obj)\n                    rightmost_blue_col = max(c for r, c in blue_obj)\n\n                    if rightmost_blue_col + 1 == leftmost_yellow_col:\n                        #rows match\n                        yellow_rows = set(r for r,c in yellow_obj)\n                        blue_rows = set(r for r,c in blue_obj)\n                        \n                        \n                        if yellow_rows.issubset(blue_rows):\n                          #expansion\n                          for r,c in yellow_obj:\n                              output_grid[r,c] = 0 #remove existing\n                          for r in yellow_rows:\n                              if r >= 0 and r < rows and rightmost_blue_col >= 0 and rightmost_blue_col < cols:\n                                output_grid[r,rightmost_blue_col] = 1\n\n                    #check above expansion\n                    topmost_yellow_row = min(r for r,c in yellow_obj)\n                    bottommost_blue_row = max(r for r,c in blue_obj)\n\n                    if bottommost_blue_row + 1 == topmost_yellow_row:\n                        #columns must match\n                        yellow_cols = set(c for r,c in yellow_obj)\n                        blue_cols = set(c for r,c in blue_obj)\n\n                        if yellow_cols.issubset(blue_cols):\n                            for r,c in yellow_obj:\n                                output_grid[r,c] = 0\n                            for c in yellow_cols:\n                              if bottommost_blue_row >= 0 and bottommost_blue_row < rows and c >=0 and c < cols:\n                                output_grid[bottommost_blue_row, c] = 1\n\n    #handle pixels not near blue\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r,c] != 1:\n                #check for adjacent blue pixel\n                adjacent_blue = False\n                if r - 1 >= 0 and output_grid[r-1,c] == 1:\n                    adjacent_blue = True\n                if r + 1 < rows and output_grid[r+1, c] == 1:\n                    adjacent_blue = True\n                if c - 1 >= 0 and output_grid[r, c-1] == 1:\n                    adjacent_blue = True\n                if c + 1 < cols and output_grid[r, c+1] == 1:\n                    adjacent_blue = True\n                if not adjacent_blue and input_grid[r,c] != 1:\n                    output_grid[r,c] = input_grid[r,c]\n                \n    return output_grid\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17276,
    "candidates_token_count": 1545,
    "total_token_count": 18821,
    "cached_content_token_count": 0
  },
  "response_time": 14.633211,
  "response_file": "024-response.json"
}