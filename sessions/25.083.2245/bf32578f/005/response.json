{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies 'cross-like' shaped objects in the input grid and expands them into solid squares of the same color in the output grid. The expanded square is then shifted based on the original position of the cross.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies distinct objects in the grid.\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, obj):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        obj.append((r, c))\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(r + dr, c + dc, color, obj)\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != 0:\n                obj = []\n                dfs(r, c, grid[r, c], obj)\n                objects.append(obj)\n    return objects\n\ndef is_cross_like(grid, object_pixels):\n    \"\"\"\n    Checks if an object is 'cross-like'.\n    \"\"\"\n    if len(object_pixels) < 3:  # Need at least 3 pixels to be cross-like\n        return False\n\n    rows, cols = zip(*object_pixels)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    center_row = (min_row + max_row) // 2\n    center_col = (min_col + max_col) // 2\n\n    if (center_row, center_col) not in object_pixels:\n       return False\n\n    # Check for at least three arms extending from the center\n    neighbor_count = 0\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nrow, ncol = center_row + dr, center_col + dc\n        if (nrow, ncol) in object_pixels:\n             neighbor_count += 1\n\n    return neighbor_count >= 3\n\ndef expand_to_square(object_pixels):\n    \"\"\"\n    Expands the object to its bounding square.\n    \"\"\"\n    rows, cols = zip(*object_pixels)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    # Make it a square\n    size = max(height, width)\n\n    # determine center of the object\n    center_row = (min_row + max_row) // 2\n    center_col = (min_col + max_col) // 2\n    \n    # compute start of square based on size and center\n    start_row = center_row - size // 2\n    start_col = center_col - size // 2\n\n    square_pixels = []\n    for r in range(start_row, start_row + size):\n        for c in range(start_col, start_col + size):\n            square_pixels.append((r, c))\n    return square_pixels\n\ndef calculate_shift(input_grid, object_pixels):\n    \"\"\"\n    Calculates the target position\n    \"\"\"\n    rows, cols = zip(*object_pixels)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    center_row = (min_row + max_row) // 2\n    center_col = (min_col + max_col) // 2\n\n    return (center_row, center_col)\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Find objects\n    objects = find_objects(input_grid)\n\n    # Process each object\n    for obj in objects:\n        color = input_grid[obj[0]]\n        if is_cross_like(input_grid, obj):\n            # Expand cross-like object to square\n            square = expand_to_square(obj)\n\n            # Calculate Shift - use the calculate shift\n            target_center = calculate_shift(input_grid, obj)\n\n            # Get original center.\n            rows, cols = zip(*obj)\n            min_row, max_row = min(rows), max(rows)\n            min_col, max_col = min(cols), max(cols)\n            original_center_row = (min_row + max_row) // 2\n            original_center_col = (min_col + max_col) // 2\n            \n\n            # Get square size from the expanded square\n            square_rows, square_cols = zip(*square)\n            min_square_row, max_square_row = min(square_rows), max(square_rows)\n            min_square_col, max_square_col = min(square_cols), max(square_cols)            \n            square_size = max(max_square_row - min_square_row + 1, max_square_col - min_square_col + 1 )\n\n\n            # Calculate the top-left corner for placing the square based on shift and center\n            row_start = target_center[0] - square_size//2\n            col_start = target_center[1] - square_size//2\n            \n\n            for r in range(square_size):\n                for c in range(square_size):\n                    shifted_r, shifted_c = row_start + r, col_start + c\n                    if 0 <= shifted_r < output_grid.shape[0] and 0 <= shifted_c < output_grid.shape[1]:\n                        output_grid[shifted_r, shifted_c] = color\n\n        # else skip - no other objects need to be transformed\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5250,
    "candidates_token_count": 1487,
    "total_token_count": 6737,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 15.697429
}