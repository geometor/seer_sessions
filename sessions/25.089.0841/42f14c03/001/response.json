{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy import ndimage\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Identify the background color, which is the most frequent color in the input grid.\n2.  Find all contiguous objects (groups of same-colored pixels) that are not the background color. Each object consists of its color and the set of coordinates it occupies.\n3.  Determine the \"target\" object: Prioritize the object with color blue (1). If no blue object exists, select the object with color green (3) as the target. It's assumed one of these will exist based on the examples.\n4.  Identify all other non-background objects as \"modifier\" objects.\n5.  Calculate the bounding box (minimum and maximum row and column) of the target object.\n6.  Determine the dimensions (height, width) of the output grid from the target object's bounding box.\n7.  Create the output grid, initially filling it entirely with the input grid's background color.\n8.  Draw the target object onto the output grid: For each pixel belonging to the target object in the input grid, place its color at the corresponding position in the output grid, relative to the target object's bounding box top-left corner.\n9.  Draw the modifier objects onto the output grid: For each modifier object, iterate through its pixels. Calculate each pixel's position relative to the target object's bounding box top-left corner. If this relative position falls within the bounds of the output grid, place the modifier pixel's color at that position in the output grid. Modifier pixels overwrite any existing pixels (from the background fill, the target object, or previously drawn modifiers).\n10. Return the final output grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assuming the background is always the most frequent color\n    if not counts:\n        return 0 # Default background if grid is empty?\n    return counts.most_common(1)[0][0]\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all contiguous objects of non-background colors.\"\"\"\n    objects = []\n    unique_colors = np.unique(grid)\n\n    for color in unique_colors:\n        if color == background_color:\n            continue\n\n        # Create a mask for the current color\n        mask = (grid == color)\n        # Label connected components for this color\n        labeled_array, num_features = ndimage.label(mask)\n\n        # For each distinct object of this color\n        for i in range(1, num_features + 1):\n            coords = set(zip(*np.where(labeled_array == i)))\n            if coords:\n                objects.append({'color': color, 'coords': coords})\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies a target object (blue=1, then green=3), uses its bounding box \n    to define the output grid, initializes with background color, draws the \n    target object, then overlays modifier objects based on relative positions.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify background color\n    background_color = find_background_color(input_np)\n\n    # 2. Find all non-background objects\n    all_objects = find_objects(input_np, background_color)\n\n    if not all_objects:\n        # Handle cases with no non-background objects if necessary\n        # Based on examples, assuming there's always at least a target.\n        # Return empty grid or input grid? Returning empty 1x1 for now.\n        return np.array([[0]], dtype=int) \n\n    # 3. Determine the target object (priority: Blue=1, then Green=3)\n    target_object = None\n    # Check for Blue (1)\n    for obj in all_objects:\n        if obj['color'] == 1:\n            target_object = obj\n            break\n    # If no Blue, check for Green (3)\n    if target_object is None:\n        for obj in all_objects:\n            if obj['color'] == 3:\n                target_object = obj\n                break\n\n    # Handle case where neither Blue nor Green object is found (shouldn't happen based on examples)\n    if target_object is None:\n         # Fallback: use the first object found if no priority match\n         if all_objects:\n              target_object = all_objects[0]\n         else:\n              return np.array([[background_color]], dtype=int) # Should not happen\n\n    # 4. Identify modifier objects\n    modifier_objects = [obj for obj in all_objects if obj != target_object]\n\n    # 5. Calculate the bounding box of the target object\n    target_coords = target_object['coords']\n    bbox = get_bounding_box(target_coords)\n    if bbox is None:\n         return np.array([[background_color]], dtype=int) # Should not happen if target found\n\n    t_min_r, t_min_c, t_max_r, t_max_c = bbox\n\n    # 6. Determine output grid dimensions\n    out_height = t_max_r - t_min_r + 1\n    out_width = t_max_c - t_min_c + 1\n\n    # 7. Create the output grid, initialized with the background color\n    output_grid = np.full((out_height, out_width), background_color, dtype=int)\n\n    # 8. Draw the target object onto the output grid\n    target_color = target_object['color']\n    for r, c in target_coords:\n        out_r = r - t_min_r\n        out_c = c - t_min_c\n        # Check bounds just in case, though should always be within\n        if 0 <= out_r < out_height and 0 <= out_c < out_width:\n             output_grid[out_r, out_c] = target_color\n\n    # 9. Draw the modifier objects onto the output grid\n    for modifier in modifier_objects:\n        modifier_color = modifier['color']\n        modifier_coords = modifier['coords']\n        for r, c in modifier_coords:\n            # Calculate position relative to target's bounding box origin\n            out_r = r - t_min_r\n            out_c = c - t_min_c\n            # Check if the relative position is within the output grid bounds\n            if 0 <= out_r < out_height and 0 <= out_c < out_width:\n                output_grid[out_r, out_c] = modifier_color\n\n    # 10. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4724,
    "candidates_token_count": 1707,
    "total_token_count": 6431,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 45.250648,
  "retries": null
}