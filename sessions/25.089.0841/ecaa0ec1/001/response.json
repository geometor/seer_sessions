{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nIdentifies a 3x3 target object composed of blue (1) and azure (8) pixels and multiple yellow (4) marker pixels in the input grid.\nThe transformation involves rotating the 3x3 target object and placing a single yellow marker in the output grid.\n\n1.  **Find Elements**: Locate the 3x3 bounding box of the blue/azure target object and find the coordinates of all yellow markers.\n2.  **Calculate Distances**: Compute the Euclidean distance between the center pixel of the target object and each yellow marker.\n3.  **Determine Closest Marker**: Identify the yellow marker closest to the target object's center.\n4.  **Determine Rotation**: Based on the relative position (quadrant) of the closest marker to the target object's center, determine the clockwise rotation angle for the target object:\n    *   Top-Left (TL): 270 degrees (k=3 clockwise, k=1 for np.rot90 CCW)\n    *   Top-Right (TR): 90 degrees (k=1 clockwise, k=3 for np.rot90 CCW)\n    *   Bottom-Left (BL): 0 degrees (k=0 clockwise, k=0 for np.rot90 CCW)\n    *   Bottom-Right (BR): 180 degrees (k=2 clockwise, k=2 for np.rot90 CCW)\n5.  **Find Second Closest Markers**: Identify the marker(s) with the second smallest distance to the target object's center.\n6.  **Calculate Output Marker Position**: Compute the average row and column of the second closest marker(s). Round the result to the nearest integer coordinates.\n7.  **Construct Output**: Create an output grid of the same size as the input, filled with white (0). Place the rotated target object at its original position. Place a single yellow marker (4) at the calculated average position.\n\"\"\"\n\ndef find_target_object(grid):\n    \"\"\"Finds the 3x3 blue/azure object, returns its patch and top-left corner.\"\"\"\n    target_colors = {1, 8}\n    coords = np.argwhere(np.isin(grid, list(target_colors)))\n    if coords.shape[0] == 0:\n        return None, None, None # No target found\n\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n\n    # Expecting a 3x3 bounding box\n    if max_r - min_r != 2 or max_c - min_c != 2:\n         # If not exactly 3x3, maybe logic needs adjustment, but for now assume 3x3\n         print(f\"Warning: Target object bounding box is not 3x3 ({max_r-min_r+1}x{max_c-min_c+1}). Using min/max bounds.\")\n         # Fallback or error? For now, proceed with bounding box\n         # Let's assume the examples guarantee 3x3, raise error otherwise\n         raise ValueError(\"Target object is not a 3x3 shape.\")\n\n\n    origin_row, origin_col = min_r, min_c\n    patch = grid[origin_row:origin_row + 3, origin_col:origin_col + 3]\n    center_row = origin_row + 1\n    center_col = origin_col + 1\n    \n    return patch, (origin_row, origin_col), (center_row, center_col)\n\ndef find_markers(grid, marker_color=4):\n    \"\"\"Finds all pixels of a specific color.\"\"\"\n    return np.argwhere(grid == marker_color)\n\ndef calculate_distance(p1, p2):\n    \"\"\"Calculates Euclidean distance.\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np) # Initialize with white (0)\n\n    # 1. Find the target object and its properties\n    target_patch, target_origin, target_center = find_target_object(input_np)\n    if target_patch is None:\n        # Handle case where no target object is found if necessary\n        # For this problem, assume target always exists per examples\n        print(\"Warning: No target object found.\")\n        return output_grid.tolist() # Return empty grid or copy of input?\n\n    origin_row, origin_col = target_origin\n    center_row, center_col = target_center\n\n    # 2. Find markers\n    marker_coords = find_markers(input_np, 4)\n    if marker_coords.shape[0] == 0:\n        print(\"Warning: No markers found.\")\n        # Place the unrotated object if no markers? Examples have markers.\n        # Place original patch back for now if no markers.\n        output_grid[origin_row:origin_row+3, origin_col:origin_col+3] = target_patch\n        return output_grid.tolist()\n\n    # 3. Calculate distances from center to markers\n    distances = []\n    for r, c in marker_coords:\n        dist = calculate_distance((r, c), target_center)\n        distances.append({'pos': (r, c), 'dist': dist})\n\n    # Sort by distance\n    distances.sort(key=lambda x: x['dist'])\n\n    # 4. Determine closest marker and rotation\n    closest_marker = distances[0]\n    closest_row, closest_col = closest_marker['pos']\n\n    # Determine relative quadrant and rotation amount (for np.rot90 CCW)\n    if closest_row < center_row and closest_col < center_col: # TL\n        k_rot = 1 # 270 CW -> 90 CCW\n    elif closest_row < center_row and closest_col >= center_col: # TR\n        k_rot = 3 # 90 CW -> 270 CCW\n    elif closest_row >= center_row and closest_col < center_col: # BL\n        k_rot = 0 # 0 CW -> 0 CCW\n    else: # BR (closest_row >= center_row and closest_col >= center_col)\n        k_rot = 2 # 180 CW -> 180 CCW\n\n    # Rotate the target patch\n    rotated_patch = np.rot90(target_patch, k=k_rot)\n\n    # 5. Find second closest markers\n    if len(distances) > 1:\n        min_dist = distances[0]['dist']\n        # Find the first distance strictly greater than the minimum\n        second_dist_val = -1\n        for d in distances:\n            # Use tolerance for float comparison\n            if d['dist'] > min_dist + 1e-9: \n                second_dist_val = d['dist']\n                break\n        \n        second_closest_markers = []\n        if second_dist_val != -1:\n             # Collect all markers with distance close to second_dist_val\n            for d in distances:\n                 if abs(d['dist'] - second_dist_val) < 1e-9:\n                     second_closest_markers.append(d['pos'])\n    else:\n        # Edge case: only one marker exists. Output marker position undefined by examples.\n        # Let's place it at the original marker's position for lack of better rule.\n        second_closest_markers = [closest_marker['pos']]\n\n\n    # 6. Calculate output marker position (average of second closest)\n    if second_closest_markers:\n        avg_row = np.mean([pos[0] for pos in second_closest_markers])\n        avg_col = np.mean([pos[1] for pos in second_closest_markers])\n        # Round to nearest integer for grid coordinates\n        output_marker_row = int(round(avg_row))\n        output_marker_col = int(round(avg_col))\n    else:\n        # If somehow no second closest markers were found (e.g. all markers equidistant)\n        # Default behavior? Place marker at center? Or original closest? Let's use closest.\n         output_marker_row, output_marker_col = closest_row, closest_col\n\n\n    # 7. Construct Output Grid\n    # Place rotated patch\n    output_grid[origin_row:origin_row+3, origin_col:origin_col+3] = rotated_patch\n    \n    # Place the single output marker (ensure within bounds)\n    if 0 <= output_marker_row < height and 0 <= output_marker_col < width:\n        output_grid[output_marker_row, output_marker_col] = 4\n    else:\n        print(f\"Warning: Calculated output marker position ({output_marker_row}, {output_marker_col}) is out of bounds.\")\n\n\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4239,
    "candidates_token_count": 2139,
    "total_token_count": 6378,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.289476,
  "retries": null
}