{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid based on the relative positions of a 3x3 target object (blue/azure) and multiple yellow markers.\n\n1.  Locates the 3x3 target object and calculates its center.\n2.  Locates all yellow markers.\n3.  Calculates the Euclidean distance and relative quadrant (TL, TR, BL, BR) of each marker from the target's center.\n4.  Sorts markers by distance.\n5.  Determines a rotation amount (k * 90 degrees counter-clockwise) for the target object based on the quadrant of the closest marker. If the closest marker is in the Top-Right quadrant, the quadrants of the second-closest marker(s) are used to disambiguate the rotation (k=1 if second-closest are Left; k=3 if second-closest are Right).\n6.  Rotates the target object.\n7.  Calculates the position for a single output yellow marker by averaging the coordinates of the second-closest input marker(s) and rounding. If no second-closest markers exist, the closest marker's position is used.\n8.  Constructs the output grid containing the rotated target object at its original location and the single output yellow marker at its calculated position, against a white background.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_target_object(grid):\n    \"\"\"\n    Finds the 3x3 object composed of blue (1) and azure (8) pixels.\n    Returns its patch, top-left origin coordinates, and center coordinates.\n    Returns None for any value if the object is not found or not exactly 3x3.\n    \"\"\"\n    target_colors = {1, 8} # Blue and Azure\n    coords = np.argwhere(np.isin(grid, list(target_colors)))\n    \n    # Check if any target pixels were found\n    if coords.shape[0] == 0:\n        print(\"Debug: No target pixels found.\")\n        return None, None, None \n\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n\n    # Check if the bounding box is exactly 3x3\n    if max_r - min_r != 2 or max_c - min_c != 2:\n        print(f\"Debug: Target bounding box is not 3x3 ({max_r-min_r+1}x{max_c-min_c+1}).\")\n        return None, None, None \n\n    origin = (min_r, min_c)\n    patch = grid[min_r:min_r + 3, min_c:min_c + 3]\n    # Center is the middle pixel of the 3x3 patch\n    center = (min_r + 1, min_c + 1)\n    \n    return patch, origin, center\n\ndef find_markers(grid, marker_color=4):\n    \"\"\"Finds all pixels of a specific color (markers). Returns list of (row, col) tuples.\"\"\"\n    return [tuple(coord) for coord in np.argwhere(grid == marker_color)]\n\ndef calculate_distance(p1, p2):\n    \"\"\"Calculates Euclidean distance between two points (row, col).\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef get_quadrant(pos, center):\n    \"\"\"Determines the quadrant (TL, TR, BL, BR) of a position relative to a center.\"\"\"\n    r, c = pos\n    cr, cc = center\n    if r < cr and c < cc: return \"TL\"\n    if r < cr and c >= cc: return \"TR\"\n    if r >= cr and c < cc: return \"BL\"\n    if r >= cr and c >= cc: return \"BR\"\n    # Should not happen if pos != center\n    print(f\"Warning: Could not determine quadrant for pos {pos} relative to center {center}\")\n    return \"Unknown\" \n\ndef calculate_distances_and_quadrants(marker_coords, center):\n    \"\"\"Calculates distance and quadrant for each marker relative to the center.\"\"\"\n    details = []\n    for pos in marker_coords:\n        dist = calculate_distance(pos, center)\n        quad = get_quadrant(pos, center)\n        # Round distance for robust comparison\n        details.append({'pos': pos, 'dist': round(dist, 8), 'quad': quad})\n    return details\n\ndef determine_rotation_k(closest_marker_detail, second_closest_marker_details):\n    \"\"\"Determines the rotation parameter k based on closest and second closest marker quadrants.\"\"\"\n    closest_quad = closest_marker_detail['quad']\n    \n    if closest_quad == \"TL\":\n        return 1\n    elif closest_quad == \"BL\":\n        return 0\n    elif closest_quad == \"BR\":\n        return 2\n    elif closest_quad == \"TR\":\n        # Disambiguate based on second closest markers\n        if not second_closest_marker_details:\n             print(\"Warning: Closest marker in TR, but no second closest markers found. Defaulting k=1.\")\n             return 1 # Default based on example 2 trend? Or maybe k=0? Let's use 1.\n\n        all_second_left = all(m['quad'] in [\"TL\", \"BL\"] for m in second_closest_marker_details)\n        all_second_right = all(m['quad'] in [\"TR\", \"BR\"] for m in second_closest_marker_details)\n\n        if all_second_left:\n            return 1\n        elif all_second_right:\n            return 3\n        else:\n            # Mixed second closest quadrants when closest is TR - undefined by examples.\n            print(\"Warning: Closest marker in TR, second closest markers have mixed L/R quadrants. Defaulting k=1.\")\n            return 1 # Defaulting to the more common TR case (k=1).\n    else:\n        # Unknown quadrant for closest marker\n        print(f\"Warning: Unknown quadrant '{closest_quad}' for closest marker. Defaulting k=0.\")\n        return 0\n\ndef calculate_output_marker_position(closest_marker_detail, second_closest_marker_details):\n    \"\"\"Calculates the output marker position.\"\"\"\n    if second_closest_marker_details:\n        # Average the positions of the second closest markers\n        avg_row = np.mean([m['pos'][0] for m in second_closest_marker_details])\n        avg_col = np.mean([m['pos'][1] for m in second_closest_marker_details])\n        # Round to nearest integer for grid coordinates\n        return (int(round(avg_row)), int(round(avg_col)))\n    else:\n        # Fallback: use the position of the closest marker\n        print(\"Debug: No distinct second closest markers found. Using closest marker position for output.\")\n        return closest_marker_detail['pos']\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # 1. Initialize output grid with background color (white)\n    output_grid = np.zeros_like(input_np) \n\n    # 2. Find the target object and its properties\n    target_patch, target_origin, target_center = find_target_object(input_np)\n    \n    # If no valid target object found, return the empty grid\n    if target_patch is None:\n        print(\"Error: Target object not found or not valid (3x3). Returning empty grid.\")\n        return output_grid.tolist() \n    origin_row, origin_col = target_origin\n\n    # 3. Find markers (yellow pixels)\n    marker_coords = find_markers(input_np, 4)\n    \n    # If no markers are found, place the original (unrotated) target object and return\n    if not marker_coords:\n        print(\"Warning: No markers found. Placing original object and returning.\")\n        output_grid[origin_row:origin_row+3, origin_col:origin_col+3] = target_patch\n        return output_grid.tolist()\n\n    # 4. Calculate distances and quadrants for markers\n    marker_details = calculate_distances_and_quadrants(marker_coords, target_center)\n\n    # 5. Sort markers by distance\n    marker_details.sort(key=lambda x: x['dist'])\n\n    # 6. Identify closest marker(s)\n    closest_marker_detail = marker_details[0]\n    min_dist = closest_marker_detail['dist']\n\n    # 7. Identify second closest marker(s)\n    second_closest_marker_details = []\n    second_dist_val = -1\n    for detail in marker_details:\n        if detail['dist'] > min_dist: \n            second_dist_val = detail['dist']\n            break\n    if second_dist_val != -1:\n        for detail in marker_details:\n             if detail['dist'] == second_dist_val:\n                 second_closest_marker_details.append(detail)\n\n    # 8. Determine rotation parameter k\n    k_rot = determine_rotation_k(closest_marker_detail, second_closest_marker_details)\n\n    # 9. Rotate the target patch\n    rotated_patch = np.rot90(target_patch, k=k_rot)\n\n    # 10. Place the rotated patch onto the output grid\n    output_grid[origin_row:origin_row+3, origin_col:origin_col+3] = rotated_patch\n\n    # 11. Calculate the position for the single output marker\n    output_marker_pos = calculate_output_marker_position(closest_marker_detail, second_closest_marker_details)\n\n    # 12. Place the single yellow output marker\n    output_marker_row, output_marker_col = output_marker_pos\n    # Check if the calculated position is within the grid boundaries\n    if 0 <= output_marker_row < height and 0 <= output_marker_col < width:\n        output_grid[output_marker_row, output_marker_col] = 4 # Yellow color\n    else:\n        # Log a warning if the position is out of bounds\n        print(f\"Warning: Calculated output marker position ({output_marker_row}, {output_marker_col}) is out of bounds.\")\n\n    # 13. Return the final output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20264,
    "candidates_token_count": 2487,
    "total_token_count": 22751,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.188695,
  "retries": null
}