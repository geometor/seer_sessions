{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict\n\n\"\"\"\nTransforms an input grid by identifying a central gray rectangle and four differently colored corner marker pixels. \nThe area corresponding to the gray rectangle in the output grid is divided into four equal quadrants. \nEach quadrant is filled with the color of the corresponding corner marker:\n- Top-left marker color fills the top-left quadrant.\n- Top-right marker color fills the top-right quadrant.\n- Bottom-left marker color fills the bottom-left quadrant.\n- Bottom-right marker color fills the bottom-right quadrant.\nThe rest of the output grid is filled with the background color (white, 0).\n\"\"\"\n\ndef find_target_rectangle(grid: np.ndarray) -> Tuple[int, int, int, int, bool]:\n    \"\"\"\n    Finds the bounding box of the contiguous gray (5) rectangle.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple (row_start, col_start, height, width, found).\n        'found' is True if a gray rectangle is found, False otherwise.\n        Returns (0, 0, 0, 0, False) if no gray pixels are found.\n    \"\"\"\n    gray_pixels = np.argwhere(grid == 5)\n    if gray_pixels.size == 0:\n        return 0, 0, 0, 0, False\n\n    row_start = np.min(gray_pixels[:, 0])\n    row_end = np.max(gray_pixels[:, 0])\n    col_start = np.min(gray_pixels[:, 1])\n    col_end = np.max(gray_pixels[:, 1])\n\n    height = row_end - row_start + 1\n    width = col_end - col_start + 1\n    \n    # Optional check for contiguity/rectangle shape, though examples seem consistent\n    # if np.count_nonzero(grid[row_start:row_end+1, col_start:col_end+1] == 5) != height * width:\n    #     print(\"Warning: Found gray pixels do not form a perfect rectangle.\")\n        # Decide how to handle this - maybe return False or proceed anyway\n\n    return row_start, col_start, height, width, True\n\ndef find_corner_markers(grid: np.ndarray) -> Dict[str, int]:\n    \"\"\"\n    Identifies the four corner marker colors based on their positions.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A dictionary mapping corner keys ('TL', 'TR', 'BL', 'BR') to their colors.\n        Returns an empty dict if markers cannot be uniquely identified.\n    \"\"\"\n    markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and color != 5:\n                markers.append({'row': r, 'col': c, 'color': color})\n\n    if len(markers) < 4:\n        # Handle cases with fewer than 4 markers if necessary\n        return {} \n\n    # Find min/max row and column indices among markers\n    min_r = min(m['row'] for m in markers)\n    max_r = max(m['row'] for m in markers)\n    min_c = min(m['col'] for m in markers)\n    max_c = max(m['col'] for m in markers)\n\n    # Identify markers based on row/col priority\n    tl_candidates = [m for m in markers if m['row'] == min_r]\n    tr_candidates = [m for m in markers if m['row'] == min_r]\n    bl_candidates = [m for m in markers if m['row'] == max_r]\n    br_candidates = [m for m in markers if m['row'] == max_r]\n\n    # Find the specific corner marker by applying the secondary column sort\n    tl_marker = min(tl_candidates, key=lambda m: m['col'])\n    tr_marker = max(tr_candidates, key=lambda m: m['col'])\n    bl_marker = min(bl_candidates, key=lambda m: m['col'])\n    br_marker = max(br_candidates, key=lambda m: m['col'])\n    \n    # Basic check to ensure we found 4 distinct markers (corner cases might exist)\n    marker_set = { (m['row'], m['col']) for m in [tl_marker, tr_marker, bl_marker, br_marker] }\n    if len(marker_set) != 4:\n         # Fallback or alternative strategy might be needed if the simple min/max logic fails\n         # For instance, if multiple markers share the exact same min/max row/col combo\n         # Or if fewer than 4 markers exist\n         # Based on examples, this simple logic seems sufficient.\n         print(f\"Warning: Could not uniquely identify 4 distinct corner markers using min/max logic. Found {len(marker_set)}.\")\n         # Attempting to return anyway, might fail later or produce unexpected results\n         # A more robust solution might sort all markers and pick first/last based on different sort keys.\n         # return {} # Return empty dict to signal failure\n\n    return {\n        'TL': tl_marker['color'],\n        'TR': tr_marker['color'],\n        'BL': bl_marker['color'],\n        'BR': br_marker['color']\n    }\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid according to the specified rules:\n    1. Finds a central gray rectangle.\n    2. Finds four corner marker colors.\n    3. Creates an output grid where the area of the gray rectangle is\n       divided into four quadrants, each filled with the corresponding corner marker color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # Find the gray target rectangle\n    row_start, col_start, height, width, found_rect = find_target_rectangle(input_np)\n\n    if not found_rect:\n        # If no gray rectangle, return the empty grid (or handle as needed)\n        print(\"Warning: No gray rectangle found.\")\n        return output_grid.tolist()\n        \n    # Find the corner marker colors\n    marker_colors = find_corner_markers(input_np)\n\n    if not marker_colors or len(marker_colors) != 4 :\n        # If markers aren't found correctly, return empty grid (or handle)\n        print(\"Warning: Could not find 4 corner markers.\")\n        return output_grid.tolist()\n        \n    # Check if height and width are divisible by 2\n    if height % 2 != 0 or width % 2 != 0:\n        print(f\"Warning: Gray rectangle dimensions ({height}x{width}) are not evenly divisible by 2.\")\n        # Decide how to handle: floor/ceil division, return error, etc.\n        # For now, proceed with integer division, which floors.\n        # return output_grid.tolist() # Option to fail transformation\n\n    # Calculate quadrant dimensions\n    quad_h = height // 2\n    quad_w = width // 2\n\n    # Define end rows/cols for slicing clarity\n    row_mid = row_start + quad_h\n    col_mid = col_start + quad_w\n    row_end = row_start + height # This index is exclusive in slicing\n    col_end = col_start + width  # This index is exclusive in slicing\n\n    # Fill the quadrants in the output grid\n    # Top-Left Quadrant\n    output_grid[row_start:row_mid, col_start:col_mid] = marker_colors['TL']\n    # Top-Right Quadrant\n    output_grid[row_start:row_mid, col_mid:col_end] = marker_colors['TR']\n    # Bottom-Left Quadrant\n    output_grid[row_mid:row_end, col_start:col_mid] = marker_colors['BL']\n    # Bottom-Right Quadrant\n    output_grid[row_mid:row_end, col_mid:col_end] = marker_colors['BR']\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3877,
    "candidates_token_count": 1972,
    "total_token_count": 5849,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.977679,
  "retries": null
}