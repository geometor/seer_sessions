{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify the Dominant Object:** Find the largest connected component (LCC) of pixels of the same color in the input grid, considering both orthogonal and diagonal adjacency. Determine the color of this LCC ('dominant_color').\n2.  **Identify External Regions:** Perform a search (e.g., Breadth-First Search) starting from all border cells of the grid. This search propagates to adjacent cells (orthogonally and diagonally) but cannot pass through any cell with the 'dominant_color'. Mark all reachable cells from the border without crossing the 'dominant_color' as \"externally reachable\".\n3.  **Identify and Fill Cavities:** Create a copy of the input grid. Iterate through each cell of the grid. If a cell in the input grid does *not* have the 'dominant_color' and was *not* marked as \"externally reachable\", change its color in the copied grid to the 'dominant_color'.\n4.  **Output:** The modified copied grid is the final output. Cells that are part of the LCC or are externally reachable retain their original colors.\n\"\"\"\n\ndef find_largest_connected_component(grid):\n    \"\"\"\n    Finds the largest connected component (LCC) in the grid.\n    Connectivity includes diagonals.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (dominant_color, set_of_coordinates) of the LCC.\n               Returns (None, set()) if the grid is empty.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    max_size = 0\n    lcc_color = None\n    lcc_coords = set()\n\n    # Define 8 directions for connectivity (orthogonal + diagonal)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0),\n                  (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                component_color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == component_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n\n                if len(component_coords) > max_size:\n                    max_size = len(component_coords)\n                    lcc_color = component_color\n                    lcc_coords = component_coords\n\n    return lcc_color, lcc_coords\n\n\ndef find_externally_reachable(grid, dominant_color):\n    \"\"\"\n    Finds all cells reachable from the border without crossing the dominant color.\n    Connectivity includes diagonals.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        dominant_color (int): The color of the LCC.\n\n    Returns:\n        set: A set of coordinates (r, c) of externally reachable cells.\n    \"\"\"\n    height, width = grid.shape\n    reachable = set()\n    q = deque()\n\n    # Define 8 directions for connectivity\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0),\n                  (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    # Add border cells to queue if they are not the dominant color\n    for r in range(height):\n        for c in range(width):\n            if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n                if grid[r, c] != dominant_color and (r, c) not in reachable:\n                    q.append((r, c))\n                    reachable.add((r, c))\n\n    # Perform BFS\n    while q:\n        curr_r, curr_c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] != dominant_color and (nr, nc) not in reachable:\n                reachable.add((nr, nc))\n                q.append((nr, nc))\n\n    return reachable\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the described rule:\n    Finds the largest connected component (LCC), identifies cells not\n    belonging to the LCC that are enclosed by it (not reachable from the border\n    without crossing the LCC), and fills these enclosed cells with the LCC's color.\n\n    Args:\n        input_grid_list (list of list of int): The input grid.\n\n    Returns:\n        list of list of int: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    \n    # --- Step 1: Identify the Dominant Object (LCC) ---\n    dominant_color, lcc_coords = find_largest_connected_component(input_grid)\n\n    # Handle edge case where grid might be empty or uniform background\n    if dominant_color is None:\n        return input_grid_list # Return original if no component found\n\n    # --- Step 2: Identify External Regions ---\n    # Find all cells reachable from the border without passing through the dominant color\n    externally_reachable_coords = find_externally_reachable(input_grid, dominant_color)\n\n    # --- Step 3: Identify and Fill Cavities ---\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Iterate through all cells\n    for r in range(height):\n        for c in range(width):\n            # Check if the cell is NOT the dominant color AND is NOT externally reachable\n            # Note: We don't need to check if it's part of lcc_coords explicitly,\n            # because if it were, its color would be dominant_color.\n            if input_grid[r, c] != dominant_color and (r, c) not in externally_reachable_coords:\n                # This cell is inside a cavity, fill it with the dominant color\n                output_grid[r, c] = dominant_color\n\n    # --- Step 4: Finalize Output ---\n    # Convert the numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3422,
    "candidates_token_count": 1631,
    "total_token_count": 5053,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.395927,
  "retries": null
}