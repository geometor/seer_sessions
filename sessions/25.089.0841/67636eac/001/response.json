{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nIdentifies all 3x3 \"plus-sign\" shapes in the input grid. \nA plus-sign shape is defined as a 3x3 area with a white center (0), four \northogonally adjacent pixels of the same non-white color, and four white \ncorner pixels.\nExtracts these 3x3 shapes.\nDetermines the primary spatial arrangement (vertical or horizontal) of these \nshapes in the input grid based on the range of their top-left corner coordinates.\nSorts the extracted shapes based on their original position: top-to-bottom \n(then left-to-right) if vertically arranged, or left-to-right (then top-to-bottom) \nif horizontally arranged.\nConcatenates the sorted shapes accordingly (vertically stacked or horizontally \naligned) to form the output grid.\n\"\"\"\n\ndef find_plus_shapes(grid: np.ndarray) -> List[Tuple[int, int, np.ndarray]]:\n    \"\"\"\n    Finds all unique 3x3 plus-sign shapes in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - The top row index of the shape's bounding box.\n        - The top column index of the shape's bounding box.\n        - A 3x3 numpy array representing the shape.\n    \"\"\"\n    h, w = grid.shape\n    found_shapes = {} # Use dict keyed by (row, col) to store unique shapes\n\n    # Iterate through potential center cells (r, c)\n    # The center of a 3x3 shape cannot be on the border\n    for r in range(1, h - 1):\n        for c in range(1, w - 1):\n            # Check if the potential center is white\n            if grid[r, c] == 0:\n                # Get neighbor colors\n                center_color = 0 # grid[r, c]\n                up_color = grid[r - 1, c]\n                down_color = grid[r + 1, c]\n                left_color = grid[r, c - 1]\n                right_color = grid[r, c + 1]\n                \n                # Check if orthogonal neighbors are the same non-white color\n                if up_color != 0 and up_color == down_color == left_color == right_color:\n                    shape_color = up_color\n                    # Check if corner neighbors are white\n                    tl_color = grid[r - 1, c - 1]\n                    tr_color = grid[r - 1, c + 1]\n                    bl_color = grid[r + 1, c - 1]\n                    br_color = grid[r + 1, c + 1]\n                    \n                    if tl_color == 0 and tr_color == 0 and bl_color == 0 and br_color == 0:\n                        # Valid plus shape found\n                        top_row, top_col = r - 1, c - 1\n                        # Extract the 3x3 subgrid\n                        shape_grid = grid[top_row : top_row + 3, top_col : top_col + 3]\n                        # Store it using its top-left coordinate as the key to avoid duplicates\n                        found_shapes[(top_row, top_col)] = shape_grid\n                        \n    # Convert the dictionary items to the desired list format\n    shapes_list = [(r, c, shape) for (r, c), shape in found_shapes.items()]\n    return shapes_list\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by extracting 3x3 plus-sign shapes and \n    concatenating them either vertically or horizontally based on their \n    original spatial arrangement.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Find all 3x3 plus shapes and their top-left coordinates\n    shapes = find_plus_shapes(input_np)\n\n    # If no shapes are found, return an empty grid or handle as needed\n    if not shapes:\n        # Based on examples, this case doesn't seem to occur, but return empty for safety\n        return [] \n        \n    # If only one shape, return it directly\n    if len(shapes) == 1:\n         return shapes[0][2].tolist()\n\n    # Determine the spatial arrangement (vertical or horizontal dominance)\n    rows = [r for r, c, s in shapes]\n    cols = [c for r, c, s in shapes]\n    \n    # Calculate the range of rows and columns\n    # Add 1 to avoid division by zero or issues if all shapes are aligned perfectly\n    row_range = max(rows) - min(rows) \n    col_range = max(cols) - min(cols)\n    \n    # Decide stacking direction: stack vertically if row range is >= column range\n    stack_vertically = row_range >= col_range\n\n    # Sort the shapes based on the determined arrangement\n    if stack_vertically:\n        # Sort primarily by row (top-to-bottom), then column (left-to-right)\n        sorted_shapes = sorted(shapes, key=lambda x: (x[0], x[1]))\n    else:\n        # Sort primarily by column (left-to-right), then row (top-to-bottom)\n        sorted_shapes = sorted(shapes, key=lambda x: (x[1], x[0]))\n\n    # Extract just the 3x3 shape grids in the sorted order\n    shape_grids = [s[2] for s in sorted_shapes]\n\n    # Concatenate the grids\n    if stack_vertically:\n        output_np = np.vstack(shape_grids)\n    else:\n        output_np = np.hstack(shape_grids)\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3177,
    "candidates_token_count": 1447,
    "total_token_count": 4624,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.146019,
  "retries": null
}