{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies horizontal and vertical axis lines of a single color that intersect within the grid.\nDetermines the quadrant containing the most non-background, non-axis 'content' pixels.\nReflects the content pixels from this source quadrant into the other three quadrants across the identified axes.\nThe background color is assumed to be the most frequent color, excluding potential axis line colors. In the examples, orange (7) is the background.\nThe axis lines themselves and the original content in the source quadrant remain unchanged. Reflected pixels overwrite the background color in the target quadrants.\n\"\"\"\n\ndef find_axis_lines(grid):\n    \"\"\"\n    Finds the single horizontal and vertical axis lines and their color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (axis_color, h_axis_row, v_axis_col) or (None, None, None) if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    # Assume background is 7 based on examples\n    background_color = 7\n\n    potential_axes = {} # color -> {'h': [rows], 'v': [cols]}\n\n    # Check horizontal lines\n    for r in range(rows):\n        counts = Counter(grid[r, :])\n        # A horizontal line candidate must have only one non-background color\n        # and that color must fill the row (or almost, allowing for intersection point)\n        non_bg_colors = [c for c, count in counts.items() if c != background_color]\n        if len(non_bg_colors) == 1:\n            axis_candidate_color = non_bg_colors[0]\n            # Check if it's a solid line (allowing one pixel of different color for intersection)\n            if counts[axis_candidate_color] >= cols -1 :\n                 if axis_candidate_color not in potential_axes:\n                     potential_axes[axis_candidate_color] = {'h': [], 'v': []}\n                 potential_axes[axis_candidate_color]['h'].append(r)\n\n    # Check vertical lines\n    for c in range(cols):\n        counts = Counter(grid[:, c])\n        non_bg_colors = [col for col, count in counts.items() if col != background_color]\n        if len(non_bg_colors) == 1:\n            axis_candidate_color = non_bg_colors[0]\n            if counts[axis_candidate_color] >= rows - 1:\n                 if axis_candidate_color not in potential_axes:\n                     potential_axes[axis_candidate_color] = {'h': [], 'v': []}\n                 potential_axes[axis_candidate_color]['v'].append(c)\n\n    # Find the color that forms exactly one horizontal and one vertical line\n    for color, axes in potential_axes.items():\n        if len(axes['h']) == 1 and len(axes['v']) == 1:\n            # Verify the intersection point color\n            h_row = axes['h'][0]\n            v_col = axes['v'][0]\n            if grid[h_row, v_col] == color:\n                 return color, h_row, v_col\n\n    return None, None, None # No valid axes found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by reflecting content from one quadrant to others.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify axis lines and color\n    # Assume background color is 7 based on examples\n    background_color = 7\n    axis_color, h_axis_row, v_axis_col = find_axis_lines(grid)\n\n    if axis_color is None:\n        # Handle error case: No single pair of intersecting axes found\n        # For ARC, we usually assume the pattern holds and return input or raise error\n        # Returning input might be safer if test cases could be malformed.\n        print(\"Warning: Could not find valid axis lines.\")\n        return input_grid\n\n    # 2. Identify the source quadrant\n    quadrant_content_count = {\n        'top_left': 0, 'top_right': 0,\n        'bottom_left': 0, 'bottom_right': 0\n    }\n    source_quadrant_key = None\n    max_count = -1\n\n    # Iterate through all cells to count content pixels in each quadrant\n    for r in range(rows):\n        for c in range(cols):\n            # Skip axis lines\n            if r == h_axis_row or c == v_axis_col:\n                continue\n\n            pixel_color = grid[r, c]\n            # Skip background and axis colors\n            if pixel_color == background_color or pixel_color == axis_color:\n                continue\n\n            # Determine quadrant and increment count\n            if r < h_axis_row and c < v_axis_col:\n                quadrant_content_count['top_left'] += 1\n            elif r < h_axis_row and c > v_axis_col:\n                quadrant_content_count['top_right'] += 1\n            elif r > h_axis_row and c < v_axis_col:\n                quadrant_content_count['bottom_left'] += 1\n            elif r > h_axis_row and c > v_axis_col:\n                quadrant_content_count['bottom_right'] += 1\n\n    # Find the quadrant with the most content pixels\n    for key, count in quadrant_content_count.items():\n        if count > max_count:\n            max_count = count\n            source_quadrant_key = key\n\n    if source_quadrant_key is None:\n         # If no content pixels found, return original grid\n         print(\"Warning: No content pixels found in any quadrant.\")\n         return input_grid\n\n    # 3. Define source quadrant boundaries (exclusive of axes)\n    r_start, r_end = 0, h_axis_row\n    c_start, c_end = 0, v_axis_col\n    if 'bottom' in source_quadrant_key:\n        r_start, r_end = h_axis_row + 1, rows\n    if 'right' in source_quadrant_key:\n        c_start, c_end = v_axis_col + 1, cols\n\n    # 4. Reflect content pixels from the source quadrant\n    for r in range(r_start, r_end):\n        for c in range(c_start, c_end):\n            content_color = grid[r, c]\n\n            # Only reflect non-background, non-axis colors\n            if content_color != background_color and content_color != axis_color:\n                # Calculate reflected coordinates\n                # Vertical reflection (across horizontal axis)\n                r_v = h_axis_row + (h_axis_row - r)\n                c_v = c\n                # Horizontal reflection (across vertical axis)\n                r_h = r\n                c_h = v_axis_col + (v_axis_col - c)\n                # Diagonal reflection (across both axes)\n                r_d = h_axis_row + (h_axis_row - r)\n                c_d = v_axis_col + (v_axis_col - c)\n\n                # Update output grid at reflected positions if within bounds\n                if 0 <= r_v < rows and 0 <= c_v < cols:\n                    output_grid[r_v, c_v] = content_color\n                if 0 <= r_h < rows and 0 <= c_h < cols:\n                    output_grid[r_h, c_h] = content_color\n                if 0 <= r_d < rows and 0 <= c_d < cols:\n                    output_grid[r_d, c_d] = content_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3581,
    "candidates_token_count": 1907,
    "total_token_count": 5488,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.518465,
  "retries": null
}