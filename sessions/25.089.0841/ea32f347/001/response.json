{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nRecolors distinct gray (5) objects in an input grid based on their scan order (top-to-bottom, left-to-right) and relative vertical positions.\n\n1. Finds all connected components (objects) of gray pixels (color 5), considering 8-way adjacency (including diagonals).\n2. Sorts these objects based on their top-most, then left-most pixel.\n3. The first object in the sorted list is colored blue (1).\n4. The second and third objects are colored red (2) and yellow (4). The assignment depends on their relative vertical position:\n   - If the second object is entirely above the third object (its maximum row index is less than the third object's minimum row index), the second becomes red (2) and the third becomes yellow (4).\n   - Otherwise, the second becomes yellow (4) and the third becomes red (2).\n5. All other pixels remain unchanged. Assumes exactly three gray objects are present based on the training examples.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, color: int) -> List[Set[Tuple[int, int]]]:\n    \"\"\"\n    Finds all connected objects of a given color in the grid.\n    Connectivity includes diagonal neighbors (8-way adjacency).\n\n    Args:\n        grid: The input numpy array representing the grid.\n        color: The color of the objects to find.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) coordinates\n        of the pixels belonging to one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) for a new object\n                obj_coords = set()\n                queue = [(r, c)]\n                visited[r, c] = True\n                \n                while queue:\n                    curr_r, curr_c = queue.pop(0)\n                    obj_coords.add((curr_r, curr_c))\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds and if neighbor is the correct color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                queue.append((nr, nc))\n                \n                if obj_coords:\n                    objects.append(obj_coords)\n    \n    return objects\n\ndef get_object_scan_order_key(obj_coords: Set[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Determines the sorting key for an object based on its top-most, left-most pixel.\n\n    Args:\n        obj_coords: A set of (row, col) coordinates for the object.\n\n    Returns:\n        A tuple (min_row, min_col) representing the scan order key.\n    \"\"\"\n    min_row = float('inf')\n    min_col_at_min_row = float('inf')\n\n    for r, c in obj_coords:\n        if r < min_row:\n            min_row = r\n            min_col_at_min_row = c\n        elif r == min_row and c < min_col_at_min_row:\n            min_col_at_min_row = c\n            \n    return min_row, min_col_at_min_row\n\ndef get_bounding_box(obj_coords: Set[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box of an object.\n\n    Args:\n        obj_coords: A set of (row, col) coordinates for the object.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col). Returns (-1,-1,-1,-1) if coords empty.\n    \"\"\"\n    if not obj_coords:\n        return -1, -1, -1, -1\n    \n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    return min(rows), min(cols), max(rows), max(cols)\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by recoloring gray objects based on scan order\n    and relative vertical positions.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    gray_color = 5\n    blue_color = 1\n    red_color = 2\n    yellow_color = 4\n\n    # Find all gray objects\n    gray_objects = find_objects(output_grid, gray_color)\n\n    # Sort objects by scan order (top-most, then left-most pixel)\n    gray_objects.sort(key=get_object_scan_order_key)\n\n    # Check if we found the expected number of objects (based on training examples)\n    if len(gray_objects) != 3:\n        # If not exactly 3 objects, return the original grid or handle error.\n        # For this specific task, based on examples, we assume 3 objects.\n        # If this assumption is wrong for test cases, this might need adjustment.\n        print(f\"Warning: Expected 3 gray objects, but found {len(gray_objects)}. Returning original grid.\")\n        return output_grid \n\n    # Assign objects based on sorted order\n    obj1_coords = gray_objects[0]\n    obj2_coords = gray_objects[1]\n    obj3_coords = gray_objects[2]\n\n    # Recolor the first object to blue\n    for r, c in obj1_coords:\n        output_grid[r, c] = blue_color\n\n    # Determine bounding boxes for the second and third objects\n    min_r2, min_c2, max_r2, max_c2 = get_bounding_box(obj2_coords)\n    min_r3, min_c3, max_r3, max_c3 = get_bounding_box(obj3_coords)\n\n    # Check relative vertical position and assign colors accordingly\n    color2 = yellow_color\n    color3 = red_color\n    if max_r2 < min_r3: # Object 2 is entirely above Object 3\n        color2 = red_color\n        color3 = yellow_color\n        \n    # Recolor the second object\n    for r, c in obj2_coords:\n        output_grid[r, c] = color2\n        \n    # Recolor the third object\n    for r, c in obj3_coords:\n        output_grid[r, c] = color3\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3919,
    "candidates_token_count": 1680,
    "total_token_count": 5599,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.679672,
  "retries": null
}