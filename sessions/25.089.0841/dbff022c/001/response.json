{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify regions of white pixels (color 0) in the input grid.\n2. Determine if a white region is \"internal\" (completely enclosed by non-white pixels) or \"external\" (connected to the grid border by other white pixels).\n3. For each internal white region:\n    a. Find the single, unique color (B) of the non-white pixels directly adjacent (sharing a side) to the region.\n    b. Determine the fill color (F) based on the border color (B) using the following rules:\n        i. If B is Gray (8), F is Blue (1).\n        ii. If B is Red (2), F is Orange (7).\n        iii. If B is Yellow (4):\n            - Check if Magenta (6) exists anywhere in the *entire* input grid. If yes, F is Magenta (6).\n            - Else, check if Gray (5) exists anywhere in the *entire* input grid. If yes, F is Gray (5).\n            - Otherwise, F is Yellow (4).\n        iv. For all other border colors B (e.g., Green(3), Orange(7), Gray(5)), F is the same as B.\n    c. Fill all pixels within that internal white region with the determined fill color F in the output grid.\n4. External white regions and all non-white pixels remain unchanged in the output grid.\n5. The output grid has the same dimensions as the input grid.\n\"\"\"\n\ndef determine_fill_color(border_color, has_magenta, has_gray5):\n    \"\"\"Determines the fill color based on the border color and global grid colors.\"\"\"\n    if border_color == 8:\n        return 1  # Blue\n    elif border_color == 2:\n        return 7  # Orange\n    elif border_color == 4:\n        if has_magenta:\n            return 6  # Magenta\n        elif has_gray5:\n            return 5  # Gray\n        else:\n            return 4  # Yellow\n    else:\n        # For Green(3), Orange(7), Gray(5), etc. fill with the border color itself\n        return border_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to fill internal white regions based on border colors.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    # Pre-calculate if colors 6 or 5 exist anywhere in the grid\n    has_magenta = np.any(input_grid_np == 6)\n    has_gray5 = np.any(input_grid_np == 5)\n\n    # Iterate through each pixel to find starting points of white regions\n    for r in range(height):\n        for c in range(width):\n            # If it's a white pixel and hasn't been visited yet, start exploring the region\n            if input_grid_np[r, c] == 0 and not visited[r, c]:\n                \n                region_coords = []\n                neighbor_colors = set()\n                is_external = False\n                queue = deque([(r, c)])\n                visited[r, c] = True\n                region_visited_mask = np.zeros_like(input_grid_np, dtype=bool) # Track visited within this specific region BFS\n                region_visited_mask[r,c] = True\n\n                # Breadth-First Search (BFS) to find the connected white region\n                while queue:\n                    curr_r, curr_c = queue.popleft()\n                    region_coords.append((curr_r, curr_c))\n\n                    # Check if this pixel touches the border\n                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:\n                        is_external = True\n                        # Note: We continue the BFS to mark all connected white cells as visited,\n                        # even if external, to avoid processing them again.\n\n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            neighbor_val = input_grid_np[nr, nc]\n                            # If neighbor is white and not visited in this BFS\n                            if neighbor_val == 0 and not region_visited_mask[nr, nc]:\n                                visited[nr, nc] = True # Mark globally visited\n                                region_visited_mask[nr, nc] = True # Mark visited for this region's BFS\n                                queue.append((nr, nc))\n                            # If neighbor is non-white, record its color\n                            elif neighbor_val != 0:\n                                neighbor_colors.add(neighbor_val)\n                        # If neighbor is out of bounds, it implicitly connects to the 'outside'\n                        # else: # If neighbor would be out of bounds\n                           # is_external = True # This isn't strictly needed due to the border check above\n\n                # After exploring the entire region, check if it's internal and has a single border color\n                if not is_external and len(neighbor_colors) == 1:\n                    border_color = list(neighbor_colors)[0]\n                    fill_color = determine_fill_color(border_color, has_magenta, has_gray5)\n                    \n                    # Fill the identified internal region in the output grid\n                    for reg_r, reg_c in region_coords:\n                        output_grid[reg_r, reg_c] = fill_color\n                # If it's external, or has multiple/no border colors, do nothing (leave as white 0)\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3681,
    "candidates_token_count": 1395,
    "total_token_count": 5076,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.211204,
  "retries": null
}