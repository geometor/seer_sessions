{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nIdentifies an object composed of an outer frame (Color A) and inner core (Color B) in the input grid.\nCreates an output grid by expanding this object based on Manhattan distance from the inner core and preserving parts of the original outer frame.\n\nTransformation Steps:\n1. Identify the coordinates of pixels for the inner color (B) (`inner_coords`) and the outer color (A) (`outer_coords`) in the input grid.\n2. Create a new output grid of the same dimensions as the input, initialized with the background color (white, 0).\n3. For each cell (r, c) in the grid:\n    a. Calculate the minimum Manhattan distance (`min_dist_inner`) from (r, c) to any coordinate in `inner_coords`.\n    b. Check if the coordinate (r, c) exists in the set `outer_coords` (`is_original_outer`).\n    c. Apply coloring rules based on precedence:\n        i. If `min_dist_inner == 1`: Set the output cell `(r, c)` to color B.\n        ii. Else if `min_dist_inner == 2`: Set the output cell `(r, c)` to color A.\n        iii. Else if `is_original_outer` is true: Set the output cell `(r, c)` to color A.\n        iv. Otherwise: Leave the output cell `(r, c)` as white (0).\n4. Return the completed output grid.\n\"\"\"\n\n# Helper functions\ndef find_colors(grid: np.ndarray) -> List[int]:\n    \"\"\"Finds the unique non-zero colors in the grid.\"\"\"\n    return sorted(list(np.unique(grid[grid != 0])))\n\ndef find_bounding_box(grid: np.ndarray) -> Tuple[int, int, int, int] | None:\n    \"\"\"Finds the bounding box (min_r, min_c, max_r, max_c) of non-zero pixels.\"\"\"\n    non_white_coords = np.argwhere(grid != 0)\n    if non_white_coords.size == 0:\n        return None\n    min_r, min_c = non_white_coords.min(axis=0)\n    max_r, max_c = non_white_coords.max(axis=0)\n    return (int(min_r), int(min_c), int(max_r), int(max_c))\n\ndef determine_inner_outer(grid: np.ndarray, colors: List[int], bbox: Tuple[int, int, int, int]) -> Tuple[int | None, int | None]:\n    \"\"\"\n    Determines the inner and outer colors based on the corner pixel of the bounding box.\n    Assumes the color at the top-left corner of the bounding box is the outer color.\n    \"\"\"\n    if not colors:\n        return None, None\n\n    min_r, min_c, _, _ = bbox\n    outer_c = grid[min_r, min_c]\n\n    if len(colors) == 1:\n        inner_c = outer_c # If only one color, it acts as both\n    elif len(colors) == 2:\n        inner_c = colors[0] if colors[1] == outer_c else colors[1]\n    else:\n        # Handle unexpected number of colors if necessary, here assuming outer is determined\n        inner_c = None # Or raise error? Based on problem constraints, should be 1 or 2.\n\n    return int(inner_c) if inner_c is not None else None, int(outer_c)\n\ndef get_color_coords(grid: np.ndarray, color: int) -> Set[Tuple[int, int]]:\n    \"\"\"Returns a set of (row, col) tuples for all pixels of a specific color.\"\"\"\n    coords = np.argwhere(grid == color)\n    return set(tuple(coord) for coord in coords)\n\ndef min_manhattan_distance(point: Tuple[int, int], coord_set: Set[Tuple[int, int]]) -> float:\n    \"\"\"Calculates the minimum Manhattan distance from a point to any coordinate in a set.\"\"\"\n    if not coord_set:\n        return float('inf') # Return infinity if the set is empty\n    r1, c1 = point\n    min_dist = float('inf')\n    for r2, c2 in coord_set:\n        dist = abs(r1 - r2) + abs(c1 - c2)\n        min_dist = min(min_dist, dist)\n    return min_dist\n\n# Main transformation function\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the two-layer expansion transformation based on distance\n    to the original object's inner core and outer frame.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify object properties\n    non_white_colors = find_colors(input_np)\n    bbox = find_bounding_box(input_np)\n\n    # Handle cases with no object or unexpected color counts\n    if bbox is None or not (1 <= len(non_white_colors) <= 2):\n        print(\"Warning: No object found or unexpected number of colors. Returning original grid.\")\n        return input_grid # Return original grid if no object or wrong color count\n\n    inner_color, outer_color = determine_inner_outer(input_np, non_white_colors, bbox)\n\n    # Check if colors were determined successfully\n    if inner_color is None or outer_color is None:\n        print(\"Warning: Could not determine inner/outer colors. Returning original grid.\")\n        return input_grid # Should not happen if bbox and colors are valid, but safety check\n\n    # Get coordinates for inner and outer colors\n    inner_coords = get_color_coords(input_np, inner_color)\n    outer_coords = get_color_coords(input_np, outer_color)\n\n    # 2. Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # 3. Iterate through each cell (r, c) and apply coloring rules\n    for r in range(rows):\n        for c in range(cols):\n            # a. Calculate min distance to inner core pixels\n            min_dist_inner = min_manhattan_distance((r, c), inner_coords)\n\n            # b. Check if the current cell was originally part of the outer frame\n            is_original_outer = (r, c) in outer_coords\n\n            # c. Apply coloring rules with precedence\n            if min_dist_inner == 1:\n                # i. Rule 1: Distance 1 from inner -> Inner Color\n                output_np[r, c] = inner_color\n            elif min_dist_inner == 2:\n                # ii. Rule 2: Distance 2 from inner -> Outer Color\n                output_np[r, c] = outer_color\n            elif is_original_outer:\n                # iii. Rule 3: Was originally outer (and not covered by rule 1/2) -> Outer Color\n                output_np[r, c] = outer_color\n            # iv. Otherwise: Leave as background (already initialized to 0)\n\n    # 4. Return the completed output grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14397,
    "candidates_token_count": 1718,
    "total_token_count": 16115,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.047144,
  "retries": null
}