{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nTransforms an input grid containing a single rectangular object with an outer frame (color A) and an inner core (color B). \nThe transformation involves swapping the colors within the original object's bounds and adding two expansion layers around it.\n\nTransformation Steps:\n1. Identify the unique non-white colors in the input grid. Assume there are exactly two: an outer frame color (A) and an inner core color (B). Determine which is which by checking the color of a corner pixel of the object's bounding box (assumed to be A).\n2. Find the coordinates of all non-white pixels in the input grid (`all_coords`).\n3. Initialize an output grid of the same dimensions as the input, filled with the background color (0, white).\n4. For each cell (r, c) in the output grid:\n    a. Calculate the minimum Manhattan distance (`min_dist`) from (r, c) to any coordinate in `all_coords`.\n    b. Apply coloring rules based on `min_dist`:\n        i. If `min_dist == 0` (the cell is within the original object's location): \n           - Check the color in the *input* grid at `(r, c)`.\n           - If the input color was B (inner), set the output cell `(r, c)` to color A (outer).\n           - If the input color was A (outer), set the output cell `(r, c)` to color B (inner).\n        ii. Else if `min_dist == 1`: Set the output cell `(r, c)` to color A (original outer color).\n        iii. Else if `min_dist == 2`: Set the output cell `(r, c)` to color A (original outer color).\n        iv. Else (`min_dist > 2`): Leave the output cell `(r, c)` as white (0).\n5. Return the completed output grid.\n\"\"\"\n\n# Helper functions\ndef find_colors(grid: np.ndarray) -> List[int]:\n    \"\"\"Finds the unique non-zero colors in the grid.\"\"\"\n    return sorted(list(np.unique(grid[grid != 0])))\n\ndef find_bounding_box(grid: np.ndarray) -> Tuple[int, int, int, int] | None:\n    \"\"\"Finds the bounding box (min_r, min_c, max_r, max_c) of non-zero pixels.\"\"\"\n    non_white_coords = np.argwhere(grid != 0)\n    if non_white_coords.size == 0:\n        return None\n    min_r, min_c = non_white_coords.min(axis=0)\n    max_r, max_c = non_white_coords.max(axis=0)\n    return (int(min_r), int(min_c), int(max_r), int(max_c))\n\ndef determine_inner_outer(grid: np.ndarray, colors: List[int], bbox: Tuple[int, int, int, int]) -> Tuple[int | None, int | None]:\n    \"\"\"\n    Determines the inner (B) and outer (A) colors.\n    Assumes the color at the top-left corner of the bounding box is the outer color (A).\n    Handles cases where only one non-white color might be present (although examples imply two).\n    \"\"\"\n    if not colors:\n        return None, None # No colors found\n\n    min_r, min_c, _, _ = bbox\n    outer_color_A = grid[min_r, min_c] # Assume corner is Outer Color A\n\n    if len(colors) == 1:\n        # If only one color, it acts as both A and B\n        inner_color_B = outer_color_A\n    elif len(colors) == 2:\n        # The other color is the Inner Color B\n        inner_color_B = colors[0] if colors[1] == outer_color_A else colors[1]\n    else:\n        # Should not happen based on examples, but handle defensively\n        print(f\"Warning: Expected 1 or 2 non-white colors, found {len(colors)}. Assuming corner color is outer.\")\n        inner_color_B = None # Cannot reliably determine inner color\n\n    # Ensure integer types before returning\n    outer_A = int(outer_color_A)\n    inner_B = int(inner_color_B) if inner_color_B is not None else None\n\n    return inner_B, outer_A\n\ndef get_all_non_white_coords(grid: np.ndarray) -> Set[Tuple[int, int]]:\n    \"\"\"Returns a set of (row, col) tuples for all non-zero pixels.\"\"\"\n    coords = np.argwhere(grid != 0)\n    return set(tuple(coord) for coord in coords)\n\ndef min_manhattan_distance(point: Tuple[int, int], coord_set: Set[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum Manhattan distance from a point to any coordinate in a set.\"\"\"\n    if not coord_set:\n        return float('inf') # Return infinity if the set is empty\n    r1, c1 = point\n    min_dist = float('inf')\n    for r2, c2 in coord_set:\n        dist = abs(r1 - r2) + abs(c1 - c2)\n        min_dist = min(min_dist, dist)\n    # Ensure the return value is an integer for comparison\n    return int(min_dist)\n\n# Main transformation function\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the color-swapping and two-layer expansion transformation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Step 1: Identify object properties\n    non_white_colors = find_colors(input_np)\n    bbox = find_bounding_box(input_np)\n\n    # Handle cases with no object or unexpected color counts\n    if bbox is None:\n        # No object found, return original grid\n        return input_grid\n    if not (1 <= len(non_white_colors) <= 2):\n         # Based on examples, expect 2 colors. Handle 1 color case, return original if > 2.\n         if len(non_white_colors) > 2:\n             print(\"Warning: More than 2 non-white colors found. Returning original grid.\")\n             return input_grid\n         # If 1 color, proceed, it will act as both A and B.\n\n    inner_color_B, outer_color_A = determine_inner_outer(input_np, non_white_colors, bbox)\n\n    # Check if colors were determined successfully (important if more than 2 colors found)\n    if inner_color_B is None or outer_color_A is None:\n        print(\"Warning: Could not reliably determine inner/outer colors. Returning original grid.\")\n        return input_grid\n\n    # Step 2: Get coordinates of all original non-white pixels\n    all_coords = get_all_non_white_coords(input_np)\n    if not all_coords: # Should be caught by bbox check, but defensive\n         return input_grid\n\n    # Step 3: Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # Step 4 & 5: Iterate through each output cell, calculate distance, apply rules\n    for r in range(rows):\n        for c in range(cols):\n            # a. Calculate min distance to the original object\n            min_dist = min_manhattan_distance((r, c), all_coords)\n\n            # b. Apply coloring rules\n            if min_dist == 0:\n                # i. Swap colors for original object location\n                original_color = input_np[r, c]\n                if original_color == inner_color_B:\n                    output_np[r, c] = outer_color_A\n                elif original_color == outer_color_A:\n                    output_np[r, c] = inner_color_B\n                # Note: If only one color, A==B, so A->B and B->A results in the same color.\n            elif min_dist == 1:\n                # ii. Layer 1 gets original outer color A\n                output_np[r, c] = outer_color_A\n            elif min_dist == 2:\n                # iii. Layer 2 gets original outer color A\n                output_np[r, c] = outer_color_A\n            # iv. Else (min_dist > 2): Leave as background (already 0)\n\n    # Convert the result back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18157,
    "candidates_token_count": 2041,
    "total_token_count": 20198,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.245136,
  "retries": null
}