
## train_1

**input:**
```
3 7 4 7 7 7 7
7 3 4 7 7 7 7
4 4 4 7 7 7 7
7 7 7 7 7 7 7
7 7 7 7 7 7 7
7 7 7 7 7 7 7
7 7 7 7 7 7 7
```


**output:**
```
3 7 4 7 3 7 4
7 3 7 4 7 3 7
4 7 3 7 4 7 3
7 4 7 3 7 4 7
3 7 4 7 3 7 4
7 3 7 4 7 3 7
4 7 3 7 4 7 3
```


## train_2

**input:**
```
2 2 7 8 7 7 7 7 7
7 2 2 8 7 7 7 7 7
2 7 7 8 7 7 7 7 7
8 8 8 8 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
```


**output:**
```
2 2 7 2 2 7 8 8 7
7 2 2 7 2 2 7 8 8
2 7 7 2 7 7 8 7 7
8 8 7 2 2 7 2 2 7
7 8 8 7 2 2 7 2 2
8 7 7 2 7 7 2 7 7
2 2 7 8 8 7 8 8 7
7 2 2 7 8 8 7 8 8
2 7 7 8 7 7 8 7 7
```


## train_3

**input:**
```
9 7 0 7 7 7 7 7
7 7 0 7 7 7 7 7
7 9 0 7 7 7 7 7
0 0 0 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7
```


**output:**
```
9 7 0 7 9 7 0 7
7 7 7 7 7 7 7 7
7 9 7 0 7 9 7 0
0 7 0 7 0 7 0 7
7 7 7 7 7 7 7 7
7 0 7 0 7 0 7 0
0 7 9 7 0 7 9 7
7 7 7 7 7 7 7 7
7 0 7 9 7 0 7 9
9 7 0 7 9 7 0 7
7 7 7 7 7 7 7 7
7 9 7 0 7 9 7 0
```

*   **Perception:** Each input grid contains a distinct pattern located in the top-left corner, surrounded by a background color (predominantly orange, color 7). The remaining area of the input grid is filled with this background color. The output grid has the same dimensions as the input grid but is entirely filled by repeating (tiling) the pattern found in the top-left corner of the input. The key is to identify the extent of this pattern and then use it to fill the output grid.

*   **Facts:**
    
```yaml
    background_color:
      description: The color that fills most of the input grid, typically surrounding a core pattern. It appears to be the most frequent color in the grid. In the examples, this is orange (7).
      value: 7 (based on examples)
    pattern:
      description: A rectangular subgrid located at the top-left corner of the input grid. It contains all the non-background colors.
      properties:
        location: Top-left corner (origin 0,0) of the input grid.
        content: Contains a mix of colors, including those different from the background color.
        extent: Defined by the smallest bounding box containing all non-background colors, anchored at the top-left. Specifically, its height (pattern_h) is (max_row_index_of_non_background + 1) and its width (pattern_w) is (max_col_index_of_non_background + 1).
    input_grid:
      properties:
        dimensions: Height (H) and Width (W).
        content: Contains the pattern in the top-left and the background color elsewhere.
    output_grid:
      properties:
        dimensions: Same Height (H) and Width (W) as the input grid.
        content: Filled entirely by repeating the identified pattern.
      relationship_to_input: The output grid is generated by tiling the pattern extracted from the input grid.
    transformation:
      action: Tiling
      input_object: Pattern extracted from the input grid.
      output_object: The entire output grid.
      rule: The color of a cell at position (r, c) in the output grid is determined by the color of the cell at position (r % pattern_h, c % pattern_w) in the pattern.
    ```


*   **Natural Language Program:**
    1.  Determine the dimensions (Height H, Width W) of the input grid.
    2.  Identify the background color by finding the most frequent color in the input grid.
    3.  Find the maximum row index (`max_r`) and maximum column index (`max_c`) of any cell in the input grid that does not contain the background color. If all cells contain the background color, treat the top-left cell as a 1x1 pattern (`max_r=0`, `max_c=0`).
    4.  Define the pattern height `pattern_h = max_r + 1` and pattern width `pattern_w = max_c + 1`.
    5.  Extract the pattern, which is the subgrid from the input grid spanning rows 0 to `max_r` and columns 0 to `max_c`.
    6.  Create a new output grid with the same dimensions (H x W) as the input grid.
    7.  For each cell in the output grid at row `r` (from 0 to H-1) and column `c` (from 0 to W-1), set its color to be the same as the color in the pattern at row `r % pattern_h` and column `c % pattern_w`.
    8.  Return the generated output grid.
```python
"""
Identifies a pattern in the top-left corner of the input grid, defined by the smallest bounding box containing all non-background colors anchored at (0,0). Then, it tiles this pattern across the entire output grid, which has the same dimensions as the input grid. The background color is determined as the most frequent color in the input grid.
"""

import numpy as np
from collections import Counter

def find_background_color(grid):
    """Finds the most frequent color in the grid, assumed to be the background."""
    if grid.size == 0:
        return 0 # Default background color if grid is empty
    counts = Counter(grid.flatten())
    if not counts:
        return 0 # Default if counter is empty (e.g., empty grid passed somehow)
    # Find the color with the maximum count
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_pattern_bounds(grid, background_color):
    """Finds the bounds (max_row, max_col) of the non-background pattern."""
    max_r, max_c = -1, -1
    non_background_found = False
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != background_color:
                max_r = max(max_r, r)
                max_c = max(max_c, c)
                non_background_found = True

    # If no non-background color is found, the pattern is just the top-left 1x1 cell
    if not non_background_found:
        return 0, 0
        
    return max_r, max_c

def transform(input_grid):
    """
    Tiles the top-left pattern of the input grid to fill the output grid.
    
    Args:
        input_grid (list of lists or np.ndarray): The input grid.

    Returns:
        np.ndarray: The transformed output grid.
    """
    # Convert input to numpy array for easier handling
    input_np = np.array(input_grid, dtype=int)
    if input_np.size == 0:
        return np.array([[]], dtype=int) # Handle empty input

    H, W = input_np.shape

    # 1. Determine the background color
    background_color = find_background_color(input_np)

    # 2. Find the maximum row and column index of non-background colors
    max_r, max_c = find_pattern_bounds(input_np, background_color)

    # 3. Define the pattern dimensions
    pattern_h = max_r + 1
    pattern_w = max_c + 1

    # 4. Extract the pattern
    # Ensure indices are valid even if pattern_h/w are 0 (though handled by find_pattern_bounds returning 0,0)
    pattern = input_np[0:pattern_h, 0:pattern_w] 
    
    # Handle case where pattern extraction might yield an empty array if input was e.g., 0xN or Nx0
    # This shouldn't happen with ARC constraints but good practice.
    if pattern.size == 0: 
         # If pattern is empty (e.g., due to 0 pattern height/width derived from empty input)
         # Re-evaluate: maybe just return an empty grid of correct dims or based on input?
         # For ARC, input dimensions >= 1x1. If all background, pattern is 1x1 of background.
         if H > 0 and W > 0: #Ensure input wasn't totally empty
             pattern = np.array([[input_np[0,0]]]) # Default to top-left 1x1
             pattern_h, pattern_w = 1, 1
         else: # Truly empty input grid case
             return np.array([[]], dtype=int)


    # 5. Create the output grid with the same dimensions as the input
    output_grid = np.zeros_like(input_np)

    # 6. Tile the pattern onto the output grid
    for r in range(H):
        for c in range(W):
            # Use modulo arithmetic to repeat the pattern
            # Ensure pattern dimensions are not zero before modulo
            if pattern_h > 0 and pattern_w > 0:
                output_grid[r, c] = pattern[r % pattern_h, c % pattern_w]
            # else: # Should be covered by earlier checks, but as a failsafe
            #    output_grid[r, c] = background_color # Or some default

    return output_grid.tolist() # Return as list of lists as per ARC standard format if needed, otherwise return np.array

```
