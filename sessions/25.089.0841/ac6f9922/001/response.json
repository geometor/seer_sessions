{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, center_of_mass, find_objects\n\n\"\"\"\nIdentifies target objects within a framed area in the input grid and maps their \ncolors to a smaller output grid based on their relative spatial positions.\n\n1.  Identify the frame color (B1) - typically the outermost border color.\n2.  Identify the main area color (C1) - typically the most frequent color within the frame.\n3.  Find all contiguous shapes (\"target objects\") located within the input grid \n    whose color is neither C1 nor B1.\n4.  Calculate the centroid for each target object.\n5.  If no target objects are found, return a 1x1 grid filled with B1.\n6.  If exactly one target object is found:\n    a.  Determine the bounding box of the area inside the frame.\n    b.  Calculate the center of this inner bounding box.\n    c.  Determine which quadrant (top-left, top-right, bottom-left, bottom-right) \n        the target object's centroid falls into relative to the inner area center.\n    d.  Create a 2x2 output grid filled with B1.\n    e.  Place the target object's color in the corresponding quadrant cell.\n7.  If multiple target objects are found:\n    a.  Extract the row and column coordinates from each target object's centroid.\n    b.  Create sorted lists of unique row and column coordinates.\n    c.  Determine output grid dimensions: height = number of unique rows, width = number of unique columns.\n    d.  Create the output grid of the determined size, filled with B1.\n    e.  For each target object, find the index of its centroid's row in the unique sorted row list \n        and the index of its centroid's column in the unique sorted column list.\n    f.  Place the target object's color at these indices (row_index, col_index) in the output grid.\n8.  Return the constructed output grid.\n\"\"\"\n\ndef find_target_objects(grid, frame_color, main_area_color):\n    \"\"\"Finds contiguous objects not matching frame or main area colors.\"\"\"\n    target_mask = (grid != frame_color) & (grid != main_area_color)\n    \n    # Ensure target_mask contains only valid target colors if needed,\n    # but current logic works if frame/main area colors are correctly identified.\n    \n    labeled_array, num_features = label(target_mask)\n    objects = []\n    if num_features > 0:\n        slices = find_objects(labeled_array)\n        for i in range(num_features):\n            obj_slice = slices[i]\n            obj_coords_local = np.argwhere(labeled_array[obj_slice] == (i + 1))\n            obj_coords_global = obj_coords_local + np.array([obj_slice[0].start, obj_slice[1].start])\n            \n            # Use the color from the original grid at the first coordinate of the object\n            obj_color = grid[obj_coords_global[0, 0], obj_coords_global[0, 1]]\n            \n            centroid = center_of_mass(target_mask, labeled_array, i + 1)\n            objects.append({'color': obj_color, 'centroid': centroid, 'pixels': obj_coords_global})\n            \n    return objects\n\ndef get_inner_bounding_box(grid, frame_color):\n    \"\"\"Finds the bounding box of the area inside the frame.\"\"\"\n    non_frame_coords = np.argwhere(grid != frame_color)\n    if non_frame_coords.size == 0:\n        # Handle cases where grid is all frame color or empty\n        return 0, grid.shape[0] -1 , 0, grid.shape[1] - 1 \n        \n    min_row = np.min(non_frame_coords[:, 0])\n    max_row = np.max(non_frame_coords[:, 0])\n    min_col = np.min(non_frame_coords[:, 1])\n    max_col = np.max(non_frame_coords[:, 1])\n    return min_row, max_row, min_col, max_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the spatial arrangement of target objects.\n    \"\"\"\n    input_np = np.array(input_grid)\n    \n    # 1. Identify frame color (B1) - Assuming it's the border color\n    # Check corners and edges; often the most frequent on border\n    border_colors, counts = np.unique(np.concatenate([\n        input_np[0, :], input_np[-1, :], input_np[1:-1, 0], input_np[1:-1, -1]\n    ]), return_counts=True)\n    frame_color = border_colors[np.argmax(counts)] # B1\n\n    # 2. Identify main area color (C1) - Most frequent non-frame color inside\n    min_r, max_r, min_c, max_c = get_inner_bounding_box(input_np, frame_color)\n    inner_area = input_np[min_r:max_r+1, min_c:max_c+1]\n    # Consider only pixels NOT equal to frame_color for C1 identification\n    inner_colors_non_frame, counts_non_frame = np.unique(inner_area[inner_area != frame_color], return_counts=True)\n    \n    if len(counts_non_frame) > 0:\n         main_area_color = inner_colors_non_frame[np.argmax(counts_non_frame)] # C1\n    else:\n         # If inner area only contains frame color, perhaps C1 = B1 ?\n         # Or maybe there's no distinct C1. Let's assume C1 cannot be B1 for target finding.\n         # Use a placeholder or handle error - for now assume B1 and find targets != B1\n         main_area_color = frame_color # If no other color is dominant inside, treat frame color as main color too?\n\n\n    # 3. Find target objects\n    # Exclude B1 and C1. If C1 ended up being same as B1, only exclude B1.\n    exclude_colors = {frame_color}\n    if main_area_color != frame_color:\n         exclude_colors.add(main_area_color)\n         \n    target_mask = np.isin(input_np, list(exclude_colors), invert=True)\n    # Need to restrict search to within the inner bounding box potentially?\n    # Let's try finding anywhere first, the examples seem contained.\n    labeled_array, num_features = label(target_mask)\n    target_objects = []\n    if num_features > 0:\n        slices = find_objects(labeled_array)\n        for i in range(num_features):\n            obj_slice = slices[i]\n            # Ensure we are processing parts of the grid that were originally target_mask=True\n            # Take the first pixel within the labeled component to get the original color\n            coords_in_comp = np.argwhere(labeled_array[obj_slice] == (i + 1))\n            first_coord_local = tuple(coords_in_comp[0])\n            first_coord_global = (obj_slice[0].start + first_coord_local[0], obj_slice[1].start + first_coord_local[1])\n            obj_color = input_np[first_coord_global]\n            \n            # Filter out objects that might be part of frame or main area if identification was imperfect\n            if obj_color in exclude_colors:\n                continue\n                \n            centroid = center_of_mass(target_mask, labeled_array, i + 1)\n            target_objects.append({'color': obj_color, 'centroid': centroid})\n            \n    num_targets = len(target_objects)\n\n    # 5. Handle no target objects\n    if num_targets == 0:\n        return np.array([[frame_color]]) # Return 1x1 grid with frame color\n\n    # 6. Handle one target object\n    if num_targets == 1:\n        target = target_objects[0]\n        obj_r, obj_c = target['centroid']\n        \n        # Use inner bounding box for center calculation\n        center_r = (min_r + max_r) / 2.0\n        center_c = (min_c + max_c) / 2.0\n        \n        output_grid = np.full((2, 2), frame_color, dtype=int)\n        \n        if obj_r < center_r and obj_c < center_c: # Top-left\n            output_grid[0, 0] = target['color']\n        elif obj_r < center_r and obj_c >= center_c: # Top-right\n            output_grid[0, 1] = target['color']\n        elif obj_r >= center_r and obj_c < center_c: # Bottom-left\n            output_grid[1, 0] = target['color']\n        else: # Bottom-right\n            output_grid[1, 1] = target['color']\n            \n        return output_grid.tolist() # Convert back to list of lists if required by framework\n\n    # 7. Handle multiple target objects\n    else:\n        centroids = [obj['centroid'] for obj in target_objects]\n        rows = sorted(list(set([c[0] for c in centroids])))\n        cols = sorted(list(set([c[1] for c in centroids])))\n        \n        # Create mapping from centroid coordinate to output index\n        row_map = {r: i for i, r in enumerate(rows)}\n        col_map = {c: j for j, c in enumerate(cols)}\n        \n        output_rows = len(rows)\n        output_cols = len(cols)\n        \n        output_grid = np.full((output_rows, output_cols), frame_color, dtype=int)\n        \n        for target in target_objects:\n            obj_r, obj_c = target['centroid']\n            # Find the *closest* unique row/col if centroid isn't exactly on a unique value\n            # Or simpler: just map directly using the created maps\n            # Note: if multiple objects map to the same relative coordinate, the last one processed wins.\n            # This seems consistent with the examples provided (no overlaps in output)\n            out_r = row_map[obj_r]\n            out_c = col_map[obj_c]\n            output_grid[out_r, out_c] = target['color']\n            \n        return output_grid.tolist() # Convert back to list of lists if required\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3723,
    "candidates_token_count": 2524,
    "total_token_count": 6247,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.517056,
  "retries": null
}