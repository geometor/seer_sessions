{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentifies a rectangular frame defined by the bounding box of a single non-white color \nwhose pixels exclusively form the 1-pixel thick perimeter of that bounding box within \nthe grid. It then extracts the content (subgrid) located strictly inside this frame. \nIf multiple such valid frames exist (potentially of different colors), the one whose \nbounding box encloses the largest area (height * width) is chosen. If no such frame \nis found, or if the selected frame is too small (less than 3x3) to contain any content, \nan empty grid (represented as an empty list) is returned.\n\"\"\"\n\ndef _find_bounding_box(grid: np.ndarray, color: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the minimum and maximum row and column indices for a given color in the grid.\n\n    Args:\n        grid: The input numpy array grid.\n        color: The color to find the bounding box for.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col) if the color exists, otherwise None.\n    \"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None\n    return rows.min(), cols.min(), rows.max(), cols.max()\n\ndef _is_valid_frame(grid: np.ndarray, color: int, r1: int, c1: int, r2: int, c2: int) -> bool:\n    \"\"\"\n    Checks if the pixels of the specified 'color' perfectly and exclusively form \n    the 1-pixel thick perimeter of the bounding box defined by r1, c1, r2, c2.\n\n    Args:\n        grid: The input numpy array grid.\n        color: The color of the potential frame.\n        r1, c1, r2, c2: The bounding box coordinates.\n\n    Returns:\n        True if it's a valid frame, False otherwise.\n    \"\"\"\n    box_h = r2 - r1 + 1\n    box_w = c2 - c1 + 1\n\n    # Calculate the expected number of pixels on the perimeter\n    if box_h == 1 and box_w == 1:\n        expected_perimeter_pixels = 1\n    elif box_h == 1:\n        expected_perimeter_pixels = box_w\n    elif box_w == 1:\n        expected_perimeter_pixels = box_h\n    else:\n        expected_perimeter_pixels = 2 * box_h + 2 * box_w - 4 # Subtract 4 corners counted twice\n\n    # Count the total number of pixels of 'color' in the entire grid\n    total_color_pixels = np.count_nonzero(grid == color)\n\n    # If the total count doesn't match the expected perimeter count, it can't be a valid frame\n    if total_color_pixels != expected_perimeter_pixels:\n        return False\n\n    # Verify that all pixels *on* the perimeter within the bounding box match the color.\n    # If the counts match, we just need to confirm they are *in the right place*.\n\n    # Check top row\n    if not np.all(grid[r1, c1:c2+1] == color):\n        return False\n        \n    # Check bottom row (only if height > 1)\n    if box_h > 1 and not np.all(grid[r2, c1:c2+1] == color):\n        return False\n        \n    # Check left column (excluding corners, only if height > 2)\n    if box_h > 2 and not np.all(grid[r1+1:r2, c1] == color):\n        return False\n        \n    # Check right column (excluding corners, only if height > 2 and width > 1)\n    # Note: The check `box_w > 1` is important here. If width is 1, the right col is the same as the left.\n    if box_h > 2 and box_w > 1 and not np.all(grid[r1+1:r2, c2] == color):\n        return False\n\n    # If all checks passed (count matches and perimeter pixels are correct), it's a valid frame\n    return True\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Extracts the content inside the largest valid rectangular frame.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the extracted content subgrid, or an empty list \n        if no suitable frame is found or the frame contains no content.\n    \"\"\"\n    # Handle empty input grid early\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Find unique non-white colors (potential frame colors)\n    # Use grid[grid != 0] to efficiently get non-zero values before finding unique ones\n    potential_frame_colors = np.unique(grid[grid != 0]) \n\n    best_frame_coords = None # Store as (min_row, min_col, max_row, max_col)\n    max_frame_area = -1\n\n    # 1. Iterate through each potential frame color\n    for color in potential_frame_colors:\n        # 2. Determine the bounding box of this color\n        bbox = _find_bounding_box(grid, color)\n        if bbox is None:\n            continue # Should not happen given how potential_frame_colors is derived, but safe check\n            \n        min_r, min_c, max_r, max_c = bbox\n\n        # 3. Validate that this color forms a perfect and exclusive frame\n        if _is_valid_frame(grid, color, min_r, min_c, max_r, max_c):\n            # Calculate the area enclosed by this frame's bounding box\n            area = (max_r - min_r + 1) * (max_c - min_c + 1)\n\n            # 4. Update if this is the largest valid frame found so far\n            if area > max_frame_area:\n                max_frame_area = area\n                best_frame_coords = (min_r, min_c, max_r, max_c)\n            # Note: Tie-breaking for area is implicit - the first largest frame encountered wins.\n            # If a different tie-breaking rule is needed (e.g., smallest color index), \n            # it would need to be added here.\n\n    # 5. Process the selected frame (if any)\n    if best_frame_coords:\n        min_r, min_c, max_r, max_c = best_frame_coords\n\n        # 6. Check if the frame can contain content (size > 2x2)\n        # Frame needs height > 2 and width > 2 to have something strictly inside\n        if max_r > min_r + 1 and max_c > min_c + 1:\n            # 7. Extract the content strictly inside the frame\n            # Numpy slicing end index is exclusive\n            content_grid_np = grid[min_r + 1 : max_r, min_c + 1 : max_c]\n            \n            # Convert the numpy array back to a list of lists for the final output\n            output_grid = content_grid_np.tolist()\n            return output_grid\n        else:\n            # 8. Frame exists but is too small to contain anything (e.g., a line or 2xN rect). \n            # Return empty grid.\n             return [] \n    else:\n        # 5. Handle No Frame: No valid frame found after checking all colors. \n        # Return empty grid.\n        return []\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5332,
    "candidates_token_count": 1847,
    "total_token_count": 7179,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.278903,
  "retries": null
}