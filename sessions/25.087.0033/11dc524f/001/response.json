{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two objects in the grid: a red object (color 2) and a gray object (color 5), against an orange background (color 7).\nThe red object moves towards the gray object, one step at a time, along the axis (vertical or horizontal) where the initial separation between their closest points is largest. If the separations are equal, it moves horizontally.\nThe movement stops when any part of the red object becomes orthogonally or diagonally adjacent to any part of the gray object. The gray object remains stationary.\nThe final grid configuration with the red object in its stopped position is returned.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components (objects) of a given color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is represented as a\n              list of (row, col) coordinate tuples. Returns an empty list\n              if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_closest_points(obj1_coords, obj2_coords):\n    \"\"\"\n    Finds the pair of points (one from each object) with the minimum\n    Manhattan distance.\n\n    Args:\n        obj1_coords (list): List of (row, col) coordinates for object 1.\n        obj2_coords (list): List of (row, col) coordinates for object 2.\n\n    Returns:\n        tuple: A tuple containing ((r1, c1), (r2, c2)), the closest pair\n               of points, or (None, None) if either list is empty.\n    \"\"\"\n    min_dist = float('inf')\n    closest_pair = (None, None)\n\n    if not obj1_coords or not obj2_coords:\n        return closest_pair\n\n    for r1, c1 in obj1_coords:\n        for r2, c2 in obj2_coords:\n            dist = abs(r1 - r2) + abs(c1 - c2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = ((r1, c1), (r2, c2))\n    return closest_pair\n\ndef is_adjacent(obj1_coords, obj2_coords):\n    \"\"\"\n    Checks if any pixel of object 1 is orthogonally or diagonally adjacent\n    to any pixel of object 2.\n\n    Args:\n        obj1_coords (list): List of (row, col) coordinates for object 1.\n        obj2_coords (list): List of (row, col) coordinates for object 2.\n\n    Returns:\n        bool: True if any pixels are adjacent, False otherwise.\n    \"\"\"\n    if not obj1_coords or not obj2_coords:\n        return False\n\n    obj2_set = set(obj2_coords) # Faster lookups\n    rows = max(max(r for r, c in obj1_coords), max(r for r, c in obj2_coords)) + 1\n    cols = max(max(c for r, c in obj1_coords), max(c for r, c in obj2_coords)) + 1\n\n\n    for r1, c1 in obj1_coords:\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r1 + dr, c1 + dc\n                # No need to check grid bounds explicitly if obj2_set handles it\n                if (nr, nc) in obj2_set:\n                    return True\n    return False\n\ndef move_object(grid, obj_coords, dr, dc, background_color):\n    \"\"\"\n    Moves an object on the grid by erasing its old position and drawing it\n    at the new position.\n\n    Args:\n        grid (np.ndarray): The current grid state.\n        obj_coords (list): List of (row, col) coordinates for the object.\n        dr (int): Row change.\n        dc (int): Column change.\n        background_color (int): The color to fill in the old object position.\n\n    Returns:\n        tuple: (new_grid, new_obj_coords) where new_grid is the updated grid\n               and new_obj_coords is the list of new coordinates for the object.\n               Returns (None, None) if move is invalid (e.g., out of bounds),\n               though this implementation assumes valid moves based on problem structure.\n    \"\"\"\n    if not obj_coords:\n        return grid.copy(), []\n\n    new_grid = grid.copy()\n    obj_color = grid[obj_coords[0]] # Get object color from first pixel\n    new_obj_coords = []\n    rows, cols = grid.shape\n\n    # Erase old position\n    for r, c in obj_coords:\n        if 0 <= r < rows and 0 <= c < cols: # Check bounds just in case\n             new_grid[r, c] = background_color\n\n    # Calculate and draw new position\n    for r, c in obj_coords:\n        nr, nc = r + dr, c + dc\n        # Basic out-of-bounds check - might need refinement if complex interactions possible\n        if not (0 <= nr < rows and 0 <= nc < cols):\n             # This case shouldn't happen based on task rules (stop at adjacency)\n             # If it did, we might return original grid or raise error\n             print(f\"Warning: Proposed move to ({nr},{nc}) is out of bounds.\")\n             return grid.copy(), obj_coords # Revert move essentially\n\n        new_obj_coords.append((nr, nc))\n\n    # Draw the object in the new locations\n    for nr, nc in new_obj_coords:\n         # We assume the move is valid and doesn't overwrite critical static parts\n         # (like the gray object), as the stop condition handles the interaction.\n         new_grid[nr, nc] = obj_color\n\n    return new_grid, new_obj_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves the red object towards the gray object until they are adjacent.\n\n    Args:\n        input_grid (np.ndarray): The input grid state.\n\n    Returns:\n        np.ndarray: The final grid state after the red object stops.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    background_color = 7 # Assuming orange background based on examples\n    red_color = 2\n    gray_color = 5\n\n    # 1. Identify Objects\n    red_objects = find_objects(input_grid_np, red_color)\n    gray_objects = find_objects(input_grid_np, gray_color)\n\n    # Assume exactly one red and one gray object based on examples\n    if not red_objects or not gray_objects:\n        print(\"Warning: Could not find both red and gray objects.\")\n        return input_grid_np # Return original if objects are missing\n\n    red_coords = red_objects[0]\n    gray_coords = gray_objects[0]\n\n    # If already adjacent, return input\n    if is_adjacent(red_coords, gray_coords):\n        return input_grid_np\n\n    # 2. Determine Movement Axis\n    closest_red, closest_gray = get_closest_points(red_coords, gray_coords)\n    if closest_red is None or closest_gray is None:\n         # Should not happen if objects were found\n        return input_grid_np\n\n    r_red, c_red = closest_red\n    r_gray, c_gray = closest_gray\n\n    delta_r = r_gray - r_red # Directional difference\n    delta_c = c_gray - c_red # Directional difference\n\n    dr, dc = 0, 0\n    if abs(delta_r) > abs(delta_c):\n        # Move vertically\n        dr = 1 if delta_r > 0 else -1\n    elif abs(delta_c) > abs(delta_r):\n         # Move horizontally\n        dc = 1 if delta_c > 0 else -1\n    else: # abs(delta_r) == abs(delta_c) -> Prioritize horizontal\n        if delta_c != 0: # Check if horizontal move is needed\n             dc = 1 if delta_c > 0 else -1\n        elif delta_r != 0: # Otherwise move vertically\n             dr = 1 if delta_r > 0 else -1\n        # If delta_r == 0 and delta_c == 0, they are overlapping, covered by adjacency check\n\n    # 3. Simulate Movement\n    current_grid = input_grid_np.copy()\n    current_red_coords = list(red_coords) # Ensure it's a mutable copy\n\n    max_steps = current_grid.shape[0] + current_grid.shape[1] # Safety break\n    steps = 0\n\n    while steps < max_steps:\n        # i. Check for Adjacency\n        if is_adjacent(current_red_coords, gray_coords):\n            break # Stop condition met\n\n        # iii. If not adjacent, move the red object\n        next_grid, next_red_coords = move_object(current_grid, current_red_coords, dr, dc, background_color)\n\n        # Handle potential invalid move (though unlikely given task structure)\n        if next_red_coords == current_red_coords:\n            print(\"Warning: Move resulted in no change or was invalid.\")\n            break\n\n        current_grid = next_grid\n        current_red_coords = next_red_coords\n        steps += 1\n\n    if steps == max_steps:\n        print(\"Warning: Maximum simulation steps reached.\")\n\n    # 4. Return Output\n    return current_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6283,
            "end_index": 6618,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4306,
    "candidates_token_count": 2566,
    "total_token_count": 6872,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 95.946604,
  "retries": null
}