
## train_1

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
2 7 7 7 7 7 7 7 7 7 7 7 7
7 2 7 7 5 5 7 7 7 7 7 7 7
2 2 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 2 7 7 5 7 7 7 7 7 7 7
7 7 7 2 5 7 7 7 7 7 7 7 7
7 7 2 2 5 5 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 7 2 2 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 7 2 2 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 5 7 7 7 7 7 7 7 7
7 7 7 7 5 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 2 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 5 7 7 7 7 7 7 7 7 7
7 7 7 7 5 7 7 7 7 7 7 7 7
7 7 7 7 5 5 7 7 7 7 7 7 7
7 7 7 7 2 2 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7
7 7 7 2 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```

**Perception**

1.  **Grid Structure:** The input and output are grids of pixels, predominantly filled with an orange background color (7).
2.  **Objects:** Each grid contains two distinct objects defined by contiguous blocks of non-background colors:
    *   A red object (color 2). The shape of this object appears to be an 'L' in the training examples, possibly rotated.
    *   A gray object (color 5). The shape of this object is a 2x2 square in the training examples.
3.  **Transformation:** The core transformation involves moving the red object while the gray object and the orange background remain stationary.
4.  **Movement Pattern:** The red object moves across the grid from its initial position in the input to a final position in the output.
5.  **Goal/Stopping Condition:** The movement of the red object appears directed *towards* the gray object. The movement ceases precisely when any pixel of the red object becomes adjacent (either orthogonally or diagonally) to any pixel of the gray object.
6.  **Movement Directionality:** The direction of movement (up, down, left, or right) seems determined by the axis (vertical or horizontal) along which the initial separation between the closest points of the red and gray objects is greatest. The red object moves one step at a time along this primary axis until adjacency is achieved.

**Facts**


```yaml
background_color: 7 # orange
objects:
  - id: red_object
    color: 2 # red
    properties:
      - initial_position: location in the input grid
      - shape: contiguous block of red pixels (variable, e.g., L-shape)
      - dynamic: True (moves)
  - id: gray_object
    color: 5 # gray
    properties:
      - initial_position: location in the input grid (same as final)
      - shape: contiguous block of gray pixels (e.g., 2x2 square)
      - dynamic: False (stationary)
transformation:
  action: move
  actor: red_object
  target: gray_object
  termination_condition: >
    Stop movement when any pixel of the red_object is orthogonally
    or diagonally adjacent to any pixel of the gray_object.
  movement_rule: >
    Iteratively move the red_object one pixel at a time towards the
    gray_object along the axis (vertical or horizontal) that has the
    largest initial separation between the closest points of the two objects.
grid:
  properties:
    - dimensions: height and width (variable per task)
    - content: pixels with colors 0-9
relationships:
  - type: adjacency
    between: [red_object, gray_object]
    definition: Orthogonal or diagonal proximity between any pixels of the objects.
    relevance: Defines the stopping point for the red_object's movement.
  - type: relative_position
    between: [red_object, gray_object]
    relevance: Determines the direction of movement for the red_object.
```


**Natural Language Program**

1.  **Identify Objects:** Locate the set of all connected pixels with color 2 (the red object) and the set of all connected pixels with color 5 (the gray object) in the input grid.
2.  **Determine Movement Axis:**
    a.  Find the pair of pixels, one from the red object and one from the gray object, that have the minimum Manhattan distance between them. Let these be `(r_red, c_red)` and `(r_gray, c_gray)`.
    b.  Calculate the vertical separation: `delta_r = abs(r_red - r_gray)`.
    c.  Calculate the horizontal separation: `delta_c = abs(c_red - c_gray)`.
    d.  If `delta_r > delta_c`, the primary movement axis is vertical. The direction is down (`dr = +1`) if `r_red < r_gray`, and up (`dr = -1`) if `r_red > r_gray`. Set `dc = 0`.
    e.  If `delta_c >= delta_r`, the primary movement axis is horizontal. The direction is right (`dc = +1`) if `c_red < c_gray`, and left (`dc = -1`) if `c_red > c_gray`. Set `dr = 0`. (Handles ties by prioritizing horizontal movement, consistent with example 1).
3.  **Simulate Movement:**
    a.  Initialize a temporary grid state identical to the input grid.
    b.  Start a loop:
        i.  Check for Adjacency: Determine if any pixel of the current red object in the temporary grid is orthogonally or diagonally adjacent to any pixel of the gray object.
        ii. If adjacent, exit the loop. The current temporary grid state is the final output.
        iii. If not adjacent, update the temporary grid state by moving *all* pixels of the red object by `dr` rows and `dc` columns. Erase the red pixels from their previous locations and draw them in the new locations.
        iv. Continue the loop.
4.  **Return Output:** The final state of the temporary grid after the loop terminates is the output grid.
