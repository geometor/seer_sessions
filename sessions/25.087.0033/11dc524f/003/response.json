{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two objects in the grid: a red object (color 2) and a gray object (color 5), against an orange background (color 7).\nThe red object moves towards the gray object, one step at a time, along the axis (vertical or horizontal) where the initial separation between their closest points is largest. The separation is measured by the difference in row or column indices between the two closest pixels of the objects. If the absolute row separation and absolute column separation are equal, the red object moves horizontally.\nThe movement stops when any part of the red object becomes orthogonally or diagonally adjacent (shares a side or corner) to any part of the gray object. The gray object remains stationary throughout the process.\nThe final grid configuration with the red object in its stopped position is returned.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components (objects) of a given color in the grid.\n    Uses 8-way connectivity (includes diagonals).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is represented as a\n              list of (row, col) coordinate tuples. Returns an empty list\n              if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_closest_points_and_separation(obj1_coords, obj2_coords):\n    \"\"\"\n    Finds the pair of points (one from each object) with the minimum\n    Manhattan distance and calculates their row/column separation.\n\n    Args:\n        obj1_coords (list): List of (row, col) coordinates for object 1 (e.g., red).\n        obj2_coords (list): List of (row, col) coordinates for object 2 (e.g., gray).\n\n    Returns:\n        tuple: ((r1, c1), (r2, c2), delta_r, delta_c)\n               - (r1, c1): Closest point in obj1.\n               - (r2, c2): Closest point in obj2 corresponding to (r1, c1).\n               - delta_r: Row difference (r2 - r1).\n               - delta_c: Column difference (c2 - c1).\n               Returns (None, None, 0, 0) if either list is empty.\n    \"\"\"\n    min_dist = float('inf')\n    closest_pair = (None, None)\n    final_delta_r, final_delta_c = 0, 0\n\n    if not obj1_coords or not obj2_coords:\n        return None, None, 0, 0\n\n    for r1, c1 in obj1_coords:\n        for r2, c2 in obj2_coords:\n            dist = abs(r1 - r2) + abs(c1 - c2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = ((r1, c1), (r2, c2))\n                final_delta_r = r2 - r1\n                final_delta_c = c2 - c1\n            # Tie-breaking for distance not explicitly needed for separation calculation,\n            # as we only need the separation values associated with *a* closest pair.\n\n    return closest_pair[0], closest_pair[1], final_delta_r, final_delta_c\n\n\ndef is_adjacent(obj1_coords, obj2_coords_set):\n    \"\"\"\n    Checks if any pixel of object 1 is orthogonally or diagonally adjacent\n    to any pixel of object 2.\n\n    Args:\n        obj1_coords (list): List of (row, col) coordinates for object 1.\n        obj2_coords_set (set): Set of (row, col) coordinates for object 2 for fast lookups.\n\n    Returns:\n        bool: True if any pixels are adjacent, False otherwise.\n    \"\"\"\n    if not obj1_coords or not obj2_coords_set:\n        return False\n\n    for r1, c1 in obj1_coords:\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r1 + dr, c1 + dc\n                if (nr, nc) in obj2_coords_set:\n                    return True\n    return False\n\ndef move_object(grid, obj_coords, dr, dc, background_color):\n    \"\"\"\n    Moves an object on the grid by erasing its old position and drawing it\n    at the new position. Assumes the move is valid (within bounds and doesn't\n    illegally overwrite static objects before adjacency check).\n\n    Args:\n        grid (np.ndarray): The current grid state.\n        obj_coords (list): List of (row, col) coordinates for the object.\n        dr (int): Row change.\n        dc (int): Column change.\n        background_color (int): The color to fill in the old object position.\n\n    Returns:\n        tuple: (new_grid, new_obj_coords) where new_grid is the updated grid\n               and new_obj_coords is the list of new coordinates for the object.\n    \"\"\"\n    if not obj_coords:\n        return grid.copy(), []\n\n    new_grid = grid.copy()\n    obj_color = grid[obj_coords[0]] # Get object color from first pixel\n    new_obj_coords = []\n    rows, cols = grid.shape\n\n    # Erase old position\n    for r, c in obj_coords:\n         new_grid[r, c] = background_color\n\n    # Calculate and draw new position\n    for r, c in obj_coords:\n        nr, nc = r + dr, c + dc\n        # Basic out-of-bounds check - stop condition should prevent this usually\n        if not (0 <= nr < rows and 0 <= nc < cols):\n             print(f\"Warning: Proposed move to ({nr},{nc}) is out of bounds.\")\n             # Revert move if out of bounds (shouldn't happen with adjacency stop)\n             return grid.copy(), obj_coords\n        new_obj_coords.append((nr, nc))\n\n    # Draw the object in the new locations\n    # We assume the move doesn't overwrite the static gray object,\n    # as the stop condition (adjacency) handles the interaction.\n    for nr, nc in new_obj_coords:\n         new_grid[nr, nc] = obj_color\n\n    return new_grid, new_obj_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving the red object towards the gray object\n    until they are adjacent.\n\n    Args:\n        input_grid (list or np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The final grid state after the red object stops.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n    \n    # Define colors (assuming standard interpretation from problem description)\n    background_color = 7 # Orange\n    moving_color = 2     # Red\n    static_color = 5     # Gray\n\n    # 1. Identify Objects\n    # Find all red objects (potentially > 1, though examples show 1)\n    red_objects = find_objects(input_grid_np, moving_color)\n    # Find all gray objects (potentially > 1, though examples show 1)\n    gray_objects = find_objects(input_grid_np, static_color)\n\n    # Basic validation: Assume exactly one red and one gray object based on examples\n    if not red_objects or not gray_objects:\n        # If objects not found as expected, return the original grid\n        # print(\"Warning: Could not find exactly one red and one gray object.\")\n        return input_grid_np\n    \n    # Select the first found object of each color\n    red_coords = red_objects[0]\n    gray_coords = gray_objects[0]\n    gray_coords_set = set(gray_coords) # Use set for faster adjacency checks\n\n    # If already adjacent, no movement needed, return original grid\n    if is_adjacent(red_coords, gray_coords_set):\n        return input_grid_np\n\n    # 2. Determine Initial Movement Axis and Direction\n    # Find the closest pair of points between the red and gray objects\n    # and the row/column separation between them.\n    _, _, delta_r, delta_c = get_closest_points_and_separation(red_coords, gray_coords)\n\n    # Determine the step direction (dr, dc)\n    dr, dc = 0, 0\n    if abs(delta_r) > abs(delta_c):\n        # Move vertically towards the gray object\n        dr = 1 if delta_r > 0 else -1\n    elif abs(delta_c) > abs(delta_r):\n         # Move horizontally towards the gray object\n        dc = 1 if delta_c > 0 else -1\n    else: # abs(delta_r) == abs(delta_c) != 0 -> Prioritize horizontal move\n        if delta_c != 0: # Check if horizontal move is needed/possible\n             dc = 1 if delta_c > 0 else -1\n        elif delta_r != 0: # Otherwise move vertically if needed/possible\n             dr = 1 if delta_r > 0 else -1\n        # If delta_r == 0 and delta_c == 0, objects are overlapping/touching,\n        # which should be caught by the initial is_adjacent check.\n\n    # Ensure movement is happening if not adjacent\n    if dr == 0 and dc == 0 and not is_adjacent(red_coords, gray_coords_set):\n        # This case might happen if initial state has issues or logic error\n        # print(\"Warning: No movement direction determined despite objects not being adjacent.\")\n        return input_grid_np # Return original if no move determined\n\n    # 3. Simulate Movement Step-by-Step\n    current_grid = input_grid_np.copy()\n    current_red_coords = list(red_coords) # Use a mutable copy\n\n    # Safety break to prevent infinite loops in unexpected scenarios\n    max_steps = rows + cols\n    steps = 0\n\n    while steps < max_steps:\n        # Check for adjacency BEFORE the move\n        if is_adjacent(current_red_coords, gray_coords_set):\n            # Stop condition met: the object is adjacent to the target\n            break\n\n        # Perform the move\n        next_grid, next_red_coords = move_object(current_grid, current_red_coords, dr, dc, background_color)\n\n        # Check if the move was valid (e.g., not out of bounds, resulted in change)\n        # Note: move_object currently handles basic out-of-bounds by reverting.\n        if next_red_coords == current_red_coords:\n             # This might happen if move_object reverted due to bounds or other issues.\n             # print(\"Warning: Move resulted in no change or was invalid. Stopping.\")\n             break\n\n        # Update state for the next iteration\n        current_grid = next_grid\n        current_red_coords = next_red_coords\n        steps += 1\n\n    # Safety check for loop termination\n    if steps == max_steps:\n        print(\"Warning: Maximum simulation steps reached.\")\n\n    # 4. Return the Final Grid State\n    return current_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 15288,
            "end_index": 15623,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6900,
    "candidates_token_count": 2946,
    "total_token_count": 9846,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 124.008234,
  "retries": null
}