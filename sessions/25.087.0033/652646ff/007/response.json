{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies significant geometric shapes in the input grid, generates a 6x6 representation for each shape, sorts these representations based on the shape's original position, and stacks them vertically to form the output grid.\n\n1.  **Analyze Input:**\n    *   Determine the `background_color`: Find the most frequent color in the input grid, excluding gray (color 5). Gray acts as noise.\n    *   Define `noise_color` = 5.\n    *   Define `significant_threshold` = 4 (components must have > 4 pixels).\n    *   Define `pattern_size` = 6.\n\n2.  **Pad Input:** Create a padded version of the input grid by adding a border of `background_color` pixels. The padding width should be at least `pattern_size - 1` (e.g., 6) to ensure any 6x6 extraction starting from an original grid coordinate is valid within the padded grid.\n\n3.  **Find Significant Components:**\n    *   Identify all connected components (using 8-way adjacency) in the *original* input grid for any color that is *not* the `background_color` and *not* the `noise_color`.\n    *   Filter these components, keeping only the \"significant components\" whose size (pixel count) is greater than `significant_threshold`.\n\n4.  **Generate and Clean Patterns:**\n    *   For each significant component found:\n        *   Determine its `primary_color`.\n        *   Find its top-left bounding box coordinate `(min_r, min_c)` relative to the *original* grid.\n        *   Extract a `pattern_size` x `pattern_size` (6x6) subgrid (the `raw_pattern`) from the *padded* grid. The extraction starts at the coordinate corresponding to `(min_r, min_c)` in the original grid (i.e., `padded_grid[min_r + pad_width : min_r + pad_width + 6, min_c + pad_width : min_c + pad_width + 6]`).\n        *   Create a new `pattern_size` x `pattern_size` \"cleaned pattern\" grid, initialized with the `background_color`.\n        *   Copy pixels from the `raw_pattern` to the `cleaned_pattern` *only* if the pixel's color in the `raw_pattern` matches either the `primary_color` or the `background_color`. All other pixels in the `cleaned_pattern` remain `background_color`.\n        *   Store this `cleaned_pattern` along with its origin coordinate `(min_r, min_c)`.\n\n5.  **Sort Patterns:** Arrange the generated `cleaned_patterns` in order based on their corresponding `(min_r, min_c)` coordinates, sorting primarily by row (`min_r`) and secondarily by column (`min_c`).\n\n6.  **Combine Patterns:** Vertically stack the sorted `cleaned_patterns` to produce the final output grid. If no significant components were found, the output is an empty grid with 0 rows and `pattern_size` columns.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\n# --- Helper Functions ---\n\ndef find_background_color(grid):\n    \"\"\"\n    Finds the most frequent color in the grid, ignoring gray (5) unless it's \n    the only significant color present besides potentially black/white (0).\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(colors, counts))\n    noise_color = 5\n\n    potential_bg_colors = {c: count for c, count in color_counts.items() if c != noise_color}\n\n    if not potential_bg_colors:\n        if noise_color in color_counts:\n            return noise_color\n        else: \n            return 0 # Default for empty or all-zero grid\n            \n    background_color = max(potential_bg_colors, key=potential_bg_colors.get)\n    return background_color\n\ndef find_components(grid, colors_to_find):\n    \"\"\"\n    Finds all connected components for a set of target colors using 8-way adjacency.\n    Returns a list of dicts: {'color': color, 'pixels': list_of_tuples, 'size': int}.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    all_components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in colors_to_find and not visited[r, c]:\n                component_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    component_pixels.append((row, col))\n                    \n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue\n                            nr, nc = row + dr, col + dc\n                            \n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component_pixels: \n                    all_components.append({\n                        'color': color, \n                        'pixels': component_pixels, \n                        'size': len(component_pixels)\n                    })\n                    \n    return all_components\n\ndef get_bounding_box_top_left(component_pixels):\n    \"\"\"Calculates the top-left coordinate (min_row, min_col) for a component.\"\"\"\n    if not component_pixels:\n        return 0, 0 \n    rows = [p[0] for p in component_pixels]\n    cols = [p[1] for p in component_pixels]\n    min_row = min(rows)\n    min_col = min(cols)\n    return min_row, min_col\n\ndef clean_pattern(raw_pattern, primary_color, background_color):\n    \"\"\"\n    Creates a cleaned 6x6 pattern. Keeps only the primary color and background \n    color pixels from the raw_pattern. All others become background color.\n    \"\"\"\n    cleaned = np.full_like(raw_pattern, background_color)\n    rows, cols = raw_pattern.shape\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = raw_pattern[r, c]\n            if pixel_color == primary_color or pixel_color == background_color:\n                cleaned[r, c] = pixel_color\n    return cleaned\n\n# --- Main Transform Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on extracting, cleaning, sorting, and \n    stacking 6x6 patterns from significant components, using padding to handle\n    boundary conditions.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    if input_grid.size == 0:\n         return np.empty((0, 6), dtype=int).tolist() # Handle empty input\n\n    rows, cols = input_grid.shape\n    noise_color = 5\n    significant_threshold = 4 \n    pattern_size = 6\n    padding_width = pattern_size # Use padding width = pattern_size for safety\n\n    # 1. Identify Background color\n    background_color = find_background_color(input_grid)\n\n    # 2. Pad Input Grid\n    padded_grid = np.pad(\n        input_grid, \n        pad_width=padding_width, \n        mode='constant', \n        constant_values=background_color\n    )\n\n    # 3. Find Significant Components in the original grid\n    present_colors = np.unique(input_grid)\n    component_colors_to_find = {\n        c for c in present_colors if c != background_color and c != noise_color\n    }\n    all_found_components = find_components(input_grid, component_colors_to_find)\n\n    # 4. Generate and Clean Patterns\n    pattern_data = [] # List to store ((min_r, min_c), cleaned_pattern)\n    \n    for comp_info in all_found_components:\n        # Check if component is significant\n        if comp_info['size'] > significant_threshold:\n            primary_color = comp_info['color']\n            component_pixels = comp_info['pixels']\n            \n            # Get top-left coordinate relative to original grid\n            min_r, min_c = get_bounding_box_top_left(component_pixels)\n            coord = (min_r, min_c)\n\n            # Extract the raw 6x6 pattern area from the padded grid\n            # Adjust coordinates for padding\n            padded_r_start = min_r + padding_width\n            padded_c_start = min_c + padding_width\n            raw_pattern = padded_grid[\n                padded_r_start : padded_r_start + pattern_size,\n                padded_c_start : padded_c_start + pattern_size\n            ]\n            \n            # Ensure raw_pattern is exactly 6x6 (should be due to padding)\n            if raw_pattern.shape == (pattern_size, pattern_size):\n                 # Create the cleaned pattern\n                 cleaned = clean_pattern(raw_pattern, primary_color, background_color)\n                 \n                 # Store the original coordinate and the cleaned pattern\n                 pattern_data.append((coord, cleaned))\n            # else: handle potential edge cases if padding wasn't sufficient (unlikely with pad_width=6)\n                 # print(f\"Warning: extracted pattern size mismatch for coord {coord}. Shape: {raw_pattern.shape}\")\n\n\n    # 5. Sort patterns based on coordinates (row, then column)\n    pattern_data.sort(key=lambda item: item[0])\n\n    # 6. Assemble Output: Vertically stack the sorted patterns\n    if not pattern_data:\n        # If no significant components were found, return empty 0x6 grid\n        output_grid = np.empty((0, pattern_size), dtype=int)\n    else:\n        # Extract just the cleaned patterns in sorted order\n        sorted_patterns = [item[1] for item in pattern_data]\n        # Stack them vertically\n        output_grid = np.vstack(sorted_patterns)\n\n    # Convert back to list of lists for ARC standard output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 8158,
            "end_index": 8490,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24095,
    "candidates_token_count": 2466,
    "total_token_count": 26561,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.249884,
  "retries": null
}