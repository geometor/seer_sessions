{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule involves identifying distinct colored shapes (components) in the input grid, excluding the background color and a noise color (gray, 5). For each identified shape component, a 6x6 pixel area starting at the component's top-left bounding box corner is extracted from the input grid. This 6x6 area is then \"cleaned\" to contain only the pixels matching the component's color (the primary color for this pattern) and the background color; all other pixels within the 6x6 area are replaced with the background color. These cleaned 6x6 patterns are then sorted based on the top-left coordinates of their corresponding components in the original input grid (first by row, then by column). Finally, the sorted, cleaned 6x6 patterns are vertically stacked to form the output grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"\n    Finds the most frequent color in the grid, ignoring gray (5) unless it's \n    the only non-zero count color besides gray.\n    Assumes background is the most prevalent color.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    \n    # Create a dictionary of counts excluding gray (5)\n    counts_without_noise = {color: count for color, count in zip(colors, counts) if color != 5}\n    \n    if not counts_without_noise:\n        # If only gray (5) or nothing else is present, return gray or the most frequent (which would be gray)\n        # Or default to 0 if grid is empty or has only 0s? Let's return most frequent overall.\n         if len(colors) > 0:\n             return colors[np.argmax(counts)]\n         else:\n             return 0 # Default background for empty grid\n\n    # Find the color with the max count among non-gray colors\n    background_color = max(counts_without_noise, key=counts_without_noise.get)\n    \n    # Handle edge case where background itself might be 0 count if only gray exists beside it\n    if counts_without_noise[background_color] == 0 and 5 in colors:\n         # This implies only gray and maybe 0s are present. Return gray.\n         return 5\n         \n    return background_color\n\ndef find_color_specific_components(grid, target_color):\n    \"\"\"\n    Finds connected components of a specific target_color using 8-way adjacency.\n    Returns a list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is the target color and hasn't been visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                # Start BFS for this component\n                while q:\n                    row, col = q.pop(0)\n                    component_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor is the target color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == target_color and \\\n                               not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component_pixels: # Should always be true here\n                    components.append(component_pixels)\n                    \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a component.\"\"\"\n    if not component:\n        return 0, 0, -1, -1 # Indicate invalid/empty component\n    rows = [p[0] for p in component]\n    cols = [p[1] for p in component]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef clean_pattern(raw_pattern, primary_color, background_color):\n    \"\"\"\n    Creates a cleaned 6x6 pattern by keeping only the primary color and background color pixels.\n    All other pixels are replaced with the background color.\n    \"\"\"\n    cleaned = np.full_like(raw_pattern, background_color)\n    rows, cols = raw_pattern.shape\n    for r in range(rows):\n        for c in range(cols):\n            if raw_pattern[r, c] == primary_color or raw_pattern[r, c] == background_color:\n                cleaned[r, c] = raw_pattern[r, c]\n    return cleaned\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts 6x6 patterns from the input grid based on non-background/non-noise components,\n    cleans them, sorts them by position, and stacks them vertically.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n    noise_color = 5\n\n    # 1. Determine background color\n    background_color = find_background_color(input_grid)\n\n    # 2. Find all potential component colors\n    potential_component_colors = np.unique(input_grid)\n    \n    patterns_map = {} # Use dict to store patterns keyed by coord to handle overlaps/duplicates simply\n\n    # 3. Find components for each potential color\n    for color in potential_component_colors:\n        if color == background_color or color == noise_color:\n            continue # Skip background and noise colors\n\n        # Find all components of this specific color\n        components_of_this_color = find_color_specific_components(input_grid, color)\n\n        # 4. Process each component\n        for component in components_of_this_color:\n            if not component:\n                continue\n                \n            primary_color = color # The color of this component is the primary color for the pattern\n\n            # 4a. Get bounding box and top-left coordinate\n            min_r, min_c, _, _ = get_bounding_box(component)\n            coord = (min_r, min_c)\n\n            # 4b. Check if a 6x6 area starting at coord fits in the grid\n            if min_r + 6 <= rows and min_c + 6 <= cols:\n                # 4c. Extract the raw 6x6 pattern area\n                raw_pattern = input_grid[min_r:min_r+6, min_c:min_c+6]\n                \n                # 4d. Create the cleaned pattern\n                cleaned = clean_pattern(raw_pattern, primary_color, background_color)\n                \n                # 4e. Store the cleaned pattern, keyed by coordinate.\n                # If another component starts at the same coord, this will overwrite.\n                # Based on examples, this seems acceptable; the first component found (order depends on iteration)\n                # or the last component found for a coord will dictate the pattern. Sorting later ensures order.\n                patterns_map[coord] = cleaned\n\n    # 5. Sort patterns based on coordinates\n    sorted_coords = sorted(patterns_map.keys())\n    \n    if not sorted_coords:\n        # Handle cases where no valid patterns are found. Return an empty grid.\n        # Determine output width (should be 6 if any pattern is found, otherwise maybe 0?)\n        # Based on tests, returning 0x0 or 0xN seems appropriate. Let's try 0x6.\n        return np.empty((0, 6), dtype=int).tolist() \n        \n    sorted_patterns = [patterns_map[coord] for coord in sorted_coords]\n\n    # 6. Assemble Output: Vertically stack the sorted patterns\n    output_grid = np.vstack(sorted_patterns)\n\n    return output_grid.tolist() # Convert back to list of lists for ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 15904,
            "end_index": 16240,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5334,
    "candidates_token_count": 1968,
    "total_token_count": 7302,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.591956,
  "retries": null
}