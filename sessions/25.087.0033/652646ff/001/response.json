{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    # Ignore gray (5) if present when determining background, unless it's the *only* color\n    non_noise_indices = np.where(colors != 5)[0]\n    if len(non_noise_indices) > 0:\n        background_index = non_noise_indices[np.argmax(counts[non_noise_indices])]\n    else:\n        # If only gray is present, it's the background (unlikely based on examples)\n        background_index = np.argmax(counts)\n    return colors[background_index]\n\ndef find_connected_components(grid, background_color, noise_color=5):\n    \"\"\"\n    Finds connected components of non-background, non-noise pixels using 8-way adjacency.\n    Returns a list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is a candidate and hasn't been visited\n            if grid[r, c] != background_color and grid[r, c] != noise_color and not visited[r, c]:\n                component = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                # Start BFS for this component\n                while q:\n                    row, col = q.pop(0)\n                    component.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor is a candidate and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != background_color and \\\n                               grid[nr, nc] != noise_color and \\\n                               not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component: # Should always be true here, but good practice\n                    components.append(component)\n                    \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a component.\"\"\"\n    rows = [p[0] for p in component]\n    cols = [p[1] for p in component]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef find_primary_color(subgrid, background_color, noise_color=5):\n    \"\"\"Finds the most frequent non-background, non-noise color in a subgrid.\"\"\"\n    colors, counts = np.unique(subgrid, return_counts=True)\n    \n    valid_indices = [i for i, color in enumerate(colors) if color != background_color and color != noise_color]\n    \n    if not valid_indices:\n        # This case shouldn't happen if component finding is correct, but handle defensively\n        # Return background if no other color is present (though this implies the component was empty/invalid)\n        return background_color \n        \n    primary_index_in_valid = np.argmax(counts[valid_indices])\n    primary_index_in_colors = valid_indices[primary_index_in_valid]\n    \n    return colors[primary_index_in_colors]\n\ndef clean_pattern(raw_pattern, primary_color, background_color):\n    \"\"\"Creates a cleaned 6x6 pattern.\"\"\"\n    cleaned = np.full_like(raw_pattern, background_color)\n    for r in range(raw_pattern.shape[0]):\n        for c in range(raw_pattern.shape[1]):\n            if raw_pattern[r, c] == primary_color or raw_pattern[r, c] == background_color:\n                cleaned[r, c] = raw_pattern[r, c]\n    return cleaned\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts 6x6 patterns from the input grid, cleans them by keeping only their \n    primary non-background/non-noise color and the background color, sorts them \n    by their top-left position (row, then column), and stacks them vertically \n    to produce the output grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    noise_color = 5\n\n    # 1. Analyze Input: Determine background color\n    background_color = find_background_color(input_grid)\n\n    # 2. & 3. Identify and Group Pattern Candidates: Find connected components\n    components = find_connected_components(input_grid, background_color, noise_color)\n\n    cleaned_patterns_with_coords = []\n\n    # 4. Filter by Size & 5. Extract and Clean\n    for component in components:\n        min_r, min_c, max_r, max_c = get_bounding_box(component)\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        # Keep only components with exactly 6x6 bounding box\n        if height == 6 and width == 6:\n            top_left_coord = (min_r, min_c)\n            \n            # 5b. Extract the raw 6x6 pattern area\n            raw_pattern = input_grid[min_r:min_r+6, min_c:min_c+6]\n            \n            # 5c. Identify the primary color\n            primary_color = find_primary_color(raw_pattern, background_color, noise_color)\n            \n            # 5d. Create the cleaned pattern\n            cleaned = clean_pattern(raw_pattern, primary_color, background_color)\n            \n            # 5e. Store the cleaned pattern and its coordinate\n            cleaned_patterns_with_coords.append({'coord': top_left_coord, 'pattern': cleaned})\n\n    # 6. Sort Patterns by coordinate (row, then column)\n    cleaned_patterns_with_coords.sort(key=lambda x: (x['coord'][0], x['coord'][1]))\n\n    # 7. Assemble Output: Vertically stack the sorted patterns\n    if not cleaned_patterns_with_coords:\n        # Handle cases where no valid patterns are found (return empty or specific grid?)\n        # Based on examples, this is unlikely. Let's return an empty 0x6 grid.\n        return np.empty((0, 6), dtype=int) \n        \n    sorted_patterns = [item['pattern'] for item in cleaned_patterns_with_coords]\n    output_grid = np.vstack(sorted_patterns)\n\n    return output_grid.tolist() # Convert back to list of lists for ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4843,
    "candidates_token_count": 1710,
    "total_token_count": 6553,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.822587,
  "retries": null
}