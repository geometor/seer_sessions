{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\n1. **Analyze Input:** Determine the `background_color` by finding the most frequent color in the input grid, excluding gray (color 5). Note that gray (5) acts as `noise_color`.\n2. **Find Significant Shapes:** Identify all connected components (using 8-way adjacency) of any color that is *not* the `background_color` and *not* the `noise_color` (gray). From these, select only the \"significant components\" which are defined as components having more than 4 pixels.\n3. **Extract and Clean Patterns:** For each significant component identified:\n    * Find its top-left bounding box coordinate, `(min_r, min_c)`.\n    * Check if a 6x6 area starting at `(min_r, min_c)` fits within the input grid dimensions.\n    * If it fits, extract the 6x6 subgrid (the \"raw pattern\"). Let the color of this significant component be the `primary_color`.\n    * Create a new 6x6 \"cleaned pattern\" grid. Fill it by copying pixels from the raw pattern only if they match the `primary_color` or the `background_color`. Replace all other pixels with the `background_color`.\n    * Store this cleaned pattern along with its origin coordinate `(min_r, min_c)`.\n4. **Sort:** Arrange the generated cleaned patterns in order based on their `(min_r, min_c)` coordinates, sorting primarily by row (`min_r`) and secondarily by column (`min_c`).\n5. **Combine:** Vertically stack the sorted cleaned patterns to produce the final output grid. If no significant components were found that fit the 6x6 extraction criteria, the output is an empty grid with 0 rows and 6 columns.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"\n    Finds the most frequent color in the grid, ignoring gray (5) unless it's \n    the only significant color present besides potentially black/white (0).\n    Assumes background is the most prevalent color after filtering noise.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(colors, counts))\n    noise_color = 5\n\n    # Filter out noise color for background calculation, unless it's dominant\n    potential_bg_colors = {c: count for c, count in color_counts.items() if c != noise_color}\n\n    if not potential_bg_colors:\n        # Only noise color (and maybe 0) present, background is noise color or 0\n        if noise_color in color_counts:\n            return noise_color\n        else: \n            return 0 # Default for empty or all-zero grid\n            \n    # Find the color with the highest count among non-noise colors\n    background_color = max(potential_bg_colors, key=potential_bg_colors.get)\n    \n    return background_color\n\ndef find_components(grid, colors_to_find):\n    \"\"\"\n    Finds all connected components for a set of target colors using 8-way adjacency.\n    Returns a list of tuples: (color, component_pixels), where component_pixels \n    is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    all_components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the pixel is one of the target colors and hasn't been visited\n            if color in colors_to_find and not visited[r, c]:\n                component_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                # Start BFS for this component\n                while q:\n                    row, col = q.pop(0)\n                    component_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor is the same color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and \\\n                               not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component_pixels: # Should always be true here\n                    all_components.append({'color': color, 'pixels': component_pixels})\n                    \n    return all_components\n\ndef get_bounding_box(component_pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a component.\"\"\"\n    if not component_pixels:\n        return 0, 0, -1, -1 # Indicate invalid/empty component\n    rows = [p[0] for p in component_pixels]\n    cols = [p[1] for p in component_pixels]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef clean_pattern(raw_pattern, primary_color, background_color):\n    \"\"\"\n    Creates a cleaned 6x6 pattern. Keeps only the primary color and background \n    color pixels. All other pixels are replaced with the background color.\n    \"\"\"\n    cleaned = np.full_like(raw_pattern, background_color)\n    rows, cols = raw_pattern.shape\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = raw_pattern[r, c]\n            if pixel_color == primary_color or pixel_color == background_color:\n                cleaned[r, c] = pixel_color\n    return cleaned\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on extracting, cleaning, sorting, and \n    stacking 6x6 patterns from significant components.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n    noise_color = 5\n    min_component_size = 4 # Significant components must have > 4 pixels\n\n    # 1. Identify Background and Noise colors\n    background_color = find_background_color(input_grid)\n\n    # 2. Find potential component colors (all colors except background and noise)\n    present_colors = np.unique(input_grid)\n    component_colors_to_find = {c for c in present_colors if c != background_color and c != noise_color}\n\n    # 3. Find all components for the target colors\n    all_found_components = find_components(input_grid, component_colors_to_find)\n\n    # 4. Filter for significant components and extract/clean patterns\n    pattern_data = [] # List to store ((min_r, min_c), cleaned_pattern)\n    \n    for comp_info in all_found_components:\n        component_pixels = comp_info['pixels']\n        primary_color = comp_info['color']\n        \n        # Check if component is significant (size > min_component_size)\n        if len(component_pixels) > min_component_size:\n            # Get bounding box and top-left coordinate\n            min_r, min_c, _, _ = get_bounding_box(component_pixels)\n            coord = (min_r, min_c)\n\n            # Check if a 6x6 area starting at coord fits within the grid\n            if min_r + 6 <= rows and min_c + 6 <= cols:\n                # Extract the raw 6x6 pattern area\n                raw_pattern = input_grid[min_r:min_r+6, min_c:min_c+6]\n                \n                # Create the cleaned pattern\n                cleaned = clean_pattern(raw_pattern, primary_color, background_color)\n                \n                # Store the coordinate and the cleaned pattern\n                pattern_data.append((coord, cleaned))\n\n    # 5. Sort patterns based on coordinates (row, then column)\n    pattern_data.sort(key=lambda item: item[0])\n\n    # 6. Assemble Output: Vertically stack the sorted patterns\n    if not pattern_data:\n        # If no significant components were found or fit, return empty 0x6 grid\n        output_grid = np.empty((0, 6), dtype=int)\n    else:\n        # Extract just the cleaned patterns in sorted order\n        sorted_patterns = [item[1] for item in pattern_data]\n        # Stack them vertically\n        output_grid = np.vstack(sorted_patterns)\n\n    # Convert back to list of lists for ARC standard output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12475,
    "candidates_token_count": 2097,
    "total_token_count": 14572,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.310184,
  "retries": null
}