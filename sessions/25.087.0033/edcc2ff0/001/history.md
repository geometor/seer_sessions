
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 2 3 8 3
3 1 1 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 2 2 3 3 3 3 8 3
3 3 3 3 3 3 3 3 3 3
3 3 8 8 3 3 3 3 3 3
3 3 8 8 3 4 4 4 3 3
3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3
3 2 2 3 3 3 3 2 2 3
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 3 3 3 3 2 3 8 3
3 3 2 2 3 3 3 3 8 3
3 3 3 3 3 3 3 3 3 3
3 3 8 8 3 3 3 3 3 3
3 3 8 8 3 4 4 4 3 3
3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3
3 2 2 3 3 3 3 2 2 3
3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
1 2 2 1 1 1 1 1 1 1
1 2 1 1 1 2 2 1 3 1
1 1 1 1 1 2 2 1 3 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 8 1 1 3 3 1 1 1
1 1 8 1 1 3 3 1 1 1
1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
1 2 2 1 1 1 1 1 1 1
1 2 1 1 1 2 2 1 3 1
1 1 1 1 1 2 2 1 3 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 3 3 1 1 1
1 1 1 1 1 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8
8 2 2 8 8 8 8 8 4 8
8 8 8 8 8 8 1 8 4 8
8 6 8 4 4 8 1 8 8 8
8 6 8 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 4 8 2 2 8 8 3 3 8
8 4 8 8 8 8 8 8 8 8
8 8 8 8 8 6 6 8 8 8
8 8 1 8 8 6 6 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 4 4 4 4 8
8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8
8 2 2 8 8 8 8 8 4 8
8 8 8 8 8 8 1 8 4 8
8 8 8 4 4 8 1 8 8 8
8 8 8 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 4 8 2 2 8 8 8 8 8
8 4 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 4 4 4 4 8
8 8 8 8 8 8 8 8 8 8
```

*   **Perception**
    *   The input and output grids are visually divided into two main sections: a top "control" section and a bottom "data" section.
    *   The division appears to be marked by the first row that is composed entirely of a single non-white color. In all examples, this is row 7.
    *   The top section (rows 0-6) consists mostly of white pixels, with a few isolated non-white pixels located exclusively in the first column (column 0).
    *   The bottom section (row 7 onwards) contains a background color filling most of the space, with various smaller objects of different colors embedded within it.
    *   The transformation only affects the top section; the bottom section remains identical between input and output.
    *   The color of each non-white pixel in the first column of the top section acts as a key.
    *   The transformation involves counting the number of distinct, connected objects (including diagonal connections) of that key color within the bottom section.
    *   This count determines the length of a horizontal line drawn in the output grid, starting from the position of the key pixel in the top section.
    *   The line is drawn using the key color.
    *   If the count of objects for a key color is zero, the corresponding key pixel in the top section is turned white in the output.

*   **Facts**
    
```yaml
    grid_structure:
      type: two_sections
      sections: [control, data]
      separator: first_row_fully_non_white
    control_section:
      location: rows_above_separator
      content: sparse_pixels_on_white_background
      key_elements: non_white_pixels_in_column_0
    data_section:
      location: rows_from_separator_downwards
      content: background_color_with_embedded_objects
      role: source_for_transformation_parameters
    object_definition:
      criteria: contiguous_block_of_same_color
      adjacency: horizontal_vertical_diagonal
      location_constraint: must_be_within_data_section
    transformation:
      target: control_section
      based_on: key_elements_in_control_section
      steps:
        - for_each: non_white_pixel (color C) at (r, 0) in control_section
        - calculate: N = count_objects_of_color C in data_section
        - condition:
            if: N > 0
            action: draw_horizontal_line
            line_properties:
              start_position: (r, 0)
              color: C
              length: N
            else: # N == 0
            action: set_pixel_white
            pixel_properties:
              position: (r, 0)
              color: white (0)
      unmodified_area: data_section
    ```


*   **Natural Language Program**
    1.  Identify the separator row, which is the first row from the top (row index `sep_row`) that contains no white pixels.
    2.  Define the "control section" as rows 0 to `sep_row - 1`.
    3.  Define the "data section" as rows `sep_row` to the bottom of the grid.
    4.  Create a copy of the input grid to serve as the basis for the output grid.
    5.  Iterate through each row `r` in the control section (from 0 to `sep_row - 1`).
    6.  Examine the pixel at column 0 in the current row: `input_grid[r][0]`. Let its color be `C`.
    7.  If `C` is not white (i.e., `C != 0`):
        a.  Count the number (`N`) of distinct connected objects of color `C` within the data section (rows `sep_row` onwards). Consider pixels connected horizontally, vertically, or diagonally as part of the same object.
        b.  If `N` is greater than 0:
            i.  In the output grid, change the color of pixels from `(r, 0)` to `(r, N-1)` (inclusive) to color `C`. Make sure not to go beyond the grid's width boundary.
            ii. Set any remaining pixels in that row `r` from column `N` onwards to white (0).
        c.  If `N` is equal to 0:
            i.  In the output grid, change the color of the pixel at `(r, 0)` to white (0).
    8.  If `C` is white (i.e., `C == 0`), make no changes to row `r` in the output grid (it remains as it was copied from the input, which should be all white in the control section except for column 0 potentially).
    9.  The data section (rows `sep_row` onwards) in the output grid remains identical to the input grid's data section.
    10. Return the modified grid as the output.
