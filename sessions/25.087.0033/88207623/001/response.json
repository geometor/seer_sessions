{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThe transformation rule identifies vertical red lines (axes) and adjacent yellow shapes in the input grid. \nFor each red axis and its associated yellow shape, it finds the single, non-background, non-red, non-yellow pixel (source color pixel) that is closest to the combined axis/shape structure. \nIt then reflects the yellow shape across the red axis. The reflected pixels are colored with the color of the closest source pixel. \nThis reflection only changes pixels that were originally white (background) in the input grid. \nAll original non-white pixels are preserved in the output.\n\"\"\"\n\ndef find_pixels_with_color(grid, color):\n    \"\"\"Finds all pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_closest_source_pixel(target_pixels, source_pixels):\n    \"\"\"\n    Finds the source pixel closest to any pixel in the target set.\n    \n    Args:\n        target_pixels: List of coordinates [(r, c), ...] representing the target shape/axis.\n        source_pixels: List of source pixel info [(r, c, color), ...].\n\n    Returns:\n        The color of the closest source pixel, or None if no source pixels are found.\n    \"\"\"\n    if not source_pixels or not target_pixels:\n        return None\n\n    min_dist = float('inf')\n    closest_source_color = None\n\n    for sr, sc, scolor in source_pixels:\n        current_min_dist_for_source = float('inf')\n        for tr, tc in target_pixels:\n            dist = manhattan_distance((sr, sc), (tr, tc))\n            current_min_dist_for_source = min(current_min_dist_for_source, dist)\n        \n        if current_min_dist_for_source < min_dist:\n            min_dist = current_min_dist_for_source\n            closest_source_color = scolor\n        # Note: Implicitly handles ties by taking the first one found with the min distance.\n\n    return closest_source_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on red axes, yellow shapes, and source color pixels.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # --- Identify components ---\n    \n    # Find all red pixels (potential axis parts)\n    red_pixels = find_pixels_with_color(input_grid, 2)\n    \n    # Find all source color pixels (non-0, non-2, non-4)\n    source_pixels = []\n    for r in range(height):\n        for c in range(width):\n            color = input_grid[r, c]\n            if color not in [0, 2, 4]:\n                source_pixels.append((r, c, color))\n\n    # --- Process Red Axes ---\n    \n    visited_red = set() # To avoid processing parts of the same axis multiple times\n    \n    for r_start, c_axis in red_pixels:\n        if (r_start, c_axis) in visited_red:\n            continue\n\n        # 1. Find the full vertical red axis starting from this pixel\n        current_axis_pixels = []\n        r = r_start\n        while r < height and input_grid[r, c_axis] == 2:\n            if (r, c_axis) in visited_red: # Check if part of an already processed axis\n                 # If we hit a visited part, stop building this segment *but* consider it part of the current axis for finding yellow/source\n                 # This handles cases where axes might be detected starting from the middle\n                 r_check = r\n                 while r_check < height and input_grid[r_check, c_axis] == 2:\n                     current_axis_pixels.append((r_check, c_axis))\n                     visited_red.add((r_check, c_axis))\n                     r_check += 1\n                 break # Stop extending downwards from the initial start\n            current_axis_pixels.append((r, c_axis))\n            visited_red.add((r, c_axis))\n            r += 1\n            \n        # Also check upwards from start just in case we didn't start at the top\n        r = r_start - 1\n        while r >= 0 and input_grid[r, c_axis] == 2:\n             if (r, c_axis) in visited_red: # Already processed this upper part\n                 break\n             # Prepend to keep order if needed, though order doesn't matter for coord list\n             current_axis_pixels.insert(0, (r, c_axis)) \n             visited_red.add((r, c_axis))\n             r -= 1\n\n\n        if not current_axis_pixels: # Should not happen if we started with a red pixel, but safety check\n            continue\n\n        # 2. Find adjacent yellow pixels for this specific axis\n        adjacent_yellow_pixels = []\n        shape_side = None # 'left' or 'right'\n        \n        for r_ax, c_ax in current_axis_pixels:\n            # Check left neighbor\n            if c_ax > 0 and input_grid[r_ax, c_ax - 1] == 4:\n                adjacent_yellow_pixels.append((r_ax, c_ax - 1))\n                if shape_side is None: shape_side = 'left'\n                elif shape_side == 'right': shape_side = 'both' # Problematic case, maybe indicates separate structures using same axis part? Let's assume simple cases first.\n                \n            # Check right neighbor\n            if c_ax < width - 1 and input_grid[r_ax, c_ax + 1] == 4:\n                adjacent_yellow_pixels.append((r_ax, c_ax + 1))\n                if shape_side is None: shape_side = 'right'\n                elif shape_side == 'left': shape_side = 'both'\n\n        # Remove duplicates if a yellow pixel is adjacent to multiple axis pixels\n        adjacent_yellow_pixels = list(set(adjacent_yellow_pixels))\n\n        if not adjacent_yellow_pixels or shape_side == 'both':\n             # If no yellow pixels found adjacent to this axis segment, or yellow on both sides (ambiguous/not expected by examples), skip.\n            continue\n\n        # 3. Find the closest source color for this axis + shape structure\n        structure_pixels = current_axis_pixels + adjacent_yellow_pixels\n        reflection_color = find_closest_source_pixel(structure_pixels, source_pixels)\n\n        if reflection_color is None: # No source color found\n            continue\n\n        # 4. Perform reflection\n        for r_yellow, c_yellow in adjacent_yellow_pixels:\n            # Find the specific red pixel it's adjacent to (must exist by definition)\n            c_axis = c_yellow + 1 if shape_side == 'left' else c_yellow - 1\n            \n            # Calculate reflected coordinates\n            if shape_side == 'left':\n                c_reflected = c_axis + (c_axis - c_yellow)\n            else: # shape_side == 'right'\n                c_reflected = c_axis - (c_yellow - c_axis)\n            r_reflected = r_yellow # Row stays the same\n\n            # Check bounds and if the original target pixel is background (white)\n            if 0 <= r_reflected < height and 0 <= c_reflected < width:\n                if input_grid[r_reflected, c_reflected] == 0:\n                    output_grid[r_reflected, c_reflected] = reflection_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4488,
    "candidates_token_count": 1881,
    "total_token_count": 6369,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.749704,
  "retries": null
}