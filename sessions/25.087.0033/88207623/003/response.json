{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule identifies vertical red lines (axes) and adjacent connected yellow shapes in the input grid.\nFor each red axis and an associated adjacent yellow shape:\n1.  The 'structure' is defined as the union of all pixels in the axis and the connected yellow shape.\n2.  The single 'source' pixel (non-background, non-red, non-yellow) closest (Manhattan distance) to any pixel in the 'structure' is found. Its color is the 'reflection_color'.\n3.  The yellow shape is reflected across the vertical red axis.\n4.  Pixels in the output grid corresponding to the reflected shape's positions are colored with the 'reflection_color', but only if those pixels were originally background (white, color 0) in the input grid.\n5.  All original non-white pixels from the input grid are preserved in the output grid.\n\"\"\"\n\ndef find_pixels_with_color(grid, color):\n    \"\"\"Finds all pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_connected_component(grid, start_coord, target_color):\n    \"\"\"\n    Finds all connected pixels of target_color starting from start_coord using BFS.\n    Handles 4-connectivity (up, down, left, right). Diagonal is not adjacency for components.\n    \"\"\"\n    height, width = grid.shape\n    component_pixels = set()\n    q = deque([start_coord])\n    visited_component = {start_coord} # Keep track of visited during this specific BFS\n\n    while q:\n        r, c = q.popleft()\n        if grid[r, c] == target_color:\n            component_pixels.add((r, c))\n            # Check neighbors (4-connectivity)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < height and 0 <= nc < width and \\\n                   grid[nr, nc] == target_color and (nr, nc) not in visited_component:\n                    visited_component.add((nr, nc))\n                    q.append((nr, nc))\n                    \n    return list(component_pixels)\n\n\ndef find_closest_source_pixel(target_pixels, source_pixels):\n    \"\"\"\n    Finds the source pixel closest to any pixel in the target set (structure).\n\n    Args:\n        target_pixels: List of coordinates [(r, c), ...] representing the target structure (axis + shape).\n        source_pixels: List of source pixel info [(r, c, color), ...].\n\n    Returns:\n        The color of the closest source pixel, or None if no source pixels are found.\n    \"\"\"\n    if not source_pixels or not target_pixels:\n        return None\n\n    min_dist = float('inf')\n    closest_source_color = None\n\n    # Pre-calculate distances from each source to the structure\n    for sr, sc, scolor in source_pixels:\n        current_min_dist_for_source = float('inf')\n        for tr, tc in target_pixels:\n            dist = manhattan_distance((sr, sc), (tr, tc))\n            current_min_dist_for_source = min(current_min_dist_for_source, dist)\n\n        # Check if this source pixel is closer than the best found so far\n        if current_min_dist_for_source < min_dist:\n            min_dist = current_min_dist_for_source\n            closest_source_color = scolor\n        # Tie-breaking: first one found with the minimum distance wins (implicit)\n\n    return closest_source_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on red axes, connected yellow shapes, and source color pixels.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # --- Identify components ---\n    \n    # Find all red pixels (potential axis parts)\n    red_pixels = find_pixels_with_color(input_grid, 2)\n\n    # Find all source color pixels (non-0, non-2, non-4)\n    source_pixels = []\n    for r in range(height):\n        for c in range(width):\n            color = input_grid[r, c]\n            if color not in [0, 2, 4]:\n                source_pixels.append((r, c, color))\n\n    # --- Process Red Axes and Adjacent Shapes ---\n\n    visited_red = set() # To avoid processing parts of the same axis multiple times\n    processed_yellow_pixels = set() # To avoid processing the same shape multiple times if it touches axis at >1 point\n\n    for r_start, c_axis in red_pixels:\n        if (r_start, c_axis) in visited_red:\n            continue\n\n        # 1. Find the full vertical red axis starting from this potential point\n        current_axis_pixels = []\n        \n        # Explore downwards\n        r = r_start\n        temp_down = []\n        while r < height and input_grid[r, c_axis] == 2:\n            if (r, c_axis) in visited_red:\n                break # Stop if we hit an already processed part downwards\n            temp_down.append((r, c_axis))\n            r += 1\n        \n        # Explore upwards\n        r = r_start - 1\n        temp_up = []\n        while r >= 0 and input_grid[r, c_axis] == 2:\n            if (r, c_axis) in visited_red:\n                 break # Stop if we hit an already processed part upwards\n            temp_up.append((r, c_axis))\n            r -= 1\n            \n        current_axis_pixels = temp_up[::-1] + temp_down # Combine ensuring order if needed (though set ops used later)\n        \n        # Mark all found axis pixels as visited\n        for r_ax, c_ax in current_axis_pixels:\n             visited_red.add((r_ax, c_ax))\n\n        if not current_axis_pixels:\n            continue # Should not happen if r_start, c_axis was red, but safety check\n\n        # 2. Find *seed* yellow pixels adjacent to this axis\n        adjacent_yellow_seeds = []\n        shape_sides = {} # Store side ('left'/'right') for each seed: {(r,c): side}\n\n        for r_ax, c_ax in current_axis_pixels:\n            # Check left neighbor\n            if c_ax > 0 and input_grid[r_ax, c_ax - 1] == 4:\n                seed = (r_ax, c_ax - 1)\n                if seed not in processed_yellow_pixels:\n                    adjacent_yellow_seeds.append(seed)\n                    shape_sides[seed] = 'left'\n                    \n            # Check right neighbor\n            if c_ax < width - 1 and input_grid[r_ax, c_ax + 1] == 4:\n                seed = (r_ax, c_ax + 1)\n                if seed not in processed_yellow_pixels:\n                     adjacent_yellow_seeds.append(seed)\n                     shape_sides[seed] = 'right'\n\n        # 3. Process each unique adjacent connected shape\n        for seed_coord in adjacent_yellow_seeds:\n            if seed_coord in processed_yellow_pixels:\n                continue # Already processed this shape\n\n            # Find the full connected yellow shape\n            current_shape_pixels = find_connected_component(input_grid, seed_coord, 4)\n            \n            # Mark all pixels of this shape as processed to avoid redundant work\n            for yp in current_shape_pixels:\n                processed_yellow_pixels.add(yp)\n\n            if not current_shape_pixels: # Should not happen if seed was yellow\n                continue\n\n            # Determine which side this shape is on (based on the seed pixel)\n            shape_side = shape_sides[seed_coord]\n\n            # 4. Find the closest source color for this axis + shape structure\n            structure_pixels = current_axis_pixels + current_shape_pixels\n            reflection_color = find_closest_source_pixel(structure_pixels, source_pixels)\n\n            if reflection_color is None: # No source color found\n                continue\n\n            # 5. Perform reflection\n            for r_yellow, c_yellow in current_shape_pixels:\n                # Calculate reflected coordinates\n                # c_axis is constant for the vertical axis\n                if shape_side == 'left':\n                    c_reflected = c_axis + (c_axis - c_yellow)\n                else: # shape_side == 'right'\n                    c_reflected = c_axis - (c_yellow - c_axis)\n                r_reflected = r_yellow # Row stays the same\n\n                # Check bounds and if the original target pixel is background (white)\n                if 0 <= r_reflected < height and 0 <= c_reflected < width:\n                    # IMPORTANT: Check original input grid for background color\n                    if input_grid[r_reflected, c_reflected] == 0:\n                        output_grid[r_reflected, c_reflected] = reflection_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12924,
    "candidates_token_count": 2244,
    "total_token_count": 15168,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.107073,
  "retries": null
}