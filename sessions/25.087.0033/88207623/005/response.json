{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule identifies vertical red lines (axes) and adjacent connected yellow shapes in the input grid. Yellow shapes are identified using 8-way connectivity (including diagonals).\nFor each red axis and an associated adjacent yellow shape:\n1.  The 'structure' is defined as the union of all pixels in the axis and the connected yellow shape.\n2.  The single 'source' pixel (non-background, non-red, non-yellow) closest (Manhattan distance) to any pixel in the 'structure' is found. Its color is the 'reflection_color'.\n3.  The yellow shape is reflected across the vertical red axis.\n4.  Pixels in the output grid corresponding to the reflected shape's positions are colored with the 'reflection_color', but only if those pixels were originally background (white, color 0) in the input grid.\n5.  All original non-white pixels from the input grid are preserved in the output grid.\n\"\"\"\n\n# Helper functions\n\ndef find_pixels_with_color(grid, color):\n    \"\"\"Finds all pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_connected_component(grid, start_coord, target_color):\n    \"\"\"\n    Finds all connected pixels of target_color starting from start_coord using BFS.\n    Uses 8-connectivity (up, down, left, right, and diagonals).\n    \"\"\"\n    height, width = grid.shape\n    component_pixels = set()\n    q = deque([start_coord])\n    visited_component = {start_coord} # Keep track of visited during this specific BFS\n\n    while q:\n        r, c = q.popleft()\n        # Ensure the starting pixel itself matches the target color\n        if grid[r, c] == target_color:\n            component_pixels.add((r, c))\n            # Check neighbors (8-connectivity)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue # Skip self\n                    nr, nc = r + dr, c + dc\n                    # Check bounds, target color, and if not visited\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       grid[nr, nc] == target_color and (nr, nc) not in visited_component:\n                        visited_component.add((nr, nc))\n                        q.append((nr, nc))\n                        \n    # Return list for consistency with previous usage, though set might be fine\n    return list(component_pixels) \n\n\ndef find_closest_source_pixel(target_pixels, source_pixels):\n    \"\"\"\n    Finds the source pixel closest to any pixel in the target set (structure).\n\n    Args:\n        target_pixels: List of coordinates [(r, c), ...] representing the target structure (axis + shape).\n        source_pixels: List of source pixel info [(r, c, color), ...].\n\n    Returns:\n        The color of the closest source pixel, or None if no source pixels are found or target_pixels is empty.\n    \"\"\"\n    if not source_pixels or not target_pixels:\n        return None\n\n    min_dist = float('inf')\n    closest_source_color = None\n\n    # Iterate through each source pixel\n    for sr, sc, scolor in source_pixels:\n        current_min_dist_for_source = float('inf')\n        # Find the minimum distance from this source to any pixel in the target structure\n        for tr, tc in target_pixels:\n            dist = manhattan_distance((sr, sc), (tr, tc))\n            current_min_dist_for_source = min(current_min_dist_for_source, dist)\n        \n        # Update the overall minimum distance and corresponding color if this source is closer\n        # Implicit tie-breaking: the first source encountered with the minimum distance wins.\n        if current_min_dist_for_source < min_dist:\n            min_dist = current_min_dist_for_source\n            closest_source_color = scolor\n\n    return closest_source_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on red axes, connected yellow shapes (8-way), and source color pixels.\n    \"\"\"\n    # 1. Initialization: Create output grid by copying input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify Components\n    # Find all red pixels (potential axis parts)\n    red_pixels = find_pixels_with_color(input_grid, 2) # Red color is 2\n\n    # Find all source color pixels (non-0, non-2, non-4)\n    source_pixels = []\n    for r in range(height):\n        for c in range(width):\n            color = input_grid[r, c]\n            if color not in [0, 2, 4]: # 0=white, 2=red, 4=yellow\n                source_pixels.append((r, c, color))\n\n    # 3. Process Reflections\n    visited_red_axis_pixels = set() # To avoid processing parts of the same axis multiple times\n    processed_yellow_pixels = set() # To avoid processing the same shape multiple times\n\n    # Iterate through potential starting points of red axes\n    for r_start, c_axis in red_pixels:\n        if (r_start, c_axis) in visited_red_axis_pixels:\n            continue\n\n        # 3a. Find the full vertical red axis containing (r_start, c_axis)\n        current_axis_pixels = []\n        q = deque([(r_start, c_axis)])\n        visited_for_this_axis = set([(r_start, c_axis)])\n\n        while q:\n             r, c = q.popleft()\n             # Check if pixel is red and within the same column\n             if input_grid[r, c] == 2 and c == c_axis:\n                 current_axis_pixels.append((r,c))\n                 visited_red_axis_pixels.add((r, c)) # Mark globally visited\n\n                 # Explore vertically (up and down)\n                 for dr in [-1, 1]:\n                     nr = r + dr\n                     # Check bounds and if not visited for this axis search\n                     if 0 <= nr < height and (nr, c) not in visited_for_this_axis:\n                         # Check if the neighbor is also red\n                         if input_grid[nr, c] == 2:\n                              visited_for_this_axis.add((nr, c))\n                              q.append((nr, c))\n\n        if not current_axis_pixels:\n            continue # Should not happen if starting pixel was red, but safety check\n\n        # Sort axis pixels for clarity if needed (optional)\n        # current_axis_pixels.sort() \n        \n        # 3b. Find yellow seed pixels adjacent (cardinally) to this axis\n        adjacent_yellow_seeds = []\n        shape_sides = {} # Store side ('left'/'right') for each seed: {(r,c): side}\n\n        for r_ax, c_ax in current_axis_pixels:\n            # Check left neighbor (c_ax - 1)\n            if c_ax > 0:\n                seed_coord = (r_ax, c_ax - 1)\n                if input_grid[r_ax, c_ax - 1] == 4 and seed_coord not in processed_yellow_pixels:\n                    adjacent_yellow_seeds.append(seed_coord)\n                    shape_sides[seed_coord] = 'left'\n                    \n            # Check right neighbor (c_ax + 1)\n            if c_ax < width - 1:\n                 seed_coord = (r_ax, c_ax + 1)\n                 if input_grid[r_ax, c_ax + 1] == 4 and seed_coord not in processed_yellow_pixels:\n                     adjacent_yellow_seeds.append(seed_coord)\n                     shape_sides[seed_coord] = 'right'\n\n        # 3c. Process each unique adjacent connected shape found from seeds\n        for seed_coord in adjacent_yellow_seeds:\n            if seed_coord in processed_yellow_pixels:\n                continue # Already processed this shape via another seed or axis part\n\n            # 3c.i. Find Full Shape (using 8-connectivity)\n            current_shape_pixels = find_connected_component(input_grid, seed_coord, 4) # Yellow color is 4\n            \n            if not current_shape_pixels: # Should not happen if seed was yellow\n                continue\n\n            # Mark all pixels of this shape as globally processed\n            for yp in current_shape_pixels:\n                processed_yellow_pixels.add(yp)\n\n            # Determine which side this shape is predominantly on (use the seed's side)\n            # This assumes a shape doesn't cross the axis, which seems true in examples\n            shape_side = shape_sides[seed_coord] \n\n            # 3c.ii. Define Structure\n            structure_pixels = current_axis_pixels + current_shape_pixels\n\n            # 3c.iii. Find Closest Source Color\n            reflection_color = find_closest_source_pixel(structure_pixels, source_pixels)\n\n            if reflection_color is None: # No source color found or no source pixels exist\n                continue\n\n            # 3c.iv. Apply Reflection\n            for r_yellow, c_yellow in current_shape_pixels:\n                # Calculate reflected coordinates\n                if shape_side == 'left':\n                    # Shape is left of axis, reflect to the right\n                    # distance = c_axis - c_yellow\n                    # c_reflected = c_axis + distance\n                    c_reflected = c_axis + (c_axis - c_yellow) \n                else: # shape_side == 'right'\n                    # Shape is right of axis, reflect to the left\n                    # distance = c_yellow - c_axis\n                    # c_reflected = c_axis - distance\n                    c_reflected = c_axis - (c_yellow - c_axis)\n                \n                r_reflected = r_yellow # Row stays the same for vertical reflection\n\n                # Check bounds and if the original target pixel is background (white)\n                if 0 <= r_reflected < height and 0 <= c_reflected < width:\n                    # IMPORTANT: Check original input grid for background color\n                    if input_grid[r_reflected, c_reflected] == 0: # White color is 0\n                        output_grid[r_reflected, c_reflected] = reflection_color\n\n    # 4. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22173,
    "candidates_token_count": 2561,
    "total_token_count": 24734,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.536422,
  "retries": null
}