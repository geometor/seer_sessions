{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the first continuous horizontal band of all-white pixels (0) spanning the grid width. This separates the grid into an Upper Region (above the band) and a Lower Region (below the band). \nWithin the Upper Region, identify the widest, leftmost vertical band of all-white pixels that spans the full height of the Upper Region. This vertical band starts at column `c_start` and ends at column `c_end`.\nDivide the Upper Region into a Left Side (columns 0 to `c_start`-1) and a Right Side (columns `c_end`+1 to end). Count non-white pixels in each side (`count_L`, `count_R`). Find the most frequent non-white color (`dominant_color`) in the entire Upper Region.\nSelect columns based on counts and dominant color: If `dominant_color` is Blue (1), choose the side (Left or Right) with the *smaller* count. Otherwise, choose the side with the *larger* count. If counts are equal, choose the wider side. If widths are also equal, choose the Right side.\nThe output grid consists of all rows from the Lower Region, using only the columns corresponding to the selected side (Left or Right).\n\"\"\"\n\ndef find_horizontal_separator(grid):\n    \"\"\"\n    Finds the start and end row indices of the first continuous horizontal\n    band of all-white pixels (0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple (int, int): The start and end row indices (inclusive). \n                         Returns (-1, -1) if no such band is found.\n    \"\"\"\n    height, width = grid.shape\n    r_start = -1\n    r_end = -1\n    in_separator = False\n\n    for r in range(height):\n        is_white_row = np.all(grid[r, :] == 0)\n        if is_white_row and not in_separator:\n            r_start = r\n            r_end = r\n            in_separator = True\n        elif is_white_row and in_separator:\n            r_end = r\n        elif not is_white_row and in_separator:\n            # Found the end of the first separator\n            return r_start, r_end\n        # Continue if not white row and not yet in separator\n        \n    # If separator goes to the bottom edge or exists\n    if r_start != -1:\n        return r_start, r_end\n    else:\n        return -1, -1\n\ndef find_vertical_separator(upper_region):\n    \"\"\"\n    Finds the widest, leftmost, full-height vertical white band in the \n    upper region.\n\n    Args:\n        upper_region (np.ndarray): The upper portion of the grid.\n\n    Returns:\n        tuple (int, int): The start and end column indices (inclusive) of the\n                          selected band. Returns (-1, -1) if none found.\n    \"\"\"\n    if upper_region.size == 0: # Handle empty upper region\n        return -1, -1\n        \n    upper_height, upper_width = upper_region.shape\n    if upper_height == 0:\n        return -1, -1\n\n    white_cols = []\n    # Identify all columns that are fully white\n    for c in range(upper_width):\n        if np.all(upper_region[:, c] == 0):\n            white_cols.append(c)\n\n    if not white_cols:\n        return -1, -1\n\n    # Group consecutive columns into bands\n    bands = []\n    current_band = [white_cols[0]]\n    for i in range(1, len(white_cols)):\n        if white_cols[i] == white_cols[i-1] + 1:\n            current_band.append(white_cols[i])\n        else:\n            bands.append(current_band)\n            current_band = [white_cols[i]]\n    bands.append(current_band)\n\n    # Find the widest band(s)\n    max_len = 0\n    for band in bands:\n        if len(band) > max_len:\n            max_len = len(band)\n\n    widest_bands = [band for band in bands if len(band) == max_len]\n\n    # If tie in width, choose the leftmost one\n    best_band = min(widest_bands, key=lambda band: band[0])\n\n    c_start = best_band[0]\n    c_end = best_band[-1]\n    \n    return c_start, c_end\n\ndef get_dominant_color(region):\n    \"\"\"\n    Finds the most frequent non-white color in a region.\n\n    Args:\n        region (np.ndarray): The grid region to analyze.\n\n    Returns:\n        int or None: The dominant color code, or None if the region is empty \n                     or contains only white pixels.\n    \"\"\"\n    if region.size == 0:\n        return None\n        \n    non_white_pixels = region[region != 0]\n    if non_white_pixels.size == 0:\n        return None\n\n    color_counts = Counter(non_white_pixels)\n    # Find the color with the highest count. If ties, Counter returns one arbitrarily.\n    dominant_color = color_counts.most_common(1)[0][0] \n    return int(dominant_color) # Ensure it's a standard int\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the specified rules involving horizontal\n    and vertical separators and pixel counts/colors in the upper region.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n    \n    # 1. Identify Horizontal Split\n    r_start, r_end = find_horizontal_separator(grid)\n\n    if r_start == -1 or r_end >= height - 1:\n        # Cannot proceed if no separator or no lower region\n        return np.array([[]], dtype=int) \n\n    upper_region = grid[:r_start, :]\n    lower_region = grid[r_end + 1:, :]\n\n    if upper_region.shape[0] == 0:\n         # Cannot proceed if no upper region\n         return np.array([[]], dtype=int) \n\n    # 2. Identify Vertical Split in Upper Region\n    c_start, c_end = find_vertical_separator(upper_region)\n\n    if c_start == -1:\n         # Cannot proceed without a vertical separator\n         return np.array([[]], dtype=int)\n\n    # 3. Analyze Upper Sides\n    upper_left = upper_region[:, :c_start]\n    upper_right = upper_region[:, c_end + 1:]\n\n    count_L = np.count_nonzero(upper_left)\n    count_R = np.count_nonzero(upper_right)\n    \n    width_L = upper_left.shape[1]\n    width_R = upper_right.shape[1]\n\n    dominant_color = get_dominant_color(upper_region)\n    \n    if dominant_color is None:\n         # Cannot determine rule without dominant color (e.g., upper region is all white)\n         # Default behavior? Based on examples, this shouldn't happen. Return empty.\n         return np.array([[]], dtype=int)\n\n    # 4. Choose Output Columns\n    selected_side = \"Right\" # Default for tie-breaking width\n\n    if dominant_color == 1: # Blue Rule\n        if count_L < count_R:\n            selected_side = \"Left\"\n        elif count_R < count_L:\n            selected_side = \"Right\"\n        else: # Counts equal - tie break on width\n            if width_L > width_R:\n                selected_side = \"Left\"\n            # If width_R > width_L or widths equal, keep \"Right\" default\n            \n    else: # Standard Rule (Not Blue)\n        if count_L > count_R:\n            selected_side = \"Left\"\n        elif count_R > count_L:\n            selected_side = \"Right\"\n        else: # Counts equal - tie break on width\n            if width_L > width_R:\n                selected_side = \"Left\"\n            # If width_R > width_L or widths equal, keep \"Right\" default\n\n    # 5. Extract Output from Lower Region\n    if selected_side == \"Left\":\n        # Check if left side exists (c_start > 0)\n        if c_start > 0:\n             output_grid = lower_region[:, :c_start]\n        else:\n             # No columns to the left, return empty\n             output_grid = np.array([[]], dtype=int) if lower_region.shape[0] > 0 else np.array([], dtype=int).reshape(0,0)\n             # Adjust empty shape based on lower_region height\n             if lower_region.shape[0] > 0:\n                 output_grid = np.empty((lower_region.shape[0], 0), dtype=int)\n             else: # lower_region was also empty\n                 output_grid = np.empty((0,0), dtype=int)\n\n    else: # selected_side == \"Right\"\n        # Check if right side exists (c_end < width - 1)\n        if c_end < width - 1:\n            output_grid = lower_region[:, c_end + 1:]\n        else:\n            # No columns to the right, return empty\n            # Adjust empty shape based on lower_region height\n             if lower_region.shape[0] > 0:\n                 output_grid = np.empty((lower_region.shape[0], 0), dtype=int)\n             else: # lower_region was also empty\n                 output_grid = np.empty((0,0), dtype=int)\n\n\n    # Ensure output is 2D, even if empty\n    if output_grid.ndim == 1:\n        # This might happen if lower_region had only 1 row and output is empty cols\n         output_grid = output_grid.reshape(1, -1) \n    if output_grid.size == 0 and lower_region.shape[0] > 0 and output_grid.shape[1] != 0:\n         # Correct shape for empty columns but existing rows\n         output_grid = np.empty((lower_region.shape[0], 0), dtype=int)\n    elif output_grid.size == 0 and lower_region.shape[0] == 0:\n         # Correct shape for no rows, no cols\n         output_grid = np.empty((0,0), dtype=int)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18814,
    "candidates_token_count": 2510,
    "total_token_count": 21324,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.483432,
  "retries": null
}