{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies horizontal and vertical lines of azure pixels (8) that divide the grid. \nIt assumes there are exactly two horizontal and two vertical lines. \nThese lines define nine regions. \nThe transformation fills the white pixels (0) in five specific regions with distinct colors, leaving the azure lines and other white areas unchanged.\nThe central region, bounded exclusively by the four azure lines, is filled with magenta (6).\nThe region directly above the central region (between the top edge/previous line and the upper central line, and between the vertical lines) is filled with red (2).\nThe region directly below the central region (between the lower central line and the bottom edge/next line, and between the vertical lines) is filled with blue (1).\nThe region directly to the left of the central region (between the horizontal lines, and between the left edge/previous line and the left central line) is filled with yellow (4).\nThe region directly to the right of the central region (between the horizontal lines, and between the right central line and the right edge/next line) is filled with green (3).\n\"\"\"\n\ndef find_azure_lines(grid):\n    \"\"\"\n    Finds the indices of complete horizontal and vertical lines of azure pixels (8).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing two sorted lists:\n               - h_lines: Row indices of horizontal azure lines.\n               - v_lines: Column indices of vertical azure lines.\n    \"\"\"\n    rows, cols = grid.shape\n    h_lines = []\n    v_lines = []\n    azure_color = 8\n    \n    # Find horizontal lines\n    for r in range(rows):\n        if np.all(grid[r, :] == azure_color):\n            h_lines.append(r)\n            \n    # Find vertical lines\n    for c in range(cols):\n        if np.all(grid[:, c] == azure_color):\n            v_lines.append(c)\n            \n    return sorted(h_lines), sorted(v_lines)\n\ndef fill_region(output_grid, r_start, r_end, c_start, c_end, color):\n    \"\"\"\n    Fills the white pixels (0) within a specified rectangular region with a given color.\n\n    Args:\n        output_grid (np.array): The grid to modify.\n        r_start (int): The starting row index (inclusive).\n        r_end (int): The ending row index (exclusive).\n        c_start (int): The starting column index (inclusive).\n        c_end (int): The ending column index (exclusive).\n        color (int): The color to fill with.\n    \"\"\"\n    # Ensure bounds are within the grid dimensions\n    rows, cols = output_grid.shape\n    r_start = max(0, r_start)\n    r_end = min(rows, r_end)\n    c_start = max(0, c_start)\n    c_end = min(cols, c_end)\n\n    # Check for valid region dimensions\n    if r_start >= r_end or c_start >= c_end:\n        return \n\n    # Iterate through the region and fill only white pixels\n    for r in range(r_start, r_end):\n        for c in range(c_start, c_end):\n            if output_grid[r, c] == 0:  # Check if the pixel is white\n                output_grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling specific regions defined by azure lines \n    with predefined colors.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # --- Identify Structure ---\n    # 1. Find all horizontal and vertical azure lines\n    h_lines, v_lines = find_azure_lines(input_grid)\n\n    # --- Define Regions ---\n    # 2. Assume exactly two horizontal and two vertical lines define the core structure\n    #    (as observed in the training examples). If this assumption fails, the logic might need adjustment.\n    if len(h_lines) == 2 and len(v_lines) == 2:\n        h1, h2 = h_lines[0], h_lines[1] # First and second horizontal lines\n        v1, v2 = v_lines[0], v_lines[1] # First and second vertical lines\n\n        # Define coordinate ranges for the 9 potential regions based on the lines and grid boundaries\n        r_top_start = 0        # Top edge\n        r_top_end = h1         # Up to the first horizontal line\n        r_mid_start = h1 + 1   # After the first horizontal line\n        r_mid_end = h2         # Up to the second horizontal line\n        r_bot_start = h2 + 1   # After the second horizontal line\n        r_bot_end = rows       # To the bottom edge\n\n        c_left_start = 0       # Left edge\n        c_left_end = v1        # Up to the first vertical line\n        c_mid_start = v1 + 1   # After the first vertical line\n        c_mid_end = v2         # Up to the second vertical line\n        c_right_start = v2 + 1 # After the second vertical line\n        c_right_end = cols     # To the right edge\n\n        # --- Apply Transformations ---\n        # 3. Fill the five target regions with their specific colors, modifying only white pixels.\n        \n        # Central Region: Fill with Magenta (6)\n        # Area between both horizontal and both vertical lines\n        fill_region(output_grid, r_mid_start, r_mid_end, c_mid_start, c_mid_end, 6)\n        \n        # Top Region: Fill with Red (2)\n        # Area above the first horizontal line, between the vertical lines\n        fill_region(output_grid, r_top_start, r_top_end, c_mid_start, c_mid_end, 2)\n        \n        # Bottom Region: Fill with Blue (1)\n        # Area below the second horizontal line, between the vertical lines\n        fill_region(output_grid, r_bot_start, r_bot_end, c_mid_start, c_mid_end, 1)\n        \n        # Left Region: Fill with Yellow (4)\n        # Area left of the first vertical line, between the horizontal lines\n        fill_region(output_grid, r_mid_start, r_mid_end, c_left_start, c_left_end, 4)\n        \n        # Right Region: Fill with Green (3)\n        # Area right of the second vertical line, between the horizontal lines\n        fill_region(output_grid, r_mid_start, r_mid_end, c_right_start, c_right_end, 3)\n\n    # If the expected line structure isn't found, return the original grid (or handle as an error case)\n    # For this problem, based on examples, we assume the structure is always present.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4664,
    "candidates_token_count": 1722,
    "total_token_count": 6386,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.296957,
  "retries": null
}