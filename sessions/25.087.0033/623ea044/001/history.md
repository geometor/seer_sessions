
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 7 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 7 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 7 0 0 0 0 0 7
0 0 0 0 0 0 0 0 0 7 0 0 0 7 0
0 0 0 0 0 0 0 0 0 0 7 0 7 0 0
0 0 0 0 0 0 0 0 0 0 0 7 0 0 0
0 0 0 0 0 0 0 0 0 0 7 0 7 0 0
0 0 0 0 0 0 0 0 0 7 0 0 0 7 0
0 0 0 0 0 0 0 0 7 0 0 0 0 0 7
0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 7 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 0 0 0
0 0 0 7 0 0 0 0 0 0 0 0 0 0 0
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 8 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 8 0
8 0 0 0 8 0 0
0 8 0 8 0 0 0
0 0 8 0 0 0 0
0 8 0 8 0 0 0
8 0 0 0 8 0 0
0 0 0 0 0 8 0
```

Okay, let's analyze the task examples.

**Perception of Elements:**

1.  **Input Grid:** Each input grid is characterized by being predominantly white (color 0), with exactly one pixel having a non-white color (orange=7 in example 1, red=2 in example 2, azure=8 in example 3).
2.  **Output Grid:** The output grid retains the same dimensions as the input grid. It contains multiple pixels of the same non-white color found in the input, arranged in a distinct pattern originating from the position of the input pixel. The background remains white.
3.  **Transformation Pattern:** The non-white pixels in the output form an 'X' shape. This 'X' is centered at the original coordinates of the non-white pixel from the input grid. The arms of the 'X' extend diagonally outwards in all four directions (up-left, up-right, down-left, down-right) until they reach the boundary of the grid. The central pixel itself is part of the 'X'.

**YAML Facts:**


```yaml
task_context:
  grid_properties:
    - dimensions_match: Input and output grids have the same height and width.
    - background_color: The background is consistently white (0).
  input_elements:
    - type: single_pixel
      color: non-white (variable, e.g., orange, red, azure)
      count: 1
      location: variable (r, c)
  output_elements:
    - type: pattern
      shape: diagonal_cross ('X')
      color: same as the single non-white input pixel
      origin: centered at the location (r, c) of the input pixel
      extent: extends from the origin to the grid boundaries along all four diagonals.
  transformation:
    - type: pattern_generation
    - description: Draws an 'X' pattern using the input pixel's color, centered at the input pixel's location, extending to the grid edges.
```


**Natural Language Program:**

1.  Identify the coordinates `(row, col)` and the color `C` of the single non-white pixel in the input grid.
2.  Initialize an output grid with the same dimensions as the input grid, filled entirely with the white color (0).
3.  Set the pixel at `(row, col)` in the output grid to color `C`.
4.  Trace outwards from `(row, col)` along the up-left diagonal (decrementing row and column indices). For each position `(r, c)` along this path that is within the grid's boundaries, set the output pixel `output[r][c]` to color `C`. Continue until a boundary is hit.
5.  Repeat step 4 for the down-right diagonal (incrementing row and column indices).
6.  Repeat step 4 for the up-right diagonal (decrementing row index, incrementing column index).
7.  Repeat step 4 for the down-left diagonal (incrementing row index, decrementing column index).
8.  Return the completed output grid.
