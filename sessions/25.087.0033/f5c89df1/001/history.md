
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0
0 0 0 2 8 0 3 0 8 2 0 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 8 0 0 0
0 0 8 8 8 0 0 0 8 8 8 0 0
0 8 0 0 0 8 0 8 0 0 0 8 0
0 0 8 8 8 0 0 0 8 8 8 0 0
0 0 0 8 0 0 0 0 0 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 8 2 0 0 0 0 0 0
0 0 0 0 8 3 8 0 0 0 0 0 0
0 0 0 0 2 8 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 8 8 0 8 8 0 0 0 0 0 0
0 0 8 8 3 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0 0 0
0 0 8 8 0 8 8 0 0 0 0 0 0
0 0 8 8 0 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The task involves transforming grids containing primarily white (0), azure (8), red (2), and green (3) pixels. The transformation consistently removes red and green pixels. In some cases, the azure pixels are reflected or duplicated based on the location of a single green pixel and the relative positions of red pixels in the input.

*   **YAML Facts:**
    
```yaml
    task_description: Remove red and green pixels, and conditionally reflect azure pixels based on the presence of a single green pixel and the relative position of red pixels.
    
    elements:
      - object: background
        color: white (0)
        properties: occupies most of the grid.
      - object: structure
        color: azure (8)
        properties: forms various shapes; can be contiguous or separated.
      - object: marker_red
        color: red (2)
        properties: appears in specific locations relative to the azure structure and green markers.
      - object: marker_green
        color: green (3)
        properties: appears typically within or near the azure structure; often acts as a center point or trigger.
    
    actions:
      - action: remove_pixels
        colors: [red (2), green (3)]
        result: Corresponding pixels are changed to white (0) in the output.
      - action: conditional_reflection
        trigger: Exactly one green pixel exists in the input.
        target: azure (8) pixels from the input grid.
        center: location of the single green pixel (row_g, col_g).
        condition_details:
          - condition: A red pixel exists on the same row as the green pixel, but no red pixel exists on the same column.
            effect: Horizontal reflection of azure pixels across the green pixel's column. Each input azure pixel at (r, c) potentially adds an azure pixel at (r, 2*col_g - c) in the output (if within bounds).
          - condition: No red pixel exists on the same row as the green pixel, and no red pixel exists on the same column.
            effect: Full point reflection (Horizontal + Vertical + Diagonal) of azure pixels around the green pixel's location. Each input azure pixel at (r, c) potentially adds azure pixels at (r, 2*col_g - c), (2*row_g - r, c), and (2*row_g - r, 2*col_g - c) in the output (if within bounds).
          - condition: All other cases (e.g., red pixel only on the same column, red pixels on both same row and same column, no red pixels at all).
            effect: No reflection occurs.
    
    relationships:
      - relation: positional_markers
        objects: [marker_red, marker_green]
        description: The positions of red pixels relative to the single green pixel (sharing the same row, same column, neither, or both) determine the type of reflection applied to the azure structure.
    
    output_grid:
      derivation: Starts as a copy of the input, then modified by removing red/green pixels and potentially adding reflected azure pixels.
    ```


*   **Natural Language Program:**
    1.  Create the output grid as an initial copy of the input grid.
    2.  Identify the locations of all red (2) pixels and green (3) pixels present in the input grid.
    3.  For every identified red and green pixel location, change the corresponding pixel in the output grid to white (0).
    4.  Count the number of green pixels found in the input grid.
    5.  If exactly one green pixel was found at location (row\_g, col\_g):
        a.  Check if any red pixel identified in step 2 shares the same row `row_g`. Set `found_red_same_row` accordingly (True/False).
        b.  Check if any red pixel identified in step 2 shares the same column `col_g`. Set `found_red_same_col` accordingly (True/False).
        c.  Identify all locations `(r, c)` of azure (8) pixels in the *input* grid.
        d.  If `found_red_same_row` is True AND `found_red_same_col` is False:
            i.  For each input azure pixel location `(r, c)`, calculate the horizontally reflected column `c_reflected = 2 * col_g - c`.
            ii. If the reflected coordinate `(r, c_reflected)` is within the bounds of the grid, set the pixel at `output[r][c_reflected]` to azure (8).
        e.  Else if `found_red_same_row` is False AND `found_red_same_col` is False:
            i.  For each input azure pixel location `(r, c)`:
                1.  Calculate horizontal reflection: `c_h = 2 * col_g - c`. If `(r, c_h)` is within bounds, set `output[r][c_h] = 8`.
                2.  Calculate vertical reflection: `r_v = 2 * row_g - r`. If `(r_v, c)` is within bounds, set `output[r_v][c] = 8`.
                3.  Calculate diagonal reflection: If `(r_v, c_h)` is within bounds, set `output[r_v][c_h] = 8`.
        f.  Else (if `found_red_same_col` is True, regardless of `found_red_same_row`): No reflection is performed.
    6.  Return the modified output grid.
