
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 8 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 8 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 4 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 4 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 8 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
2 8 8 8 4 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 2
8 8 8 8 8 8 8 2
0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 8 0 0 2
0 0 8 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 8 0 0 0 0 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 4 8 8 2
0 0 4 8 8 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 4 8 8 8 8 2
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 8 8 8
2 8 8 8 8 8 8 8 8 8
2 0 0 0 0 0 0 0 0 0
2 8 8 8 8 8 8 8 8 8
2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception:**

1.  **Grid Structure:** The input and output are 2D grids of pixels with different colors. The background is white (0).
2.  **Key Colors:** The active colors involved in the transformation are red (2), azure (8), and yellow (4). White (0) serves as the background and remains mostly unchanged, except where overwritten.
3.  **Objects:**
    *   **Red Lines:** Red pixels (2) consistently appear as vertical line segments, typically along the left or right edges of the grid. These red pixels seem to act as boundaries or starting points for the transformation. They persist unchanged in the output.
    *   **Azure Seeds:** Azure pixels (8) appear sparsely in the input grid, always located in rows that also contain at least one red pixel. These seem to act as target points or "seeds".
    *   **Azure Fills:** In the output grid, horizontal lines of azure pixels (8) appear. These lines originate or are bounded by the red pixels.
    *   **Yellow Markers:** Yellow pixels (4) appear only in the output, replacing the original position of an azure "seed" pixel when a fill operation reaches it.
4.  **Transformation Pattern:** The core transformation seems to involve drawing horizontal lines of azure (8) based on the positions of red (2) and azure (8) pixels within the same row.
    *   **Rule 1 (Red + Azure):** If a row contains both red pixel(s) and azure pixel(s), a horizontal azure line is drawn. The line appears to fill the space *between* a red pixel and an azure pixel. The pixel at the original azure location is then changed to yellow (4). The examples suggest the fill originates from the side of the red pixel and extends towards the azure pixel, stopping just before it, and then replacing the azure pixel's spot with yellow. If multiple reds exist, the closest one to the azure pixel seems to be used as the boundary.
    *   **Rule 2 (Red Only):** If a row contains red pixel(s) but no azure pixels, the entire row (excluding the position(s) of the red pixel(s)) is filled with azure (8). The fill extends across the row, bounded by the grid edges and the red pixel(s).
    *   **Other Rows:** Rows containing no red pixels remain unchanged.

**YAML Facts:**


```yaml
task_elements:
  - element: grid
    description: A 2D array of pixels representing colors (0-9).
  - element: background_color
    value: 0 (white)
    role: Default empty space.
  - element: boundary_color
    value: 2 (red)
    role: Acts as a boundary or starting point for horizontal fills. Forms vertical segments, usually at edges. Persists in the output.
  - element: seed_color
    value: 8 (azure)
    role: Input pixels that act as targets for horizontal fills initiated by red pixels in the same row.
  - element: fill_color
    value: 8 (azure)
    role: Color used to fill horizontal segments in the output grid based on rules.
  - element: marker_color
    value: 4 (yellow)
    role: Output color that replaces the original position of a seed_color (azure) when a fill operation reaches it.

transformation_rules:
  - rule: process_by_row
    description: The transformation logic is applied independently to each row of the grid.
  - rule: red_and_azure_present
    condition: A row contains at least one red (2) pixel and at least one azure (8) pixel.
    action:
      - For each azure pixel (seed) in the row:
        - Find the closest red pixel (boundary) in the same row.
        - Fill the pixels between the boundary and the seed (exclusive of boundary, inclusive of pixels up to seed) with azure (8).
        - Change the pixel at the original seed location to yellow (4).
  - rule: red_only_present
    condition: A row contains at least one red (2) pixel and no azure (8) pixels.
    action:
      - Fill all pixels in the row with azure (8), except for the pixels that were originally red (2).
  - rule: no_red_present
    condition: A row contains no red (2) pixels.
    action:
      - The row remains unchanged in the output.

relationships:
  - relationship: horizontal_adjacency
    description: The fill process connects red and azure pixels horizontally within the same row.
  - relationship: closest_boundary
    description: When both red and azure pixels are present, the fill originates from the red pixel closest to the azure pixel in that row.

assumptions:
  - If multiple red pixels exist in a row with no azure pixels, all non-red pixels in that row are filled with azure (based on single-red examples).
  - If multiple azure pixels exist in a row with red pixels, the rule applies independently for each azure pixel relative to its closest red pixel.
  - Rows with only azure pixels (no red) are unchanged (not explicitly shown, but follows from observed rules).
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Iterate through each row of the input grid.
3.  For the current row, find the column indices of all red pixels (color 2) and all azure pixels (color 8).
4.  **Check Conditions:**
    *   **If** the row contains at least one red pixel **and** at least one azure pixel:
        *   For each azure pixel at column `c_azure`:
            *   Find the red pixel column `c_red` in the same row that has the minimum horizontal distance to `c_azure`.
            *   Determine the start and end columns for the fill:
                *   If `c_red < c_azure`, fill columns from `c_red + 1` to `c_azure - 1`.
                *   If `c_red > c_azure`, fill columns from `c_azure + 1` to `c_red - 1`.
            *   In the output grid's current row, set the color of the pixels in the determined fill range to azure (8).
            *   In the output grid's current row, set the color of the pixel at column `c_azure` to yellow (4).
    *   **Else if** the row contains at least one red pixel **and** no azure pixels:
        *   For every column `c` in the row:
            *   If the input pixel at `(row, c)` is not red (2), set the output pixel at `(row, c)` to azure (8).
    *   **Else** (the row contains no red pixels):
        *   Do nothing; the row in the output grid remains as copied from the input.
5.  After processing all rows, return the modified output grid.
