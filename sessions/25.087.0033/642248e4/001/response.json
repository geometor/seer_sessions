{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef _find_borders(grid):\n    \"\"\"\n    Identifies the two border lines (top/bottom or left/right) and their colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (border_type, color1, edge1, color2, edge2) or None if no valid borders found.\n               border_type is 'horizontal' or 'vertical'.\n               color1, color2 are the border colors.\n               edge1, edge2 are the row/column indices of the borders.\n    \"\"\"\n    height, width = grid.shape\n\n    # Check horizontal borders (top and bottom rows)\n    top_row = grid[0, :]\n    bottom_row = grid[height - 1, :]\n    if len(np.unique(top_row)) == 1 and top_row[0] != 0 and \\\n       len(np.unique(bottom_row)) == 1 and bottom_row[0] != 0:\n        return 'horizontal', top_row[0], 0, bottom_row[0], height - 1\n\n    # Check vertical borders (left and right columns)\n    left_col = grid[:, 0]\n    right_col = grid[:, width - 1]\n    if len(np.unique(left_col)) == 1 and left_col[0] != 0 and \\\n       len(np.unique(right_col)) == 1 and right_col[0] != 0:\n        return 'vertical', left_col[0], 0, right_col[0], width - 1\n\n    return None # Should not happen based on examples\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\" Gets orthogonal neighbor coordinates within grid bounds. \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the proximity of blue pixels (1) to borders.\n\n    1. Identifies two single-color borders (either top/bottom rows or left/right columns).\n    2. For each blue pixel (1) not on a border:\n        a. Determines which of the two borders it is closer to (based on row/col index).\n        b. Finds the orthogonally adjacent white neighbor (0) that is closest to that same border.\n        c. Recolors that specific white neighbor with the color of the closer border.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    output_grid = np.copy(input_grid_np)\n\n    # 1. Identify borders\n    border_info = _find_borders(input_grid_np)\n    if not border_info:\n        # Fallback or error handling if borders aren't as expected\n        return output_grid.tolist() \n    border_type, color1, edge1, color2, edge2 = border_info\n\n    # Define border ranges to exclude blue pixels on borders\n    border_rows = set()\n    border_cols = set()\n    if border_type == 'horizontal':\n        border_rows.add(edge1)\n        border_rows.add(edge2)\n    else: # vertical\n        border_cols.add(edge1)\n        border_cols.add(edge2)\n\n    # 2. Find and process each blue pixel\n    blue_pixels = []\n    for r in range(height):\n        for c in range(width):\n            # Exclude pixels on the border lines themselves\n            if r in border_rows or c in border_cols:\n                continue\n            if input_grid_np[r, c] == 1:\n                blue_pixels.append((r, c))\n\n    for r_blue, c_blue in blue_pixels:\n        # 2a. Determine closer border\n        closer_border_color = -1\n        closer_border_edge = -1\n        min_dist_to_border = float('inf')\n\n        if border_type == 'horizontal':\n            dist1 = abs(r_blue - edge1)\n            dist2 = abs(r_blue - edge2)\n            if dist1 < dist2:\n                closer_border_color = color1\n                closer_border_edge = edge1\n                min_dist_to_border = dist1\n            elif dist2 < dist1:\n                closer_border_color = color2\n                closer_border_edge = edge2\n                min_dist_to_border = dist2\n            # else: equal distance, do nothing based on implicit rule from examples\n        else: # vertical\n            dist1 = abs(c_blue - edge1)\n            dist2 = abs(c_blue - edge2)\n            if dist1 < dist2:\n                closer_border_color = color1\n                closer_border_edge = edge1\n                min_dist_to_border = dist1\n            elif dist2 < dist1:\n                closer_border_color = color2\n                closer_border_edge = edge2\n                min_dist_to_border = dist2\n            # else: equal distance, do nothing\n\n        # If a closer border was identified (not equidistant)\n        if closer_border_color != -1:\n            \n            # 2b. Find orthogonal white neighbors\n            potential_targets = []\n            neighbors = _get_neighbors(r_blue, c_blue, height, width)\n            for nr, nc in neighbors:\n                if input_grid_np[nr, nc] == 0: # Must be white in the input\n                    potential_targets.append((nr, nc))\n\n            # 2c. Find the neighbor closest to the closer border\n            target_neighbor = None\n            min_neighbor_dist = float('inf')\n\n            for tr, tc in potential_targets:\n                if border_type == 'horizontal':\n                    dist = abs(tr - closer_border_edge)\n                else: # vertical\n                    dist = abs(tc - closer_border_edge)\n\n                # Check if this neighbor is strictly closer than the current best\n                # Using <= allows picking one if multiple are equally close, \n                # favoring the one encountered first (or based on iteration order).\n                # Examples suggest a unique closest neighbor exists. Let's assume strict minimum for now.\n                # If strict '<' fails tests, change to '<='\n                if dist < min_neighbor_dist:\n                     min_neighbor_dist = dist\n                     target_neighbor = (tr, tc)\n                # Handle ties explicitly if needed later based on testing\n\n            # 2d. Recolor the target neighbor\n            if target_neighbor:\n                tr, tc = target_neighbor\n                # Check if the target is not already colored by another blue pixel's rule in this pass\n                # Although the logic seems deterministic, this prevents accidental overwrites if logic gets complex\n                # For this specific task, it might be redundant if each blue influences at most one white.\n                if output_grid[tr, tc] == 0: # Ensure we only color originally white pixels\n                   output_grid[tr, tc] = closer_border_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4334,
    "candidates_token_count": 1726,
    "total_token_count": 6060,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.398236,
  "retries": null
}