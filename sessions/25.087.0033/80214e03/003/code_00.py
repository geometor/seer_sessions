import numpy as np
from collections import deque, OrderedDict

"""
Identifies distinct non-white shapes (objects) in the input grid. 
Groups these objects into conceptual horizontal rows based on vertical overlap. 
For each conceptual row, determines the sequence of unique colors present, ordered 
left-to-right based on the first appearance (minimum column index) of each color 
within that row. 
Calculates the maximum length (`max_width`) among these unique color sequences across all rows.
Creates an output grid where each row corresponds to an input conceptual row. 
Each output row is generated by:
1. Reversing the unique color sequence for that input row.
2. If the reversed sequence length is less than `max_width`, prepending (padding on the left) 
   with the first color of the reversed sequence (which corresponds to the rightmost unique 
   color in the original input row) until the length reaches `max_width`.
The final output grid has dimensions (number of conceptual rows) x `max_width`.
"""

def find_objects(grid):
    """
    Finds all contiguous objects of the same non-background color in the grid.

    Args:
        grid (np.array): The input grid.

    Returns:
        list: A list of dictionaries, each representing an object with its 
              color, pixels, and bounding box (min/max row/col).
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Check for non-background color and if not visited
            if color != 0 and not visited[r, c]:
                obj_pixels = set()
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, max_r = r, r
                min_c, max_c = c, c
                
                while q:
                    curr_r, curr_c = q.popleft()
                    obj_pixels.add((curr_r, curr_c))
                    
                    # Update bounding box
                    min_r = min(min_r, curr_r)
                    max_r = max(max_r, curr_r)
                    min_c = min(min_c, curr_c)
                    max_c = max(max_c, curr_c)
                    
                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        
                        # Check bounds, color match, and visited status
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            
                objects.append({
                    'color': color,
                    'pixels': obj_pixels,
                    'min_row': min_r,
                    'max_row': max_r,
                    'min_col': min_c,
                    'max_col': max_c
                })
                
    return objects

def group_objects_by_row(objects):
    """
    Groups objects into conceptual rows based on vertical overlap.

    Args:
        objects (list): A list of object dictionaries.

    Returns:
        list: A list of lists, where each inner list contains objects 
              belonging to the same conceptual row, ordered top-to-bottom 
              based on the vertical position of the rows. Objects within 
              each row list are *not* guaranteed to be sorted horizontally 
              at this stage, although the input sorting helps.
    """
    if not objects:
        return []

    # Sort objects primarily by top row, then left column to process top-down
    objects.sort(key=lambda o: (o['min_row'], o['min_col']))

    rows_of_objects = []
    current_row_objects = []
    current_row_max_r = -1 # Keep track of the max row extent of the current group

    for obj in objects:
        # Check if the object belongs to the current row being built
        belongs_to_current = False
        if not current_row_objects:
            # First object starts the first row
            belongs_to_current = True
        else:
             # Check for vertical overlap with the *current row's overall vertical span*
             # An object belongs if its vertical span overlaps with the span defined
             # by the min(min_row) and max(max_row) of objects currently in the row group.
             # Simplified check: does it overlap with *any* object already in the group?
             # (Equivalent to checking if obj.min_row <= current_row_max_r and obj.max_row >= min_row_of_current_group - but the original overlap check with any object works)

            for existing_obj in current_row_objects:
                # Vertical overlap condition:
                if max(obj['min_row'], existing_obj['min_row']) <= min(obj['max_row'], existing_obj['max_row']):
                    belongs_to_current = True
                    break 
        
        if belongs_to_current:
            current_row_objects.append(obj)
            # Update the maximum row extent of the current group
            current_row_max_r = max(current_row_max_r, obj['max_row']) 
        else:
            # Finalize the previous row
            if current_row_objects:
                rows_of_objects.append(current_row_objects) # Don't sort here, handle unique colors later
            # Start a new row with the current object
            current_row_objects = [obj]
            current_row_max_r = obj['max_row']

    # Add the last row after the loop finishes
    if current_row_objects:
        rows_of_objects.append(current_row_objects)
        
    return rows_of_objects


def get_unique_color_sequence(object_row):
    """
    Determines the sequence of unique colors in a row, ordered left-to-right.

    Args:
        object_row (list): A list of object dictionaries for a single conceptual row.

    Returns:
        list: An ordered list of unique colors found in the row.
    """
    if not object_row:
        return []

    # Find the minimum column index for each color present in the row
    color_min_col = {}
    for obj in object_row:
        color = obj['color']
        min_col = obj['min_col']
        if color not in color_min_col:
            color_min_col[color] = min_col
        else:
            color_min_col[color] = min(color_min_col[color], min_col)

    # Sort the unique colors based on their minimum column index
    # Use OrderedDict to preserve insertion order if min_cols are equal (unlikely but safe)
    # Or simply sort the items by value (min_col)
    sorted_colors = sorted(color_min_col.items(), key=lambda item: item[1])
    
    unique_color_sequence = [color for color, min_col in sorted_colors]
    return unique_color_sequence


def transform(input_grid):
    """
    Transforms the input grid based on identified object rows and unique color sequences.

    Args:
        input_grid (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the transformed output grid.
    """
    input_np = np.array(input_grid, dtype=int)

    # 1. Identify all distinct, contiguous, non-white shapes
    objects = find_objects(input_np)
    
    # 2. Group the identified shapes into conceptual horizontal "rows"
    object_rows = group_objects_by_row(objects)

    # 3. For each group (row), get the list of unique colors ordered left-to-right
    unique_color_sequences = []
    max_width = 0
    for row in object_rows:
        unique_colors = get_unique_color_sequence(row)
        unique_color_sequences.append(unique_colors)
        max_width = max(max_width, len(unique_colors))

    # 4. Determine output dimensions
    output_height = len(unique_color_sequences)
    if output_height == 0: # Handle empty input case
        return [] 
        
    # 5. Initialize output grid with background color (0) initially might be safer
    #    although the logic should fill every cell.
    output_np = np.zeros((output_height, max_width), dtype=int)

    # 6. Process each row for the output
    for i, unique_colors in enumerate(unique_color_sequences):
        # a. Reverse the order of unique colors
        reversed_colors = unique_colors[::-1]
        
        # b. Get current width
        current_width = len(reversed_colors)
        
        # c. Pad if necessary
        if current_width == 0: # Handle case of an empty unique color sequence
             final_row_colors = [0] * max_width # Fill with background if row was effectively empty
        elif current_width < max_width:
            # Padding color is the first in the reversed list (rightmost unique color from input)
            padding_color = reversed_colors[0] 
            padding = [padding_color] * (max_width - current_width)
            final_row_colors = padding + reversed_colors
        else:
            final_row_colors = reversed_colors
            
        # d. Place into output grid
        output_np[i, :] = final_row_colors

    # 7. Return the completed output grid as a list of lists
    return output_np.tolist()