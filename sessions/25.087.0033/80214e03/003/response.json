{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, OrderedDict\n\n\"\"\"\nIdentifies distinct non-white shapes (objects) in the input grid. \nGroups these objects into conceptual horizontal rows based on vertical overlap. \nFor each conceptual row, determines the sequence of unique colors present, ordered \nleft-to-right based on the first appearance (minimum column index) of each color \nwithin that row. \nCalculates the maximum length (`max_width`) among these unique color sequences across all rows.\nCreates an output grid where each row corresponds to an input conceptual row. \nEach output row is generated by:\n1. Reversing the unique color sequence for that input row.\n2. If the reversed sequence length is less than `max_width`, prepending (padding on the left) \n   with the first color of the reversed sequence (which corresponds to the rightmost unique \n   color in the original input row) until the length reaches `max_width`.\nThe final output grid has dimensions (number of conceptual rows) x `max_width`.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with its \n              color, pixels, and bounding box (min/max row/col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check for non-background color and if not visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_row': min_r,\n                    'max_row': max_r,\n                    'min_col': min_c,\n                    'max_col': max_c\n                })\n                \n    return objects\n\ndef group_objects_by_row(objects):\n    \"\"\"\n    Groups objects into conceptual rows based on vertical overlap.\n\n    Args:\n        objects (list): A list of object dictionaries.\n\n    Returns:\n        list: A list of lists, where each inner list contains objects \n              belonging to the same conceptual row, ordered top-to-bottom \n              based on the vertical position of the rows. Objects within \n              each row list are *not* guaranteed to be sorted horizontally \n              at this stage, although the input sorting helps.\n    \"\"\"\n    if not objects:\n        return []\n\n    # Sort objects primarily by top row, then left column to process top-down\n    objects.sort(key=lambda o: (o['min_row'], o['min_col']))\n\n    rows_of_objects = []\n    current_row_objects = []\n    current_row_max_r = -1 # Keep track of the max row extent of the current group\n\n    for obj in objects:\n        # Check if the object belongs to the current row being built\n        belongs_to_current = False\n        if not current_row_objects:\n            # First object starts the first row\n            belongs_to_current = True\n        else:\n             # Check for vertical overlap with the *current row's overall vertical span*\n             # An object belongs if its vertical span overlaps with the span defined\n             # by the min(min_row) and max(max_row) of objects currently in the row group.\n             # Simplified check: does it overlap with *any* object already in the group?\n             # (Equivalent to checking if obj.min_row <= current_row_max_r and obj.max_row >= min_row_of_current_group - but the original overlap check with any object works)\n\n            for existing_obj in current_row_objects:\n                # Vertical overlap condition:\n                if max(obj['min_row'], existing_obj['min_row']) <= min(obj['max_row'], existing_obj['max_row']):\n                    belongs_to_current = True\n                    break \n        \n        if belongs_to_current:\n            current_row_objects.append(obj)\n            # Update the maximum row extent of the current group\n            current_row_max_r = max(current_row_max_r, obj['max_row']) \n        else:\n            # Finalize the previous row\n            if current_row_objects:\n                rows_of_objects.append(current_row_objects) # Don't sort here, handle unique colors later\n            # Start a new row with the current object\n            current_row_objects = [obj]\n            current_row_max_r = obj['max_row']\n\n    # Add the last row after the loop finishes\n    if current_row_objects:\n        rows_of_objects.append(current_row_objects)\n        \n    return rows_of_objects\n\n\ndef get_unique_color_sequence(object_row):\n    \"\"\"\n    Determines the sequence of unique colors in a row, ordered left-to-right.\n\n    Args:\n        object_row (list): A list of object dictionaries for a single conceptual row.\n\n    Returns:\n        list: An ordered list of unique colors found in the row.\n    \"\"\"\n    if not object_row:\n        return []\n\n    # Find the minimum column index for each color present in the row\n    color_min_col = {}\n    for obj in object_row:\n        color = obj['color']\n        min_col = obj['min_col']\n        if color not in color_min_col:\n            color_min_col[color] = min_col\n        else:\n            color_min_col[color] = min(color_min_col[color], min_col)\n\n    # Sort the unique colors based on their minimum column index\n    # Use OrderedDict to preserve insertion order if min_cols are equal (unlikely but safe)\n    # Or simply sort the items by value (min_col)\n    sorted_colors = sorted(color_min_col.items(), key=lambda item: item[1])\n    \n    unique_color_sequence = [color for color, min_col in sorted_colors]\n    return unique_color_sequence\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified object rows and unique color sequences.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct, contiguous, non-white shapes\n    objects = find_objects(input_np)\n    \n    # 2. Group the identified shapes into conceptual horizontal \"rows\"\n    object_rows = group_objects_by_row(objects)\n\n    # 3. For each group (row), get the list of unique colors ordered left-to-right\n    unique_color_sequences = []\n    max_width = 0\n    for row in object_rows:\n        unique_colors = get_unique_color_sequence(row)\n        unique_color_sequences.append(unique_colors)\n        max_width = max(max_width, len(unique_colors))\n\n    # 4. Determine output dimensions\n    output_height = len(unique_color_sequences)\n    if output_height == 0: # Handle empty input case\n        return [] \n        \n    # 5. Initialize output grid with background color (0) initially might be safer\n    #    although the logic should fill every cell.\n    output_np = np.zeros((output_height, max_width), dtype=int)\n\n    # 6. Process each row for the output\n    for i, unique_colors in enumerate(unique_color_sequences):\n        # a. Reverse the order of unique colors\n        reversed_colors = unique_colors[::-1]\n        \n        # b. Get current width\n        current_width = len(reversed_colors)\n        \n        # c. Pad if necessary\n        if current_width == 0: # Handle case of an empty unique color sequence\n             final_row_colors = [0] * max_width # Fill with background if row was effectively empty\n        elif current_width < max_width:\n            # Padding color is the first in the reversed list (rightmost unique color from input)\n            padding_color = reversed_colors[0] \n            padding = [padding_color] * (max_width - current_width)\n            final_row_colors = padding + reversed_colors\n        else:\n            final_row_colors = reversed_colors\n            \n        # d. Place into output grid\n        output_np[i, :] = final_row_colors\n\n    # 7. Return the completed output grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9165,
    "candidates_token_count": 2365,
    "total_token_count": 11530,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.077212,
  "retries": null
}