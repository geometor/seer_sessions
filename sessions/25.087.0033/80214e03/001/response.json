{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-white shapes in the input grid. Groups these shapes into \nhorizontal rows based on vertical overlap. For each row, determines the colors \nof the shapes, ordered left-to-right. Reverses this order for each row. \nDetermines the maximum number of shapes in any row (`max_width`). Creates an \noutput grid where each row corresponds to an input row group. Each output row \ncontains the reversed color sequence. If a row has fewer colors than `max_width`, \nit's padded at the beginning (left) with the first color of its reversed sequence \n(which corresponds to the rightmost shape in the original input row).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with its \n              color, pixels, and bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check for non-background color and if not visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_row': min_r,\n                    'max_row': max_r,\n                    'min_col': min_c,\n                    'max_col': max_c\n                })\n                \n    return objects\n\ndef group_objects_by_row(objects):\n    \"\"\"\n    Groups objects into rows based on vertical overlap.\n\n    Args:\n        objects (list): A list of object dictionaries.\n\n    Returns:\n        list: A list of lists, where each inner list contains objects \n              belonging to the same conceptual row, ordered top-to-bottom.\n    \"\"\"\n    if not objects:\n        return []\n\n    # Sort objects primarily by top row, then left column\n    objects.sort(key=lambda o: (o['min_row'], o['min_col']))\n\n    rows_of_objects = []\n    current_row = []\n\n    for obj in objects:\n        # Check if the object belongs to the current row being built\n        belongs_to_current = False\n        if not current_row:\n            # First object starts the first row\n            belongs_to_current = True\n        else:\n            # Check for vertical overlap with ANY object already in the current row\n            for existing_obj in current_row:\n                # Vertical overlap condition\n                if max(obj['min_row'], existing_obj['min_row']) <= min(obj['max_row'], existing_obj['max_row']):\n                    belongs_to_current = True\n                    break \n        \n        if belongs_to_current:\n            current_row.append(obj)\n        else:\n            # Finalize the previous row\n            if current_row:\n                 # Sort the completed row by min_col before adding\n                current_row.sort(key=lambda o: o['min_col'])\n                rows_of_objects.append(current_row)\n            # Start a new row with the current object\n            current_row = [obj]\n\n    # Add the last row after the loop finishes\n    if current_row:\n        # Sort the final row by min_col before adding\n        current_row.sort(key=lambda o: o['min_col'])\n        rows_of_objects.append(current_row)\n        \n    return rows_of_objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified object rows.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct, contiguous, non-white shapes\n    objects = find_objects(input_np)\n    \n    # 2. Group the identified shapes into horizontal \"rows\"\n    #    The grouping function already orders rows top-to-bottom implicitly by processing sorted objects.\n    object_rows = group_objects_by_row(objects)\n\n    # 3. For each group (row), get the list of colors (sorted left-to-right by default from grouping)\n    color_rows = []\n    max_width = 0\n    for row in object_rows:\n        # Objects within each row are already sorted by min_col in group_objects_by_row\n        colors = [obj['color'] for obj in row]\n        color_rows.append(colors)\n        max_width = max(max_width, len(colors))\n\n    # 4. Determine output dimensions\n    output_height = len(color_rows)\n    if output_height == 0: # Handle empty input case\n        return [] \n        \n    # 5. Initialize output grid\n    output_np = np.zeros((output_height, max_width), dtype=int)\n\n    # 6. Process each row for the output\n    for i, colors in enumerate(color_rows):\n        # a. Reverse the order of colors\n        reversed_colors = colors[::-1]\n        \n        # b. Get current width\n        current_width = len(reversed_colors)\n        \n        # c. Pad if necessary\n        if current_width < max_width:\n            if not reversed_colors: # Handle case of an empty row (shouldn't happen with current logic but good practice)\n                 padding_color = 0 # Default to background if row was empty\n            else:\n                padding_color = reversed_colors[0] # Padding color is the first in reversed list\n            \n            padding = [padding_color] * (max_width - current_width)\n            final_row_colors = padding + reversed_colors\n        else:\n            final_row_colors = reversed_colors\n            \n        # d. Place into output grid\n        output_np[i, :] = final_row_colors\n\n    # 7. Return the completed output grid as a list of lists\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3877,
    "candidates_token_count": 1777,
    "total_token_count": 5654,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.93448,
  "retries": null
}