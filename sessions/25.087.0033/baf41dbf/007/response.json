{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by resizing a green frame based on the location of external magenta markers, while preserving the original content within the frame's initial area.\n\n1.  Initialize an output grid of the same dimensions as the input grid, filled with white (0).\n2.  Find all coordinates of magenta (6) pixels (markers) and store them.\n3.  Find all connected components of green (3) pixels. \n4.  If no green components exist, skip to step 9 (drawing markers).\n5.  If green components exist, identify the \"main\" component (largest bounding box area, tie-breaking with top-left corner) and calculate its initial bounding box (`initial_bbox`).\n6.  Copy the rectangular region defined by `initial_bbox` from the input grid to the corresponding region in the output grid.\n7.  Identify magenta markers that lie strictly outside `initial_bbox`.\n8.  Calculate the new bounding box (`new_bbox`) by potentially expanding `initial_bbox` based on external markers:\n    a.  Expand top edge up to one row below the lowest external marker above the box.\n    b.  Expand bottom edge down to one row above the highest external marker below the box.\n    c.  Expand left edge leftwards to one column right of the rightmost external marker left of the box.\n    d.  Expand right edge rightwards to one column left of the leftmost external marker right of the box.\n    e.  If no external markers exist in a direction, the corresponding edge of `new_bbox` matches `initial_bbox`.\n    f.  Clamp `new_bbox` coordinates to grid boundaries.\n    g.  Draw the hollow perimeter of `new_bbox` onto the output grid using green (3), overwriting any previously copied content.\n9.  Draw all original magenta markers (found in step 2) onto the output grid at their original coordinates, overwriting any existing pixels.\n10. Return the final output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a connected object. Objects are connected\n              cardinally (up, down, left, right). Returns an empty list if no\n              objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_coords: # ensure we found something\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) inclusive.\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    min_row = min(r for r, c in obj_coords)\n    min_col = min(c for r, c in obj_coords)\n    max_row = max(r for r, c in obj_coords)\n    max_col = max(c for r, c in obj_coords)\n    \n    return min_row, min_col, max_row, max_col\n\ndef get_bbox_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    if not bbox:\n        return 0\n    min_r, min_c, max_r, max_c = bbox\n    # Ensure non-negative dimensions before calculating area\n    height = max(0, max_r - min_r + 1)\n    width = max(0, max_c - min_c + 1)\n    return height * width\n    \ndef transform(input_grid):\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # 1. Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_np) \n\n    # 2. Find Magenta Markers\n    magenta_markers = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 6:\n                magenta_markers.append((r, c))\n\n    # 3. Find Green Objects\n    green_objects = find_objects(input_np, 3)\n    \n    main_green_object = None\n    initial_bbox = None\n\n    # 4. Check if green components exist\n    if green_objects:\n        # 5. Identify Main Green Object and its initial bounding box\n        max_area = -1\n        best_bbox_top_left = (rows, cols) # Initialize with max possible values\n\n        for obj_coords in green_objects:\n            bbox = get_bounding_box(obj_coords)\n            if not bbox: continue\n            \n            area = get_bbox_area(bbox)\n            min_r, min_c, _, _ = bbox\n            \n            if area > max_area:\n                max_area = area\n                main_green_object = obj_coords\n                initial_bbox = bbox\n                best_bbox_top_left = (min_r, min_c)\n            elif area == max_area:\n                # Tie-breaking: choose the one with the top-most, then left-most corner\n                if (min_r, min_c) < best_bbox_top_left:\n                    main_green_object = obj_coords\n                    initial_bbox = bbox\n                    best_bbox_top_left = (min_r, min_c)\n\n    # --- Process if a main green object was found ---\n    if initial_bbox:\n        initial_min_r, initial_min_c, initial_max_r, initial_max_c = initial_bbox\n\n        # 6. Copy the content within the initial bounding box\n        output_grid[initial_min_r:initial_max_r+1, initial_min_c:initial_max_c+1] = \\\n            input_np[initial_min_r:initial_max_r+1, initial_min_c:initial_max_c+1]\n\n        # 7. Identify external markers\n        external_markers = [\n            (m_r, m_c) for m_r, m_c in magenta_markers \n            if not (initial_min_r <= m_r <= initial_max_r and initial_min_c <= m_c <= initial_max_c)\n        ]\n\n        # 8. Calculate the new bounding box based on external markers\n        target_min_r = initial_min_r\n        target_max_r = initial_max_r\n        target_min_c = initial_min_c\n        target_max_c = initial_max_c\n\n        markers_above = [m_r for m_r, m_c in external_markers if m_r < initial_min_r]\n        markers_below = [m_r for m_r, m_c in external_markers if m_r > initial_max_r]\n        markers_left  = [m_c for m_r, m_c in external_markers if m_c < initial_min_c]\n        markers_right = [m_c for m_r, m_c in external_markers if m_c > initial_max_c]\n\n        if markers_above:\n            # Target top row stops one step *before* the lowest marker above\n            target_min_r = min(markers_above) + 1 \n        if markers_below:\n            # Target bottom row stops one step *before* the highest marker below\n            target_max_r = max(markers_below) - 1\n        if markers_left:\n            # Target left col stops one step *after* the rightmost marker to the left\n            target_min_c = max(markers_left) + 1 \n        if markers_right:\n            # Target right col stops one step *before* the leftmost marker to the right\n            target_max_c = min(markers_right) - 1\n\n        # Determine final new bounding box: union of initial and target areas\n        new_min_r = min(initial_min_r, target_min_r)\n        new_max_r = max(initial_max_r, target_max_r)\n        new_min_c = min(initial_min_c, target_min_c)\n        new_max_c = max(initial_max_c, target_max_c)\n        \n        # Clamp bounds to grid dimensions\n        new_min_r = max(0, new_min_r)\n        new_max_r = min(rows - 1, new_max_r)\n        new_min_c = max(0, new_min_c)\n        new_max_c = min(cols - 1, new_max_c)\n\n        # Draw the hollow green rectangle perimeter of the new bounding box\n        if new_min_r <= new_max_r and new_min_c <= new_max_c: # Check validity\n            # Draw top border\n            if new_min_r < rows:\n                output_grid[new_min_r, new_min_c:new_max_c+1] = 3\n            # Draw bottom border\n            if new_max_r >= 0:\n                output_grid[new_max_r, new_min_c:new_max_c+1] = 3\n            # Draw left border (excluding corners)\n            if new_min_c < cols and new_max_r > new_min_r: \n                 output_grid[new_min_r+1:new_max_r, new_min_c] = 3\n            # Draw right border (excluding corners)\n            if new_max_c >= 0 and new_max_r > new_min_r: \n                 output_grid[new_min_r+1:new_max_r, new_max_c] = 3\n            \n    # 9. Draw ALL Magenta Markers (overwriting anything underneath)\n    # This happens regardless of whether a green frame was found/processed\n    for r, c in magenta_markers:\n        # Ensure marker is within bounds before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = 6\n\n    # 10. Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11281,
    "candidates_token_count": 2754,
    "total_token_count": 14035,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.178613,
  "retries": null
}