{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by finding the main green (3) frame object, resizing it based on the positions of external magenta (6) markers, and drawing the resized frame on a new grid along with the original markers.\n\n1. Identifies all magenta markers and stores their coordinates.\n2. Identifies all connected green objects (potential frames).\n3. If green objects exist, determines the \"main\" green object based on the largest bounding box area. Ties are broken by the top-left corner position (min_row, then min_col).\n4. Calculates the initial bounding box of this main green object.\n5. Finds magenta markers located strictly outside the main object's initial bounding box.\n6. Calculates a target bounding box based on these external markers:\n    - Top boundary extends towards the lowest marker above, stopping one step before it.\n    - Bottom boundary extends towards the highest marker below, stopping one step before it.\n    - Left boundary extends towards the rightmost marker to the left, stopping one step before it.\n    - Right boundary extends towards the leftmost marker to the right, stopping one step before it.\n7. Determines the final new bounding box as the union of the initial box and the target expansion area. Coordinates are clamped to grid bounds.\n8. Creates an output grid initialized to white (0).\n9. Draws a hollow green rectangle representing the perimeter of the new bounding box on the output grid.\n10. Redraws all original magenta markers at their initial positions on the output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a connected object. Objects are connected\n              cardinally (up, down, left, right). Returns an empty list if no\n              objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_coords: # ensure we found something\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) inclusive.\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    min_row = min(r for r, c in obj_coords)\n    min_col = min(c for r, c in obj_coords)\n    max_row = max(r for r, c in obj_coords)\n    max_col = max(c for r, c in obj_coords)\n    \n    return min_row, min_col, max_row, max_col\n\ndef get_bbox_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    if not bbox:\n        return 0\n    min_r, min_c, max_r, max_c = bbox\n    return (max_r - min_r + 1) * (max_c - min_c + 1)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_np) \n\n    # --- Step 1: Find Magenta Markers ---\n    magenta_markers = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 6:\n                magenta_markers.append((r, c))\n\n    # --- Step 2: Find Green Objects ---\n    green_objects = find_objects(input_np, 3)\n    \n    main_green_object = None\n    if green_objects:\n        # --- Step 3: Identify Main Green Object ---\n        max_area = -1\n        best_bbox_top_left = (rows, cols) # Initialize with max possible values\n\n        for obj_coords in green_objects:\n            bbox = get_bounding_box(obj_coords)\n            if not bbox: continue\n            \n            area = get_bbox_area(bbox)\n            min_r, min_c, _, _ = bbox\n            \n            if area > max_area:\n                max_area = area\n                main_green_object = obj_coords\n                best_bbox_top_left = (min_r, min_c)\n            elif area == max_area:\n                # Tie-breaking: choose the one with the top-most, then left-most corner\n                if (min_r, min_c) < best_bbox_top_left:\n                    main_green_object = obj_coords\n                    best_bbox_top_left = (min_r, min_c)\n\n    # --- Process the main frame if found ---\n    if main_green_object:\n        # --- Step 4: Calculate initial bounding box ---\n        initial_bbox = get_bounding_box(main_green_object)\n        if not initial_bbox: # Should not happen if main_green_object is valid\n             # Draw only markers if frame finding failed unexpectedly\n             for r, c in magenta_markers:\n                 if 0 <= r < rows and 0 <= c < cols:\n                     output_grid[r, c] = 6\n             return output_grid.tolist()\n\n        initial_min_r, initial_min_c, initial_max_r, initial_max_c = initial_bbox\n\n        # --- Step 5: Find external markers ---\n        external_markers = [\n            (m_r, m_c) for m_r, m_c in magenta_markers \n            if not (initial_min_r <= m_r <= initial_max_r and initial_min_c <= m_c <= initial_max_c)\n        ]\n\n        # --- Step 6: Calculate target boundaries based on external markers ---\n        target_min_r = rows # Default: grid height (no markers above)\n        target_max_r = -1   # Default: -1 (no markers below)\n        target_min_c = cols # Default: grid width (no markers left)\n        target_max_c = -1   # Default: -1 (no markers right)\n\n        markers_above = [m_r for m_r, m_c in external_markers if m_r < initial_min_r]\n        markers_below = [m_r for m_r, m_c in external_markers if m_r > initial_max_r]\n        markers_left  = [m_c for m_r, m_c in external_markers if m_c < initial_min_c]\n        markers_right = [m_c for m_r, m_c in external_markers if m_c > initial_max_c]\n\n        if markers_above:\n            # Lowest marker above defines target top row (+1 because boundary stops before marker)\n            target_min_r = min(markers_above) + 1 \n        if markers_below:\n            # Highest marker below defines target bottom row (-1 because boundary stops before marker)\n            target_max_r = max(markers_below) - 1\n        if markers_left:\n            # Rightmost marker left defines target left col (+1) - use max coord\n            target_min_c = max(markers_left) + 1 \n        if markers_right:\n            # Leftmost marker right defines target right col (-1) - use min coord\n            target_max_c = min(markers_right) - 1\n\n        # --- Step 7: Determine final new bounding box ---\n        # Union of initial box and target expansion area\n        new_min_r = min(initial_min_r, target_min_r)\n        new_max_r = max(initial_max_r, target_max_r)\n        new_min_c = min(initial_min_c, target_min_c)\n        new_max_c = max(initial_max_c, target_max_c)\n        \n        # --- Step 8: Clamp bounds to grid dimensions ---\n        new_min_r = max(0, new_min_r)\n        new_max_r = min(rows - 1, new_max_r)\n        new_min_c = max(0, new_min_c)\n        new_max_c = min(cols - 1, new_max_c)\n\n        # --- Step 9 & 10: Draw hollow green rectangle ---\n        # Check if the calculated box has valid dimensions before drawing\n        if new_min_r <= new_max_r and new_min_c <= new_max_c:\n            # Draw top border\n            output_grid[new_min_r, new_min_c:new_max_c+1] = 3\n            # Draw bottom border\n            output_grid[new_max_r, new_min_c:new_max_c+1] = 3\n            # Draw left border (excluding corners already drawn)\n            if new_max_r > new_min_r: # Avoid index error for single row boxes\n                 output_grid[new_min_r+1:new_max_r, new_min_c] = 3\n            # Draw right border (excluding corners already drawn)\n            if new_max_r > new_min_r and new_max_c > new_min_c: # Avoid index error and overdraw for single row/col boxes\n                 output_grid[new_min_r+1:new_max_r, new_max_c] = 3\n            \n    # --- Step 11: Redraw Magenta Markers ---\n    # This happens regardless of whether a green frame was found/processed\n    for r, c in magenta_markers:\n        # Ensure marker is within bounds before drawing (should always be)\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = 6\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6731,
    "candidates_token_count": 2686,
    "total_token_count": 9417,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 112.091254,
  "retries": null
}