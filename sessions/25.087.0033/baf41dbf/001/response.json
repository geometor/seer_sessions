{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies green (3) rectangular frames and magenta (6) markers in the input grid.\nFor each green frame, it determines its initial bounding box.\nIt then searches for magenta markers located strictly outside this initial bounding box.\nThe frame's boundaries are expanded outwards (up, down, left, right) to align with the row/column of the outermost magenta markers found in each respective direction.\nA new output grid is created, initially all white (0).\nThe expanded green frames are drawn onto this output grid. The area inside the frame remains white (0).\nFinally, the original magenta markers are redrawn in their original positions on the output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a connected object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 cardinal neighbors (no diagonals needed for frames)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_coords: # ensure we found something\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) inclusive.\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    min_row = min(r for r, c in obj_coords)\n    min_col = min(c for r, c in obj_coords)\n    max_row = max(r for r, c in obj_coords)\n    max_col = max(c for r, c in obj_coords)\n    \n    return min_row, min_col, max_row, max_col\n\n# Basic check, assumes objects found are frames if they look like it.\n# A more robust check could verify pixel counts match perimeter, etc.\n# def is_hollow_rectangle(grid, obj_coords, bbox):\n#     min_r, min_c, max_r, max_c = bbox\n#     width = max_c - min_c + 1\n#     height = max_r - min_r + 1\n    \n#     # Check perimeter pixels - are they all in obj_coords?\n#     for c in range(min_c, max_c + 1):\n#         if (min_r, c) not in obj_coords or (max_r, c) not in obj_coords:\n#             return False\n#     for r in range(min_r + 1, max_r):\n#         if (r, min_c) not in obj_coords or (r, max_c) not in obj_coords:\n#             return False\n            \n#     # Check interior pixels - are they NOT in obj_coords? (should be 0)\n#     for r in range(min_r + 1, max_r):\n#         for c in range(min_c + 1, max_c):\n#             if (r, c) in obj_coords:\n#                 return False\n#             # Optional: check if interior is specifically white(0)\n#             # if grid[r, c] != 0: return False \n            \n#     # Check pixel count matches perimeter\n#     expected_perimeter_pixels = 0\n#     if width > 0 and height > 0:\n#         if width == 1 and height == 1:\n#              expected_perimeter_pixels = 1\n#         elif width == 1:\n#              expected_perimeter_pixels = height\n#         elif height == 1:\n#              expected_perimeter_pixels = width\n#         else:\n#              expected_perimeter_pixels = 2 * width + 2 * height - 4\n             \n#     return len(obj_coords) == expected_perimeter_pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by expanding green frames towards magenta markers.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np) # Start with a blank (white) grid\n\n    # --- Step 1: Find Magenta Markers ---\n    magenta_markers = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 6:\n                magenta_markers.append((r, c))\n\n    # --- Step 2: Find Green Objects and their original BBoxes ---\n    green_objects = find_objects(input_np, 3)\n    original_bboxes = []\n    for obj_coords in green_objects:\n        bbox = get_bounding_box(obj_coords)\n        if bbox:\n             # Assuming found green objects are the frames as per examples\n             # Add more robust check like is_hollow_rectangle if needed\n            original_bboxes.append(bbox)\n\n    # --- Step 3: Calculate New Bounding Boxes ---\n    new_bboxes = []\n    for min_r, min_c, max_r, max_c in original_bboxes:\n        new_min_r, new_min_c, new_max_r, new_max_c = min_r, min_c, max_r, max_c\n\n        # Find markers outside the original box and update new boundaries\n        markers_above = [m_r for m_r, m_c in magenta_markers if m_r < min_r]\n        markers_below = [m_r for m_r, m_c in magenta_markers if m_r > max_r]\n        markers_left = [m_c for m_r, m_c in magenta_markers if m_c < min_c]\n        markers_right = [m_c for m_r, m_c in magenta_markers if m_c > max_c]\n\n        if markers_above:\n            new_min_r = min(markers_above)\n        if markers_below:\n            new_max_r = max(markers_below)\n        if markers_left:\n            new_min_c = min(markers_left)\n        if markers_right:\n            new_max_c = max(markers_right)\n            \n        new_bboxes.append((new_min_r, new_min_c, new_max_r, new_max_c))\n\n    # --- Step 4: Draw New Frames on Output Grid ---\n    for r1, c1, r2, c2 in new_bboxes:\n        # Ensure coordinates are within grid bounds (although expansion logic should handle this)\n        r1, c1 = max(0, r1), max(0, c1)\n        r2, c2 = min(rows - 1, r2), min(cols - 1, c2)\n\n        # Draw frame border if the box has valid dimensions\n        if r1 <= r2 and c1 <= c2:\n            output_grid[r1, c1:c2+1] = 3  # Top border\n            output_grid[r2, c1:c2+1] = 3  # Bottom border\n            output_grid[r1:r2+1, c1] = 3  # Left border\n            output_grid[r1:r2+1, c2] = 3  # Right border\n\n    # --- Step 5: Redraw Magenta Markers ---\n    for r, c in magenta_markers:\n        # Ensure marker is within bounds before drawing\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = 6\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4740,
    "candidates_token_count": 2126,
    "total_token_count": 6866,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.577146,
  "retries": null
}