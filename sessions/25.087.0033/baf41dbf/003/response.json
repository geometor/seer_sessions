{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by resizing green (3) frame objects based on the positions of magenta (6) markers.\n\n1. Identifies all magenta markers and stores their coordinates.\n2. Identifies all connected green objects (frames).\n3. For each green frame:\n    a. Calculates its initial bounding box.\n    b. Finds magenta markers located strictly outside this initial box.\n    c. Calculates a target bounding box based on these external markers, expanding outwards but stopping one step short of the marker's row/column.\n    d. Determines the final new bounding box as the union of the initial box and the target expansion area.\n    e. Draws a hollow green rectangle representing the perimeter of this new bounding box on an initially white output grid.\n4. After drawing all resized frames, redraws all original magenta markers at their initial positions on the output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples\n              of pixels belonging to a connected object. Objects are connected\n              cardinally (up, down, left, right).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_coords: # ensure we found something\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) inclusive.\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    min_row = min(r for r, c in obj_coords)\n    min_col = min(c for r, c in obj_coords)\n    max_row = max(r for r, c in obj_coords)\n    max_col = max(c for r, c in obj_coords)\n    \n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_np) \n\n    # --- Step 1: Find Magenta Markers ---\n    magenta_markers = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 6:\n                magenta_markers.append((r, c))\n\n    # --- Step 2: Find Green Objects (Frames) ---\n    green_objects = find_objects(input_np, 3)\n    \n    # --- Step 3 & 4: Process each frame, calculate new bbox, draw frame ---\n    for obj_coords in green_objects:\n        # --- Step 3a: Calculate initial bounding box ---\n        initial_bbox = get_bounding_box(obj_coords)\n        if not initial_bbox:\n            continue # Should not happen if find_objects returns non-empty sets\n        \n        initial_min_r, initial_min_c, initial_max_r, initial_max_c = initial_bbox\n\n        # --- Step 3b: Find external markers ---\n        external_markers = [\n            (m_r, m_c) for m_r, m_c in magenta_markers \n            if not (initial_min_r <= m_r <= initial_max_r and initial_min_c <= m_c <= initial_max_c)\n        ]\n\n        # --- Step 3c: Calculate target boundaries based on external markers ---\n        target_min_r = rows # Default: grid height (no markers above)\n        target_max_r = -1   # Default: -1 (no markers below)\n        target_min_c = cols # Default: grid width (no markers left)\n        target_max_c = -1   # Default: -1 (no markers right)\n\n        markers_above = [m_r for m_r, m_c in external_markers if m_r < initial_min_r]\n        markers_below = [m_r for m_r, m_c in external_markers if m_r > initial_max_r]\n        markers_left  = [m_c for m_r, m_c in external_markers if m_c < initial_min_c]\n        markers_right = [m_c for m_r, m_c in external_markers if m_c > initial_max_c]\n\n        if markers_above:\n            # Lowest marker above defines target top row (+1 because boundary stops before marker)\n            target_min_r = min(markers_above) + 1 \n        if markers_below:\n            # Highest marker below defines target bottom row (-1 because boundary stops before marker)\n            target_max_r = max(markers_below) - 1\n        if markers_left:\n            # Rightmost marker left defines target left col (+1)\n            target_min_c = min(markers_left) + 1 # Bugfix: Should be max(markers_left) + 1? No, min coordinate + 1. Example 1/3 analysis confirms min(coord) + 1. Example 1: marker (3,1), initial min_c 4 -> new_min_c min(4, 1+1)=2. Example 3: marker (6,1), initial min_c 4 -> new_min_c min(4, 1+1)=2.\n        if markers_right:\n            # Leftmost marker right defines target right col (-1)\n            target_max_c = max(markers_right) - 1 # Bugfix: Should be min(markers_right) - 1? No, max coordinate - 1. Example 2 analysis confirms max(coord) - 1. Example 2: marker (2,11), initial max_c 6 -> new_max_c max(6, 11-1)=10. Example 3: marker (4,12), initial max_c 9 -> new_max_c max(9, 12-1)=11.\n\n        # --- Step 3d: Determine final new bounding box ---\n        # Union of initial box and target expansion area\n        new_min_r = min(initial_min_r, target_min_r)\n        new_max_r = max(initial_max_r, target_max_r)\n        new_min_c = min(initial_min_c, target_min_c)\n        new_max_c = max(initial_max_c, target_max_c)\n        \n        # Ensure calculated bounds are valid within the grid - clamp if necessary.\n        # The logic should inherently keep them mostly valid, but clamping adds robustness.\n        new_min_r = max(0, new_min_r)\n        new_max_r = min(rows - 1, new_max_r)\n        new_min_c = max(0, new_min_c)\n        new_max_c = min(cols - 1, new_max_c)\n\n        # --- Step 4e: Draw hollow green rectangle ---\n        # Check if the calculated box has valid dimensions before drawing\n        if new_min_r <= new_max_r and new_min_c <= new_max_c:\n            # Draw top border\n            output_grid[new_min_r, new_min_c:new_max_c+1] = 3\n            # Draw bottom border\n            output_grid[new_max_r, new_min_c:new_max_c+1] = 3\n            # Draw left border\n            output_grid[new_min_r:new_max_r+1, new_min_c] = 3\n            # Draw right border\n            output_grid[new_min_r:new_max_r+1, new_max_c] = 3\n            \n    # --- Step 5: Redraw Magenta Markers ---\n    for r, c in magenta_markers:\n        # Ensure marker is within bounds before drawing (should always be)\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = 6\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15659,
    "candidates_token_count": 2299,
    "total_token_count": 17958,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 369.303529,
  "retries": null
}