{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by identifying pairs of vertically aligned objects. \nFor each pair, the upper object is shifted one column to the left, and the \nlower object is shifted one column to the right. The output grid is \nreconstructed with these shifted objects against the original background color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque, Counter\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds connected components (objects) of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains its 'color' and 'coords' (a set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not background and not visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                coords.add((r, c))\n                \n                # BFS to find all connected cells of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Check 4-directional neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and color match\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            coords.add((nr, nc))\n                            \n                # Store the found object\n                if coords:\n                    objects.append({'color': color, 'coords': coords})\n    return objects\n\ndef find_vertical_pairs(objects):\n    \"\"\"\n    Identifies pairs of objects where one is vertically above the other and\n    they share at least one column.\n\n    Args:\n        objects (list): A list of object dictionaries (from find_objects).\n\n    Returns:\n        list: A list of tuples, where each tuple contains the indices of the\n              (upper_object, lower_object) in the original objects list.\n    \"\"\"\n    pairs = []\n    num_objects = len(objects)\n    if num_objects < 2:\n        return pairs\n\n    # Precompute object properties (coordinates, columns, row range)\n    obj_props = []\n    for obj in objects:\n        coords = obj['coords']\n        if not coords: continue \n        rows = {r for r, c in coords}\n        cols = {c for r, c in coords}\n        min_r = min(rows)\n        max_r = max(rows)\n        obj_props.append({'cols': cols, 'min_r': min_r, 'max_r': max_r})\n\n    # Compare each pair of objects (i, j)\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            props_i = obj_props[i]\n            props_j = obj_props[j]\n\n            # Check if they share any columns\n            shared_cols = props_i['cols'].intersection(props_j['cols'])\n            if not shared_cols:\n                continue\n\n            # Check for vertical alignment based on row ranges\n            # If max row of i is less than min row of j, i is above j\n            if props_i['max_r'] < props_j['min_r']:\n                pairs.append((i, j)) # Store indices: (upper, lower)\n            # If max row of j is less than min row of i, j is above i\n            elif props_j['max_r'] < props_i['min_r']:\n                pairs.append((j, i)) # Store indices: (upper, lower)\n\n    return pairs\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: shifts upper objects left and lower \n    objects right within vertically aligned pairs.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n\n    # 1. Identify Background Color (most frequent color)\n    colors, counts = np.unique(input_array, return_counts=True)\n    if len(colors) > 0:\n        background_color = colors[np.argmax(counts)]\n    else: # Handle empty grid case\n        background_color = 0 # Default to white\n\n    # 2. Find Objects\n    objects = find_objects(input_array, background_color)\n\n    # 3. Identify Vertical Pairs\n    # Returns list of tuples: [(upper_obj_index, lower_obj_index), ...]\n    vertical_pairs = find_vertical_pairs(objects)\n\n    # 4. Determine which objects shift left and which shift right\n    objects_to_shift_left_indices = set(pair[0] for pair in vertical_pairs)\n    objects_to_shift_right_indices = set(pair[1] for pair in vertical_pairs)\n\n    # 5. Construct Output Grid\n    # Initialize with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # Apply shifts by drawing objects in their new positions\n    for i, obj in enumerate(objects):\n        obj_color = obj['color']\n        coords = obj['coords']\n\n        # Apply left shift if this object is an upper object in a pair\n        if i in objects_to_shift_left_indices:\n            for r, c in coords:\n                if c > 0: # Ensure the new column is within bounds\n                    output_grid[r, c - 1] = obj_color\n        # Apply right shift if this object is a lower object in a pair\n        elif i in objects_to_shift_right_indices:\n            for r, c in coords:\n                if c < width - 1: # Ensure the new column is within bounds\n                    output_grid[r, c + 1] = obj_color\n        # Note: Based on observed examples, objects not part of a pair are not \n        # explicitly handled, as all non-background objects seem to be in pairs.\n        # If an object was not part of any pair, it wouldn't be drawn here.\n\n    # 6. Return the transformed grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7016,
    "candidates_token_count": 1640,
    "total_token_count": 8656,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.945869,
  "retries": null
}