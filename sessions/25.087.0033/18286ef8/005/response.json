{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the following rule:\n1. Initialize: Create a copy of the input grid to serve as the output grid.\n2. Locate Source: Find the unique 3x3 pattern consisting of a maroon (9) center pixel surrounded by eight gray (5) pixels. Record the coordinates of the center pixel as (r_s, c_s). If not found, return the grid unchanged.\n3. Locate Target 1: Find the unique magenta (6) pixel in the grid. Record its coordinates as (r_t1, c_t1). If not found, return the grid unchanged.\n4. Calculate Vector: Compute the vector V = (dr, dc) pointing from the source center to Target 1: dr = r_t1 - r_s, dc = c_t1 - c_s.\n5. Determine Neighbor Offset: Calculate the offset (dr_n, dc_n) to find the neighbor pixel relative to the source center (r_s, c_s) based on the vector V:\n    - If dr is 0 and dc is 0, the offset is (0, 0).\n    - If dr is 0 (and dc is not 0), the offset is (0, sign(dc)).\n    - If dc is 0 (and dr is not 0), the offset is (sign(dr), 0).\n    - If neither dr nor dc is 0:\n        - Calculate the ratio R = min(abs(dr), abs(dc)) / max(abs(dr), abs(dc)).\n        - Define a threshold T = 0.3.\n        - If R < T (vector is strongly cardinal):\n            - If abs(dr) > abs(dc), the offset is (sign(dr), 0).\n            - Otherwise (i.e., abs(dc) >= abs(dr)), the offset is (0, sign(dc)).\n        - If R >= T (vector is substantially diagonal or components are equal):\n            - The offset is (sign(dr), sign(dc)).\n6. Calculate Neighbor Coordinates: Determine the coordinates of the neighbor pixel (Target 2) by adding the offset to the source center coordinates: (r_n, c_n) = (r_s + dr_n, c_s + dc_n).\n7. Modify Source: Change the color of the pixel at the source center coordinates (r_s, c_s) in the output grid from maroon (9) to gray (5).\n8. Modify Target 1: Change the color of the pixel at the Target 1 coordinates (r_t1, c_t1) in the output grid from magenta (6) to maroon (9).\n9. Modify Neighbor (Target 2): Check if the calculated neighbor coordinates (r_n, c_n) are valid (within the grid boundaries) and different from the source coordinates (r_s, c_s). If valid and different, change the color of the pixel at (r_n, c_n) in the output grid from gray (5) to maroon (9).\n10. Return: Return the modified output grid.\n\"\"\"\n\ndef find_pattern_center(grid):\n    \"\"\"\n    Finds the center coordinates (r, c) of the 3x3 pattern with a gray (5) border \n    and a maroon (9) center.\n    Returns None if the pattern is not found.\n    \"\"\"\n    height, width = grid.shape\n    # Iterate only over possible center coordinates (avoiding edges)\n    for r in range(1, height - 1):\n        for c in range(1, width - 1):\n            # Check if the center is maroon (9)\n            if grid[r, c] == 9:\n                # Check the 3x3 neighborhood for gray (5) border\n                is_pattern = True\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        # Skip the center pixel itself\n                        if dr == 0 and dc == 0:\n                            continue\n                        # Check if border pixel is gray (5)\n                        nr, nc = r + dr, c + dc\n                        # Ensure neighbor is within bounds AND is gray\n                        if not (0 <= nr < height and 0 <= nc < width and grid[nr, nc] == 5):\n                            is_pattern = False\n                            break\n                    if not is_pattern:\n                        break\n                \n                # If the 3x3 pattern matches, return the center coordinates\n                if is_pattern:\n                    return r, c\n    # Return None if the pattern was not found in the grid\n    return None \n\ndef find_unique_pixel(grid, color):\n    \"\"\"\n    Finds the coordinates (r, c) of the unique pixel with the specified color.\n    Returns None if the pixel is not found or if more than one is found.\n    \"\"\"\n    # Find all locations of the specified color\n    locations = np.argwhere(grid == color)\n    # Check if exactly one location was found\n    if len(locations) == 1:\n        # Return the coordinates of the unique pixel\n        return tuple(locations[0])\n    # Return None if zero or more than one pixel of that color exists\n    return None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    \n    # 1. Initialize: Create a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n    \n    # 2. Locate Source (maroon center of gray pattern)\n    source_coords = find_pattern_center(output_grid)\n    if source_coords is None:\n        # print(\"Warning: Source pattern (gray border, maroon center) not found.\")\n        return output_grid # Return unchanged if pattern not found\n\n    # 3. Locate Target 1 (unique magenta pixel)\n    target1_coords = find_unique_pixel(output_grid, 6) # 6 is magenta\n    if target1_coords is None:\n        # print(\"Warning: Unique magenta (6) pixel not found.\")\n        return output_grid # Return unchanged if unique magenta not found\n        \n    r_s, c_s = source_coords\n    r_t1, c_t1 = target1_coords\n\n    # 4. Calculate the relative vector V = (dr, dc)\n    dr = r_t1 - r_s\n    dc = c_t1 - c_s\n\n    # 5. Determine the neighbor offset (dr_n, dc_n)\n    dr_n, dc_n = 0, 0\n    threshold = 0.3 \n    \n    if dr == 0 and dc == 0:\n        dr_n, dc_n = 0, 0 # Source and Target1 are the same, no neighbor change\n    elif dr == 0: # Purely horizontal move\n        dc_n = np.sign(dc)\n    elif dc == 0: # Purely vertical move\n        dr_n = np.sign(dr)\n    else: # Both dr and dc are non-zero\n        # Use float division for ratio\n        ratio = min(abs(float(dr)), abs(float(dc))) / max(abs(float(dr)), abs(float(dc)))\n        \n        if ratio < threshold:\n            # Cardinal direction based on dominance\n            if abs(dr) > abs(dc):\n                 dr_n = np.sign(dr) # More vertical than horizontal\n            else: # abs(dc) >= abs(dr) # More horizontal or equal (tie-break to horizontal if ratio < threshold, though this case implies inequality)\n                 dc_n = np.sign(dc)\n        else: # ratio >= threshold\n            # Diagonal direction\n            dr_n = np.sign(dr)\n            dc_n = np.sign(dc)\n            \n    # 6. Calculate Neighbor Coordinates (Target 2)\n    r_n = r_s + dr_n\n    c_n = c_s + dc_n\n        \n    # 7. Modify Source: Change the source pixel's color (center of pattern) to gray (5)\n    output_grid[r_s, c_s] = 5 \n\n    # 8. Modify Target 1: Change the target1 pixel's color (original magenta) to maroon (9)\n    output_grid[r_t1, c_t1] = 9\n    \n    # 9. Modify Neighbor (Target 2): Change the neighbor pixel's color to maroon (9)\n    # Ensure coordinates are valid (within bounds) and not the same as the source center\n    if (dr_n != 0 or dc_n != 0) and (0 <= r_n < height and 0 <= c_n < width):\n        # We assume based on examples that this neighbor is initially gray(5)\n        output_grid[r_n, c_n] = 9\n    # else:\n        # Handle edge cases or unexpected conditions if needed\n        # if not (0 <= r_n < height and 0 <= c_n < width):\n        #     print(f\"Warning: Calculated neighbor ({r_n}, {c_n}) is out of bounds.\")\n        # if dr_n == 0 and dc_n == 0:\n        #     print(\"Warning: Source and Target1 are the same, no neighbor change.\")\n        # pass # Do nothing if neighbor is out of bounds or same as source\n\n    # 10. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17404,
    "candidates_token_count": 2195,
    "total_token_count": 19599,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.183158,
  "retries": null
}