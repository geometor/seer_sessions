{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the following rule:\n1. Locate the unique 3x3 pattern with a gray (5) border and a maroon (9) center. Let the center be (r_s, c_s).\n2. Locate the unique magenta (6) pixel. Let its coordinates be (r_t1, c_t1).\n3. Calculate the relative vector V = (dr, dc) = (r_t1 - r_s, c_t1 - c_s).\n4. Determine the primary direction based on the component of V with the larger absolute magnitude. If magnitudes are equal, prioritize the vertical (North/South) direction.\n    - If |dr| >= |dc|, the primary direction is North (if dr < 0) or South (if dr >= 0).\n    - If |dc| > |dr|, the primary direction is West (if dc < 0) or East (if dc > 0).\n5. Determine the coordinates (r_n, c_n) of the gray (5) neighbor adjacent to the center (r_s, c_s) in the primary direction.\n6. Create the output grid by copying the input grid.\n7. Change the pixel at (r_s, c_s) from maroon (9) to gray (5).\n8. Change the pixel at (r_t1, c_t1) from magenta (6) to maroon (9).\n9. Change the pixel at the neighbor coordinates (r_n, c_n) from gray (5) to maroon (9).\n\"\"\"\n\ndef find_pattern_center(grid):\n    \"\"\"\n    Finds the center coordinates (r, c) of the 3x3 pattern with a gray (5) border \n    and a maroon (9) center.\n    Returns None if the pattern is not found.\n    \"\"\"\n    height, width = grid.shape\n    # Iterate only over possible center coordinates (avoiding edges)\n    for r in range(1, height - 1):\n        for c in range(1, width - 1):\n            # Check if the center is maroon (9)\n            if grid[r, c] == 9:\n                # Check the 3x3 neighborhood for gray (5) border\n                is_pattern = True\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        # Skip the center pixel itself\n                        if dr == 0 and dc == 0:\n                            continue\n                        # Check if border pixel is gray (5)\n                        if grid[r + dr, c + dc] != 5:\n                            is_pattern = False\n                            break\n                    if not is_pattern:\n                        break\n                \n                # If the 3x3 pattern matches, return the center coordinates\n                if is_pattern:\n                    return r, c\n    # Return None if the pattern was not found in the grid\n    return None \n\ndef find_unique_pixel(grid, color):\n    \"\"\"\n    Finds the coordinates (r, c) of the unique pixel with the specified color.\n    Returns None if the pixel is not found or if more than one is found.\n    \"\"\"\n    # Find all locations of the specified color\n    locations = np.argwhere(grid == color)\n    # Check if exactly one location was found\n    if len(locations) == 1:\n        # Return the coordinates of the unique pixel\n        return tuple(locations[0])\n    # Return None if zero or more than one pixel of that color exists\n    return None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find the source pixel (center of the gray/maroon pattern)\n    source_coords = find_pattern_center(output_grid)\n    if source_coords is None:\n        # If the pattern is not found, return the grid unchanged (as per examples)\n        # print(\"Warning: Source pattern (gray border, maroon center) not found.\")\n        return output_grid \n\n    # 2. Find the target pixel (the unique magenta pixel)\n    target1_coords = find_unique_pixel(output_grid, 6) # 6 is magenta\n    if target1_coords is None:\n        # If the unique magenta pixel is not found, return the grid unchanged\n        # print(\"Warning: Unique magenta (6) pixel not found.\")\n        return output_grid \n        \n    r_s, c_s = source_coords\n    r_t1, c_t1 = target1_coords\n\n    # 3. Calculate the relative vector V = (dr, dc)\n    dr = r_t1 - r_s\n    dc = c_t1 - c_s\n\n    # 4. Determine the primary direction and neighbor offset (dr_n, dc_n)\n    dr_n, dc_n = 0, 0\n    if abs(dr) >= abs(dc):\n        # Vertical direction is primary or equal\n        if dr > 0: \n            dr_n = 1 # South\n        elif dr < 0:\n             dr_n = -1 # North\n        # If dr == 0 (and dc == 0), offset remains (0,0), neighbor is center itself.\n        # This case implies source == target, which shouldn't happen based on examples.\n        # If dr == 0 and dc != 0 but abs(dr) >= abs(dc) is technically true, \n        # it means dc must be 0. We default dr_n to 0. The target neighbor logic needs care.\n        # Let's refine: if dr==0 and dc==0, no neighbor change. If dr==0 and dc!=0, horizontal is dominant.\n        # The condition abs(dr) >= abs(dc) handles the tie-break correctly if dr!=0 or dc!=0.\n        # If dr > 0, dr_n=1. If dr < 0, dr_n = -1. If dr=0 (and abs(dc)<=abs(dr)), then dc must be 0, so dr_n=0, dc_n=0.\n        \n    else: # abs(dc) > abs(dr)\n        # Horizontal direction is primary\n        if dc > 0:\n            dc_n = 1 # East\n        elif dc < 0:\n            dc_n = -1 # West\n            \n    # 5. Determine the coordinates (r_n, c_n) of the target neighbor\n    # Ensure source and target are distinct to avoid neighbor being the source itself\n    if dr_n != 0 or dc_n != 0: \n        r_n = r_s + dr_n\n        c_n = c_s + dc_n\n        \n        # Check bounds for neighbor coordinates\n        height, width = output_grid.shape\n        if 0 <= r_n < height and 0 <= c_n < width:\n            # 9. Change the pixel at the neighbor coordinates (r_n, c_n) to maroon (9)\n            # We assume based on examples that this neighbor is always gray(5)\n            output_grid[r_n, c_n] = 9\n        else:\n             # Handle edge case: neighbor is outside grid (shouldn't happen with pattern search)\n             # print(f\"Warning: Calculated neighbor ({r_n}, {c_n}) is out of bounds.\")\n             pass # Do nothing if neighbor is out of bounds\n\n    # 7. Change the source pixel's color (center of pattern) to gray (5)\n    output_grid[r_s, c_s] = 5 \n\n    # 8. Change the target1 pixel's color (original magenta) to maroon (9)\n    output_grid[r_t1, c_t1] = 9\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12033,
    "candidates_token_count": 1844,
    "total_token_count": 13877,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.234662,
  "retries": null
}