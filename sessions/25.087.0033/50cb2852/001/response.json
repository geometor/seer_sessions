{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies solid rectangular blocks of non-white colors in the input grid. \nFor each block that has a height and width greater than 2, it changes the color \nof the interior pixels (excluding the 1-pixel border) to azure (8). \nPixels belonging to the border, the background (white, 0), or blocks too small \nto have an interior remain unchanged.\n\"\"\"\n\ndef find_solid_rectangles(grid):\n    \"\"\"\n    Finds solid rectangular blocks of non-white colors using Breadth-First Search (BFS).\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        list: A list of tuples, where each tuple represents a found solid rectangle\n              and contains (color, r_min, c_min, r_max, c_max).\n              - color: The color of the rectangle.\n              - r_min, c_min: Coordinates of the top-left corner.\n              - r_max, c_max: Coordinates of the bottom-right corner.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool) # Keep track of visited pixels\n    rectangles = [] # List to store properties of found rectangles\n\n    # Iterate through each pixel of the grid\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white (not 0) and hasn't been visited yet, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c] # Get the color of the potential object\n                q = [(r, c)] # Initialize queue for BFS with the starting pixel\n                visited[r, c] = True # Mark starting pixel as visited\n                pixels = set([(r, c)]) # Set to store all pixels belonging to this object\n                \n                # Initialize bounding box for the current object\n                r_min, c_min = r, c\n                r_max, c_max = r, c\n\n                # Perform BFS to find all connected pixels of the same color\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    \n                    # Update bounding box coordinates\n                    r_min = min(r_min, row)\n                    c_min = min(c_min, col)\n                    r_max = max(r_max, row)\n                    c_max = max(c_max, col)\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                           # Check if neighbor has the same color and hasn't been visited\n                           if not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True # Mark neighbor as visited\n                                q.append((nr, nc)) # Add neighbor to the queue\n                                pixels.add((nr, nc)) # Add neighbor to the set of object pixels\n\n                # After BFS, check if the identified object is a solid rectangle\n                rect_height = r_max - r_min + 1\n                rect_width = c_max - c_min + 1\n                is_solid_rectangle = True\n                \n                # Condition 1: The number of pixels found must equal the area of the bounding box\n                if len(pixels) != rect_height * rect_width:\n                    is_solid_rectangle = False\n                else:\n                    # Condition 2: Verify all pixels within the bounding box actually match the color\n                    # This confirms the shape is solid and rectangular.\n                    for row_idx in range(r_min, r_max + 1):\n                        for col_idx in range(c_min, c_max + 1):\n                            if grid[row_idx, col_idx] != color:\n                                is_solid_rectangle = False\n                                break\n                        if not is_solid_rectangle:\n                            break\n                \n                # If it's confirmed to be a solid rectangle, add its properties to the list\n                if is_solid_rectangle:\n                    rectangles.append((color, r_min, c_min, r_max, c_max))\n                    # Make sure all pixels within this confirmed rectangle are marked visited\n                    # This prevents issues if BFS somehow didn't cover every pixel within the bounds,\n                    # although the len(pixels) check should handle this.\n                    visited[r_min:r_max+1, c_min:c_max+1] = True\n                           \n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by changing the color of the interior pixels \n    of solid rectangular blocks (with height > 2 and width > 2) to azure (8).\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Initialize the output grid as a copy of the input grid\n    output_array = np.copy(input_array)\n    \n    # Find all solid rectangular objects in the input grid\n    solid_rects = find_solid_rectangles(input_array)\n    \n    # Define the color to use for filling the interior\n    fill_color = 8 # azure\n\n    # Process each found solid rectangle\n    for _color, r_min, c_min, r_max, c_max in solid_rects:\n        # Calculate the height and width of the rectangle\n        height = r_max - r_min + 1\n        width = c_max - c_min + 1\n        \n        # Check if the rectangle is large enough to have an interior region\n        # An interior exists only if height > 2 and width > 2\n        if height > 2 and width > 2:\n            # Determine the slice indices for the interior region\n            # The interior starts one pixel in from each border\n            interior_r_start = r_min + 1\n            interior_r_end = r_max # NumPy slice upper bound is exclusive\n            interior_c_start = c_min + 1\n            interior_c_end = c_max # NumPy slice upper bound is exclusive\n            \n            # Update the output array by setting the interior pixels to the fill color\n            output_array[interior_r_start:interior_r_end, interior_c_start:interior_c_end] = fill_color\n            \n    # Convert the resulting NumPy array back to a list of lists format\n    output_grid = output_array.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3831,
    "candidates_token_count": 1622,
    "total_token_count": 5453,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 50.488371,
  "retries": null
}