{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a grid based on the following rules:\n1.  Identifies Magenta (6) shapes on an Azure (8) background.\n2.  Identifies connected regions of Azure (8) pixels that are fully enclosed by Magenta (6) pixels (using 8-way adjacency for checking enclosure) and do not touch the grid boundary.\n3.  Fills enclosed Azure regions with Yellow (4) if the region contains more than one pixel. Single-pixel enclosed Azure regions remain Azure.\n4.  Adds a Green (3) border (including diagonals, 8-way adjacency) around each Magenta shape by changing adjacent Azure pixels to Green.\n5.  Crucially, if an Azure pixel qualifies for both becoming part of a Yellow fill (step 3) and a Green border (step 4), it becomes Yellow. Green borders only replace Azure pixels that are *not* part of a multi-pixel enclosed region.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _get_neighbors(r, c, rows, cols, connectivity=8):\n    \"\"\"Get valid neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonal neighbors if connectivity is 4\n            if connectivity == 4 and abs(dr) + abs(dc) > 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if _is_valid(nr, nc, rows, cols):\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the enclosure filling and bordering transformation to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = input_np.copy() # Start with a copy\n\n    # --- Step 1: Identify Azure pixels reachable from the boundary ---\n    visited_reachable = np.zeros_like(input_np, dtype=bool)\n    q_reachability = deque()\n\n    # Add boundary Azure pixels to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not visited_reachable[r, c] and input_np[r, c] == 8: # Azure\n                q_reachability.append((r, c))\n                visited_reachable[r, c] = True\n    for c in range(1, cols - 1): # Avoid double-counting corners\n        for r in [0, rows - 1]:\n             if not visited_reachable[r, c] and input_np[r, c] == 8: # Azure\n                q_reachability.append((r, c))\n                visited_reachable[r, c] = True\n\n    # Perform BFS to find all Azure pixels reachable from the boundary (using 8-way adjacency)\n    while q_reachability:\n        r, c = q_reachability.popleft()\n        # Check 8 neighbors\n        for nr, nc in _get_neighbors(r, c, rows, cols, connectivity=8):\n            if not visited_reachable[nr, nc] and input_np[nr, nc] == 8: # Azure\n                visited_reachable[nr, nc] = True\n                q_reachability.append((nr, nc))\n\n    # --- Step 2: Identify enclosed Azure regions and mark for Yellow fill ---\n    visited_holes = np.zeros_like(input_np, dtype=bool)\n    yellow_pixels = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's an Azure pixel, wasn't reached from boundary, and hasn't been visited for holes yet\n            if input_np[r, c] == 8 and not visited_reachable[r, c] and not visited_holes[r, c]:\n                # Found the start of a potential enclosed Azure component\n                current_hole_pixels = []\n                q_hole = deque([(r, c)])\n                visited_holes[r, c] = True\n                is_truly_enclosed = True # Check if all non-component neighbors are magenta - technically redundant because of boundary check, but good practice\n\n                # BFS to find the full component (using 8-way adjacency)\n                while q_hole:\n                    hr, hc = q_hole.popleft()\n                    current_hole_pixels.append((hr, hc))\n\n                    for nhr, nhc in _get_neighbors(hr, hc, rows, cols, connectivity=8):\n                        neighbor_val = input_np[nhr, nhc]\n                        if neighbor_val == 8: # Azure\n                            if not visited_reachable[nhr, nhc] and not visited_holes[nhr, nhc]:\n                                visited_holes[nhr, nhc] = True\n                                q_hole.append((nhr, nhc))\n                        # Check for non-magenta neighbors (excluding other parts of the hole itself)\n                        # This check ensures it's *only* surrounded by Magenta or itself.\n                        # Since we already know it's not reachable from the boundary (which has Azure or is outside),\n                        # any non-Magenta neighbor implies it's not truly enclosed by *only* Magenta.\n                        # However, the boundary reachability check *should* cover this.\n                        # elif neighbor_val != 6: # If neighbor is not Magenta and not part of the growing hole\n                        #     # We need to be careful here. A neighbor might be part of the hole but not yet visited.\n                        #     # The logic based on visited_reachable is sufficient.\n                        #     pass\n\n\n                # If the hole component has more than one pixel, mark it for yellow fill\n                if len(current_hole_pixels) > 1:\n                    for hr, hc in current_hole_pixels:\n                        yellow_pixels.add((hr, hc))\n\n    # --- Step 3: Identify potential Green border pixels ---\n    potential_green_pixels = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 8: # Only Azure pixels can become Green\n                is_border = False\n                # Check 8 neighbors for Magenta\n                for nr, nc in _get_neighbors(r, c, rows, cols, connectivity=8):\n                    if input_np[nr, nc] == 6: # Magenta\n                        is_border = True\n                        break\n                if is_border:\n                    potential_green_pixels.add((r, c))\n\n    # --- Step 4: Construct the final output grid ---\n    # Apply Yellow fill first\n    for r, c in yellow_pixels:\n        output_grid[r, c] = 4 # Yellow\n\n    # Apply Green border, only if the pixel wasn't turned Yellow\n    for r, c in potential_green_pixels:\n        if output_grid[r, c] == 8: # Check if it's still Azure\n            output_grid[r, c] = 3 # Green\n\n    # Magenta pixels remain unchanged (already copied from input_np)\n    # Azure pixels that weren't filled or bordered remain Azure\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7268,
    "candidates_token_count": 1751,
    "total_token_count": 9019,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.551038,
  "retries": null
}