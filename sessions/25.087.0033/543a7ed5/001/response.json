{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies Magenta (6) shapes on an Azure (8) background.\nAdds a Green (3) border (including diagonals) around each Magenta shape, replacing Azure pixels.\nIdentifies Azure regions completely enclosed by Magenta shapes (and potentially the new Green border).\nFills enclosed Azure regions with Yellow (4) if the region contains more than one pixel.\nSingle-pixel enclosed Azure regions remain Azure.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the border and fill transformation to the input grid.\n\n    Args:\n        input_grid (np.array): The input grid as a 2D numpy array.\n\n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n    output_grid = input_grid.copy()\n\n    # --- Step 1: Add Green (3) border ---\n    border_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            # Only consider Azure pixels for potential bordering\n            if input_grid[r, c] == 8:\n                is_border = False\n                # Check 8 neighbors (orthogonal and diagonal)\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = r + dr, c + dc\n                        if _is_valid(nr, nc, rows, cols) and input_grid[nr, nc] == 6: # Magenta\n                            is_border = True\n                            break\n                    if is_border:\n                        break\n                if is_border:\n                    border_pixels.append((r, c))\n\n    # Apply the green border to the output grid\n    for r, c in border_pixels:\n        output_grid[r, c] = 3 # Green\n\n    # --- Step 2: Identify and fill enclosed holes ---\n\n    # Create a grid to track visited pixels during reachability analysis\n    visited_reachability = np.zeros_like(output_grid, dtype=bool)\n    q_reachability = deque()\n\n    # Start BFS from all boundary pixels that are Azure (8) or Green (3)\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not visited_reachability[r, c] and (output_grid[r, c] == 8 or output_grid[r, c] == 3):\n                q_reachability.append((r, c))\n                visited_reachability[r, c] = True\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if not visited_reachability[r, c] and (output_grid[r, c] == 8 or output_grid[r, c] == 3):\n                q_reachability.append((r, c))\n                visited_reachability[r, c] = True\n\n    # Perform BFS to find all Azure/Green pixels reachable from the boundary\n    while q_reachability:\n        r, c = q_reachability.popleft()\n        # Check orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if _is_valid(nr, nc, rows, cols) and \\\n               not visited_reachability[nr, nc] and \\\n               (output_grid[nr, nc] == 8 or output_grid[nr, nc] == 3): # Azure or Green\n                visited_reachability[nr, nc] = True\n                q_reachability.append((nr, nc))\n\n    # Create a grid to track visited pixels during hole identification\n    visited_holes = np.zeros_like(output_grid, dtype=bool)\n\n    # Iterate through the grid to find unvisited Azure pixels (potential holes)\n    for r in range(rows):\n        for c in range(cols):\n            # If it's an Azure pixel and wasn't reached from the boundary\n            if output_grid[r, c] == 8 and not visited_reachability[r, c] and not visited_holes[r, c]:\n                # Found the start of a potential hole\n                current_hole_pixels = []\n                q_hole = deque([(r, c)])\n                visited_holes[r, c] = True\n                is_enclosed = True # Assume enclosed until proven otherwise (redundant check, but safe)\n\n                # Perform BFS to find all connected Azure pixels in this hole\n                while q_hole:\n                    hr, hc = q_hole.popleft()\n                    current_hole_pixels.append((hr, hc))\n\n                    # Check orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nhr, nhc = hr + dr, hc + dc\n                        if _is_valid(nhr, nhc, rows, cols):\n                             # If neighbor is Azure and not visited for holes yet\n                            if output_grid[nhr, nhc] == 8 and not visited_holes[nhr, nhc]:\n                                visited_holes[nhr, nhc] = True\n                                q_hole.append((nhr, nhc))\n                            # Double-check if it touches a reachable area (shouldn't happen based on reachability BFS)\n                            # elif visited_reachability[nhr, nhc] and (output_grid[nhr, nhc] == 8 or output_grid[nhr, nhc] == 3):\n                            #     is_enclosed = False\n\n                # After finding the whole component, check its size\n                # We already know it's enclosed because it wasn't reached by the first BFS\n                if len(current_hole_pixels) > 1:\n                    # Fill the hole with Yellow (4)\n                    for hr, hc in current_hole_pixels:\n                        output_grid[hr, hc] = 4\n\n    return output_grid.tolist() # Return as list of lists per standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3807,
    "candidates_token_count": 1480,
    "total_token_count": 5287,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.975948,
  "retries": null
}