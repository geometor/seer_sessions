{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict\n\n\"\"\"\nIdentifies 2x2 gray squares and other colored pixels (non-white, non-gray) in the input grid.\nPixels adjacent (including diagonally) to any part of a gray square are removed (set to white).\nNon-adjacent colored pixels are moved.\nThe movement rule is:\n1. Find the \"closest\" 2x2 gray square to the colored pixel.\n   - \"Closest\" is defined by the minimum Manhattan distance from the pixel's coordinates to any of the four cells forming the gray square.\n   - Ties in distance are broken by choosing the gray square whose top-left corner has the highest row index, then the highest column index.\n2. Find the target destination cell:\n   - Identify all empty (white) cells adjacent (including diagonally) to the chosen gray square.\n   - Calculate the Manhattan distance from the original colored pixel's position to each of these empty adjacent cells.\n   - The destination cell is the one with the minimum Manhattan distance.\n   - Ties are broken by choosing the cell with the lowest row index, then the lowest column index.\n3. The colored pixel is moved from its original location to the determined destination cell. The original location becomes white.\nThe output grid reflects these removals and movements. Gray squares remain unchanged.\n\"\"\"\n\ndef find_gray_squares(grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Finds the top-left coordinates of all 2x2 gray (5) squares.\"\"\"\n    gray_squares = []\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            if (grid[r, c] == 5 and\n                grid[r + 1, c] == 5 and\n                grid[r, c + 1] == 5 and\n                grid[r + 1, c + 1] == 5):\n                gray_squares.append((r, c))\n    return gray_squares\n\ndef find_colored_pixels(grid: np.ndarray) -> List[Tuple[Tuple[int, int], int]]:\n    \"\"\"Finds all non-white (0) and non-gray (5) pixels.\"\"\"\n    colored_pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0 and color != 5:\n                colored_pixels.append(((r, c), color))\n    return colored_pixels\n\ndef get_gray_square_cells(square_tl: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"Returns the four cell coordinates of a gray square given its top-left.\"\"\"\n    r, c = square_tl\n    return [(r, c), (r + 1, c), (r, c + 1), (r + 1, c + 1)]\n\ndef is_adjacent_to_gray(r: int, c: int, gray_squares: List[Tuple[int, int]]) -> bool:\n    \"\"\"Checks if a pixel at (r, c) is adjacent (incl. diagonally) to any gray square cell.\"\"\"\n    for sq_tl in gray_squares:\n        sq_cells = get_gray_square_cells(sq_tl)\n        for sq_r, sq_c in sq_cells:\n            if abs(r - sq_r) <= 1 and abs(c - sq_c) <= 1:\n                # Check it's not the cell itself, but an adjacent one\n                if not (r == sq_r and c == sq_c): \n                     # Now check if the adjacent cell is actually part of *any* gray square\n                     for check_sq_tl in gray_squares:\n                         check_sq_cells = get_gray_square_cells(check_sq_tl)\n                         if (sq_r, sq_c) in check_sq_cells:\n                              return True\n    return False\n    \ndef manhattan_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_closest_gray_square(r: int, c: int, gray_squares: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"Finds the closest gray square based on min distance and tie-breaking rules.\"\"\"\n    min_dist = float('inf')\n    closest_squares = []\n\n    for sq_tl in gray_squares:\n        sq_cells = get_gray_square_cells(sq_tl)\n        current_min_dist_to_square = float('inf')\n        for sq_r, sq_c in sq_cells:\n            dist = manhattan_distance((r, c), (sq_r, sq_c))\n            current_min_dist_to_square = min(current_min_dist_to_square, dist)\n        \n        if current_min_dist_to_square < min_dist:\n            min_dist = current_min_dist_to_square\n            closest_squares = [sq_tl]\n        elif current_min_dist_to_square == min_dist:\n            closest_squares.append(sq_tl)\n\n    # Tie-breaking: highest row, then highest column for top-left corner\n    closest_squares.sort(key=lambda sq: (-sq[0], -sq[1]))\n    return closest_squares[0]\n\ndef find_destination_cell(r: int, c: int, chosen_square_tl: Tuple[int, int], grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"Finds the best destination cell adjacent to the chosen gray square.\"\"\"\n    height, width = grid.shape\n    sq_cells = get_gray_square_cells(chosen_square_tl)\n    potential_destinations = []\n\n    # Find all adjacent cells (including diagonals) to the gray square\n    adjacent_cells = set()\n    for sq_r, sq_c in sq_cells:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = sq_r + dr, sq_c + dc\n                # Check bounds and ensure it's not part of the square itself\n                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in sq_cells:\n                    adjacent_cells.add((nr, nc))\n\n    # Filter for empty (white) cells and calculate distances\n    min_dist = float('inf')\n    valid_destinations = []\n    for dest_r, dest_c in adjacent_cells:\n        if grid[dest_r, dest_c] == 0: # Check if the cell is initially empty\n            dist = manhattan_distance((r, c), (dest_r, dest_c))\n            if dist < min_dist:\n                min_dist = dist\n                valid_destinations = [(dest_r, dest_c)]\n            elif dist == min_dist:\n                valid_destinations.append((dest_r, dest_c))\n\n    # Tie-breaking: lowest row, then lowest column\n    valid_destinations.sort(key=lambda pos: (pos[0], pos[1]))\n    \n    # It's possible no valid empty adjacent cell exists, though not seen in examples\n    if not valid_destinations:\n        # This case shouldn't happen based on examples, but handle defensively\n        # Maybe return original position or raise error? Let's return original for now.\n         print(f\"Warning: No valid destination found for pixel at ({r},{c}) near square {chosen_square_tl}. Keeping original position.\")\n         return (r, c) \n         \n    return valid_destinations[0]\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid according to the rules:\n    - Removes colored pixels adjacent to gray squares.\n    - Moves non-adjacent colored pixels closer to their nearest gray square.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find static elements\n    gray_squares = find_gray_squares(input_grid)\n    \n    # Find elements to process\n    colored_pixels = find_colored_pixels(input_grid)\n\n    # Store moves to apply later to avoid conflicts during iteration\n    moves = {} # original_pos -> new_pos\n    removals = [] # original_pos\n\n    for (r, c), color in colored_pixels:\n        # Check adjacency to any gray square\n        is_adj = False\n        for sq_tl in gray_squares:\n             sq_cells = get_gray_square_cells(sq_tl)\n             for sq_r, sq_c in sq_cells:\n                 # Check 8 neighbours of the pixel (r,c)\n                 for dr in [-1, 0, 1]:\n                     for dc in [-1, 0, 1]:\n                         if dr == 0 and dc == 0:\n                             continue\n                         nr, nc = r + dr, c + dc\n                         if (nr, nc) == (sq_r, sq_c): # Is neighbour a gray cell?\n                             is_adj = True\n                             break\n                     if is_adj: break\n             if is_adj: break\n        \n        if is_adj:\n            # Mark for removal (set to white)\n            removals.append((r, c))\n        else:\n            # Pixel needs to be moved\n            if not gray_squares: # Handle case with no gray squares\n                 print(f\"Warning: No gray squares found. Pixel at ({r},{c}) cannot be moved.\")\n                 continue # Pixel stays in place\n\n            # 1. Find the closest gray square\n            chosen_square_tl = find_closest_gray_square(r, c, gray_squares)\n\n            # 2. Find the destination cell using the *original* grid state for emptiness check\n            dest_r, dest_c = find_destination_cell(r, c, chosen_square_tl, input_grid)\n\n            # Mark for movement\n            if (r, c) != (dest_r, dest_c): # Only record if it actually moves\n                moves[(r, c)] = (dest_r, dest_c, color)\n\n\n    # Apply removals first\n    for r, c in removals:\n        output_grid[r, c] = 0\n\n    # Apply moves - need to handle potential overwrites if multiple pixels target same destination\n    # Since tie-breaking for destination exists, this implies a unique target per source pixel.\n    # Let's clear original positions first, then place new ones.\n    \n    # Intermediate grid to handle potential move conflicts (A->B, C->A)\n    temp_grid = np.copy(output_grid) \n    \n    # Clear original positions of moved pixels\n    for (r, c) in moves.keys():\n         temp_grid[r,c] = 0 # Make original spot empty in temp grid\n         \n    # Place pixels in new positions\n    final_output_grid = np.copy(temp_grid) # Start with cleared spots\n    \n    # Check for conflicts before placing\n    target_cells = {} # dest_pos -> list of source_pos\n    for source_pos, (dest_r, dest_c, color) in moves.items():\n        dest_pos = (dest_r, dest_c)\n        if dest_pos not in target_cells:\n            target_cells[dest_pos] = []\n        target_cells[dest_pos].append(source_pos)\n\n    # Apply moves, handling conflicts (though examples don't show any)\n    # If conflict, problem is underspecified. Let's assume no conflicts based on examples.\n    for source_pos, (dest_r, dest_c, color) in moves.items():\n        if len(target_cells.get((dest_r, dest_c), [])) > 1:\n             print(f\"Warning: Conflict detected! Multiple pixels moving to ({dest_r},{dest_c}). Sources: {target_cells[(dest_r, dest_c)]}. Behavior undefined.\")\n             # Apply one arbitrarily for now, maybe the one processed last in original loop?\n             # Or maybe the one with lower original row/col? Let's stick to last-write wins for now.\n        final_output_grid[dest_r, dest_c] = color\n\n\n    return final_output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3717,
    "candidates_token_count": 2942,
    "total_token_count": 6659,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.351876,
  "retries": null
}