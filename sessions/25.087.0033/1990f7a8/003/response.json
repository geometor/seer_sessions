{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid containing scattered red pixel patterns into a fixed 7x7 output grid by grouping fragments based on input grid quadrants.\n\nThe transformation involves:\n1. Identifying all distinct 4-connected components (fragments) of red (2) pixels in the input grid.\n2. Calculating the center of the input grid.\n3. Assigning each identified red fragment to one of four input grid quadrants (Top-Left, Top-Right, Bottom-Left, Bottom-Right) based on the location of the fragment's bounding box center relative to the input grid center.\n4. For each quadrant, determining the overall top-left corner (minimum row, minimum column) across all fragments assigned to that quadrant. This defines a reference point for the group.\n5. Creating a 7x7 output grid initialized with white (0).\n6. For each quadrant group:\n    a. Iterating through all pixels of all fragments belonging to that group.\n    b. Calculating each pixel's position relative to the group's overall top-left corner found in step 4.\n    c. If the relative position falls within a 3x3 area (0<=row<3, 0<=col<3), placing a red pixel at the corresponding position within the target 3x3 quadrant in the output grid (TL -> rows 0-2, cols 0-2; TR -> rows 0-2, cols 4-6; BL -> rows 4-6, cols 0-2; BR -> rows 4-6, cols 4-6).\n7. The central row (3) and column (3) of the output remain white.\n\"\"\"\n\ndef _find_objects(grid, color):\n    \"\"\"Finds all connected components (fragments) of a given color in the grid using 4-connectivity.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the fragment's pixels and its bounding box\n                objects.append({\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef _get_bbox_center(obj_bbox):\n    \"\"\"Calculates the center coordinates of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = obj_bbox\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n    return center_r, center_c\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid according to the described rules.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    input_height, input_width = input_grid.shape\n    red_color = 2\n    background_color = 0\n    output_size = 7\n    quadrant_size = 3\n\n    # 1. Initialize the output grid\n    output_grid = np.full((output_size, output_size), background_color, dtype=int)\n\n    # Define the target quadrant top-left corners in the output grid\n    target_quadrants_output_origin = {\n        \"TL\": (0, 0),\n        \"TR\": (0, 4),\n        \"BL\": (4, 0),\n        \"BR\": (4, 4)\n    }\n\n    # 2. Identify all red fragments\n    fragments = _find_objects(input_grid, red_color)\n\n    # 3. Calculate input grid center\n    grid_center_r = (input_height - 1) / 2.0\n    grid_center_c = (input_width - 1) / 2.0\n\n    # 4. Create structure to hold fragments assigned to each quadrant\n    quadrant_fragments = {\"TL\": [], \"TR\": [], \"BL\": [], \"BR\": []}\n\n    # 5. Assign fragments to quadrants based on their bbox center\n    for frag in fragments:\n        frag_center_r, frag_center_c = _get_bbox_center(frag['bbox'])\n\n        if frag_center_r <= grid_center_r and frag_center_c <= grid_center_c:\n            quadrant_fragments[\"TL\"].append(frag)\n        elif frag_center_r <= grid_center_r and frag_center_c > grid_center_c:\n            quadrant_fragments[\"TR\"].append(frag)\n        elif frag_center_r > grid_center_r and frag_center_c <= grid_center_c:\n            quadrant_fragments[\"BL\"].append(frag)\n        else: # frag_center_r > grid_center_r and frag_center_c > grid_center_c\n            quadrant_fragments[\"BR\"].append(frag)\n\n    # 6. Process each quadrant group\n    for quadrant, frags_in_quadrant in quadrant_fragments.items():\n        if not frags_in_quadrant:\n            continue # Skip if no fragments were assigned to this quadrant\n\n        # 6.a. Find the overall top-left corner for this group of fragments\n        min_r_group = input_height  # Initialize with max possible value\n        min_c_group = input_width   # Initialize with max possible value\n        for frag in frags_in_quadrant:\n            min_r, min_c, _, _ = frag['bbox']\n            min_r_group = min(min_r_group, min_r)\n            min_c_group = min(min_c_group, min_c)\n\n        # Get the output grid starting position for this quadrant\n        out_r_start, out_c_start = target_quadrants_output_origin[quadrant]\n\n        # 6.b-c. Place pixels relative to group origin into the output quadrant\n        for frag in frags_in_quadrant:\n            for r, c in frag['pixels']:\n                # Calculate position relative to the group's origin\n                rel_r = r - min_r_group\n                rel_c = c - min_c_group\n\n                # Check if the relative position is within the 3x3 target area\n                if 0 <= rel_r < quadrant_size and 0 <= rel_c < quadrant_size:\n                    # Calculate absolute position in the output grid\n                    output_r = out_r_start + rel_r\n                    output_c = out_c_start + rel_c\n                    \n                    # Set the pixel color (ensure it's within output bounds, though logic should prevent issues)\n                    if 0 <= output_r < output_size and 0 <= output_c < output_size:\n                         output_grid[output_r, output_c] = red_color\n\n    # 7. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11509,
    "candidates_token_count": 1878,
    "total_token_count": 13387,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.151613,
  "retries": null
}