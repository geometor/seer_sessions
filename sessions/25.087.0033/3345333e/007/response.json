{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nThe transformation rule identifies two potential target objects for removal:\n1. 'unique_solid': An object that is the only one of its color AND is a solid rectangle.\n2. 'majority_largest': The largest object (by pixel area) belonging to the color group that has the most distinct objects. Ties in object count are broken by selecting the color with the largest total pixel area.\n\nThe default action is to remove 'unique_solid' if exactly one such object exists.\n\nHowever, this action is overridden, and 'majority_largest' is removed instead, IF ALL of the following conditions are met:\n- Both 'unique_solid' and 'majority_largest' exist.\n- 'majority_largest' is NOT a solid rectangle.\n- The area of 'majority_largest' is greater than the area of 'unique_solid'.\n- The difference in area between 'majority_largest' and 'unique_solid' is greater than 10 pixels.\n\nIf 'unique_solid' does not exist, but 'majority_largest' does, then 'majority_largest' is removed.\n\nIf neither 'unique_solid' nor 'majority_largest' can be definitively identified according to these rules, the grid remains unchanged. Removal consists of changing the object's pixels to the background color (white, 0).\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              {'color': int, 'coords': set((r, c)), 'size': int, 'bbox': dict}.\n              bbox is {'min_r', 'max_r', 'min_c', 'max_c'}. Returns empty list if no objects.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # If pixel is non-background (not 0) and not visited yet\n            if color != 0 and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_color = color \n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # Breadth-First Search (BFS) to find connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == obj_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    bbox = {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c}\n                    objects.append({\n                        'color': int(obj_color), \n                        'coords': obj_coords, \n                        'size': len(obj_coords), \n                        'bbox': bbox\n                    }) \n                    \n    return objects\n\ndef is_solid_rectangle(obj):\n    \"\"\"\n    Checks if an object (represented by its dictionary) is a solid rectangle.\n\n    Args:\n        obj (dict): The object dictionary from find_objects.\n\n    Returns:\n        bool: True if the object is a solid rectangle, False otherwise.\n    \"\"\"\n    coords = obj['coords']\n    if not coords:\n        return False\n        \n    bbox = obj['bbox']\n    height = bbox['max_r'] - bbox['min_r'] + 1\n    width = bbox['max_c'] - bbox['min_c'] + 1\n    \n    # Check if the number of pixels in the object equals the area of its bounding box\n    return obj['size'] == height * width\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on 'unique_solid' and 'majority_largest' objects.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find all objects\n    objects = find_objects(input_grid)\n    if not objects:\n        return output_grid # No objects, return original grid\n\n    # 2. Identify 'unique_solid'\n    color_counts = Counter(obj['color'] for obj in objects)\n    num_objects_by_color = {int(k): int(v) for k, v in color_counts.items()}\n    \n    unique_solid_object = None\n    unique_solid_found = False\n    for obj in objects:\n        obj['is_solid'] = is_solid_rectangle(obj) # Cache solidity check\n        if num_objects_by_color[obj['color']] == 1 and obj['is_solid']:\n            if unique_solid_found: # Found more than one\n                unique_solid_object = None\n                break \n            else:\n                 unique_solid_object = obj\n                 unique_solid_found = True\n    # Ensure unique_solid_object is None if multiple were found\n    if unique_solid_object is not None and not unique_solid_found:\n         unique_solid_object = None\n\n\n    # 3. Identify 'majority_largest'\n    majority_color = -1\n    majority_largest_object = None\n    \n    if num_objects_by_color:\n        max_count = 0\n        # Check if there are any colors with multiple objects\n        if any(v > 1 for v in num_objects_by_color.values()):\n             max_count = max(num_objects_by_color.values())\n        elif num_objects_by_color: # If no color has >1 object, consider max count as 1\n            max_count = 1 \n            \n        if max_count > 0: # Proceed only if there are objects\n            majority_colors = [color for color, count in num_objects_by_color.items() if count == max_count]\n            \n            if len(majority_colors) == 1:\n                majority_color = majority_colors[0]\n            elif len(majority_colors) > 1: # Tie-break by total area\n                max_total_area = -1\n                chosen_color = -1\n                for color in majority_colors:\n                    total_area = sum(obj['size'] for obj in objects if obj['color'] == color)\n                    if total_area > max_total_area:\n                        max_total_area = total_area\n                        chosen_color = color\n                majority_color = chosen_color\n\n            # Find the largest object of the majority color\n            if majority_color != -1:\n                largest_size = -1\n                for obj in objects:\n                    if obj['color'] == majority_color:\n                        # Solidity was already calculated and cached in step 2\n                        # obj['is_solid'] = is_solid_rectangle(obj) \n                        if obj['size'] > largest_size:\n                            largest_size = obj['size']\n                            majority_largest_object = obj\n\n    # 4. Apply Decision Logic\n    target_object_to_remove = None\n    \n    # Primary Rule\n    if unique_solid_object is not None:\n        target_object_to_remove = unique_solid_object\n        \n        # Override Check\n        if majority_largest_object is not None:\n            # Ensure solidity is checked for majority_largest if not already done\n            if 'is_solid' not in majority_largest_object:\n                 majority_largest_object['is_solid'] = is_solid_rectangle(majority_largest_object)\n\n            override_conditions_met = (\n                not majority_largest_object['is_solid'] and\n                majority_largest_object['size'] > unique_solid_object['size'] and\n                (majority_largest_object['size'] - unique_solid_object['size']) > 10\n            )\n            \n            if override_conditions_met:\n                target_object_to_remove = majority_largest_object # Override target\n\n    # Fallback: If no unique_solid, but majority_largest exists\n    elif majority_largest_object is not None:\n         target_object_to_remove = majority_largest_object\n\n    # 5. Execute Removal\n    if target_object_to_remove is not None:\n        for r, c in target_object_to_remove['coords']:\n             # Basic bounds check (should be redundant)\n            if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n                 output_grid[r, c] = 0 # Set to background color\n\n    # 6. Return the resulting grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18023,
    "candidates_token_count": 2240,
    "total_token_count": 20263,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.632513,
  "retries": null
}