{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, Counter\n\n\"\"\"\nNatural Language Program:\n\n1.  **Identify Objects:** Find all connected components (objects) of non-white pixels in the input grid using 8-neighbor connectivity (including diagonals). For each object, record its color, coordinates, and bounding box.\n2.  **Determine Template Shape:** Calculate a shape signature (relative coordinates from the top-left corner) for each object. Group objects by their shape signature. Identify the most frequently occurring shape signature as the `Template Signature`. Record the height (`H`) and width (`W`) of this template shape. Store the objects matching this signature as `Template Objects`.\n3.  **Identify Palette Objects & Colors:**\n    a. Identify objects whose shape signature does *not* match the `Template Signature`. These are the `Palette Objects`.\n    b. If `Palette Objects` exist:\n        i. Find the minimum bounding box enclosing *all* pixels of *all* `Palette Objects`.\n        ii. Determine the orientation of the palette based on this bounding box: Horizontal if width > height, Vertical if height > width. Handle ties or single-pixel palettes (assume Horizontal if ambiguous or dimensions are equal).\n        iii. Extract `Palette Colors` based on orientation:\n            - **Horizontal:** Scan columns from left to right within the palette bounding box. For each column, find the top-most pixel belonging to any `Palette Object`. Add its color to the `Palette Colors` list, ensuring uniqueness and preserving the left-to-right order.\n            - **Vertical:** Scan rows from top to bottom within the palette bounding box. For each row, find the left-most pixel belonging to any `Palette Object`. Add its color to the `Palette Colors` list, ensuring uniqueness and preserving the top-to-bottom order.\n    c. If no `Palette Objects` exist:\n        i. Use the `Template Objects` themselves as the source for the palette.\n        ii. Sort the `Template Objects` by their top-most row coordinate (`bbox[0]`).\n        iii. The `Palette Colors` list consists of the colors of these sorted `Template Objects`, preserving order and uniqueness.\n4.  **Identify Anchor Template:** Among the `Template Objects`, find the one with the minimum starting row (top-most). Record its starting row (`min_orig_row`), starting column (`colS` - the left-most column of its bbox), and color (`anchor_color`).\n5.  **Find Anchor Index:** Determine the 0-based index (`k`) of `anchor_color` within the ordered `Palette Colors` list. If the anchor color is not found (which shouldn't happen with correct logic, but as a fallback), use `k=0`.\n6.  **Calculate Output Stack Start Row:** Compute the starting row (`R_start`) for the stacked output shapes using the formula: `R_start = min_orig_row - (k * H)`.\n7.  **Generate Output Grid:** Create a new grid of the same dimensions as the input, initialized with the background color (white, 0). Iterate through the `Palette Colors` list. For each color `ci` at index `i`:\n    a. Calculate the top row for placing this instance of the template: `current_row = R_start + (i * H)`.\n    b. Using the `Template Signature` (relative coordinates `dr, dc`), draw the template shape onto the output grid at position (`current_row`, `colS`) using color `ci`. Specifically, for each `(dr, dc)` in the signature, set the pixel at `(current_row + dr, colS + dc)` to `ci`, ensuring it's within grid bounds.\n8.  Return the generated output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict, Counter\n\ndef find_connected_components_8_neighbor(grid):\n    \"\"\"Finds all connected components of non-background pixels using 8-neighbor connectivity.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    component_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                objects.append({\n                    \"coords\": frozenset(component_coords), # Use frozenset for hashability\n                    \"color\": color,\n                    \"bbox\": (min_r, min_c, max_r, max_c), # top, left, bottom, right\n                })\n    return objects\n\ndef get_shape_signature(obj):\n    \"\"\"Calculates a shape signature (sorted relative coordinates) and dimensions.\"\"\"\n    min_r, min_c, _, _ = obj['bbox']\n    relative_coords = tuple(sorted([(r - min_r, c - min_c) for r, c in obj['coords']]))\n    # Calculate height and width based on relative coordinates max values\n    height = 0\n    width = 0\n    if relative_coords:\n        height = max(rc[0] for rc in relative_coords) + 1\n        width = max(rc[1] for rc in relative_coords) + 1\n    return relative_coords, height, width\n\n\ndef transform(input_grid):\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 1. Identify Objects (8-neighbor connectivity)\n    all_objects = find_connected_components_8_neighbor(input_np)\n    if not all_objects:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # 2. Determine Template Shape\n    shape_signatures = defaultdict(list)\n    obj_details = {}\n    for i, obj in enumerate(all_objects):\n        signature, h, w = get_shape_signature(obj)\n        shape_signatures[signature].append(i)\n        obj_details[i] = {'signature': signature, 'height': h, 'width': w, 'obj': obj}\n\n    if not shape_signatures:\n         return output_grid.tolist() # Should not happen if all_objects is not empty\n\n    # Find the most frequent signature\n    template_signature = max(shape_signatures, key=lambda k: len(shape_signatures[k]))\n    template_indices = shape_signatures[template_signature]\n    template_height = obj_details[template_indices[0]]['height']\n    template_width = obj_details[template_indices[0]]['width']\n\n    template_objects = [all_objects[i] for i in template_indices]\n    palette_object_indices = list(set(range(len(all_objects))) - set(template_indices))\n    palette_objects = [all_objects[i] for i in palette_object_indices]\n\n    # 3. Identify Palette Objects & Colors\n    palette_colors = []\n    if palette_objects:\n        # Collect all pixels from palette objects\n        all_palette_pixels = set()\n        min_pr, min_pc = rows, cols\n        max_pr, max_pc = -1, -1\n        for obj in palette_objects:\n            all_palette_pixels.update(obj['coords'])\n            min_r, min_c, max_r, max_c = obj['bbox']\n            min_pr = min(min_pr, min_r)\n            min_pc = min(min_pc, min_c)\n            max_pr = max(max_pr, max_r)\n            max_pc = max(max_pc, max_c)\n\n        # Create a lookup for palette pixel coordinates to color\n        palette_pixel_map = {coord: input_np[coord] for coord in all_palette_pixels}\n\n        # Determine orientation\n        palette_bbox_height = max_pr - min_pr + 1\n        palette_bbox_width = max_pc - min_pc + 1\n        is_horizontal = palette_bbox_width >= palette_bbox_height # Default to horizontal if square or ambiguous\n\n        seen_colors = set()\n        if is_horizontal:\n            # Scan columns L->R\n            for c in range(min_pc, max_pc + 1):\n                col_pixels = []\n                for r in range(min_pr, max_pr + 1):\n                    if (r, c) in palette_pixel_map:\n                        col_pixels.append((r, palette_pixel_map[(r, c)]))\n                if col_pixels:\n                    col_pixels.sort() # Sort by row (top-most)\n                    top_color = col_pixels[0][1]\n                    if top_color not in seen_colors:\n                        palette_colors.append(top_color)\n                        seen_colors.add(top_color)\n        else:\n            # Scan rows T->B\n            for r in range(min_pr, max_pr + 1):\n                row_pixels = []\n                for c in range(min_pc, max_pc + 1):\n                    if (r, c) in palette_pixel_map:\n                        row_pixels.append((c, palette_pixel_map[(r, c)]))\n                if row_pixels:\n                    row_pixels.sort() # Sort by col (left-most)\n                    left_color = row_pixels[0][1]\n                    if left_color not in seen_colors:\n                        palette_colors.append(left_color)\n                        seen_colors.add(left_color)\n\n    # Fallback: No separate palette objects found\n    if not palette_colors:\n        # Use colors of template objects, sorted by row\n        template_objects.sort(key=lambda obj: obj['bbox'][0])\n        seen_colors = set()\n        for obj in template_objects:\n            if obj['color'] not in seen_colors:\n                 palette_colors.append(obj['color'])\n                 seen_colors.add(obj['color'])\n\n    # Check if palette or template identification failed\n    if not palette_colors or not template_objects:\n        # Cannot proceed meaningfully\n        # print(\"Warning: Could not determine palette or template shapes.\")\n        return output_grid.tolist()\n\n    # 4. Identify Anchor Template\n    template_objects.sort(key=lambda obj: obj['bbox'][0]) # Sort by top row\n    anchor_template = template_objects[0]\n    min_orig_row, colS, _, _ = anchor_template['bbox']\n    anchor_color = anchor_template['color']\n\n    # 5. Find Anchor Index\n    try:\n        k = palette_colors.index(anchor_color)\n    except ValueError:\n        # Fallback if anchor color isn't in the derived palette\n        # print(f\"Warning: Anchor color {anchor_color} not found in derived palette {palette_colors}. Using index 0.\")\n        k = 0 # Use index 0 as a fallback\n\n    # 6. Calculate Output Stack Start Row\n    R_start = min_orig_row - (k * template_height)\n\n    # 7. Generate Output Grid\n    for i, ci in enumerate(palette_colors):\n        current_row = R_start + (i * template_height)\n        # Draw the template shape using its signature\n        for dr, dc in template_signature:\n            r_draw, c_draw = current_row + dr, colS + dc\n            # Ensure drawing is within grid bounds\n            if 0 <= r_draw < rows and 0 <= c_draw < cols:\n                output_grid[r_draw, c_draw] = ci\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 9145,
            "end_index": 9480,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11858,
    "candidates_token_count": 2942,
    "total_token_count": 14800,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.966083,
  "retries": null
}