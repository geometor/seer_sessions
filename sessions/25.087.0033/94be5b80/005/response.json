{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, Counter\n\n\"\"\"\nIdentify a template shape and a color palette from the input grid. \nGenerate an output grid by replicating the template shape vertically, forming a stack. \nThe colors of the stacked shapes and their order are determined by the sequence of colors in the palette. \nThe stack's position is anchored relative to the topmost instance of the template shape found in the input.\n\nNatural Language Program:\n\n1.  **Identify Objects:** Find all connected components (objects) of non-white pixels using 8-neighbor connectivity. Record each object's color, coordinates, bounding box, and pixel count.\n2.  **Group Objects by Shape:** Calculate a canonical shape signature (e.g., sorted relative coordinates from the top-left of the bounding box) for each object. Group objects sharing the same signature.\n3.  **Distinguish Palette and Template Candidates:**\n    a.  Find all objects and group them by shape signature. Record the pixel count for each shape signature.\n    b.  Identify the shape signature associated with the largest individual object pixel count. Assume this signature belongs to the `Template Objects`.\n    c.  Designate all objects *not* matching the `Template Signature` as `Palette Components`.\n    d.  If no `Palette Components` are found (e.g., all objects have the same shape), use the `Template Objects` themselves as the source for the palette (fallback mechanism).\n4.  **Extract Palette Colors:**\n    a.  If `Palette Components` exist:\n        i.   Collect all pixel coordinates belonging to any `Palette Component`.\n        ii.  Determine the bounding box of these collected palette pixels.\n        iii. Determine the primary orientation (Horizontal if width >= height, Vertical otherwise).\n        iv.  Scan the palette pixels along the primary axis (left-to-right if Horizontal, top-to-bottom if Vertical). For each step along the axis, find the first palette pixel encountered (top-most for horizontal, left-most for vertical) and add its color (from the input grid) to the `Palette Colors` list, ensuring uniqueness while preserving order.\n    b.  If using the fallback mechanism (no distinct `Palette Components`):\n        i.   Sort the `Template Objects` by their top-most row coordinate (`bbox[0]`).\n        ii.  The `Palette Colors` list consists of the unique colors of these sorted `Template Objects`, preserving their order.\n5.  **Identify Anchor Template:** Among the confirmed `Template Objects`, find the one with the minimum starting row (top-most). Record its starting row (`min_orig_row`), starting column (`colS` - the left-most column of its bbox), and color (`anchor_color`).\n6.  **Find Anchor Index:** Find the 0-based index (`k`) of `anchor_color` in the ordered `Palette Colors` list. If not found, default to `k=0`.\n7.  **Calculate Output Stack Start Row:** Compute `R_start = min_orig_row - (k * H)`, where `H` is the height of the `Template Signature`.\n8.  **Generate Output Grid:** Create a new grid of the same dimensions as the input, initialized with the background color (white, 0). Iterate through the `Palette Colors` list (index `i`, color `ci`):\n    a.  Calculate the draw row: `current_row = R_start + (i * H)`.\n    b.  Using the `Template Signature`, draw the template shape at (`current_row`, `colS`) using color `ci`. For each relative coordinate `(dr, dc)` in the signature, set the output grid pixel at `(current_row + dr, colS + dc)` to `ci`, checking grid bounds.\n9.  Return the generated output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict, Counter\n\ndef find_connected_components_8_neighbor(grid):\n    \"\"\"Finds all connected components of non-background pixels using 8-neighbor connectivity.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    component_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                objects.append({\n                    \"coords\": frozenset(component_coords), # Use frozenset for hashability\n                    \"color\": color,\n                    \"bbox\": (min_r, min_c, max_r, max_c), # top, left, bottom, right\n                    \"pixel_count\": len(component_coords),\n                })\n    return objects\n\ndef get_shape_signature(obj):\n    \"\"\"Calculates a shape signature (sorted relative coordinates) and dimensions.\"\"\"\n    min_r, min_c, _, _ = obj['bbox']\n    relative_coords = tuple(sorted([(r - min_r, c - min_c) for r, c in obj['coords']]))\n    # Calculate height and width based on relative coordinates max values\n    height = 0\n    width = 0\n    if relative_coords:\n        height = max(rc[0] for rc in relative_coords) + 1\n        width = max(rc[1] for rc in relative_coords) + 1\n    return relative_coords, height, width\n\n\ndef transform(input_grid):\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 1. Identify Objects\n    all_objects = find_connected_components_8_neighbor(input_np)\n    if not all_objects:\n        return output_grid.tolist()\n\n    # 2. Group Objects by Shape and calculate properties\n    shape_groups = defaultdict(lambda: {\"indices\": [], \"pixel_count\": 0})\n    obj_details = [] # Store details for each object\n    max_pixel_count = 0\n    signature_with_max_pixels = None\n\n    for i, obj in enumerate(all_objects):\n        signature, h, w = get_shape_signature(obj)\n        shape_groups[signature][\"indices\"].append(i)\n        shape_groups[signature][\"pixel_count\"] = obj[\"pixel_count\"] # Store pixel count per object of this shape\n        shape_groups[signature][\"height\"] = h\n        shape_groups[signature][\"width\"] = w\n        obj_details.append({'signature': signature, 'height': h, 'width': w, 'obj': obj, 'id': i})\n\n        # Track the signature corresponding to the largest object found so far\n        if obj[\"pixel_count\"] > max_pixel_count:\n            max_pixel_count = obj[\"pixel_count\"]\n            signature_with_max_pixels = signature\n\n    # 3. Distinguish Palette and Template Candidates\n    template_signature = None\n    template_objects = []\n    palette_components = []\n\n    if signature_with_max_pixels is not None:\n        # Assume the signature of the largest object is the template signature\n        template_signature = signature_with_max_pixels\n        template_height = shape_groups[template_signature][\"height\"]\n        template_width = shape_groups[template_signature][\"width\"]\n\n        for detail in obj_details:\n            if detail['signature'] == template_signature:\n                template_objects.append(detail['obj'])\n            else:\n                palette_components.append(detail['obj'])\n    else:\n        # Fallback if no objects were found or something went wrong\n        return output_grid.tolist()\n\n    # 4. Extract Palette Colors\n    palette_colors = []\n    seen_colors = set()\n\n    if palette_components:\n        # Collect all pixels from palette components\n        all_palette_pixels = set()\n        min_pr, min_pc = rows, cols\n        max_pr, max_pc = -1, -1\n        for obj in palette_components:\n            all_palette_pixels.update(obj['coords'])\n            min_r, min_c, max_r, max_c = obj['bbox']\n            min_pr = min(min_pr, min_r)\n            min_pc = min(min_pc, min_c)\n            max_pr = max(max_pr, max_r)\n            max_pc = max(max_pc, max_c)\n\n        if not all_palette_pixels: # Should not happen if palette_components is not empty, but check anyway\n             pass # Fallback to using templates below\n        else:\n            # Create a lookup for palette pixel coordinates to color\n            palette_pixel_map = {coord: input_np[coord] for coord in all_palette_pixels}\n\n            # Determine orientation\n            palette_bbox_height = max_pr - min_pr + 1\n            palette_bbox_width = max_pc - min_pc + 1\n            is_horizontal = palette_bbox_width >= palette_bbox_height # Default to horizontal if square\n\n            if is_horizontal:\n                # Scan columns L->R\n                for c in range(min_pc, max_pc + 1):\n                    col_pixels = []\n                    for r in range(min_pr, max_pr + 1):\n                        if (r, c) in palette_pixel_map:\n                            col_pixels.append((r, palette_pixel_map[(r, c)])) # Store (row, color)\n                    if col_pixels:\n                        col_pixels.sort() # Sort by row (find top-most)\n                        top_color = col_pixels[0][1]\n                        if top_color not in seen_colors:\n                            palette_colors.append(top_color)\n                            seen_colors.add(top_color)\n            else:\n                # Scan rows T->B\n                for r in range(min_pr, max_pr + 1):\n                    row_pixels = []\n                    for c in range(min_pc, max_pc + 1):\n                        if (r, c) in palette_pixel_map:\n                            row_pixels.append((c, palette_pixel_map[(r, c)])) # Store (col, color)\n                    if row_pixels:\n                        row_pixels.sort() # Sort by col (find left-most)\n                        left_color = row_pixels[0][1]\n                        if left_color not in seen_colors:\n                            palette_colors.append(left_color)\n                            seen_colors.add(left_color)\n\n    # Fallback: No separate palette components identified OR palette extraction failed\n    if not palette_colors:\n        if not template_objects: # No template either, something is wrong\n            return output_grid.tolist()\n        # Use colors of template objects, sorted by row\n        template_objects.sort(key=lambda obj: obj['bbox'][0])\n        seen_colors_fallback = set()\n        for obj in template_objects:\n            if obj['color'] not in seen_colors_fallback:\n                 palette_colors.append(obj['color'])\n                 seen_colors_fallback.add(obj['color'])\n\n    # Final check for critical components\n    if not palette_colors or not template_objects or template_signature is None:\n        # Cannot proceed meaningfully\n        # print(\"Warning: Could not determine palette, template shapes, or template signature.\")\n        return output_grid.tolist()\n\n    # 5. Identify Anchor Template\n    template_objects.sort(key=lambda obj: obj['bbox'][0]) # Sort by top row\n    anchor_template = template_objects[0]\n    min_orig_row, colS, _, _ = anchor_template['bbox']\n    anchor_color = anchor_template['color']\n\n    # 6. Find Anchor Index\n    try:\n        k = palette_colors.index(anchor_color)\n    except ValueError:\n        # Fallback if anchor color isn't in the derived palette\n        # print(f\"Warning: Anchor color {anchor_color} not found in derived palette {palette_colors}. Using index 0.\")\n        k = 0\n\n    # 7. Calculate Output Stack Start Row\n    # H is template_height\n    R_start = min_orig_row - (k * template_height)\n\n    # 8. Generate Output Grid\n    for i, ci in enumerate(palette_colors):\n        current_row = R_start + (i * template_height)\n        # Draw the template shape using its signature\n        for dr, dc in template_signature:\n            r_draw, c_draw = current_row + dr, colS + dc\n            # Ensure drawing is within grid bounds\n            if 0 <= r_draw < rows and 0 <= c_draw < cols:\n                output_grid[r_draw, c_draw] = ci\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 8308,
            "end_index": 8643,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12807,
    "candidates_token_count": 3214,
    "total_token_count": 16021,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.910749,
  "retries": null
}