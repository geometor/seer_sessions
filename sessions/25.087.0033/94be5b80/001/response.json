{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, Counter\n\n\"\"\"\nNatural Language Program:\n\n1.  **Identify Objects:** Find all connected components (objects) of non-white pixels in the input grid. For each object, record its color, coordinates, and bounding box.\n2.  **Determine Template Shape:** Calculate a shape signature (relative coordinates from the top-left corner) for each object. Group objects by their shape signature. Identify the most frequently occurring shape signature as the `Template Signature`. Record the height (`H`) of this template shape. Store the objects matching this signature as `Template Objects`.\n3.  **Identify Palette Colors:** Consider all pixels *not* belonging to the `Template Objects` as potential palette pixels. Find the bounding box enclosing all these potential palette pixels. Scan this bounding box column by column, from left to right. For each column, find the first non-white pixel within the bounding box's rows. Add its color to the `Palette Colors` list, ensuring uniqueness and preserving the left-to-right order.\n4.  **Identify Anchor Template:** Among the `Template Objects`, find the one with the minimum starting row (top-most). Record its starting row (`min_orig_row`), starting column (`colS`), and color (`anchor_color`). Note: Assume all template objects share the same starting column `colS`.\n5.  **Find Anchor Index:** Determine the 0-based index (`k`) of `anchor_color` within the ordered `Palette Colors` list.\n6.  **Calculate Output Stack Start Row:** Compute the starting row (`R_start`) for the stacked output shapes using the formula: `R_start = min_orig_row - (k * H)`.\n7.  **Generate Output Grid:** Create a new grid of the same dimensions as the input, initialized with the background color (white, 0). Iterate through the `Palette Colors` list. For each color `ci` at index `i`:\n    a.  Calculate the top row for placing this instance of the template: `current_row = R_start + (i * H)`.\n    b.  Using the `Template Signature` (relative coordinates `dr, dc`), draw the template shape onto the output grid at position (`current_row`, `colS`) using color `ci`. Specifically, for each `(dr, dc)` in the signature, set the pixel at `(current_row + dr, colS + dc)` to `ci`.\n8.  Return the generated output grid.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components of non-background pixels.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    component_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Check orthogonal neighbors only if diagonal fails\n                if not component_coords: # Should not happen with initial pixel\n                     continue\n                \n                q = [(r, c)]\n                visited_ortho = np.zeros_like(grid, dtype=bool)\n                visited_ortho[r,c] = True\n                component_coords_ortho = set()\n                min_r_ortho, max_r_ortho = r, r\n                min_c_ortho, max_c_ortho = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    component_coords_ortho.add((row, col))\n                    min_r_ortho = min(min_r_ortho, row)\n                    max_r_ortho = max(max_r_ortho, row)\n                    min_c_ortho = min(min_c_ortho, col)\n                    max_c_ortho = max(max_c_ortho, col)\n                    \n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = row + dr, col + dc\n                         if 0 <= nr < rows and 0 <= nc < cols and \\\n                            grid[nr, nc] == color and not visited_ortho[nr, nc]:\n                            visited_ortho[nr, nc] = True\n                            visited[nr,nc] = True # Mark as visited globally\n                            q.append((nr, nc))\n\n                objects.append({\n                    \"coords\": component_coords_ortho,\n                    \"color\": color,\n                    \"bbox\": (min_r_ortho, min_c_ortho, max_r_ortho, max_c_ortho) # top, left, bottom, right\n                })\n                # Mark all found coords as visited to avoid reprocessing\n                # for cr, cc in component_coords_ortho:\n                #     visited[cr, cc] = True\n\n\n    return objects\n\ndef get_shape_signature(obj):\n    \"\"\"Calculates a shape signature (sorted relative coordinates) and dimensions.\"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    relative_coords = tuple(sorted([(r - min_r, c - min_c) for r, c in obj['coords']]))\n    return relative_coords, height, width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying a palette and template shapes,\n    then stacking instances of the template shape colored according to the palette order.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 1. Identify Objects\n    all_objects = find_connected_components(input_np)\n    if not all_objects:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # 2. Determine Template Shape\n    shape_signatures = defaultdict(list)\n    obj_signatures = {}\n    for i, obj in enumerate(all_objects):\n        signature, h, w = get_shape_signature(obj)\n        shape_signatures[signature].append(i)\n        obj_signatures[i] = {'signature': signature, 'height': h, 'width': w}\n\n    if not shape_signatures:\n         return output_grid.tolist() # Should not happen if all_objects is not empty\n\n    # Find the most frequent signature\n    template_signature = max(shape_signatures, key=lambda k: len(shape_signatures[k]))\n    template_indices = shape_signatures[template_signature]\n    template_height = obj_signatures[template_indices[0]]['height'] # Get height from first template obj\n\n    template_objects = [all_objects[i] for i in template_indices]\n    palette_object_indices = set(range(len(all_objects))) - set(template_indices)\n\n    # 3. Identify Palette Colors\n    palette_pixels = []\n    if palette_object_indices:\n        min_pr, min_pc, max_pr, max_pc = rows, cols, -1, -1\n        for i in palette_object_indices:\n            obj = all_objects[i]\n            for r, c in obj['coords']:\n                palette_pixels.append({'coord': (r, c), 'color': obj['color']})\n                min_pr = min(min_pr, r)\n                min_pc = min(min_pc, c)\n                max_pr = max(max_pr, r)\n                max_pc = max(max_pc, c)\n\n        # Extract palette colors by scanning the bounding box L->R\n        palette_colors = []\n        if palette_pixels: # Check if palette exists\n             processed_cols = set()\n             sorted_palette_pixels = sorted(palette_pixels, key=lambda p: (p['coord'][1], p['coord'][0])) # sort by col, then row\n             \n             current_col_colors = []\n             last_col = -1\n             unique_col_colors = []\n\n             for p in sorted_palette_pixels:\n                 r,c = p['coord']\n                 color = p['color']\n                 if c != last_col:\n                     if current_col_colors:\n                          # Take the first color encountered in the previous column (lowest row)\n                          if unique_col_colors and unique_col_colors[-1] != current_col_colors[0]:\n                             unique_col_colors.append(current_col_colors[0])\n                          elif not unique_col_colors:\n                               unique_col_colors.append(current_col_colors[0])\n\n                     current_col_colors = []\n                     last_col = c\n                 \n                 if color not in current_col_colors:\n                     current_col_colors.append(color)\n\n             # Add colors from the last column processed\n             if current_col_colors:\n                  if unique_col_colors and unique_col_colors[-1] != current_col_colors[0]:\n                      unique_col_colors.append(current_col_colors[0])\n                  elif not unique_col_colors:\n                       unique_col_colors.append(current_col_colors[0])\n\n             palette_colors = unique_col_colors\n             \n        # Fallback if palette identification failed but templates exist\n        if not palette_colors and template_objects: \n             # Use colors of template objects as palette, sorted by row\n             template_objects.sort(key=lambda obj: obj['bbox'][0])\n             palette_colors = [obj['color'] for obj in template_objects]\n\n\n    else: # No separate palette objects found, assume template colors are the palette\n        template_objects.sort(key=lambda obj: obj['bbox'][0]) # sort by row\n        palette_colors = []\n        seen_colors = set()\n        for obj in template_objects:\n            if obj['color'] not in seen_colors:\n                 palette_colors.append(obj['color'])\n                 seen_colors.add(obj['color'])\n\n\n    if not palette_colors or not template_objects:\n        # If still no palette or templates, cannot proceed\n         print(\"Warning: Could not determine palette or template shapes.\")\n         return output_grid.tolist()\n\n\n    # 4. Identify Anchor Template\n    template_objects.sort(key=lambda obj: obj['bbox'][0]) # Sort by top row\n    anchor_template = template_objects[0]\n    min_orig_row, colS, _, _ = anchor_template['bbox']\n    anchor_color = anchor_template['color']\n\n    # Verify common starting column (optional but good check)\n    # for obj in template_objects:\n    #     if obj['bbox'][1] != colS:\n    #         print(f\"Warning: Template objects do not share the same start column. Expected {colS}, found {obj['bbox'][1]}\")\n            # Decide how to handle: maybe use the anchor's colS, or majority? Using anchor's colS.\n\n\n    # 5. Find Anchor Index\n    try:\n        k = palette_colors.index(anchor_color)\n    except ValueError:\n        # Anchor color not in derived palette? This indicates an issue.\n        # Maybe the palette logic needs refinement, or the anchor is wrong.\n        # As a fallback, perhaps just use index 0 or try matching based on position?\n        print(f\"Warning: Anchor color {anchor_color} not found in derived palette {palette_colors}. Using index 0.\")\n        k = 0 # Fallback\n\n    # 6. Calculate Output Stack Start Row\n    # Need template height H, which we got during signature calculation\n    R_start = min_orig_row - (k * template_height)\n\n    # 7. Generate Output Grid\n    for i, ci in enumerate(palette_colors):\n        current_row = R_start + (i * template_height)\n        # Draw the template shape\n        for dr, dc in template_signature:\n            r_draw, c_draw = current_row + dr, colS + dc\n            # Ensure drawing is within grid bounds\n            if 0 <= r_draw < rows and 0 <= c_draw < cols:\n                output_grid[r_draw, c_draw] = ci\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 9366,
            "end_index": 9701,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4255,
    "candidates_token_count": 3129,
    "total_token_count": 7384,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.941164,
  "retries": null
}