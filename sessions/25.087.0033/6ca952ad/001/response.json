{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the background color (most frequent color).\nFind all connected objects of non-background colors using 8-way connectivity.\nDetermine the size of each object.\nObjects with size greater than 3 are considered \"falling\" objects.\nObjects with size less than or equal to 3 are considered \"stationary\" objects.\nInitialize the output grid with the background color.\nPlace the stationary objects onto the output grid in their original positions.\nSort the falling objects based on their top-most row coordinate (minimum row index), ascending.\nFor each falling object, simulate its fall downwards:\n  Determine the maximum distance it can fall vertically until it hits the bottom boundary or another pixel already placed in the output grid (either a stationary object or a previously fallen object).\n  Place the object in the output grid at its final resting position.\nReturn the modified output grid.\n\"\"\"\n\ndef find_background(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all connected objects of non-background colors.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    # Directions for 8-way connectivity (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1), (1, 0), (1, 1)]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new object\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                \n                while q:\n                    row, col = q.popleft()\n                    color = grid[row, col]\n                    obj_pixels.append({'r': row, 'c': col, 'color': color})\n                    \n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] != background_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'pixels': obj_pixels,\n                    'size': len(obj_pixels),\n                    'min_r': min_r,\n                    'max_r': max_r\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity to objects larger than 3 pixels in size.\n    Smaller objects remain stationary.\n    \"\"\"\n    input_np = np.array(input_grid)\n    height, width = input_np.shape\n    \n    # 1. Find Background Color\n    background_color = find_background(input_np)\n    \n    # 2. Find Objects\n    objects = find_objects(input_np, background_color)\n    \n    # 3. Initialize Output Grid\n    output_grid = np.full_like(input_np, background_color)\n    \n    # 4. Identify Falling and Stationary Objects\n    falling_objects = []\n    stationary_objects = []\n    for obj in objects:\n        if obj['size'] > 3:\n            falling_objects.append(obj)\n        else:\n            stationary_objects.append(obj)\n            \n    # 5. Place Stationary Objects\n    for obj in stationary_objects:\n        for pixel in obj['pixels']:\n            output_grid[pixel['r'], pixel['c']] = pixel['color']\n            \n    # 6. Simulate Falling\n    # Sort falling objects by their top-most row (min_r)\n    falling_objects.sort(key=lambda obj: obj['min_r'])\n    \n    # Process each falling object\n    for obj in falling_objects:\n        obj_pixels = obj['pixels']\n        current_offset_r = 0\n        \n        # Determine how far the object can fall\n        while True:\n            next_offset_r = current_offset_r + 1\n            can_move = True\n            # Check collision for the next potential position\n            for pixel in obj_pixels:\n                target_r = pixel['r'] + next_offset_r\n                target_c = pixel['c']\n                \n                # Check bounds\n                if target_r >= height:\n                    can_move = False\n                    break\n                # Check collision with existing pixels in output_grid\n                if output_grid[target_r, target_c] != background_color:\n                    # Need to ensure it's not colliding with a part of itself\n                    # Check if the colliding pixel belongs to the current object *at its potential new position*\n                    is_self_collision = False\n                    for p_self in obj_pixels:\n                        if (p_self['r'] + next_offset_r == target_r and\n                            p_self['c'] == target_c):\n                           is_self_collision = True\n                           break\n                    if not is_self_collision:\n                       can_move = False\n                       break\n\n            if can_move:\n                current_offset_r = next_offset_r\n            else:\n                # Cannot move further, current_offset_r is the final offset\n                break\n                \n        # Place the object at its final position\n        for pixel in obj_pixels:\n            final_r = pixel['r'] + current_offset_r\n            final_c = pixel['c']\n            output_grid[final_r, final_c] = pixel['color']\n            \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3226,
    "candidates_token_count": 1461,
    "total_token_count": 4687,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 181.263355,
  "retries": null
}