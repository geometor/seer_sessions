
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 6 0 6 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 6 6 6 0 0 0
0 0 0 0 6 0 6 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 6 6 6 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 8 0 8 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0
0 0 0 8 0 8 0 0 0 0
0 0 0 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_6

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 8 0 8 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** Each task example consists of a 10x10 grid containing a single 3x3 hollow square object (like a frame or the number zero) made of a single non-white color (magenta, azure, or yellow in the examples) on a white background. The transformation involves moving this object within the grid. The object's shape and color remain unchanged. The direction and distance of the movement seem determined by the object's color and its initial position relative to the grid boundaries.

*   **YAML Facts:**
    
```yaml
    Grid:
      Size: 10x10 (consistent across examples)
      Background: white (0)
    Object:
      Shape: 3x3 hollow square
      Quantity: 1 per grid
      Color: Varies (magenta(6), azure(8), yellow(4)), but consistent within a single input/output pair.
      Integrity: Shape and color are preserved during transformation.
    Transformation:
      Type: Translation (movement)
      Direction_Rule: Determined by object color:
        - magenta(6): Up
        - azure(8): Right
        - yellow(4): Down
      Distance_Rule: Determined by the distance from the object's relevant edge to the corresponding grid boundary in the direction of movement:
        - If Up: Distance = top_row_index_of_object
        - If Right: Distance = (grid_width - 1) - rightmost_column_index_of_object
        - If Down: Distance = (grid_height - 1) - bottommost_row_index_of_object
        - If Left (hypothesized): Distance = leftmost_column_index_of_object
      Result: The object is moved to a new location, potentially touching a grid boundary. The original location becomes white.
    ```


*   **Natural Language Program:**
    1.  Identify the single non-white object within the input grid. Note its color and pixels.
    2.  Determine the bounding box (minimum and maximum row and column indices) of the object.
    3.  Determine the direction of movement based on the object's color:
        *   If the color is magenta (6), the direction is Up.
        *   If the color is azure (8), the direction is Right.
        *   If the color is yellow (4), the direction is Down.
        *   (Assume default behavior or specific rules for other colors if encountered).
    4.  Calculate the distance of movement based on the determined direction and the object's bounding box relative to the grid dimensions (assuming a 10x10 grid based on examples, but generalize using grid height/width):
        *   If moving Up, the distance is equal to the minimum row index of the object's bounding box.
        *   If moving Right, the distance is equal to `(grid_width - 1) - maximum_column_index_of_bounding_box`.
        *   If moving Down, the distance is equal to `(grid_height - 1) - maximum_row_index_of_bounding_box`.
        *   If moving Left (hypothetical), the distance would be equal to the minimum column index of the object's bounding box.
    5.  Create a new output grid of the same dimensions as the input grid, initialized with the background color (white, 0).
    6.  For each pixel belonging to the original object, calculate its new position by adding the calculated distance to the relevant coordinate (subtracting from the row index for Up, adding to the column index for Right, adding to the row index for Down, subtracting from the column index for Left).
    7.  Place the object's pixels (preserving their original color) at their calculated new positions in the output grid.
