
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 0 0 0 0 0 0 0
0 8 0 0 0 0 0 8 0 0 0 0 0 0 0
0 8 8 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 8 0 0 8 8 8 8 8
0 0 8 0 8 8 8 8 0 0 8 0 0 0 8
0 0 8 8 8 0 0 0 0 0 8 8 0 0 8
0 0 0 0 0 0 0 0 0 0 0 8 0 0 8
0 0 0 0 0 0 0 0 0 8 8 8 0 8 8
0 0 8 8 8 0 0 0 0 8 0 0 0 8 0
0 0 8 0 8 0 0 0 0 8 8 8 8 8 0
0 0 8 8 8 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 8 8 8 8 8 4 0 0 0 0 0 0 0
0 8 0 0 0 0 0 8 0 0 0 0 0 0 0
0 4 2 0 0 0 0 8 0 0 0 0 0 0 0
0 0 8 0 0 0 0 8 0 0 4 8 8 8 4
0 0 8 0 2 8 8 4 0 0 8 0 0 0 8
0 0 4 8 4 0 0 0 0 0 4 2 0 0 8
0 0 0 0 0 0 0 0 0 0 0 8 0 0 8
0 0 0 0 0 0 0 0 0 4 8 2 0 2 4
0 0 4 8 4 0 0 0 0 8 0 0 0 8 0
0 0 8 0 8 0 0 0 0 4 8 8 8 4 0
0 0 4 8 4 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 0 0 0 0 0
0 0 3 3 3 0 0 3 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 0 0
0 0 3 0 0 3 3 3 0 0 0 0 0
0 0 3 3 3 3 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 3 3 0 3 0
0 0 0 0 0 0 0 0 3 0 0 3 0
0 0 0 0 3 3 3 3 3 0 0 3 0
0 0 0 0 3 0 0 0 0 0 0 3 0
0 0 0 0 3 0 0 0 3 3 3 3 0
0 0 0 0 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 3 3 4 0 0 0 0 0
0 0 4 3 2 0 0 3 0 0 0 0 0
0 0 3 0 0 0 0 3 0 0 0 0 0
0 0 3 0 0 2 3 4 0 0 0 0 0
0 0 4 3 3 4 0 0 0 4 3 4 0
0 0 0 0 0 0 0 0 4 2 0 3 0
0 0 0 0 0 0 0 0 3 0 0 3 0
0 0 0 0 4 3 3 3 2 0 0 3 0
0 0 0 0 3 0 0 0 0 0 0 3 0
0 0 0 0 3 0 0 0 2 3 3 4 0
0 0 0 0 4 3 3 3 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0
0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0
0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 0 1 1 1 0 1 0
0 0 0 1 1 1 1 1 1 1 1 0 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 1 1 1 1 4 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 2 1 4 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 4 1 2 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 1 0 0 2 1 4 0 0 0 0 0 0 0
0 0 0 4 1 1 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 1 1 4 0 0
0 0 0 0 0 0 0 0 4 1 2 0 0 2 4 0
0 0 0 4 1 1 1 1 2 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 0 2 1 2 0 1 0
0 0 0 4 1 1 1 1 1 1 4 0 4 1 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Input Grid:** Each input grid contains shapes composed of a single dominant color (azure, green, or blue) on a white background. The shapes have varying complexity, including straight lines, corners, and enclosed areas.
2.  **Output Grid:** The output grid retains the overall structure and position of the shapes from the input grid. The white background remains unchanged.
3.  **Color Changes:** Specific pixels of the original shape color are changed to either yellow (4) or red (2) in the output. The original color pixels that are not changed remain the same.
4.  **Pattern Recognition:** The color changes appear related to the local geometry of the shape at each pixel's location.
    *   Yellow pixels seem to replace the original color at points that could be described as "outer" corners (convex points relative to the shape) or some types of "inner" corners (concave points).
    *   Red pixels seem to replace the original color at specific types of "inner" corners, seemingly sharper ones.
5.  **Neighborhood Analysis:** The transformation rule likely depends on the configuration of neighboring pixels, specifically the count and arrangement of adjacent white pixels (background).
    *   Pixels changing to yellow (4) consistently have three or more white neighbors (including diagonals).
    *   Pixels changing to red (2) consistently have exactly two white neighbors, and these two white neighbors are positioned diagonally relative to each other across the pixel in question (e.g., the North and East neighbors are white, or the South and West neighbors are white).

**Facts**


```yaml
- task: corner_detection_and_coloring
- description: Identifies different types of corners within shapes based on neighboring background pixels and recolors them.
- objects:
    - type: grid
      properties:
        - contains_pixels
    - type: pixel
      properties:
        - color (value 0-9)
        - position (row, column)
        - neighbors (8 adjacent pixels: N, NE, E, SE, S, SW, W, NW)
    - type: shape
      properties:
        - composed_of_contiguous_non_white_pixels
        - has_boundary_pixels_adjacent_to_white_pixels
- relationships:
    - pixel_is_part_of_shape: A non-white pixel belongs to a shape.
    - pixel_is_background: A white pixel (0) is background.
    - pixel_is_neighbor_of_pixel: Based on adjacency (cardinal or diagonal).
- actions:
    - analyze_pixel_neighborhood: For each non-white pixel, count its white neighbors and determine their relative positions.
    - recolor_pixel: Change the color of a pixel based on the neighborhood analysis.
- rules:
    - rule_1:
        - condition: Pixel is non-white AND has exactly 2 white neighbors AND these 2 white neighbors are diagonally adjacent relative to the pixel (e.g., N and E are white, or S and W are white).
        - action: Change pixel color to red (2).
    - rule_2:
        - condition: Pixel is non-white AND has 3 or more white neighbors.
        - action: Change pixel color to yellow (4).
    - rule_3:
        - condition: Pixel is white OR conditions for rule_1 and rule_2 are not met.
        - action: Keep the original pixel color.

```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the output grid.
2.  Iterate through each pixel `P` at position (row, column) in the input grid.
3.  If the color of pixel `P` is white (0), continue to the next pixel (the output pixel remains white).
4.  If the color of pixel `P` is non-white:
    a.  Examine the 8 neighbors of pixel `P`.
    b.  Count the number of neighbors that are white (0). Let this count be `white_neighbor_count`.
    c.  Identify the positions of the white neighbors relative to `P` (N, NE, E, SE, S, SW, W, NW).
    d.  **Check for Red Condition:** If `white_neighbor_count` is exactly 2, check if the two white neighbors form one of the following pairs: (N and E), (S and E), (S and W), or (N and W). If they do, change the color of the corresponding pixel in the output grid to red (2).
    e.  **Check for Yellow Condition:** If the condition for red was not met, check if `white_neighbor_count` is 3 or more. If it is, change the color of the corresponding pixel in the output grid to yellow (4).
    f.  **Default Condition:** If neither the red nor the yellow condition was met, the corresponding pixel in the output grid retains the original non-white color of pixel `P`.
5.  Return the modified output grid.
