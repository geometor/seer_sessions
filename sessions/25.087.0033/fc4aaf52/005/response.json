{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies a single non-background object in the input grid, where the background color is Azure (8). \nIt then creates two copies of this object. \nA conditional color swap is applied to both copies: if the original object contains both Blue (1) and Red (2) pixels, then Blue and Red are swapped in the copies.\nFinally, the two copies (potentially with swapped colors) are placed onto an output grid of the same dimensions as the input, initialized with the background color. \nThe placement involves specific shifts relative to the original object's top-left position:\n- Copy A is always shifted by (4 rows down, 1 column left).\n- Copy B is shifted by (0 rows down, 5 columns right) if the color swap occurred, or by (0 rows down, 3 columns right) if no color swap occurred.\nIf multiple objects exist or no object exists, the behavior might be undefined by the examples, but this implementation assumes a single object.\n\"\"\"\n\ndef find_single_object(grid_np, background_color):\n    \"\"\"\n    Finds the pixels, colors, and top-left corner of a single non-background object.\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n        background_color (int): The color designated as the background.\n\n    Returns:\n        tuple: (object_pixels, object_colors, min_row, min_col) or (None, None, None, None) if no object found.\n               object_pixels: List of (row, col) tuples for object pixels.\n               object_colors: Set of unique colors in the object.\n               min_row, min_col: Coordinates of the top-left bounding box corner.\n    \"\"\"\n    rows, cols = grid_np.shape\n    object_pixels = []\n    object_colors = set()\n    min_row, min_col = rows, cols  # Initialize to max possible values\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_np[r, c]\n            if color != background_color:\n                object_pixels.append((r, c))\n                object_colors.add(color)\n                min_row = min(min_row, r)\n                min_col = min(min_col, c)\n\n    if not object_pixels:\n        return None, None, None, None\n\n    return object_pixels, object_colors, min_row, min_col\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by duplicating, shifting, and potentially \n    color-swapping a single non-background object based on specific rules.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    background_color = 8  # Azure is the background color\n\n    # Initialize the output grid with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # --- Step 1: Find the single non-background object ---\n    object_pixels, object_colors, min_row, min_col = find_single_object(input_np, background_color)\n\n    # If there's no object (only background), return the empty output grid\n    if object_pixels is None:\n        return output_grid.tolist()\n\n    # --- Step 2: Extract the object's relative pattern ---\n    relative_pattern = []\n    for r, c in object_pixels:\n        color = input_np[r, c]\n        # Store relative coordinates and original color\n        relative_pattern.append(((r - min_row, c - min_col), color)) \n\n    # --- Step 3: Check if color swapping is needed ---\n    # Condition: Both Blue (1) and Red (2) must be present in the object\n    needs_swap = (1 in object_colors and 2 in object_colors)\n\n    # --- Step 4: Determine the shift vectors ---\n    shift_A = (4, -1) # Corrected: Always (delta_row=4, delta_col=-1)\n    if needs_swap:\n        shift_B = (0, 5)  # (delta_row=0, delta_col=5) if swap occurred\n    else:\n        shift_B = (0, 3)  # (delta_row=0, delta_col=3) if no swap occurred\n\n    # --- Step 5: Place the two copies onto the output grid ---\n    for (rel_r, rel_c), original_color in relative_pattern:\n        \n        # Determine the output color (apply swap if needed for both copies)\n        output_color = original_color\n        if needs_swap:\n            if original_color == 1:\n                output_color = 2\n            elif original_color == 2:\n                output_color = 1\n        \n        # Calculate target position for Copy A and place pixel if within bounds\n        target_r_A = min_row + rel_r + shift_A[0]\n        target_c_A = min_col + rel_c + shift_A[1]\n        if 0 <= target_r_A < rows and 0 <= target_c_A < cols:\n            output_grid[target_r_A, target_c_A] = output_color\n\n        # Calculate target position for Copy B and place pixel if within bounds\n        target_r_B = min_row + rel_r + shift_B[0]\n        target_c_B = min_col + rel_c + shift_B[1]\n        if 0 <= target_r_B < rows and 0 <= target_c_B < cols:\n            output_grid[target_r_B, target_c_B] = output_color # Use the same potentially swapped color\n\n    # --- Step 6: Return the final grid ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5400,
    "candidates_token_count": 1411,
    "total_token_count": 6811,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.030113,
  "retries": null
}