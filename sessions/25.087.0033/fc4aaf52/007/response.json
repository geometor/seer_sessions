{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies a single non-background object in the input grid, where the background color is Azure (8). \nIt then creates two copies of this object. \nA conditional color swap is applied to both copies: if the original object contains both Blue (1) and Red (2) pixels, then Blue and Red are swapped in the copies.\nFinally, the two copies (potentially with swapped colors) are placed onto an output grid of the same dimensions as the input, initialized with the background color. \nThe placement involves specific constant shifts relative to the original object's top-left position:\n- Copy A (Bottom-Left) is always shifted by (4 rows down, 1 column left) -> (\u0394row=4, \u0394col=-1).\n- Copy B (Top-Right) is always shifted by (0 rows down, 5 columns right) -> (\u0394row=0, \u0394col=5).\nIf multiple objects exist or no object exists, the behavior is undefined by the examples; this implementation assumes a single object and returns an empty grid if none is found.\n\"\"\"\n\ndef find_single_object(grid_np, background_color):\n    \"\"\"\n    Finds the pixels, colors, and top-left corner of a single non-background object.\n    Uses Breadth-First Search (BFS) to find the first connected component.\n    Assumes only one object exists based on the task description.\n\n    Args:\n        grid_np (np.ndarray): The input grid as a NumPy array.\n        background_color (int): The color designated as the background.\n\n    Returns:\n        tuple: (object_pixels, object_colors, min_row, min_col) or (None, None, None, None) if no object found.\n               object_pixels: List of (row, col) tuples for object pixels.\n               object_colors: Set of unique colors in the object.\n               min_row, min_col: Coordinates of the top-left bounding box corner.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    \n    for r_start in range(rows):\n        for c_start in range(cols):\n            if grid_np[r_start, c_start] != background_color and not visited[r_start, c_start]:\n                # Found the start of an object, perform BFS\n                object_pixels = []\n                object_colors = set()\n                min_row, min_col = r_start, c_start\n                q = [(r_start, c_start)]\n                visited[r_start, c_start] = True\n\n                while q:\n                    r, c = q.pop(0)\n                    color = grid_np[r, c]\n                    object_pixels.append((r, c))\n                    object_colors.add(color)\n                    min_row = min(min_row, r)\n                    min_col = min(min_col, c)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid_np[nr, nc] != background_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Since we assume only one object, return immediately after finding the first one\n                return object_pixels, object_colors, min_row, min_col\n\n    # If no non-background pixels found\n    return None, None, None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by duplicating, shifting, and potentially \n    color-swapping a single non-background object based on specific rules.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    background_color = 8  # Azure is the background color\n\n    # 1. Initialize output grid with background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # 2. Identify the single non-background object\n    object_pixels, object_colors, min_row, min_col = find_single_object(input_np, background_color)\n\n    # If there's no object (only background), return the empty output grid\n    if object_pixels is None:\n        return output_grid.tolist()\n\n    # 3. Check if color swapping is needed (Blue=1 and Red=2 present)\n    needs_swap = (1 in object_colors and 2 in object_colors)\n\n    # 4. Define the constant shift vectors\n    shift_A = (4, -1)  # Bottom-Left copy shift (delta_row, delta_col)\n    shift_B = (0, 5)   # Top-Right copy shift (delta_row, delta_col)\n\n    # 5. Iterate through object pixels, calculate target positions, apply color swap if needed, and place pixels\n    for r, c in object_pixels:\n        original_color = input_np[r, c]\n        \n        # Determine the output color (apply swap if needed for both copies)\n        output_color = original_color\n        if needs_swap:\n            if original_color == 1:\n                output_color = 2\n            elif original_color == 2:\n                output_color = 1\n        \n        # Calculate relative position within the object\n        rel_r = r - min_row\n        rel_c = c - min_col\n\n        # Calculate target position for Copy A (Bottom-Left)\n        target_r_A = min_row + rel_r + shift_A[0]\n        target_c_A = min_col + rel_c + shift_A[1]\n        # Place pixel if within bounds\n        if 0 <= target_r_A < rows and 0 <= target_c_A < cols:\n            output_grid[target_r_A, target_c_A] = output_color\n\n        # Calculate target position for Copy B (Top-Right)\n        target_r_B = min_row + rel_r + shift_B[0]\n        target_c_B = min_col + rel_c + shift_B[1]\n        # Place pixel if within bounds\n        if 0 <= target_r_B < rows and 0 <= target_c_B < cols:\n            output_grid[target_r_B, target_c_B] = output_color \n\n    # 6. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15176,
    "candidates_token_count": 1607,
    "total_token_count": 16783,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.71618,
  "retries": null
}