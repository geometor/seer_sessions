
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 0 5 0 8 8 8 8 8 8 8 8 8 8
8 8 0 5 5 5 0 8 8 8 8 8 8 8 8 8
8 8 8 0 5 0 8 8 8 8 8 8 8 8 8 8
8 8 8 0 5 0 8 8 8 8 8 8 8 8 8 8
8 8 0 5 5 5 0 8 8 8 8 8 8 8 8 8
8 8 8 0 5 0 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 5 0 5 8 8 8 8 8 8 8
8 8 8 8 8 5 0 0 0 5 8 8 8 8 8 8
8 8 8 8 8 8 5 0 5 8 8 8 8 8 8 8
8 8 8 5 0 5 8 8 8 8 8 8 8 8 8 8
8 8 5 0 0 0 5 8 8 8 8 8 8 8 8 8
8 8 8 5 0 5 8 8 8 8 8 8 8 8 8 8
8 8 8 8 5 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 1 2 1 8 8 8 8 8 8 8 8 8 8 8 8
8 1 2 1 8 8 8 8 8 8 8 8 8 8 8 8
8 1 2 2 1 1 8 8 8 8 8 8 8 8 8 8
8 1 2 2 1 1 8 8 8 8 8 8 8 8 8 8
8 1 2 1 8 8 8 8 8 8 8 8 8 8 8 8
8 1 2 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 1 2 8 8 8 8 8 8 8
8 8 8 8 8 8 2 1 2 8 8 8 8 8 8 8
8 8 8 8 8 8 2 1 1 2 2 8 8 8 8 8
8 2 1 1 2 2 8 8 8 8 8 8 8 8 8 8
8 2 1 2 8 8 8 8 8 8 8 8 8 8 8 8
8 2 1 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Grid Structure:** Both input and output grids in both examples are 16x16.
2.  **Background:** The background color is consistently Azure (8) and remains unchanged in the output.
3.  **Input Object:** Each input grid contains a single composite object composed of non-background colors, set against the Azure background.
    *   Example 1: The object is made of White (0) and Gray (5). It has a hollow diamond shape (White) with a cross inside (Gray).
    *   Example 2: The object is made of Blue (1) and Red (2). It looks somewhat like an 'F' or a key, with Blue outlining Red.
4.  **Output Objects:** Each output grid contains two distinct objects, which are modified copies of the input object.
5.  **Transformation - Position:** The input object is effectively replaced by two copies, each shifted to a new location. By comparing the bounding boxes of the objects:
    *   One copy is consistently shifted 4 rows down and 0 columns right relative to the original position.
    *   The other copy is consistently shifted 1 row down and 4 columns right relative to the original position.
6.  **Transformation - Color:**
    *   In Example 1 (White/Gray object), the colors in the output copies remain the same as the input object.
    *   In Example 2 (Blue/Red object), the colors within the object are swapped in *both* output copies: Blue (1) becomes Red (2), and Red (2) becomes Blue (1).
7.  **Hypothesis:** The core transformation involves identifying the non-background object, creating two copies, applying specific translations to each copy, and conditionally swapping specific colors (Blue and Red) within the copies before placing them on the output grid.

**Facts**


```yaml
Task: Duplicate and shift an object, with conditional color swap.

Input:
  Grid:
    Size: Variable (16x16 in examples)
    Background: Azure (8)
    Contains: A single contiguous object composed of non-background colors.

Object:
  Properties:
    - Colors: Set of colors making up the object (e.g., {White(0), Gray(5)}, {Blue(1), Red(2)}).
    - Pixels: List of coordinates and colors for each pixel in the object.
    - BoundingBox: Coordinates of the minimum rectangle enclosing the object.

Transformations:
  - Action: Identify the single non-background object.
  - Action: Create two copies of the object's pixel data (relative positions and colors).
  - Condition: Check if the object's colors include BOTH Blue (1) AND Red (2).
    - If True:
      - Action: In BOTH copies, swap Blue (1) pixels to Red (2) and Red (2) pixels to Blue (1).
  - Action: Translate Copy 1.
    - Source: Original object position (using BoundingBox top-left).
    - Vector: (rows: +4, columns: +0).
  - Action: Translate Copy 2.
    - Source: Original object position (using BoundingBox top-left).
    - Vector: (rows: +1, columns: +4).
  - Action: Compose Output Grid.
    - Start with the background color (Azure/8).
    - Draw the pixels of Translated Copy 1.
    - Draw the pixels of Translated Copy 2.

Output:
  Grid:
    Size: Same as input.
    Background: Azure (8).
    Contains: Two objects, which are the translated (and potentially color-swapped) copies of the input object.
```


**Natural Language Program**

1.  Create an output grid of the same dimensions as the input grid, filled entirely with the background color (Azure, 8).
2.  Find all non-background pixels in the input grid. Identify the single contiguous object formed by these pixels.
3.  Determine the bounding box of this object and record its top-left corner coordinates (min_row, min_col).
4.  Extract the pattern of the object relative to its top-left corner (i.e., for each pixel within the bounding box, store its relative coordinates (r, c) and its color).
5.  Analyze the colors present in the extracted object pattern. Check if both Blue (1) and Red (2) are present.
6.  Create two copies of the object pattern (relative coordinates and colors).
7.  If both Blue (1) and Red (2) were found in step 5, modify both copies: change all pixels with color Blue (1) to Red (2), and change all pixels with color Red (2) to Blue (1).
8.  For the first copy (potentially color-swapped): Iterate through its relative pixel coordinates (r, c) and colors. Place each pixel onto the output grid at the absolute coordinates (min_row + r + 4, min_col + c + 0).
9.  For the second copy (potentially color-swapped): Iterate through its relative pixel coordinates (r, c) and colors. Place each pixel onto the output grid at the absolute coordinates (min_row + r + 1, min_col + c + 4).
10. Return the final output grid.
