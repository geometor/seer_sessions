
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 0 0 0
0 0 0 0 4 4 0 0 0 0
0 0 0 0 4 0 4 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 6 6 6 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 4 4 0
0 0 0 0 4 4 0 0 4 4
0 0 0 0 4 0 4 4 0 4
0 0 0 0 0 4 0 0 4 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 6 6 6 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 4 4 0 0 0 0 0 0 0
0 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 4 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 4 4 0 0 4 4 0 0 0
0 4 4 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 0 0 6 6 6 6 0
0 0 0 0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 6 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 4 4 4 4 0 0
```

*   **Perception:**
    *   The input grids contain two distinct objects: one yellow (color 4) and one magenta (color 6), on a white (color 0) background.
    *   The output grids contain only a yellow object, which is larger than the input yellow object. The magenta object is removed.
    *   The transformation appears to involve reflecting the input yellow object and combining the original and reflected shapes.
    *   The type of reflection (horizontal or vertical) seems to depend on the shape (aspect ratio) of the magenta object.
    *   The axis of reflection seems to be positioned relative to the bounding box of the *yellow* object.

*   **Facts:**
    
```yaml
    elements:
      - object: yellow_object
        color: 4
        properties:
          - shape: variable
          - location: variable
          - bounding_box: defined by extent of yellow pixels
      - object: magenta_object
        color: 6
        properties:
          - shape: variable
          - location: variable
          - bounding_box: defined by extent of magenta pixels
          - aspect_ratio: height vs width of bounding_box
    actions:
      - find_objects: Identify contiguous pixels of color 4 (yellow) and 6 (magenta).
      - calculate_bounding_box: Determine the min/max row/col for both yellow and magenta objects.
      - determine_reflection_type:
          - condition: If magenta_object height >= magenta_object width
          - result: horizontal_reflection
          - condition: If magenta_object height < magenta_object width
          - result: vertical_reflection
      - determine_reflection_axis:
          - if horizontal_reflection: Use the vertical line immediately right of the yellow_object's bounding box (x = yellow_max_col + 0.5).
          - if vertical_reflection: Use the horizontal line immediately below the yellow_object's bounding box (y = yellow_max_row + 0.5).
      - reflect_pixels: For each yellow pixel in the input, calculate its reflected position across the determined axis.
      - construct_output: Create a new grid of the same dimensions as the input. Fill it with the background color (0). Draw the original yellow pixels and the newly calculated reflected yellow pixels onto the output grid.
    relationships:
      - The aspect ratio of the magenta_object's bounding box determines whether the reflection applied to the yellow_object is horizontal or vertical.
      - The position of the reflection axis is determined by the bounding box of the yellow_object.
      - The magenta_object itself is removed in the output.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, but replace all magenta (6) pixels with the background color (white, 0).
    2.  Identify all pixels belonging to the yellow object (color 4) and the magenta object (color 6).
    3.  Determine the bounding box (minimum row, maximum row, minimum column, maximum column) for the yellow object.
    4.  Determine the bounding box for the magenta object.
    5.  Calculate the height and width of the magenta object's bounding box.
    6.  Compare the height and width of the magenta object's bounding box:
        a.  If the height is greater than or equal to the width (taller or square):
            i.  Define the reflection axis as the vertical line located at `x = maximum_column_of_yellow_bounding_box + 0.5`.
            ii. For each yellow pixel at `(row, col)` in the input, calculate its horizontally reflected position `(row, reflected_col)`, where `reflected_col = 2 * (maximum_column_of_yellow_bounding_box + 0.5) - col - 1`. If the reflection calculation results in non-integer coordinates adjust logic to reflect pixel centers, e.g. `reflected_col = maximum_column_of_yellow_bounding_box + (maximum_column_of_yellow_bounding_box - col + 1)`.
            iii. Change the color of the pixel at the reflected position `(row, reflected_col)` in the output grid to yellow (4), provided the coordinates are within the grid boundaries.
        b.  If the height is less than the width (wider):
            i.  Define the reflection axis as the horizontal line located at `y = maximum_row_of_yellow_bounding_box + 0.5`.
            ii. For each yellow pixel at `(row, col)` in the input, calculate its vertically reflected position `(reflected_row, col)`, where `reflected_row = 2 * (maximum_row_of_yellow_bounding_box + 0.5) - row - 1`. If the reflection calculation results in non-integer coordinates adjust logic to reflect pixel centers, e.g. `reflected_row = maximum_row_of_yellow_bounding_box + (maximum_row_of_yellow_bounding_box - row + 1)`.
            iii. Change the color of the pixel at the reflected position `(reflected_row, col)` in the output grid to yellow (4), provided the coordinates are within the grid boundaries.
    7.  Ensure the original yellow pixels remain yellow in the output grid. The final output grid contains the original yellow object plus its reflection, with the magenta object removed.
