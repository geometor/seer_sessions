{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# COLOR MAPPING (for reference, not used in code)\n# 0: white, 1: blue, 2: red, 5: gray\n\ndef find_reachable_background(grid):\n    \"\"\"\n    Performs a flood fill (BFS) starting from the white pixels (0) on the\n    border of the grid to identify all white pixels connected to the outside.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        np.array: A boolean mask where True indicates a white pixel reachable\n                  from the border.\n    \"\"\"\n    height, width = grid.shape\n    reachable = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Seed the queue with all white pixels on the border\n    for r in range(height):\n        if grid[r, 0] == 0 and not reachable[r, 0]:\n            q.append((r, 0))\n            reachable[r, 0] = True\n        # Avoid double-adding corners if width=1\n        if width > 1 and grid[r, width - 1] == 0 and not reachable[r, width - 1]:\n            q.append((r, width - 1))\n            reachable[r, width - 1] = True\n    for c in range(1, width - 1): # Avoid corners already checked\n        if grid[0, c] == 0 and not reachable[0, c]:\n            q.append((0, c))\n            reachable[0, c] = True\n        # Avoid double-adding corners if height=1\n        if height > 1 and grid[height - 1, c] == 0 and not reachable[height - 1, c]:\n            q.append((height - 1, c))\n            reachable[height - 1, c] = True\n\n    # Perform BFS using 4-directional neighbors (sufficient for area connection)\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds and if the neighbor is white and not yet visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and not reachable[nr, nc]:\n                reachable[nr, nc] = True\n                q.append((nr, nc))\n\n    return reachable\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"\n    Gets the coordinates of all valid 8-connected neighbors for a given cell (r, c).\n\n    Args:\n        r (int): Row index of the cell.\n        c (int): Column index of the cell.\n        height (int): Grid height.\n        width (int): Grid width.\n\n    Returns:\n        list: A list of tuples, where each tuple is the (row, col) of a neighbor.\n    \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the cell itself\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor coordinates are within the grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rule:\n    Find all white pixels (color 0) that are completely enclosed by other colors\n    (i.e., not connected to the white background reaching the edge of the grid).\n    Then, find all gray pixels (color 5) that are adjacent (including diagonals)\n    to these enclosed white pixels. Change the color of these adjacent gray pixels\n    to red (color 2). All other pixels remain unchanged.\n\n    Workflow:\n    1. Convert the input list of lists to a NumPy array.\n    2. Create a copy of the NumPy array for the output grid.\n    3. Use a flood fill (BFS) starting from the border white pixels to identify all\n       'background' white pixels (those connected to the grid edge).\n    4. Iterate through each cell (r, c) of the input grid.\n    5. If a cell contains a white pixel (0) and it was *not* marked as a background\n       pixel by the flood fill, then it is an 'enclosed' white pixel.\n    6. For each enclosed white pixel, get its 8 neighbors (horizontal, vertical,\n       and diagonal).\n    7. For each neighbor (nr, nc), if the input grid at (nr, nc) is gray (5),\n       change the corresponding pixel in the output grid at (nr, nc) to red (2).\n    8. Convert the final output NumPy array back to a list of lists.\n    9. Return the output list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_np = input_np.copy()\n    height, width = input_np.shape\n\n    # Step 3: Identify background white pixels\n    background_mask = find_reachable_background(input_np)\n\n    # Step 4-7: Iterate, find enclosed white pixels, and modify neighbors\n    for r in range(height):\n        for c in range(width):\n            # Step 5: Check if it's an enclosed white pixel\n            if input_np[r, c] == 0 and not background_mask[r, c]:\n                # Step 6: Get 8 neighbors\n                for nr, nc in get_neighbors(r, c, height, width):\n                    # Step 7: Check if neighbor is gray in input and change in output\n                    if input_np[nr, nc] == 5:\n                        output_np[nr, nc] = 2\n\n    # Step 8: Convert output numpy array back to list of lists\n    output_grid = output_np.tolist()\n    # Step 9: Return the result\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3434,
    "candidates_token_count": 1454,
    "total_token_count": 4888,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 178.19721,
  "retries": null
}