
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 3 2 2 3 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 2 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 2 2 1 0 0 1 2 1 0
0 1 2 2 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 3 3 3 2 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```

Okay, let's analyze the provided ARC task examples.

**Perception of Task Elements:**

1.  **Input/Output Grids:** Both input and output are 2D grids of pixels with integer values representing colors (0=white, 1=blue, 2=red, 3=green).
2.  **Objects:** The primary objects in the input grids are contiguous blocks (rectangles in these examples) of blue (1) pixels, set against a white (0) background.
3.  **Transformation:** The transformation exclusively affects the blue pixels within these blocks. The white background pixels remain unchanged.
4.  **Color Changes:** Within each blue block, the pixels change color based on their position relative to the boundary of the block. New colors introduced are red (2) and green (3).
5.  **Pattern:** The color change appears related to the "depth" or distance of a pixel from the nearest non-blue (white) pixel outside the block.
    *   Pixels on the immediate border (distance 0 from the outside) remain blue (1).
    *   Pixels one step inside (distance 1) become red (2).
    *   Pixels two steps inside (distance 2) become green (3).
    *   Pixels three steps inside (distance 3) become red (2) again.
    *   This suggests a cyclical pattern based on Manhattan distance from the exterior: Blue (1) -> Red (2) -> Green (3) -> Red (2) -> Blue (1) -> ...

**YAML Facts:**


```yaml
task_description: "Modify the color of pixels within contiguous blue objects based on their Manhattan distance to the nearest non-blue pixel."
elements:
  - element: "grid"
    description: "A 2D array of pixels representing colors."
  - element: "pixel"
    description: "A single cell in the grid with a color value (0-9)."
    properties:
      - color: "Integer value 0-9."
      - position: "(row, column) coordinates."
  - element: "object"
    description: "A contiguous area of pixels of the same color."
    properties:
      - color: "The color of the pixels forming the object."
      - pixels: "Set of (row, column) coordinates belonging to the object."
      - boundary: "Pixels within the object adjacent (including diagonals) to pixels outside the object."
      - interior: "Pixels within the object not on the boundary."
objects_in_examples:
  - object: "blue_block"
    color: 1 (blue)
    description: "Contiguous blocks of blue pixels found in the input grids."
  - object: "background"
    color: 0 (white)
    description: "The area surrounding the blue blocks."
relationships:
  - relationship: "adjacency"
    description: "Pixels are adjacent if they share a side or a corner (8-connectivity)."
  - relationship: "distance"
    description: "Manhattan distance between two pixels (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|."
transformation:
  action: "recolor"
  target: "Pixels within blue_blocks."
  rule: >
    The new color of a blue pixel is determined by its minimum Manhattan distance 'd'
    to the nearest non-blue (background) pixel. The color follows a repeating sequence
    based on 'd': distance 0 -> color 1 (blue), distance 1 -> color 2 (red),
    distance 2 -> color 3 (green), distance 3 -> color 2 (red).
    This cycle repeats every 4 distance units.
    Specifically, the color is determined by `sequence[d % 4]`, where `sequence = [1, 2, 3, 2]`.
  unchanged: "Non-blue pixels (background) remain unchanged."
```


**Natural Language Program:**

1.  Identify all contiguous blocks of blue (1) pixels in the input grid.
2.  Create an output grid initialized as a copy of the input grid.
3.  For each pixel `(r, c)` in the input grid:
    a.  If the pixel `(r, c)` is blue (color 1):
        i.  Calculate the minimum Manhattan distance `d` from this pixel `(r, c)` to any pixel `(r', c')` in the input grid that is *not* blue (i.e., color 0 in these examples).
        ii. Define a color sequence: `colors = [Blue(1), Red(2), Green(3), Red(2)]`.
        iii. Determine the index into the sequence using the distance: `index = d % 4`.
        iv. Assign the color from the sequence at the calculated index to the pixel `(r, c)` in the output grid: `output_grid[r][c] = colors[index]`.
    b.  If the pixel `(r, c)` is not blue, its color in the output grid remains the same as in the input grid.
4.  Return the completed output grid.
