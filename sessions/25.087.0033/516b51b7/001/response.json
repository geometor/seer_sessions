{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nModify the color of pixels within contiguous blue objects based on their Manhattan distance \nto the nearest non-blue pixel. The new color of a blue pixel is determined by its \nminimum Manhattan distance 'd' to the nearest non-blue pixel. The color follows a \nrepeating sequence based on 'd': distance 0 -> color 1 (blue), \ndistance 1 -> color 2 (red), distance 2 -> color 3 (green), distance 3 -> color 2 (red). \nThis cycle repeats every 4 distance units. Specifically, the color is determined by \nsequence[d % 4], where sequence = [1, 2, 3, 2]. Non-blue pixels remain unchanged.\n\"\"\"\n\ndef calculate_min_manhattan_distance(r, c, target_coords):\n    \"\"\"\n    Calculates the minimum Manhattan distance from a point (r, c) to any point\n    in the target_coords list.\n    \"\"\"\n    min_dist = float('inf')\n    for tr, tc in target_coords:\n        dist = abs(r - tr) + abs(c - tc)\n        if dist < min_dist:\n            min_dist = dist\n            # Optimization: if distance is 0, it can't be smaller\n            if min_dist == 0:\n                break\n    return min_dist\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the distance rule.\n\n    Args:\n        input_grid (list of lists): The input grid representing pixel colors.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Define the color sequence based on distance\n    # d=0 -> 1, d=1 -> 2, d=2 -> 3, d=3 -> 2, d=4 -> 1, ...\n    color_sequence = [1, 2, 3, 2] \n\n    # Find coordinates of all non-blue pixels (color != 1)\n    # These are the pixels we measure distance *to*.\n    non_blue_coords = list(zip(*np.where(input_np != 1)))\n\n    # If there are no non-blue pixels, the input is likely all blue.\n    # The rule is defined based on distance *to* non-blue, so this case needs clarification.\n    # Based on examples, the border pixels stay blue (dist=0 to outside),\n    # which implies we measure to the conceptual boundary *or* actual non-blue pixels.\n    # If the grid were entirely blue, perhaps it remains all blue?\n    # However, given the examples always have a background, we proceed assuming non_blue_coords is not empty.\n    # If it were empty, the distance calculation would fail or return infinity.\n    # A safer approach if non_blue_coords can be empty might be needed for more general cases.\n    if not non_blue_coords:\n         # If the whole grid is blue, maybe it stays blue? Or apply a default?\n         # Based on the description \"distance to the nearest *non-blue* pixel\",\n         # if none exist, the distance is undefined or infinite.\n         # Let's assume for this task context, non-blue pixels *always* exist,\n         # possibly even implicitly outside the grid boundary for border pixels.\n         # But the provided examples have explicit non-blue (0) pixels.\n         # If the entire grid was blue, perhaps return it unchanged?\n         # For now, we'll rely on the examples having non-blue pixels.\n         pass # Or handle this edge case explicitly if needed\n\n\n    # Iterate through each pixel in the grid\n    for r in range(height):\n        for c in range(width):\n            # Check if the current pixel is blue\n            if input_np[r, c] == 1:\n                # Calculate the minimum Manhattan distance to any non-blue pixel\n                min_dist = calculate_min_manhattan_distance(r, c, non_blue_coords)\n                \n                # Calculate the index in the color sequence\n                # The description implies distance 0 from non-blue means the pixel *is* non-blue.\n                # But the examples show boundary blue pixels (distance 1 from inner non-blue, 0 from outer non-blue)\n                # remain blue. Let's reinterpret distance 'd' as the shortest path *within* the blue shape\n                # to reach a boundary adjacent to a non-blue.\n                # No, the description is \"distance 'd' to the *nearest non-blue* pixel\".\n                # Let's test the examples with this direct interpretation.\n                # Example 1: Pixel (2, 2) is blue (1). Nearest non-blue are (1, 1), (1, 2)...(1,8), (2,1), (2,8), etc.\n                # Min distance to (1,2) is 1. Output is 2. Correct. sequence[1%4] = sequence[1] = 2.\n                # Pixel (3, 3) is blue (1). Nearest non-blue are (1,3), (2,1), (2,8), (3,1), (3,8) ... Min distance is 2 (e.g. to (1,3) or (3,1)).\n                # Output is 3. Correct. sequence[2%4] = sequence[2] = 3.\n                # Pixel (4, 4) is blue (1). Nearest non-blue: (1,4), (2,1), (2,8)... min dist 3 (e.g. to (1,4) or (4,1)).\n                # Output is 2. Correct. sequence[3%4] = sequence[3] = 2.\n                # Pixel (3, 4) is blue (1). Nearest non-blue: (1,4), (2,1), (2,8)... min dist is 2 (e.g. to (1,4) or (3,1)).\n                # Output is 3. Correct. sequence[2%4] = sequence[2] = 3.\n\n                # It seems the direct interpretation works.\n\n                sequence_index = min_dist % 4\n                \n                # Assign the new color based on the distance\n                output_np[r, c] = color_sequence[sequence_index]\n\n    # Convert the result back to a list of lists\n    output_grid = output_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4252,
    "candidates_token_count": 1535,
    "total_token_count": 5787,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.024509,
  "retries": null
}