
## train_1

**input:**
```
0 0 0 0 0 0 0 0 2 2 0 0 0 2 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0 2 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 2 2 3 0 3 2 3 0
2 0 0 0 0 0 0 3 3 3 3 0 3 2 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 3 3
0 0 2 0 0 0 0 0 0 0 2 0 0 2 3 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```

**Perception**

1.  **Input/Output Grids:** The task takes an input grid containing white (0) and red (2) pixels and produces an output grid of the same dimensions.
2.  **Color Transformation:** The primary transformation involves changing some white (0) pixels to green (3) pixels in the output. The original red (2) pixels remain unchanged in their positions.
3.  **Identifying the Trigger:** The appearance of green pixels is related to the configuration of red pixels. Specifically, green pixels appear in the vicinity of red pixels that are adjacent to *other* red pixels.
4.  **Adjacency:** Adjacency includes horizontal, vertical, and diagonal neighbors (8-connectivity).
5.  **Rule:** A white pixel turns green if and only if it is adjacent (8-connectivity) to at least one red pixel *that itself* has at least one adjacent red neighbor. Red pixels that are isolated (having no red neighbors) do not trigger the creation of green pixels around them.
6.  **Example Walkthrough (train_1):**
    *   Red pixels `(0, 8)` and `(0, 9)` are adjacent. They belong to the 'paired' red set.
    *   White pixel `(0, 7)` is adjacent to `(0, 8)`. Since `(0, 8)` is in the 'paired' set, `(0, 7)` becomes green.
    *   White pixel `(1, 8)` is adjacent to both `(0, 8)` and `(0, 9)`. Both are in the 'paired' set, so `(1, 8)` becomes green.
    *   Red pixel `(1, 0)` has no adjacent red pixels. It is not in the 'paired' set.
    *   White pixel `(1, 1)` is adjacent to `(1, 0)`. Since `(1, 0)` is not in the 'paired' set, `(1, 1)` remains white.
7.  **Example Walkthrough (train_2):**
    *   Red pixels `(2, 7)` and `(3, 7)` are adjacent. They form the 'paired' red set.
    *   White pixel `(1, 6)` is adjacent to `(2, 7)`. Since `(2, 7)` is in the 'paired' set, `(1, 6)` becomes green.
    *   All other red pixels are isolated. White pixels adjacent only to these isolated red pixels remain white.

**Facts**


```yaml
task_context:
  description: "Create a green 'aura' around contiguous groups (size >= 2) of red pixels."
  grid_properties:
    - dimensions_variable: True # Examples have different sizes
    - colors_used_input: [white(0), red(2)]
    - colors_used_output: [white(0), red(2), green(3)]

input_elements:
  - element_type: pixel
    color: white(0)
    role: background / potential_target_for_change
  - element_type: pixel
    color: red(2)
    role: source_marker / potential_trigger

output_elements:
  - element_type: pixel
    color: white(0)
    role: background / unchanged_target
  - element_type: pixel
    color: red(2)
    role: source_marker (preserved from input)
  - element_type: pixel
    color: green(3)
    role: indicator / aura (marks neighborhood of 'paired' red pixels)

transformation_steps:
  - step: 1
    action: identify_pixels
    input: input_grid
    condition: color == red(2)
    result: set of all red pixel coordinates `AllReds`
  - step: 2
    action: filter_pixels
    input: `AllReds`
    condition: "For a red pixel P in `AllReds`, check its 8 neighbors. If at least one neighbor is also in `AllReds`, keep P."
    result: set of 'paired' red pixel coordinates `PairedReds`
  - step: 3
    action: initialize_output_grid
    based_on: input_grid (copy)
  - step: 4
    action: iterate_grid
    target: each pixel `(r, c)` in the input grid
    condition: "input_grid[r, c] == white(0)"
    sub_steps:
      - action: check_neighbors
        target: 8 neighbors of `(r, c)`
        condition: "any neighbor coordinate `(nr, nc)` exists in the `PairedReds` set"
        effect_if_true: "set output_grid[r, c] = green(3)"
  - step: 5
    action: finalize
    result: output_grid
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the locations of all red pixels (color 2) in the input grid.
3.  Create a new set, called `PairedRedPixels`, containing only those red pixels
