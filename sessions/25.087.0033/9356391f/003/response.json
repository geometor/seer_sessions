{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set\n\n\"\"\"\nTransformation Rule:\n\n1.  **Initialize Output:** Create a copy of the input grid to serve as the output grid.\n2.  **Identify Target:** Locate the single non-white pixel (`target_color`) in the input grid at or below row 2. Record its position (`center_r`, `center_c`).\n3.  **Analyze Top Row (Row 0):**\n    a.  Find the rightmost non-white pixel. Record its color (`frame_color`) and column index (`frame_col`). This column index defines the maximum radius (`max_radius`) of the structure to be drawn.\n    b.  Collect the colors of all non-white pixels in row 0 located to the left of `frame_col`. Record these as `sequence_colors`.\n4.  **Determine Layer Colors:** Construct an ordered list of unique colors (`layer_colors`) for the concentric structure:\n    a.  Start with `target_color`.\n    b.  Append the unique colors from `sequence_colors`, sorted numerically (by color value).\n    c.  Append `frame_color`.\n    d.  Remove any duplicate colors from this combined list while preserving the relative order established in steps a-c. Let the final number of unique colors be `num_layers`.\n5.  **Modify Top Row (Conditional):** Check if `frame_col` is greater than 0 and if the pixel at `(0, frame_col - 1)` in the *input* grid is white (0).\n    a.  If both conditions are true, change the color of the pixel at `(0, frame_col)` in the *output* grid to the color of the pixel directly below it in the *input* grid (i.e., the color at `(1, frame_col)`).\n6.  **Construct Concentric Structure:**\n    a.  Set the pixel at the center position (`center_r`, `center_c`) in the output grid to the first color in `layer_colors` (`layer_colors[0]`).\n    b.  Iterate through radii `r` from 1 up to `max_radius` (inclusive):\n        i.  Determine the color for the current radius `r`: If `r` is less than `num_layers`, use the color `layer_colors[r]`. Otherwise (if `r` is greater than or equal to `num_layers`), use the last color in the list, `layer_colors[num_layers - 1]`.\n        ii. Draw a hollow square frame using this determined color. The frame consists of all pixels that are exactly at a Chebyshev distance of `r` from the center position (`center_r`, `center_c`). Ensure the drawing stays within the grid boundaries. Pixels drawn overwrite any existing colors at those locations in the output grid.\n\"\"\"\n\ndef find_target_pixel(grid: np.ndarray) -> Tuple[int, Tuple[int, int]]:\n    \"\"\"Finds the single non-white pixel at or below row 2.\"\"\"\n    height, width = grid.shape\n    for r in range(2, height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                return grid[r, c], (r, c)\n    # Should not happen based on task examples, but raise error if no target found\n    raise ValueError(\"Target pixel not found at or below row 2\")\n\ndef analyze_top_row(grid: np.ndarray) -> Tuple[int, int, List[int]]:\n    \"\"\"Analyzes row 0 to find frame color, frame column (max radius), and sequence colors.\"\"\"\n    width = grid.shape[1]\n    frame_color = 0\n    frame_col = -1 # Represents max_radius\n    sequence_colors = []\n\n    # Find rightmost non-white pixel (frame_color, frame_col)\n    for c in range(width - 1, -1, -1):\n        if grid[0, c] != 0:\n            frame_color = grid[0, c]\n            frame_col = c\n            break\n\n    if frame_col == -1:\n         # Handle case where top row is all white (or no non-white pixel found)\n         # Based on examples, this shouldn't happen. If it did, structure size is undefined.\n         # Returning -1 for frame_col allows the caller to handle this.\n         return 0, -1, []\n\n    # Collect sequence colors to the left of frame_col\n    for c in range(frame_col):\n        if grid[0, c] != 0:\n            sequence_colors.append(grid[0, c])\n\n    return frame_color, frame_col, sequence_colors\n\ndef determine_layer_colors(target_color: int, sequence_colors: List[int], frame_color: int) -> List[int]:\n    \"\"\"Determines the ordered list of unique colors for the concentric layers.\"\"\"\n    # Get unique sequence colors and sort them numerically\n    unique_sequence_colors = sorted(list(set(sequence_colors)))\n    \n    # Combine in the specified order: target, sorted unique sequence, frame\n    combined_colors = [target_color] + unique_sequence_colors + [frame_color]\n\n    # Remove duplicates while preserving the established order\n    layer_colors: List[int] = []\n    seen: Set[int] = set()\n    for color in combined_colors:\n        if color not in seen:\n            layer_colors.append(color)\n            seen.add(color)\n            \n    # Filter out white (0) if it somehow got included, shouldn't happen with non-white logic\n    layer_colors = [c for c in layer_colors if c != 0] \n            \n    return layer_colors\n\ndef draw_hollow_square_frame(grid: np.ndarray, center_r: int, center_c: int, radius: int, color: int):\n    \"\"\"Draws a hollow square frame (perimeter) at a given radius (Chebyshev distance) from the center.\"\"\"\n    height, width = grid.shape\n    # Calculate boundaries\n    top = center_r - radius\n    bottom = center_r + radius\n    left = center_c - radius\n    right = center_c + radius\n\n    # Draw top row of the frame\n    if 0 <= top < height:\n        for c in range(max(0, left), min(width, right + 1)):\n            grid[top, c] = color\n    # Draw bottom row of the frame\n    if 0 <= bottom < height:\n        for c in range(max(0, left), min(width, right + 1)):\n             grid[bottom, c] = color\n    # Draw left column (excluding corners already drawn by top/bottom)\n    if 0 <= left < width:\n        for r in range(max(0, top + 1), min(height, bottom)):\n             grid[r, left] = color\n    # Draw right column (excluding corners already drawn by top/bottom)\n    if 0 <= right < width:\n        for r in range(max(0, top + 1), min(height, bottom)):\n            grid[r, right] = color\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    # Convert to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    \n    # 1. Initialize Output: Create a copy of the input grid\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 2. Identify Target\n    try:\n        target_color, center_pos = find_target_pixel(input_np)\n        center_r, center_c = center_pos\n    except ValueError as e:\n        # If no target pixel is found (violates problem assumption), return the original grid\n        print(f\"Error: {e}. Returning input grid unchanged.\") \n        return input_grid\n\n    # 3. Analyze Top Row (Row 0)\n    frame_color, max_radius, sequence_colors = analyze_top_row(input_np)\n\n    # Check if top row analysis was successful (max_radius != -1)\n    if max_radius == -1:\n        print(\"Warning: No frame pixel found in top row. Cannot determine structure size. Returning input grid.\")\n        # Or potentially just draw the target pixel? Returning copy for now.\n        if 0 <= center_r < height and 0 <= center_c < width:\n             output_np[center_r, center_c] = target_color # At least place the target?\n        return output_np.tolist()\n\n    # 4. Determine Layer Colors\n    layer_colors = determine_layer_colors(target_color, sequence_colors, frame_color)\n    num_layers = len(layer_colors) # Number of unique colors available including center\n\n    if num_layers == 0: # Should not happen if target_color is non-zero\n        print(\"Warning: No layer colors determined. Returning input grid.\")\n        return output_np.tolist()\n\n    # 5. Modify Top Row (Conditional)\n    # Check if there's a pixel to the left (max_radius > 0) and if it's white\n    if max_radius > 0 and input_np[0, max_radius - 1] == 0:\n        # Check bounds for the pixel below\n        if 1 < height: # Ensure row 1 exists\n             replacement_color = input_np[1, max_radius] # Color from row below\n             output_np[0, max_radius] = replacement_color\n        # Else: row 1 doesn't exist, do nothing\n\n    # 6. Construct Concentric Structure\n    # a. Set the center pixel (radius 0)\n    if 0 <= center_r < height and 0 <= center_c < width:\n        output_np[center_r, center_c] = layer_colors[0]\n\n    # b. Iterate through radii r from 1 up to max_radius\n    for r in range(1, max_radius + 1):\n        # i. Determine the color for the current radius r\n        if r < num_layers:\n            # Use the color specified for this layer index (r)\n            color_for_radius = layer_colors[r]\n        else:\n            # If radius exceeds available unique colors, reuse the last available color\n            color_for_radius = layer_colors[num_layers - 1]\n            \n        # ii. Draw the hollow square frame for this radius\n        draw_hollow_square_frame(output_np, center_r, center_c, r, color_for_radius)\n\n    # Convert back to list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8933,
    "candidates_token_count": 2490,
    "total_token_count": 11423,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.797426,
  "retries": null
}