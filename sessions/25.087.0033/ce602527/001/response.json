{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1. Determine the background color by finding the most frequent color value in the input grid.\n2. Find all connected groups of pixels (objects) that have a color different from the background color, considering pixels connected horizontally, vertically, or diagonally (8-way connectivity) as part of the same group.\n3. For each object found, count how many distinct connected regions of the background color are entirely surrounded by pixels of that object (these are the \"holes\").\n4. Create a list of candidate objects consisting only of those objects that have exactly one hole or exactly two holes.\n5. If this list of candidate objects contains only one object, choose that object.\n6. If the list contains more than one candidate object, calculate the absolute difference between the background color's numerical value and the numerical value of the color of each candidate object. Choose the object for which this difference is the smallest.\n7. Find the minimum and maximum row and column indices occupied by the chosen object to define its bounding box.\n8. Construct the output grid by copying all pixels from the input grid that fall within this bounding box (inclusive of the minimum and maximum rows and columns).\n\"\"\"\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of pixels.\"\"\"\n    if not pixels:\n        return 0, 0, 0, 0\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds all distinct connected objects of non-background color using BFS (8-way connectivity).\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n                    \n    return objects\n\ndef count_holes(grid, object_pixels, background_color):\n    \"\"\"Counts the number of holes (enclosed background regions) within an object.\"\"\"\n    height, width = grid.shape\n    if not object_pixels:\n        return 0\n\n    min_r, min_c, max_r, max_c = get_bounding_box(object_pixels)\n\n    # Create a temporary grid for flood fill, slightly larger if possible, or use boundary checks\n    # Use a copy of the relevant part of the grid + padding logic\n    # We can flood fill from the *outer* background area and see what internal background pixels remain untouched\n\n    # Let's use a different approach: flood fill *within* the bounding box\n    # and identify background components that don't reach the edge.\n\n    # Create a temporary grid representing the bounding box area\n    bb_height = max_r - min_r + 1\n    bb_width = max_c - min_c + 1\n    temp_grid = np.full((bb_height, bb_width), -1) # -1 indicates unvisited/non-background\n\n    obj_pixels_relative = set((r - min_r, c - min_c) for r, c in object_pixels)\n\n    for r in range(bb_height):\n        for c in range(bb_width):\n            if (r, c) not in obj_pixels_relative:\n                # Check original grid color corresponding to this relative position\n                orig_r, orig_c = r + min_r, c + min_c\n                if grid[orig_r, orig_c] == background_color:\n                    temp_grid[r, c] = background_color # Mark background pixels in temp grid\n\n    visited_holes = np.zeros_like(temp_grid, dtype=bool)\n    hole_count = 0\n\n    for r in range(bb_height):\n        for c in range(bb_width):\n            # If it's a background pixel in the temp_grid and not visited yet\n            if temp_grid[r, c] == background_color and not visited_holes[r, c]:\n                is_hole = True\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited_holes[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n\n                    # Check if this component touches the bounding box edge\n                    if row == 0 or row == bb_height - 1 or col == 0 or col == bb_width - 1:\n                       # Need to check if this edge point corresponds to an *external* background pixel\n                       # i.e. not blocked by the object itself extending to the bbox edge there.\n                       # Let's refine: Flood fill from outside first is better.\n\n                       pass # Placeholder - this approach needs more careful edge handling.\n\n    # --- Let's switch to the flood fill from outside approach ---\n\n    flood_fill_grid = np.copy(grid)\n    q = deque()\n    visited_flood = np.zeros_like(grid, dtype=bool)\n\n    # Add all background pixels on the border to the queue\n    for r in range(height):\n        if flood_fill_grid[r, 0] == background_color and not visited_flood[r, 0]:\n             q.append((r, 0))\n             visited_flood[r, 0] = True\n        if flood_fill_grid[r, width-1] == background_color and not visited_flood[r, width-1]:\n             q.append((r, width-1))\n             visited_flood[r, width-1] = True\n    for c in range(width):\n        if flood_fill_grid[0, c] == background_color and not visited_flood[0, c]:\n            q.append((0, c))\n            visited_flood[0, c] = True\n        if flood_fill_grid[height-1, c] == background_color and not visited_flood[height-1, c]:\n            q.append((height-1, c))\n            visited_flood[height-1, c] = True\n            \n    # Also check pixels adjacent *to* the object pixels, if they are background\n    # This handles cases where the object itself doesn't touch the border\n    for orow, ocol in object_pixels:\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                 # 4-way check is sufficient for background connectivity for flood fill\n                 if abs(dr) + abs(dc) != 1: continue \n                 nr, nc = orow + dr, ocol + dc\n                 if 0 <= nr < height and 0 <= nc < width and \\\n                    flood_fill_grid[nr, nc] == background_color and \\\n                    not visited_flood[nr, nc] and \\\n                    (nr < min_r or nr > max_r or nc < min_c or nc > max_c): # Ensure it's outside BB\n                     q.append((nr, nc))\n                     visited_flood[nr, nc] = True\n\n    # Perform flood fill for external background\n    EXTERNAL_BG_MARKER = -2\n    while q:\n        r, c = q.popleft()\n        flood_fill_grid[r,c] = EXTERNAL_BG_MARKER # Mark as externally connected bg\n\n        # Check 4 neighbors (sufficient for region filling)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width and \\\n               not visited_flood[nr, nc] and \\\n               flood_fill_grid[nr, nc] == background_color: # Must be original background color\n                visited_flood[nr, nc] = True\n                q.append((nr, nc))\n\n    # Now count connected components of remaining background pixels *within* the bounding box\n    hole_count = 0\n    visited_holes_final = np.zeros_like(grid, dtype=bool)\n\n    for r_obj, c_obj in object_pixels: # Iterate near the object\n         for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0: continue\n                r, c = r_obj + dr, c_obj + dc\n\n                if 0 <= r < height and 0 <= c < width and \\\n                   flood_fill_grid[r, c] == background_color and \\\n                   not visited_holes_final[r,c]:\n                    # Found a potential start of a hole, do BFS to find the component\n                    hole_count += 1\n                    q_hole = deque([(r,c)])\n                    visited_holes_final[r, c] = True\n                    while q_hole:\n                        hr, hc = q_hole.popleft()\n                        # Use 4-way connectivity for hole components\n                        for hdr, hdc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nhr, nhc = hr + hdr, hc + hdc\n                            if 0 <= nhr < height and 0 <= nhc < width and \\\n                               flood_fill_grid[nhr, nhc] == background_color and \\\n                               not visited_holes_final[nhr, nhc]:\n                                visited_holes_final[nhr, nhc] = True\n                                q_hole.append((nhr, nhc))\n    return hole_count\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on selecting an object with 1 or 2 holes\n    and extracting its bounding box. Tie-breaking based on color difference.\n    \"\"\"\n    # Convert input list of lists to a NumPy array\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Handle empty grid case\n    if grid.size == 0:\n        return []\n\n    # Step 1: Find background color\n    counts = Counter(grid.flatten())\n    # Handle case where grid might be uniform\n    if not counts: return [] # Or return input? Assume non-empty based on task format.\n    background_color = counts.most_common(1)[0][0]\n    \n    # If grid is uniform background color, what should happen?\n    # Based on examples, there's always at least one non-background object.\n    # If only one color exists, find_objects will return empty.\n    \n    # Step 2: Find objects\n    objects = find_objects(grid, background_color)\n    if not objects:\n        # Or maybe return empty grid? Depending on requirement for uniform grids.\n        # Let's assume valid inputs always have distinct objects per examples.\n         return [] # Or maybe raise ValueError(\"No objects found\")\n\n    # Step 3 & 4: Calculate holes and filter objects\n    candidate_objects = []\n    for obj in objects:\n        num_holes = count_holes(grid, obj['pixels'], background_color)\n        if num_holes == 1 or num_holes == 2:\n            obj['holes'] = num_holes\n            candidate_objects.append(obj)\n\n    # Step 5: Select the target object\n    if not candidate_objects:\n        # This case shouldn't happen based on the training examples provided.\n        # If it could, we need a defined behavior. Returning empty list for now.\n        print(\"Warning: No objects found with 1 or 2 holes.\")\n        return []\n\n    selected_object = None\n    if len(candidate_objects) == 1:\n        selected_object = candidate_objects[0]\n    else:\n        # Tie-breaking: minimum absolute color difference from background\n        min_diff = float('inf')\n        best_obj = None\n        for obj in candidate_objects:\n            diff = abs(obj['color'] - background_color)\n            if diff < min_diff:\n                min_diff = diff\n                best_obj = obj\n            # Note: The problem description doesn't specify tie-breaking if *differences* are equal.\n            # We implicitly take the first one encountered with the minimum difference.\n        selected_object = best_obj\n\n    if selected_object is None:\n         # Should not happen if candidate_objects is not empty\n         print(\"Error: Failed to select an object.\")\n         return []\n\n    # Step 6: Determine the bounding box of the selected object\n    min_r, min_c, max_r, max_c = get_bounding_box(selected_object['pixels'])\n\n    # Step 7: Create the output grid by extracting the bounding box content\n    output_grid_np = grid[min_r:max_r+1, min_c:max_c+1]\n\n    # Convert the resulting NumPy array back to a list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5337,
    "candidates_token_count": 3279,
    "total_token_count": 8616,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.069133,
  "retries": null
}