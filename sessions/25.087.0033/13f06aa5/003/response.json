{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nModifies a grid based on a uniquely occurring 'trigger' pixel (Azure, Red, or Magenta) and applies color-specific propagation patterns and border modifications.\n\n1.  **Identify Background Color:** Determine the most frequent pixel color in the input grid.\n2.  **Identify Trigger Pixel:** Find the unique pixel `(r, c)` whose color `C` is *not* the background color, appears exactly once in the grid, and is one of Azure (8), Red (2), or Magenta (6). If no such pixel exists, return the input grid.\n3.  **Initialize Output Grid:** Create a copy of the input grid.\n4.  **Apply Conditional Propagation:**\n    *   **If `C` is Azure (8) or Red (2):** Perform horizontal propagation from `(r, c)`.\n        *   Move right: For steps `i = 2, 4, 6,...`, check column `c+i`. If `c+i` is in bounds and the pixel at `(r, c+i-1)` in the *input* grid is the background color, set the output pixel `(r, c+i)` to `C`. Stop moving right if the column is out of bounds or the intermediate pixel `(r, c+i-1)` is not background.\n        *   Move left: For steps `i = 2, 4, 6,...`, check column `c-i`. If `c-i` is in bounds and the pixel at `(r, c-i+1)` in the *input* grid is the background color, set the output pixel `(r, c-i)` to `C`. Stop moving left if the column is out of bounds or the intermediate pixel `(r, c-i+1)` is not background.\n    *   **If `C` is Magenta (6):** Perform vertical (downward) propagation from `(r, c)`.\n        *   Move down: For steps `i = 2, 4, 6,...`, check row `r+i`. If `r+i` is in bounds and the pixel at `(r+i-1, c)` in the *input* grid is the background color, set the output pixel `(r+i, c)` to `C`. Stop moving down if the row is out of bounds or the intermediate pixel `(r+i-1, c)` is not background.\n5.  **Apply Border Modifications based on `C`:**\n    *   **If `C` is Azure (8):** Set the rightmost column to Azure (8), the top row to Blue (1), and the top-right corner pixel to White (0).\n    *   **If `C` is Red (2):** Set the leftmost column to Red (2), the top row to Green (3), and the top-left corner pixel to White (0).\n    *   **If `C` is Magenta (6):** Set the bottommost row to Magenta (6).\n6.  **Return Output:** Return the modified grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default to white for empty grid\n    return counts.most_common(1)[0][0]\n\ndef find_trigger_pixel_revised(grid, background_color):\n    \"\"\"\n    Finds the color and location of the pixel that appears exactly once,\n    is not the background color, and is one of {8, 2, 6}.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    trigger_candidates = []\n    trigger_colors_of_interest = {8, 2, 6} # Azure, Red, Magenta\n\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color and counts[color] == 1 and color in trigger_colors_of_interest:\n                trigger_candidates.append({'color': color, 'pos': (r, c)})\n\n    if len(trigger_candidates) == 1:\n        trigger = trigger_candidates[0]\n        return trigger['color'], trigger['pos'][0], trigger['pos'][1]\n    else:\n        # Handle cases where 0 or >1 triggers are found matching the criteria\n        # For this specific problem based on examples, we expect exactly one.\n        # If not found, signal failure.\n        return None, None, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Identify Trigger Pixel\n    trigger_color, trigger_r, trigger_c = find_trigger_pixel_revised(input_grid_np, background_color)\n\n    # If no valid trigger found, return the original grid\n    if trigger_color is None:\n        print(\"Warning: No valid trigger pixel (unique, non-bg, color 8/2/6) found.\")\n        return input_grid # Return original as per requirement\n\n    # 3. Initialize Output Grid\n    output_grid = np.copy(input_grid_np)\n\n    # 4. Apply Conditional Propagation\n    if trigger_color == 8 or trigger_color == 2: # Azure or Red -> Horizontal\n        # Rightward propagation\n        for i in range(2, width * 2, 2): # Iterate step size, ensure large enough range\n            check_c = trigger_c + i\n            intermediate_c = trigger_c + i - 1\n            if 0 <= check_c < width and 0 <= intermediate_c < width:\n                if input_grid_np[trigger_r, intermediate_c] == background_color:\n                    # Check if the target pixel isn't already the trigger color (avoid unnecessary change)\n                    # Although copy ensures start state, this is conceptually cleaner\n                    if output_grid[trigger_r, check_c] != trigger_color:\n                         output_grid[trigger_r, check_c] = trigger_color\n                else:\n                    break # Stop rightward propagation\n            else:\n                break # Stop if out of bounds\n\n        # Leftward propagation\n        for i in range(2, width * 2, 2): # Iterate step size\n            check_c = trigger_c - i\n            intermediate_c = trigger_c - i + 1\n            if 0 <= check_c < width and 0 <= intermediate_c < width:\n                 if input_grid_np[trigger_r, intermediate_c] == background_color:\n                     if output_grid[trigger_r, check_c] != trigger_color:\n                         output_grid[trigger_r, check_c] = trigger_color\n                 else:\n                     break # Stop leftward propagation\n            else:\n                 break # Stop if out of bounds\n\n    elif trigger_color == 6: # Magenta -> Vertical (Downward)\n        # Downward propagation\n        for i in range(2, height * 2, 2): # Iterate step size\n             check_r = trigger_r + i\n             intermediate_r = trigger_r + i - 1\n             if 0 <= check_r < height and 0 <= intermediate_r < height:\n                 if input_grid_np[intermediate_r, trigger_c] == background_color:\n                      if output_grid[check_r, trigger_c] != trigger_color:\n                         output_grid[check_r, trigger_c] = trigger_color\n                 else:\n                     break # Stop downward propagation\n             else:\n                  break # Stop if out of bounds\n\n    # 5. Apply Border Modifications\n    if trigger_color == 8: # Azure\n        # Set right column to Azure (8)\n        output_grid[:, width - 1] = 8\n        # Set top row to Blue (1)\n        output_grid[0, :] = 1\n        # Set top-right corner to White (0)\n        output_grid[0, width - 1] = 0\n    elif trigger_color == 2: # Red\n        # Set left column to Red (2)\n        output_grid[:, 0] = 2\n        # Set top row to Green (3)\n        output_grid[0, :] = 3\n         # Set top-left corner to White (0)\n        output_grid[0, 0] = 0\n    elif trigger_color == 6: # Magenta\n        # Set bottom row to Magenta (6)\n        output_grid[height - 1, :] = 6\n\n    # 6. Return Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14806,
    "candidates_token_count": 2055,
    "total_token_count": 16861,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.3775,
  "retries": null
}