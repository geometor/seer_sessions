{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nModifies a grid based on a unique 'trigger' pixel (Azure, Red, or Magenta) by applying color-specific propagation patterns and border modifications, including a conditional update to the row below the top border for Azure and Red triggers.\n\n1.  **Identify Background Color:** Determine the most frequent pixel color in the input grid.\n2.  **Identify Trigger Pixel:** Find the unique pixel `(trigger_r, trigger_c)` whose color `trigger_color` is one of Azure (8), Red (2), or Magenta (6), appears exactly once, and is not the background color. If no such pixel exists, return the original input grid.\n3.  **Initialize Output Grid:** Create a copy of the input grid.\n4.  **Apply Conditional Propagation:** Modify the output grid based on `trigger_color`:\n    *   **If `trigger_color` is Azure (8) or Red (2):** Perform horizontal propagation. Move left and right from `(trigger_r, trigger_c)` in steps of 2, painting the pixel `(trigger_r, trigger_c +/- i)` with `trigger_color` if the intermediate pixel `(trigger_r, trigger_c +/- (i-1))` in the *input* grid is the background color. Stop propagation in a direction if out of bounds or the intermediate pixel is not the background color.\n    *   **If `trigger_color` is Magenta (6):** Perform vertical (downward) propagation. Move down from `(trigger_r, trigger_c)` in steps of 2, painting the pixel `(trigger_r + i, trigger_c)` with `trigger_color` if the intermediate pixel `(trigger_r + i - 1, trigger_c)` in the *input* grid is the background color. Stop propagation if out of bounds or the intermediate pixel is not the background color.\n5.  **Apply Border Modifications:** Modify the borders of the output grid based on `trigger_color`. Let H be height and W be width.\n    *   **If `trigger_color` is Azure (8):**\n        *   Set rightmost column (`output_grid[:, W-1]`) to Azure (8).\n        *   Set top row (`output_grid[0, :]`) to Blue (1).\n        *   Set top-right corner (`output_grid[0, W-1]`) to White (0).\n        *   **Conditional Row 1 Update:** For each column `c`, if the pixel `input_grid[1, c]` was the background color AND Blue (1) exists anywhere in column `c` of the *input* grid (`input_grid[:, c]`), set `output_grid[1, c]` to Blue (1).\n    *   **If `trigger_color` is Red (2):**\n        *   Set leftmost column (`output_grid[:, 0]`) to Red (2).\n        *   Set top row (`output_grid[0, :]`) to Green (3).\n        *   Set top-left corner (`output_grid[0, 0]`) to White (0).\n        *   **Conditional Row 1 Update:** For each column `c`, if the pixel `input_grid[1, c]` was the background color AND Green (3) exists anywhere in column `c` of the *input* grid (`input_grid[:, c]`), set `output_grid[1, c]` to Green (3).\n    *   **If `trigger_color` is Magenta (6):**\n        *   Set bottommost row (`output_grid[H-1, :]`) to Magenta (6).\n6.  **Return Output:** Return the modified grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default to white for empty grid\n    # If there's a tie for the most frequent color, the behavior might be undefined by the problem.\n    # Let's assume Counter's behavior (returning one of the most frequent) is sufficient.\n    return counts.most_common(1)[0][0]\n\ndef find_trigger_pixel_revised(grid, background_color):\n    \"\"\"\n    Finds the color and location of the pixel that appears exactly once,\n    is not the background color, and is one of {8, 2, 6}.\n    Returns (trigger_color, trigger_r, trigger_c) or (None, None, None).\n    \"\"\"\n    counts = Counter(grid.flatten())\n    trigger_candidates = []\n    trigger_colors_of_interest = {8, 2, 6} # Azure, Red, Magenta\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if color is potential trigger: correct color set, not background, unique count\n            if color in trigger_colors_of_interest and \\\n               color != background_color and \\\n               counts[color] == 1:\n                trigger_candidates.append({'color': color, 'pos': (r, c)})\n\n    if len(trigger_candidates) == 1:\n        trigger = trigger_candidates[0]\n        return trigger['color'], trigger['pos'][0], trigger['pos'][1]\n    else:\n        # No unique trigger found matching criteria\n        return None, None, None\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Identify Trigger Pixel\n    trigger_color, trigger_r, trigger_c = find_trigger_pixel_revised(input_grid_np, background_color)\n\n    # If no valid trigger found, return the original grid\n    if trigger_color is None:\n        # print(\"Debug: No valid trigger pixel found. Returning original grid.\")\n        return input_grid # Return original list of lists\n\n    # 3. Initialize Output Grid\n    output_grid = np.copy(input_grid_np)\n\n    # 4. Apply Conditional Propagation\n    if trigger_color == 8 or trigger_color == 2: # Azure or Red -> Horizontal\n        # Rightward propagation\n        # Iterate step size i = 2, 4, 6...\n        for i in range(2, width * 2, 2):\n            prop_c = trigger_c + i\n            inter_c = trigger_c + i - 1\n            # Check bounds for propagated and intermediate positions\n            if 0 <= prop_c < width and 0 <= inter_c < width:\n                # Check if intermediate pixel in *input* grid is background\n                if input_grid_np[trigger_r, inter_c] == background_color:\n                    output_grid[trigger_r, prop_c] = trigger_color\n                else:\n                    break # Stop rightward propagation if intermediate is blocked\n            else:\n                break # Stop rightward propagation if out of bounds\n\n        # Leftward propagation\n        # Iterate step size i = 2, 4, 6...\n        for i in range(2, width * 2, 2):\n            prop_c = trigger_c - i\n            inter_c = trigger_c - i + 1\n            # Check bounds for propagated and intermediate positions\n            if 0 <= prop_c < width and 0 <= inter_c < width:\n                 # Check if intermediate pixel in *input* grid is background\n                 if input_grid_np[trigger_r, inter_c] == background_color:\n                     output_grid[trigger_r, prop_c] = trigger_color\n                 else:\n                     break # Stop leftward propagation if intermediate is blocked\n            else:\n                 break # Stop leftward propagation if out of bounds\n\n    elif trigger_color == 6: # Magenta -> Vertical (Downward)\n        # Downward propagation\n        # Iterate step size i = 2, 4, 6...\n        for i in range(2, height * 2, 2):\n             prop_r = trigger_r + i\n             inter_r = trigger_r + i - 1\n             # Check bounds for propagated and intermediate positions\n             if 0 <= prop_r < height and 0 <= inter_r < height:\n                 # Check if intermediate pixel in *input* grid is background\n                 if input_grid_np[inter_r, trigger_c] == background_color:\n                      output_grid[prop_r, trigger_c] = trigger_color\n                 else:\n                     break # Stop downward propagation if intermediate is blocked\n             else:\n                  break # Stop downward propagation if out of bounds\n\n    # 5. Apply Border Modifications\n    if trigger_color == 8: # Azure\n        border_color = 1 # Top row becomes Blue\n        # Set right column AFTER potential row 1 modifications affecting the last column\n        # Set top row AFTER potential row 1 modifications affecting the top row (though unlikely)\n        # Set top-right corner LAST to overwrite row/column changes\n\n        # Conditional Row 1 Update (Check based on INPUT grid)\n        if height > 1: # Only apply if row 1 exists\n            for c in range(width):\n                if input_grid_np[1, c] == background_color and border_color in input_grid_np[:, c]:\n                    output_grid[1, c] = border_color\n\n        # Apply basic border modifications\n        output_grid[:, width - 1] = 8  # Rightmost column -> Azure (8)\n        output_grid[0, :] = border_color  # Top row -> Blue (1)\n        output_grid[0, width - 1] = 0  # Top-right corner -> White (0)\n\n    elif trigger_color == 2: # Red\n        border_color = 3 # Top row becomes Green\n        # Set left column AFTER potential row 1 modifications affecting the first column\n        # Set top row AFTER potential row 1 modifications affecting the top row\n        # Set top-left corner LAST\n\n        # Conditional Row 1 Update (Check based on INPUT grid)\n        if height > 1: # Only apply if row 1 exists\n            for c in range(width):\n                if input_grid_np[1, c] == background_color and border_color in input_grid_np[:, c]:\n                    output_grid[1, c] = border_color\n\n        # Apply basic border modifications\n        output_grid[:, 0] = 2  # Leftmost column -> Red (2)\n        output_grid[0, :] = border_color  # Top row -> Green (3)\n        output_grid[0, 0] = 0  # Top-left corner -> White (0)\n\n    elif trigger_color == 6: # Magenta\n        # No conditional update for adjacent row observed\n        output_grid[height - 1, :] = 6 # Bottommost row -> Magenta (6)\n\n    # 6. Return Output\n    return output_grid.tolist() # Convert back to list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16731,
    "candidates_token_count": 2589,
    "total_token_count": 19320,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.215233,
  "retries": null
}