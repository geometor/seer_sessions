{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the largest contiguous red object (MainRedObject) in the input grid.\nIdentify all other smaller, contiguous, non-red, non-white objects (StampObjects).\nExtract the shape and color pattern of each StampObject relative to its bounding box.\nIdentify contiguous white areas (WhiteHoles) within the bounding box of the MainRedObject.\nFor each WhiteHole, find a StampObject with the exact same shape (set of relative pixel coordinates).\nIf a match is found, fill the WhiteHole in the MainRedObject area with the color pattern of the matching StampObject.\nThe final output is the modified MainRedObject area, cropped to its bounding box.\n\"\"\"\n\ndef find_objects(grid, colors_to_find=None, ignore_colors=None, connectivity=1):\n    \"\"\"\n    Finds contiguous objects of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): Set of colors to look for. If None, finds all colors not in ignore_colors.\n        ignore_colors (set, optional): Set of colors to ignore. Defaults to {0} (white).\n        connectivity (int): 1 for 4-way connectivity, 2 for 8-way connectivity.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'pixels': set of (row, col) tuples.\n              'color': the color of the object.\n              'bbox': tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    if ignore_colors is None:\n        ignore_colors = {0}\n        \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    if connectivity == 1:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 2:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 1 or 2\")\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if visited[r, c] or color in ignore_colors or (colors_to_find is not None and color not in colors_to_find):\n                continue\n\n            obj_pixels = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                curr_r, curr_c = q.popleft()\n                obj_pixels.add((curr_r, curr_c))\n                min_r = min(min_r, curr_r)\n                min_c = min(min_c, curr_c)\n                max_r = max(max_r, curr_r)\n                max_c = max(max_c, curr_c)\n\n                for dr, dc in deltas:\n                    nr, nc = curr_r + dr, curr_c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            objects.append({\n                'pixels': obj_pixels,\n                'color': color,\n                'bbox': (min_r, min_c, max_r, max_c)\n            })\n            \n    return objects\n\ndef get_relative_pattern(grid, pixels, bbox):\n    \"\"\"Calculates the shape (relative coords) and pattern (relative coords -> color).\"\"\"\n    min_r, min_c, _, _ = bbox\n    shape = frozenset((r - min_r, c - min_c) for r, c in pixels)\n    pattern = {(r - min_r, c - min_c): grid[r, c] for r, c in pixels}\n    return shape, pattern\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described rules.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    rows, cols = input_arr.shape\n    \n    # 1. Find the largest contiguous red object (MainRedObject)\n    red_objects = find_objects(input_arr, colors_to_find={2})\n    if not red_objects:\n        # Handle case where no red object is found (return empty or original?)\n        # Based on examples, seems like a red object is always present.\n        # Let's assume an error or return empty grid for now.\n        return [] \n        \n    main_red_object = max(red_objects, key=lambda obj: len(obj['pixels']))\n    main_bbox = main_red_object['bbox']\n    min_r, min_c, max_r, max_c = main_bbox\n    \n    # 2. Create the initial output grid by copying the MainRedObject area\n    output_arr = input_arr[min_r:max_r+1, min_c:max_c+1].copy()\n    out_rows, out_cols = output_arr.shape\n\n    # 3. Find all StampObjects (non-red, non-white) in the *input* grid\n    # We ignore the main red object pixels during search to avoid including parts of it if stamps touch it.\n    temp_input_arr = input_arr.copy()\n    for r, c in main_red_object['pixels']:\n         temp_input_arr[r,c] = -1 # Mark red object pixels as temporary ignore value\n         \n    stamp_objects_raw = find_objects(temp_input_arr, ignore_colors={0, 2, -1}) # Ignore white, red, and marked pixels\n    \n    # 4. Extract shapes and patterns of StampObjects\n    stamp_patterns = {}\n    for stamp in stamp_objects_raw:\n        shape, pattern = get_relative_pattern(input_arr, stamp['pixels'], stamp['bbox']) # Use original grid for colors\n        # If multiple stamps have the same shape, the last one found will overwrite previous ones.\n        # This seems acceptable based on the task description.\n        stamp_patterns[shape] = pattern \n\n    # 5. Identify WhiteHoles within the *output* grid (cropped MainRedObject area)\n    hole_objects = find_objects(output_arr, colors_to_find={0}, ignore_colors=None) # Find white objects in the cropped area\n\n    # 6. Match WhiteHoles to StampObjects by shape and fill\n    for hole in hole_objects:\n        hole_min_r, hole_min_c, _, _ = hole['bbox'] # Bbox relative to output_arr\n        \n        # Calculate the shape of the hole relative to its own bounding box\n        hole_shape = frozenset((r - hole_min_r, c - hole_min_c) for r, c in hole['pixels'])\n\n        # 7. Check if a StampObject matches the hole shape\n        if hole_shape in stamp_patterns:\n            matched_pattern = stamp_patterns[hole_shape]\n            \n            # 8. Fill the hole in the output grid using the matched pattern\n            for (dr, dc), color in matched_pattern.items():\n                # Coordinates are relative to the stamp's bbox, which matches the hole's bbox\n                out_r, out_c = hole_min_r + dr, hole_min_c + dc\n                # Ensure coordinates are within the bounds of the output array\n                if 0 <= out_r < out_rows and 0 <= out_c < out_cols:\n                    # Check if the target pixel is actually part of the hole we are filling\n                    # This prevents accidentally overwriting parts of the red frame if the stamp\n                    # pattern's bounding box extends beyond the hole pixels.\n                    if output_arr[out_r, out_c] == 0 and (out_r, out_c) in hole['pixels']:\n                         output_arr[out_r, out_c] = color\n\n    # Convert the final numpy array back to a list of lists\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4736,
    "candidates_token_count": 1975,
    "total_token_count": 6711,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.23216,
  "retries": null
}