{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify Objects: Divide the input grid into distinct objects, where each object is a contiguous region of pixels of the same color.\n2. Find Border Pixels: For each object, identify its border pixels. In this case, a border pixel is defined as a pixel within the object that has a horizontal neighbor (left or right) *that is part of a different object or the edge of the grid*.\n3. Determine Trigger and Insert Colors: From the training set inputs and outputs, locate pairs of pixels that are horizontally adjacent. One pixel from each pair will be the *trigger*, and the other will be the *insert*. Record all unique trigger, insert pairs.\n4. Conditional Insertion:\n    * Iterate through all trigger, insert color pairs found in step 3.\n    * Locate the border pixels of each object in the input_grid.\n    * If a border pixel is a trigger color, check its immediate horizontal neighbors.\n        *  If a horizontal neighbor is not the same as either the *trigger* or *insert* color, change that neighboring pixel's color to the *insert* color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"Finds all contiguous objects in a grid.\"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    def bfs(r, c, color):\n        \"\"\"Performs breadth-first search to find contiguous pixels of the same color.\"\"\"\n        obj = []\n        queue = deque([(r, c)])\n        visited.add((r, c))\n\n        while queue:\n            row, col = queue.popleft()\n            obj.append((row, col))\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr, nc] == color:\n                    queue.append((nr, nc))\n                    visited.add((nr, nc))\n        return obj\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                obj = bfs(r, c, grid[r, c])\n                objects.append(obj)\n    return objects\n\ndef find_horizontal_border_pixels(grid, object_pixels):\n    \"\"\"Finds border pixels with horizontal neighbors of a different color.\"\"\"\n    border_pixels = []\n    rows, cols = grid.shape\n    for r, c in object_pixels:\n        # Check left neighbor\n        if c > 0 and grid[r, c - 1] != grid[r, c]:\n            border_pixels.append((r, c))\n            continue  # Avoid double-counting\n        # Check right neighbor\n        if c < cols - 1 and grid[r, c + 1] != grid[r, c]:\n            border_pixels.append((r, c))\n    return border_pixels\n\ndef get_trigger_insert_pairs(input_grid, output_grid):\n    \"\"\"\n    Identifies pairs of (trigger_color, insert_color) based on horizontal adjacency\n    changes between the input and output grids.\n    \"\"\"\n\n    rows, cols = input_grid.shape\n    pairs = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check right neighbor\n            if c < cols - 1:\n                if input_grid[r,c] != output_grid[r,c] or input_grid[r, c+1] != output_grid[r,c+1]:\n                    # something changed here\n                    if input_grid[r,c] != input_grid[r,c+1]:\n                        # different colors\n                        if input_grid[r,c] == output_grid[r,c] and input_grid[r,c+1] != output_grid[r,c+1]:\n                            # right changed\n                            pairs.add( (input_grid[r,c], output_grid[r,c+1]) )\n                        if input_grid[r,c+1] == output_grid[r,c+1] and input_grid[r,c] != output_grid[r,c]:\n                            # left changed\n                            pairs.add( (input_grid[r,c+1], output_grid[r,c]))\n\n    return pairs\n\ndef transform(input_grid, input_grid_2=None, output_grid_2=None): # Added extra example grids\n    \"\"\"Transforms the input grid according to the described rule.\"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Find Objects\n    objects = find_objects(input_grid)\n\n    # 2. Determine Trigger-Insert Pairs (using both examples)\n    trigger_insert_pairs = get_trigger_insert_pairs(input_grid, output_grid)\n    if input_grid_2 is not None and output_grid_2 is not None:\n         pairs2 = get_trigger_insert_pairs(input_grid_2, output_grid_2)\n         trigger_insert_pairs = trigger_insert_pairs.union(pairs2)\n\n    # 3. Iterate and apply transformations\n    for obj in objects:\n        # 3a. Find Horizontal Border Pixels\n        border_pixels = find_horizontal_border_pixels(input_grid, obj)\n\n        # 3b. Apply insertion rules\n        for trigger_color, insert_color in trigger_insert_pairs:\n            for r, c in border_pixels:\n                if input_grid[r, c] == trigger_color:\n                    # Check left neighbor\n                    if c > 0 and input_grid[r, c - 1] != trigger_color and input_grid[r, c - 1] != insert_color:\n                        output_grid[r, c - 1] = insert_color\n                    # Check right neighbor\n                    if c < cols - 1 and input_grid[r, c + 1] != trigger_color and input_grid[r, c + 1] != insert_color:\n                        output_grid[r, c + 1] = insert_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3771,
    "candidates_token_count": 1449,
    "total_token_count": 5220,
    "cached_content_token_count": 0
  },
  "response_time": 14.065352,
  "response_file": "010-response.json"
}