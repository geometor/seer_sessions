{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Examine the input grid and identify all contiguous regions of the same color as distinct objects.\n2.  **Targeted Color Removal:** Remove *all* objects of a specific color, with exceptions based on the structure and location of the objects.\n    *   If the *targeted* color is yellow (4), remove all yellow (4) objects.\n    *   If the *targeted* color is magenta (6), remove all magenta (6) objects.\n    *   If the *targeted* color is blue (1):\n        *   Keep blue (1) objects if they form a contiguous region at the top of the grid.\n        *   Remove all other blue (1) objects.\n3.  **Output:** Create an output grid of the same dimensions as the input, containing only the objects not removed in the previous step. All other pixels should be black (0).\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\ndef find_objects(grid: np.ndarray) -> List[Tuple[int, List[Tuple[int, int]]]]:\n    \"\"\"\n    Identifies contiguous objects of the same color in a grid.\n\n    Args:\n        grid: A 2D numpy array representing the grid.\n\n    Returns:\n        A list of tuples.  Each tuple contains:\n          - The color of the object.\n          - A list of (row, col) coordinates representing the object's pixels.\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(row, col, color, object_pixels):\n        if (row, col) in visited or not (0 <= row < rows and 0 <= col < cols) or grid[row, col] != color:\n            return\n        visited.add((row, col))\n        object_pixels.append((row, col))\n        dfs(row + 1, col, color, object_pixels)\n        dfs(row - 1, col, color, object_pixels)\n        dfs(row, col + 1, color, object_pixels)\n        dfs(row, col - 1, color, object_pixels)\n\n    for row in range(rows):\n        for col in range(cols):\n            if (row, col) not in visited and grid[row, col] != 0:\n                color = grid[row, col]\n                object_pixels = []\n                dfs(row, col, color, object_pixels)\n                objects.append((color, object_pixels))\n    return objects\n\ndef get_target_color(grid: np.ndarray, objects:List[Tuple[int, List[Tuple[int, int]]]]) -> int:\n    \"\"\"\n    Determines target color for removal - most common non-black color.\n    Handles edge cases of 0 and single non-black color cases.\n\n    Args:\n        grid: grid to analyze.\n        objects: object list, as produced by find_objects\n\n    Returns:\n        Target color integer, 0 if no target is found\n    \"\"\"\n    color_counts = {}\n    rows, cols = grid.shape\n    \n    # edge cases:\n    # all black\n    if len(objects) == 0:\n        return 0\n\n    # single color, other than black\n    colors = set([color for color, _ in objects])\n    if len(colors) == 1:\n        return colors.pop()\n    \n    # multiple colors - find most common\n    for color, pixels in objects:\n        if color != 0:  # Exclude black\n            color_counts[color] = color_counts.get(color, 0) + len(pixels)\n    \n    if not color_counts: # only black\n        return 0\n    \n    return max(color_counts, key=color_counts.get)\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid according to the rules.\n    \"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    output_grid = np.zeros_like(grid)\n\n    # Find objects\n    objects = find_objects(grid)\n    \n    # Determine target color - most common non-black\n    target_color = get_target_color(grid, objects)\n    \n    # special case for blue (1)\n    if target_color == 1:\n        for color, pixels in objects:\n            if color == 1:\n                # check contiguity and top location\n                contiguous_top = False\n                if pixels:\n                    min_row = min(row for row, _ in pixels)\n                    # consider top if any part of object is at top\n                    if min_row == 0:\n                        # build grid to use find_objects to check contiguity\n                        temp_grid = np.zeros_like(grid)\n                        for r, c in pixels:\n                            temp_grid[r,c] = 1\n                        blue_objects = find_objects(temp_grid)\n                        # if only one object, it's contigious!\n                        if len(blue_objects) == 1:\n                            contiguous_top = True\n\n                if contiguous_top:  # keep object\n                    for row, col in pixels:\n                         output_grid[row, col] = color\n            # all other colors copied to output\n            elif color != 0:\n                for row, col in pixels:\n                    output_grid[row, col] = color\n    else: # not blue\n        for color, pixels in objects:\n            if color != target_color and color != 0:  # Keep if not target color and not black\n                for row, col in pixels:\n                    output_grid[row, col] = color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7453,
    "candidates_token_count": 1324,
    "total_token_count": 8777,
    "cached_content_token_count": 0
  },
  "response_time": 14.105598,
  "response_file": "005-response.json"
}