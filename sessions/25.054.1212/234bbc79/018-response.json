{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify and Preserve Horizontal Lines:** Find any horizontal, contiguous lines of color 2 or color 6 pixels on row 1 (second row). These lines, and their positions, remain unchanged in the output grid.\n2.  **Remove Gray Pixels in Row 0:** All pixels of color 5 in the first row (row index 0) are removed, which may affect the width of the grid.\n3.  **Process Gray Pixels in Row 1:** For any gray pixels (color 5) in the second row (row index 1), replace them based on adjacency with the following:\n\n    *   If adjacent to a color 1 or 2, change to that color. If adjacent to BOTH, prioritize the color to the *right*.\n    *   Propagate the replacement from right to left.\n4.  **Process Gray Pixels in Row 2:** For any gray pixels (color 5) in the third row (row index 2):\n\n    *   If adjacent to a color 3 or 8, change to that color. If adjacent to BOTH, prioritize the color to the *right*.\n    *   Propagate the replacement from right to left.\n5. The height of the grid is always 3.\n\"\"\"\n\nimport numpy as np\n\ndef get_horizontal_lines(grid, row_index, colors):\n    \"\"\"\n    Finds horizontal lines of specified colors in a given row.\n\n    Args:\n        grid: The input grid (numpy array).\n        row_index: The index of the row to search.\n        colors: A list of colors to search for.\n\n    Returns:\n        A list of tuples, where each tuple represents a horizontal line\n        and contains (start_column, end_column, color).\n    \"\"\"\n    lines = []\n    rows, cols = grid.shape\n    if row_index >= rows:\n        return lines\n\n    in_line = False\n    start_col = -1\n    current_color = -1\n\n    for c in range(cols):\n        if grid[row_index, c] in colors:\n            if not in_line:\n                in_line = True\n                start_col = c\n                current_color = grid[row_index, c]\n            elif grid[row_index,c] != current_color:\n                # color changed within the line\n                lines.append( (start_col, c-1, current_color) )\n                start_col = c\n                current_color = grid[row_index,c]\n\n        elif in_line:\n            lines.append((start_col, c - 1, current_color))\n            in_line = False\n\n    if in_line:\n        lines.append((start_col, cols - 1, current_color))\n\n    return lines\ndef transform(input_grid):\n    # initialize output_grid\n    rows, cols = input_grid.shape\n    output_grid = np.zeros((3,0), dtype=int)\n\n\n    # 1. Identify and Preserve Horizontal Lines (Row 1)\n    horizontal_lines = get_horizontal_lines(input_grid, 1, [2, 6])\n    preserved_cols = []\n    for start_col, end_col, color in horizontal_lines:\n        segment = input_grid[1, start_col:end_col+1]\n        output_grid = np.concatenate((output_grid, np.array([[0]*(end_col-start_col+1),[color]*(end_col-start_col+1),[0]*(end_col-start_col+1))), axis=1)\n        preserved_cols.extend(range(start_col, end_col+1))\n\n    # build a temporary grid for processing, removing the columns that are part\n    # of the horizontal lines, so we do not overwrite\n    temp_grid = np.copy(input_grid)\n\n    # 2. Remove Gray Pixels in Row 0 and build new temporary grid\n    temp_cols = []\n    for c in range(cols):\n        if c not in preserved_cols:\n            if temp_grid[0,c] != 5:\n                temp_cols.append(c)\n        else:\n            temp_cols.append(c)\n\n    temp_grid_filtered = temp_grid[:, temp_cols]\n\n    # 3 & 4: Process the filtered data\n    rows_temp, cols_temp = temp_grid_filtered.shape\n    new_temp_grid = np.copy(temp_grid_filtered)\n\n    for r in range(rows_temp):\n        for c in range(cols_temp -1, -1, -1): # right to left\n            if new_temp_grid[r,c] == 5:\n                if r == 1:\n                    if c < cols_temp - 1 and new_temp_grid[r,c+1] in [1,2]:\n                        new_temp_grid[r,c] = new_temp_grid[r,c+1]\n                    elif c > 0 and new_temp_grid[r,c-1] in [1,2]:\n                        new_temp_grid[r,c] = new_temp_grid[r,c-1]\n                    else:\n                         new_temp_grid[r,c] = 0 # default\n                if r == 2:\n                    if c < cols_temp - 1 and new_temp_grid[r,c+1] in [3,8]:\n                        new_temp_grid[r,c] = new_temp_grid[r,c+1]\n                    elif c > 0 and new_temp_grid[r,c-1] in [3,8]:\n                        new_temp_grid[r,c] = new_temp_grid[r,c-1]\n                    else:\n                         new_temp_grid[r,c] = 0\n\n    # merge the new temp grid with the output grid\n    output_rows, output_cols = output_grid.shape\n    temp_rows, temp_cols = new_temp_grid.shape\n    final_output = np.zeros((3,0), dtype=int)\n    temp_idx = 0\n    out_idx = 0\n\n    for c in range(cols):\n        if c in preserved_cols: # part of preserved line\n            # search output grid to insert\n            found = False\n            for ec in range(output_cols):\n                if output_grid[1,ec] == input_grid[1,c] and not found:\n                    final_output = np.concatenate( (final_output, output_grid[:, ec:ec+1]), axis=1 )\n                    found = True\n\n        elif temp_idx < temp_cols and temp_grid_filtered[0,temp_idx] == input_grid[0,c] \\\n             and temp_grid_filtered[1, temp_idx] == input_grid[1,c] \\\n             and temp_grid_filtered[2, temp_idx] == input_grid[2,c]:\n            final_output = np.concatenate((final_output, new_temp_grid[:, temp_idx:temp_idx+1]), axis=1)\n            temp_idx += 1\n\n    return final_output\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4170,
    "candidates_token_count": 1660,
    "total_token_count": 5830,
    "cached_content_token_count": 0
  },
  "response_time": 14.24313,
  "response_file": "018-response.json"
}