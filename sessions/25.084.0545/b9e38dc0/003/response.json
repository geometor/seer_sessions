{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Global Color Mapping:**\n    *   Examine all input/output pairs.\n    *   Create a dictionary mapping each input color to its corresponding output color. If a color remains unchanged, that mapping does not need to be stored.\n\n2.  **Apply Color Map:** Iterate through all cells of the input grid, replace the colors with their mapped values as determined in step 1\n\n3.  **(Modified) Interior Object Identification:**\n *   Identify \"interior objects,\" which are contiguous regions of the *same color*, not on the border of the grid.\n\n4.  **(Modified) Interior object Processing:**\n  * Check color change - check for change in color by comparing objects location in the input and output.\n  * Apply the change to the object in the working grid.\n\n5. **(Modified) Propagation:**\n    *   For each changed pixel within each interior object do:\n    *   Check adjacent cells (up, down, left, and right).\n    *   If an adjacent cell has the *original* color of the changed pixel (before color mapping), change the adjacent cell's color to the *new* color (after color mapping).\n    *   Continue this process recursively for all newly changed pixels, forming \"chains\" of color changes. This is similar to a flood-fill, but only triggered by interior object color changes and only propagating along connected components of the original color.\n\"\"\"\n\nimport numpy as np\n\n# Global variables to store training data.\ntrain_inputs = []\ntrain_outputs = []\n\ndef calculate_color_mapping(inputs, outputs):\n    \"\"\"Calculates the color mapping between input and output grids.\"\"\"\n    color_mapping = {}\n    for input_grid, output_grid in zip(inputs, outputs):\n        input_grid = np.array(input_grid)\n        output_grid = np.array(output_grid)\n        for i in range(input_grid.shape[0]):\n            for j in range(input_grid.shape[1]):\n                input_val = input_grid[i, j]\n                output_val = output_grid[i, j]\n                if input_val != output_val:\n                    color_mapping[input_val] = output_val\n    return color_mapping\n\ndef find_interior_objects(grid):\n    \"\"\"Finds contiguous blocks of same-colored pixels not on the border.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    def is_interior(r, c):\n        \"\"\"Checks if a cell is within the interior of the grid.\"\"\"\n        return 0 < r < rows - 1 and 0 < c < cols - 1\n\n    def dfs(r, c, color, obj_coords):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (\n            r < 0\n            or r >= rows\n            or c < 0\n            or c >= cols\n            or visited[r, c]\n            or grid[r, c] != color\n            or not is_interior(r, c)\n        ):\n            return\n\n        visited[r, c] = True\n        obj_coords.append((r, c))\n        dfs(r + 1, c, color, obj_coords)\n        dfs(r - 1, c, color, obj_coords)\n        dfs(r, c + 1, color, obj_coords)\n        dfs(r, c - 1, color, obj_coords)\n\n    for r in range(1, rows - 1):\n        for c in range(1, cols - 1):\n            if not visited[r, c] and is_interior(r, c):\n                obj_coords = []\n                dfs(r, c, grid[r, c], obj_coords)\n                if obj_coords:\n                    objects.append((grid[r, c], obj_coords))\n    return objects\n\ndef propagate_changes(grid, changed_pixels, original_color_map):\n    \"\"\"\n    Propagates color changes horizontally and vertically, recursively.\n    Uses the original_color_map to check against pre-change colors.\n    \"\"\"\n    rows, cols = grid.shape\n    new_changes = set()\n    \n    while changed_pixels:\n        next_changed_pixels = set()\n        for r, c, old_color, new_color in changed_pixels:\n            # Check neighbors (up, down, left, right)\n            neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]\n            for nr, nc in neighbors:\n                if (0 <= nr < rows and 0 <= nc < cols and\n                        (nr, nc) not in new_changes and\n                        original_color_map.get(grid[nr,nc],grid[nr,nc]) == old_color\n                    ):\n                    grid[nr, nc] = new_color\n                    next_changed_pixels.add((nr, nc, old_color, new_color))\n                    new_changes.add( (nr,nc) ) # prevent infinite loops.\n        changed_pixels = next_changed_pixels\n    return\n\ndef transform(input_grid):\n    # Make copies to avoid modifying the input directly.\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    \n    # 1. Global Color Mapping\n    color_mapping = calculate_color_mapping(train_inputs, train_outputs)\n\n    # Create a reverse mapping for propagation\n    original_color_map = {v:k for k,v in color_mapping.items()}\n\n    # 2. Apply Color Map to entire grid\n    rows, cols = output_grid.shape\n    for r in range(rows):\n      for c in range(cols):\n        if output_grid[r,c] in color_mapping:\n          output_grid[r,c] = color_mapping[output_grid[r,c]]\n          \n    # 3. Interior Object Identification (after color mapping)\n    input_objects = find_interior_objects(output_grid)\n    \n    # 4. & 5. Interior object Processing and Propagation\n    changed_pixels = set()\n\n    for color, coords in input_objects:\n      first_coord = coords[0]\n\n      # check if interior object has color change\n      new_color = None\n      for train_input, train_output in zip(train_inputs, train_outputs):\n        train_input_grid = np.array(train_input)\n        train_output_grid = np.array(train_output)\n        # apply global map to input\n        for r in range(train_input_grid.shape[0]):\n            for c in range(train_input_grid.shape[1]):\n                if train_input_grid[r,c] in color_mapping:\n                    train_input_grid[r,c] = color_mapping[train_input_grid[r,c]]\n        # check if coord exists in this example\n        if (first_coord[0] < train_input_grid.shape[0] and\n              first_coord[1] < train_input_grid.shape[1] and\n              train_input_grid[first_coord] == color\n           ):\n             new_color = train_output_grid[first_coord]\n             break\n\n      # Propagate if needed\n      if new_color is not None and new_color != color:\n        for r, c in coords:\n            # find old color from the original input\n            old_color = original_color_map.get(color, color)\n            output_grid[r, c] = new_color  # Apply change to the object\n            changed_pixels.add((r, c, old_color, new_color))\n\n    propagate_changes(output_grid, changed_pixels, original_color_map)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15073,
    "candidates_token_count": 1824,
    "total_token_count": 16897,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 17.468032
}