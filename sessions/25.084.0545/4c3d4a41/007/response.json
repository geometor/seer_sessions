{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Find Top Boundary:** Locate the topmost horizontal line consisting entirely of gray (5) pixels. Record its row index.\n\n2.  **Find Bottom Boundaries:** For each column, find the row index of the highest gray (5) pixel that is *below* the top boundary. If a column has *no* gray pixel below the top boundary, the bottom boundary for that column is the row immediately below the top boundary.\n\n3.  **Identify Objects:** Scan the grid between the top and bottom boundaries (exclusive of the boundary rows themselves). Identify \"objects,\" which are contiguous groups of pixels of the same color, *excluding* white (0) and gray (5). Contiguous means adjacent horizontally, vertically, *or diagonally*.\n\n4. **Shift Objects Left:**\n   *   Iterate through all identified objects.\n   *   For *each* object:\n       *  Determine the leftmost available column within the object's *current* row. A column is \"available\" if it is within the boundaries for that column and contains a white (0) pixel.\n       * Move all pixels of the object to the leftmost available columns, maintaining the object's shape relative to its leftmost pixel, stopping when the object's pixels encounter any gray boundary pixel (left or vertical) or another object's pixel, defined as a non-white, non-gray pixel.\n\n5. **Output:** The result is the modified grid after all objects have been shifted.\n\"\"\"\n\nimport numpy as np\n\ndef find_top_boundary(grid):\n    \"\"\"Finds the row index of the top horizontal gray line.\"\"\"\n    for i, row in enumerate(grid):\n        if all(pixel == 5 for pixel in row):\n            return i\n    return -1  # Should not happen in valid input\n\ndef find_bottom_boundaries(grid, top_row):\n    \"\"\"Finds the bottom boundary row for each column.\"\"\"\n    rows, cols = grid.shape\n    bottom_boundaries = [-1] * cols\n\n    for c in range(cols):\n        for r in range(rows - 1, top_row, -1):\n            if grid[r, c] == 5:\n                bottom_boundaries[c] = r\n                break\n        if bottom_boundaries[c] == -1:\n            bottom_boundaries[c] = top_row + 1\n\n    return bottom_boundaries\n\ndef find_objects(grid, top_boundary, bottom_boundaries):\n    \"\"\"Identifies all objects within the specified boundaries.\"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, object_pixels):\n        stack = [(r, c)]\n        while stack:\n            curr_r, curr_c = stack.pop()\n            if (curr_r, curr_c) in visited:\n                continue\n            visited.add((curr_r, curr_c))\n\n            if (curr_r > top_boundary and curr_r < bottom_boundaries[curr_c] and\n                grid[curr_r, curr_c] == color):\n\n                object_pixels.append((curr_r, curr_c))\n\n                # Check all 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if is_valid(nr, nc):\n                            stack.append((nr, nc))\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != 0 and grid[r, c] != 5:\n                if r > top_boundary and r < bottom_boundaries[c]:\n                  object_pixels = []\n                  dfs(r, c, grid[r, c], object_pixels)\n                  if object_pixels:\n                      objects.append({'color': grid[r, c], 'pixels': object_pixels})\n    return objects\n\ndef shift_object_left(grid, object_pixels, top_boundary, bottom_boundaries):\n  \"\"\"Shifts a single object left within the boundaries.\"\"\"\n  output_grid = np.copy(grid)  # Work on a copy to avoid modifying original during iteration\n\n  # Find the leftmost pixel's column in the object\n  leftmost_col = min(c for _, c in object_pixels)\n  color = grid[object_pixels[0][0],object_pixels[0][1]] #get color from first pixel\n\n  # clear pixels\n  for r, c in object_pixels:\n      output_grid[r,c]=0\n\n  # Determine the target leftmost column\n  target_col = leftmost_col\n  for c in range(leftmost_col -1, -1, -1):\n    valid_move = True\n    for r, _ in object_pixels:\n        if not( r > top_boundary and r < bottom_boundaries[c] and output_grid[r,c] == 0):\n          valid_move = False\n          break\n    if valid_move:\n      target_col = c\n    else:\n      break\n\n  # Shift the object to the new position\n  for r, c in object_pixels:\n\n      new_c = target_col + (c - leftmost_col)\n      output_grid[r, new_c] = color\n\n\n  return output_grid\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Find Top Boundary\n    top_boundary = find_top_boundary(input_grid)\n\n    # 2. Find Bottom Boundaries\n    bottom_boundaries = find_bottom_boundaries(input_grid, top_boundary)\n\n    # 3. Identify Objects\n    objects = find_objects(input_grid, top_boundary, bottom_boundaries)\n\n    # 4. Shift Objects Left\n    for obj in objects:\n        output_grid = shift_object_left(output_grid, obj['pixels'], top_boundary, bottom_boundaries)\n\n    # 5. Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15535,
    "candidates_token_count": 1444,
    "total_token_count": 16979,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 19.448105
}