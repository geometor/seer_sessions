{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation involves a series of color expansions, with specific rules and order of operations for each color.\n\n1.  **Initial Setup:**\n    *   The input grid is the starting point.\n\n2.  **Ordered Expansions:** Apply the following expansions *in the specified order*:\n\n    a. **Top Half Expansions** (only consider the top half of grid)\n        *   If color `3` (green) is present, expand it upwards, overwriting `0` (white), and stopping at any other color.\n        *   If color `4` (yellow) is present, expand it upwards, overwriting `0` (white), and stopping at any other color.\n    b. **Bottom Half Expansions** (only consider the bottom half of the grid)\n        *    If colors `6` (magenta) and `7` (orange) are both present:\n            *   Expand color `6` (magenta), overwriting `0` and stop at any other color except 6.\n            *   Within the expanded `6` region, expand `7` (orange) overwriting `0` and `6`. Stop at any other color.\n        *   If only `7` (orange) is present (no `6`): Expand `7` overwriting `0` and stop at any other color.\n    c. **Global Expansions (consider the entire grid)**:\n       *  Expand color 5 (gray) to fill all areas where there are 0s.\n       * Expand color 6 (magenta), overwriting `0`, `3`, `4`, `5`, `7`, `8`, and `9`, stopping at `1` and `2`.\n       * Expand color `9` (maroon), overwriting `0`, `2`, and `4`, stopping at `1`, `3`.\n       * Expand color `3` (green) *only within the regions where color 5 (gray) was present* in the input. Color `3` overwrites `0` and `5` and stops at all others.\n\n3.  **Notes and Interactions:**\n\n    *   The order of expansions is *critical*.\n    *   \"Expand\" means to replace neighboring pixels of the specified \"overwrite\" colors with the expanding color.\n    *   \"Stopping at\" a color means the expansion does *not* replace that color.\n\"\"\"\n\nimport numpy as np\n\ndef find_regions(grid, color):\n    \"\"\"Finds contiguous regions of a given color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(row, col):\n        \"\"\"Depth-first search to find contiguous region.\"\"\"\n        if (row < 0 or row >= rows or col < 0 or col >= cols or\n                visited[row, col] or grid[row, col] != color):\n            return []\n\n        visited[row, col] = True\n        region = [(row, col)]\n\n        region.extend(dfs(row + 1, col))\n        region.extend(dfs(row - 1, col))\n        region.extend(dfs(row, col + 1))\n        region.extend(dfs(row, col - 1))\n        return region\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                regions.append(dfs(r, c))\n    return regions\n\ndef expand_region(grid, region, fill_color, overwrite_colors, stop_colors):\n    \"\"\"Expands a region, replacing specified colors and stopping at others.\"\"\"\n    expanded_region = set(region)\n    queue = region[:]\n    rows, cols = grid.shape\n\n    while queue:\n        row, col = queue.pop(0)\n        neighbors = [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\n        for nr, nc in neighbors:\n            if (0 <= nr < rows and 0 <= nc < cols and\n                (nr, nc) not in expanded_region):\n                pixel_color = grid[nr, nc]\n                if pixel_color in overwrite_colors:\n                    expanded_region.add((nr, nc))\n                    queue.append((nr, nc))\n                elif pixel_color in stop_colors:\n                    continue\n\n    return list(expanded_region)\n\ndef apply_transformation_pass(input_grid, anchor_color, fill_color, overwrite_colors, stop_colors, local_region=None):\n    \"\"\"Applies a single pass of the transformation, expanding from anchor color.\"\"\"\n    output_grid = np.copy(input_grid)\n    if local_region == \"top_half\":\n        grid_slice = output_grid[:output_grid.shape[0] // 2, :]\n    elif local_region == \"bottom_half\":\n        grid_slice = output_grid[output_grid.shape[0] // 2:, :]\n    else:\n        grid_slice = output_grid\n\n    anchor_regions = find_regions(grid_slice, anchor_color)\n\n    for region in anchor_regions:\n      expanded = expand_region(grid_slice, region, fill_color, overwrite_colors, stop_colors)\n      for r, c in expanded:\n          if local_region == \"top_half\":\n              output_grid[r,c] = fill_color #no offset needed\n          elif local_region == \"bottom_half\":\n              output_grid[r + output_grid.shape[0] // 2, c] = fill_color\n          else:\n            output_grid[r,c] = fill_color\n\n    return output_grid\n\ndef apply_masked_expansion(grid, fill_color, mask_color, overwrite_colors, stop_colors):\n     \"\"\"Expands fill_color within the mask, overwriting specified colors.\"\"\"\n     output_grid = np.copy(grid)\n     mask = (grid == mask_color)\n     regions = find_regions(grid, fill_color)\n\n     # Get initial regions of the mask color.\n     initial_mask_regions = find_regions(grid, mask_color)\n     initial_mask_coords = set()\n     for region in initial_mask_regions:\n          initial_mask_coords.update(region)\n\n\n     for region in regions:\n        expanded = expand_region(grid, region, fill_color, overwrite_colors, stop_colors)\n        for r, c in expanded:\n            # Only fill if the coordinate was originally part of the mask\n            if (r,c) in initial_mask_coords:\n                output_grid[r,c] = fill_color\n     return output_grid\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    initial_grid = np.copy(input_grid) # for masked expansion later\n\n    # 2. Ordered Expansions\n    # a. Top Half Expansions\n    output_grid = apply_transformation_pass(output_grid, 3, 3, [0], [1, 2, 4, 5, 6, 7, 8, 9], local_region=\"top_half\")\n    output_grid = apply_transformation_pass(output_grid, 4, 4, [0], [1, 2, 3, 5, 6, 7, 8, 9], local_region=\"top_half\")\n\n    # b. Bottom Half Expansions\n    if 6 in output_grid[rows // 2:, :] and 7 in output_grid[rows // 2:, :]:\n        output_grid = apply_transformation_pass(output_grid, 6, 6, [0], [1, 2, 3, 4, 5, 7, 8, 9], local_region=\"bottom_half\")\n        output_grid = apply_masked_expansion(output_grid, 7, 6, [0, 6], [1, 2, 3, 4, 5, 8, 9])\n    elif 7 in output_grid[rows // 2:, :]:\n         output_grid = apply_transformation_pass(output_grid, 7, 7, [0], [1, 2, 3, 4, 5, 6, 8, 9], local_region=\"bottom_half\")\n\n    # c. Global Expansions\n    output_grid = apply_transformation_pass(output_grid, 5, 5, [0], [1, 2, 3, 4, 6, 7, 8, 9])\n    output_grid = apply_transformation_pass(output_grid, 6, 6, [0, 3, 4, 5, 7, 8, 9], [1, 2])\n    output_grid = apply_transformation_pass(output_grid, 9, 9, [0, 2, 4], [1, 3]) #corrected overwrite colors\n    # Masked expansion of 3, using the *initial* grid's color 5 locations.\n    output_grid = apply_masked_expansion(initial_grid, 3, 5, [0, 5], [1, 2, 4, 6, 7, 8, 9])\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20878,
    "candidates_token_count": 2200,
    "total_token_count": 23078,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 26.513911
}