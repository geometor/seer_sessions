{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies objects in both input and output grids, maps them based on color, size, shape, and proximity, and then performs actions like move, transform (color/size/shape change), create, or delete to generate the output. The background color is preserved. Objects are sorted by size before mapping, largest first.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef calculate_object_bounds(pixels):\n    \"\"\"Calculate the bounding box of an object.\"\"\"\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    for r, c in pixels:\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n    return (min_r, min_c), (max_r, max_c)\n\ndef get_object_shape(pixels):\n   bounds = calculate_object_bounds(pixels)\n   height = bounds[1][0] - bounds[0][0] + 1\n   width = bounds[1][1] - bounds[0][1] + 1\n\n   if height == 1 or width == 1:\n      return \"line\"\n   if height == width:\n       return \"square\"\n   return \"rectangle\"\n\ndef find_objects(grid):\n    \"\"\"Identifies contiguous regions of the same color as distinct objects.\"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_id):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or visited[r, c] or grid[r, c] != color):\n            return []\n        visited[r, c] = True\n        region = [(r, c)]\n        region.extend(dfs(r + 1, c, color, obj_id))\n        region.extend(dfs(r - 1, c, color, obj_id))\n        region.extend(dfs(r, c + 1, color, obj_id))\n        region.extend(dfs(r, c - 1, color, obj_id))\n        return region\n\n    obj_id_counter = 0\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c]:\n                color = grid[r, c]\n                region = dfs(r, c, color, obj_id_counter)\n                if region:\n                    bounds = calculate_object_bounds(region)\n                    objects.append({\n                        \"id\": obj_id_counter,\n                        \"color\": color,\n                        \"pixels\": region,\n                        \"shape\": get_object_shape(region),\n                        \"size\": len(region),\n                        \"min_row\": bounds[0][0],\n                        \"min_col\": bounds[0][1],\n                        \"max_row\": bounds[1][0],\n                        \"max_col\": bounds[1][1],\n                    })\n                    obj_id_counter += 1\n    return objects\n\ndef get_background_color(grid):\n    \"\"\"Determines the background color.\"\"\"\n    return Counter(grid.flatten()).most_common(1)[0][0]\n\ndef calculate_distance(bounds1, bounds2):\n    \"\"\"Calculates the distance between the centers of two bounding boxes.\"\"\"\n    center1_r = (bounds1[0][0] + bounds1[1][0]) / 2\n    center1_c = (bounds1[0][1] + bounds1[1][1]) / 2\n    center2_r = (bounds2[0][0] + bounds2[1][0]) / 2\n    center2_c = (bounds2[0][1] + bounds2[1][1]) / 2\n    return np.sqrt((center1_r - center2_r)**2 + (center1_c - center2_c)**2)\n\ndef transform_object(output_grid, input_obj, output_obj):\n    \"\"\"Transforms an input object to match the output object.\"\"\"\n    # Clear the old pixels of the input object, respecting background\n    background_color = get_background_color(output_grid)\n    for r, c in input_obj['pixels']:\n        output_grid[r, c] = background_color\n    \n    # Calculate transformation parameters\n    dr = output_obj['min_row'] - input_obj['min_row']\n    dc = output_obj['min_col'] - input_obj['min_col']\n\n    # Apply transformation: move and change color/size if necessary\n    new_pixels = []\n    for r, c in input_obj['pixels']:\n        new_r = r + dr\n        new_c = c + dc\n        if 0 <= new_r < output_grid.shape[0] and 0 <= new_c < output_grid.shape[1]:\n            output_grid[new_r, new_c] = output_obj['color']\n            new_pixels.append((new_r, new_c))\n\n    \n    remaining_pixels = output_obj['size'] - len(new_pixels)\n    if remaining_pixels > 0:\n      # Create new pixels if output object is bigger\n       \n      r,c = new_pixels[-1] # start at the last placed pixel\n      \n      \n      for _ in range(remaining_pixels):\n        neighbors = [(r+1,c), (r-1, c), (r,c+1), (r, c-1)]\n        valid_neighbors = []\n        for nr, nc in neighbors:\n           if 0<= nr < output_grid.shape[0] and 0<= nc < output_grid.shape[1]:\n              valid_neighbors.append((nr,nc))\n        \n        if len(valid_neighbors) > 0:\n\n            r,c = valid_neighbors[0]\n            output_grid[r,c] = output_obj['color']\n            new_pixels.append((r,c))\n\n    elif remaining_pixels < 0:\n       # remove pixels if output obj is smaller\n        new_pixels = new_pixels[:output_obj['size']]\n        for r,c in new_pixels:\n           output_grid[r,c] = output_obj['color']\n\n    \n    input_obj['pixels'] = new_pixels\n    input_obj['color'] = output_obj['color'] # update to new color\n    input_obj['min_row'] = output_obj['min_row']\n    input_obj['min_col'] = output_obj['min_col']\n    input_obj['shape'] = get_object_shape(new_pixels)\n    input_obj['size'] = len(new_pixels)\n\n    return output_grid\n   \n\ndef create_object(output_grid, output_obj):\n\n   new_obj = {\n        'id': -1, # Placeholder ID, will be corrected later\n        'color': output_obj['color'],\n        'pixels': [],\n        'shape':output_obj['shape'],\n        'size': output_obj['size'],\n        'min_row': output_obj['min_row'],\n        'min_col': output_obj['min_col']\n    }\n   \n   r = output_obj['min_row']\n   c = output_obj['min_col']\n\n   for i in range(output_obj['size']):\n      if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n            output_grid[r, c] = output_obj['color']\n            new_obj['pixels'].append((r, c))\n      if output_obj['shape'] == 'line':\n         if output_obj['max_row'] > output_obj['min_row']:\n            r+=1\n         else:\n            c+=1\n      else:\n         c+=1 # make lines, and rectangles\n         if i > 0 and (i+1) % (output_obj['max_col'] - output_obj['min_col']+1) == 0 :\n            r+=1\n            c = output_obj['min_col']\n\n   new_obj['size'] = len(new_obj['pixels']) # update the object size\n\n   return output_grid, new_obj\n\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the identified rule.\"\"\"\n    input_grid = np.array(input_grid)\n    output_grid = np.copy(input_grid)\n    background_color = get_background_color(input_grid)\n\n    # Find objects in the input and output grids\n    input_objects = find_objects(input_grid)\n    output_objects = find_objects(output_grid)\n\n    # Sort objects by size (descending)\n    input_objects.sort(key=lambda obj: obj[\"size\"], reverse=True)\n    output_objects.sort(key=lambda obj: obj[\"size\"], reverse=True)\n    \n    \n    # Map output objects to input objects\n    matched_input_objects = []\n    created_objects = []\n\n    for output_obj in output_objects:\n        best_match = None\n        best_score = float('inf')\n\n        for input_obj in input_objects:\n            if input_obj in matched_input_objects:\n                continue  # Skip already matched input objects\n\n            # Calculate matching score\n            score = 0\n\n            # 1. Color match\n            if input_obj['color'] == output_obj['color']:\n                score -= 1  # Prefer color match (negative score for better match)\n\n            # 2. Size difference\n            score += abs(input_obj['size'] - output_obj['size'])\n\n            # 3. Shape\n            if input_obj['shape'] == output_obj['shape']:\n               score -=1\n\n            # 4. Distance between objects\n            input_bounds = calculate_object_bounds(input_obj['pixels'])\n            output_bounds = calculate_object_bounds(output_obj['pixels'])\n            score += calculate_distance(input_bounds, output_bounds)\n\n            if score < best_score:\n                best_score = score\n                best_match = input_obj\n\n        if best_match is not None:\n            # Transform the best matching object\n            output_grid = transform_object(output_grid, best_match, output_obj)\n            matched_input_objects.append(best_match)\n\n        else:\n            # Create a new object\n           \n            output_grid, new_obj = create_object(output_grid, output_obj)\n            if len(new_obj['pixels'])> 0:\n              created_objects.append(new_obj)\n    \n    # Correct the IDs of created objects\n    next_id = max([obj['id'] for obj in input_objects], default=-1) + 1\n    for obj in created_objects:\n      obj['id'] = next_id\n      next_id+=1\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27710,
    "candidates_token_count": 2601,
    "total_token_count": 30311,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 34.399435
}