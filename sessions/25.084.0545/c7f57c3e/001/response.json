{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies regions of uniform size (3x3, 1x3, or 3x1) within the input grid. \nWhen a change is detected in pixels adjacent to these regions in the output grid, it swaps the colors \nbetween the changed pixel group and a uniform region of matching size and changed pixel's color elsewhere on grid.\nThe background color is maintained throughout.\n\"\"\"\n\nimport numpy as np\n\ndef find_uniform_regions(grid):\n    \"\"\"Finds 3x3, 1x3, and 3x1 uniform regions in the grid.\"\"\"\n    rows, cols = grid.shape\n    uniform_regions = []\n\n    # Find 3x3 uniform regions\n    for r in range(rows - 2):\n        for c in range(cols - 2):\n            region = grid[r:r+3, c:c+3]\n            if np.all(region == region[0, 0]):\n                uniform_regions.append(((r, c), (3, 3)))\n\n    # Find 1x3 uniform regions\n    for r in range(rows):\n        for c in range(cols - 2):\n            region = grid[r, c:c+3]\n            if np.all(region == region[0]):\n                uniform_regions.append(((r, c), (1, 3)))\n\n    # Find 3x1 uniform regions\n    for r in range(rows - 2):\n        for c in range(cols):\n            region = grid[r:r+3, c]\n            if np.all(region == region[0]):\n                uniform_regions.append(((r, c), (3, 1)))\n\n    return uniform_regions\n\ndef find_changed_pixels(input_grid, output_grid):\n    \"\"\"Finds pixels that have changed between input and output grids.\"\"\"\n    return np.where(input_grid != output_grid)\n\ndef find_matching_region(grid, size, color):\n    \"\"\"Finds a uniform region of specified size and color.\"\"\"\n    rows, cols = grid.shape\n    h, w = size\n    for r in range(rows - h + 1):\n        for c in range(cols - w + 1):\n            region = grid[r:r+h, c:c+w]\n            if np.all(region == color):\n                return (r, c)\n    return None\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the identified rule.\"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    uniform_regions = find_uniform_regions(input_grid)\n    changed_pixels = find_changed_pixels(input_grid, output_grid)\n    changed_coords = list(zip(changed_pixels[0], changed_pixels[1]))\n    processed = []\n\n    for (r, c), (h, w) in uniform_regions:\n        if h==3 and w==3:\n            neighbors = []\n            if c + 3 < cols:\n               neighbors.extend([(r + i, c + 3) for i in range(3)])  # Right\n            if r + 3 < rows:\n               neighbors.extend([(r + 3, c + i) for i in range(3)]) # Bottom\n            if r > 0:\n               neighbors.extend([(r - 1, c + i) for i in range(3)])    # Top\n            if c > 0:\n                neighbors.extend([(r+i, c -1) for i in range(3)])   # Left\n        elif h == 3 and w == 1:\n             neighbors = []\n             if c + 1 < cols:\n                neighbors.append((r, c + 1)) #right\n                neighbors.append((r+1, c + 1))\n                neighbors.append((r+2, c + 1))\n\n             if r > 0:\n                neighbors.append((r - 1, c ))  # Top\n             if r + 3 < rows:\n                neighbors.append((r + 3, c))  # Bottom\n             if c > 0:\n                neighbors.append((r, c-1)) #left\n                neighbors.append((r+1, c - 1))\n                neighbors.append((r+2, c - 1))\n        elif h == 1 and w == 3:\n             neighbors = []\n             if r + 1 < rows:\n                neighbors.append((r+1, c))\n                neighbors.append((r+1, c+1))\n                neighbors.append((r+1, c+2))\n             if c + 3 < cols:\n                neighbors.append((r, c + 3))  # Right\n             if r > 0:\n                neighbors.append((r - 1, c)) # Top\n                neighbors.append((r - 1, c+1))\n                neighbors.append((r - 1, c+2))\n\n             if c > 0:\n                neighbors.append((r, c - 1))  # Left\n\n\n        for nr, nc in neighbors:\n             if (nr, nc) in changed_coords and (nr,nc) not in processed:\n                changed_color = output_grid[nr, nc]\n                original_color = input_grid[nr,nc]\n                if h==3 and w==3:\n                    changed_size = (1,1)\n                    \n                    \n                else:\n                    changed_size = (h,w)\n                \n                \n                if h==1 and w ==3:\n                  match_start = find_matching_region(output_grid, changed_size, changed_color)\n                  if match_start is not None:\n                    mr, mc = match_start\n                    \n                    output_grid[nr, nc] = original_color\n                    \n                    output_grid[mr:mr+1, mc:mc+3] = changed_color\n                    processed.append((nr,nc))\n                elif h==3 and w==1:\n                  match_start = find_matching_region(output_grid, changed_size, changed_color)\n\n                  if match_start is not None:\n                      mr, mc = match_start\n                      output_grid[nr, nc] = original_color\n                      output_grid[mr:mr+3, mc:mc+1] = changed_color\n                      processed.append((nr,nc))\n                else:\n                    \n                  match_start = find_matching_region(output_grid, (1,1), changed_color)\n                  if match_start is not None:\n                      mr, mc = match_start\n                      output_grid[mr, mc] = original_color\n                      output_grid[nr, nc] = changed_color\n                      processed.append((nr,nc))\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4423,
    "candidates_token_count": 1577,
    "total_token_count": 6000,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 18.680757
}