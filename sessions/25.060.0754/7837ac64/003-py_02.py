import numpy as np

def analyze_example(input_grid, output_grid):
    input_grid = np.array(input_grid)
    output_grid = np.array(output_grid)
    height, width = input_grid.shape
    num_unique_colors_input = len(np.unique(input_grid))
    num_unique_colors_output = len(np.unique(output_grid))
    output_height, output_width = output_grid.shape
    print(f"Input Grid: {height}x{width}, Unique Colors: {num_unique_colors_input}")
    print(f"Output Grid: {output_height}x{output_width}, Unique Colors: {num_unique_colors_output}")
    # simulate the find_repeating_pattern function
    pattern_counts = {}
    for r in range(height):
        row_pattern = tuple(input_grid[r])
        if row_pattern in pattern_counts:
            pattern_counts[row_pattern]['count'] += 1
        else:
            pattern_counts[row_pattern] = {'count': 1}
    print(f"Row Pattern Counts: {pattern_counts}")
    # determine the output from the transform function
    dominant_pattern = max(pattern_counts, key=lambda k: pattern_counts[k]['count'])
    print(f"Dominant Pattern: {dominant_pattern}")

    disruptions = []
    for r in range(height):
        for c in range(width):
            if tuple(input_grid[r]) != dominant_pattern:
                disruptions.append((r, c, input_grid[r, c]))
    print(f"Disruptions from Dominant Pattern: {disruptions}")

    predicted_output = transform(input_grid)  # use the provided transform function
    print(f"Predicted Output:\n{predicted_output}")
    print(f"Actual Output:\n{output_grid}")
    print(f"Match: {np.array_equal(predicted_output, output_grid)}")
    print("-" * 20)

# the datasets
train_data = [
    ([
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 0, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 0, 8, 8],
    ], [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]),
    ([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]),
    ([
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 0, 0, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
    ], [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]),
    ([
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ], [
       [0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]
    ]),
    ([
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
        [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
    ], [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ]),
    ([
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [8, 8, 8, 8, 8, 0, 8, 8],
        [8, 8, 8, 8, 8, 8, 8, 8]
    ],
    [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ])
]

for input_grid, output_grid in train_data:
    analyze_example(input_grid, output_grid)
