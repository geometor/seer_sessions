{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a red rectangle based on its spatial relationship with a multi-colored object. If a multi-colored object exists, the red rectangle that overlaps with its bounding box on the x and y axis is selected. Otherwise, the largest red rectangle is selected. The selected rectangle is preserved in the output grid, with all other pixels set to white.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n    Returns a list of bounding box tuples (start_row, start_col, end_row, end_col).\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def dfs(row, col):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (row < 0 or row >= grid.shape[0] or col < 0 or col >= grid.shape[1] or\n                visited[row, col] or grid[row, col] != color):\n            return []\n\n        visited[row, col] = True\n        region = [(row, col)]\n\n        region.extend(dfs(row + 1, col))\n        region.extend(dfs(row - 1, col))\n        region.extend(dfs(row, col + 1))\n        region.extend(dfs(row, col - 1))\n        return region\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if grid[row, col] == color and not visited[row, col]:\n                region = dfs(row, col)\n                if region:\n                    min_row = min(r[0] for r in region)\n                    max_row = max(r[0] for r in region)\n                    min_col = min(r[1] for r in region)\n                    max_col = max(r[1] for r in region)\n                    objects.append((min_row, min_col, max_row, max_col))\n    return objects\n\ndef find_largest_red_rectangle(grid):\n    \"\"\"\n    Finds the largest rectangle of red pixels within the grid.\n\n    Returns:\n        A tuple (start_row, start_col, end_row, end_col) defining the rectangle,\n        or None if no red pixels are found.\n    \"\"\"\n    red_pixels = np.argwhere(grid == 2)\n    if len(red_pixels) == 0:\n        return None\n\n    max_area = 0\n    best_rectangle = None\n\n    for start_row, start_col in red_pixels:\n        for end_row, end_col in red_pixels:\n            if end_row >= start_row and end_col >= start_col:\n                # Check if the rectangle is all red\n                sub_grid = grid[start_row:end_row+1, start_col:end_col+1]\n                if np.all(sub_grid == 2):\n                    area = (end_row - start_row + 1) * (end_col - start_col + 1)\n                    if area > max_area:\n                        max_area = area\n                        best_rectangle = (start_row, start_col, end_row, end_col)\n    return best_rectangle\n\ndef find_multicolored_object(grid):\n    \"\"\"\n    Finds a single contiguous object composed of multiple colors (excluding red).\n\n    Returns:\n      A bounding box (start_row, start_col, end_row, end_col), or None.\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def dfs(row, col, start_color):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (row < 0 or row >= grid.shape[0] or col < 0 or col >= grid.shape[1] or\n                visited[row, col] or grid[row, col] == 2): # Exclude red\n            return []\n\n        visited[row, col] = True\n        region = [(row, col)]\n        current_color = grid[row,col]\n\n        region.extend(dfs(row + 1, col, start_color))\n        region.extend(dfs(row - 1, col, start_color))\n        region.extend(dfs(row, col + 1, start_color))\n        region.extend(dfs(row, col - 1, start_color))\n        return region\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if grid[row, col] != 2 and not visited[row, col]:  # Exclude red and visited\n                start_color = grid[row,col]\n                region = dfs(row, col, start_color)\n                if region:\n                    colors_present = set()\n                    for r,c in region:\n                      colors_present.add(grid[r,c])\n                    if len(colors_present) > 1:\n                      min_row = min(r[0] for r in region)\n                      max_row = max(r[0] for r in region)\n                      min_col = min(r[1] for r in region)\n                      max_col = max(r[1] for r in region)\n                      return (min_row, min_col, max_row, max_col) # Return immediately upon finding one\n    return None\n\ndef overlaps(rect1, rect2):\n    \"\"\"\n    Checks if two rectangles (bounding boxes) overlap on x and y projections.\n    \"\"\"\n    start_row1, start_col1, end_row1, end_col1 = rect1\n    start_row2, start_col2, end_row2, end_col2 = rect2\n    \n    # Check for x-axis overlap\n    x_overlap = not (end_col1 < start_col2 or end_col2 < start_col1)\n\n    # Check for y-axis overlap\n    y_overlap = not (end_row1 < start_row2 or end_row2 < start_row1)\n    \n    return x_overlap and y_overlap\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    input_grid = np.array(input_grid)\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the multi-colored object\n    multicolored_object = find_multicolored_object(input_grid)\n    \n    selected_rectangle = None\n\n    if multicolored_object:\n      # Find red rectangles\n      red_rectangles = find_objects(input_grid, 2)\n      # Check for overlaps\n      for red_rect in red_rectangles:\n          if overlaps(red_rect, multicolored_object):\n              selected_rectangle = red_rect\n              break # select the first that overlaps\n    \n    # if no multi-colored object, or no overlap\n    if selected_rectangle is None:\n        selected_rectangle = find_largest_red_rectangle(input_grid)\n        \n    # change output pixels \n    if selected_rectangle:\n        start_row, start_col, end_row, end_col = selected_rectangle\n        output_grid[start_row:end_row+1, start_col:end_col+1] = 2\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2465,
    "candidates_token_count": 1720,
    "total_token_count": 4185,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 17.032996,
  "response_file": "006-response.json"
}