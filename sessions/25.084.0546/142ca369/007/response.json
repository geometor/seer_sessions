{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all contiguous blocks of non-zero colored pixels. Each block is an object.\n2.  **Object Pairing and Connection:** Objects of different colors will attempt to connect diagonally based on these rules:\n    *   Objects are considered for connection if they are within reasonable proximity (Manhattan distance <= 10). Objects far apart will not connect.\n    *   Objects that *can* connect diagonally *will* connect diagonally. If a direct diagonal connection would pass through another object, the connection is not made.\n    *   Objects that have multiple potential connections will connect to all valid partners.\n    *   Connections will use the color of the first object.\n\n3. **Drawing Connections**\n   * From the center of the first object, move diagonally towards the center of its connecting partner.\n   * Connect to the center of the other object.\n   * Expand the connection line to match the width of the *narrowest* of the two connecting objects. If one of the objects has a width of 1, the connection remains 1 pixel wide.\n   * Fill all pixels between the two centers, not just a single diagonal line, taking the smallest dimension of the two objects as the width.\n\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"Finds all contiguous objects in a grid.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def _bfs(r, c, color):\n        obj = []\n        queue = deque([(r, c)])\n        visited.add((r, c))\n\n        while queue:\n            row, col = queue.popleft()\n            obj.append((row, col))\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (-1,-1), (1, -1), (-1, 1)]:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr, nc] == color:\n                    queue.append((nr, nc))\n                    visited.add((nr, nc))\n        return obj\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                obj = _bfs(r, c, grid[r, c])\n                objects.append((grid[r,c], obj))\n    return objects\n\ndef get_object_bounds(obj):\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    for r,c in obj:\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n    return min_r, min_c, max_r, max_c\n\ndef get_object_center(obj):\n    min_r, min_c, max_r, max_c = get_object_bounds(obj)\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    return center_r, center_c\n\ndef object_dimensions(obj):\n    min_r, min_c, max_r, max_c = get_object_bounds(obj)\n    return max_r - min_r + 1, max_c - min_c + 1\n\ndef object_distance(obj1, obj2):\n    center1_r, center1_c = get_object_center(obj1)\n    center2_r, center2_c = get_object_center(obj2)\n    return abs(center1_r - center2_r) + abs(center1_c - center2_c)\n\ndef can_connect_diagonally(grid, obj1, obj2):\n    \"\"\"Checks if two objects can be connected diagonally without passing through other objects.\"\"\"\n    center1_r, center1_c = get_object_center(obj1)\n    center2_r, center2_c = get_object_center(obj2)\n\n    dr = 1 if center2_r > center1_r else -1\n    dc = 1 if center2_c > center1_c else -1\n\n    curr_r, curr_c = center1_r, center1_c\n    while (curr_r != center2_r) or (curr_c != center2_c):\n        next_r = curr_r + dr if curr_r != center2_r else curr_r\n        next_c = curr_c + dc if curr_c != center2_c else curr_c\n\n        if grid[next_r, next_c] != 0 and (next_r, next_c) not in obj1 and (next_r, next_c) not in obj2:\n            return False  # Path is blocked\n\n        curr_r, curr_c = next_r, next_c\n\n    return True\n\n\ndef find_connections(grid, objects):\n    \"\"\"Finds valid connections between objects.\"\"\"\n    connections = []\n    for i in range(len(objects)):\n        for j in range(i + 1, len(objects)):\n            color1, obj1 = objects[i]\n            color2, obj2 = objects[j]\n            if color1 != color2:\n                if object_distance(obj1,obj2) <= 10:\n                    if can_connect_diagonally(grid, obj1, obj2):\n                        connections.append((i, j))\n    return connections\n\ndef draw_connection(grid, obj1, obj2, color):\n    \"\"\"Draws a diagonal connection between two objects with appropriate width.\"\"\"\n    center1_r, center1_c = get_object_center(obj1)\n    center2_r, center2_c = get_object_center(obj2)\n\n    # Determine fill width\n    height1, width1 = object_dimensions(obj1)\n    height2, width2 = object_dimensions(obj2)\n    fill_width = min(height1, width1, height2, width2)\n\n    # Bresenham's algorithm for the main diagonal line\n    dx = abs(center2_c - center1_c)\n    dy = abs(center2_r - center1_r)\n    sx = 1 if center1_c < center2_c else -1\n    sy = 1 if center1_r < center2_r else -1\n    err = dx - dy\n\n    curr_r, curr_c = center1_r, center1_c\n\n    while True:\n        # Apply fill width\n        for i in range(-(fill_width // 2), (fill_width + 1) // 2):\n            # Fill vertically\n            row = max(0, min(grid.shape[0] - 1, curr_r + i))\n            col = max(0, min(grid.shape[1] - 1, curr_c))\n            if grid[row, col] == 0 :\n                grid[row, col] = color\n                \n            #Fill horizontally\n            row = max(0, min(grid.shape[0] - 1, curr_r))\n            col = max(0, min(grid.shape[1] - 1, curr_c + i))\n            if grid[row, col] == 0:\n                grid[row,col] = color\n        \n\n        if curr_r == center2_r and curr_c == center2_c:\n            break\n\n        e2 = 2 * err\n        if e2 > -dy:\n            err -= dy\n            curr_c += sx\n        if e2 < dx:\n            err += dx\n            curr_r += sy\n\ndef transform(input_grid):\n    grid = np.array(input_grid)\n    objects = find_objects(grid)\n    connections = find_connections(grid, objects)\n\n    for i, j in connections:\n        color1, obj1 = objects[i]\n        _, obj2 = objects[j]\n        draw_connection(grid, obj1, obj2, color1)\n\n    return grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10448,
    "candidates_token_count": 1954,
    "total_token_count": 12402,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 23.036346
}