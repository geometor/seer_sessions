{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify Objects: Find all contiguous blocks of non-zero colored pixels in the input grid. Consider each block as a separate object.\n2. Combination:\n      - non-zero objects will attempt to find the nearest object of different color, and merge diagonally.\n        - find every adjacent color\n        - include diagonals\n        - fill a diagonal line towards the matched other object\n        - the fill will be one pixel wide, except when connecting two objects that are more than one pixel wide - in this case, the fill will expand\n          to the width of the narrowest object, centered.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"Finds all contiguous objects in a grid.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def _bfs(r, c, color):\n        obj = []\n        queue = deque([(r, c)])\n        visited.add((r, c))\n\n        while queue:\n            row, col = queue.popleft()\n            obj.append((row, col))\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr, nc] == color:\n                    queue.append((nr, nc))\n                    visited.add((nr, nc))\n        return obj\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                obj = _bfs(r, c, grid[r, c])\n                objects.append((grid[r,c], obj))\n    return objects\n\ndef get_object_bounds(obj):\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    for r,c in obj:\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n    return min_r, min_c, max_r, max_c\n\n\ndef get_object_center(obj):\n    min_r, min_c, max_r, max_c = get_object_bounds(obj)\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    return center_r, center_c\n\ndef object_distance(obj1, obj2):\n    center1_r, center1_c = get_object_center(obj1)\n    center2_r, center2_c = get_object_center(obj2)\n    return abs(center1_r - center2_r) + abs(center1_c - center2_c)\n\ndef find_nearest_object(objects, current_object_index):\n    min_dist = float('inf')\n    nearest_obj_index = -1\n\n    for i in range(len(objects)):\n        if i == current_object_index:\n            continue\n\n        current_color = objects[current_object_index][0]\n        other_color = objects[i][0]\n        if current_color != other_color:\n            current_dist = object_distance(objects[current_object_index][1], objects[i][1])\n            if current_dist < min_dist:\n                min_dist = current_dist\n                nearest_obj_index = i\n\n    return nearest_obj_index\n\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the combination rule.\"\"\"\n    grid = np.array(input_grid)  # Convert to NumPy array\n    output_grid = np.copy(grid)\n\n    objects = find_objects(grid)\n\n    for i in range(len(objects)):\n        nearest_object_index = find_nearest_object(objects,i)\n        if nearest_object_index != -1:\n            current_object = objects[i][1]\n            nearest_object = objects[nearest_object_index][1]\n            current_color = objects[i][0]\n            \n            current_center_r, current_center_c = get_object_center(current_object)\n            nearest_center_r, nearest_center_c = get_object_center(nearest_object)\n\n            dr = 1 if nearest_center_r > current_center_r else -1 if nearest_center_r < current_center_r else 0\n            dc = 1 if nearest_center_c > current_center_c else -1 if nearest_center_c < current_center_c else 0\n\n            # determine fill width\n            cur_min_r, cur_min_c, cur_max_r, cur_max_c = get_object_bounds(current_object)\n            near_min_r, near_min_c, near_max_r, near_max_c = get_object_bounds(nearest_object)\n\n            current_width = max(cur_max_r - cur_min_r + 1, cur_max_c-cur_min_c+1)\n            nearest_width = max(near_max_r-near_min_r+1, near_max_c - near_min_c + 1)\n            fill_width = min(current_width, nearest_width)\n\n            curr_r = current_center_r\n            curr_c = current_center_c\n\n            while (curr_r, curr_c) != (nearest_center_r, nearest_center_c):\n\n                for i in range(-(fill_width//2), (fill_width+1)//2):\n                    if dr != 0 and dc != 0: # diagonal\n                        output_grid[curr_r+i, curr_c] = current_color\n                        output_grid[curr_r, curr_c+i] = current_color\n\n                    elif dr != 0: # vertical\n                        output_grid[curr_r, curr_c + i] = current_color\n\n                    elif dc != 0:  #horizontal\n                        output_grid[curr_r+i, curr_c] = current_color\n\n                if (curr_r != nearest_center_r):\n                    curr_r += dr\n                if (curr_c != nearest_center_c):\n                    curr_c += dc\n\n\n            for i in range(-(fill_width//2), (fill_width + 1)//2):\n                if dr != 0 and dc != 0:\n                    output_grid[curr_r + i, curr_c] = current_color\n                    output_grid[curr_r, curr_c + i] = current_color\n                elif dr != 0:\n                    output_grid[curr_r, curr_c + i] = current_color\n                elif dc != 0:\n                    output_grid[curr_r + i, curr_c] = current_color\n\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6070,
    "candidates_token_count": 1681,
    "total_token_count": 7751,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.994334
}