{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule involves identifying objects of different colors and performing operations based on their relative positions. The operations include copying, shifting, and replacing objects. A key aspect is the relative vertical positioning of objects, and in some cases, using the position of one object to determine the placement of another.\n\n1.  **General Approach:**\n    *   Identify all distinct objects and the background color.\n    *   Determine the relative positions of objects (top-most, bottom-most, etc.).\n    *   Based on the relative positions, perform operations like:\n        *   Copying an object to a new location, possibly relative to another object.\n        *   Shifting parts of the grid.\n        *   Replacing one object with another.\n\n2.  **Example-Specific Observations and Corrections:**\n      *   **Example 1:** The azure object is removed, and the red object's final position is influenced by the initial position of the azure object. The grid is shifted, so the red appears to be moved down 1 unit\n    *   **Example 2:** The blue object is copied to the top.  The red object is placed at a location relative to the blue one (but constant) and also copied 1 unit down.\n    *   **Example 3:** The magenta object is removed. The yellow object is copied multiple times, including to the rows previously occupied by the magenta object and 1 unit above\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Identifies the background color and foreground objects in the grid.\n    Returns a dictionary where keys are colors and values are lists of (row, col) positions.\n    \"\"\"\n    background_color = np.bincount(grid.flatten()).argmax()\n    objects = {}\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append((r, c))\n    return background_color, objects\n\ndef copy_object(grid, object_positions, r_offset, c_offset, background_color):\n    \"\"\"Copies an object to a new location with offsets, handling bounds and background.\"\"\"\n    new_grid = grid.copy()\n    for r, c in object_positions:\n        new_r, new_c = r + r_offset, c + c_offset\n        if 0 <= new_r < new_grid.shape[0] and 0 <= new_c < new_grid.shape[1]:\n            new_grid[new_r,new_c] = grid[r,c]\n    return new_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the observed rules.\n    \"\"\"\n    output_grid = input_grid.copy()\n    background_color, objects = get_objects(input_grid)\n\n    object_colors = list(objects.keys())\n\n    if len(object_colors) == 2:\n        # Determine top and bottom objects based on average row position\n        color1_positions = objects[object_colors[0]]\n        color2_positions = objects[object_colors[1]]\n\n        avg_row1 = sum(r for r, _ in color1_positions) / len(color1_positions)\n        avg_row2 = sum(r for r, _ in color2_positions) / len(color2_positions)\n\n        if avg_row1 < avg_row2:\n            top_color = object_colors[0]\n            bottom_color = object_colors[1]\n            top_object = color1_positions\n            bottom_object = color2_positions\n\n        else:\n            top_color = object_colors[1]\n            bottom_color = object_colors[0]\n            top_object = color2_positions\n            bottom_object = color1_positions\n            \n\n        # find top row\n        top_row = min(r for r,_ in top_object)\n        # find bottom row\n        bottom_row = max(r for r,_ in top_object)\n\n        top_obj_height = bottom_row - top_row + 1\n\n        # clear top object\n        for r,c in top_object:\n            output_grid[r,c] = background_color\n\n\n        if top_color == 8 and bottom_color == 2: # Example 1: Azure and Red\n          # shift down, copy below\n            #find top row of bottom object\n            bottom_top_row = min(r for r, _ in bottom_object)\n            output_grid = copy_object(output_grid,bottom_object,top_row - bottom_top_row, 0, background_color)\n            output_grid = copy_object(output_grid,bottom_object, 1, 0, background_color)\n        elif top_color == 2 and bottom_color == 1: # Example 2: Red and Blue (Inverted)\n            # copy top to constant\n            output_grid = copy_object(output_grid, top_object, 2-top_row, 0, background_color)\n            # clear bottom\n            for r,c in bottom_object:\n                output_grid[r,c] = background_color\n            output_grid = copy_object(output_grid, top_object, bottom_row-top_row - (top_obj_height + 1), 0, background_color)\n            # copy below\n            output_grid = copy_object(output_grid, top_object, 1, 0, background_color)\n        elif top_color == 4 and bottom_color == 6: # Example 3: Yellow and Magenta\n             # find yellow objects\n            yellow_object = objects.get(4,[])\n\n            # find magenta objects\n            magenta_object = objects.get(6,[])\n\n            #replace yellow to magenta\n            if len(magenta_object) > 0 and len(yellow_object) > 0:\n\n                magenta_rows = sorted(list(set([r for r,c in magenta_object])))\n                yellow_rows = sorted(list(set([r for r,c in yellow_object])))\n\n                # clear magenta\n                for r,c in magenta_object:\n                    output_grid[r,c] = background_color\n\n                # copy yellows to magenta's old place\n                for i in range(min(len(magenta_rows),len(yellow_rows))):\n                    for r,c in yellow_object:\n                        if (r-yellow_rows[0]) < output_grid.shape[0]:\n                            output_grid[magenta_rows[i] + (r-yellow_rows[0]),c] = 4\n                \n                # copy 1 row above yellow\n                for r,c in yellow_object:\n                    if magenta_rows[0]-1 > -1:\n                        output_grid[magenta_rows[0]-1+(r-yellow_rows[0]),c] = 4\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12127,
    "candidates_token_count": 1617,
    "total_token_count": 13744,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 16.895726
}