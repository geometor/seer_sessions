{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule involves identifying objects of different colors, and then moving, reflecting, or copying them based on their relative positions. The background color is consistently maintained.\n\n1. **Example 1 (Red and Azure):** The azure object is removed. The red object is copied down by one row. The entire grid is then shifted down, with the top section filled with the background color, such that the original red object's top row becomes the top row of the shifted grid.\n2. **Example 2 (Blue and Red):** The blue object is copied to the top of the grid. The red object is copied to a position above where the blue object was originally, and then the red object is copied down one position.\n3. **Example 3 (Yellow and Magenta):** The magenta objects are removed.  The rows occupied by the magenta object are replaced by the yellow objects.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Identifies the background color and foreground objects in the grid.\n    Returns a dictionary where keys are colors and values are lists of (row, col) positions.\n    \"\"\"\n    background_color = np.bincount(grid.flatten()).argmax()\n    objects = {}\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append((r, c))\n    return background_color, objects\n\ndef shift_rows(grid, start_row, num_rows, shift_amount, fill_color):\n    \"\"\"\n    Shifts rows down within a grid.\n\n    Args:\n      grid: The numpy array representing the grid.\n      start_row: The index of the first row to shift.\n      num_rows:  How many rows must be shifted\n      shift_amount: The number of rows to shift down (positive integer).\n      fill_color: The color to fill the vacated rows with.\n\n    \"\"\"\n    new_grid = grid.copy()\n\n    if shift_amount > 0 :\n        new_grid[start_row + shift_amount:start_row+num_rows, :] = grid[start_row : start_row+num_rows-shift_amount, :]\n        new_grid[start_row:start_row + shift_amount, :] = fill_color\n    return new_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the observed rules.\n    \"\"\"\n    output_grid = input_grid.copy()\n    background_color, objects = get_objects(input_grid)\n\n    # Example 1 Logic (Red and Azure objects)\n    if len(objects) == 2 and 2 in objects and 8 in objects:\n\n        # find red object top row\n        red_object = objects.get(2,[])\n        red_top_row = -1\n        if len(red_object) > 0:\n            red_top_row = min(r for r, c in red_object)\n\n        blue_object = objects.get(8, [])\n        blue_top_row = -1\n        if len(blue_object) > 0:\n          blue_top_row = min(r for r,c in blue_object)\n\n\n        # fill the area with the same pattern where the object was first encountered\n        for r in range(output_grid.shape[0]):\n            for c in range(output_grid.shape[1]):\n                if output_grid[r,c] == 8:\n                    output_grid[r,c] = background_color\n\n        output_grid = shift_rows(output_grid,blue_top_row, output_grid.shape[0]-blue_top_row, red_top_row, background_color)\n\n        #Copy Red Objects\n        red_positions = objects.get(2, [])\n        if red_positions:\n            #first_red_row = min(r for r, _ in red_positions) # Not needed\n            for r, c in red_positions:\n                 if r+1 < output_grid.shape[0]:\n                    output_grid[r + 1, c] = 2\n\n    # Example 2 Logic (Blue and Red objects)\n    elif len(objects) == 2 and 1 in objects and 2 in objects:\n       #Invert and move blue\n\n        output_grid[:] = background_color  # Clear the output grid first.\n\n        blue_object = objects.get(1, [])\n        \n        if len(blue_object) > 0:\n            blue_top_row =  min(r for r,c in blue_object)\n            blue_bottom_row =  max(r for r,c in blue_object)\n\n            blue_height = blue_bottom_row - blue_top_row + 1\n\n            new_blue_top = 2 # constant\n            # copy the object in new place\n            for r,c in blue_object:\n                output_grid[new_blue_top + (r - blue_top_row), c] = 1\n\n\n        red_object = objects.get(2,[])\n        \n        if len(red_object) > 0:\n            red_top_row = min(r for r, c in red_object)\n            new_red_top = blue_top_row - (red_top_row+4)  # calculate distance based on dream\n            \n            for r, c in red_object:\n              if(new_red_top > -1):  \n                output_grid[new_red_top,c] = 2\n\n            #Copy Red Object down\n            for r in range(output_grid.shape[0]):\n                for c in range(output_grid.shape[1]):\n                    if output_grid[r,c] == 2:\n                       if r+1 < output_grid.shape[0]:\n                            output_grid[r + 1, c] = 2\n\n\n    # Example 3 Logic (Yellow and Magenta objects)\n    elif len(objects) == 2 and 4 in objects and 6 in objects:\n        # find yellow objects\n        yellow_object = objects.get(4,[])\n\n        # find magenta objects\n        magenta_object = objects.get(6,[])\n\n        #replace yellow to magenta\n        if len(magenta_object) > 0 and len(yellow_object) > 0:\n\n            magenta_rows = sorted(list(set([r for r,c in magenta_object])))\n            yellow_rows = sorted(list(set([r for r,c in yellow_object])))\n\n            # clear magenta\n            for r,c in magenta_object:\n                output_grid[r,c] = background_color\n            # clear yellow\n            for r,c in yellow_object:\n                output_grid[r,c] = background_color\n\n            # copy yellows to magenta's old place\n            for i in range(min(len(magenta_rows),len(yellow_rows))):\n                 for r,c in yellow_object:\n                    if (r-yellow_rows[0]) < output_grid.shape[0]:\n                         output_grid[magenta_rows[i] + (r-yellow_rows[0]),c] = 4\n            \n            # copy 1 row below yellow\n            for r,c in yellow_object:\n                if magenta_rows[0]-1 > -1:\n                    output_grid[magenta_rows[0]-1+(r-yellow_rows[0]),c] = 4\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12020,
    "candidates_token_count": 1757,
    "total_token_count": 13777,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.246812
}