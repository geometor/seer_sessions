{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule involves identifying foreground objects within a background and manipulating them based on their type and position. The rows containing or adjacent to certain objects might be shifted, and objects of one color might be replaced or copied based on the positions of other objects.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Identifies the background color and foreground objects in the grid.\n    Returns a dictionary where keys are colors and values are lists of (row, col) positions.\n    \"\"\"\n    background_color = np.bincount(grid.flatten()).argmax()\n    objects = {}\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append((r, c))\n    return background_color, objects\n\ndef shift_rows(grid, start_row, num_rows, shift_amount, fill_color):\n    \"\"\"\n    Shifts rows down within a grid.\n\n    Args:\n      grid: The numpy array representing the grid.\n      start_row: The index of the first row to shift.\n      num_rows:  How many rows must be shifted\n      shift_amount: The number of rows to shift down (positive integer).\n      fill_color: The color to fill the vacated rows with.\n\n    \"\"\"\n    new_grid = grid.copy()\n\n    if shift_amount > 0 :\n        new_grid[start_row + shift_amount:start_row+num_rows, :] = grid[start_row : start_row+num_rows-shift_amount, :]\n        new_grid[start_row:start_row + shift_amount, :] = fill_color\n    return new_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the observed rules.\n    \"\"\"\n    output_grid = input_grid.copy()\n    background_color, objects = get_objects(input_grid)\n\n    # Example 1 Logic (Red and Blue objects)\n    if len(objects) == 2 and 2 in objects and 8 in objects:\n\n        # find red object top row\n        red_object = objects.get(2,[])\n        red_top_row = -1\n        if len(red_object) > 0:\n            red_top_row = min(r for r, c in red_object)\n\n        blue_object = objects.get(8, [])\n        blue_top_row = -1\n        if len(blue_object) > 0:\n          blue_top_row = min(r for r,c in blue_object)\n\n\n        # fill the area with the same pattern where the object was first encountered\n        for r in range(output_grid.shape[0]):\n            for c in range(output_grid.shape[1]):\n                if output_grid[r,c] == 8:\n                    output_grid[r,c] = background_color\n\n        output_grid = shift_rows(output_grid,blue_top_row, output_grid.shape[0]-blue_top_row, red_top_row, background_color)\n\n        #Copy Red Objects\n        red_positions = objects.get(2, [])\n        if red_positions:\n            first_red_row = min(r for r, _ in red_positions)\n            for r, c in red_positions:\n                 if r+1 < output_grid.shape[0]:\n                    output_grid[r + 1, c] = 2\n\n    # Example 2 Logic (Blue and Red objects)\n    elif len(objects) == 2 and 1 in objects and 2 in objects:\n       #Invert and move blue\n\n        output_grid[:] = background_color  # Clear the output grid first.\n\n        blue_object = objects.get(1, [])\n        \n        if len(blue_object) > 0:\n            blue_top_row =  min(r for r,c in blue_object)\n            blue_bottom_row =  max(r for r,c in blue_object)\n\n            blue_height = blue_bottom_row - blue_top_row+1\n\n            new_blue_top = 2\n            # copy the object in new place\n            for r,c in blue_object:\n                output_grid[new_blue_top + (r - blue_top_row), c] = 1\n\n            # fill object area in between with green\n            for r in range (new_blue_top, new_blue_top+blue_height):\n                 for c in range(output_grid.shape[1]):\n                    if output_grid[r,c] == 1:\n                       if r+1 < output_grid.shape[0]:\n                            output_grid[r + 1, c] = 1\n                       if r-1 > 0:\n                            output_grid[r -1, c] = 1\n\n\n\n        # fill the previous area of blue with green\n        red_object = objects.get(2,[])\n        \n        if len(red_object) > 0:\n            red_top_row = min(r for r, c in red_object)\n\n            for r, c in red_object:\n                output_grid[red_top_row-4,c] = 2\n\n            #Copy Red Object\n            for r in range(output_grid.shape[0]):\n                for c in range(output_grid.shape[1]):\n                    if output_grid[r,c] == 2:\n                       if r+1 < output_grid.shape[0]:\n                            output_grid[r + 1, c] = 2\n\n\n\n    elif len(objects) == 2 and 4 in objects and 6 in objects:\n        # find yellow objects\n        yellow_object = objects.get(4,[])\n\n        # find magenta objects\n        magenta_object = objects.get(6,[])\n\n        #replace yellow to magenta\n        if len(magenta_object) > 0 and len(yellow_object) > 0:\n\n            magenta_rows = sorted(list(set([r for r,c in magenta_object])))\n            yellow_rows = sorted(list(set([r for r,c in yellow_object])))\n\n\n            #copy magenta object to yellows\n            for r,c in magenta_object:\n                output_grid[r,c] = background_color\n            # move yellow to old position of magenta\n            for r,c in yellow_object:\n                output_grid[r,c] = background_color\n\n            for i in range(len(magenta_rows)):\n                 for r,c in yellow_object:\n                    output_grid[magenta_rows[i],c] = 4\n\n        # reflect magenta\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7651,
    "candidates_token_count": 1587,
    "total_token_count": 9238,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.24926
}