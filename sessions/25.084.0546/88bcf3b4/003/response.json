{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all contiguous clusters of non-zero pixels. Each cluster is an object, and pixels of the same color within an object are considered parts of it.\n\n2.  **Iterate through Columns:** Examine the grid column by column, starting from the rightmost column and moving towards the left.\n\n3.  **Determine Shift Potential:** Within each column, determine the objects that are eligible for shifting.\n    *   Objects are shifted if they are not in the leftmost column.\n    *   The direction of the shift (left or right) depends on where it is blocked by another object.\n    *   Consider the grid edge as a blocking object.\n\n4.  **Shift Objects:** Shift each object to the left or right by one or more columns.\n   * if any part of an object would collide with a non-zero pixel of another object, the moving object stops immediately before the collision.\n\n5. **Join and Coalesce Objects**: After an object is moved, if parts of another object of the same color exist that are adjacent, combine them.\n\n6. **Vertical Alignment**: objects shift down to the lowest row of a blocking object\n\n7.  **Preserve Background:**  The background (pixels with value 0) is preserved unless overwritten by a shifted object.\n\"\"\"\n\nimport numpy as np\n\ndef find_clusters(grid):\n    \"\"\"Finds clusters of contiguous non-zero pixels of the same color.\"\"\"\n    clusters = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def dfs(row, col, color, cluster):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (\n            row < 0\n            or row >= grid.shape[0]\n            or col < 0\n            or col >= grid.shape[1]\n            or visited[row, col]\n            or grid[row, col] != color\n            or grid[row, col] == 0\n        ):\n            return\n        visited[row, col] = True\n        cluster.append((row, col))\n        dfs(row + 1, col, color, cluster)\n        dfs(row - 1, col, color, cluster)\n        dfs(row, col + 1, color, cluster)\n        dfs(row, col - 1, color, cluster)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if not visited[row, col] and grid[row, col] != 0:\n                cluster = []\n                dfs(row, col, grid[row, col], cluster)\n                if cluster:\n                    clusters.append(cluster)\n    return clusters\n\ndef shift_cluster(grid, cluster, direction):\n    \"\"\"Shifts a cluster one position to the left or right, if possible.\"\"\"\n    new_grid = np.copy(grid)\n    \n    #check if we can move cluster, exit early\n    can_move = True\n    for row, col in cluster:\n        new_col = col + direction\n        if new_col < 0 or new_col >= grid.shape[1]:\n          can_move = False\n          break\n        if grid[row, new_col] != 0 and (row, new_col) not in cluster:\n            can_move = False\n            break\n            \n    if not can_move: return new_grid, False\n\n    # clear cells\n    for row, col in cluster:\n        new_grid[row, col] = 0\n\n    # move cluster\n    new_cluster = []\n    for row, col in cluster:\n      new_cluster.append((row, col + direction))\n    for row, col in new_cluster:\n        new_grid[row, col] = grid[row, col-direction]\n    return new_grid, True\n\ndef get_lowest_row(grid, cluster):\n    \"\"\"Returns the lowest row index within a cluster.\"\"\"\n    lowest_row = -1\n    for row, _ in cluster:\n        lowest_row = max(lowest_row, row)\n    return lowest_row\n\ndef vertically_align_cluster(grid, cluster):\n    \"\"\"\n    Vertically aligns a cluster downwards, stopping at the bottom of\n      the grid or when it encounters another non-zero pixel.\n    \"\"\"\n    new_grid = np.copy(grid)\n    max_shift = grid.shape[0]\n\n     # clear cells\n    for row, col in cluster:\n        new_grid[row, col] = 0\n\n    # Find maximum possible downward shift\n    for row, col in cluster:\n      for r in range(row + 1, grid.shape[0]):\n            if grid[r,col] != 0 and (r,col) not in cluster:\n              max_shift = min(max_shift, r - row -1)\n              break\n            elif r == grid.shape[0] - 1:\n                max_shift = min(max_shift, r-row)\n\n    new_cluster = []\n\n    for row, col in cluster:\n      new_cluster.append((row + max_shift, col))\n\n    for row, col in new_cluster:\n      new_grid[row, col] = grid[row - max_shift, col]\n    return new_grid\n\ndef coalesce_clusters(grid):\n    \"\"\"Combines adjacent clusters of the same color.\"\"\"\n    new_grid = np.copy(grid)\n    clusters = find_clusters(new_grid)  # Find clusters in the current grid\n\n    # Iterate through all pairs of clusters\n    for i in range(len(clusters)):\n        for j in range(i + 1, len(clusters)):\n            cluster1 = clusters[i]\n            cluster2 = clusters[j]\n            \n            # Check if clusters have the same color\n            if cluster1 and cluster2:  # Make sure clusters haven't been emptied\n              color1 = new_grid[cluster1[0]]\n              color2 = new_grid[cluster2[0]]\n              \n              if color1 == color2:\n                # Check for adjacency (including diagonals)\n                adjacent = False\n                for row1, col1 in cluster1:\n                    for row2, col2 in cluster2:\n                        if abs(row1 - row2) <= 1 and abs(col1 - col2) <= 1:\n                            adjacent = True\n                            break\n                    if adjacent:\n                        break\n                if adjacent: # combine clusters\n                    # clear cluster2\n                    for row, col in cluster2:\n                        new_grid[row,col] = 0\n                    # move pixels in cluster2 to cluster1\n                    for row, col in cluster2:\n                      new_grid[row, col] = color1  # move into first cluster\n\n                    # rebuild clusters - recursion\n                    return coalesce_clusters(new_grid)\n\n    return new_grid\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the observed rule.\"\"\"\n    \n    output_grid = np.copy(input_grid)\n    \n    # iterate by columns, right to left\n    for col in range(output_grid.shape[1] - 1, -1, -1):\n        clusters_in_col = []\n        \n        # any clusters in the column?\n        for row in range(output_grid.shape[0]):\n             if output_grid[row, col] != 0:\n                 #get the object and try to shift\n                 for cluster in find_clusters(output_grid):\n                     for r,c in cluster:\n                         if r == row and c == col:\n                             clusters_in_col.append(cluster)\n\n        if len(clusters_in_col) > 0:\n          for cluster in clusters_in_col:\n            #try to shift left\n            output_grid, did_move = shift_cluster(output_grid, cluster, -1)\n            #if it can't move left, try to move right\n            if not did_move:\n               output_grid, did_move = shift_cluster(output_grid, cluster, 1)\n\n    # align vertically\n    clusters = find_clusters(output_grid)\n    for cluster in clusters:\n        output_grid = vertically_align_cluster(output_grid, cluster)\n        \n    # coalesce clusters\n    output_grid = coalesce_clusters(output_grid)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20299,
    "candidates_token_count": 1910,
    "total_token_count": 22209,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 28.257012
}