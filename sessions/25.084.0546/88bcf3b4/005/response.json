{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nShifts objects horizontally, then vertically, and coalesces adjacent objects of the same color.\n\"\"\"\n\nimport numpy as np\n\ndef find_clusters(grid):\n    \"\"\"Finds clusters of contiguous non-zero pixels of the same color.\"\"\"\n    clusters = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def dfs(row, col, color, cluster):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (\n            row < 0\n            or row >= grid.shape[0]\n            or col < 0\n            or col >= grid.shape[1]\n            or visited[row, col]\n            or grid[row, col] != color\n            or grid[row, col] == 0\n        ):\n            return\n        visited[row, col] = True\n        cluster.append((row, col))\n        dfs(row + 1, col, color, cluster)\n        dfs(row - 1, col, color, cluster)\n        dfs(row, col + 1, color, cluster)\n        dfs(row, col - 1, color, cluster)\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if not visited[row, col] and grid[row, col] != 0:\n                cluster = []\n                dfs(row, col, grid[row, col], cluster)\n                if cluster:\n                    clusters.append(cluster)\n    return clusters\n\ndef shift_cluster_horizontal(grid, cluster):\n    \"\"\"Shifts a cluster one position left or right, if possible, with gravity.\"\"\"\n    new_grid = np.copy(grid)\n    color = grid[cluster[0]]\n\n    # Try shifting left\n    can_move_left = True\n    for row, col in cluster:\n        if col == 0 or (grid[row, col - 1] != 0 and (row, col - 1) not in cluster):\n            can_move_left = False\n            break\n\n    if can_move_left:\n        direction = -1\n    else:\n        # Try shifting right\n        can_move_right = True\n        for row, col in cluster:\n            if col == grid.shape[1] - 1 or (grid[row, col + 1] != 0 and (row, col + 1) not in cluster):\n                can_move_right = False\n                break\n        if can_move_right:\n            direction = 1\n        else:\n            return grid  # No horizontal movement possible\n\n    # clear the original cluster\n    for r, c in cluster:\n      new_grid[r,c] = 0\n\n    # Determine maximum downward shift after horizontal move\n    new_cluster = []\n    max_downward_shift = 0\n\n    for row, col in cluster:\n      new_col = col + direction\n      max_shift = 0\n\n      # move as far down as possible\n      for r in range(row + 1, grid.shape[0]):\n        if grid[r,new_col] != 0 and (r,new_col) not in cluster:\n          break\n        else:\n          max_shift += 1\n      max_downward_shift = max(max_downward_shift, max_shift)\n\n    # Apply horizontal and vertical shift, combine into new_cluster\n    for row, col in cluster:\n      new_cluster.append( (row + max_downward_shift, col + direction) )\n\n    # apply the color to the new cluster\n    for r, c in new_cluster:\n      new_grid[r,c] = color\n\n    return new_grid\n\ndef coalesce_clusters(grid):\n    \"\"\"Combines adjacent clusters of the same color, iteratively.\"\"\"\n    new_grid = np.copy(grid)\n    \n    while True:\n        clusters = find_clusters(new_grid)\n        coalesced = False\n        \n        for i in range(len(clusters)):\n            for j in range(i + 1, len(clusters)):\n                if i >= len(clusters) or j >= len(clusters): # handle changes to clusters\n                    break\n                cluster1 = clusters[i]\n                cluster2 = clusters[j]\n\n                if cluster1 and cluster2:\n                    color1 = new_grid[cluster1[0]]\n                    color2 = new_grid[cluster2[0]]\n\n                    if color1 == color2:\n                        adjacent = False\n                        for row1, col1 in cluster1:\n                            for row2, col2 in cluster2:\n                                if abs(row1 - row2) <= 1 and abs(col1 - col2) <= 1:\n                                    adjacent = True\n                                    break\n                            if adjacent:\n                                break\n\n                        if adjacent:\n                            # Combine clusters:  clear cluster2, add to first\n                            for row, col in cluster2:\n                                new_grid[row, col] = 0\n                            for row, col in cluster2:\n                                cluster1.append((row,col))\n                            clusters[j] = [] # remove\n                            coalesced = True\n                            # put all cluster1 pixels into the grid with color1\n                            for row, col in cluster1:\n                                new_grid[row,col] = color1\n\n        if not coalesced:  # Exit when no more coalescing occurs\n            break\n\n    return new_grid\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the observed rule.\"\"\"\n\n    output_grid = np.copy(input_grid)\n\n    # Horizontal Shifting (with integrated vertical drop)\n    for col in range(output_grid.shape[1] - 1, -1, -1):\n        clusters_in_col = []\n        for row in range(output_grid.shape[0]):\n            if output_grid[row, col] != 0:\n                for cluster in find_clusters(output_grid):\n                    if (row, col) in cluster:\n                        clusters_in_col.append(cluster)\n        \n        # shift\n        for cluster in clusters_in_col:\n            output_grid = shift_cluster_horizontal(output_grid, cluster)\n            \n    # Coalescing\n    output_grid = coalesce_clusters(output_grid)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7846,
    "candidates_token_count": 1454,
    "total_token_count": 9300,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.701201
}