{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Convert Blue to Red:** Replace all blue (1) pixels with red (2) pixels.\n2.  **Identify Isolated Red Regions:** Before any expansion, identify connected regions of red (2) pixels. A red region is considered \"isolated\" if none of its pixels are directly adjacent (horizontally, vertically, *or diagonally*) to a green (3) pixel.\n3.  **Expand Existing Green Regions Conditionally:** For each existing green (3) pixel, check for adjacent red (2) pixels (horizontally or vertically).\n    *   If a red pixel is found adjacent to the green:\n        *   Expand the green region vertically upwards from the green pixel, stopping if a background (8) pixel or the edge of the grid is encountered.\n        *   Expand the green region vertically downwards from the green pixel, stopping if a background (8) pixel or the edge of the grid is encountered.\n4.  **Insert Green to the Left of Isolated Red Regions:** For each *isolated* red region (determined in step 2):\n    * Find the top row of each isolated red region.\n    *   Insert green (3) pixels to the left of the entire isolated region, starting at the top row and filling all columns to the left of the leftmost red pixel in the region.\n5.  **Expand the Inserted Green Vertically:** Extend the newly inserted green pixels (from step 4) vertically (up and down).\n    *  Expand upwards, stopping at a background (8) pixel, existing green (3) pixel, or the grid edge.\n    *  Expand downwards, stopping at a background (8) pixel, existing green (3) pixel, or the grid edge.\n6.  **Preserve Background:** Ensure all background (8) pixels that were not part of any transformation remain unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef get_neighbors(grid, r, c, include_diagonal=False):\n    \"\"\"Get the neighbors of a cell.\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            if not include_diagonal and (i != 0 and j != 0):\n              continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef get_connected_regions(grid, value, include_diagonal=False):\n    \"\"\"Find connected regions of a specific value.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(r, c, current_region):\n        if (\n            r < 0\n            or r >= rows\n            or c < 0\n            or c >= cols\n            or visited[r, c]\n            or grid[r, c] != value\n        ):\n            return\n        visited[r, c] = True\n        current_region.append((r, c))\n        for nr, nc in get_neighbors(grid, r, c, include_diagonal):\n            dfs(nr, nc, current_region)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == value and not visited[r, c]:\n                current_region = []\n                dfs(r, c, current_region)\n                regions.append(current_region)\n    return regions\n\ndef is_isolated(region, grid):\n    \"\"\"Checks if a region is isolated (not adjacent to green).\"\"\"\n    for r, c in region:\n        for nr, nc in get_neighbors(grid, r, c, include_diagonal=True):\n            if grid[nr, nc] == 3:\n                return False  # Found an adjacent green pixel\n    return True\n\ndef transform(input_grid):\n    # Initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Convert Blue to Red\n    output_grid[output_grid == 1] = 2\n\n    # 2. Identify Isolated Red Regions (before expansion)\n    red_regions = get_connected_regions(output_grid, 2)\n    isolated_red_regions = [region for region in red_regions if is_isolated(region, output_grid)]\n\n    # 3. Expand Existing Green Regions Conditionally\n    existing_greens = np.argwhere(output_grid == 3)\n    for r, c in existing_greens:\n        neighbors = get_neighbors(output_grid, r, c)  # Only orthogonal\n        for nr, nc in neighbors:\n            if output_grid[nr, nc] == 2:\n                # Expand vertically upwards\n                ur = r - 1\n                while ur >= 0 and output_grid[ur, nc] != 8:\n                    output_grid[ur, nc] = 3\n                    ur -= 1\n                # Expand vertically downwards\n                dr = r + 1\n                while dr < rows and output_grid[dr, nc] != 8:\n                    output_grid[dr, nc] = 3\n                    dr += 1\n\n    # 4. Insert Green to the Left of Isolated Red Regions\n    for region in isolated_red_regions:\n        min_row = min(r for r, c in region)\n        min_col = min(c for r, c in region)\n        for c in range(min_col):\n          output_grid[min_row,c] = 3\n\n    # 5. Expand the Inserted Green Vertically\n    for region in isolated_red_regions:\n        min_row = min(r for r, c in region)\n        min_col = min(c for r, c in region)\n\n        # expand up\n        ur = min_row - 1\n        while ur >= 0 and output_grid[ur, min_col -1] != 8:\n          for c in range(min_col):\n            if output_grid[ur,c] != 3:\n              output_grid[ur,c] = 3\n          ur -= 1\n        # expand down\n        dr = min_row + 1\n        while dr < rows and output_grid[dr, min_col-1] != 8:\n          for c in range(min_col):\n            if output_grid[dr,c] != 3:\n              output_grid[dr,c] = 3\n          dr += 1\n\n    # 6. Preserve Background (Implicit in the logic)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24639,
    "candidates_token_count": 1533,
    "total_token_count": 26172,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 18.936978
}