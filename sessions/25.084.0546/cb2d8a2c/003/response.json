{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Replace Blues with Reds:** Change all pixels with the value '1' (blue) to '2' (red).\n2.  **Identify Existing Greens:** Locate pixels with a value '3'.\n3.  **Expand Existing Green Regions:** For each green (3) pixel, check for adjacent red (2) pixels. If a green pixel is next to a red pixel, expand the green region *vertically* upwards and downwards. Stop the expansion when an '8' (azure) pixel or the grid edge is encountered.\n4.  **Identify start row of Isolated Red Regions**: Locate distinct, non-connected regions of red (2) pixels. Find the row index for the start of each red region.\n5.  **Insert Green for Isolated Regions:** For each *isolated* red region (those *not* adjacent to any existing green regions *and* not directly adjacent to an expanding 3 region), insert green (3) pixels to the left of this region.\n6.  **Extend Inserted Green Vertically:** Extend the newly inserted green pixels vertically (up and down), stopping at an '8' pixel or the grid edge.\n7.  **Preserve background** Ensure that untouched '8' pixels remain unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef get_neighbors(grid, r, c):\n    \"\"\"Get the neighbors of a cell (including diagonals).\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef get_connected_regions(grid, value):\n    \"\"\"Find connected regions of a specific value.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    regions = []\n\n    def dfs(r, c, current_region):\n        if (\n            r < 0\n            or r >= rows\n            or c < 0\n            or c >= cols\n            or visited[r, c]\n            or grid[r, c] != value\n        ):\n            return\n        visited[r, c] = True\n        current_region.append((r, c))\n        for nr, nc in get_neighbors(grid, r, c):\n            dfs(nr, nc, current_region)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == value and not visited[r, c]:\n                current_region = []\n                dfs(r, c, current_region)\n                regions.append(current_region)\n    return regions\n\ndef transform(input_grid):\n    # Initialize output_grid\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # Replace Blues with Reds (1 -> 2)\n    output_grid[output_grid == 1] = 2\n\n    # Identify Existing Greens\n    existing_greens = np.argwhere(output_grid == 3)\n\n    # Expand Existing Green Regions\n    for r, c in existing_greens:\n        neighbors = get_neighbors(output_grid, r, c)\n        for nr, nc in neighbors:\n            if output_grid[nr, nc] == 2:\n                # Expand vertically upwards\n                ur = r - 1\n                while ur >= 0 and output_grid[ur, nc] != 8:\n                    output_grid[ur, nc] = 3\n                    ur -= 1\n                # Expand vertically downwards\n                dr = r + 1\n                while dr < rows and output_grid[dr, nc] != 8:\n                    output_grid[dr, nc] = 3\n                    dr += 1\n\n    # Identify Isolated Red Regions\n    red_regions = get_connected_regions(output_grid, 2)\n    isolated_red_regions = []\n    for region in red_regions:\n        has_adjacent_green = False\n        for r, c in region:\n            neighbors = get_neighbors(output_grid, r, c)\n            for nr, nc in neighbors:\n                if output_grid[nr, nc] == 3:\n                    has_adjacent_green = True\n                    break\n            if has_adjacent_green:\n                break\n        if not has_adjacent_green:\n            isolated_red_regions.append(region)\n\n\n    # Find Start Rows and insert green for Isolated Regions, extending vertically\n    for region in isolated_red_regions:\n      # find start row\n      min_row = min(r for r, c in region)\n      \n      # find any adjacent greens after initial expansion\n      adj_to_expanded = False\n      for r,c in region:\n        neighbors = get_neighbors(output_grid, r, c)\n        for nr, nc in neighbors:\n          if output_grid[nr,nc] == 3:\n            adj_to_expanded = True\n            break\n        if adj_to_expanded:\n          break\n\n      if not adj_to_expanded:      \n        # insert green to left of region\n        first_red_col = min(c for r, c in region)\n        for c in range(first_red_col):\n            output_grid[min_row, c] = 3\n\n        # expand inserted green up\n        ur = min_row - 1\n        while ur >= 0 and output_grid[ur, first_red_col -1] != 8:\n            for c in range(first_red_col):\n              output_grid[ur, c] = 3\n            ur -= 1\n        # expand inserted green down\n        dr = min_row + 1\n        while dr < rows and output_grid[dr, first_red_col - 1] != 8:\n          for c in range(first_red_col):\n            output_grid[dr, c] = 3\n          dr += 1\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15131,
    "candidates_token_count": 1411,
    "total_token_count": 16542,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 15.667625
}