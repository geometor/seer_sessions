{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by extracting rectangular blocks of non-white pixels,\ngrouping them by their effective width (including holes), and arranging these groups\nhorizontally in the output grid. Rectangles within each group are stacked\nvertically, maintaining their original horizontal order. The groups are sorted\nby the minimum horizontal position of any rectangle within them, and the layout is\ncompacted vertically.\n\"\"\"\n\nimport numpy as np\n\ndef get_rectangles(grid):\n    \"\"\"\n    Identifies and extracts rectangular blocks of non-white pixels, calculating\n    effective width including holes.\n    \"\"\"\n    rectangles = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, rect_coords):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        rect_coords.append((r, c))\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(r + dr, c + dc, color, rect_coords)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                rect_coords = []\n                dfs(r, c, grid[r, c], rect_coords)\n                if rect_coords:\n                    min_r = min(coord[0] for coord in rect_coords)\n                    max_r = max(coord[0] for coord in rect_coords)\n                    min_c = min(coord[1] for coord in rect_coords)\n                    max_c = max(coord[1] for coord in rect_coords)\n\n                    # Calculate effective width including holes\n                    relevant_cols = []\n                    for rr in range(min_r, max_r + 1):\n                        for cc in range(cols):\n                            if grid[rr,cc] == grid[r,c]:\n                                relevant_cols.append(cc)\n                    \n                    effective_min_c = min(relevant_cols)\n                    effective_max_c = max(relevant_cols)\n                    effective_width = effective_max_c - effective_min_c + 1\n                    \n                    rectangles.append({\n                        'color': grid[r, c],\n                        'min_r': min_r,\n                        'max_r': max_r,\n                        'min_c': effective_min_c,\n                        'max_c': effective_max_c,\n                        'height': max_r - min_r + 1,\n                        'width': effective_width,\n                        'coords': rect_coords,\n                        'original_min_c': min_c #store original for sorting\n                    })\n    return rectangles\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid as per the described rules.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    rectangles = get_rectangles(input_grid)\n\n    # Group rectangles by effective width\n    groups = {}\n    for rect in rectangles:\n        width = rect['width']\n        if width not in groups:\n            groups[width] = []\n        groups[width].append(rect)\n\n    # Sort rectangles within each group by their original minimum column and then row.\n    for width in groups:\n        groups[width].sort(key=lambda r: (r['original_min_c'], r['min_r']))\n\n    # Sort group keys by the minimum original_min_c of *any* rectangle within them.\n    sorted_group_keys = sorted(groups.keys(), key=lambda k: min(rect['original_min_c'] for rect in groups[k]))\n\n    # Create stacks for each group\n    stacks = []\n    for group_key in sorted_group_keys:\n        group = groups[group_key]\n        stack_height = sum(rect['height'] for rect in group)\n        stack_width = group_key  # Width is the key\n        stack = np.zeros((stack_height, stack_width), dtype=int)\n\n        curr_row = 0\n        for rect in group:\n            for r in range(rect['min_r'], rect['max_r'] + 1):\n                for c in range(rect['min_c'], rect['max_c'] + 1):\n                    if input_grid[r,c] == rect['color']:\n                        stack_c = c - rect['min_c']\n                        stack[curr_row + (r - rect['min_r']), stack_c] = rect['color']\n            curr_row += rect['height']\n        stacks.append(stack)\n    \n    # compact stacks\n    compacted_stacks = []\n    for stack in stacks:\n        \n        #find first row with non-zero entry\n        first_non_zero = 0\n        for i in range(stack.shape[0]):\n            if np.any(stack[i,:] != 0):\n                first_non_zero = i\n                break\n        compacted_stacks.append(stack[first_non_zero:,:])\n\n    # Calculate output dimensions and arrange stacks horizontally\n    output_width = sum(stack.shape[1] for stack in compacted_stacks)\n    output_height = max(stack.shape[0] for stack in compacted_stacks)\n\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    curr_col = 0\n    for stack in compacted_stacks:\n        output_grid[:stack.shape[0], curr_col:curr_col + stack.shape[1]] = stack\n        curr_col += stack.shape[1]\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8983,
    "candidates_token_count": 1375,
    "total_token_count": 10358,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 16.049736
}