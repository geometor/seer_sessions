{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms input grids based on a combination of rectangle detection, color transformations, and neighborhood analysis.\n\n1. **Rectangle-Based Transformations:**\n   - Identify all rectangular regions of uniform color.\n   - Remove blue (1) rectangles.\n   - Change the interior of red (2) rectangles to gray (5), keeping the border.\n   - For azure (8) rectangles (width and height > 2) surrounded by yellow (4) or magenta (6), fill the interior with green (3) and, if the bottom edge touches a non-azure, non-white pixel, change the bottom edge to green.\n\n2. **Neighborhood-Based Transformations:**\n   - Remove green (3) pixels surrounded by blue (1) pixels.\n   - Analyze cases where green (3) changes to white (0), and red (2) interior changes to gray (5) that may not have been captured by rectangle rules.\n\n3. **Additional Edge Cases**\n   - Examine edge cases and inconsistencies to further refine transformations.\n\n\"\"\"\n\nimport numpy as np\n\ndef find_rectangles(grid):\n    \"\"\"\n    Finds all rectangular regions of uniform color in a grid.\n    Returns a list of tuples: (color, (row_start, col_start), (row_end, col_end)).\n    \"\"\"\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c]:\n                color = grid[r, c]\n                r_start, c_start = r, c\n                r_end, c_end = r, c\n\n                # Expand right\n                while c_end + 1 < cols and grid[r, c_end + 1] == color and not visited[r, c_end+1]:\n                    c_end += 1\n\n                # Expand down\n                while r_end + 1 < rows and all(grid[r_end + 1, c_start:c_end + 1] == color) and not any(visited[r_end+1, c_start:c_end+1]):\n                    r_end += 1\n\n                # Mark visited\n                visited[r_start:r_end + 1, c_start:c_end + 1] = True\n                rectangles.append((color, (r_start, c_start), (r_end, c_end)))\n    return rectangles\n\ndef is_surrounded_by(grid, r_start, c_start, r_end, c_end, surrounding_color):\n    \"\"\"\n    Checks if a rectangular region is surrounded by a specific color.\n    \"\"\"\n    rows, cols = grid.shape\n\n    # Check top\n    if r_start > 0 and not all(grid[r_start - 1, c_start:c_end + 1] == surrounding_color):\n        return False\n    # Check bottom\n    if r_end < rows - 1 and not all(grid[r_end + 1, c_start:c_end + 1] == surrounding_color):\n        return False\n    # Check left\n    if c_start > 0 and not all(grid[r_start:r_end + 1, c_start - 1] == surrounding_color):\n        return False\n    # Check right\n    if c_end < cols - 1 and not all(grid[r_start:r_end + 1, c_end + 1] == surrounding_color):\n        return False\n\n    # Check corners (top-left)\n    if r_start > 0 and c_start > 0 and grid[r_start-1, c_start-1] != surrounding_color:\n        return False\n    # Check corners (top-right)\n    if r_start > 0 and c_end < cols - 1 and grid[r_start-1, c_end+1] != surrounding_color:\n      return False\n    # Check corners (bottom-left)\n    if r_end < rows - 1 and c_start > 0 and grid[r_end+1, c_start -1] != surrounding_color:\n      return False\n    # Check corners (bottom-right)\n    if r_end < rows -1 and c_end < cols - 1 and grid[r_end+1, c_end+1] != surrounding_color:\n      return False\n\n    return True\n\ndef remove_surrounded(grid, color_to_remove, surrounding_color):\n  \"\"\"Removes contiguous regions of color_to_remove if surrounded by surrounding_color.\"\"\"\n  rows, cols = grid.shape\n  output_grid = grid.copy()\n  visited = np.zeros_like(grid, dtype=bool)\n\n  for r in range(rows):\n      for c in range(cols):\n          if not visited[r, c] and grid[r, c] == color_to_remove:\n              # BFS to find connected region\n              region = []\n              queue = [(r, c)]\n              visited[r, c] = True\n              \n              while queue:\n                curr_r, curr_c = queue.pop(0)\n                region.append((curr_r, curr_c))\n\n                neighbors = [(curr_r-1, curr_c), (curr_r+1, curr_c), (curr_r, curr_c-1), (curr_r, curr_c+1)]\n                for nr, nc in neighbors:\n                  if(0 <= nr < rows and 0 <= nc < cols and not visited[nr,nc] and grid[nr,nc] == color_to_remove):\n                    visited[nr,nc] = True\n                    queue.append((nr,nc))\n\n              # Check if surrounded\n              surrounded = True\n              for curr_r, curr_c in region:\n                neighbors = [(curr_r-1, curr_c), (curr_r+1, curr_c), (curr_r, curr_c-1), (curr_r, curr_c+1),\n                            (curr_r-1, curr_c-1), (curr_r+1, curr_c-1), (curr_r-1, curr_c+1), (curr_r+1, curr_c+1)]\n                for nr, nc in neighbors:\n                  if not (0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == surrounding_color or (nr,nc) in region)):\n                      surrounded = False\n                      break\n\n                if not surrounded:\n                  break\n\n\n              # Remove if surrounded\n              if surrounded:\n                  for curr_r, curr_c in region:\n                      output_grid[curr_r, curr_c] = 0\n\n  return output_grid\n\ndef transform(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Remove green surrounded by blue (using the existing function)\n    output_grid = remove_surrounded(output_grid, 3, 1)\n\n    # Find rectangles (using the existing function)\n    rectangles = find_rectangles(output_grid)\n\n    # Rectangle transformations\n    for color, (r_start, c_start), (r_end, c_end) in rectangles:\n        # Remove blue rectangles\n        if color == 1:\n            output_grid[r_start:r_end+1, c_start:c_end+1] = 0\n        # Red interior to gray\n        elif color == 2:\n            output_grid[r_start+1:r_end, c_start+1:c_end] = 5\n        # Azure rectangle transformation (existing logic)\n        elif color == 8:\n            if r_end - r_start + 1 > 2 and c_end - c_start + 1 > 2:\n                if is_surrounded_by(input_grid, r_start, c_start, r_end, c_end, 4) or is_surrounded_by(input_grid, r_start, c_start, r_end, c_end, 6):\n                    output_grid[r_start+1:r_end, c_start+1:c_end] = 3\n                    rows, cols = output_grid.shape\n                    if r_end < rows - 1:\n                      for col in range(c_start, c_end + 1):\n                        if output_grid[r_end+1,col] != 8 and output_grid[r_end+1,col] != 0:\n                            output_grid[r_end,col] = 3\n                            break\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16606,
    "candidates_token_count": 2015,
    "total_token_count": 18621,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 18.001652
}