{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Green Components:** Locate all disconnected green (color 3)\n    components in the input grid. Each separate contiguous block of green\n    pixels is a distinct component.\n\n2.  **Reposition Green Components:** Move each identified green component to\n    the top-left region of the output grid.\n    *   Maintain the original shape of each green component.\n    *   Preserve the relative vertical and horizontal positions *between* the\n        green components. Start placing at (0,0), and subsequent components\n        are positioned relative to the already placed ones, matching the\n        relative positioning they had in the input.\n    *   After moving the green components, fill the positions that used to\n        have a green object with black pixels (value 0).\n\n3.  **Identify and Remove Blue and Yellow Objects:**\n    *   Locate a 2x1 block of blue (color 1) pixels.\n    *   Locate a single yellow (color 4) pixel directly adjacent to the 2x1\n        blue block.\n    *   Remove both the identified blue and yellow objects by setting the\n        pixel to 0.\n\n4. **Output Grid:** The output grid should contain the repositioned green\n   components and zeros in all other cells.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid, color):\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, current_object):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        current_object.append((r, c))\n        dfs(r + 1, c, current_object)\n        dfs(r - 1, c, current_object)\n        dfs(r, c + 1, current_object)\n        dfs(r, c - 1, current_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                current_object = []\n                dfs(r, c, current_object)\n                objects.append(current_object)\n    return objects\n\ndef get_object_shape(object_coords):\n    min_row = min(r for r, c in object_coords)\n    max_row = max(r for r, c in object_coords)\n    min_col = min(c for r, c in object_coords)\n    max_col = max(c for r, c in object_coords)\n    shape = []\n    for r, c in object_coords:\n        shape.append((r - min_row, c - min_col))\n    return shape, (max_row - min_row + 1, max_col - min_col + 1)\n\ndef find_2x1_blue_and_adjacent_yellow(grid):\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            # Check for 2x1 blue\n            if c + 1 < cols and grid[r, c] == 1 and grid[r, c + 1] == 1:\n                # Check for adjacent yellow\n                if c + 2 < cols and grid[r,c+2] == 4:\n                    return (r, c), (r, c + 1), (r, c+2)\n                if c - 1 >= 0 and grid[r,c-1] == 4:\n                    return (r, c), (r, c + 1), (r, c-1)\n                if r + 1 < rows:\n                    if grid[r+1,c] == 4:\n                        return (r, c), (r, c+1), (r+1, c)\n                    if c + 1 < cols and grid[r+1, c+1] == 4:\n                        return (r, c), (r, c + 1), (r+1, c+1)\n                if r - 1 >= 0:\n                    if grid[r-1,c] == 4:\n                        return (r, c), (r, c+1), (r-1, c)\n                    if c+1 < cols and grid[r-1,c+1] == 4:\n                        return (r, c), (r, c + 1), (r-1, c+1)\n            elif r + 1 < rows and grid[r,c] == 1 and grid[r+1,c] == 1:\n                if c + 1 < cols and grid[r,c+1] == 4:\n                    return (r, c), (r+1, c), (r, c+1)\n                if r + 1 < rows and c + 1 < cols and grid[r+1, c+1] == 4:\n                        return (r, c), (r+1, c), (r+1, c+1)\n                if c - 1 >= 0 and grid[r,c-1] == 4:\n                    return (r, c), (r+1, c), (r, c-1)\n                if r + 1 < rows and c - 1 >= 0 and grid[r+1, c - 1] == 4:\n                        return (r, c), (r+1, c), (r+1, c - 1)\n                if r + 2 < rows and grid[r+2,c] == 4:\n                    return (r,c), (r+1,c), (r+2,c)\n                if r - 1 >= 0 and grid[r-1,c] == 4:\n                    return (r,c), (r+1,c), (r-1,c)\n\n    return None, None, None\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n    input_grid_copy = np.copy(input_grid)\n\n    # Find green components\n    green_objects = find_objects(input_grid_copy, 3)\n\n    # Reposition Green Components\n    current_row = 0\n    current_col = 0\n    for obj in green_objects:\n        shape, (height, width) = get_object_shape(obj)\n\n        for r, c in shape:\n            output_grid[current_row + r, current_col + c] = 3\n        current_row += height #simple stack\n\n        #clear object after placement\n        for r,c in obj:\n            input_grid_copy[r][c] = 0\n\n    # Find and Remove Blue and Yellow Objects\n    blue1, blue2, yellow = find_2x1_blue_and_adjacent_yellow(input_grid_copy)\n    if blue1:\n        input_grid_copy[blue1] = 0\n        input_grid_copy[blue2] = 0\n        input_grid_copy[yellow] = 0\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4126,
    "candidates_token_count": 1687,
    "total_token_count": 5813,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 29.998944
}