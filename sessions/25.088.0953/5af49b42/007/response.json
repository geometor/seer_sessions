{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict\n\n\"\"\"\nTransforms an input grid based on patterns found in its last row and trigger pixels above it.\n\n1. Analyzes the last row of the input grid to find all contiguous horizontal sequences of non-white pixels.\n2. Creates a mapping from each unique non-white color found in these sequences to the first sequence it appears in (from left to right) and its index (first occurrence) within that sequence.\n3. Identifies all non-white 'trigger' pixels in the grid rows above the last row.\n4. Initializes an output grid as a copy of the input grid.\n5. For each trigger pixel:\n    a. Looks up the trigger pixel's color in the mapping.\n    b. If found, retrieves the associated sequence and the color's index within that sequence.\n    c. Calculates the starting column to paste the sequence in the trigger's row, aligning the sequence based on the trigger's column and the color's index within the sequence.\n    d. Pastes the retrieved sequence onto the trigger pixel's row in the output grid, overwriting existing pixels. Pasting is clipped to the grid boundaries.\n6. The last row of the grid remains unchanged in the output.\n7. Returns the modified output grid.\n\"\"\"\n\ndef find_sequences_and_mapping(grid: np.ndarray) -> Tuple[List[List[int]], Dict[int, Tuple[List[int], int]]]:\n    \"\"\"\n    Finds all contiguous sequences of non-white colors in the last row\n    and creates a mapping from each color within those sequences to the\n    sequence itself and the color's first index within that sequence.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - A list of all sequences found (each sequence is a list of ints).\n        - A dictionary mapping each color found in the sequences to a tuple:\n          (the list representing the first sequence containing the color, \n           the first index of the color in that sequence).\n          If a color appears in multiple sequences, it maps to the first sequence \n          (left-to-right) it appears in.\n    \"\"\"\n    sequences = []\n    color_to_sequence_map = {}\n    last_row = grid[-1, :]\n    width = grid.shape[1]\n    \n    current_sequence = []\n    in_sequence = False\n    \n    # Scan the last row to identify sequences\n    for c, color in enumerate(last_row):\n        if color != 0: # Non-white pixel (value 0 is white)\n            if not in_sequence:\n                # Start of a new sequence\n                in_sequence = True\n                current_sequence = [color]\n            else:\n                # Continue existing sequence\n                current_sequence.append(color)\n        else: # White pixel\n            if in_sequence:\n                # End of the current sequence\n                in_sequence = False\n                if current_sequence:\n                    # Store the sequence *as a new list* to avoid reference issues\n                    finalized_sequence = list(current_sequence)\n                    sequences.append(finalized_sequence)\n                    # Update mapping for colors in this sequence\n                    # Only map a color the *first* time it's seen in any sequence\n                    for idx, seq_color in enumerate(finalized_sequence):\n                        if seq_color not in color_to_sequence_map:\n                             # Map color to the finalized sequence list and its index\n                             color_to_sequence_map[seq_color] = (finalized_sequence, idx)\n                    current_sequence = [] # Reset for next potential sequence\n\n    # Handle sequence ending at the right edge of the grid\n    if in_sequence and current_sequence:\n        finalized_sequence = list(current_sequence)\n        sequences.append(finalized_sequence)\n        # Update mapping for colors in this sequence\n        for idx, seq_color in enumerate(finalized_sequence):\n            if seq_color not in color_to_sequence_map:\n                 color_to_sequence_map[seq_color] = (finalized_sequence, idx)\n\n    return sequences, color_to_sequence_map\n\ndef find_triggers(grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Finds all non-white pixels (triggers) in the grid, excluding the last row.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains (row, column, color)\n        for a trigger pixel.\n    \"\"\"\n    triggers = []\n    height, width = grid.shape\n    # Iterate through rows, excluding the last one (index height - 1)\n    for r in range(height - 1):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0: # Non-white pixel\n                triggers.append((r, c, color))\n    return triggers\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input (Step 1 / Step 4 in Docstring)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # Step 1 & 2 (Docstring): Analyze Last Row - Find sequences and build the color map\n    sequences, color_map = find_sequences_and_mapping(input_array)\n\n    # If no sequences are found in the last row, or the map is empty (no non-white colors in sequences),\n    # then no transformation can occur based on the rules. Return the original grid.\n    if not sequences or not color_map:\n        return output_array.tolist()\n\n    # Step 3 (Docstring): Identify Triggers - Find all non-white pixels above the last row\n    triggers = find_triggers(input_array)\n\n    # Step 5 (Docstring): Transform Rows - Process each trigger\n    for r, c, trigger_color in triggers:\n        # Step 5a: Check if the trigger color exists as a key in our map\n        if trigger_color in color_map:\n            # Step 5b: Look up the associated sequence and the index of the trigger color within it\n            target_sequence, color_index_in_sequence = color_map[trigger_color]\n            sequence_len = len(target_sequence)\n\n            # Step 5c: Calculate the starting column for pasting the sequence\n            # The sequence should be placed such that the column 'c' (trigger's column) \n            # aligns with the 'color_index_in_sequence' within the pasted sequence.\n            paste_start_col = c - color_index_in_sequence\n            \n            # Step 5d: Iterate through the sequence and paste it onto the output grid row 'r'\n            for i, seq_color in enumerate(target_sequence):\n                target_col = paste_start_col + i\n                # Check if the target column is within the grid boundaries (clipping)\n                if 0 <= target_col < width:\n                    # Update the output grid pixel. This overwrites previous values.\n                    output_array[r, target_col] = seq_color\n            \n    # Step 6 (Docstring): Last row remains unchanged (handled by initial copy and selective updates)\n    # Step 7 (Docstring): Finalize - Convert the numpy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18455,
    "candidates_token_count": 1769,
    "total_token_count": 20224,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.064833,
  "retries": null
}