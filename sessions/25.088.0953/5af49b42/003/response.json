{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict\n\ndef find_sequences_and_mapping(grid: np.ndarray) -> Tuple[List[List[int]], Dict[int, Tuple[List[int], int]]]:\n    \"\"\"\n    Finds all contiguous sequences of non-white colors in the last row\n    and creates a mapping from each color within those sequences to the\n    sequence itself and the color's first index within that sequence.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - A list of all sequences found (each sequence is a list of ints).\n        - A dictionary mapping each color found in the sequences to a tuple:\n          (the sequence containing the color, the first index of the color in that sequence).\n          If a color appears in multiple sequences, it maps to the first sequence it appears in.\n    \"\"\"\n    sequences = []\n    color_to_sequence_map = {}\n    last_row = grid[-1, :]\n    width = grid.shape[1]\n    \n    current_sequence = []\n    in_sequence = False\n    start_index_in_row = -1\n\n    for c, color in enumerate(last_row):\n        if color != 0: # Non-white pixel\n            if not in_sequence:\n                # Start of a new sequence\n                in_sequence = True\n                start_index_in_row = c\n                current_sequence = [color]\n            else:\n                # Continue existing sequence\n                current_sequence.append(color)\n        else: # White pixel\n            if in_sequence:\n                # End of the current sequence\n                in_sequence = False\n                if current_sequence:\n                    sequences.append(current_sequence)\n                    # Update mapping for colors in this sequence\n                    for idx, seq_color in enumerate(current_sequence):\n                        if seq_color not in color_to_sequence_map:\n                             color_to_sequence_map[seq_color] = (current_sequence, idx)\n                    current_sequence = [] # Reset for next potential sequence\n\n    # Handle sequence ending at the edge of the grid\n    if in_sequence and current_sequence:\n        sequences.append(current_sequence)\n        for idx, seq_color in enumerate(current_sequence):\n            if seq_color not in color_to_sequence_map:\n                 color_to_sequence_map[seq_color] = (current_sequence, idx)\n\n    return sequences, color_to_sequence_map\n\ndef find_triggers(grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Finds all non-white pixels (triggers) in the grid, excluding the last row.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains (row, column, color)\n        for a trigger pixel.\n    \"\"\"\n    triggers = []\n    height, width = grid.shape\n    # Iterate through rows, excluding the last one\n    for r in range(height - 1):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0:\n                triggers.append((r, c, color))\n    return triggers\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Identifies color sequences in the bottom row of the input grid.\n    Finds non-white 'trigger' pixels in the rest of the grid.\n    For each trigger pixel, determines which sequence its color belongs to\n    in the bottom row.\n    Copies the corresponding sequence onto the trigger pixel's row, aligning\n    it such that the trigger pixel's original position corresponds to the\n    position of its color within the sequence. Overwrites existing pixels,\n    including the trigger pixel itself. Clips the sequence if it extends\n    beyond the grid boundaries. The last row remains unchanged.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # Find sequences in the last row and the mapping from colors to sequences/indices\n    sequences, color_map = find_sequences_and_mapping(input_array)\n\n    # If no sequences are found, or the map is empty, return the original grid\n    if not sequences or not color_map:\n        return output_array.tolist()\n\n    # Find trigger pixels (non-white pixels above the last row)\n    triggers = find_triggers(input_array)\n\n    # Process each trigger\n    for r, c, trigger_color in triggers:\n        # Check if the trigger color exists in any of the sequences\n        if trigger_color in color_map:\n            # Get the corresponding sequence and the index of the trigger color within it\n            sequence, color_index_in_sequence = color_map[trigger_color]\n            sequence_len = len(sequence)\n\n            # Calculate the starting column for pasting the sequence\n            # The sequence should be placed such that the position 'c' aligns with 'color_index_in_sequence'\n            paste_start_col = c - color_index_in_sequence\n            \n            # Iterate through the sequence and paste it onto the output grid row 'r'\n            for i, seq_color in enumerate(sequence):\n                target_col = paste_start_col + i\n                # Check if the target column is within the grid boundaries\n                if 0 <= target_col < width:\n                    output_array[r, target_col] = seq_color\n            \n    # Return the modified grid as a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5502,
    "candidates_token_count": 1321,
    "total_token_count": 6823,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.215786,
  "retries": null
}