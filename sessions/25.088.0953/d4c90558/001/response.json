{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies non-white, non-gray contiguous shapes (\"containers\") in the input grid.\nFor each container, counts the number of gray pixels strictly enclosed within its bounding box.\nConstructs an output grid where each row corresponds to a container.\nThe color of the row matches the container's color.\nThe number of colored cells in the row equals the count of enclosed gray pixels for that container.\nThe rows are sorted in ascending order based on the count of enclosed gray pixels.\nThe width of the output grid is determined by the maximum count of enclosed gray pixels found in any container.\n\"\"\"\n\ndef find_connected_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component of the same color starting from (start_r, start_c) using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): Boolean array marking visited cells.\n\n    Returns:\n        tuple: (color, list_of_pixels)\n               color (int): The color of the component.\n               list_of_pixels (list): A list of (row, col) tuples for the component's pixels.\n               Returns (None, []) if the starting pixel is already visited or invalid.\n    \"\"\"\n    rows, cols = grid.shape\n    if not (0 <= start_r < rows and 0 <= start_c < cols) or visited[start_r, start_c]:\n        return None, []\n\n    target_color = grid[start_r, start_c]\n    pixels = []\n    queue = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n\n    while queue:\n        r, c = queue.popleft()\n        pixels.append((r, c))\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not visited[nr, nc] and grid[nr, nc] == target_color:\n                visited[nr, nc] = True\n                queue.append((nr, nc))\n\n    return target_color, pixels\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a list of pixels.\n\n    Args:\n        pixels (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, max_r, min_c, max_c) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying containers and counting enclosed gray pixels.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    visited = np.zeros_like(input_np, dtype=bool)\n    container_data = []\n\n    # 1. Scan the input grid to identify all distinct contiguous objects (containers)\n    #    that are not white (0) or gray (5).\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = input_np[r, c]\n            if pixel_color != 0 and pixel_color != 5 and not visited[r, c]:\n                # Found a potential start of a container\n                container_color, container_pixels = find_connected_component(input_np, r, c, visited)\n\n                if container_pixels:\n                    # 2a. Record its primary color.\n                    # (Done above: container_color)\n\n                    # 2b. Determine its bounding box.\n                    bounding_box = get_bounding_box(container_pixels)\n                    if bounding_box:\n                        min_r, max_r, min_c, max_c = bounding_box\n\n                        # 2c. Count the number of gray (5) pixels located strictly within this bounding box.\n                        gray_count = 0\n                        for rr in range(min_r + 1, max_r):\n                            for cc in range(min_c + 1, max_c):\n                                if input_np[rr, cc] == 5:\n                                    gray_count += 1\n\n                        # 2d. Store the container's color and the count of gray pixels.\n                        container_data.append({'color': container_color, 'count': gray_count})\n\n    # 3. Collect all such (color, count) pairs. (Done in container_data)\n\n    # 4. Sort these pairs in ascending order based on the count.\n    sorted_data = sorted(container_data, key=lambda item: item['count'])\n\n    # 5. Calculate the required height of the output grid.\n    output_height = len(sorted_data)\n\n    # 6. Calculate the required width of the output grid.\n    output_width = 0\n    if sorted_data:\n        output_width = max(item['count'] for item in sorted_data)\n\n    # 7. Create a new grid with the calculated height and width, initially filled with white (0).\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 8. Iterate through the sorted (color, count) pairs and populate the output grid.\n    for i, item in enumerate(sorted_data):\n        color = item['color']\n        count = item['count']\n        # Fill the first 'count' cells of row 'i' with the color 'c'.\n        # Remaining cells default to white (0).\n        if count > 0: # Ensure count is positive before slicing\n            output_grid[i, :count] = color\n\n    # 9. The resulting grid is the final output.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5162,
    "candidates_token_count": 1530,
    "total_token_count": 6692,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.896354,
  "retries": null
}