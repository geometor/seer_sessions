
## train_1

**input:**
```
0 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 0 0 0 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 0 0 0 5 0 0 8 8 8 0 0 0 0 1 1 1 1 1 1 0 0 0
0 8 0 0 5 0 0 0 0 8 8 8 0 0 0 0 1 0 5 0 0 1 0 0 0
0 8 0 5 0 0 0 0 0 8 8 8 0 0 0 0 1 0 0 0 0 1 0 0 0
0 8 0 0 0 0 0 5 0 8 8 8 0 0 0 0 1 0 0 5 0 1 0 0 0
0 8 0 0 0 0 0 0 0 8 8 8 0 0 0 0 1 1 1 1 1 1 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 5 0 0 0 0 0 5 0 0 0 0 5 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 5 0 0 0 0 0 5 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 5 0 0 0 5 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 0 0
0 0 0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 1 0 0 0 0 0 0
8 8 8 8 0 0 0 0
7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 6 6 0 0 0
0 0 0 0 0 6 0 0 0 0 0 5 0 0 0 6 6 0 0 0
0 0 0 0 0 6 0 0 5 0 5 0 0 0 0 6 6 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 6 6 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 5 0 6 6 0 0 0
0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
0 2 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 0 0 5 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 5 0 5 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 0
6 6 6 6
```


## train_3

**input:**
```
0 0 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0 3 0 0 8 8 8 8 8 0 0
0 0 3 0 0 5 0 0 0 0 3 0 0 8 0 0 0 8 0 0
0 0 3 5 0 5 0 0 0 0 3 0 0 8 5 0 0 8 0 0
0 0 3 0 0 0 0 0 5 0 3 0 0 8 0 5 0 8 0 0
0 0 3 0 0 0 0 0 0 0 3 0 0 8 0 0 0 8 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 8 8 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4 4 4 4
0 2 2 2 2 2 2 2 2 0 0 4 4 4 4 4 4 4 4 4
0 2 0 0 0 0 5 0 2 0 0 4 0 0 0 0 0 0 0 4
0 2 0 5 0 0 0 0 2 0 0 4 0 5 0 5 0 0 0 4
0 2 0 5 0 5 0 0 2 0 0 4 0 0 0 0 5 0 5 4
0 2 0 0 0 0 0 5 2 0 0 4 0 0 0 0 0 0 0 4
0 2 0 0 0 0 0 0 2 0 0 4 0 0 5 0 5 0 0 4
0 2 2 2 2 2 2 2 2 0 0 4 0 0 0 0 0 0 0 4
0 2 2 2 2 2 2 2 2 0 0 4 4 4 4 4 4 4 4 4
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 0 0 0 0
3 3 3 3 0 0
2 2 2 2 2 0
4 4 4 4 4 4
```

*   **Perception**: The input grids contain several distinct, hollow, rectangular or square shapes ("containers"), each made of a single color (other than white or gray). Inside the hollow space of each container, there are one or more gray pixels. The output grid summarizes information about these containers and their contained gray pixels. Each row in the output corresponds to one container from the input. The color of the row is the color of the container, and the number of colored cells in the row equals the number of gray pixels found inside that container. The rows in the output grid are sorted based on the count of contained gray pixels, in ascending order. The width of the output grid is determined by the maximum number of gray pixels found in any single container.

*   **Facts**:
    
```yaml
    objects:
      - type: grid
        role: input
        contains:
          - type: shape
            role: container
            attributes:
              - color: variable (not white=0, not gray=5)
              - shape: hollow rectangle/square
              - encloses:
                  - type: pixel
                    role: content
                    attributes:
                      - color: gray=5
                      - count: variable (>=1)
                      - location: inside the hollow space of a container
          - type: pixel
            role: background
            attributes:
              - color: white=0
      - type: grid
        role: output
        attributes:
          - height: equals the number of container objects in the input
          - width: equals the maximum count of gray pixels enclosed by any single container
        contains:
          - type: row
            count: same as number of containers
            attributes:
              - represents: one container from the input
              - structure:
                  - sequence of pixels of container's color
                  - followed by sequence of white pixels
              - length_colored_sequence: equals the count of gray pixels enclosed by the corresponding container
              - total_length: equals the width of the output grid
            relationships:
              - sorted_by: length_colored_sequence (ascending)

    relationships:
      - input_container_color -> output_row_color
      - input_enclosed_gray_pixel_count -> output_row_colored_pixel_count
      - input_container_count -> output_grid_height
      - input_max_enclosed_gray_pixel_count -> output_grid_width
      - sorting_criterion: input_enclosed_gray_pixel_count (ascending) determines output row order

    actions:
      - identify_containers: Find contiguous blocks of pixels with the same color, excluding white and gray.
      - identify_bounding_boxes: Determine the min/max row/column for each container.
      - identify_enclosed_pixels: Find all gray pixels located within the bounding box of each container.
      - count_enclosed_pixels: Count the number of gray pixels for each container.
      - associate_count_with_color: Pair the count with the container's color.
      - sort_pairs: Sort the (color, count) pairs based on the count in ascending order.
      - determine_output_dimensions: Find the number of pairs (height) and the maximum count (width).
      - construct_output_grid: Create the grid and populate rows based on sorted pairs, filling with color up to the count, then padding with white.
    ```


*   **Natural Language Program**:
    1.  Scan the input grid to identify all distinct contiguous objects (shapes) that are not white (0) or gray (5). These are the "containers".
    2.  For each container found:
        a.  Record its primary color.
        b.  Determine its bounding box (minimum and maximum row and column).
        c.  Count the number of gray (5) pixels located strictly within this bounding box.
        d.  Store the container's color and the count of gray pixels associated with it as a pair (color, count).
    3.  Collect all such (color, count) pairs.
    4.  Sort these pairs in ascending order based on the count.
    5.  Calculate the required height of the output grid, which is equal to the total number of containers found.
    6.  Calculate the required width of the output grid, which is equal to the maximum count found among all pairs.
    7.  Create a new grid with the calculated height and width, initially filled with white (0).
    8.  Iterate through the sorted (color, count) pairs:
        a.  For the current pair (c, n) at index `i` (starting from 0), populate the `i`-th row of the output grid.
        b.  Fill the first `n` cells of row `i` with the color `c`.
        c.  Leave the remaining cells in row `i` as white (0).
    9.  The resulting grid is the final output.
