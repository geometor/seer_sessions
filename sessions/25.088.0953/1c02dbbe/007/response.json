{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1.  **Initialize:** Create the output grid as an exact copy of the input grid.\n2.  **Identify Markers and Regions:**\n    a.  Find all \"marker pixels\" in the input grid (pixels neither white (0) nor gray (5)). Record the location (row, column) and color of each marker pixel. Store these in a list `all_markers`.\n    b.  Group the marker pixel locations by their color into a dictionary `marker_locations_by_color`.\n    c.  For each unique marker color `C` found:\n        i.  Determine the rectangular bounding box `B_C` that minimally encloses all marker pixels of color `C`. Store these bounding boxes, e.g., in `bboxes_by_color`.\n        ii. Identify the set of coordinates `F_C` (the \"fill region\") corresponding to pixels that are gray (5) in the *input* grid and fall within the bounding box `B_C`. Store these fill regions, e.g., in `fill_regions_by_color`.\n3.  **Apply Fill:**\n    a.  For each unique marker color `C` and its corresponding fill region `F_C`:\n        i.  Iterate through every coordinate `(r, c)` in the fill region `F_C`.\n        ii. Set the color of the pixel at `(r, c)` in the *output* grid to color `C`.\n4.  **Handle Original Markers:**\n    a.  Iterate through *all* original marker pixel locations `(r, c)` with their original color `C_marker` from the `all_markers` list.\n    b.  Retrieve the bounding box `B_{C_marker}` calculated for that specific color `C_marker` from `bboxes_by_color`.\n    c.  Check if the location `(r, c)` is contained within the bounding box `B_{C_marker}`.\n    d.  If `(r, c)` is **within** `B_{C_marker}`:\n        i.  Set the color of the pixel at `(r, c)` in the *output* grid to `C_marker`. (This ensures the marker persists, potentially overwriting a color filled in step 3 if bounding boxes overlap).\n    e.  If `(r, c)` is **not within** `B_{C_marker}`:\n        i.  Set the color of the pixel at `(r, c)` in the *output* grid to white (0). (This erases markers used only to define the box extent).\n5.  **Return:** Return the final modified output grid.\n\"\"\"\n\ndef find_markers_and_group(grid):\n    \"\"\"\n    Identifies marker pixels (not white 0 or gray 5) and groups them.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - marker_locations_by_color (dict): Maps color -> list of (row, col) coords.\n        - all_markers (list): List of tuples (row, col, color) for every marker.\n    \"\"\"\n    marker_locations_by_color = {}\n    all_markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the pixel is a marker (not white 0 and not gray 5)\n            if color != 0 and color != 5:\n                if color not in marker_locations_by_color:\n                    marker_locations_by_color[color] = []\n                marker_locations_by_color[color].append((r, c))\n                all_markers.append((r, c, color))\n    return marker_locations_by_color, all_markers\n\ndef calculate_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\n\n    Args:\n        coords: A list of (row, col) tuples.\n\n    Returns:\n        A tuple (min_r, min_c, max_r, max_c) representing the bounding box.\n        Returns None if the coords list is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Marker pixels define bounding boxes. Gray pixels within these boxes are\n    recolored with the marker color. Original markers are kept if they fall\n    within their color's bounding box, otherwise erased to white.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Initialize output grid as a copy of the input grid.\n    output_grid = np.copy(input_np)\n\n    # 2a. Identify all marker pixels and their locations/colors.\n    # 2b. Group marker locations by color.\n    marker_locations_by_color, all_markers = find_markers_and_group(input_np)\n\n    # 2c. Calculate bounding boxes and fill regions for each marker color.\n    bboxes_by_color = {}\n    fill_regions_by_color = {}\n    for color, coords in marker_locations_by_color.items():\n        # 2c.i. Determine bounding box.\n        bbox = calculate_bounding_box(coords)\n        if bbox is None: # Should not happen if color has coords, but safety check\n            continue\n        bboxes_by_color[color] = bbox # Store the bounding box\n\n        min_r, min_c, max_r, max_c = bbox\n\n        # 2c.ii. Calculate the fill region (intersection of bbox and input gray pixels).\n        fill_region = set()\n        for r_fill in range(min_r, max_r + 1):\n            for c_fill in range(min_c, max_c + 1):\n                # Ensure coordinates are within grid bounds (redundant check with bbox logic)\n                if 0 <= r_fill < rows and 0 <= c_fill < cols:\n                    # Check if the *original input grid* pixel is gray (5)\n                    if input_np[r_fill, c_fill] == 5:\n                        fill_region.add((r_fill, c_fill))\n\n        fill_regions_by_color[color] = fill_region\n\n    # 3. Apply Fill: Update output grid based on calculated fill regions.\n    for color, fill_region in fill_regions_by_color.items():\n        for r, c in fill_region:\n            # Check bounds again just in case, although set logic should be correct\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_grid[r, c] = color\n\n    # 4. Handle Original Markers: Determine persistence based on bounding box.\n    # 4a. Iterate through all original marker locations.\n    for r, c, marker_color in all_markers:\n        # Check if coordinates are valid (should always be)\n        if not (0 <= r < rows and 0 <= c < cols):\n             continue\n\n        # 4b. Retrieve the bounding box for this marker's color.\n        # Use .get() in case a marker somehow didn't generate a bbox (shouldn't happen).\n        bbox = bboxes_by_color.get(marker_color)\n\n        is_within_bbox = False\n        if bbox:\n            min_r, min_c, max_r, max_c = bbox\n            if min_r <= r <= max_r and min_c <= c <= max_c:\n                is_within_bbox = True\n\n        # 4d. If marker is within its bounding box, ensure it has its color.\n        if is_within_bbox:\n            output_grid[r, c] = marker_color\n        # 4e. If marker is outside its bounding box, erase it (set to white).\n        else:\n            output_grid[r, c] = 0\n\n    # 5. Return the final output grid, converted back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17844,
    "candidates_token_count": 2001,
    "total_token_count": 19845,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.223904,
  "retries": null
}