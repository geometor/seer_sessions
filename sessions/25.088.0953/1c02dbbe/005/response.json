{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n\n1.  **Initialize:** Create the output grid as an exact copy of the input grid.\n2.  **Identify Markers and Regions:**\n    a.  Find all \"marker pixels\" in the input grid. A marker pixel is any pixel whose color is not white (0) and not gray (5). Record the location (row, column) and color of each marker pixel.\n    b.  Group the marker pixel locations by their color.\n    c.  For each unique marker color `C`:\n        i.  Determine the rectangular bounding box `B_C` that minimally encloses all marker pixels of color `C`.\n        ii. Identify the set of all coordinates `G_gray` where the *input* grid has a gray (5) pixel.\n        iii. Calculate the \"fill region\" `F_C` for color `C` by finding the intersection of the bounding box `B_C` and the gray pixel set `G_gray` (i.e., all coordinates within B_C where the input grid is gray). Store this set of coordinates `F_C`.\n3.  **Apply Fill:**\n    a.  For each unique marker color `C` and its corresponding fill region `F_C`:\n        i.  Iterate through every coordinate `(r, c)` in the fill region `F_C`.\n        ii. Set the color of the pixel at `(r, c)` in the *output* grid to color `C`.\n4.  **Apply Conditional Marker Erasure:**\n    a.  Consider all original marker pixel locations found in step 2a.\n    b.  For each original marker pixel location `(r, c)` with original color `C_marker`:\n        i.  Retrieve the fill region `F_{C_marker}` calculated in step 2.c.iii for that specific color `C_marker`.\n        ii. Check if the location `(r, c)` is contained within the fill region `F_{C_marker}`.\n        iii. If `(r, c)` is **not** within `F_{C_marker}`, change the color of the pixel at `(r, c)` in the *output* grid to white (0).\n        iv. If `(r, c)` **is** within `F_{C_marker}`, leave the pixel `(r, c)` in the *output* grid unchanged (it will retain the color assigned in step 1 or step 3).\n5.  **Return:** Return the final modified output grid.\n\"\"\"\n\ndef find_markers_and_group(grid):\n    \"\"\"\n    Identifies marker pixels (not white 0 or gray 5) and groups them.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - marker_locations_by_color (dict): Maps color -> list of (row, col) coords.\n        - all_markers (list): List of tuples (row, col, color) for every marker.\n    \"\"\"\n    marker_locations_by_color = {}\n    all_markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the pixel is a marker (not white 0 and not gray 5)\n            if color != 0 and color != 5:\n                if color not in marker_locations_by_color:\n                    marker_locations_by_color[color] = []\n                marker_locations_by_color[color].append((r, c))\n                all_markers.append((r, c, color))\n    return marker_locations_by_color, all_markers\n\ndef calculate_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\n\n    Args:\n        coords: A list of (row, col) tuples.\n\n    Returns:\n        A tuple (min_r, min_c, max_r, max_c) representing the bounding box.\n        Returns None if the coords list is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Marker pixels define bounding boxes. Gray pixels within these boxes in the\n    original input are recolored with the corresponding marker color in the output.\n    Marker pixels are erased (set to white) only if they fall *outside* the\n    calculated fill area for their own color.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    \n    # 1. Initialize output grid as a copy of the input grid.\n    output_grid = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # 2a. Identify all marker pixels and their locations/colors.\n    # 2b. Group marker locations by color.\n    marker_locations_by_color, all_markers = find_markers_and_group(input_np)\n\n    # 2c. Calculate fill regions for each marker color.\n    fill_regions_by_color = {}\n    for color, coords in marker_locations_by_color.items():\n        # 2c.i. Determine bounding box.\n        bbox = calculate_bounding_box(coords)\n        if bbox is None: # Should not happen if color has coords, but safety check\n            continue\n            \n        min_r, min_c, max_r, max_c = bbox\n        \n        # 2c.iii. Calculate the fill region (intersection of bbox and input gray pixels).\n        fill_region = set()\n        for r_fill in range(min_r, max_r + 1):\n            for c_fill in range(min_c, max_c + 1):\n                # Ensure coordinates are within grid bounds (redundant check)\n                if 0 <= r_fill < rows and 0 <= c_fill < cols:\n                    # Check if the *original input grid* pixel is gray (5)\n                    if input_np[r_fill, c_fill] == 5:\n                        fill_region.add((r_fill, c_fill))\n                        \n        fill_regions_by_color[color] = fill_region\n\n    # 3. Apply Fill: Update output grid based on calculated fill regions.\n    for color, fill_region in fill_regions_by_color.items():\n        for r, c in fill_region:\n            # Check bounds again just in case, although set logic should be correct\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_grid[r, c] = color\n\n    # 4. Apply Conditional Marker Erasure.\n    # 4a. Iterate through all original marker locations.\n    for r, c, marker_color in all_markers:\n        # 4b.i. Retrieve the fill region for this marker's color.\n        # Use .get with an empty set default in case a marker color somehow didn't\n        # generate a fill region (e.g., only markers, no gray pixels in bbox).\n        marker_fill_region = fill_regions_by_color.get(marker_color, set())\n        \n        # 4b.ii & 4b.iii. Check if marker location is OUTSIDE its fill region.\n        if (r, c) not in marker_fill_region:\n            # Ensure coordinates are valid before writing (should always be)\n             if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = 0 # Erase marker (set to white)\n\n    # 5. Return the final output grid, converted back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14776,
    "candidates_token_count": 1891,
    "total_token_count": 16667,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 107.533256,
  "retries": null
}