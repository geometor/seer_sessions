{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentifies pairs of distinct objects that are vertically aligned based on sharing the same leftmost column coordinate. If exactly two objects share the same leftmost column, the one with the smaller top row index (upper object) is shifted one column left, and the one with the larger top row index (lower object) is shifted one column right. Objects not part of such a pair remain stationary.\n\"\"\"\n\ndef get_background_color(grid_np):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    unique, counts = np.unique(grid_np, return_counts=True)\n    if not unique.size: \n        return 0 # Default to white if grid is empty\n    # Cast to standard python int for consistency\n    return int(unique[np.argmax(counts)])\n\ndef find_all_objects(grid_np):\n    \"\"\"\n    Finds all distinct objects (contiguous non-background pixels of the same color) \n    in the grid using 4-connectivity BFS.\n    Returns a list of dictionaries, each representing an object with its\n    id, color, pixels (set of (row, col) tuples), top_row, and leftmost_col.\n    \"\"\"\n    if grid_np.size == 0: return []\n    height, width = grid_np.shape\n    background_color = get_background_color(grid_np)\n    objects = []\n    object_id_counter = 0\n    visited = np.zeros_like(grid_np, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            color = grid_np[r, c]\n            # Start BFS if pixel is not background and not visited\n            if color != background_color and not visited[r, c]:\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                current_color = color # Color of the object being traced\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object if it has pixels\n                if obj_pixels:\n                     objects.append({\n                        'id': object_id_counter,\n                        'color': int(current_color),\n                        'pixels': obj_pixels, \n                        'top_row': int(min_r),\n                        'leftmost_col': int(min_c),\n                        # Add bottom_row for potential future use, though not strictly needed here\n                        'bottom_row': int(max_r) \n                    })\n                     object_id_counter += 1\n                     \n    # Sort objects primarily by top_row then leftmost_col for consistent processing order\n    objects.sort(key=lambda o: (o['top_row'], o['leftmost_col']))\n    # Re-assign sequential IDs after sorting (optional but can be helpful for debugging)\n    for i, obj in enumerate(objects):\n        obj['id'] = i\n        \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # Handle empty input grid\n    if height == 0 or width == 0:\n        return [] \n\n    # 1. Initialization: Determine background and create output grid\n    background_color = get_background_color(input_grid_np)\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 2. Object Identification: Find all distinct objects\n    objects = find_all_objects(input_grid_np)\n    if not objects:\n        return output_grid.tolist() # Return background if no objects\n\n    # 3. Pair Identification: Group objects by leftmost column\n    grouped_by_leftmost_col = defaultdict(list)\n    for obj in objects:\n        grouped_by_leftmost_col[obj['leftmost_col']].append(obj)\n\n    # 4. Shift Calculation: Determine shifts for paired objects\n    # Initialize all shifts to 0 (no horizontal movement)\n    object_shifts = {obj['id']: 0 for obj in objects} \n\n    for col, group in grouped_by_leftmost_col.items():\n        # Check if exactly two objects share this leftmost column\n        if len(group) == 2: \n            obj_a, obj_b = group[0], group[1]\n\n            # Determine upper and lower objects based on top_row\n            if obj_a['top_row'] < obj_b['top_row']:\n                obj_upper, obj_lower = obj_a, obj_b\n            else:\n                # Should not happen if objects are sorted, but handle defensively\n                obj_upper, obj_lower = obj_b, obj_a\n\n            # Assign shifts: -1 (left) for upper, +1 (right) for lower\n            object_shifts[obj_upper['id']] = -1\n            object_shifts[obj_lower['id']] = +1\n            \n            # Sanity check: ensure the lower object starts below the upper one\n            # This condition wasn't explicitly required by the examples but is implied\n            # assert obj_lower['top_row'] > obj_upper['bottom_row'] \n\n    # 5. Apply Transformation: Draw objects (shifted or stationary) onto output grid\n    for obj in objects:\n        shift = object_shifts[obj['id']] # Get the calculated horizontal shift\n        color = obj['color']\n\n        # Iterate through each pixel of the object\n        for r, c in obj['pixels']:\n            new_c = c + shift # Calculate the new column coordinate\n            \n            # Check if the new coordinate is within the grid boundaries\n            if 0 <= r < height and 0 <= new_c < width:\n                 output_grid[r, new_c] = color # Draw the pixel\n\n    # 6. Output: Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21364,
    "candidates_token_count": 1619,
    "total_token_count": 22983,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.761545,
  "retries": null
}