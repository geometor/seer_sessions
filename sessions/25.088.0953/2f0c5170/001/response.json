{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct rectangular regions containing non-azure (8) pixels within an azure background.\nCounts the number of 'significant' pixels (neither white (0) nor azure (8)) within each region's bounding box.\nThe region bounding box with the *fewer* significant pixels determines the output grid's dimensions.\nThe region bounding box with the *more* significant pixels provides the content pattern.\nCreates an output grid of the determined size, initialized to white (0), and places the content\npattern (potentially cropped or padded with white) into the top-left corner of the output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a list of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    # Find min/max row and column indices from the list of pixel coordinates\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    # Return tuple: (min_row, min_col, max_row, max_col)\n    return (min_r, min_c, max_r, max_c)\n\ndef find_non_background_regions(grid, background_color=8):\n    \"\"\"\n    Finds bounding boxes of contiguous regions of non-background pixels.\n    Uses Breadth-First Search (BFS) with 8-way connectivity.\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color value considered as background.\n    Returns:\n        list: A list of bounding box tuples [(min_r, min_c, max_r, max_c), ...].\n              Returns an empty list if no regions are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions_bboxes = []\n\n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if pixel is not background and has not been visited yet\n            if grid[r, c] != background_color and not visited[r, c]:\n                component_pixels = []  # Store pixels belonging to the current component\n                q = deque([(r, c)])    # Initialize queue for BFS\n                visited[r, c] = True   # Mark starting pixel as visited\n\n                # Perform BFS\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n\n                    # Explore neighbors using 8-way connectivity\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue  # Skip self\n                            nr, nc = row + dr, col + dc\n\n                            # Check if neighbor is within grid bounds\n                            if 0 <= nr < rows and 0 <= nc < cols:\n                                # Check if neighbor is valid (not background, not visited)\n                                if grid[nr, nc] != background_color and not visited[nr, nc]:\n                                    visited[nr, nc] = True # Mark neighbor as visited\n                                    q.append((nr, nc))     # Add neighbor to the queue\n\n                # After BFS completes for a component, calculate its bounding box\n                if component_pixels:\n                    bbox = get_bounding_box(component_pixels)\n                    regions_bboxes.append(bbox)\n\n    # The task expects exactly two regions based on the examples.\n    # No explicit error handling here, assuming input conforms.\n    return regions_bboxes\n\n\ndef count_internal_pixels(grid, bbox, ignore_colors=(0, 8)):\n    \"\"\"\n    Counts pixels within a specified bounding box that are not in the ignore_colors set.\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n        ignore_colors (tuple): A tuple of color values to ignore in the count.\n    Returns:\n        int: The count of significant pixels within the bounding box.\n    \"\"\"\n    if bbox is None:\n        return 0\n    min_r, min_c, max_r, max_c = bbox\n    count = 0\n    # Iterate through every cell within the bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check grid bounds just in case bbox goes out (shouldn't happen with calculation)\n            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:\n                # Increment count if the pixel color is not in the ignored set\n                if grid[r, c] not in ignore_colors:\n                    count += 1\n    return count\n\ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts the subgrid defined by the bounding box from the main grid.\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n    Returns:\n        np.array: The extracted subgrid.\n    \"\"\"\n    if bbox is None:\n        return np.array([[]]) # Return empty array if no bbox\n    min_r, min_c, max_r, max_c = bbox\n    # Slice the grid using the bounding box coordinates (inclusive end for slicing)\n    return grid[min_r : max_r + 1, min_c : max_c + 1]\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on identifying two regions, counting internal\n    pixels to determine size and content source, and constructing the output grid.\n    Args:\n        input_grid_list (list of lists): The input grid represented as a list of lists.\n    Returns:\n        list of lists: The transformed output grid. Returns empty list on error (e.g., not 2 regions).\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    background_color = 8\n    content_fill_color = 0 # white (used for initializing output and ignoring in count)\n\n    # 1. Find the bounding boxes of the two non-background regions\n    #    Assumes exactly two regions will be found based on task structure.\n    regions = find_non_background_regions(input_grid, background_color)\n\n    # Check if exactly two regions were found, as expected by the task logic\n    if len(regions) != 2:\n        print(f\"Error: Expected 2 non-background regions, but found {len(regions)}. Cannot proceed.\")\n        return [] # Return empty list or raise error to indicate failure\n\n    bbox1, bbox2 = regions[0], regions[1]\n\n    # 2. Count the 'significant' internal pixels (non-white, non-azure) in each region's bbox\n    count1 = count_internal_pixels(input_grid, bbox1, ignore_colors=(content_fill_color, background_color))\n    count2 = count_internal_pixels(input_grid, bbox2, ignore_colors=(content_fill_color, background_color))\n\n    # 3. Determine which region's bounding box provides size and which provides content\n    #    Size comes from the region with *fewer* significant pixels.\n    #    Content comes from the region with *more* significant pixels.\n    if count1 < count2:\n        size_bbox = bbox1\n        content_bbox = bbox2\n    elif count2 < count1:\n        size_bbox = bbox2\n        content_bbox = bbox1\n    else:\n        # Undefined case based on examples: Equal counts.\n        # Defaulting: use the first found region (bbox1) for size, second (bbox2) for content.\n        # This might need refinement if test cases reveal a specific tie-breaking rule (e.g., position).\n        print(\"Warning: Equal internal pixel counts found. Defaulting assignment (bbox1=size, bbox2=content).\")\n        size_bbox = bbox1\n        content_bbox = bbox2\n\n    # 4. Determine output grid dimensions from the 'size' region's bounding box\n    min_r_size, min_c_size, max_r_size, max_c_size = size_bbox\n    output_height = max_r_size - min_r_size + 1\n    output_width = max_c_size - min_c_size + 1\n\n    # 5. Create the output grid, initialized with the fill color (white)\n    output_grid = np.full((output_height, output_width), content_fill_color, dtype=int)\n\n    # 6. Extract the content pattern using the 'content' region's bounding box\n    content_subgrid = extract_subgrid(input_grid, content_bbox)\n    \n    # Check if content extraction was successful\n    if content_subgrid.size == 0:\n         print(\"Error: Failed to extract content subgrid.\")\n         return [] # Indicate failure\n\n    content_height, content_width = content_subgrid.shape\n\n    # 7. Copy the content pattern to the top-left of the output grid\n    #    Determine the dimensions of the area to copy, handling potential cropping\n    #    if the content subgrid is larger than the output grid.\n    copy_height = min(output_height, content_height)\n    copy_width = min(output_width, content_width)\n\n    # Place the (potentially cropped) content subgrid into the output grid's top-left corner.\n    # If content is smaller, the rest of the output grid remains white (due to initialization).\n    output_grid[0:copy_height, 0:copy_width] = content_subgrid[0:copy_height, 0:copy_width]\n\n    # 8. Return the final grid converted back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 5585,
            "end_index": 5917,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          },
          {
            "start_index": 7405,
            "end_index": 7740,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5476,
    "candidates_token_count": 2371,
    "total_token_count": 7847,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 66.607947,
  "retries": null
}