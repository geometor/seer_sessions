{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify a palette object, which is a small line (horizontal or vertical) of unique, adjacent, non-background colors [C1, C2, ..., CN].\n2. Identify core objects Obj2, Obj3, ..., Obj(N-1) in the input grid, where each Obj_i has the color C_i from the *inner* part of the palette sequence.\n3. Calculate the vertical displacement (delta_y) between the top rows of the first two core objects (Obj2 and Obj3).\n4. Create an output grid initialized with the background color (0).\n5. Copy all identified core objects (Obj2 through Obj(N-1)) to the output grid at their original positions.\n6. Create a new object using the shape of Obj2 but colored with the first palette color (C1). Place this new object on the output grid, vertically shifted *up* by delta_y relative to Obj2's original position.\n7. If the palette has more than 3 colors (N > 3), create another new object using the shape of the *last* core object (Obj(N-1)) but colored with the last palette color (CN). Place this new object on the output grid, vertically shifted *down* by delta_y relative to Obj(N-1)'s original position.\n8. The resulting grid with the original core objects and the newly created/colored/shifted objects is the final output. The original palette object is not copied.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects found. Each object is a dictionary containing:\n              'color': The color of the object.\n              'pixels': A set of (row, col) tuples representing the object's pixels.\n              'bounds': A tuple (min_row, min_col, max_row, max_col).\n              'shape_mask': A np.array representing the object's shape relative to its bounding box.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    obj_height = max_r - min_r + 1\n                    obj_width = max_c - min_c + 1\n                    shape_mask = np.zeros((obj_height, obj_width), dtype=int)\n                    for p_r, p_c in obj_pixels:\n                        shape_mask[p_r - min_r, p_c - min_c] = color\n\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bounds': (min_r, min_c, max_r, max_c),\n                        'shape_mask': shape_mask\n                    })\n    return objects\n\ndef find_palette(grid):\n    \"\"\"\n    Finds the palette object (a horizontal or vertical line of unique non-zero colors).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: The sequence of colors in the palette, or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    background_color = 0\n\n    # Check horizontal lines\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color:\n                palette = []\n                cc = c\n                while cc < width and grid[r, cc] != background_color:\n                    color = grid[r, cc]\n                    # Check uniqueness and non-zero\n                    if color in palette or color == background_color:\n                         palette = None # Invalid palette\n                         break\n                    # Check if part of a larger vertical structure (not just a line)\n                    if (r > 0 and grid[r-1, cc] != background_color) or \\\n                       (r < height - 1 and grid[r+1, cc] != background_color):\n                        palette = None # Not just a line\n                        break\n                    palette.append(color)\n                    cc += 1\n\n                if palette and len(palette) > 1:\n                    # Verify it's not part of a larger horizontal structure immediately adjacent\n                    is_isolated_line = True\n                    for pc in range(c, cc):\n                       # Check left/right immediate neighbors (should be background or edge)\n                       if pc > 0 and grid[r, pc-1] != background_color and pc-1 < c:\n                           is_isolated_line = False\n                           break\n                       if pc < width - 1 and grid[r, pc+1] != background_color and pc+1 >= cc:\n                           is_isolated_line = False\n                           break\n                    if is_isolated_line:\n                       return palette\n\n    # Check vertical lines\n    for c in range(width):\n        for r in range(height):\n             if grid[r, c] != background_color:\n                palette = []\n                rr = r\n                while rr < height and grid[rr, c] != background_color:\n                    color = grid[rr, c]\n                    # Check uniqueness and non-zero\n                    if color in palette or color == background_color:\n                        palette = None\n                        break\n                    # Check if part of a larger horizontal structure (not just a line)\n                    if (c > 0 and grid[rr, c-1] != background_color) or \\\n                       (c < width - 1 and grid[rr, c+1] != background_color):\n                        palette = None\n                        break\n                    palette.append(color)\n                    rr += 1\n\n                if palette and len(palette) > 1:\n                    # Verify it's not part of a larger vertical structure immediately adjacent\n                    is_isolated_line = True\n                    for pr in range(r, rr):\n                        # Check up/down immediate neighbors (should be background or edge)\n                        if pr > 0 and grid[pr-1, c] != background_color and pr-1 < r:\n                           is_isolated_line = False\n                           break\n                        if pr < height - 1 and grid[pr+1, c] != background_color and pr+1 >= rr:\n                           is_isolated_line = False\n                           break\n                    if is_isolated_line:\n                       return palette\n\n    return None # No palette found\n\ndef draw_object(grid, shape_mask, top_left_r, top_left_c, color):\n    \"\"\"Draws an object onto the grid using its shape mask and color.\"\"\"\n    obj_h, obj_w = shape_mask.shape\n    grid_h, grid_w = grid.shape\n\n    for r_offset in range(obj_h):\n        for c_offset in range(obj_w):\n            if shape_mask[r_offset, c_offset] != 0: # Use the original color in the mask to determine shape\n                target_r = top_left_r + r_offset\n                target_c = top_left_c + c_offset\n                # Check grid boundaries\n                if 0 <= target_r < grid_h and 0 <= target_c < grid_w:\n                    grid[target_r, target_c] = color # Draw with the new color\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color 0\n\n    # 1. Find the palette\n    palette = find_palette(input_grid)\n    if not palette or len(palette) < 3:\n        # If no valid palette (or too short), maybe return input or empty?\n        # Based on examples, we expect a palette and core objects.\n        # Returning input might be safer if logic isn't found. Let's try that.\n        print(\"Warning: Palette not found or too short. Returning input.\")\n        return input_grid_list\n\n    num_palette_colors = len(palette)\n    c1 = palette[0]\n    cn = palette[-1]\n\n    # 2. Find the core objects\n    core_objects_data = {} # Store by color for easy access\n    core_object_list_ordered = [] # Store in palette order\n    found_all_core = True\n    for i in range(1, num_palette_colors - 1):\n        core_color = palette[i]\n        objects = find_objects(input_grid, core_color)\n        if not objects:\n            # Could not find a required core object\n            print(f\"Warning: Core object for color {core_color} not found.\")\n            found_all_core = False\n            break\n        # Assume only one object per core color as per examples\n        if len(objects) > 1:\n             print(f\"Warning: Found multiple objects for core color {core_color}. Using the first one.\")\n        core_objects_data[core_color] = objects[0]\n        core_object_list_ordered.append(objects[0])\n\n    if not found_all_core or not core_object_list_ordered:\n         print(\"Warning: Could not find all required core objects. Returning input.\")\n         return input_grid_list\n\n    obj2_data = core_object_list_ordered[0] # Corresponds to C2\n    obj3_data = core_object_list_ordered[1] # Corresponds to C3\n    obj_last_core_data = core_object_list_ordered[-1] # Corresponds to C(N-1)\n\n    # 3. Calculate vertical displacement\n    delta_y = obj3_data['bounds'][0] - obj2_data['bounds'][0] # min_row(Obj3) - min_row(Obj2)\n\n    # 4. Initialize output grid (already done)\n\n    # 5. Copy all core objects to output grid\n    for obj_data in core_object_list_ordered:\n        min_r, min_c, _, _ = obj_data['bounds']\n        draw_object(output_grid, obj_data['shape_mask'], min_r, min_c, obj_data['color'])\n\n    # 6. Create and draw the first generated object (color C1, shape Obj2)\n    obj2_min_r, obj2_min_c, _, _ = obj2_data['bounds']\n    new_obj1_top_r = obj2_min_r - delta_y\n    new_obj1_top_c = obj2_min_c\n    # Use obj2's shape mask but draw with color C1\n    draw_object(output_grid, obj2_data['shape_mask'], new_obj1_top_r, new_obj1_top_c, c1)\n\n    # 7. Create and draw the second generated object if N > 3\n    if num_palette_colors > 3:\n        obj_last_core_min_r, obj_last_core_min_c, _, _ = obj_last_core_data['bounds']\n        new_obj2_top_r = obj_last_core_min_r + delta_y\n        new_obj2_top_c = obj_last_core_min_c\n         # Use last core object's shape mask but draw with color CN\n        draw_object(output_grid, obj_last_core_data['shape_mask'], new_obj2_top_r, new_obj2_top_c, cn)\n\n    # 8. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4604,
    "candidates_token_count": 3033,
    "total_token_count": 7637,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.88986,
  "retries": null
}