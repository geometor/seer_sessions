{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct connected components (objects) of red (2) pixels in the input grid using orthogonal adjacency. \nAssigns a unique identifier to each red pixel based on the object it belongs to.\nIterates through every white (0) pixel in the input grid.\nFor each white pixel, checks if it lies on a straight, unobstructed (only white pixels) horizontal path between two red pixels belonging to *different* objects. If so, colors the white pixel blue (1).\nIf the horizontal check fails, performs a similar check vertically. If it lies on a straight, unobstructed vertical path between two red pixels belonging to *different* objects, colors the white pixel blue (1).\nOriginal red pixels and other white pixels remain unchanged.\n\"\"\"\n\ndef find_objects(grid, target_color):\n    \"\"\"\n    Finds connected components of a specific color in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color of the objects to find.\n\n    Returns:\n        np.array: A grid of the same dimensions where each pixel belonging\n                  to an object is labeled with a unique positive integer ID.\n                  Other pixels are labeled 0.\n    \"\"\"\n    rows, cols = grid.shape\n    object_id_grid = np.zeros_like(grid, dtype=int)\n    current_object_id = 1\n    visited = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == target_color and (r, c) not in visited:\n                # Start BFS for a new object\n                q = deque([(r, c)])\n                visited.add((r, c))\n                object_id_grid[r, c] = current_object_id\n                \n                while q:\n                    row, col = q.popleft()\n                    \n                    # Explore neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check boundaries and if the neighbor is the target color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == target_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            object_id_grid[nr, nc] = current_object_id\n                            q.append((nr, nc))\n                            \n                current_object_id += 1\n                \n    return object_id_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by adding blue bridges between distinct red objects.\n\n    Args:\n        input_grid (np.array): The input grid.\n\n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.copy(input_grid)\n    \n    # 1. Identify distinct red objects\n    red_object_ids = find_objects(input_grid, 2) # 2 is red\n\n    # 2. Iterate through white pixels to check for potential bridges\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] == 0: # Check only white pixels (0)\n                \n                # 3a. Check horizontally\n                left_red_pixel = None\n                right_red_pixel = None\n\n                # Scan left\n                for nc in range(c - 1, -2, -1): # Go down to -1 to handle boundary check easily\n                    if nc < 0: # Reached boundary\n                        break\n                    if input_grid[r, nc] != 0: # Found non-white\n                        if input_grid[r, nc] == 2: # It's red\n                            left_red_pixel = (r, nc)\n                        break # Stop scanning left (either found red or obstruction)\n                \n                # Scan right\n                for nc in range(c + 1, cols + 1): # Go up to cols to handle boundary check easily\n                    if nc >= cols: # Reached boundary\n                        break\n                    if input_grid[r, nc] != 0: # Found non-white\n                        if input_grid[r, nc] == 2: # It's red\n                            right_red_pixel = (r, nc)\n                        break # Stop scanning right\n\n                # Check if valid horizontal bridge\n                if (left_red_pixel is not None and \n                    right_red_pixel is not None and\n                    red_object_ids[left_red_pixel] != red_object_ids[right_red_pixel]):\n                    output_grid[r, c] = 1 # Color blue\n                    continue # Move to next white pixel, no need for vertical check\n\n                # 3b. Check vertically (only if horizontal failed)\n                up_red_pixel = None\n                down_red_pixel = None\n\n                # Scan up\n                for nr in range(r - 1, -2, -1): # Go down to -1 \n                    if nr < 0:\n                        break\n                    if input_grid[nr, c] != 0:\n                        if input_grid[nr, c] == 2:\n                            up_red_pixel = (nr, c)\n                        break\n                        \n                # Scan down\n                for nr in range(r + 1, rows + 1): # Go up to rows\n                    if nr >= rows:\n                        break\n                    if input_grid[nr, c] != 0:\n                        if input_grid[nr, c] == 2:\n                            down_red_pixel = (nr, c)\n                        break\n\n                # Check if valid vertical bridge\n                if (up_red_pixel is not None and \n                    down_red_pixel is not None and\n                    red_object_ids[up_red_pixel] != red_object_ids[down_red_pixel]):\n                    output_grid[r, c] = 1 # Color blue\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4345,
    "candidates_token_count": 1418,
    "total_token_count": 5763,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.658522,
  "retries": null
}