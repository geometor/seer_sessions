{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom itertools import combinations\n\n\"\"\"\nThis module transforms an input grid based on the locations of non-white pixels.\n\nTransformation Rule:\n1. Find all non-white pixels (points) in the input grid.\n2. Count the number of points (n).\n3. Initialize the output grid as a copy of the input grid.\n4. If n = 1:\n    - Let the point be at (r, c).\n    - Draw a vertical gray (5) line from the top edge (row 0) down to row r-1 in column c.\n5. If n >= 2:\n    - For every unique pair of points P1=(r1, c1) and P2=(r2, c2):\n        - If P1 and P2 are in the same row (r1 == r2):\n            Draw a horizontal gray (5) line segment connecting them (exclusive of endpoints).\n        - If P1 and P2 are in the same column (c1 == c2):\n            Draw a vertical gray (5) line segment connecting them (exclusive of endpoints).\n        - If P1 and P2 are in different rows and columns:\n            Draw an L-shaped path:\n            - The corner is at C=(r2, c1). Color the corner yellow (4).\n            - Draw a vertical gray (5) line segment from P1 towards C (exclusive of endpoints and corner).\n            - Draw a horizontal gray (5) line segment from P2 towards C (exclusive of endpoints and corner).\n    - Color Priority:\n        - Original non-white pixels are preserved.\n        - Yellow (4) corners overwrite gray (5) segments and white (0) background.\n        - Gray (5) segments only overwrite white (0) background.\n\"\"\"\n\ndef find_points(grid):\n    \"\"\"Finds coordinates and colors of non-white pixels.\"\"\"\n    points = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                points.append(((r, c), grid[r, c])) # Store ((row, col), color)\n    return points\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 1. Find non-white points\n    points_with_color = find_points(input_np)\n    points = [p[0] for p in points_with_color] # List of (r, c) tuples\n    n = len(points)\n\n    # 2. Handle single point case\n    if n == 1:\n        (r, c) = points[0]\n        for i in range(r): # Iterate from row 0 up to r-1\n            if 0 <= i < height and 0 <= c < width:\n                 # Only draw if the cell is background\n                 if output_grid[i, c] == 0:\n                    output_grid[i, c] = 5 # Gray\n    \n    # 3. Handle multiple points case\n    elif n >= 2:\n        gray_coords = set()\n        yellow_coords = set()\n        \n        # Iterate through all unique pairs of points\n        for (r1, c1), (r2, c2) in combinations(points, 2):\n            \n            # Case a: Same row\n            if r1 == r2:\n                for c in range(min(c1, c2) + 1, max(c1, c2)):\n                    gray_coords.add((r1, c))\n            \n            # Case b: Same column\n            elif c1 == c2:\n                for r in range(min(r1, r2) + 1, max(r1, r2)):\n                    gray_coords.add((r, c1))\n            \n            # Case c: Different row and column (L-shape)\n            else:\n                corner = (r2, c1)\n                yellow_coords.add(corner)\n                \n                # Vertical segment (from (r1, c1) to (r2, c1), excluding ends)\n                for r in range(min(r1, r2) + 1, max(r1, r2)):\n                    gray_coords.add((r, c1))\n                    \n                # Horizontal segment (from (r2, c2) to (r2, c1), excluding ends)\n                for c in range(min(c1, c2) + 1, max(c1, c2)):\n                    gray_coords.add((r2, c))\n\n        # Apply colors based on priority\n        \n        # Apply gray segments first (only on white background)\n        for r, c in gray_coords:\n             # Check bounds just in case, although coordinates should be derived from valid points\n             if 0 <= r < height and 0 <= c < width:\n                 # Check if the target is not an original point and is background\n                 if output_grid[r, c] == 0: \n                     output_grid[r, c] = 5 # Gray\n\n        # Apply yellow corners (overwrites gray and white, but not original points)\n        for r, c in yellow_coords:\n            # Check bounds\n            if 0 <= r < height and 0 <= c < width:\n                # Yellow overwrites gray or white background\n                # It should NOT overwrite an original non-white pixel\n                original_color_at_corner = input_np[r,c]\n                if original_color_at_corner == 0: # Only overwrite if it was originally background\n                    output_grid[r, c] = 4 # Yellow\n                # If the corner coordinate was already colored gray by a segment, \n                # and it wasn't an original point, yellow overwrites it.\n                # This check handles both overwriting gray and not overwriting original points.\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5242,
    "candidates_token_count": 1401,
    "total_token_count": 6643,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.263537,
  "retries": null
}