{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by recoloring azure (8) objects based on their size rank \nand the total number of objects.\n\n1. Identifies all distinct connected components (objects) of azure (8) pixels using \n   8-way connectivity (including diagonals).\n2. Calculates the size (pixel count) and top-left coordinate (minimum row, then \n   minimum column) for each object.\n3. Counts the total number of azure objects found (M).\n4. Sorts the objects based primarily on size (ascending) and secondarily on their \n   top-left coordinate (row ascending, then column ascending).\n5. Determines a specific color sequence based on the total number of objects found (M):\n   - M=4: [Green(3), Green(3), Orange(7), Orange(7)]\n   - M=5: [Blue(1), Red(2), Red(2), Blue(1), Green(3)]\n   - M=6: [Blue(1), Red(2), Red(2), Red(2), Green(3), Orange(7)]\n6. Creates a copy of the input grid.\n7. Recolors each object in the output grid according to its rank in the sorted list, \n   using the determined color sequence. Pixels of the i-th object in the sorted list\n   are recolored with the i-th color in the sequence.\n8. If M is not 4, 5, or 6, the original grid is returned unchanged.\n\"\"\"\n\ndef find_objects(grid, color_code):\n    \"\"\"\n    Finds all connected components of a specific color in the grid using 8-way connectivity.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color_code (int): The color code of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'pixels' (set of (r, c) tuples), 'size' (int),\n              and 'top_left' ((r, c) tuple). Returns an empty list if no objects\n              of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    # Define 8 neighbors (including diagonals) for connectivity\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 (0, -1),           (0, 1),\n                 (1, -1), (1, 0), (1, 1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color_code and not visited[r, c]:\n                # Found the start of a new object, perform Breadth-First Search (BFS)\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Initialize top-left coordinate tracking\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Update top-left coordinate if a pixel further up or left is found\n                    if row < min_r:\n                        min_r, min_c = row, col\n                    elif row == min_r and col < min_c:\n                        min_c = col\n\n                    # Explore neighbors\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is the target color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color_code and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Store the found object's properties\n                objects.append({\n                    'pixels': obj_pixels,\n                    'size': len(obj_pixels),\n                    'top_left': (min_r, min_c)\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify all azure (8) objects\n    azure_objects = find_objects(input_grid_np, 8)\n    \n    # 2. Get the total number of objects found\n    M = len(azure_objects)\n    \n    # If no azure objects found, return the original grid\n    if M == 0:\n        return input_grid \n\n    # 3. Sort the objects: primary key size (asc), secondary key top-left row (asc), tertiary key top-left col (asc)\n    sorted_objects = sorted(azure_objects, key=lambda obj: (obj['size'], obj['top_left'][0], obj['top_left'][1]))\n    \n    # 4. Determine the target color sequence based on M\n    color_sequence = []\n    if M == 4:\n        # Green, Green, Orange, Orange\n        color_sequence = [3, 3, 7, 7]\n    elif M == 5:\n        # Blue, Red, Red, Blue, Green  (Corrected sequence)\n        color_sequence = [1, 2, 2, 1, 3] \n    elif M == 6:\n        # Blue, Red, Red, Red, Green, Orange\n        color_sequence = [1, 2, 2, 2, 3, 7]\n    else:\n        # If M is not 4, 5, or 6, the transformation is undefined by examples. Return original grid.\n        # print(f\"Warning: Unexpected number of objects M={M}. No transformation applied.\")\n        return input_grid\n\n    # 5. Create the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid_np)\n    \n    # 6. Iterate through the sorted objects and assign colors based on rank\n    for i, obj in enumerate(sorted_objects):\n        # Get the target color for the current object based on its rank (i)\n        target_color = color_sequence[i]\n        # 7. Recolor the pixels of the current object in the output grid\n        for r, c in obj['pixels']:\n            output_grid[r, c] = target_color\n            \n    # Convert the NumPy array back to a list of lists for the final output\n    return output_grid.tolist() \n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11499,
    "candidates_token_count": 1558,
    "total_token_count": 13057,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.185648,
  "retries": null
}