{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies closed shapes formed by red (2) pixels in the input grid, resembling either a digit '5' or a letter 'H'.\nThe transformation involves filling the area enclosed by these red shapes with a specific color, \nwhile leaving the red outline and the exterior background (white - 0) unchanged. \nThe fill color depends on the shape type ('5' or 'H') and whether the shape originally contained an internal \nred pixel (2) within its enclosed area in the input grid.\n\nRules:\n1. Find all distinct connected components of red (2) pixels (boundaries).\n2. For each boundary component:\n    a. Find the set of enclosed white (0) pixels (interior).\n    b. Classify the red shape boundary as '5' or 'H'.\n    c. Check if any red (2) pixel existed within the interior region in the *input* grid.\n    d. Determine the fill color based on shape and internal red presence:\n        - If shape is '5', fill color is azure (8).\n        - If shape is 'H' and has internal red, fill color is yellow (4).\n        - If shape is 'H' and has no internal red, fill color is green (3).\n    e. Fill the white interior pixels in the *output* grid with the determined fill color. Original red pixels within the interior remain unchanged.\n3. Pixels not part of a boundary or an enclosed interior remain unchanged.\n\"\"\"\n\ndef find_connected_component(grid, start_coord, target_color, visited):\n    \"\"\"Finds all coordinates of a connected component of target_color using BFS.\"\"\"\n    height, width = grid.shape\n    q = deque([start_coord])\n    component_coords = set()\n    # Add start_coord to visited *before* starting BFS for this component\n    visited.add(start_coord)\n    component_coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor = (nr, nc)\n\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == target_color and neighbor not in visited:\n                visited.add(neighbor)\n                component_coords.add(neighbor)\n                q.append(neighbor)\n                \n    return component_coords\n\ndef find_interior_coords(grid, boundary_coords):\n    \"\"\"\n    Finds interior white (0) pixels enclosed by boundary_coords using border flood fill.\n    Identifies all white pixels reachable from the grid border without crossing the boundary.\n    Any remaining white pixels are considered interior to *some* shape.\n    We then verify these potential interior points are adjacent only to the given boundary.\n    \"\"\"\n    height, width = grid.shape\n    \n    # visited_exterior includes the boundary itself to prevent crossing\n    visited_exterior = set(boundary_coords) \n    exterior_white = set()\n    q = deque()\n\n    # Start BFS from all border white pixels\n    for r in range(height):\n        for c in [0, width - 1]: # Left and Right borders\n            if grid[r, c] == 0 and (r, c) not in visited_exterior:\n                visited_exterior.add((r, c))\n                q.append((r, c))\n    for c in range(width):\n         for r in [0, height-1]: # Top and bottom borders (avoid adding corners twice)\n             if grid[r,c] == 0 and (r,c) not in visited_exterior:\n                 visited_exterior.add((r,c))\n                 q.append((r,c))\n\n\n    # Flood fill to find all exterior white pixels\n    while q:\n        r, c = q.popleft()\n        exterior_white.add((r, c))\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor = (nr, nc)\n\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and neighbor not in visited_exterior:\n                visited_exterior.add(neighbor)\n                q.append(neighbor)\n\n    # Potential interior = all white pixels not reached by the exterior flood fill\n    potential_interior = set()\n    for r in range(height):\n        for c in range(width):\n            coord = (r, c)\n            # Must be white, not part of the boundary itself, and not reachable from outside\n            if grid[r, c] == 0 and coord not in boundary_coords and coord not in exterior_white:\n                potential_interior.add(coord)\n\n    # Verification step: Ensure potential interior points are contiguous and truly bounded \n    # *only* by the current boundary_coords or other interior points of the same region.\n    # This handles cases where potential_interior might span multiple shapes if they are close.\n    final_interior = set()\n    visited_potential = set()\n\n    for start_r, start_c in potential_interior:\n        if (start_r, start_c) in visited_potential or (start_r, start_c) in final_interior:\n            continue\n\n        component_q = deque([(start_r, start_c)])\n        current_component = set([(start_r, start_c)])\n        visited_potential.add((start_r, start_c))\n        is_bounded_by_current = True\n\n        while component_q:\n            r, c = component_q.popleft()\n\n            # Check neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                neighbor = (nr, nc)\n\n                if not (0 <= nr < height and 0 <= nc < width):\n                    # Should not happen if exterior fill was correct, but safety check\n                    is_bounded_by_current = False\n                    break \n                \n                if neighbor in boundary_coords:\n                    continue # Neighbor is the correct boundary, OK.\n                elif neighbor in potential_interior and neighbor not in visited_potential:\n                    visited_potential.add(neighbor)\n                    current_component.add(neighbor)\n                    component_q.append(neighbor)\n                elif neighbor in exterior_white:\n                     # This component touches the outside, not interior to this boundary\n                     is_bounded_by_current = False\n                     break\n                elif grid[nr, nc] != 0 and neighbor not in boundary_coords:\n                     # This component touches another shape/color, not purely interior to this boundary\n                     is_bounded_by_current = False\n                     break\n                # If neighbor is already visited_potential or part of final_interior, ignore.\n            \n            if not is_bounded_by_current:\n                break # Stop exploring this component\n\n        if is_bounded_by_current:\n            # This component is validly interior to the current boundary\n            final_interior.update(current_component)\n            \n    return final_interior\n\n\ndef classify_shape(boundary_coords):\n    \"\"\"Classifies the shape as '5' or 'H' based on structure using heuristics.\"\"\"\n    if not boundary_coords:\n        return None\n\n    rows = [r for r, c in boundary_coords]\n    cols = [c for r, c in boundary_coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    center_r = min_r + height // 2\n\n    # Heuristic for 'H': Look for a horizontal bar near the middle row\n    # and check for vertical segments above and below it.\n    \n    # Check for roughly continuous horizontal segment near the center row\n    has_mid_horizontal_bar = False\n    mid_row_pixels = {c for br, bc in boundary_coords if abs(br - center_r) <= height // 4} # Allow some deviation\n    if mid_row_pixels:\n        min_c_mid = min(mid_row_pixels)\n        max_c_mid = max(mid_row_pixels)\n        \n        # Check if there's a reasonably solid horizontal line near the center\n        # Find a row near the center with good horizontal extent\n        best_mid_r = -1\n        max_span = 0\n        for r_check in range(min_r + 1, max_r): # Exclude top/bottom boundary rows\n             row_pixels = {c for br, bc in boundary_coords if br == r_check}\n             if not row_pixels: continue\n             r_min_c, r_max_c = min(row_pixels), max(row_pixels)\n             span = r_max_c - r_min_c\n             is_connected = all((r_check, c) in boundary_coords for c in range(r_min_c, r_max_c + 1))\n             \n             # Check if this row is near the center and has decent span and connection\n             if abs(r_check - center_r) <= height // 4 and span >= width * 0.5 and is_connected:\n                  has_mid_horizontal_bar = True\n                  best_mid_r = r_check\n                  break # Found a plausible bar\n\n    if has_mid_horizontal_bar:\n         # Further check for H: vertical segments above and below the bar near edges\n         bar_row_pixels = {c for br, bc in boundary_coords if br == best_mid_r}\n         bar_min_c, bar_max_c = min(bar_row_pixels), max(bar_row_pixels)\n\n         # Check for vertical connection near the left end of the bar\n         left_connected_above = any((r, bar_min_c) in boundary_coords for r in range(min_r, best_mid_r))\n         left_connected_below = any((r, bar_min_c) in boundary_coords for r in range(best_mid_r + 1, max_r + 1))\n         \n         # Check for vertical connection near the right end of the bar\n         right_connected_above = any((r, bar_max_c) in boundary_coords for r in range(min_r, best_mid_r))\n         right_connected_below = any((r, bar_max_c) in boundary_coords for r in range(best_mid_r + 1, max_r + 1))\n\n         if (left_connected_above and left_connected_below) and \\\n            (right_connected_above and right_connected_below):\n             return 'H'\n\n    # If the structure doesn't match 'H' heuristics strongly, default to '5' based on examples.\n    # A more robust classifier might analyze topology (number of holes) or match templates.\n    return '5'\n\n\ndef check_internal_red(input_grid, interior_coords):\n    \"\"\"Checks if any red (2) pixel exists within the interior coordinates in the input grid.\"\"\"\n    for r, c in interior_coords:\n        # Need to check bounds just in case interior_coords calculation had edge cases\n        if 0 <= r < input_grid.shape[0] and 0 <= c < input_grid.shape[1]:\n             if input_grid[r, c] == 2:\n                 return True\n    return False\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by finding red shapes ('5' or 'H'), \n    determining their interior, and filling the interior based on shape type \n    and presence of internal red pixels in the original input.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    visited_shapes = set() # Keep track of red pixels already processed as part of a shape boundary\n\n    # Iterate through the grid to find potential starting points for red shapes\n    for r in range(height):\n        for c in range(width):\n            # If it's a red pixel and hasn't been assigned to a shape boundary yet\n            if input_grid[r, c] == 2 and (r, c) not in visited_shapes:\n                \n                # Find the complete connected component for this red shape boundary\n                boundary_coords = find_connected_component(input_grid, (r, c), 2, visited_shapes)\n\n                # Find the interior white pixels enclosed by this specific boundary\n                interior_coords = find_interior_coords(input_grid, boundary_coords)\n\n                # Only proceed if we found a non-empty interior for this boundary\n                if interior_coords:\n                    # Classify the shape based on the boundary's geometry\n                    shape_type = classify_shape(boundary_coords)\n                    \n                    # Check if the *original input grid* had red pixels within this interior area\n                    internal_red_present = check_internal_red(input_grid, interior_coords)\n                    \n                    # Determine the fill color based on the rules\n                    fill_color = 0 # Default initialization, will be overwritten\n                    apply_fill = True\n                    if shape_type == '5':\n                        fill_color = 8 # Azure\n                    elif shape_type == 'H':\n                        if internal_red_present:\n                            fill_color = 4 # Yellow\n                        else:\n                            fill_color = 3 # Green\n                    else:\n                        # If classification failed (returned None or unexpected value)\n                        apply_fill = False \n\n                    # Fill the identified interior white pixels in the output grid\n                    if apply_fill:\n                        for ir, ic in interior_coords:\n                             # Check bounds again for safety\n                             if 0 <= ir < height and 0 <= ic < width:\n                                 # IMPORTANT: Only fill if the target pixel in the OUTPUT is currently white (0)\n                                 # This preserves any original non-white pixels (like internal red)\n                                 if output_grid[ir, ic] == 0: \n                                     output_grid[ir, ic] = fill_color\n\n    # Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9838,
    "candidates_token_count": 3367,
    "total_token_count": 13205,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.912242,
  "retries": null
}