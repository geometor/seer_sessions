{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies closed shapes formed by red (2) pixels in the input grid.\nThese shapes resemble either a digit '5' or a letter 'H'.\nThe transformation involves filling the area enclosed by these red shapes with a specific color, \nwhile leaving the red outline and the exterior background (white - 0) unchanged. \nThe fill color depends on the shape type ('5' or 'H') and whether the shape contains an internal \nred pixel (2) in the input grid.\n\nRules:\n1. Find all connected components of red (2) pixels.\n2. For each component, determine the set of enclosed white (0) pixels (interior).\n3. If an interior exists:\n    a. Classify the red shape boundary as '5' or 'H'.\n    b. Check if any red (2) pixel exists within the interior region in the *input* grid.\n    c. Determine the fill color:\n        - If shape is '5', fill color is azure (8).\n        - If shape is 'H' and has internal red, fill color is yellow (4).\n        - If shape is 'H' and has no internal red, fill color is green (3).\n    d. Fill the interior white (0) pixels in the *output* grid with the determined fill color.\n4. Pixels not part of an enclosed interior remain unchanged.\n\"\"\"\n\ndef find_connected_component(grid, start_coord, target_color, visited):\n    \"\"\"Finds all coordinates of a connected component of target_color using BFS.\"\"\"\n    height, width = grid.shape\n    q = deque([start_coord])\n    component_coords = set()\n    visited.add(start_coord)\n    component_coords.add(start_coord)\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor = (nr, nc)\n\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == target_color and neighbor not in visited:\n                visited.add(neighbor)\n                component_coords.add(neighbor)\n                q.append(neighbor)\n                \n    return component_coords\n\ndef find_interior_coords(grid, boundary_coords):\n    \"\"\"\n    Finds interior white (0) pixels enclosed by boundary_coords.\n    Uses BFS starting from white neighbors of the boundary to identify exterior white pixels.\n    Any remaining white pixels not reachable from the outside are interior.\n    \"\"\"\n    height, width = grid.shape\n    exterior_white = set()\n    q = deque()\n    visited_flood = set()\n\n    # Find initial white pixels adjacent to the boundary or grid edges\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 0:\n                is_boundary_neighbor = False\n                is_edge_pixel = (r == 0 or r == height - 1 or c == 0 or c == width - 1)\n                \n                # Check adjacency to boundary_coords\n                if not is_edge_pixel:\n                     for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1,-1)]: # Check diagonals too for safety\n                         nr, nc = r + dr, c + dc\n                         if (nr, nc) in boundary_coords:\n                             is_boundary_neighbor = True\n                             break\n                \n                # Start BFS from edge white pixels or white pixels adjacent to the *current* boundary\n                if (is_edge_pixel or is_boundary_neighbor) and (r, c) not in visited_flood:\n                    q.append((r, c))\n                    visited_flood.add((r,c))\n                    exterior_white.add((r,c))\n\n    # Perform BFS to find all reachable exterior white pixels\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor = (nr, nc)\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and neighbor not in boundary_coords and \\\n               neighbor not in visited_flood:\n                 visited_flood.add(neighbor)\n                 exterior_white.add(neighbor)\n                 q.append(neighbor)\n\n    # Identify interior pixels: white pixels not in exterior_white and not on the boundary\n    interior_coords = set()\n    for r in range(height):\n        for c in range(width):\n            coord = (r, c)\n            if grid[r, c] == 0 and coord not in exterior_white and coord not in boundary_coords:\n                # Double check it's truly enclosed by *this* boundary\n                # Perform a quick check: are all non-zero, non-boundary neighbours part of this boundary?\n                is_truly_interior = True\n                q_check = deque([coord])\n                visited_check = {coord}\n                component_check = {coord}\n                connected_to_outside_or_other_shape = False\n\n                while q_check:\n                    cr,cc = q_check.popleft()\n                    is_near_target_boundary = False\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = cr + dr, cc + dc\n                         neighbor = (nr, nc)\n\n                         if not (0 <= nr < height and 0 <= nc < width):\n                             connected_to_outside_or_other_shape = True\n                             break\n                         \n                         if neighbor in boundary_coords:\n                             is_near_target_boundary = True\n                         elif grid[nr, nc] == 0 and neighbor not in visited_check:\n                             q_check.append(neighbor)\n                             visited_check.add(neighbor)\n                             component_check.add(neighbor)\n                         elif grid[nr, nc] != 0 and neighbor not in boundary_coords: # Hits another color/shape\n                            connected_to_outside_or_other_shape = True\n                            break\n                    if connected_to_outside_or_other_shape:\n                        break\n                \n                # If the flood fill from this point stayed within white cells OR hit only the target boundary, it's interior\n                if not connected_to_outside_or_other_shape and is_near_target_boundary:\n                     interior_coords.update(component_check) # Add the whole component found\n\n    # Refine: Ensure interior pixels are contiguous and actually bounded by the specific boundary_coords.\n    # The above check is an attempt, but might still incorrectly identify interiors if shapes are complex/adjacent.\n    # A truly robust method often involves winding numbers or point-in-polygon tests on the boundary.\n    # Given ARC constraints, the BFS from exterior might be sufficient if shapes are well-separated.\n    \n    # Let's retry the simple definition: White cells not reachable from the outside.\n    all_interior = set()\n    for r in range(height):\n        for c in range(width):\n             coord = (r,c)\n             if grid[r,c] == 0 and coord not in exterior_white and coord not in boundary_coords:\n                 all_interior.add(coord)\n                 \n    # Now, verify these potential interior points are connected and adjacent only to the boundary or other interior points\n    final_interior = set()\n    visited_final = set()\n    for r_start, c_start in all_interior:\n        if (r_start, c_start) in visited_final:\n            continue\n\n        current_component = set()\n        q_final = deque([(r_start, c_start)])\n        visited_final.add((r_start, c_start))\n        is_bounded_by_current_shape = True\n        \n        while q_final:\n            r,c = q_final.popleft()\n            current_component.add((r,c))\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n                 neighbor = (nr, nc)\n                 \n                 if not (0 <= nr < height and 0 <= nc < width): # Should not happen if exterior fill worked\n                     is_bounded_by_current_shape = False\n                     break\n\n                 if neighbor in boundary_coords:\n                     continue # It's bounded by the shape, that's okay.\n                 elif neighbor in all_interior and neighbor not in visited_final:\n                     visited_final.add(neighbor)\n                     q_final.append(neighbor)\n                 elif neighbor not in all_interior and grid[nr,nc] == 0: # Hits exterior white\n                     is_bounded_by_current_shape = False\n                     break\n                 elif grid[nr,nc] != 0 and neighbor not in boundary_coords: # Hits another shape/color\n                      is_bounded_by_current_shape = False\n                      break\n            if not is_bounded_by_current_shape:\n                 break # This component is not validly interior to this boundary\n        \n        if is_bounded_by_current_shape:\n             final_interior.update(current_component)\n\n\n    return final_interior\n\n\ndef classify_shape(boundary_coords):\n    \"\"\"Classifies the shape as '5' or 'H' based on structure.\"\"\"\n    if not boundary_coords:\n        return None\n\n    rows = [r for r, c in boundary_coords]\n    cols = [c for r, c in boundary_coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Heuristic for 'H': Look for a horizontal bar near the middle row\n    # that is not the top or bottom edge and connects points near min_c and max_c.\n    mid_r_area = range(min_r + height // 3, max_r - height // 3 + 1)\n    \n    has_mid_horizontal_bar = False\n    for r in mid_r_area:\n         # Check if row 'r' contains red pixels spanning a significant width\n         row_pixels = {c for br, bc in boundary_coords if br == r}\n         if not row_pixels:\n             continue\n         \n         min_c_row, max_c_row = min(row_pixels), max(row_pixels)\n         # Check for continuity across the middle\n         is_continuous = True\n         for c in range(min_c_row, max_c_row + 1):\n             if (r, c) not in boundary_coords:\n                 is_continuous = False\n                 break\n         # Check if it spans a good portion of the width and isn't top/bottom boundary element\n         if is_continuous and (max_c_row - min_c_row + 1) > width / 2 and r != min_r and r != max_r:\n             has_mid_horizontal_bar = True\n             break\n             \n    if has_mid_horizontal_bar:\n        # Further check: Does it connect two vertical segments?\n        # Look for vertical segments above and below the bar near min_c and max_c\n        has_left_vertical = any((r_check, min_c_row) in boundary_coords for r_check in range(min_r, r)) and \\\n                            any((r_check, min_c_row) in boundary_coords for r_check in range(r + 1, max_r + 1))\n        has_right_vertical = any((r_check, max_c_row) in boundary_coords for r_check in range(min_r, r)) and \\\n                             any((r_check, max_c_row) in boundary_coords for r_check in range(r + 1, max_r + 1))\n        \n        if has_left_vertical and has_right_vertical:\n             return 'H'\n\n    # If not clearly 'H', assume '5' based on the examples provided\n    return '5'\n\n\ndef check_internal_red(input_grid, interior_coords):\n    \"\"\"Checks if any red (2) pixel exists within the interior coordinates.\"\"\"\n    for r, c in interior_coords:\n        if input_grid[r, c] == 2:\n            return True\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding red shapes ('5' or 'H'), \n    determining their interior, and filling the interior based on shape type \n    and presence of internal red pixels.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    visited_shapes = set() # Keep track of red pixels already processed as part of a shape\n\n    # Iterate through the grid to find potential starting points for red shapes\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] == 2 and (r, c) not in visited_shapes:\n                # Found a potential start of a red shape, find its connected component\n                boundary_coords = find_connected_component(input_grid, (r, c), 2, visited_shapes)\n\n                # Find the interior pixels enclosed by this boundary\n                # Pass the original grid and the found boundary\n                interior_coords = find_interior_coords(input_grid, boundary_coords)\n\n                # If interior pixels exist, process this shape\n                if interior_coords:\n                    # Classify the shape based on the boundary\n                    shape_type = classify_shape(boundary_coords)\n                    \n                    # Check if the *input* grid had red pixels in the interior area\n                    internal_red_present = check_internal_red(input_grid, interior_coords)\n                    \n                    # Determine the fill color based on the rules\n                    fill_color = 0 # Default to white (shouldn't happen if interior_coords exist)\n                    if shape_type == '5':\n                        fill_color = 8 # Azure\n                    elif shape_type == 'H':\n                        if internal_red_present:\n                            fill_color = 4 # Yellow\n                        else:\n                            fill_color = 3 # Green\n                    else:\n                        # Should not happen for valid inputs based on examples\n                        # If classification failed, maybe leave interior as is or use a default?\n                        # Let's skip filling if classification fails.\n                        continue \n\n                    # Fill the interior white pixels in the output grid\n                    for ir, ic in interior_coords:\n                        # Only fill if the pixel is currently white (0)\n                        # This preserves any original internal red pixels\n                        if output_grid[ir, ic] == 0: \n                            output_grid[ir, ic] = fill_color\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4180,
    "candidates_token_count": 3557,
    "total_token_count": 7737,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.406816,
  "retries": null
}