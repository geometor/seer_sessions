{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis task requires identifying the largest hollow rectangular frame made of a single, non-background color within the input grid. \nThe output is the content found strictly inside this frame.\n\nThe process involves:\n1. Scan the input grid to identify all possible hollow rectangular frames. A frame is defined by its top-left (r1, c1) and bottom-right (r2, c2) corners.\n2. A valid frame must meet these criteria:\n    a. The boundary pixels (top row r1 from c1 to c2, bottom row r2 from c1 to c2, left column c1 from r1+1 to r2-1, right column c2 from r1+1 to r2-1) must all be of the same single non-background color (1-9).\n    b. The frame must have an interior, meaning height (r2-r1+1) > 2 and width (c2-c1+1) > 2.\n    c. The interior region (pixels from r1+1 to r2-1, c1+1 to c2-1) must contain at least one pixel whose color is different from the frame's boundary color.\n3. Calculate the area (height * width) of the bounding box for each valid frame found.\n4. Select the frame with the largest bounding box area. \n5. Apply tie-breaking rules if multiple frames share the largest area: choose the one whose top-left corner (r1, c1) has the smallest row index (r1), and then the smallest column index (c1).\n6. Extract the subgrid corresponding to the interior region of the selected frame (rows r1+1 to r2-1, columns c1+1 to c2-1).\n7. Return this extracted subgrid as the output.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _is_hollow_frame(grid: np.ndarray, r1: int, c1: int, r2: int, c2: int) -> Tuple[bool, Optional[int], Optional[int]]:\n    \"\"\"\n    Checks if the rectangle defined by (r1, c1) and (r2, c2) forms a valid hollow frame.\n\n    Args:\n        grid: The input grid as a numpy array.\n        r1, c1: Top-left corner coordinates.\n        r2, c2: Bottom-right corner coordinates.\n\n    Returns:\n        A tuple: (is_frame, frame_color, area)\n        is_frame (bool): True if it's a valid hollow frame, False otherwise.\n        frame_color (Optional[int]): The color of the frame if valid, None otherwise.\n        area (Optional[int]): The area of the frame's bounding box if valid, None otherwise.\n    \"\"\"\n    height = r2 - r1 + 1\n    width = c2 - c1 + 1\n\n    # Frame must have dimensions at least 3x3 to have an interior\n    if height < 3 or width < 3:\n        return False, None, None\n\n    # Check top-left corner for frame color\n    frame_color = grid[r1, c1]\n    if frame_color == 0:  # Frame color cannot be background\n        return False, None, None\n\n    # Check boundary pixels\n    # Top row\n    if not np.all(grid[r1, c1:c2+1] == frame_color):\n        return False, None, None\n    # Bottom row\n    if not np.all(grid[r2, c1:c2+1] == frame_color):\n        return False, None, None\n    # Left column (excluding corners)\n    if not np.all(grid[r1+1:r2, c1] == frame_color):\n        return False, None, None\n    # Right column (excluding corners)\n    if not np.all(grid[r1+1:r2, c2] == frame_color):\n        return False, None, None\n\n    # Check interior condition: at least one pixel must differ from frame_color\n    interior = grid[r1+1:r2, c1+1:c2]\n    if np.all(interior == frame_color):\n        return False, None, None\n        \n    # If all checks pass, it's a valid frame\n    area = height * width\n    return True, frame_color, area\n\ndef find_frames(grid: np.ndarray) -> List[dict]:\n    \"\"\"\n    Finds all valid hollow rectangular frames in the grid.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a frame\n        with keys: 'r1', 'c1', 'r2', 'c2', 'color', 'area'.\n    \"\"\"\n    rows, cols = grid.shape\n    frames = []\n\n    # Iterate through all possible top-left (r1, c1) corners\n    for r1 in range(rows):\n        for c1 in range(cols):\n            # Iterate through all possible bottom-right (r2, c2) corners\n            # such that r2 >= r1 and c2 >= c1\n            for r2 in range(r1, rows):\n                for c2 in range(c1, cols):\n                    is_frame, frame_color, area = _is_hollow_frame(grid, r1, c1, r2, c2)\n                    if is_frame:\n                        frames.append({\n                            'r1': r1, 'c1': c1,\n                            'r2': r2, 'c2': c2,\n                            'color': frame_color,\n                            'area': area\n                        })\n    return frames\n\ndef select_largest_frame(frames: List[dict]) -> Optional[dict]:\n    \"\"\"\n    Selects the largest frame based on area, with tie-breaking.\n\n    Args:\n        frames: A list of frame dictionaries.\n\n    Returns:\n        The dictionary of the selected frame, or None if no frames were found.\n    \"\"\"\n    if not frames:\n        return None\n\n    # Sort frames:\n    # 1. By area (descending)\n    # 2. By top row (r1, ascending)\n    # 3. By left column (c1, ascending)\n    sorted_frames = sorted(frames, key=lambda f: (-f['area'], f['r1'], f['c1']))\n\n    return sorted_frames[0]\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Identifies the largest hollow rectangular frame of a single non-background color\n    in the input grid and returns the content strictly inside that frame.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the extracted interior of the largest frame.\n        Returns an empty list if no valid frame is found.\n    \"\"\"\n    # Convert input to numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    \n    if grid_np.size == 0:\n        return [] # Handle empty input\n\n    # Find all valid hollow rectangular frames\n    frames = find_frames(grid_np)\n\n    # Select the largest frame based on area and tie-breaking rules\n    largest_frame = select_largest_frame(frames)\n\n    # If no frame is found, return an empty grid (or handle as appropriate)\n    if largest_frame is None:\n        # Based on examples, it seems a frame is always expected.\n        # If this can happen, decide on behavior (e.g., return empty grid, input grid, error?)\n        # For now, returning an empty list.\n        return [] \n\n    # Extract the interior of the selected frame\n    r1, c1 = largest_frame['r1'], largest_frame['c1']\n    r2, c2 = largest_frame['r2'], largest_frame['c2']\n    \n    # Interior coordinates are (r1+1 : r2, c1+1 : c2)\n    output_np = grid_np[r1+1:r2, c1+1:c2]\n\n    # Convert output numpy array back to list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4533,
    "candidates_token_count": 1915,
    "total_token_count": 6448,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.24825,
  "retries": null
}