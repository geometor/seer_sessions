{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous red objects (color 2) within distinct background regions \n(color 1 - blue or 8 - azure). For each red object, determines the horizontal \nboundaries (min and max column) of its containing background region. \nIf the background region is blue (1), the object is moved horizontally to the \nright edge of the region. \nIf the background region is azure (8), the object is moved horizontally to the \nleft edge of the region. \nThe object's vertical position remains unchanged. The background regions themselves \nare static.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates\n              of the pixels belonging to a single object. Returns empty list if \n              no objects of the specified color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Start BFS from this pixel\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                             # Check if neighbor is the same color and not visited\n                             if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                # Add the found object's coordinates to the list if it's not empty\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_background_region_boundaries(grid, obj_coords):\n    \"\"\"\n    Determines the background color and horizontal boundaries of the connected \n    background region immediately surrounding or containing the object.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_coords (set): Set of (row, col) coordinates for the object.\n\n    Returns:\n        tuple: (background_color, region_min_col, region_max_col) or\n               (None, -1, -1) if no valid background region is found adjacent \n               to the object.\n    \"\"\"\n    height, width = grid.shape\n    object_color = 2 # Assuming objects are always red (color 2)\n    \n    # Find a starting pixel for the background BFS\n    q_start_points = deque()\n    visited_bg_search = set() # Keep track of visited pixels during background search\n    background_color = -1\n\n    # Check neighbors of all object pixels to find a valid background starting point\n    for r_obj, c_obj in obj_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_obj + dr, c_obj + dc\n            # Check if neighbor is within bounds and not part of the object itself\n            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in obj_coords:\n                potential_bg_color = grid[nr, nc]\n                # Check if it's a valid background color (blue or azure)\n                if potential_bg_color == 1 or potential_bg_color == 8:\n                     # If we haven't found a background color yet, set it\n                     if background_color == -1:\n                         background_color = potential_bg_color\n                         # Add this neighbor as a starting point if it matches the determined color\n                         if (nr, nc) not in visited_bg_search:\n                            q_start_points.append((nr, nc))\n                            visited_bg_search.add((nr, nc))\n                     # If we already have a background color, only add neighbors of that color\n                     elif potential_bg_color == background_color:\n                          if (nr, nc) not in visited_bg_search:\n                             q_start_points.append((nr, nc))\n                             visited_bg_search.add((nr, nc))\n                     # If we find a neighbor of a *different* valid background color,\n                     # this indicates an edge case not handled by the simple logic\n                     # (e.g., object touching both blue and azure). Assume the first found color is correct.\n                     # else: pass\n\n    # If no valid adjacent background pixel was found, we cannot determine the region\n    if background_color == -1 or not q_start_points:\n         # Fallback: Check if the object is single pixel and grid has only one background color?\n         # Or maybe the object fills almost the whole grid?\n         # Let's check non-object pixels for a dominant background color.\n         non_obj_pixels = grid[grid != object_color]\n         unique_bg, counts = np.unique(non_obj_pixels, return_counts=True)\n         valid_bg_present = [c for c in unique_bg if c == 1 or c == 8]\n\n         if len(valid_bg_present) == 1:\n             background_color = valid_bg_present[0]\n             # Need to find *any* pixel of this color to start BFS\n             bg_indices = np.argwhere(grid == background_color)\n             if len(bg_indices) > 0:\n                 start_node = tuple(bg_indices[0])\n                 if start_node not in visited_bg_search:\n                     q_start_points.append(start_node)\n                     visited_bg_search.add(start_node)\n                 # else: it was already found near the object, but queue was empty? Unlikely.\n             else:\n                 return None, -1, -1 # No pixels of this background color found\n\n         elif len(valid_bg_present) == 0:\n              return None, -1, -1 # No blue or azure pixels found at all\n         else: # Both blue and azure present, but none adjacent? Ambiguous.\n             # Stick with the first one found if any adjacent was found, otherwise fail.\n             if background_color == -1: # implies q_start_points is empty too\n                 return None, -1, -1\n\n    # BFS to find all connected background pixels of the determined color\n    region_coords = set()\n    q = q_start_points # Use the starting points found near the object\n    visited_bfs = visited_bg_search # Reuse visited set\n\n    while q:\n        row, col = q.popleft()\n        region_coords.add((row, col))\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = row + dr, col + dc\n            # Check bounds, ensure it's the correct background color, and not visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == background_color and (nr, nc) not in visited_bfs:\n                visited_bfs.add((nr, nc))\n                q.append((nr, nc))\n\n    # If BFS didn't find any region coords (shouldn't happen if q_start_points had items)\n    if not region_coords:\n        print(f\"Warning: BFS for background region failed despite finding start points for object near {next(iter(obj_coords))}.\")\n        return background_color, -1, -1 # Return color but indicate boundary failure\n\n    # Determine min/max col of the background region from the coordinates found\n    region_min_col = width\n    region_max_col = -1\n    for r_reg, c_reg in region_coords:\n        region_min_col = min(region_min_col, c_reg)\n        region_max_col = max(region_max_col, c_reg)\n\n    # Handle case where region was technically found but resulted in invalid bounds (e.g., empty after filtering?)\n    if region_min_col == width or region_max_col == -1:\n        print(f\"Warning: Calculated invalid region boundaries for object near {next(iter(obj_coords))}.\")\n        return background_color, -1, -1\n\n    return background_color, region_min_col, region_max_col\n\n\ndef get_object_boundaries(obj_coords):\n    \"\"\"\n    Finds the minimum and maximum column index occupied by the object.\n\n    Args:\n        obj_coords (set): Set of (row, col) coordinates for the object.\n\n    Returns:\n        tuple: (object_min_col, object_max_col) or (-1, -1) if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return -1, -1\n    \n    # Initialize min_col to positive infinity and max_col to negative infinity\n    min_col = float('inf')\n    max_col = float('-inf')\n    \n    # Iterate through object coordinates to find min and max columns\n    for _, c in obj_coords:\n        min_col = min(min_col, c)\n        max_col = max(max_col, c)\n        \n    # Check if min_col or max_col were updated, if not, return invalid bounds\n    if min_col == float('inf') or max_col == float('-inf'):\n        return -1, -1\n        \n    return int(min_col), int(max_col)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Moves red objects (2) within blue (1) or azure (8) backgrounds.\n    Objects in blue backgrounds move to the right boundary of their background region.\n    Objects in azure backgrounds move to the left boundary of their background region.\n    \"\"\"\n    # Convert input grid list of lists to a NumPy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy of the input grid to modify and return as the output\n    output_np = np.copy(input_np)\n    height, width = output_np.shape\n    object_color = 2\n    blue_color = 1\n    azure_color = 8\n\n    # Find all red objects in the input grid\n    red_objects = find_objects(input_np, object_color)\n\n    # Process each red object found\n    for obj_coords in red_objects:\n        if not obj_coords:\n            continue # Skip if somehow an empty object set was returned\n\n        # Determine the background color and boundaries for the current object\n        background_color, region_min_col, region_max_col = get_background_region_boundaries(input_np, obj_coords)\n\n        # If background region details are invalid, skip processing this object\n        if background_color is None or region_min_col == -1 or region_max_col == -1:\n            # Optional: print a warning\n            # print(f\"Warning: Could not determine valid region for object starting near {next(iter(obj_coords))}. Skipping.\")\n            continue\n\n        # Determine the object's current horizontal boundaries\n        object_min_col, object_max_col = get_object_boundaries(obj_coords)\n        \n        # If object boundaries are invalid, skip\n        if object_min_col == -1 or object_max_col == -1:\n             # Optional: print a warning\n             # print(f\"Warning: Could not determine valid boundaries for object starting near {next(iter(obj_coords))}. Skipping.\")\n             continue\n\n        # Calculate the required horizontal shift based on the background color\n        shift_amount = 0\n        if background_color == blue_color:\n            # Move Right: Shift needed to align object's right edge with region's right edge\n            shift_amount = region_max_col - object_max_col\n        elif background_color == azure_color:\n            # Move Left: Shift needed to align object's left edge with region's left edge\n            shift_amount = region_min_col - object_min_col # This will be <= 0\n        else:\n            # Should not happen if get_background_region_boundaries works correctly\n            # print(f\"Warning: Invalid background color {background_color} determined. Skipping object.\")\n            continue\n            \n        # Only perform the move if a shift is necessary\n        if shift_amount != 0:\n            # Erase the object from its original position in the output grid\n            # Set the original object pixels to the determined background color\n            for r, c in obj_coords:\n                # Basic boundary check for safety, though coordinates should be valid\n                if 0 <= r < height and 0 <= c < width:\n                     output_np[r, c] = background_color \n\n            # Draw the object in its new position\n            for r, c in obj_coords:\n                # Calculate the new column position\n                new_c = c + shift_amount\n                # Check if the new position is within grid bounds\n                if 0 <= r < height and 0 <= new_c < width:\n                     output_np[r, new_c] = object_color\n                else:\n                     # This indicates an error in logic or boundary calculation,\n                     # as the object should stay within the calculated region boundaries.\n                     # Optional: print a warning\n                     # print(f\"Warning: Object pixel ({r},{c}) moved out of bounds to ({r},{new_c}). Region: {region_min_col}-{region_max_col}. Shift: {shift_amount}\")\n                     # As a fallback, maybe revert the erase? Or leave as is?\n                     # Reverting the erase might be safer if the move failed.\n                     # However, the specification implies the move should always be valid.\n                     # Let's stick to drawing within bounds. If a pixel goes out, it's lost,\n                     # which might reveal the error more clearly than partial drawing.\n                     pass \n\n    # Convert the final NumPy array back to a list of lists for the return value\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10011,
    "candidates_token_count": 3441,
    "total_token_count": 13452,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 120.293998,
  "retries": null
}