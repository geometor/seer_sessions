{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous objects of color 2 (red) within distinct background regions \n(color 1 - blue or 8 - azure). For each red object, determines the horizontal \nboundaries of its containing background region. Calculates the horizontal distance \nfrom the object's edges to the region's left and right boundaries. Moves the \nobject horizontally towards the *closer* boundary until it touches that boundary. \nThe object's vertical position remains unchanged. The background regions themselves \nare static.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates\n              of the pixels belonging to a single object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_background_region_boundaries(grid, obj_coords):\n    \"\"\"\n    Determines the background color and horizontal boundaries of the region\n    containing the object.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_coords (set): Set of (row, col) coordinates for the object.\n\n    Returns:\n        tuple: (background_color, region_min_col, region_max_col) or\n               (None, -1, -1) if background cannot be determined.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Find a representative point and try to find an adjacent background pixel\n    start_r, start_c = next(iter(obj_coords)) # Get one coordinate from the object\n    background_color = -1\n    q_start_points = deque()\n\n    # Check neighbors of all object pixels to find background color and starting points for BFS\n    visited_bg_check = set() # Track pixels checked for background identification\n    \n    for r_obj, c_obj in obj_coords:\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_obj + dr, c_obj + dc\n            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in obj_coords:\n                potential_bg_color = grid[nr, nc]\n                if potential_bg_color != 2: # Must not be red (the object color)\n                    background_color = potential_bg_color\n                    # Add this neighbor as a potential starting point for region BFS\n                    if (nr, nc) not in visited_bg_check:\n                        q_start_points.append((nr, nc))\n                        visited_bg_check.add((nr, nc))\n\n    if background_color == -1:\n        # Should not happen based on examples, but handle case where object has no non-red neighbors\n        # Or object fills the entire grid? Highly unlikely. Could also happen if object touches grid edge only.\n        # Let's assume background is the most common color *not* red if this fails. This is a heuristic.\n         colors, counts = np.unique(grid[grid != 2], return_counts=True)\n         if len(colors)>0:\n              background_color = colors[np.argmax(counts)]\n              # Need a starting point for BFS still if q_start_points is empty\n              # This part is tricky, relies on object not touching *all* boundaries\n              if not q_start_points:\n                   # Find any pixel with background_color, preferably close to the object\n                   # For simplicity, just find the first instance\n                   bg_indices = np.argwhere(grid == background_color)\n                   if len(bg_indices) > 0:\n                       q_start_points.append(tuple(bg_indices[0]))\n                       visited_bg_check.add(tuple(bg_indices[0]))\n                   else: # No background pixels found? Error state.\n                       return None, -1, -1 # Indicate error\n         else: # Only red pixels in grid? Error state.\n             return None, -1, -1\n\n    if not q_start_points:\n        # If we identified a background color but couldn't find a starting pixel adjacent\n        # to the object (e.g., single pixel object in a corner), find any pixel of that color.\n         bg_indices = np.argwhere(grid == background_color)\n         if len(bg_indices) > 0:\n             start_bg_pixel = tuple(bg_indices[0])\n             if start_bg_pixel not in visited_bg_check:\n                  q_start_points.append(start_bg_pixel)\n                  visited_bg_check.add(start_bg_pixel)\n         else:\n              return None, -1, -1 # No pixels of this background color exist\n\n    # BFS to find all connected background pixels\n    region_coords = set()\n    q = q_start_points # Use the starting points found earlier\n    visited_bfs = visited_bg_check.copy() # Keep track of visited during this BFS\n\n    while q:\n        row, col = q.popleft()\n        region_coords.add((row, col))\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == background_color and (nr, nc) not in visited_bfs:\n                visited_bfs.add((nr, nc))\n                q.append((nr, nc))\n\n    if not region_coords:\n         # Fallback if BFS from neighbours failed to find a region.\n         # This might happen if the determined background color isn't connected\n         # to the object neighbours found earlier. Search entire grid for the color.\n         bg_indices = np.argwhere(grid == background_color)\n         if len(bg_indices) > 0:\n             start_bg_pixel = tuple(bg_indices[0])\n             q = deque([start_bg_pixel])\n             visited_bfs = {start_bg_pixel}\n             while q:\n                 row, col = q.popleft()\n                 region_coords.add((row, col))\n                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                     nr, nc = row + dr, col + dc\n                     if 0 <= nr < height and 0 <= nc < width and \\\n                        grid[nr, nc] == background_color and (nr, nc) not in visited_bfs:\n                         visited_bfs.add((nr, nc))\n                         q.append((nr, nc))\n         else: # Really cannot find the background region\n              return background_color, -1, -1 # Return color, but invalid bounds\n\n    # Determine min/max col of the background region\n    region_min_col = width\n    region_max_col = -1\n    for r_reg, c_reg in region_coords:\n        region_min_col = min(region_min_col, c_reg)\n        region_max_col = max(region_max_col, c_reg)\n\n    if region_min_col == width: # Handle case where region was empty\n        return background_color, -1, -1\n\n    return background_color, region_min_col, region_max_col\n\n\ndef get_object_boundaries(obj_coords):\n    \"\"\"\n    Finds the minimum and maximum column index occupied by the object.\n\n    Args:\n        obj_coords (set): Set of (row, col) coordinates for the object.\n\n    Returns:\n        tuple: (object_min_col, object_max_col)\n    \"\"\"\n    if not obj_coords:\n        return -1, -1\n    min_col = float('inf')\n    max_col = float('-inf')\n    for _, c in obj_coords:\n        min_col = min(min_col, c)\n        max_col = max(max_col, c)\n    return min_col, max_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves red objects horizontally to the nearest vertical boundary of their\n    background region.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    object_color = 2\n\n    # Find all red objects\n    red_objects = find_objects(input_np, object_color)\n\n    for obj_coords in red_objects:\n        if not obj_coords:\n            continue\n\n        # Determine the background region and its boundaries\n        background_color, region_min_col, region_max_col = get_background_region_boundaries(input_np, obj_coords)\n\n        # If region boundaries are invalid, skip this object\n        if region_min_col == -1 or region_max_col == -1 or background_color is None:\n            print(f\"Warning: Could not determine valid region for object at {next(iter(obj_coords))}. Skipping.\")\n            continue\n\n        # Determine the object's horizontal boundaries\n        object_min_col, object_max_col = get_object_boundaries(obj_coords)\n\n        # Calculate distances to boundaries\n        dist_left = object_min_col - region_min_col\n        dist_right = region_max_col - object_max_col\n\n        # Determine shift amount\n        shift_amount = 0\n        if dist_left <= dist_right:\n            # Move left\n            shift_amount = -dist_left\n        else:\n            # Move right\n            shift_amount = dist_right\n            \n        # Don't move if already touching the target boundary\n        if shift_amount == 0:\n             continue\n\n        # Erase the object from its original position in the output grid\n        for r, c in obj_coords:\n            # Check bounds just in case, though should be within grid\n            if 0 <= r < output_np.shape[0] and 0 <= c < output_np.shape[1]:\n                 output_np[r, c] = background_color # Set to background color\n\n        # Draw the object in its new position\n        for r, c in obj_coords:\n            new_c = c + shift_amount\n            # Check bounds for the new position\n            if 0 <= r < output_np.shape[0] and 0 <= new_c < output_np.shape[1]:\n                 output_np[r, new_c] = object_color\n            else:\n                 # This case implies an error in boundary calculation or logic,\n                 # as the object should stay within its region boundaries.\n                 print(f\"Warning: Object pixel ({r},{c}) moved out of bounds to ({r},{new_c}). Original boundaries: {region_min_col}-{region_max_col}. Shift: {shift_amount}\")\n                 # As a fallback, draw it back at original position? Or leave it erased?\n                 # Leaving it erased might be safer than drawing potentially wrong pixel.\n                 # Let's try drawing back at original pos, hoping background erase happened.\n                 if 0 <= r < output_np.shape[0] and 0 <= c < output_np.shape[1]:\n                    output_np[r, c] = object_color # Revert this pixel\n\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4779,
    "candidates_token_count": 2929,
    "total_token_count": 7708,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.933212,
  "retries": null
}