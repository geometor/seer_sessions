{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects as scipy_find_objects\n\n\"\"\"\nIdentifies all connected components (objects) of non-white pixels (colors 3-green and 9-maroon) using 8-way connectivity.\nCalculates the number of maroon (9) pixels within each object ('maroon_count') and the total size of the object ('size').\nDetermines the median 'maroon_count' across all objects (using the lower median if the number of objects is even).\nSelects the object(s) whose 'maroon_count' matches this median value.\nIf multiple objects match the median count, selects the one with the largest 'size'.\nIf there's still a tie in size, selects the object whose top-most, then left-most pixel occurs first in grid scan order (row-major).\nRemoves the selected object by changing all its pixels to white (0) in the output grid.\nIf no non-white objects are found, returns the input grid unchanged.\n\"\"\"\n\ndef get_objects_properties(grid):\n    \"\"\"\n    Finds all connected non-background objects (value != 0) in the grid\n    using 8-way connectivity and calculates their properties.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (list of (r, c) tuples), 'maroon_count' (int),\n              'size' (int), and 'top_left' (tuple (min_row, min_col)).\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    # Define connectivity for 8-way (including diagonals)\n    structure = np.array([[1, 1, 1],\n                          [1, 1, 1],\n                          [1, 1, 1]], dtype=bool)\n\n    # Create a boolean mask where True indicates non-background pixels\n    mask = grid != 0\n\n    # Label connected components\n    labeled_array, num_features = label(mask, structure=structure)\n\n    if num_features == 0:\n        return []\n\n    # Find the bounding boxes and coordinates for each labeled object\n    objects_slices = scipy_find_objects(labeled_array)\n    objects_properties = []\n\n    for i in range(num_features):\n        obj_label = i + 1\n        coords = list(zip(*np.where(labeled_array == obj_label)))\n\n        if not coords: # Should not happen with scipy_find_objects result but safety check\n            continue\n\n        maroon_count = 0\n        size = len(coords)\n        min_row = float('inf')\n        min_col_at_min_row = float('inf')\n\n        for r, c in coords:\n            if grid[r, c] == 9: # Count maroon pixels\n                maroon_count += 1\n            # Determine the top-most, left-most coordinate for tie-breaking\n            if r < min_row:\n                min_row = r\n                min_col_at_min_row = c\n            elif r == min_row and c < min_col_at_min_row:\n                min_col_at_min_row = c\n\n        objects_properties.append({\n            'coords': coords,\n            'maroon_count': maroon_count,\n            'size': size,\n            'top_left': (min_row, min_col_at_min_row) # Store for tie-breaking\n        })\n\n    return objects_properties\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify all distinct non-white objects and their properties\n    objects = get_objects_properties(output_grid)\n\n    # If no objects found, return the original grid\n    if not objects:\n        return output_grid\n\n    # 2. Calculate maroon_count and size (done in get_objects_properties)\n\n    # 3. Create a list of maroon_counts\n    maroon_counts = [obj['maroon_count'] for obj in objects]\n\n    # 4. Determine the target median maroon_count\n    sorted_counts = sorted(maroon_counts)\n    n = len(sorted_counts)\n    if n % 2 == 1:\n        median_index = n // 2\n        target_maroon_count = sorted_counts[median_index]\n    else:\n        # Use the lower median for even number of objects\n        median_index = n // 2 - 1\n        target_maroon_count = sorted_counts[median_index]\n\n    # 5. Identify all objects matching the target_maroon_count\n    matching_objects = [obj for obj in objects if obj['maroon_count'] == target_maroon_count]\n\n    # 6. & 7. Select the object to remove based on criteria\n    object_to_remove = None\n    if len(matching_objects) == 1:\n        object_to_remove = matching_objects[0]\n    elif len(matching_objects) > 1:\n        # Tie-breaker 1: Largest size\n        max_size = -1\n        potential_objects = []\n        for obj in matching_objects:\n            if obj['size'] > max_size:\n                max_size = obj['size']\n                potential_objects = [obj]\n            elif obj['size'] == max_size:\n                potential_objects.append(obj)\n\n        if len(potential_objects) == 1:\n             object_to_remove = potential_objects[0]\n        else:\n             # Tie-breaker 2: Top-most, then left-most pixel\n             potential_objects.sort(key=lambda obj: (obj['top_left'][0], obj['top_left'][1]))\n             object_to_remove = potential_objects[0]\n\n\n    # 8. Create output grid (already done by copying input)\n\n    # 9. Remove the selected object by setting its pixels to white (0)\n    if object_to_remove:\n        for r, c in object_to_remove['coords']:\n            output_grid[r, c] = 0\n\n    # 10. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6178,
    "candidates_token_count": 1537,
    "total_token_count": 7715,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.434897,
  "retries": null
}