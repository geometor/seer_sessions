
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 8 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0
8 8 8 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3
0 0 0 0 0 0 0 0 0 3 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 4 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 8 0 0 0 4 0 0 0
0 0 8 0 0 0 4 0 0 0
0 0 8 0 0 0 4 0 0 0
8 8 8 0 0 0 4 0 0 0
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 5 5
0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 9 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 9 0 0 0
0 0 0 0 9 0 0 0
0 0 0 0 9 0 0 0
0 0 0 0 9 0 0 0
0 0 0 0 9 9 9 9
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```

*   **Perception:** The task involves transforming an input grid containing a few isolated, non-white pixels into an output grid. The transformation adds lines extending from each original non-white pixel. These lines are always orthogonal (horizontal and vertical) and use the same color as the source pixel. The lines extend towards the two nearest edges of the grid from the source pixel's location.

*   **YAML Facts:**
    
```yaml
    task_description: Extends lines from colored pixels towards the two nearest grid edges.
    elements:
      - element: grid
        description: A 2D array of pixels with values 0-9 representing colors.
        properties:
          - height: Integer number of rows.
          - width: Integer number of columns.
      - element: pixel
        description: A single cell in the grid.
        properties:
          - value: Integer 0-9 representing a color.
          - color: String name of the color (white, blue, red, etc.).
          - position: Tuple (row, column) indicating location.
      - element: object
        description: A single non-white pixel in the input grid.
        properties:
          - color: The color of the pixel.
          - position: The (row, column) of the pixel.
          - distances_to_edges:
              - top: Row index.
              - bottom: Grid height - 1 - row index.
              - left: Column index.
              - right: Grid width - 1 - column index.
    actions:
      - action: find_non_white_pixels
        description: Identify all pixels in the input grid that are not white (value > 0).
      - action: calculate_edge_distances
        description: For each non-white pixel, calculate its distance to the top, bottom, left, and right edges.
      - action: identify_closest_edges
        description: Determine the two edges with the minimum distances. Handle ties using a priority order (Top, Left, Bottom, Right).
      - action: draw_lines
        description: For each non-white pixel, draw two lines of its color. One line extends vertically towards the closest top/bottom edge, and the other extends horizontally towards the closest left/right edge, based on the identified closest edges. The lines start from the pixel's original position and end at the grid edge.
    relationships:
      - The output grid is the input grid modified by the drawn lines.
      - Each non-white pixel in the input corresponds to itself and two extending lines in the output.
      - The direction and length of the lines depend on the pixel's position relative to the grid boundaries.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Iterate through each pixel of the input grid.
    3.  If a pixel is not white (value > 0):
        a.  Identify its color and position (row, col).
        b.  Calculate the distances to the four edges: `dist_top = row`, `dist_bottom = grid_height - 1 - row`, `dist_left = col`, `dist_right = grid_width - 1 - col`.
        c.  Store these distances along with their corresponding directions: `[(dist_top, 'up'), (dist_bottom, 'down'), (dist_left, 'left'), (dist_right, 'right')]`.
        d.  Sort these pairs first by distance (ascending) and then by a direction priority ('up', 'left', 'down', 'right') for tie-breaking.
        e.  Select the first two directions from the sorted list. These represent the directions towards the two closest edges.
        f.  For each of the two selected directions:
            i.  If the direction is 'up', fill pixels in the output grid with the identified color from `(row, col)` up to `(0, col)`, inclusive.
            ii. If the direction is 'down', fill pixels in the output grid with the identified color from `(row, col)` down to `(grid_height - 1, col)`, inclusive.
            iii. If the direction is 'left', fill pixels in the output grid with the identified color from `(row, col)` left to `(row, 0)`, inclusive.
            iv. If the direction is 'right', fill pixels in the output grid with the identified color from `(row, col)` right to `(row, grid_width - 1)`, inclusive.
    4.  Return the modified output grid.
