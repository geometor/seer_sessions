{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies all distinct colored objects (contiguous non-white pixels) in the input grid.\nCalculates the bounding box, area, and aspect ratio for each object.\nDetermines a 'center object' based on the minimum bounding box area, using aspect ratio closeness to 1 as a tie-breaker.\nSorts the remaining objects by bounding box area in ascending order. This defines the layer order from inside to outside.\nDetermines the output grid size (N x N) based on the largest dimension (width or height) of any object's bounding box.\nConstructs the output grid by drawing concentric filled square layers, starting from the outermost layer and working inwards.\nThe outermost layer (N x N) uses the color of the object with the largest area (excluding the center object if it's not the largest).\nSubsequent layers decrease in size by 2 (e.g., (N-2)x(N-2), (N-4)x(N-4)...) and use the colors of the objects in descending order of area.\nThe innermost layer uses the color of the 'center object'.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous blocks of non-background (non-zero) pixels.\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        list: A list of objects, where each object is a tuple containing:\n              - color (int): The color of the object.\n              - coordinates (list): A list of (row, col) tuples for pixels belonging to the object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is not background (0) and not visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Breadth-First Search (BFS) to find connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    objects.append((color, obj_coords))\n                    \n    return objects\n\ndef calculate_bounding_boxes(objects):\n    \"\"\"\n    Calculates bounding box properties for each object.\n\n    Args:\n        objects (list): List of objects from find_objects.\n\n    Returns:\n        list: A list of dictionaries, each containing object properties:\n              'color', 'coords', 'bbox' (min_r, min_c, max_r, max_c), \n              'width', 'height', 'area', 'aspect_ratio'.\n              Returns empty list if input objects list is empty.\n    \"\"\"\n    object_details = []\n    if not objects:\n        return object_details\n\n    for color, coords in objects:\n        if not coords: continue # Skip if an object somehow has no coordinates\n\n        rows = [r for r, c in coords]\n        cols = [c for r, c in coords]\n        \n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        \n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        area = width * height\n        \n        # Calculate aspect ratio (larger dim / smaller dim), handle 0 dim case\n        if min(width, height) > 0:\n            aspect_ratio = max(width, height) / min(width, height)\n        else:\n            # Should not happen for valid objects, but handle defensively\n            aspect_ratio = float('inf') \n\n        object_details.append({\n            'color': color,\n            'coords': coords,\n            'bbox': (min_r, min_c, max_r, max_c),\n            'width': width,\n            'height': height,\n            'area': area,\n            'aspect_ratio': aspect_ratio\n        })\n        \n    return object_details\n\ndef draw_centered_square(grid, layer_size, color):\n    \"\"\" Draws a filled centered square of given size and color onto the grid. \"\"\"\n    grid_size = grid.shape[0] # Assuming square grid\n    if layer_size <= 0:\n        return # Cannot draw non-positive size square\n\n    # Calculate top-left corner for centering\n    start_r = (grid_size - layer_size) // 2\n    start_c = (grid_size - layer_size) // 2\n    \n    # Ensure calculated coordinates are within bounds (can happen if layer_size > grid_size)\n    start_r = max(0, start_r)\n    start_c = max(0, start_c)\n    end_r = min(grid_size, start_r + layer_size)\n    end_c = min(grid_size, start_c + layer_size)\n\n    # Fill the square area\n    grid[start_r:end_r, start_c:end_c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identified object properties.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify Objects\n    objects_found = find_objects(input_np)\n    if not objects_found:\n        # Return a minimal grid if no objects found\n        return [[0]] \n\n    # 2. Analyze Objects (Calculate Bounding Box Properties)\n    object_details = calculate_bounding_boxes(objects_found)\n    if not object_details:\n         # Should not happen if objects_found is not empty, but handle defensively\n        return [[0]]\n\n    # 3. Determine Output Size\n    # Find the maximum dimension (width or height) among all bounding boxes\n    max_dim = 0\n    for obj in object_details:\n        max_dim = max(max_dim, obj['width'], obj['height'])\n    \n    output_size = max_dim\n    if output_size == 0: # Handle edge case where objects might be 0-dimensional (shouldn't happen)\n        return [[0]]\n\n    # 4. Order Objects for Layering\n    # Sort primarily by area (ascending), secondarily by aspect ratio deviation from 1 (ascending)\n    object_details.sort(key=lambda x: (x['area'], abs(x['aspect_ratio'] - 1)))\n    \n    # The sorted list `object_details` now represents the layers from inside to outside.\n    # The first element is the 'center object'.\n    \n    # 5. Construct Output Layers (Draw Outside-In)\n    # Initialize the N x N output grid with background color 0\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n    \n    num_layers = len(object_details)\n    \n    # Iterate through the layers from outside (largest area object) to inside (center object)\n    for i in range(num_layers):\n        # The object for the current layer (working from outside inwards)\n        # Index `num_layers - 1 - i` corresponds to the object for the i-th layer from the outside\n        obj_index = num_layers - 1 - i\n        current_object = object_details[obj_index]\n        \n        # Calculate the size of the current square layer\n        # Outermost layer (i=0) has size N, next (i=1) has N-2, etc.\n        current_layer_size = output_size - (2 * i)\n        \n        # Ensure layer size is at least 1\n        if current_layer_size < 1:\n            current_layer_size = 1\n            \n        # Draw the filled square for this layer\n        draw_centered_square(output_grid, current_layer_size, current_object['color'])\n\n    # 6. Final Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8821,
    "candidates_token_count": 2032,
    "total_token_count": 10853,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.865492,
  "retries": null
}