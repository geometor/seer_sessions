{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nIdentifies the primary non-black color (C) in the input grid.\nIterates through each pixel of the input grid.\nIf a pixel has color C:\n  Count its orthogonal neighbors (up, down, left, right) that also have color C.\n  Let N be the list of coordinates of these same-colored neighbors.\n  If the count is exactly 2:\n    Let the neighbors be N[0] = (r1, c1) and N[1] = (r2, c2).\n    Check if the neighbors form a corner configuration around the current pixel (r, c).\n    This occurs if the neighbors are not opposite each other (i.e., r1 != r2 AND c1 != c2).\n    If it's a corner configuration, change the pixel's color to yellow (4) in the output grid.\n    If it's a line configuration (r1 == r2 OR c1 == c2), keep the color C.\n  If the count is exactly 3:\n    Change the pixel's color to red (2) in the output grid.\n  Otherwise (count 0, 1, 4, or 2 in a line):\n    Keep the original color C.\nPixels that are not of the primary color C (including black background) remain unchanged.\n\"\"\"\n\ndef find_primary_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent non-black color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    # Filter out black (color 0)\n    non_black_mask = colors != 0\n    non_black_colors = colors[non_black_mask]\n    non_black_counts = counts[non_black_mask]\n\n    if non_black_colors.size == 0:\n        # Handle case where grid might be all black or empty\n        return 0 \n    \n    # Find the index of the most frequent non-black color\n    most_frequent_idx = np.argmax(non_black_counts)\n    return non_black_colors[most_frequent_idx]\n\ndef get_orthogonal_neighbors_coords(grid: np.ndarray, r: int, c: int) -> List[Tuple[int, int]]:\n    \"\"\"Gets the coordinates of orthogonal neighbors within grid bounds.\"\"\"\n    neighbors_coords = []\n    rows, cols = grid.shape\n    # Define potential moves (up, down, left, right)\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] \n    for dr, dc in moves:\n        nr, nc = r + dr, c + dc\n        # Check if the neighbor coordinates are within the grid boundaries\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors_coords.append((nr, nc))\n    return neighbors_coords\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on neighbor count and configuration.\n    - Primary color pixels with 3 primary color neighbors become Red (2).\n    - Primary color pixels with 2 primary color neighbors in a corner configuration become Yellow (4).\n    - All other pixels retain their original color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # Step 1: Identify the primary non-black color\n    primary_color = find_primary_color(input_np)\n    \n    # If no primary color found (e.g., all black grid), return the original grid\n    if primary_color == 0: \n        return output_np.tolist() \n\n    # Step 2: Iterate through each pixel of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Step 3: Check if the current pixel is of the primary color\n            if input_np[r, c] == primary_color:\n                \n                # Step 4: Find orthogonal neighbors and count those with the primary color\n                neighbor_coords = get_orthogonal_neighbors_coords(input_np, r, c)\n                primary_neighbors = []\n                for nr, nc in neighbor_coords:\n                    if input_np[nr, nc] == primary_color:\n                        primary_neighbors.append((nr, nc))\n                \n                neighbor_count = len(primary_neighbors)\n\n                # Step 5: Apply transformation rules based on neighbor count and configuration\n                \n                # Rule for Red (3 neighbors)\n                if neighbor_count == 3:\n                    output_np[r, c] = 2 # Red\n                    \n                # Rule for Yellow (2 neighbors in a corner)\n                elif neighbor_count == 2:\n                    # Get coordinates of the two primary neighbors\n                    (r1, c1) = primary_neighbors[0]\n                    (r2, c2) = primary_neighbors[1]\n                    \n                    # Check if neighbors are in a corner configuration (not opposite each other)\n                    # Opposite means rows are same OR columns are same.\n                    # Corner means rows are different AND columns are different.\n                    if r1 != r2 and c1 != c2:\n                        output_np[r, c] = 4 # Yellow\n                    # Else (if neighbor_count is 2 but neighbors are in a line): \n                    # no change needed, pixel remains primary_color (already set in output_np copy)\n                        \n                # Else (neighbor_count is 0, 1, 4, or 2-in-a-line):\n                # no change needed, pixel remains primary_color (already set in output_np copy)\n\n    # Step 6: Return the transformed grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5984,
    "candidates_token_count": 1374,
    "total_token_count": 7358,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 204.864262,
  "retries": null
}