{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom scipy.spatial.distance import cdist\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Base Shapes:** Find all connected components (objects) in the input grid consisting solely of yellow (4) and red (2) pixels, ensuring each component includes at least one red pixel. Record the locations of all pixels in each shape, paying special attention to the locations of the red pixels (sorted top-to-bottom, left-to-right).\n2.  **Identify Marker Pixels:** Locate all single pixels in the grid that are *not* white (0), *not* yellow (4), *not* red (2), and do *not* belong to any identified base shape. These are the marker pixels. Record their location and color.\n3.  **Associate Markers with Shapes:** For each marker pixel, determine the base shape it is closest to (based on minimum Euclidean distance between the marker's location and any red pixel within the shape). Ensure each marker is associated with at most one shape (the closest), and each shape is associated with at most one marker (the closest one to it).\n4.  **Determine Fill Properties:** For each base shape successfully associated with a marker:\n    a.  The `fill_color` is the color of the associated marker pixel.\n    b.  The `fill_direction` is determined by the marker's horizontal position relative to a reference red pixel of the shape (e.g., the first one in the sorted list). If the marker's column index is greater than the red pixel's column index, the direction is 'right' (+1). Otherwise, it's 'left' (-1).\n5.  **Perform Fill:** Create a copy of the input grid. For each associated (shape, marker) pair, iterate through every red pixel `(r, c)` within that shape. Starting from the column `c + fill_direction`, move horizontally in the `fill_direction`. At each step `fill_c`, check the pixel at `(r, fill_c)` in the *current state* of the output grid. If the location is within bounds and the pixel is white (0), change it to the `fill_color`. Stop filling along row `r` (originating from that specific red pixel `(r, c)`) as soon as a non-white (1-9) pixel is encountered or the grid boundary is reached.\n6.  **Output:** Return the modified grid after all fills are completed.\n\"\"\"\n\ndef find_objects_and_markers(grid):\n    \"\"\"\n    Identifies base shapes (yellow/red containing red) and valid marker pixels.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A tuple: (shapes, markers)\n        shapes: A dictionary where keys are shape IDs (starting from 1) and\n                values are dictionaries {'all_pixels': set(), 'red_pixels': list()}.\n                Red pixels are sorted.\n        markers: A list of dictionaries {'loc': tuple(r, c), 'color': int}.\n                 Markers are non-white, non-yellow, non-red, and not part of a base shape.\n    \"\"\"\n    height, width = grid.shape\n    base_mask = (grid == 4) | (grid == 2) # yellow or red\n    labeled_shapes, num_shapes = label(base_mask)\n\n    shapes = {}\n    all_base_pixels = set()\n\n    # Initial pass to find potential shapes and all their pixels\n    for r in range(height):\n        for c in range(width):\n            shape_id = labeled_shapes[r, c]\n            if shape_id > 0:\n                loc = (r, c)\n                if shape_id not in shapes:\n                    shapes[shape_id] = {'all_pixels': set(), 'red_pixels': []}\n                shapes[shape_id]['all_pixels'].add(loc)\n                if grid[r, c] == 2:\n                    shapes[shape_id]['red_pixels'].append(loc)\n                all_base_pixels.add(loc) # Track all pixels belonging to any yellow/red shape\n\n    # Filter out shapes without red pixels and sort red pixels\n    valid_shapes = {}\n    for shape_id, data in shapes.items():\n        if data['red_pixels']:\n            # Sort red pixels: top-to-bottom, then left-to-right\n            data['red_pixels'].sort()\n            valid_shapes[shape_id] = data\n        else:\n            # If a shape has no red pixels, its pixels are not considered base pixels\n            # Remove them from the set used for marker identification\n             all_base_pixels -= data['all_pixels']\n\n\n    # Find marker pixels (not white, not yellow, not red, not part of a base shape)\n    markers = []\n    disallowed_marker_colors = {0, 2, 4} # white, red, yellow\n    for r in range(height):\n        for c in range(width):\n            loc = (r, c)\n            color = grid[r, c]\n            # Check if the pixel is NOT white/red/yellow AND not part of any valid base shape\n            if color not in disallowed_marker_colors and loc not in all_base_pixels:\n                markers.append({'loc': loc, 'color': color})\n\n    return valid_shapes, markers\n\n\ndef associate_markers_to_shapes(shapes, markers):\n    \"\"\"\n    Associates each marker to its closest shape based on red pixel distance.\n    Ensures each shape is associated with at most one (the closest) marker.\n\n    Args:\n        shapes: Dictionary of valid shapes from find_objects_and_markers.\n        markers: List of valid markers from find_objects_and_markers.\n\n    Returns:\n        A dictionary mapping shape_id to the associated marker dictionary\n        {'loc': tuple(r, c), 'color': int}.\n    \"\"\"\n    if not shapes or not markers:\n        return {}\n\n    shape_associations = {} # shape_id -> {'marker': marker, 'min_dist': float}\n\n    # Pre-calculate all red pixel locations and their shape IDs from valid shapes\n    all_red_pixels = []\n    red_pixel_shape_map = {}\n    for shape_id, data in shapes.items():\n        for red_loc in data['red_pixels']:\n            all_red_pixels.append(red_loc)\n            red_pixel_shape_map[red_loc] = shape_id\n\n    if not all_red_pixels: # No red pixels found anywhere in valid shapes\n        return {}\n\n    marker_locs = [m['loc'] for m in markers]\n\n    # Calculate distances between all markers and all red pixels\n    # dist_matrix[i, j] = distance between marker i and red_pixel j\n    dist_matrix = cdist(marker_locs, all_red_pixels, metric='euclidean')\n\n    # Find the closest shape for each marker\n    marker_closest_shape = {} # marker_idx -> {'shape_id': int, 'dist': float}\n    for i, marker in enumerate(markers):\n        if dist_matrix.shape[1] == 0: continue # No red pixels to compare against\n        min_dist_marker = np.min(dist_matrix[i, :])\n        closest_red_pixel_indices = np.where(dist_matrix[i, :] == min_dist_marker)[0]\n        # In case of ties for a marker to different red pixels (possibly in different shapes),\n        # prioritize based on red pixel index (which corresponds to sorted order)\n        # This implicitly handles ties by picking the first one encountered.\n        closest_red_pixel_idx = closest_red_pixel_indices[0]\n        closest_red_loc = all_red_pixels[closest_red_pixel_idx]\n        closest_shape_id = red_pixel_shape_map[closest_red_loc]\n        marker_closest_shape[i] = {'shape_id': closest_shape_id, 'dist': min_dist_marker}\n\n    # Now, ensure each shape gets assigned at most one marker (the closest one to that shape)\n    final_associations = {} # shape_id -> {'marker': marker_dict, 'dist': min_dist}\n    for marker_idx, assoc_info in marker_closest_shape.items():\n        shape_id = assoc_info['shape_id']\n        dist = assoc_info['dist']\n        marker = markers[marker_idx]\n\n        if shape_id not in final_associations or dist < final_associations[shape_id]['dist']:\n             final_associations[shape_id] = {'marker': marker, 'dist': dist}\n        # Handle tie-breaking for distance to shape: if distances are equal, potentially prefer lower marker index?\n        # Current logic implicitly prefers the marker processed later if distances are equal.\n        # Let's stick with the simple \"closest\" logic for now.\n\n    # Return only the marker info keyed by shape_id\n    return {shape_id: data['marker'] for shape_id, data in final_associations.items()}\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the fill transformation based on base shapes and marker pixels.\n\n    Identifies base shapes (yellow/red blocks containing red pixels) and\n    isolated marker pixels (non-white, non-yellow, non-red).\n    Associates each marker with the nearest base shape.\n    For each associated shape, determines a fill color (from the marker) and\n    direction (marker position relative to shape's red pixels).\n    Performs a horizontal fill originating from each red pixel of the shape,\n    replacing background (white) pixels with the fill color until a\n    non-background (non-white) pixel or grid boundary is hit.\n    \"\"\"\n    # initialize output_grid\n    output_grid = input_grid.copy()\n    height, width = output_grid.shape\n\n    # 1. & 2. Identify Base Shapes and Valid Marker Pixels\n    shapes, markers = find_objects_and_markers(output_grid)\n\n    if not shapes or not markers:\n        # No valid shapes with red pixels or no valid markers found\n        return output_grid\n\n    # 3. Associate Markers with Shapes\n    shape_marker_associations = associate_markers_to_shapes(shapes, markers)\n\n    if not shape_marker_associations:\n        # No associations were made (e.g., markers too far, etc.)\n        return output_grid\n\n    # 4. & 5. Determine Fill Properties and Perform Fill for each associated shape\n    for shape_id, associated_marker in shape_marker_associations.items():\n        # Ensure shape_id is valid before proceeding\n        if shape_id not in shapes:\n            continue # Should not happen with current logic, but safe check\n\n        shape_data = shapes[shape_id]\n        red_pixels = shape_data['red_pixels'] # Already sorted\n\n        # Should have been filtered by find_objects_and_markers, but double check\n        if not red_pixels: continue\n\n        # Determine fill color\n        fill_color = associated_marker['color']\n\n        # Determine fill direction based on the first (topmost, leftmost) red pixel\n        marker_col = associated_marker['loc'][1]\n        ref_red_col = red_pixels[0][1]\n        fill_direction = 1 if marker_col > ref_red_col else -1\n\n        # Perform fill originating from *each* red pixel in this shape\n        for r, c in red_pixels:\n            # Start filling from the column next to the red pixel\n            fill_c = c + fill_direction\n\n            # Loop while the fill column is within the grid boundaries\n            while 0 <= fill_c < width:\n                # Check the pixel *in the current output grid* at the target fill location\n                if output_grid[r, fill_c] == 0: # If it's white (background)\n                    # Fill it with the marker color\n                    output_grid[r, fill_c] = fill_color\n                    # Move to the next column in the fill direction\n                    fill_c += fill_direction\n                else:\n                    # If a non-white pixel is encountered, stop filling for this row (r)\n                    # originating from this specific red pixel (r, c).\n                    break\n            # End of while loop (either hit non-white or boundary)\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11065,
    "candidates_token_count": 2851,
    "total_token_count": 13916,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.376656,
  "retries": null
}