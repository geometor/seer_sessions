{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom scipy.spatial.distance import cdist\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Base Shapes:** Find connected components composed exclusively of yellow (4) and red (2) pixels. Note the locations of all pixels, especially the red (2) ones, within each shape.\n2.  **Identify Marker Pixels:** Find isolated pixels that are not white (0) and are not part of any identified base shape. These are the marker pixels.\n3.  **Associate Markers with Shapes:** For each marker pixel, determine the base shape it is closest to (based on Euclidean distance between the marker and the red pixels of the shapes). Each marker is associated with at most one shape, and each shape is associated with at most one marker (the closest one).\n4.  **Determine Fill Properties:** For each shape associated with a marker:\n    a.  The `fill_color` is the color of the associated marker pixel.\n    b.  The `fill_direction` is determined by the marker's horizontal position relative to the red pixels of the shape. If the marker's column index is greater than the red pixel(s)' column index(es), the direction is 'right'. Otherwise, it's 'left'. (If multiple red pixels exist, comparison can be made to any, e.g., the topmost, leftmost red pixel).\n5.  **Perform Fill:** Create a copy of the input grid. For each red (2) pixel in an associated base shape:\n    a.  Starting from the column immediately adjacent to the red pixel in the determined `fill_direction`, iterate horizontally.\n    b.  Replace any white (0) pixel encountered with the `fill_color`.\n    c.  Stop filling along that row when a non-white pixel or the grid boundary is reached.\n6.  **Output:** Return the modified grid after all fills are completed.\n\"\"\"\n\ndef find_objects_and_markers(grid):\n    \"\"\"\n    Identifies base shapes (yellow/red) and marker pixels.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A tuple: (shapes, markers)\n        shapes: A dictionary where keys are shape IDs (starting from 1) and\n                values are dictionaries {'all_pixels': set(), 'red_pixels': list()}.\n        markers: A list of dictionaries {'loc': tuple(r, c), 'color': int}.\n    \"\"\"\n    height, width = grid.shape\n    base_mask = (grid == 4) | (grid == 2)\n    labeled_shapes, num_shapes = label(base_mask)\n\n    shapes = {shape_id: {'all_pixels': set(), 'red_pixels': []}\n              for shape_id in range(1, num_shapes + 1)}\n    all_base_pixels = set()\n\n    # Populate shape data and collect all base pixel locations\n    for r in range(height):\n        for c in range(width):\n            shape_id = labeled_shapes[r, c]\n            if shape_id > 0:\n                loc = (r, c)\n                shapes[shape_id]['all_pixels'].add(loc)\n                all_base_pixels.add(loc)\n                if grid[r, c] == 2:\n                    # Store red pixels sorted by row, then column for consistent direction check\n                    shapes[shape_id]['red_pixels'].append(loc)\n\n    # Sort red pixels within each shape\n    for shape_id in shapes:\n        shapes[shape_id]['red_pixels'].sort()\n\n    # Filter out shapes without red pixels (shouldn't occur based on examples)\n    shapes = {sid: data for sid, data in shapes.items() if data['red_pixels']}\n\n    # Find marker pixels\n    markers = []\n    marker_colors = {3, 5, 7, 8} # Colors observed as markers in examples\n    # Generalize: any non-zero color not part of a base shape\n    for r in range(height):\n        for c in range(width):\n            loc = (r, c)\n            color = grid[r, c]\n            if color != 0 and loc not in all_base_pixels:\n                markers.append({'loc': loc, 'color': color})\n\n    return shapes, markers\n\ndef associate_markers_to_shapes(shapes, markers):\n    \"\"\"\n    Associates each marker to its closest shape based on red pixel distance.\n    Ensures each shape is associated with at most one (the closest) marker.\n\n    Args:\n        shapes: Dictionary of shapes from find_objects_and_markers.\n        markers: List of markers from find_objects_and_markers.\n\n    Returns:\n        A dictionary mapping shape_id to the associated marker dictionary\n        {'loc': tuple(r, c), 'color': int}.\n    \"\"\"\n    if not shapes or not markers:\n        return {}\n\n    shape_associations = {} # shape_id -> {'marker': marker, 'min_dist': float}\n\n    # Pre-calculate all red pixel locations and their shape IDs\n    all_red_pixels = []\n    red_pixel_shape_map = {}\n    for shape_id, data in shapes.items():\n        for red_loc in data['red_pixels']:\n            all_red_pixels.append(red_loc)\n            red_pixel_shape_map[red_loc] = shape_id\n\n    if not all_red_pixels: # No red pixels found anywhere\n        return {}\n\n    marker_locs = [m['loc'] for m in markers]\n\n    # Calculate distances between all markers and all red pixels\n    # dist_matrix[i, j] = distance between marker i and red_pixel j\n    dist_matrix = cdist(marker_locs, all_red_pixels, metric='euclidean')\n\n    # Find the closest shape for each marker\n    marker_closest_shape = {} # marker_idx -> {'shape_id': int, 'dist': float}\n    for i, marker in enumerate(markers):\n        min_dist_marker = np.min(dist_matrix[i, :])\n        closest_red_pixel_indices = np.where(dist_matrix[i, :] == min_dist_marker)[0]\n        # In case of ties, just pick the first one found\n        closest_red_pixel_idx = closest_red_pixel_indices[0]\n        closest_red_loc = all_red_pixels[closest_red_pixel_idx]\n        closest_shape_id = red_pixel_shape_map[closest_red_loc]\n        marker_closest_shape[i] = {'shape_id': closest_shape_id, 'dist': min_dist_marker}\n\n    # Now, ensure each shape gets assigned at most one marker (the closest one)\n    final_associations = {} # shape_id -> {'marker': marker_dict, 'dist': min_dist}\n    for marker_idx, assoc_info in marker_closest_shape.items():\n        shape_id = assoc_info['shape_id']\n        dist = assoc_info['dist']\n        marker = markers[marker_idx]\n\n        if shape_id not in final_associations or dist < final_associations[shape_id]['dist']:\n             final_associations[shape_id] = {'marker': marker, 'dist': dist}\n\n    # Return only the marker info keyed by shape_id\n    return {shape_id: data['marker'] for shape_id, data in final_associations.items()}\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the fill transformation based on base shapes and marker pixels.\n\n    Identifies base shapes (yellow/red blocks) and isolated marker pixels.\n    Associates each marker with the nearest base shape.\n    For each associated shape, determines a fill color (from the marker) and\n    direction (marker position relative to shape's red pixels).\n    Performs a horizontal fill originating from each red pixel of the shape,\n    replacing background (white) pixels with the fill color until a\n    non-background pixel or grid boundary is hit.\n    \"\"\"\n    output_grid = input_grid.copy()\n    height, width = output_grid.shape\n\n    # 1. & 2. Identify Base Shapes and Marker Pixels\n    shapes, markers = find_objects_and_markers(output_grid)\n\n    if not shapes or not markers:\n        return output_grid # Nothing to do if no shapes or markers\n\n    # 3. Associate Markers with Shapes\n    shape_marker_associations = associate_markers_to_shapes(shapes, markers)\n\n    if not shape_marker_associations:\n        return output_grid # No associations found\n\n    # 4. & 5. Determine Fill Properties and Perform Fill for each associated shape\n    for shape_id, associated_marker in shape_marker_associations.items():\n        shape_data = shapes[shape_id]\n        red_pixels = shape_data['red_pixels']\n        if not red_pixels: continue # Should be filtered already, but safety check\n\n        fill_color = associated_marker['color']\n        marker_col = associated_marker['loc'][1]\n\n        # Use the first (top-most, then left-most) red pixel for direction check\n        ref_red_col = red_pixels[0][1]\n        fill_direction = 1 if marker_col > ref_red_col else -1\n\n        # Perform fill originating from each red pixel in this shape\n        for r, c in red_pixels:\n            fill_c = c + fill_direction\n            while 0 <= fill_c < width:\n                # Check against the current state of the output grid\n                if output_grid[r, fill_c] == 0:\n                    output_grid[r, fill_c] = fill_color\n                    fill_c += fill_direction\n                else:\n                    # Stop filling on this row if non-white is hit\n                    break\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4457,
    "candidates_token_count": 2279,
    "total_token_count": 6736,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.476156,
  "retries": null
}