{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom scipy.spatial.distance import cdist\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Base Shapes:** Find all connected components (objects) in the input grid consisting solely of yellow (4) and red (2) pixels, ensuring each component includes at least one red pixel. Record the locations of all pixels in each shape, and the locations of the red pixels (sorted top-to-bottom, left-to-right).\n2.  **Identify Marker Pixels:** Locate all single pixels in the grid that are *not* white (0), *not* yellow (4), *not* red (2), and do *not* belong to any identified valid base shape (a shape containing red). These are the marker pixels. Record their location and color.\n3.  **Associate Markers with Shapes:** For each marker pixel, determine the base shape it is closest to (based on minimum Euclidean distance between the marker's location and any red pixel within the shape). Ensure each marker is associated with at most one shape (the closest), and each shape is associated with at most one marker (the closest one to it).\n4.  **Determine Fill Properties:** For each base shape successfully associated with a marker:\n    a.  The `fill_color` is the color of the associated marker pixel.\n    b.  The `fill_direction` is determined by the marker's horizontal position relative to the shape's topmost, leftmost red pixel. If the marker's column index is greater than the red pixel's column index, the direction is 'right' (+1). Otherwise, it's 'left' (-1).\n5.  **Perform Fill:** Create a copy of the input grid. For each associated (shape, marker) pair, iterate through every red pixel `(r, c)` within that shape. Starting from the column `c + fill_direction`, move horizontally in the `fill_direction`. At each step `fill_c`, check the pixel at `(r, fill_c)` in the *original input grid*. If the location is within bounds and the pixel is white (0), change the corresponding pixel in the *output grid* to the `fill_color`. Stop filling along row `r` (originating from that specific red pixel `(r, c)`) as soon as an originally non-white (1-9) pixel is encountered or the grid boundary is reached.\n6.  **Output:** Return the modified grid after all fills are completed.\n\"\"\"\n\n# ================================= HELPER FUNCTIONS =================================\n\ndef find_objects_and_markers(grid):\n    \"\"\"\n    Identifies base shapes (yellow/red containing red) and valid marker pixels.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A tuple: (shapes, markers)\n        shapes: A dictionary where keys are shape IDs (starting from 1) and\n                values are dictionaries {'all_pixels': set(), 'red_pixels': list()}.\n                Red pixels are sorted. Only includes shapes with at least one red pixel.\n        markers: A list of dictionaries {'loc': tuple(r, c), 'color': int}.\n                 Markers are non-white, non-yellow, non-red, and not part of a valid base shape.\n    \"\"\"\n    height, width = grid.shape\n    # Mask for pixels that could potentially be part of a base shape\n    base_mask = (grid == 4) | (grid == 2) # yellow or red\n    # Label connected components in the mask\n    labeled_shapes, num_potential_shapes = label(base_mask)\n\n    # Store information about each potential shape component\n    potential_shapes = {}\n    for r in range(height):\n        for c in range(width):\n            shape_id = labeled_shapes[r, c]\n            if shape_id > 0: # Pixel belongs to a potential shape\n                loc = (r, c)\n                if shape_id not in potential_shapes:\n                    potential_shapes[shape_id] = {'all_pixels': set(), 'red_pixels': []}\n                potential_shapes[shape_id]['all_pixels'].add(loc)\n                # Record red pixels within the shape\n                if grid[r, c] == 2:\n                    potential_shapes[shape_id]['red_pixels'].append(loc)\n\n    # Filter out shapes that do not contain any red pixels\n    # These are the 'valid' base shapes for the transformation\n    valid_shapes = {}\n    for shape_id, data in potential_shapes.items():\n        if data['red_pixels']:\n            # Sort red pixels: top-to-bottom, then left-to-right\n            data['red_pixels'].sort()\n            valid_shapes[shape_id] = data\n\n    # Collect the set of all pixels belonging to any valid base shape\n    all_valid_base_pixels = set()\n    for shape_id, data in valid_shapes.items():\n        all_valid_base_pixels.update(data['all_pixels'])\n\n    # Find marker pixels\n    markers = []\n    disallowed_marker_colors = {0, 2, 4} # white, red, yellow\n    for r in range(height):\n        for c in range(width):\n            loc = (r, c)\n            color = grid[r, c]\n            # A marker must not be white/red/yellow AND must not be part of a valid base shape\n            if color not in disallowed_marker_colors and loc not in all_valid_base_pixels:\n                markers.append({'loc': loc, 'color': color})\n\n    return valid_shapes, markers\n\n\ndef associate_markers_to_shapes(shapes, markers):\n    \"\"\"\n    Associates each marker to its closest shape based on red pixel distance.\n    Ensures each shape is associated with at most one (the closest) marker,\n    and each marker is associated with at most one (the closest) shape.\n\n    Args:\n        shapes: Dictionary of valid shapes from find_objects_and_markers.\n        markers: List of valid markers from find_objects_and_markers.\n\n    Returns:\n        A dictionary mapping shape_id to the associated marker dictionary\n        {'loc': tuple(r, c), 'color': int}.\n    \"\"\"\n    if not shapes or not markers:\n        return {}\n\n    # --- Step 1: Find the closest shape for each marker ---\n    marker_closest_shape = {} # marker_idx -> {'shape_id': int, 'dist': float, 'red_loc': tuple}\n\n    # Prepare lists for distance calculation\n    all_red_pixels = []\n    red_pixel_shape_map = {} # Map red_pixel_loc back to its shape_id\n    for shape_id, data in shapes.items():\n        for red_loc in data['red_pixels']:\n            all_red_pixels.append(red_loc)\n            red_pixel_shape_map[red_loc] = shape_id\n\n    if not all_red_pixels: # No red pixels found in any valid shape\n        return {}\n\n    marker_locs = [m['loc'] for m in markers]\n\n    # Calculate distances: rows=markers, cols=red_pixels\n    dist_matrix = cdist(marker_locs, all_red_pixels, metric='euclidean')\n\n    # Determine closest red pixel (and thus shape) for each marker\n    for i, marker in enumerate(markers):\n        if dist_matrix.shape[1] == 0: continue # Should be caught by 'if not all_red_pixels'\n        min_dist_marker = np.min(dist_matrix[i, :])\n        # Find all red pixels at this minimum distance\n        closest_red_pixel_indices = np.where(dist_matrix[i, :] == min_dist_marker)[0]\n        # Tie-breaking for marker: Choose the red pixel that comes first in the sorted list\n        # (which corresponds to the smallest index in closest_red_pixel_indices)\n        closest_red_pixel_idx = closest_red_pixel_indices[0]\n        closest_red_loc = all_red_pixels[closest_red_pixel_idx]\n        closest_shape_id = red_pixel_shape_map[closest_red_loc]\n        marker_closest_shape[i] = {\n            'shape_id': closest_shape_id,\n            'dist': min_dist_marker,\n            'red_loc': closest_red_loc # Store which red pixel was closest\n        }\n\n    # --- Step 2: Assign markers to shapes, ensuring one marker per shape (the closest) ---\n    shape_potential_markers = {} # shape_id -> list of {'marker_idx': int, 'dist': float}\n    for marker_idx, assoc_info in marker_closest_shape.items():\n        shape_id = assoc_info['shape_id']\n        dist = assoc_info['dist']\n        if shape_id not in shape_potential_markers:\n            shape_potential_markers[shape_id] = []\n        shape_potential_markers[shape_id].append({'marker_idx': marker_idx, 'dist': dist})\n\n    # --- Step 3: Finalize associations by picking the closest marker for each shape ---\n    final_associations = {} # shape_id -> {'marker': marker_dict, 'dist': min_dist}\n    for shape_id, potential_marker_list in shape_potential_markers.items():\n        # Sort potential markers for this shape by distance (ascending)\n        potential_marker_list.sort(key=lambda x: x['dist'])\n        # The closest marker is the first one in the sorted list\n        closest_marker_info = potential_marker_list[0]\n        marker_idx = closest_marker_info['marker_idx']\n        min_dist = closest_marker_info['dist']\n        # Store the association\n        final_associations[shape_id] = {'marker': markers[marker_idx], 'dist': min_dist}\n\n    # Return only the marker info keyed by shape_id\n    return {shape_id: data['marker'] for shape_id, data in final_associations.items()}\n\n# ================================= MAIN TRANSFORM FUNCTION =================================\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the fill transformation based on base shapes and marker pixels.\n\n    Identifies base shapes (yellow/red blocks containing red pixels) and\n    isolated marker pixels (non-white, non-yellow, non-red).\n    Associates each marker with the nearest base shape (one-to-one mapping).\n    For each associated shape, determines a fill color (from the marker) and\n    direction (marker position relative to shape's top-leftmost red pixel).\n    Performs a horizontal fill originating from each red pixel of the shape,\n    replacing originally background (white) pixels in the output grid with the\n    fill color until an originally non-background pixel or grid boundary is hit.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = input_grid.copy()\n    height, width = output_grid.shape\n\n    # 1. & 2. Identify Base Shapes (yellow/red with red) and Valid Marker Pixels\n    shapes, markers = find_objects_and_markers(input_grid) # Use input_grid for analysis\n\n    # Early exit if no shapes or markers are found\n    if not shapes or not markers:\n        return output_grid\n\n    # 3. Associate Markers with Shapes (closest, one-to-one)\n    shape_marker_associations = associate_markers_to_shapes(shapes, markers)\n\n    # Early exit if no associations could be made\n    if not shape_marker_associations:\n        return output_grid\n\n    # 4. & 5. Determine Fill Properties and Perform Fill for each associated shape\n    for shape_id, associated_marker in shape_marker_associations.items():\n        # Should always be a valid shape_id here, but check just in case\n        if shape_id not in shapes:\n            continue\n\n        shape_data = shapes[shape_id]\n        red_pixels = shape_data['red_pixels'] # Already sorted top-to-bottom, left-to-right\n\n        # Should not happen due to filtering in find_objects_and_markers\n        if not red_pixels: continue\n\n        # Determine fill color from the associated marker\n        fill_color = associated_marker['color']\n\n        # Determine fill direction based on the first (topmost, leftmost) red pixel\n        marker_col = associated_marker['loc'][1]\n        # red_pixels is sorted, so red_pixels[0] is the topmost, leftmost red pixel\n        ref_red_col = red_pixels[0][1]\n        fill_direction = 1 if marker_col > ref_red_col else -1 # +1 for right, -1 for left\n\n        # Perform fill originating from *each* red pixel in this shape\n        for r, c in red_pixels:\n            # Start filling from the column adjacent to the red pixel in the fill direction\n            fill_c = c + fill_direction\n\n            # Loop while the fill column is within the grid boundaries\n            while 0 <= fill_c < width:\n                # Check the pixel *in the ORIGINAL input grid* at the target fill location\n                # Only fill if the original pixel was white (background color 0)\n                if input_grid[r, fill_c] == 0:\n                    # Fill the corresponding pixel in the output grid\n                    output_grid[r, fill_c] = fill_color\n                    # Move to the next column in the fill direction\n                    fill_c += fill_direction\n                else:\n                    # If an originally non-white pixel is encountered in the input grid,\n                    # stop filling along this row (r) originating from this specific red pixel (r, c).\n                    break\n            # End of while loop (either hit a non-white pixel in input_grid or grid boundary)\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6918,
    "candidates_token_count": 3193,
    "total_token_count": 10111,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 199.541243,
  "retries": null
}