{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nSimulate gravity on blue objects (color 1) within a grid.\n\nThe grid contains a background (color 0, typically white), blue objects (color 1), and static barriers (color 2, typically red).\nBlue objects are defined as contiguous groups of blue pixels using orthogonal connectivity (up, down, left, right).\nThe transformation involves moving blue objects downwards, one step at a time, until they cannot move further.\nAn object stops moving if any part of it encounters:\n1. A red pixel directly below it.\n2. A blue pixel belonging to another object (or an already settled part of the same object in more complex scenarios, although not strictly needed with whole-object movement) directly below it.\n3. The bottom edge of the grid.\n\nRed pixels remain fixed throughout the process.\nBlue objects maintain their shape during the fall.\nThe process iterates until no blue object can move down in a full pass.\n\"\"\"\n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using BFS.\n    Connectivity is orthogonal (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[list[tuple[int, int]]]: A list of objects, where each object is represented\n                                     by a list of its coordinate tuples (row, col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col))\n                    \n                    # Check neighbors (orthogonal)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component:\n                    objects.append(component)\n                    \n    return objects\n\ndef can_object_move_down(grid, obj_coords):\n    \"\"\"\n    Checks if an entire object can move down by one step based on the current grid state.\n\n    Args:\n        grid (np.array): The grid state to check against.\n        obj_coords (list[tuple[int, int]]): The coordinates of the object pixels.\n\n    Returns:\n        bool: True if the object can move down one step, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    object_coords_set = set(obj_coords) # Use set for faster lookups\n\n    for r, c in obj_coords:\n        below_r = r + 1\n        \n        # Check boundary\n        if below_r >= rows:\n            return False # Reached bottom edge\n\n        # Check cell below\n        # If the cell below is part of the *same* object, it's irrelevant for *this* check\n        # because the whole object moves together. We only care about obstacles *outside* the object.\n        if (below_r, c) not in object_coords_set:\n            # Check if the cell below is occupied by something other than the background\n            if grid[below_r, c] != 0: \n                 return False # Blocked by red (2) or another blue object (1)\n            \n    return True # Can move if no part is blocked\n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity to blue objects (color 1) in the grid, stopping at red objects (color 2),\n    other blue objects, or the grid bottom.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid with blue objects settled.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    blue_color = 1\n    background_color = 0\n\n    while True:\n        moved_in_iteration = False\n        \n        # Find all current blue objects based on the grid state at the start of the iteration\n        blue_objects = find_connected_components(grid, blue_color)\n        \n        # Sort objects by their lowest point (max row index) in descending order.\n        # This ensures that objects lower down are considered for movement first,\n        # creating a stable settling process layer by layer from the bottom up.\n        blue_objects.sort(key=lambda obj: max(r for r, c in obj), reverse=True)\n\n        # Determine which objects can move based on the current state, *before* any moves happen this iteration.\n        objects_to_move_this_iteration = []\n        for obj_coords in blue_objects:\n             if can_object_move_down(grid, obj_coords):\n                 objects_to_move_this_iteration.append(obj_coords)\n\n        # If no objects can move, the simulation is stable.\n        if not objects_to_move_this_iteration:\n            break\n\n        # Perform the moves for all objects identified as movable in this iteration.\n        # Important: Erase all moving objects first, then redraw them in their new positions.\n        # This prevents conflicts where one object moves into the space vacated by another\n        # *within the same step*.\n        \n        # Erase all moving objects\n        for obj_coords in objects_to_move_this_iteration:\n            moved_in_iteration = True # Mark that at least one object moved\n            for r, c in obj_coords:\n                grid[r, c] = background_color\n        \n        # Redraw all moving objects one step down\n        for obj_coords in objects_to_move_this_iteration:\n            for r, c in obj_coords:\n                grid[r + 1, c] = blue_color\n            \n        # If we didn't actually move anything (e.g., list was empty), break.\n        # This condition is already checked by `if not objects_to_move_this_iteration:` above.\n        # We keep the `moved_in_iteration` flag mostly for clarity/debugging,\n        # but the primary loop control is the list emptiness.\n\n    # Return the final grid state as a list of lists\n    return grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6381,
    "candidates_token_count": 1585,
    "total_token_count": 7966,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.888566,
  "retries": null
}