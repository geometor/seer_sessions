{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nSimulate gravity on blue objects (color 1) within a grid.\n\nThe grid contains a background (color 0, typically white), blue objects (color 1), and static barriers (color 2, typically red).\nBlue objects are defined as contiguous groups of blue pixels using orthogonal connectivity (up, down, left, right).\nThe transformation involves moving blue objects downwards, one step at a time, until they cannot move further.\nAn object stops moving if any part of it encounters:\n1. A red pixel directly below it.\n2. A blue pixel belonging to another object directly below it.\n3. The bottom edge of the grid.\n\nRed pixels remain fixed throughout the process.\nBlue objects maintain their shape during the fall.\nThe process iterates until no blue object can move down in a full pass. Objects are processed effectively from bottom-to-top within each step to ensure stable settling.\n\"\"\"\n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using BFS.\n    Connectivity is orthogonal (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[list[tuple[int, int]]]: A list of objects, where each object is represented\n                                     by a list of its coordinate tuples (row, col). Returns\n                                     an empty list if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col))\n\n                    # Check neighbors (orthogonal: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Add the found component (object) to the list if it's not empty\n                if component:\n                    objects.append(component)\n\n    return objects\n\ndef can_object_move_down(grid, obj_coords):\n    \"\"\"\n    Checks if an entire object can move down by one step based on the current grid state.\n    An object can move down only if ALL cells immediately below its constituent pixels\n    are either background (0) or part of the object itself. If ANY cell below is\n    a boundary, red (2), or part of *another* blue object, it cannot move.\n\n    Args:\n        grid (np.array): The grid state to check against.\n        obj_coords (list[tuple[int, int]]): The coordinates of the object pixels.\n\n    Returns:\n        bool: True if the object can move down one step, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    # Use a set for efficient checking if a coordinate belongs to the current object\n    obj_coords_set = set(obj_coords)\n\n    # Iterate through each pixel coordinate (r, c) of the object\n    for r, c in obj_coords:\n        below_r = r + 1\n        below_c = c\n\n        # Check 1: Bottom grid boundary\n        # If moving any pixel down would go past the last row, the object cannot move.\n        if below_r >= rows:\n            return False # Object hit the bottom edge\n\n        # Check 2: Obstacle below (that is NOT part of the current object)\n        # If the cell below the current pixel IS part of the object itself, it doesn't block movement.\n        # We only care about external obstacles (background, red, other blue objects).\n        if (below_r, below_c) not in obj_coords_set:\n            # Check the color of the cell directly below the current pixel\n            # If it's not background (0), it's an obstacle (red=2 or another blue object=1)\n            if grid[below_r, below_c] != 0: # 0 is background color\n                 return False # Blocked by red or another blue object\n\n    # If we looped through all pixels of the object and found no blocking conditions\n    # for any of the cells immediately below them (considering only external obstacles or boundaries),\n    # then the entire object can move down.\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity to blue objects (color 1) in the grid, making them fall downwards\n    until they hit red barriers (color 2), other settled blue objects, or the grid bottom.\n    Objects fall one step at a time, and the process repeats until no object can move further.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid with blue objects settled.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    blue_color = 1\n    background_color = 0\n\n    # Main simulation loop: continues as long as any object successfully moves in a pass\n    while True:\n        moved_this_pass = False # Flag to track if any movement occurred in the current pass\n\n        # Find all distinct blue objects based on the current grid state\n        # This needs to be done inside the loop because objects' positions change\n        blue_objects = find_connected_components(grid, blue_color)\n\n        # If there are no blue objects left to move, the simulation is finished\n        if not blue_objects:\n            break\n\n        # Sort objects by their lowest point (maximum row index) in descending order.\n        # This ensures we attempt to move the objects closest to the bottom first.\n        blue_objects.sort(key=lambda obj: max(r for r, c in obj), reverse=True)\n\n        # Iterate through the objects found (from bottom-most to top-most)\n        for obj_coords in blue_objects:\n            # Check if the current object can move down one step\n            if can_object_move_down(grid, obj_coords):\n                # --- Perform the move ---\n                # 1. Erase the object from its current position by setting pixels to background color\n                for r, c in obj_coords:\n                    grid[r, c] = background_color\n\n                # 2. Redraw the object one step lower\n                # (The can_object_move_down check already confirmed r+1 is within bounds)\n                for r, c in obj_coords:\n                    grid[r + 1, c] = blue_color\n\n                # --- Update state and control flow ---\n                # Mark that at least one object moved in this pass\n                moved_this_pass = True\n\n                # IMPORTANT: Since the grid state has changed (one object moved),\n                # the conditions for other objects might have changed. We must restart\n                # the process: break out of the inner 'for' loop and begin a new\n                # iteration of the outer 'while' loop. This re-finds, re-sorts,\n                # and re-evaluates all objects based on the newly updated grid.\n                break # Exit the 'for obj_coords...' loop\n\n        # If we completed a full pass through all found objects (the 'for' loop finished\n        # without the 'break' being triggered), it means no object could move.\n        # The grid configuration is stable.\n        if not moved_this_pass:\n            break # Exit the 'while True' loop\n\n    # Return the final stable grid state as a standard Python list of lists\n    return grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6772,
    "candidates_token_count": 1924,
    "total_token_count": 8696,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 74.479697,
  "retries": null
}