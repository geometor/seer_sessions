{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nSimulate gravity on blue objects (color 1) within a grid.\n\nThe grid contains a background (color 0, typically white), blue objects (color 1), and static barriers (color 2, typically red).\nBlue objects are defined as contiguous groups of blue pixels using orthogonal connectivity (up, down, left, right).\nThe transformation involves moving blue objects downwards, one step at a time, until they cannot move further.\nAn object stops moving if any part of it encounters:\n1. A red pixel directly below it.\n2. A blue pixel belonging to another object directly below it.\n3. The bottom edge of the grid.\n\nRed pixels remain fixed throughout the process.\nBlue objects maintain their shape during the fall.\nThe process iterates until no blue object can move down in a full pass. Objects are processed effectively from bottom-to-top within each step to ensure stable settling.\n\"\"\"\n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid using BFS.\n    Connectivity is orthogonal (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[list[tuple[int, int]]]: A list of objects, where each object is represented\n                                     by a list of its coordinate tuples (row, col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col))\n                    \n                    # Check neighbors (orthogonal)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component:\n                    objects.append(component)\n                    \n    return objects\n\ndef can_object_move_down(grid, obj_coords):\n    \"\"\"\n    Checks if an entire object can move down by one step based on the current grid state.\n    An object can move down only if ALL cells immediately below its constituent pixels\n    are either background (0) or part of the object itself. If ANY cell below is\n    a boundary, red (2), or part of *another* blue object, it cannot move.\n\n    Args:\n        grid (np.array): The grid state to check against.\n        obj_coords (list[tuple[int, int]]): The coordinates of the object pixels.\n\n    Returns:\n        bool: True if the object can move down one step, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    obj_coords_set = set(obj_coords) # Use set for efficient lookups\n\n    for r, c in obj_coords:\n        below_r = r + 1\n        below_c = c\n        \n        # Check 1: Bottom boundary\n        if below_r >= rows:\n            return False # Object hit the bottom edge\n\n        # Check 2: Obstacle below (that is NOT part of the current object)\n        # If the cell below IS part of the current object, it doesn't block movement;\n        # we only care about external obstacles.\n        if (below_r, below_c) not in obj_coords_set:\n            # Check the color of the cell below\n            if grid[below_r, below_c] != 0: # 0 is background\n                 # It's blocked by red (2) or another blue object (1)\n                 return False \n            \n    # If we looped through all pixels of the object and found no blocking conditions\n    # for any of the cells immediately below them, the object can move.\n    return True \n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity to blue objects (color 1) in the grid, stopping at red objects (color 2),\n    other blue objects, or the grid bottom.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid with blue objects settled.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    blue_color = 1\n    red_color = 2\n    background_color = 0\n\n    # Main simulation loop: continues as long as any object moves in an iteration\n    while True:\n        # Find all current blue objects in the grid at the start of this iteration\n        blue_objects = find_connected_components(grid, blue_color)\n        \n        # Sort objects by their lowest point (max row index) in descending order.\n        # This helps ensure that lower objects attempt to move and settle first,\n        # providing a stable base for objects above them.\n        blue_objects.sort(key=lambda obj: max(r for r, c in obj), reverse=True)\n\n        # Identify which objects can actually move down in this step\n        objects_to_move_this_iteration = []\n        for obj_coords in blue_objects:\n             if can_object_move_down(grid, obj_coords):\n                 objects_to_move_this_iteration.append(obj_coords)\n\n        # If no objects can move in this iteration, the simulation is stable.\n        if not objects_to_move_this_iteration:\n            break # Exit the while loop\n\n        # Perform the moves for all objects identified as movable in this iteration.\n        # Strategy: Erase all moving objects first, then redraw them in their new positions.\n        # This prevents conflicts where an object moves into a space just vacated\n        # by another object *within the same iteration*.\n        \n        # Erase all moving objects from their current positions\n        for obj_coords in objects_to_move_this_iteration:\n            for r, c in obj_coords:\n                grid[r, c] = background_color\n        \n        # Redraw all moving objects one step down in their new positions\n        for obj_coords in objects_to_move_this_iteration:\n            for r, c in obj_coords:\n                # The can_object_move_down check ensures r+1 is within bounds\n                grid[r + 1, c] = blue_color\n            \n        # Continue to the next iteration of the while loop\n\n    # Return the final stable grid state as a list of lists\n    return grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13613,
    "candidates_token_count": 1634,
    "total_token_count": 15247,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.220152,
  "retries": null
}