{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a horizontal gray separator line (row 5) in the 15x15 input grid.\nFinds three colored objects above the line (Left, Middle, Right) and one blue key object below.\nAnalyzes the key object's shape (Hollow, Plus, Diagonal) and vertical position (High if top row < 10, Low otherwise).\nMatches the key object's shape to one of the upper objects (always the Left object in examples).\nSelects the Matched Object (Left) and the Right upper object for the output.\nDetermines the stacking order of these two selected objects based on Key Type and Key Height:\n  - Base Order: Hollow/Diagonal keys -> Right object on top; Plus key -> Left object on top.\n  - Modification: If Key Type is Hollow AND Key Height is High, flip the Base Order.\nDetermines the vertical starting row for the top object in the 9x15 output grid based on Key Type and Key Height:\n  - High Key: Hollow -> Row 3, Diagonal -> Row 0, Plus -> Row 1.\n  - Low Key: Hollow -> Row 2. (Other types not observed for Low key).\nConstructs the output grid by stacking the selected objects in the determined order, starting at the calculated row, and centered horizontally.\n\"\"\"\n\n# --- Constants for Shape Definitions ---\nSHAPE_HOLLOW = frozenset({(0, 1), (1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)})\nSHAPE_PLUS = frozenset({(0, 1), (1, 2), (2, 1), (1, 0), (1, 1)})\nSHAPE_DIAGONAL = frozenset({(0, 2), (2, 2), (0, 0), (1, 1), (2, 0)})\n\nSHAPE_TYPE_MAP = {\n    SHAPE_HOLLOW: \"Hollow\",\n    SHAPE_PLUS: \"Plus\",\n    SHAPE_DIAGONAL: \"Diagonal\"\n}\n\n# --- Helper Functions ---\n\ndef pad_grid(grid_list):\n    \"\"\"Pads a potentially ragged grid_list to be rectangular.\"\"\"\n    max_width = 0\n    if not grid_list: return [] \n    for row in grid_list:\n        if isinstance(row, (list, tuple)):\n            max_width = max(max_width, len(row))\n        else:\n           pass # Assume rows are lists/tuples\n\n    padded_grid = []\n    for row in grid_list:\n         if isinstance(row, (list, tuple)):\n            # Ensure row elements are integers, default invalid elements to 0\n            processed_row = []\n            for x in row:\n                try:\n                    processed_row.append(int(x))\n                except (ValueError, TypeError):\n                    processed_row.append(0) # Default invalid cell to white\n            padded_row = processed_row + [0] * (max_width - len(processed_row)) \n            padded_grid.append(padded_row)\n         else:\n            padded_grid.append([0] * max_width)\n            \n    return padded_grid\n\ndef find_separator_row(grid):\n    \"\"\"Finds the row index containing the horizontal gray line (color 5).\"\"\"\n    # Expects numpy array\n    rows, cols = grid.shape\n    for r in range(rows):\n        if np.all(grid[r, :] == 5):\n            return r\n    return -1 # Separator not found\n\ndef find_objects(grid, ignore_colors=[0, 5]):\n    \"\"\"\n    Finds connected objects of the same color in the grid, ignoring specified colors.\n    Uses Breadth-First Search (BFS). Handles numpy array input.\n    Returns a list of objects, where each object is a dict containing:\n    'color', 'coords' (set of (r, c) tuples), 'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Ensure grid value is treated as int for comparison\n            current_pixel = int(grid[r, c]) \n            if (r, c) in visited or current_pixel in ignore_colors:\n                continue\n\n            color = current_pixel\n            obj_coords = set()\n            q = deque([(r, c)])\n            visited.add((r, c))\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_coords.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check 8 neighbors (including diagonals)\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and int(grid[nr, nc]) == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n            if obj_coords: # Only add if an object was actually found\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_relative_shape(obj):\n    \"\"\"\n    Calculates the shape of an object relative to its bounding box top-left corner.\n    Returns a frozenset of (dr, dc) tuples.\n    \"\"\"\n    if not obj or 'coords' not in obj or not obj['coords']:\n         return frozenset() # Return empty for invalid object\n    min_r, min_c, _, _ = obj['bbox']\n    shape = set()\n    for r, c in obj['coords']:\n        shape.add((r - min_r, c - min_c))\n    return frozenset(shape) # Use frozenset to make it hashable for comparison\n\ndef get_object_dims(obj):\n    \"\"\"Calculates the height and width of an object's bounding box.\"\"\"\n    if not obj or 'bbox' not in obj:\n        return 0, 0\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef draw_object(output_grid, obj, target_start_row, target_start_col):\n    \"\"\"Draws an object onto the output grid at the specified top-left position.\"\"\"\n    if not obj or 'coords' not in obj or not obj['coords']:\n        return # Do nothing if object is invalid\n    min_r, min_c, _, _ = obj['bbox']\n    out_rows, out_cols = output_grid.shape\n    for r, c in obj['coords']:\n        dr = r - min_r\n        dc = c - min_c\n        out_r = target_start_row + dr\n        out_c = target_start_col + dc\n        # Check bounds before drawing\n        if 0 <= out_r < out_rows and 0 <= out_c < out_cols:\n            output_grid[out_r, out_c] = obj['color']\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    # 0. Initialization and Input Validation\n    padded_input_list = pad_grid(input_grid)\n    if not padded_input_list:\n        return [[0]*15 for _ in range(9)] # Return default empty grid if input is bad\n        \n    input_np = np.array(padded_input_list, dtype=int)\n    height, width = input_np.shape\n    output_height = 9\n    output_width = width # Output width is same as input\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 1. Identify Components\n    separator_row = find_separator_row(input_np)\n    if separator_row == -1:\n        # Fallback: Maybe return input or default grid if separator missing\n        return output_grid.tolist() \n        \n    all_objects = find_objects(input_np)\n\n    upper_objects_raw = [obj for obj in all_objects if obj['bbox'][0] < separator_row]\n    lower_objects = [obj for obj in all_objects if obj['bbox'][0] > separator_row]\n\n    # Validate assumptions\n    if len(upper_objects_raw) != 3 or len(lower_objects) != 1 or lower_objects[0]['color'] != 1:\n        # Fallback if assumptions invalid\n        return output_grid.tolist() \n\n    key_object = lower_objects[0]\n    # Sort upper objects by horizontal position (using min_c) and add original index\n    upper_objects = sorted(upper_objects_raw, key=lambda obj: obj['bbox'][1])\n    for i, obj in enumerate(upper_objects):\n        obj['original_index'] = i # 0:Left, 1:Middle, 2:Right\n\n    # 2. Analyze Key Object\n    key_shape = get_relative_shape(key_object)\n    key_min_row = key_object['bbox'][0]\n    \n    key_type = SHAPE_TYPE_MAP.get(key_shape, \"Unknown\")\n    is_key_high = key_min_row < 10 # High if top row < 10\n\n    if key_type == \"Unknown\":\n         return output_grid.tolist() # Cannot proceed if key shape is unrecognized\n\n    # 3. Find Match\n    matched_object = None\n    matched_object_idx = -1\n    for obj in upper_objects:\n        obj['shape'] = get_relative_shape(obj)\n        if obj['shape'] == key_shape:\n            matched_object = obj\n            matched_object_idx = obj['original_index']\n            break # Found the match\n\n    if matched_object is None:\n        return output_grid.tolist() # Cannot proceed without a match\n\n    # 4. Select Objects for Output\n    # In all examples, Left (idx 0) matches. Select Matched (0) and Right (2).\n    # Generalizing (though not strictly needed for training examples):\n    if matched_object_idx == 0: # Matched Left\n        non_matched_object = upper_objects[2] # Select Right\n    elif matched_object_idx == 2: # Matched Right\n        non_matched_object = upper_objects[0] # Select Left\n    else: # Matched Middle (idx 1)\n        non_matched_object = upper_objects[2] # Select Right (based on assumption)\n\n    objects_to_stack = [matched_object, non_matched_object]\n\n    # 5. Determine Stacking Order\n    top_object = None\n    bottom_object = None\n    \n    # Determine base order: Leftmost original index vs Rightmost original index\n    obj_a, obj_b = objects_to_stack[0], objects_to_stack[1]\n    left_orig_obj = obj_a if obj_a['original_index'] < obj_b['original_index'] else obj_b\n    right_orig_obj = obj_b if obj_a['original_index'] < obj_b['original_index'] else obj_a\n\n    # Base order: Rightmost on top for Hollow/Diagonal, Leftmost on top for Plus\n    if key_type == \"Hollow\" or key_type == \"Diagonal\":\n        base_top = right_orig_obj\n        base_bottom = left_orig_obj\n    else: # key_type == \"Plus\"\n        base_top = left_orig_obj\n        base_bottom = right_orig_obj\n\n    # Modification: Flip for Hollow + High Key\n    if key_type == \"Hollow\" and is_key_high:\n        top_object = base_bottom\n        bottom_object = base_top\n    else:\n        top_object = base_top\n        bottom_object = base_bottom\n        \n    # 6. Determine Vertical Placement\n    output_start_row = -1\n    if is_key_high:\n        if key_type == \"Hollow\": output_start_row = 3\n        elif key_type == \"Diagonal\": output_start_row = 0\n        elif key_type == \"Plus\": output_start_row = 1\n    else: # Key is Low\n        if key_type == \"Hollow\": output_start_row = 2\n        # Add fallbacks or assumptions for Diagonal/Plus Low if needed\n        # else: output_start_row = 1 # Default assumption?\n\n    if output_start_row == -1:\n        return output_grid.tolist() # Cannot place if start row is undetermined\n\n    # 7. Construct Output Grid\n    top_height, top_width = get_object_dims(top_object)\n    top_start_col = (output_width - top_width) // 2\n    draw_object(output_grid, top_object, output_start_row, top_start_col)\n\n    bottom_start_row = output_start_row + top_height # Place immediately below\n    bottom_height, bottom_width = get_object_dims(bottom_object)\n    bottom_start_col = (output_width - bottom_width) // 2\n    draw_object(output_grid, bottom_object, bottom_start_row, bottom_start_col)\n\n    # Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21388,
    "candidates_token_count": 3335,
    "total_token_count": 24723,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.161286,
  "retries": null
}