{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a horizontal gray separator line in the input grid.\nFinds three colored objects above the line and one blue key object below the line.\nDetermines which upper object's shape matches the key object's shape.\nDiscards the matched object.\nStacks the remaining two upper objects vertically in a new 9-row output grid.\nThe stacking order (which object is on top) depends on the horizontal position (Left, Middle, Right) of the discarded object.\n  - Discard Left: Right object on top of Middle object.\n  - Discard Middle: Left object on top of Right object.\n  - Discard Right: Left object on top of Middle object.\nThe vertical starting position of the stack in the output grid depends on the vertical position of the key object (High/Low) and the horizontal position of the discarded object.\n  - Key Low & Discard Left: Start Row 2\n  - Key High & Discard Left: Start Row 0\n  - Key Low & Discard Middle/Right: Start Row 1\n  - Key High & Discard Middle/Right: Start Row 3\nThe stacked objects are centered horizontally in the output grid.\n\"\"\"\n\ndef find_separator_row(grid):\n    \"\"\"Finds the row index containing the horizontal gray line (color 5).\"\"\"\n    for r, row in enumerate(grid):\n        if all(pixel == 5 for pixel in row):\n            return r\n    return -1 # Should not happen based on examples\n\ndef find_objects(grid, ignore_colors=[0, 5]):\n    \"\"\"\n    Finds connected objects of the same color in the grid, ignoring specified colors.\n    Uses Breadth-First Search (BFS).\n    Returns a list of objects, where each object is a dict containing:\n    'color', 'coords' (set of (r, c) tuples), 'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) in visited or grid[r, c] in ignore_colors:\n                continue\n\n            color = grid[r, c]\n            obj_coords = set()\n            q = deque([(r, c)])\n            visited.add((r, c))\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_coords.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check 8 neighbors (including diagonals)\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n            objects.append({\n                'color': color,\n                'coords': obj_coords,\n                'bbox': (min_r, min_c, max_r, max_c)\n            })\n    return objects\n\ndef get_relative_shape(obj):\n    \"\"\"\n    Calculates the shape of an object relative to its bounding box top-left corner.\n    Returns a frozenset of (dr, dc) tuples.\n    \"\"\"\n    min_r, min_c, _, _ = obj['bbox']\n    shape = set()\n    for r, c in obj['coords']:\n        shape.add((r - min_r, c - min_c))\n    return frozenset(shape) # Use frozenset to make it hashable for comparison\n\ndef get_object_dims(obj):\n    \"\"\"Calculates the height and width of an object's bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef draw_object(output_grid, obj, target_start_row, target_start_col):\n    \"\"\"Draws an object onto the output grid at the specified top-left position.\"\"\"\n    min_r, min_c, _, _ = obj['bbox']\n    for r, c in obj['coords']:\n        dr = r - min_r\n        dc = c - min_c\n        out_r = target_start_row + dr\n        out_c = target_start_col + dc\n        # Check bounds before drawing\n        if 0 <= out_r < output_grid.shape[0] and 0 <= out_c < output_grid.shape[1]:\n            output_grid[out_r, out_c] = obj['color']\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic described in the docstring.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_height = 9\n\n    # 1. Find separator and objects\n    separator_row = find_separator_row(input_np)\n    if separator_row == -1:\n        # Fallback or error handling if separator not found\n        return [[0]*width for _ in range(output_height)] \n        \n    all_objects = find_objects(input_np)\n\n    # 2. Separate upper and lower objects\n    upper_objects = [obj for obj in all_objects if obj['bbox'][0] < separator_row]\n    lower_objects = [obj for obj in all_objects if obj['bbox'][0] > separator_row]\n\n    # Validate assumptions (3 upper, 1 lower, lower is blue)\n    if len(upper_objects) != 3 or len(lower_objects) != 1 or lower_objects[0]['color'] != 1:\n         # Fallback or error handling if assumptions invalid\n        return [[0]*width for _ in range(output_height)] \n\n    key_object = lower_objects[0]\n\n    # 3. Sort upper objects by horizontal position (using min_c)\n    upper_objects.sort(key=lambda obj: obj['bbox'][1])\n    position_map = {i: obj for i, obj in enumerate(upper_objects)} # 0:Left, 1:Middle, 2:Right\n\n    # 4. Find the matched object\n    key_shape = get_relative_shape(key_object)\n    matched_object = None\n    matched_object_pos_idx = -1\n    kept_objects = []\n\n    for i, obj in enumerate(upper_objects):\n        obj['shape'] = get_relative_shape(obj)\n        obj['dims'] = get_object_dims(obj)\n        if obj['shape'] == key_shape:\n            matched_object = obj\n            matched_object_pos_idx = i\n        else:\n            kept_objects.append(obj)\n\n    if matched_object is None:\n        # Fallback or error handling if no match found\n        return [[0]*width for _ in range(output_height)] \n\n    # 5. Determine stacking order\n    top_object = None\n    bottom_object = None\n    if matched_object_pos_idx == 0: # Matched Left\n        # Right kept obj above Middle kept obj\n        # Kept objects are already sorted by original position\n        # So kept_objects[0] is Middle, kept_objects[1] is Right\n        top_object = kept_objects[1]\n        bottom_object = kept_objects[0]\n    elif matched_object_pos_idx == 1: # Matched Middle\n        # Left kept obj above Right kept obj\n        # kept_objects[0] is Left, kept_objects[1] is Right\n        top_object = kept_objects[0]\n        bottom_object = kept_objects[1]\n    elif matched_object_pos_idx == 2: # Matched Right\n        # Left kept obj above Middle kept obj\n        # kept_objects[0] is Left, kept_objects[1] is Middle\n        top_object = kept_objects[0]\n        bottom_object = kept_objects[1]\n\n    # 6. Determine key object vertical position\n    key_min_row = key_object['bbox'][0]\n    # Using row 10 as the threshold based on examples (separator at 5)\n    # Example 1&3 key starts row 11 (Low). Example 2&4 key starts row 9 (High).\n    is_key_high = key_min_row < 10 \n\n    # 7. Determine output start row for the top object\n    output_start_row = 0\n    if is_key_high:\n        if matched_object_pos_idx == 0: # Match Left\n            output_start_row = 0\n        else: # Match Middle or Right\n            output_start_row = 3\n    else: # Key Low\n        if matched_object_pos_idx == 0: # Match Left\n            output_start_row = 2\n        else: # Match Middle or Right\n            output_start_row = 1\n\n    # 8. Create output grid\n    output_grid = np.zeros((output_height, width), dtype=int)\n\n    # 9. Calculate placement and draw top object\n    top_height, top_width = top_object['dims']\n    top_start_col = (width - top_width) // 2\n    draw_object(output_grid, top_object, output_start_row, top_start_col)\n\n    # 10. Calculate placement and draw bottom object\n    bottom_start_row = output_start_row + top_height # Place immediately below\n    bottom_height, bottom_width = bottom_object['dims']\n    bottom_start_col = (width - bottom_width) // 2\n    draw_object(output_grid, bottom_object, bottom_start_row, bottom_start_col)\n\n    # 11. Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5796,
    "candidates_token_count": 2461,
    "total_token_count": 8257,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 115.391327,
  "retries": null
}