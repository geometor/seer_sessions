{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# --- Constants for Shape Definitions ---\nSHAPE_HOLLOW = frozenset({(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)}) # 8 pixels\nSHAPE_PLUS = frozenset({(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}) # 5 pixels\nSHAPE_DIAGONAL = frozenset({(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)}) # 5 pixels\n\n# Map shapes to names for clarity\nSHAPE_TYPE_MAP = {\n    SHAPE_HOLLOW: \"Hollow\",\n    SHAPE_PLUS: \"Plus\",\n    SHAPE_DIAGONAL: \"Diagonal\"\n}\n# Inverse map for convenience if needed later\n# TYPE_SHAPE_MAP = {v: k for k, v in SHAPE_TYPE_MAP.items()}\n\n# --- Helper Functions ---\n\ndef pad_grid(grid_list):\n    \"\"\"\n    Pads a potentially ragged grid_list (list of lists or tuples) or converts\n    a NumPy array to a padded list of lists of integers.\n    Ensures all rows have the same maximum width found in the input, padding with 0.\n    Handles non-integer elements by converting them to 0.\n    Returns an empty list if the input is invalid or empty.\n    \"\"\"\n    if isinstance(grid_list, np.ndarray):\n        # Convert numpy array to list of lists first\n        try:\n            grid_list = grid_list.tolist()\n        except Exception:\n            return [] # Cannot convert\n\n    if not isinstance(grid_list, (list, tuple)) or not grid_list:\n        return [] # Input must be a non-empty list or tuple\n\n    max_width = 0\n    processed_rows = []\n\n    # First pass: Process rows and find max_width\n    for i, row in enumerate(grid_list):\n        if not isinstance(row, (list, tuple)):\n           # If a row is not a list/tuple, treat it as empty for width calculation\n           # but create a placeholder list for the padding step.\n           processed_rows.append([])\n           continue # Skip max_width calculation for invalid row type\n\n        current_row = []\n        for x in row:\n            try:\n                current_row.append(int(x))\n            except (ValueError, TypeError):\n                current_row.append(0) # Default invalid cell to white (0)\n        processed_rows.append(current_row)\n        max_width = max(max_width, len(current_row))\n\n    if max_width == 0 and not processed_rows: # Check if input was completely invalid\n        return []\n\n    # Second pass: Pad rows\n    padded_grid = []\n    for row in processed_rows:\n        padded_row = row + [0] * (max_width - len(row))\n        padded_grid.append(padded_row)\n\n    return padded_grid\n\ndef find_separator_row(grid_np):\n    \"\"\"\n    Finds the row index containing a horizontal gray line (color 5).\n    Expects an integer NumPy array. Returns -1 if not found.\n    \"\"\"\n    if grid_np.ndim != 2 or grid_np.dtype.kind not in 'iu': # Check dimension and integer type\n         return -1\n    rows, cols = grid_np.shape\n    for r in range(rows):\n        # Ensure comparison works even if cols is 0\n        if cols > 0 and np.all(grid_np[r, :] == 5):\n            return r\n    return -1 # Separator not found\n\ndef find_objects(grid_np, ignore_colors=frozenset({0, 5})):\n    \"\"\"\n    Finds connected objects (8-way connectivity) of the same color in the grid.\n    Ignores specified colors (typically background 0 and separator 5).\n    Expects an integer NumPy array.\n    Returns a list of objects, where each object is a dict containing:\n    'color', 'coords' (set of (r, c) tuples), 'bbox' (min_r, min_c, max_r, max_c),\n    'shape' (frozenset of relative coords), 'height', 'width'.\n    \"\"\"\n    if grid_np.ndim != 2 or grid_np.dtype.kind not in 'iu':\n        return [] # Invalid grid input\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_np[r, c]\n            if visited[r, c] or color in ignore_colors:\n                continue\n\n            obj_coords = set()\n            q = deque([(r, c)])\n            visited[r, c] = True\n            min_r, min_c = r, c\n            max_r, max_c = r, c\n\n            while q:\n                row, col = q.popleft()\n                obj_coords.add((row, col))\n                min_r = min(min_r, row)\n                min_c = min(min_c, col)\n                max_r = max(max_r, row)\n                max_c = max(max_c, col)\n\n                # Check 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n            if obj_coords:\n                # Calculate relative shape\n                shape = frozenset((rr - min_r, cc - min_c) for rr, cc in obj_coords)\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n\n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'shape': shape,\n                    'height': height,\n                    'width': width,\n                    'id': len(objects) # Assign a unique ID for tracking\n                })\n    return objects\n\ndef get_relative_shape(obj):\n    \"\"\" Safely returns the shape from an object dict, or empty frozenset. \"\"\"\n    return obj.get('shape', frozenset())\n\ndef get_object_dims(obj):\n    \"\"\" Safely returns height and width from an object dict, or (0, 0). \"\"\"\n    return obj.get('height', 0), obj.get('width', 0)\n\ndef draw_object(output_grid_np, obj, target_start_row, target_start_col):\n    \"\"\"\n    Draws an object onto the output grid (NumPy array) at the specified top-left position.\n    Uses the object's relative shape and color.\n    \"\"\"\n    if not obj or 'coords' not in obj or not obj['coords']:\n        return # Do nothing if object is invalid\n\n    out_rows, out_cols = output_grid_np.shape\n    min_r, min_c, _, _ = obj['bbox']\n    color = obj['color']\n\n    for r, c in obj['coords']:\n        # Calculate offset from object's top-left\n        dr = r - min_r\n        dc = c - min_c\n        # Calculate target position in output grid\n        out_r = target_start_row + dr\n        out_c = target_start_col + dc\n        # Check bounds before drawing\n        if 0 <= out_r < out_rows and 0 <= out_c < out_cols:\n            output_grid_np[out_r, out_c] = color\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms a 15x15 input grid based on the following rules:\n    1.  Finds a horizontal gray separator line (row 5).\n    2.  Identifies three 3x3 colored objects above the line (Left, Middle, Right)\n        and one blue 3x3 key object below the line.\n    3.  Analyzes the key object's shape (Hollow, Plus, Diagonal) and vertical\n        position (High if top row < 10, Low otherwise).\n    4.  Finds the upper object whose shape matches the key object's shape (Matched Object).\n    5.  Selects the Matched Object and the Rightmost upper object for the output.\n        (If the Rightmost is the Matched object, selects the Leftmost instead).\n    6.  Determines the stacking order of the two selected objects based on Key Type and Key Height:\n        - Base Order: Plus key -> Matched object on top; Hollow/Diagonal keys -> Other selected object on top.\n        - Modification: If Key Type is Hollow AND Key Height is High, flip the Base Order.\n    7.  Determines the vertical starting row for the top object in the 9x15 output grid based on Key Type and Key Height:\n        - High Key: Hollow -> Row 3, Diagonal -> Row 0, Plus -> Row 1.\n        - Low Key: Hollow -> Row 2. (Other types assumed to follow High rules if they occur).\n    8.  Constructs the output grid (9x15) by stacking the selected objects in the\n        determined order, starting at the calculated row, and centered horizontally.\n    \"\"\"\n    # 0. Initialize and Validate Input\n    padded_input_list = pad_grid(input_grid)\n    if not padded_input_list:\n        # Return default 9x15 white grid if input padding failed\n        return [[0] * 15 for _ in range(9)]\n\n    input_np = np.array(padded_input_list, dtype=int)\n\n    # Expect 15x15 input, produce 9x15 output\n    expected_input_h, expected_input_w = 15, 15\n    output_h, output_w = 9, 15\n    default_output = np.zeros((output_h, output_w), dtype=int)\n\n    if input_np.shape != (expected_input_h, expected_input_w):\n         # Handle unexpected input dimensions if necessary, here returning default\n         return default_output.tolist()\n\n    # 1. Identify Separator\n    separator_row = find_separator_row(input_np)\n    if separator_row != 5: # Expect separator specifically at row 5\n        return default_output.tolist()\n\n    # 2. Identify Objects\n    all_objects = find_objects(input_np, ignore_colors=frozenset({0, 5}))\n\n    # Filter objects above and below the separator\n    upper_objects_raw = [obj for obj in all_objects if obj['bbox'][0] < separator_row]\n    lower_objects = [obj for obj in all_objects if obj['bbox'][0] > separator_row]\n\n    # Validate assumptions: 3 upper, 1 lower (blue)\n    if len(upper_objects_raw) != 3 or len(lower_objects) != 1:\n        return default_output.tolist()\n\n    key_object = lower_objects[0]\n    if key_object['color'] != 1: # Key must be blue\n         return default_output.tolist()\n\n    # Sort upper objects by horizontal position (min_c) and assign location names\n    upper_objects = sorted(upper_objects_raw, key=lambda obj: obj['bbox'][1])\n    if len(upper_objects) == 3:\n        upper_objects[0]['location'] = 'Left'\n        upper_objects[1]['location'] = 'Middle'\n        upper_objects[2]['location'] = 'Right'\n    else: # Should not happen based on length check, but safety belt\n        return default_output.tolist()\n\n    # 3. Analyze Key Object\n    key_shape = get_relative_shape(key_object)\n    key_type = SHAPE_TYPE_MAP.get(key_shape, \"Unknown\")\n    if key_type == \"Unknown\":\n        return default_output.tolist() # Cannot proceed if key shape is unrecognized\n\n    key_min_row = key_object['bbox'][0]\n    is_key_high = key_min_row < 10 # Definition: High if top row < 10\n\n    # 4. Find Match\n    matched_object = None\n    for obj in upper_objects:\n        if get_relative_shape(obj) == key_shape:\n            matched_object = obj\n            break # Found the match\n\n    if matched_object is None:\n        return default_output.tolist() # Cannot proceed without a match\n\n    # 5. Select Objects for Output\n    # Select Matched object and Rightmost object.\n    # If Rightmost IS the matched object, select Leftmost instead.\n    rightmost_object = upper_objects[2]\n    leftmost_object = upper_objects[0]\n\n    if matched_object['id'] == rightmost_object['id']:\n        other_selected_object = leftmost_object\n    else:\n        other_selected_object = rightmost_object\n\n    # We now have 'matched_object' and 'other_selected_object'\n\n    # 6. Determine Stacking Order\n    top_object = None\n    bottom_object = None\n\n    # Base order: Plus key -> Matched on top; Hollow/Diagonal -> Other on top\n    if key_type == \"Plus\":\n        base_top = matched_object\n        base_bottom = other_selected_object\n    elif key_type == \"Hollow\" or key_type == \"Diagonal\":\n        base_top = other_selected_object\n        base_bottom = matched_object\n    else: # Should be unreachable due to earlier key_type check\n         return default_output.tolist()\n\n    # Modification: Flip for Hollow + High Key\n    if key_type == \"Hollow\" and is_key_high:\n        top_object = base_bottom\n        bottom_object = base_top\n    else:\n        top_object = base_top\n        bottom_object = base_bottom\n\n    # 7. Determine Vertical Placement\n    output_start_row = -1 # Initialize to invalid value\n\n    # Rules based on Key Type and Key Height\n    if is_key_high:\n        if key_type == \"Hollow\": output_start_row = 3\n        elif key_type == \"Diagonal\": output_start_row = 0\n        elif key_type == \"Plus\": output_start_row = 1\n    else: # Key is Low\n        # Assume only Hollow is observed for Low keys in examples\n        if key_type == \"Hollow\": output_start_row = 2\n        # Add rules for other low keys if observed, otherwise they might default to -1\n        # Fallback assumption: use High rules if type/height combo not specified\n        elif key_type == \"Diagonal\": output_start_row = 0 # Assuming same as high\n        elif key_type == \"Plus\": output_start_row = 1 # Assuming same as high\n\n\n    if output_start_row == -1:\n        # If placement rule didn't match (e.g., unexpected key type/height combo)\n        return default_output.tolist()\n\n    # 8. Construct Output Grid\n    output_grid_np = np.zeros((output_h, output_w), dtype=int)\n\n    # All objects are assumed 3x3, calculate centering column\n    obj_width = 3 # Assuming all relevant objects are 3 wide\n    center_start_col = (output_w - obj_width) // 2 # (15 - 3) // 2 = 6\n\n    # Draw the top object\n    top_h, _ = get_object_dims(top_object)\n    draw_object(output_grid_np, top_object, output_start_row, center_start_col)\n\n    # Draw the bottom object immediately below the top one\n    # Assuming top object height is 3\n    bottom_start_row = output_start_row + 3 # top_h should be 3\n    draw_object(output_grid_np, bottom_object, bottom_start_row, center_start_col)\n\n    # Return as list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10809,
    "candidates_token_count": 3938,
    "total_token_count": 14747,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.432665,
  "retries": null
}