{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n# Define color constants\nWHITE = 0\nBLUE = 1\nRED = 2\nGREEN = 3\n# YELLOW = 4 # Not used in this logic\n# GRAY = 5 # Not used in this logic\n# MAGENTA = 6 # Not used in this logic\nORANGE = 7\nAZURE = 8\n# MAROON = 9 # Not used in this logic\n\n# Define the canonical shapes found in the examples, represented by 1s on a 0 background\n# Shape 1 ('+') maps to Red (2)\nPLUS_SHAPE = np.array([\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n], dtype=np.uint8)\n\n# Shape 2 ('Weird Cross') maps to Green (3)\n# Found in examples 2 and 5\nWEIRD_CROSS_SHAPE = np.array([\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 1, 1]\n], dtype=np.uint8)\n\n# Shape 3 ('Weird L') maps to Orange (7)\n# Found in example 4\nWEIRD_L_SHAPE = np.array([\n    [1, 1, 1],\n    [1, 0, 1],\n    [0, 1, 0]\n], dtype=np.uint8)\n\ndef _find_pixels(grid, color):\n    \"\"\"Finds the coordinates of all pixels of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if len(rows) == 0:\n        return None # No pixels of this color found\n    return list(zip(rows, cols))\n\ndef _extract_shape_pattern(grid, color):\n    \"\"\"\n    Extracts the pattern of a given color as a minimal bounding box grid.\n    The pattern is represented by 1s on a background of 0s.\n    Returns the pattern grid (numpy array) or None if no pixels of the color are found.\n    \"\"\"\n    # Find all coordinates of the specified color\n    coords = _find_pixels(grid, color)\n    if not coords:\n        return None # No pattern found\n\n    # Determine the bounding box of the pattern\n    rows, cols = zip(*coords)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Calculate the dimensions of the minimal grid containing the pattern\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Create an empty grid (filled with 0s) for the pattern\n    pattern_grid = np.zeros((height, width), dtype=np.uint8)\n\n    # Populate the pattern grid with 1s at the relative coordinates of the colored pixels\n    for r, c in coords:\n        relative_r = r - min_r\n        relative_c = c - min_c\n        pattern_grid[relative_r, relative_c] = 1 # Use 1 to represent the shape\n\n    return pattern_grid\n\n\ndef _get_target_color_from_shape(blue_shape_pattern):\n    \"\"\"\n    Determines the target color (Red, Green, or Orange) based on the\n    provided blue shape pattern grid.\n    Raises ValueError if the shape is not recognized or not found.\n    \"\"\"\n    if blue_shape_pattern is None:\n        raise ValueError(\"No blue shape pattern found in the input grid.\")\n\n    # Compare the extracted shape with the known canonical shapes\n    if blue_shape_pattern.shape == PLUS_SHAPE.shape and np.array_equal(blue_shape_pattern, PLUS_SHAPE):\n        return RED\n    elif blue_shape_pattern.shape == WEIRD_CROSS_SHAPE.shape and np.array_equal(blue_shape_pattern, WEIRD_CROSS_SHAPE):\n        return GREEN\n    elif blue_shape_pattern.shape == WEIRD_L_SHAPE.shape and np.array_equal(blue_shape_pattern, WEIRD_L_SHAPE):\n        return ORANGE\n    else:\n        # This case should ideally not happen with valid ARC task inputs following the observed pattern\n        raise ValueError(f\"Unknown blue shape pattern encountered:\\n{blue_shape_pattern}\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identifies a pattern of blue (1) pixels.\n    2. Determines the specific shape of the blue pattern by comparing it to known templates ('+', 'Weird Cross', 'Weird L').\n    3. Maps the identified blue shape to a target color: '+' maps to Red(2), 'Weird Cross' maps to Green(3), 'Weird L' maps to Orange(7).\n    4. Creates an output grid by:\n       a. Replacing all azure (8) pixels in the input grid with the determined target color.\n       b. Replacing all blue (1) pixels in the input grid with the background color (white=0).\n       c. Keeping all other pixels (background white=0) the same.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=np.uint8)\n\n    # --- Step 1 & 2: Identify blue shape ---\n    # Extract the minimal grid containing the blue pattern, represented by 1s\n    blue_shape_pattern = _extract_shape_pattern(input_array, BLUE)\n\n    # --- Step 3: Map shape to target color ---\n    # Determine the target color based on the identified blue shape\n    # This will raise a ValueError if the shape is missing or not recognized\n    target_color = _get_target_color_from_shape(blue_shape_pattern)\n\n    # --- Step 4: Create output grid ---\n    # Initialize output grid as a copy of the input\n    output_array = input_array.copy()\n\n    # 4a. Recolor Azure Pixels: Find all azure pixels and change them to the target color\n    output_array[input_array == AZURE] = target_color\n\n    # 4b. Remove Blue Pixels: Find all blue pixels and change them to the background color\n    output_array[input_array == BLUE] = WHITE\n\n    # 4c. Other pixels (white=0) remain unchanged as they were copied initially.\n\n    # Convert the resulting numpy array back to a list of lists for the standard ARC output format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6183,
    "candidates_token_count": 1534,
    "total_token_count": 7717,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.323947,
  "retries": null
}