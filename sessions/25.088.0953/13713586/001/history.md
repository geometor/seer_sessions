
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 4 4 4 4 0 0 0 0
8 8 8 8 0 0 4 3 3 3 4 0 0 0 0
8 8 8 8 0 0 4 3 3 3 4 0 0 0 0
8 8 8 8 0 0 4 3 3 3 4 0 0 0 0
8 8 8 8 0 0 4 3 3 3 4 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 5
0 0 7 0 0 0 3 0 0 0 0 0 0 0 0 0 5
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 5
0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 5
0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 5
0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 5
0 0 7 7 7 7 3 3 3 3 3 3 3 3 3 3 5
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5
```


## train_3

**input:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 3 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 2 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 2 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
5 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
5 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
5 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0
5 3 3 3 3 3 3 3 3 3 6 6 6 6 0 0 0
5 3 3 3 3 3 3 3 3 3 6 6 6 6 0 0 0
5 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
5 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
5 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
5 2 2 2 2 2 2 6 6 6 6 6 6 6 0 0 0
5 2 2 2 2 2 2 6 6 6 6 6 6 6 0 0 0
5 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Grid Structure:** The input and output are both grids of pixels with different colors.
2.  **Background:** The primary background color is white (0).
3.  **Colored Objects:** Each input grid contains one or more distinct, contiguous blocks (objects) of non-white, non-gray colors (e.g., yellow, azure, green in train_1; red, green, orange in train_2; green, magenta, red in train_3). These objects appear as lines or small segments.
4.  **Gray Border:** A single, straight line of gray (5) pixels exists along one edge of the grid (bottom in train_1, right in train_2, left in train_3). This gray line acts as a boundary or wall.
5.  **Transformation:** The core transformation involves filling the white (0) space. The colored objects seem to "expand" or "fill" the adjacent white space in a specific direction until they hit another colored object or the gray border.
6.  **Fill Directionality:** The direction of the fill appears to be determined by the location of the gray border.
    *   If the gray border is at the bottom, the fill direction is downwards.
    *   If the gray border is at the right, the fill direction is rightwards.
    *   If the gray border is at the left, the fill direction is leftwards.
    *   It's logical to assume if the border were at the top, the fill direction would be upwards.
7.  **Fill Mechanism:** A white pixel changes color if the pixel immediately adjacent to it *opposite* the fill direction (e.g., the pixel above for downward fill, the pixel left for rightward fill) is a non-white, non-gray color. The white pixel takes on that adjacent pixel's color. This process repeats iteratively until no more white pixels can be filled according to the rule for that direction.

**Facts:**


```yaml
Grid:
  Type: 2D Array
  Pixels: Represent colors (0-9)
  Background: Primarily white (0)
Boundary:
  Type: Object
  Shape: Line (horizontal or vertical)
  Color: Gray (5)
  Location: Always along one single edge of the grid (top, bottom, left, or right).
  Function: Acts as a stop condition for filling.
Colored_Objects:
  Type: Object(s)
  Shape: Variable, often lines or segments initially.
  Color: Any color except white (0) and gray (5).
  Contiguity: Pixels of the same color are connected.
  Function: Act as sources for filling and stop conditions for other fills.
Transformation:
  Action: Fill
  Target: White (0) pixels.
  Mechanism: Iterative color propagation from non-white, non-gray pixels.
  Direction_Rule: Determined by the location of the Gray Boundary.
    - If Boundary is Bottom, Fill Direction is Down.
    - If Boundary is Right, Fill Direction is Right.
    - If Boundary is Left, Fill Direction is Left.
    - If Boundary is Top, Fill Direction is Up.
  Propagation_Rule: A white pixel at (r, c) changes color based on the Fill Direction:
    - Down: Takes color from pixel (r-1, c) if it's non-white/non-gray.
    - Right: Takes color from pixel (r, c-1) if it's non-white/non-gray.
    - Left: Takes color from pixel (r, c+1) if it's non-white/non-gray.
    - Up: Takes color from pixel (r+1, c) if it's non-white/non-gray.
  Stop_Condition: Filling stops when a pixel encounters a non-white pixel (either another Colored_Object or the Gray Boundary) in the Fill Direction.
  Iteration: The filling process repeats until no more white pixels can change color according to the rules in a single pass.
```


**Natural Language Program:**

1.  **Identify the Boundary:** Scan the edges (top row, bottom row, leftmost column, rightmost column) of the input grid to locate the gray (5) line. Determine if it's positioned at the top, bottom, left, or right edge.
2.  **Determine Fill Direction:** Based on the boundary's location, set the fill direction:
    *   If the boundary is at the bottom, the fill direction is Down.
    *   If the boundary is at the right, the fill direction is Right.
    *   If the boundary is at the left, the fill direction is Left.
    *   If the boundary is at the top, the fill direction is Up.
3.  **Initialize Output Grid:** Create a copy of the input grid. This copy will be modified.
4.  **Iterative Filling:** Repeat the following process until no changes are made to the output grid in a full pass:
    *   Set a flag `change_made` to `False`.
    *   Iterate through each pixel `(r, c)` of the grid.
    *   Check if the current pixel `(r, c)` in the *output* grid is white (0).
    *   If it is white, check the color of the adjacent pixel *opposite* the fill direction (the "source" pixel):
        *   **Down Fill:** Check pixel `(r-1, c)`.
        *   **Right Fill:** Check pixel `(r, c-1)`.
        *   **Left Fill:** Check pixel `(r, c+1)`.
        *   **Up Fill:** Check pixel `(r+1, c)`.
        *   *(Ensure the source pixel coordinates are within the grid boundaries)*.
    *   If the source pixel exists and its color in the *output* grid is neither white (0) nor gray (5):
        *   Change the color of the current pixel `(r, c)` in the output grid to the color of the source pixel.
        *   Set `change_made` to `True`.
    *   If `change_made` is `False` after iterating through all pixels, exit the loop.
5.  **Return Output:** The final modified grid is the result.
