{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n# COLOR MAPPING (for reference, not used directly in logic)\n# 0: white\n# 1: blue\n# 2: red\n# 3: green\n# ...\n\ndef find_pixels(grid, color):\n    \"\"\"\n    Finds all coordinates (row, col) of pixels with a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of tuples, where each tuple is the (row, col) coordinate.\n    \"\"\"\n    points = []\n    # Iterate through each cell of the grid\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            # If the cell color matches the target color, add its coordinates\n            if grid[r, c] == color:\n                points.append((r, c))\n    return points\n\ndef get_line_pixels(p1, p2):\n    \"\"\"\n    Generates integer coordinates for pixels on the straight line segment\n    connecting p1 and p2 (inclusive).\n    Handles horizontal, vertical, and diagonal lines (slope +/- 1).\n    Assumes the line will be one of these three types based on ARC task nature.\n\n    Args:\n        p1 (tuple): The (row, col) coordinates of the first endpoint.\n        p2 (tuple): The (row, col) coordinates of the second endpoint.\n\n    Returns:\n        list: A list of (row, col) tuples representing pixels on the line segment.\n    \"\"\"\n    r1, c1 = p1\n    r2, c2 = p2\n    points = []\n\n    # Determine the type of line and generate points accordingly\n    if r1 == r2:  # Horizontal line\n        # Iterate through columns from the minimum to maximum column index\n        for c in range(min(c1, c2), max(c1, c2) + 1):\n            points.append((r1, c))\n    elif c1 == c2:  # Vertical line\n        # Iterate through rows from the minimum to maximum row index\n        for r in range(min(r1, r2), max(r1, r2) + 1):\n            points.append((r, c1))\n    elif abs(r1 - r2) == abs(c1 - c2):  # Diagonal line (slope is +/- 1)\n        # Determine the step direction for row and column\n        dr = np.sign(r2 - r1)\n        dc = np.sign(c2 - c1)\n        r, c = r1, c1\n        # Step along the diagonal until the second endpoint is reached\n        while True:\n            points.append((r, c))\n            if (r, c) == (r2, c2):\n                break\n            r += dr\n            c += dc\n    # else: # Optional: Handle cases where the line is not H, V, or D - assumed not to occur in this ARC task\n\n    return points\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rule:\n    1. Find the two red (2) pixels in the input grid. These act as endpoints.\n    2. Identify the straight line segment (horizontal, vertical, or diagonal with slope +/- 1) \n       connecting these two red pixels.\n    3. Create a copy of the input grid for the output.\n    4. Iterate through all pixels lying on the identified line segment (including endpoints).\n    5. For each pixel on the line:\n       - If the pixel's original color in the input grid is white (0), change its color \n         to red (2) in the output grid.\n       - If the pixel's original color in the input grid is blue (1), change its color \n         to green (3) in the output grid.\n       - If the pixel's color is anything else (including the original red endpoints), \n         keep its original color in the output grid.\n    6. Return the modified grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy of the input grid to modify, ensuring the original is unchanged\n    output_np = np.copy(input_np)\n\n    # Define color constants for clarity\n    RED = 2\n    WHITE = 0\n    BLUE = 1\n    GREEN = 3\n\n    # Step 1: Find the coordinates of the two red pixels\n    red_pixels = find_pixels(input_np, RED)\n\n    # Assumption based on training examples: there are exactly two red pixels.\n    # If not, the behavior might be undefined or return the unchanged grid.\n    if len(red_pixels) != 2:\n        # In a robust implementation, might raise error or log warning.\n        # For ARC, often assume test cases follow the observed pattern.\n        return input_grid # Return original if assumption fails\n\n    p1, p2 = red_pixels[0], red_pixels[1]\n\n    # Step 2: Get all pixel coordinates on the line segment between the red pixels\n    line_pixels = get_line_pixels(p1, p2)\n\n    # Step 4 & 5: Iterate through the pixels on the line and apply transformations\n    for r, c in line_pixels:\n        # Get the original color of the pixel at (r, c) from the input grid\n        original_color = input_np[r, c]\n        \n        # Apply the transformation rules based on the original color\n        if original_color == WHITE:\n            output_np[r, c] = RED  # Change white to red\n        elif original_color == BLUE:\n            output_np[r, c] = GREEN # Change blue to green\n        # No action needed for other colors; they remain the same in the copied output grid.\n\n    # Step 6: Convert the final numpy array back to a list of lists for ARC standard output\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3106,
    "candidates_token_count": 1397,
    "total_token_count": 4503,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.019946,
  "retries": null
}