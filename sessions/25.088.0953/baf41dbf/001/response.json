{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify distinct green (3) shapes and magenta (6) markers in the input grid.\nFor each green shape, find associated magenta markers that align horizontally or vertically with the shape's bounding box.\nBased on the relative position of the associated marker (left, right, above, below), determine a rectangular fill area extending from the shape's edge towards the marker.\nFill the calculated area(s) in the output grid with green (3), overwriting any existing colors except magenta (6).\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is represented by:\n              - set: A set of (row, col) tuples representing the pixels of the object.\n              - tuple: The bounding box (min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append((obj_pixels, (min_r, max_r, min_c, max_c)))\n    return objects\n\ndef find_pixels(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels of a specific color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to find.\n\n    Returns:\n        list: A list of (row, col) tuples for pixels of the specified color.\n    \"\"\"\n    return list(zip(*np.where(grid == color)))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extending green shapes towards associated magenta markers.\n\n    1. Finds all distinct green shapes and magenta markers.\n    2. For each green shape, determines associated markers based on alignment.\n    3. Calculates the fill area between the shape and the marker.\n    4. Fills the area with green, avoiding overwriting magenta markers.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    \n    # Find green shapes (color 3) and their bounding boxes\n    green_shapes = find_objects(output_grid, 3)\n    \n    # Find magenta markers (color 6)\n    magenta_markers = find_pixels(output_grid, 6)\n\n    # Process each green shape\n    for _, (min_r, max_r, min_c, max_c) in green_shapes:\n        # Check each marker for association\n        for m_r, m_c in magenta_markers:\n            fill_area_rows = None\n            fill_area_cols = None\n\n            # Check horizontal alignment (marker row within shape's row span)\n            if min_r <= m_r <= max_r:\n                # Marker is to the right\n                if m_c > max_c:\n                    fill_area_rows = range(min_r, max_r + 1)\n                    fill_area_cols = range(max_c + 1, m_c)\n                # Marker is to the left\n                elif m_c < min_c:\n                    fill_area_rows = range(min_r, max_r + 1)\n                    fill_area_cols = range(m_c + 1, min_c)\n\n            # Check vertical alignment (marker col within shape's col span)\n            elif min_c <= m_c <= max_c:\n                 # Marker is below\n                if m_r > max_r:\n                    fill_area_rows = range(max_r + 1, m_r)\n                    fill_area_cols = range(min_c, max_c + 1)\n                # Marker is above\n                elif m_r < min_r:\n                    fill_area_rows = range(m_r + 1, min_r)\n                    fill_area_cols = range(min_c, max_c + 1)\n            \n            # Apply fill if an area was determined\n            if fill_area_rows is not None and fill_area_cols is not None:\n                for r in fill_area_rows:\n                    for c in fill_area_cols:\n                        # Ensure coordinates are within grid bounds\n                        if 0 <= r < rows and 0 <= c < cols:\n                           # Fill with green (3) only if not magenta (6)\n                           if output_grid[r, c] != 6:\n                               output_grid[r, c] = 3\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4533,
    "candidates_token_count": 1406,
    "total_token_count": 5939,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.337894,
  "retries": null
}