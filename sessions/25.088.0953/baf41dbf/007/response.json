{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by expanding green shapes into adjacent white areas. \nThe expansion is directed towards magenta markers that are horizontally or vertically \naligned with the initial bounding box of the green shape. The expansion stops one \npixel short of the marker. Only white pixels in the expansion path are filled \nwith green. Original green shapes, magenta markers, and white pixels within the \noriginal green shape's bounding box are preserved.\n\n1.  Create a copy of the input grid for the output.\n2.  Find all distinct contiguous green (3) shapes and their initial bounding \n    boxes (min_r, max_r, min_c, max_c).\n3.  Find the coordinates of all magenta (6) markers.\n4.  For each green shape:\n    a.  Determine the maximum extent of expansion in each of the four \n        directions (up, down, left, right) based on aligned magenta markers.\n        i.  Initialize expansion limits: find the marker closest but outside \n            the initial bounding box for each direction (left, right, top, bottom) \n            that shares the respective row/column range of the initial box.\n        ii. Calculate the final expansion boundaries, stopping one pixel before \n            the respective marker. Default to the initial bounding box edge if \n            no marker exists in a direction.\n    b.  Define four rectangular expansion zones (potentially empty):\n        - Left Zone: The area between the calculated left expansion boundary and \n          the initial left edge of the shape, within the shape's initial row span.\n        - Right Zone: The area between the initial right edge and the calculated \n          right expansion boundary, within the shape's initial row span.\n        - Top Zone: The area between the calculated top expansion boundary and \n          the initial top edge, within the shape's initial column span.\n        - Bottom Zone: The area between the initial bottom edge and the \n          calculated bottom expansion boundary, within the shape's initial column span.\n    c.  Iterate through the pixels within these four expansion zones.\n    d.  If a pixel `(r, c)` within an expansion zone corresponds to a white (0) \n        pixel in the *input* grid, change its color to green (3) in the *output* grid.\n5.  Return the modified output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              - 'pixels': A set of (row, col) tuples for the object's pixels.\n              - 'bbox': The bounding box (min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels, 'bbox': (min_r, max_r, min_c, max_c)})\n    return objects\n\ndef find_pixels(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels of a specific color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to find.\n\n    Returns:\n        list: A list of (row, col) tuples for pixels of the specified color.\n    \"\"\"\n    # np.where returns tuple of arrays (rows, cols); zip pairs them up\n    return list(zip(*np.where(grid == color)))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 2. Identify Green Shapes and their initial bounding boxes\n    green_shapes = find_objects(input_grid, 3)\n\n    # 3. Identify Magenta Markers\n    magenta_markers = find_pixels(input_grid, 6)\n\n    # 4. Process each green shape\n    for shape in green_shapes:\n        # Get the initial bounding box\n        min_r, max_r, min_c, max_c = shape['bbox']\n\n        # 4a. Determine expansion limits based on aligned markers\n        # Find the marker *positions* that define the furthest expansion boundary\n        limit_left_c = -1  # Furthest marker col to the left\n        limit_right_c = cols # Furthest marker col to the right\n        limit_top_r = -1   # Furthest marker row above\n        limit_bottom_r = rows # Furthest marker row below\n\n        for m_r, m_c in magenta_markers:\n            # Check horizontal alignment (marker row within shape's initial row span)\n            if min_r <= m_r <= max_r:\n                if m_c < min_c:\n                    limit_left_c = max(limit_left_c, m_c) # Find the closest marker to the shape edge\n                elif m_c > max_c:\n                    limit_right_c = min(limit_right_c, m_c) # Find the closest marker to the shape edge\n\n            # Check vertical alignment (marker col within shape's initial col span)\n            if min_c <= m_c <= max_c:\n                if m_r < min_r:\n                    limit_top_r = max(limit_top_r, m_r) # Find the closest marker to the shape edge\n                elif m_r > max_r:\n                    limit_bottom_r = min(limit_bottom_r, m_r) # Find the closest marker to the shape edge\n\n        # Calculate the final coordinates for the expansion fill (stop before marker)\n        # Default to initial bbox edge if no marker found in that direction\n        expand_min_c = limit_left_c + 1 if limit_left_c != -1 else min_c\n        expand_max_c = limit_right_c - 1 if limit_right_c != cols else max_c\n        expand_min_r = limit_top_r + 1 if limit_top_r != -1 else min_r\n        expand_max_r = limit_bottom_r - 1 if limit_bottom_r != rows else max_r\n\n        # Clamp to grid boundaries (though loop ranges should handle this)\n        expand_min_c = max(0, expand_min_c)\n        expand_max_c = min(cols - 1, expand_max_c)\n        expand_min_r = max(0, expand_min_r)\n        expand_max_r = min(rows - 1, expand_max_r)\n\n        # 4b. Define and fill expansion zones\n        # 4c/d. Iterate through zones and fill white pixels\n\n        # Fill Left Zone (if expansion happened leftwards)\n        if expand_min_c < min_c:\n            for r in range(min_r, max_r + 1):\n                for c in range(expand_min_c, min_c): # Up to min_c - 1\n                     # Check bounds just in case, though range should be correct\n                    if 0 <= r < rows and 0 <= c < cols:\n                        if input_grid[r, c] == 0:\n                           output_grid[r, c] = 3\n\n        # Fill Right Zone (if expansion happened rightwards)\n        if expand_max_c > max_c:\n            for r in range(min_r, max_r + 1):\n                for c in range(max_c + 1, expand_max_c + 1): # Up to expand_max_c\n                     if 0 <= r < rows and 0 <= c < cols:\n                        if input_grid[r, c] == 0:\n                            output_grid[r, c] = 3\n\n        # Fill Top Zone (if expansion happened upwards)\n        if expand_min_r < min_r:\n            for r in range(expand_min_r, min_r): # Up to min_r - 1\n                for c in range(min_c, max_c + 1):\n                     if 0 <= r < rows and 0 <= c < cols:\n                        if input_grid[r, c] == 0:\n                            output_grid[r, c] = 3\n\n        # Fill Bottom Zone (if expansion happened downwards)\n        if expand_max_r > max_r:\n            for r in range(max_r + 1, expand_max_r + 1): # Up to expand_max_r\n                for c in range(min_c, max_c + 1):\n                     if 0 <= r < rows and 0 <= c < cols:\n                        if input_grid[r, c] == 0:\n                            output_grid[r, c] = 3\n\n    # 5. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15140,
    "candidates_token_count": 2434,
    "total_token_count": 17574,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 116.234869,
  "retries": null
}