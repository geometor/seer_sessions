{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by extending green shapes towards associated magenta markers.\n\n1. Identify all distinct contiguous green (3) shapes and their initial bounding boxes.\n2. Identify all magenta (6) marker pixels.\n3. For each green shape, calculate its final extended bounding box:\n    - Start with the initial bounding box.\n    - Check each magenta marker for horizontal or vertical alignment with the *initial* bounding box.\n    - If a marker is aligned and outside the initial box, expand the corresponding edge of the bounding box towards the marker, stopping one pixel short. Use min/max to handle multiple markers extending the same edge.\n4. Create the output grid by filling the area within each calculated final extended bounding box with green (3), *unless* the pixel corresponds to a magenta (6) marker in the input grid. Magenta markers are preserved.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              - 'pixels': A set of (row, col) tuples for the object's pixels.\n              - 'bbox': The bounding box (min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels, 'bbox': (min_r, max_r, min_c, max_c)})\n    return objects\n\ndef find_pixels(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels of a specific color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to find.\n\n    Returns:\n        list: A list of (row, col) tuples for pixels of the specified color.\n    \"\"\"\n    return list(zip(*np.where(grid == color)))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    \n    # 1. Identify Objects\n    green_shapes = find_objects(input_grid, 3)\n    magenta_markers = find_pixels(input_grid, 6)\n\n    # Store the final extended bounding boxes for each shape\n    extended_bboxes = []\n\n    # 2. Calculate Extensions for each green shape\n    for shape in green_shapes:\n        # Get the initial bounding box\n        min_r, max_r, min_c, max_c = shape['bbox']\n        # Initialize the extended bounding box with the initial values\n        ext_min_r, ext_max_r = min_r, max_r\n        ext_min_c, ext_max_c = min_c, max_c\n\n        # Check each marker for association and update extended bounds\n        for m_r, m_c in magenta_markers:\n            # Check horizontal alignment (marker row within shape's initial row span)\n            if min_r <= m_r <= max_r:\n                # Marker is to the right of the initial bbox\n                if m_c > max_c:\n                    ext_max_c = max(ext_max_c, m_c - 1)\n                # Marker is to the left of the initial bbox\n                elif m_c < min_c:\n                    ext_min_c = min(ext_min_c, m_c + 1)\n\n            # Check vertical alignment (marker col within shape's initial col span)\n            elif min_c <= m_c <= max_c:\n                 # Marker is below the initial bbox\n                if m_r > max_r:\n                    ext_max_r = max(ext_max_r, m_r - 1)\n                # Marker is above the initial bbox\n                elif m_r < min_r:\n                    ext_min_r = min(ext_min_r, m_r + 1)\n        \n        # Store the calculated final extended bounding box for this shape\n        extended_bboxes.append((ext_min_r, ext_max_r, ext_min_c, ext_max_c))\n\n    # 4. Fill Extended Areas in the output grid\n    # Note: We fill based on *all* extended boxes combined conceptually.\n    # If a pixel falls within *any* extended box, it becomes green (unless it's a marker).\n    for ext_min_r, ext_max_r, ext_min_c, ext_max_c in extended_bboxes:\n        # Iterate through every pixel within this extended bounding box\n        for r in range(ext_min_r, ext_max_r + 1):\n            for c in range(ext_min_c, ext_max_c + 1):\n                # Ensure coordinates are within the grid bounds (safety check)\n                if 0 <= r < rows and 0 <= c < cols:\n                    # Check the *original* input grid for a magenta marker\n                    if input_grid[r, c] != 6:\n                        # If not a marker, fill with green in the output grid\n                        output_grid[r, c] = 3\n\n    # 5. Final Result: The output grid now contains the filled areas\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11254,
    "candidates_token_count": 1599,
    "total_token_count": 12853,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.412566,
  "retries": null
}