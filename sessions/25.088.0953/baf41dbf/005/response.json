{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by extending green shapes towards associated magenta markers, \nfilling the extended area with green while preserving magenta markers and original \nwhite spaces within the initial bounds of the green shapes.\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Identify all distinct, contiguous green (3) shapes and their initial bounding \n    boxes (min_row, max_row, min_col, max_col).\n3.  Identify the coordinates of all magenta (6) marker pixels.\n4.  For each identified green shape:\n    a.  Calculate its corresponding \"extended bounding box\" based on marker alignment:\n        i.  Start with the initial bounding box dimensions.\n        ii. Check each magenta marker for horizontal or vertical alignment with the \n            *initial* bounding box.\n        iii. If a marker is aligned and outside the initial box, expand the \n             corresponding edge of the bounding box towards the marker, stopping \n             one pixel short. Use min/max to handle multiple markers extending \n             the same edge.\n    b.  Iterate through all pixel coordinates (row `r`, column `c`) within this \n        calculated extended bounding box.\n    c.  For each pixel (r, c) inside the extended bounding box:\n        i.  If the pixel in the *input* grid `input_grid[r, c]` is magenta (6), \n            do nothing (it's preserved).\n        ii. Else if the pixel (r, c) falls *within* the *initial* bounding box of \n            the current green shape AND the pixel `input_grid[r, c]` is white (0), \n            do nothing (preserve internal \"hole\").\n        iii. Else (pixel is not a marker and not an internal white hole), set \n             the pixel in the `output_grid[r, c]` to green (3).\n5.  Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              - 'pixels': A set of (row, col) tuples for the object's pixels.\n              - 'bbox': The bounding box (min_row, max_row, min_col, max_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels, 'bbox': (min_r, max_r, min_c, max_c)})\n    return objects\n\ndef find_pixels(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels of a specific color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to find.\n\n    Returns:\n        list: A list of (row, col) tuples for pixels of the specified color.\n    \"\"\"\n    # np.where returns tuple of arrays (rows, cols); zip pairs them up\n    return list(zip(*np.where(grid == color)))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 2. Identify Green Shapes and their initial bounding boxes\n    green_shapes = find_objects(input_grid, 3)\n\n    # 3. Identify Magenta Markers\n    magenta_markers = find_pixels(input_grid, 6)\n    magenta_marker_set = set(magenta_markers) # For quick lookup\n\n    # 4. Process each green shape\n    for shape in green_shapes:\n        # Get the initial bounding box\n        min_r, max_r, min_c, max_c = shape['bbox']\n        initial_bbox = shape['bbox'] # Keep a reference\n\n        # 4a. Calculate the extended bounding box\n        ext_min_r, ext_max_r = min_r, max_r\n        ext_min_c, ext_max_c = min_c, max_c\n\n        for m_r, m_c in magenta_markers:\n            # Check horizontal alignment (marker row within shape's initial row span)\n            if min_r <= m_r <= max_r:\n                # Marker is to the right of the initial bbox\n                if m_c > max_c:\n                    # Extend right edge up to one pixel before the marker\n                    ext_max_c = max(ext_max_c, m_c - 1)\n                # Marker is to the left of the initial bbox\n                elif m_c < min_c:\n                    # Extend left edge up to one pixel after the marker\n                    ext_min_c = min(ext_min_c, m_c + 1)\n\n            # Check vertical alignment (marker col within shape's initial col span)\n            elif min_c <= m_c <= max_c:\n                 # Marker is below the initial bbox\n                if m_r > max_r:\n                    # Extend bottom edge up to one pixel before the marker\n                    ext_max_r = max(ext_max_r, m_r - 1)\n                # Marker is above the initial bbox\n                elif m_r < min_r:\n                    # Extend top edge up to one pixel after the marker\n                    ext_min_r = min(ext_min_r, m_r + 1)\n\n        # Clamp extended bounds to grid limits (important edge case)\n        ext_min_r = max(0, ext_min_r)\n        ext_max_r = min(rows - 1, ext_max_r)\n        ext_min_c = max(0, ext_min_c)\n        ext_max_c = min(cols - 1, ext_max_c)\n        \n        # Store the calculated final extended bounding box for this shape\n        extended_bbox = (ext_min_r, ext_max_r, ext_min_c, ext_max_c)\n\n        # 4b. Iterate through pixels within the extended bounding box\n        for r in range(ext_min_r, ext_max_r + 1):\n            for c in range(ext_min_c, ext_max_c + 1):\n                # 4c. Apply fill logic\n                \n                # i. Check if it's a magenta marker (already handled by initial copy)\n                if (r, c) in magenta_marker_set:\n                    continue # Skip, preserve marker\n\n                # ii. Check if it's an internal white \"hole\" within the initial bbox\n                is_within_initial_bbox = (initial_bbox[0] <= r <= initial_bbox[1] and\n                                          initial_bbox[2] <= c <= initial_bbox[3])\n                is_input_white = (input_grid[r, c] == 0)\n\n                if is_within_initial_bbox and is_input_white:\n                    continue # Skip, preserve internal white hole\n\n                # iii. Otherwise, fill with green\n                output_grid[r, c] = 3\n\n    # 5. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13651,
    "candidates_token_count": 2055,
    "total_token_count": 15706,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.101602,
  "retries": null
}