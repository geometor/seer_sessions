{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies whether the input grid has horizontal (top/bottom) or vertical (left/right) single-pixel thick borders of uniform, non-white, distinct colors.\nIf borders are found, iterates through the inner grid (excluding borders) looking for blue pixels (color 1).\nFor each blue pixel, it determines the closest border (top vs. bottom, or left vs. right).\nIt then checks the orthogonally adjacent white pixel (color 0) located in the direction of the closest border.\nIf such a white pixel exists, is within the inner grid boundaries, and is white, it is repainted with the color of the closest border.\nThe original blue pixels and the border pixels remain unchanged.\nIf no valid borders are identified, the original grid is returned.\nPixels exactly equidistant from both borders do not trigger any painting (based on observed examples).\n\"\"\"\n\ndef is_uniform_and_non_white(arr):\n    \"\"\"Checks if a 1D numpy array is uniform (all elements same) and not color 0 (white).\"\"\"\n    if arr.size == 0:\n        return False, -1 # Cannot be uniform if empty\n    first_val = arr[0]\n    if first_val == 0: # Check if the color is white\n        return False, -1\n    # Check if all elements are the same as the first element\n    is_uniform = np.all(arr == first_val)\n    return is_uniform, first_val\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the border-proximity-based color transformation to white pixels adjacent to blue pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n\n    border_type = None\n    color1 = -1 # Will store top or left color\n    color2 = -1 # Will store bottom or right color\n\n    # --- 1. Identify Borders ---\n    # Check for horizontal borders (top and bottom rows)\n    if height >= 3: # Need at least 3 rows for top border, inner row, bottom border\n        top_row = input_np[0, :]\n        bottom_row = input_np[height - 1, :]\n        top_uniform, top_color = is_uniform_and_non_white(top_row)\n        bottom_uniform, bottom_color = is_uniform_and_non_white(bottom_row)\n\n        # Check if both are uniform, non-white, and different from each other\n        if top_uniform and bottom_uniform and top_color != bottom_color:\n            border_type = 'horizontal'\n            color1 = top_color  # color_top\n            color2 = bottom_color # color_bottom\n\n    # If horizontal borders not found or not valid, check for vertical borders\n    if border_type is None and width >= 3: # Need at least 3 cols for left border, inner col, right border\n        left_col = input_np[:, 0]\n        right_col = input_np[:, width - 1]\n        left_uniform, left_color = is_uniform_and_non_white(left_col)\n        right_uniform, right_color = is_uniform_and_non_white(right_col)\n\n        # Check if both are uniform, non-white, and different from each other\n        if left_uniform and right_uniform and left_color != right_color:\n            border_type = 'vertical'\n            color1 = left_color # color_left\n            color2 = right_color # color_right\n\n    # --- 2. No Valid Borders: Return Input ---\n    if border_type is None:\n        return output_grid.tolist()\n\n    # --- 3. Apply Transformation based on Proximity ---\n    if border_type == 'horizontal':\n        color_top = color1\n        color_bottom = color2\n        # Iterate through the inner grid rows (excluding borders)\n        for r in range(1, height - 1):\n            # Iterate through all columns (borders don't affect column iteration)\n            for c in range(width):\n                # Find blue pixels (trigger pixels)\n                if input_np[r, c] == 1:\n                    # Calculate distance to borders (row index is distance from top)\n                    dist_top = r\n                    dist_bottom = (height - 1) - r\n\n                    # Check proximity and paint adjacent white pixel if applicable\n                    if dist_top < dist_bottom:\n                        # Closer to top: check pixel above\n                        target_r, target_c = r - 1, c\n                        # Ensure target is within inner grid (r-1 >= 1) and is white\n                        if target_r >= 1 and input_np[target_r, target_c] == 0:\n                            output_grid[target_r, target_c] = color_top\n                    elif dist_bottom < dist_top:\n                        # Closer to bottom: check pixel below\n                        target_r, target_c = r + 1, c\n                        # Ensure target is within inner grid (r+1 <= height-2) and is white\n                        if target_r <= height - 2 and input_np[target_r, target_c] == 0:\n                            output_grid[target_r, target_c] = color_bottom\n                    # If dist_top == dist_bottom, do nothing (based on examples)\n\n    elif border_type == 'vertical':\n        color_left = color1\n        color_right = color2\n        # Iterate through all rows (borders don't affect row iteration)\n        for r in range(height):\n            # Iterate through the inner grid columns (excluding borders)\n             for c in range(1, width - 1):\n                 # Find blue pixels (trigger pixels)\n                if input_np[r, c] == 1:\n                    # Calculate distance to borders (col index is distance from left)\n                    dist_left = c\n                    dist_right = (width - 1) - c\n\n                    # Check proximity and paint adjacent white pixel if applicable\n                    if dist_left < dist_right:\n                        # Closer to left: check pixel left\n                        target_r, target_c = r, c - 1\n                        # Ensure target is within inner grid (c-1 >= 1) and is white\n                        if target_c >= 1 and input_np[target_r, target_c] == 0:\n                            output_grid[target_r, target_c] = color_left\n                    elif dist_right < dist_left:\n                        # Closer to right: check pixel right\n                        target_r, target_c = r, c + 1\n                        # Ensure target is within inner grid (c+1 <= width-2) and is white\n                        if target_c <= width - 2 and input_np[target_r, target_c] == 0:\n                            output_grid[target_r, target_c] = color_right\n                    # If dist_left == dist_right, do nothing (based on examples)\n\n    # Convert the NumPy array back to a list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7002,
    "candidates_token_count": 1667,
    "total_token_count": 8669,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.823726,
  "retries": null
}