
## train_1

**input:**
```
2 0 0 2
2 2 2 2
2 0 0 2
0 2 0 2
```


**output:**
```
2 0 0 2 0 0 0 0 0 0 0 0 2 0 0 2
2 2 2 2 0 0 0 0 0 0 0 0 2 2 2 2
2 0 0 2 0 0 0 0 0 0 0 0 2 0 0 2
0 2 0 2 0 0 0 0 0 0 0 0 0 2 0 2
2 0 0 2 2 0 0 2 2 0 0 2 2 0 0 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 0 0 2 2 0 0 2 2 0 0 2 2 0 0 2
0 2 0 2 0 2 0 2 0 2 0 2 0 2 0 2
2 0 0 2 0 0 0 0 0 0 0 0 2 0 0 2
2 2 2 2 0 0 0 0 0 0 0 0 2 2 2 2
2 0 0 2 0 0 0 0 0 0 0 0 2 0 0 2
0 2 0 2 0 0 0 0 0 0 0 0 0 2 0 2
0 0 0 0 2 0 0 2 0 0 0 0 2 0 0 2
0 0 0 0 2 2 2 2 0 0 0 0 2 2 2 2
0 0 0 0 2 0 0 2 0 0 0 0 2 0 0 2
0 0 0 0 0 2 0 2 0 0 0 0 0 2 0 2
```


## train_2

**input:**
```
0 0 0 1
0 1 1 0
0 0 0 0
0 0 0 1
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0
0 0 0 0 0 1 1 0 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
```


## train_3

**input:**
```
0 0 0 0
4 4 4 4
0 4 4 0
4 4 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 4 4 0 0 4 4 0 0 4 4 0 0 4 4 0
4 4 0 0 4 4 0 0 4 4 0 0 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 0 0 4 4 0 0 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 0 0 0 0 0 0 0 0
0 4 4 0 0 4 4 0 0 0 0 0 0 0 0 0
4 4 0 0 4 4 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
3 3 0 3
3 0 0 3
0 0 0 3
3 3 0 3
```


**output:**
```
3 3 0 3 3 3 0 3 0 0 0 0 3 3 0 3
3 0 0 3 3 0 0 3 0 0 0 0 3 0 0 3
0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 3
3 3 0 3 3 3 0 3 0 0 0 0 3 3 0 3
3 3 0 3 0 0 0 0 0 0 0 0 3 3 0 3
3 0 0 3 0 0 0 0 0 0 0 0 3 0 0 3
0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 3
3 3 0 3 0 0 0 0 0 0 0 0 3 3 0 3
0 0 0 0 0 0 0 0 0 0 0 0 3 3 0 3
0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 3 3 0 3
3 3 0 3 3 3 0 3 0 0 0 0 3 3 0 3
3 0 0 3 3 0 0 3 0 0 0 0 3 0 0 3
0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 3
3 3 0 3 3 3 0 3 0 0 0 0 3 3 0 3
```


## train_5

**input:**
```
1 0 1 0
1 1 0 0
1 1 1 1
1 0 0 1
```


**output:**
```
1 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0
1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0
1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0
1 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0
1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0
1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0
1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0
1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1
```

*   **Perception:**
    *   The task transforms a small input grid (4x4 in all examples) into a larger output grid (16x16 in all examples).
    *   The output grid's dimensions appear to be related to the input grid's dimensions: `output_height = input_height * input_height` and `output_width = input_width * input_width`. In the examples, 16 = 4 * 4.
    *   The output grid is constructed by tiling smaller subgrids. The number of subgrids tiled horizontally is equal to the input grid's width, and the number tiled vertically is equal to the input grid's height. So, there is an `input_height` x `input_width` arrangement of subgrids.
    *   Each subgrid has the same dimensions as the original input grid (4x4 in the examples).
    *   The content of each subgrid in the output depends on the color of the corresponding pixel in the input grid.
    *   If an input pixel at `(r, c)` is white (0), the corresponding subgrid in the output (at tile position `(r, c)`) is entirely white.
    *   If an input pixel at `(r, c)` is *not* white (any color other than 0), the corresponding subgrid in the output is an identical copy of the *entire* original input grid.

*   **Facts YAML:**
    
```yaml
    task_type: grid_transformation
    input_grid_size: H x W (examples: 4x4)
    output_grid_size: (H*H) x (W*W) (examples: 16x16)
    background_color: 0 (white)
    transformation: tiling
    tiling_structure:
      grid_layout: H x W (based on input dimensions)
      subgrid_size: H x W (same as input dimensions)
    subgrid_determination_rule:
      based_on: corresponding pixel in input grid at position (r, c)
      condition_1:
        input_pixel_value: 0 (white)
        output_subgrid_content: H x W grid filled with white (0)
      condition_2:
        input_pixel_value: non-zero (any other color)
        output_subgrid_content: copy of the original input grid
    ```


*   **Natural Language Program:**
    1.  Let `input_grid` be the input grid with height `H` and width `W`.
    2.  Calculate the output grid dimensions: `output_height = H * H`, `output_width = W * W`.
    3.  Create an empty `output_grid` of size `output_height` x `output_width`.
    4.  Create a template `white_subgrid` of size `H` x `W`, filled entirely with the white color (0).
    5.  Iterate through each row `r` from 0 to `H-1` and each column `c` from 0 to `W-1` of the `input_grid`.
    6.  For the pixel `input_grid[r][c]`:
        a.  Determine the `subgrid_to_place`.
        b.  If `input_grid[r][c]` is white (0), set `subgrid_to_place` to `white_subgrid`.
        c.  If `input_grid[r][c]` is not white (non-zero), set `subgrid_to_place` to a copy of the `input_grid`.
        d.  Calculate the starting coordinates in the `output_grid` for this subgrid: `start_row = r * H`, `start_col = c * W`.
        e.  Copy the contents of `subgrid_to_place` into the `output_grid` region defined by rows `start_row` to `start_row + H - 1` and columns `start_col` to `start_col + W - 1`.
    7.  Return the `output_grid`.
