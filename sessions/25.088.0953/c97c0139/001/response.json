{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom math import floor, ceil\nfrom collections import deque\n\n\"\"\"\nThis module transforms an input grid based on the following rules:\n\n1.  Identifies all distinct connected components of red pixels (color 2) in the input grid. These components are assumed to be lines (horizontal or vertical).\n2.  For each identified red line object:\n    a. Calculates its length (L), which is the number of pixels in the line (or its maximum dimension).\n    b. Calculates a radius value K = floor((L - 1) / 2).\n    c. Determines the geometric center (center_r, center_c) of the line. If the average coordinate along the line's dimension is halfway between two integers (e.g., 8.5), it rounds up to the next integer (e.g., 9).\n    d. Generates a diamond shape centered at (center_r, center_c) with radius K. The diamond includes all pixels (r, c) such that the Manhattan distance |r - center_r| + |c - center_c| <= K.\n3.  Initializes the output grid as a copy of the input grid.\n4.  For each generated diamond, iterates through its pixels. If a pixel within the diamond's bounds corresponds to a white pixel (color 0) in the current output grid state, that pixel's color is changed to azure (color 8). Red pixels and pixels already changed to azure remain unchanged.\n5.  The final modified grid is returned as the output.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a specified color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[list[tuple[int, int]]]: A list where each element is a list\n                                     of (row, col) coordinates for one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start BFS to find a connected component\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component.append((curr_r, curr_c))\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds and if it's the target color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if component:\n                    objects.append(component)\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding red lines and drawing azure diamonds\n    around their centers based on their length.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid represented as a list of lists.\n                         Or None if input is invalid.\n    \"\"\"\n    if not input_grid or not isinstance(input_grid, list) or not isinstance(input_grid[0], list):\n        print(\"Invalid input grid format.\")\n        return None\n        \n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = output_grid.shape\n    \n    # 1. Find all red objects (lines)\n    red_objects = find_objects(input_np, 2) # 2 is red\n\n    # 2. Process each red object\n    for obj_coords in red_objects:\n        if not obj_coords:\n            continue\n\n        # a. Calculate length L\n        obj_length = len(obj_coords)\n        \n        # b. Calculate radius K\n        radius_k = floor((obj_length - 1) / 2)\n\n        # c. Calculate center (center_r, center_c)\n        # Find min/max row and column for the object\n        min_r = min(r for r, c in obj_coords)\n        max_r = max(r for r, c in obj_coords)\n        min_c = min(c for r, c in obj_coords)\n        max_c = max(c for r, c in obj_coords)\n\n        # Calculate average coordinates and round up (.5 case handled by ceil)\n        # Use integer conversion after ceiling\n        center_r = int(ceil((min_r + max_r) / 2))\n        center_c = int(ceil((min_c + max_c) / 2))\n\n        # d. & 4. Draw the azure diamond, modifying only white pixels\n        # Iterate potential diamond coordinates based on radius K\n        for r_offset in range(-radius_k, radius_k + 1):\n            for c_offset in range(-radius_k, radius_k + 1):\n                r, c = center_r + r_offset, center_c + c_offset\n                \n                # Calculate Manhattan distance\n                dist = abs(r - center_r) + abs(c - center_c)\n\n                # Check if within diamond radius and grid bounds\n                if dist <= radius_k and 0 <= r < rows and 0 <= c < cols:\n                    # Modify only if the pixel is currently white (0)\n                    if output_grid[r, c] == 0:\n                        output_grid[r, c] = 8 # 8 is azure\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5402,
    "candidates_token_count": 1429,
    "total_token_count": 6831,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.357736,
  "retries": null
}