{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRecolor blue (1) objects based on the shape of the spatially closest orange (7) object, then remove the orange objects.\n\nThe transformation rule involves the following steps:\n1. Identify all distinct contiguous objects composed of blue (1) pixels and orange (7) pixels in the input grid.\n2. For each orange object, determine its unique shape. The shape is defined as the pattern of orange pixels within the object's minimal bounding box, represented as a tuple of tuples.\n3. Establish a mapping between these specific orange object shapes and target output colors:\n    - Shape ((0, 7), (7, 7)) maps to Green (3).\n    - Shape ((7, 7), (7, 0)) maps to Magenta (6).\n    - Shape ((7, 7), (0, 7)) maps to Yellow (4).\n    - Shape ((7, 0), (7, 7)) maps to Azure (8).\n4. For each blue object:\n    a. Calculate the minimum Manhattan distance to every orange object. The distance is measured between any pixel of the blue object and any pixel of the orange object.\n    b. Identify the orange object that is closest to the blue object.\n    c. Retrieve the shape of this closest orange object.\n    d. Use the shape-to-color mapping to determine the target output color for the blue object.\n5. Create an output grid initialized with the background color (white, 0).\n6. For each blue object, color its corresponding pixels in the output grid with its determined target output color. Orange objects are not drawn in the output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is represented as a set of\n              (row, col) coordinate tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4-directional neighbors (ARC standard for contiguity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                objects.append(obj_coords)\n    return objects\n\ndef get_object_shape(grid, obj_coords):\n    \"\"\"\n    Calculates the shape of an object based on its pixels within its minimal bounding box.\n\n    Args:\n        grid (np.array): The input grid (needed for color values).\n        obj_coords (set): A set of (row, col) coordinates for the object.\n\n    Returns:\n        tuple: A tuple of tuples representing the object's shape within its\n               bounding box, including background pixels within the box.\n               Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    # Use object's color, not just 7, in case this is reused\n    obj_color = grid[min_r, min_c] if (min_r, min_c) in obj_coords else grid[list(obj_coords)[0]]\n\n\n    shape_grid = np.zeros((height, width), dtype=int)\n\n    for r, c in obj_coords:\n        shape_grid[r - min_r, c - min_c] = grid[r,c] # Use actual color\n\n    # Convert to tuple of tuples for hashing\n    return tuple(map(tuple, shape_grid))\n\ndef min_manhattan_distance(obj1_coords, obj2_coords):\n    \"\"\"\n    Calculates the minimum Manhattan distance between two objects.\n\n    Args:\n        obj1_coords (set): Set of (row, col) coordinates for object 1.\n        obj2_coords (set): Set of (row, col) coordinates for object 2.\n\n    Returns:\n        int: The minimum Manhattan distance between any pixel in obj1 and\n             any pixel in obj2. Returns infinity if either object is empty.\n    \"\"\"\n    if not obj1_coords or not obj2_coords:\n        return float('inf')\n\n    min_dist = float('inf')\n    for r1, c1 in obj1_coords:\n        for r2, c2 in obj2_coords:\n            dist = abs(r1 - r2) + abs(c1 - c2)\n            min_dist = min(min_dist, dist)\n    return min_dist\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    output_grid = np.zeros_like(input_grid_np) # Initialize with background color 0\n\n    # 1. Find blue and orange objects\n    blue_objects = find_objects(input_grid_np, 1)\n    orange_objects = find_objects(input_grid_np, 7)\n\n    if not blue_objects or not orange_objects:\n        return output_grid.tolist() # Return background if no blue or no orange objects\n\n    # 2. Precompute shapes for orange objects\n    orange_shapes = [get_object_shape(input_grid_np, obj_coords) for obj_coords in orange_objects]\n\n    # 3. Define the shape-to-color mapping\n    SHAPE_COLOR_MAP = {\n        ((0, 7), (7, 7)): 3,  # Green\n        ((7, 7), (7, 0)): 6,  # Magenta\n        ((7, 7), (0, 7)): 4,  # Yellow\n        ((7, 0), (7, 7)): 8,  # Azure\n    }\n\n    # 4. Process each blue object\n    for blue_coords in blue_objects:\n        min_dist = float('inf')\n        closest_orange_idx = -1\n\n        # 4a. Calculate minimum distances to all orange objects\n        for idx, orange_coords in enumerate(orange_objects):\n            dist = min_manhattan_distance(blue_coords, orange_coords)\n            if dist < min_dist:\n                min_dist = dist\n                closest_orange_idx = idx\n            # Tie-breaking: Implicitly picks the first one found in the list\n            # (consistent iteration order should handle this deterministically)\n\n        if closest_orange_idx != -1:\n            # 4c. Get the shape of the closest orange object\n            closest_orange_shape = orange_shapes[closest_orange_idx]\n\n            # 4d. Determine output color from shape\n            output_color = SHAPE_COLOR_MAP.get(closest_orange_shape)\n\n            # 6. Color the blue object's pixels in the output grid\n            if output_color is not None:\n                for r, c in blue_coords:\n                    output_grid[r, c] = output_color\n            # else: handle case where shape is not in map (optional: error or default color)\n            # Based on training examples, all shapes should be in the map.\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4765,
    "candidates_token_count": 1984,
    "total_token_count": 6749,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 68.81074,
  "retries": null
}