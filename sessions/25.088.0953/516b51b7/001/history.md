
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 2 2 1 0 0 1 2 1 0
0 1 2 2 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 3 2 2 3 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 2 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 3 3 3 2 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```

**Perception:**

The input grids consist of a white background (color 0) with one or more solid rectangular objects composed of blue pixels (color 1). The output grids modify the interior of these blue rectangles, leaving the white background unchanged. The blue pixels are replaced with colors blue (1), red (2), and green (3) forming concentric layers or contours within the original rectangle shapes. The outermost layer of the original blue rectangle remains blue. Moving inwards, the color typically changes to red, then green, then potentially back to red, suggesting a pattern related to the distance from the edge (the surrounding white background).

**Facts:**


```yaml
Input Grid:
  - Background: White pixels (0).
  - Objects:
    - Type: Solid rectangles.
    - Composition: Blue pixels (1).
    - Count: One or more per grid.
    - Properties: Defined by their position, width, and height.
Transformation:
  - Target: Blue pixels (1) within the input grid.
  - Action: Recolor blue pixels based on their spatial relationship to the background.
  - Rule:
    - Identify all blue pixels (1) in the input.
    - For each blue pixel, calculate its minimum Chebyshev distance 'd' to the nearest non-blue (white, 0) pixel. (Chebyshev distance considers orthogonal and diagonal neighbors as distance 1).
    - Assign a new color to the pixel in the output grid based on the calculated distance 'd'.
    - The color mapping follows a cyclical pattern:
      - If d = 1, color = 1 (blue).
      - If d = 2, color = 2 (red).
      - If d = 3, color = 3 (green).
      - If d = 4, color = 2 (red).
      - This pattern repeats every 4 steps: [1, 2, 3, 2]. The color for distance 'd' is given by the element at index `(d-1) % 4` in the sequence [1, 2, 3, 2].
  - Invariant: Non-blue pixels (white background) remain unchanged in the output grid.
Output Grid:
  - Background: Identical to input background (white, 0).
  - Objects: Original blue rectangles are now filled with layered colors (1, 2, 3) according to the distance-based rule. The outermost layer remains blue (1).
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Create a list of coordinates for all non-blue (value 0) pixels in the input grid. These represent the boundary or background points.
3.  Iterate through each pixel `(r, c)` of the input grid.
4.  If the pixel `input[r][c]` is blue (value 1):
    a.  Calculate the minimum Chebyshev distance `d` from `(r, c)` to any of the non-blue pixel coordinates identified in step 2. The Chebyshev distance between `(r1, c1)` and `(r2, c2)` is `max(abs(r1 - r2), abs(c1 - c2))`.
    b.  Determine the new color based on the distance `d` using the repeating sequence `[1, 2, 3, 2]`. The color is the value at index `(d - 1) % 4` in this sequence (0-based index).
    c.  Set the corresponding pixel `output[r][c]` to this calculated color.
5.  If the pixel `input[r][c]` is not blue (value 0), keep its value unchanged in the output grid (already handled by initializing output as a copy).
6.  Return the final output grid.
