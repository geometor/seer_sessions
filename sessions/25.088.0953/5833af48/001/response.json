{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on identifying two main regions: a large, solid-colored rectangular 'canvas' and a 'stamps' area containing other non-white patterns. The transformation involves:\n1. Identifying the largest contiguous rectangular area of a single non-white color (the 'Canvas Area'). Determine its color ('Canvas Color') and dimensions.\n2. Identifying all other non-white pixels in the input grid that are *not* part of the Canvas Area. These constitute the 'Stamps Area'.\n3. Determining the bounding box of the Stamps Area.\n4. Creating an output grid with the dimensions of the Canvas Area, filled entirely with the Canvas Color.\n5. Iterating through the cells within the bounding box of the Stamps Area in the input grid.\n6. For each cell within the Stamps Area bounding box:\n    a. If the input cell's color is non-white (not 0) AND it's not part of the identified Canvas Area rectangle:\n        i. Calculate the cell's relative row and column position within the Stamps Area bounding box (relative to its top-left corner).\n        ii. If these relative coordinates fall within the bounds of the output grid:\n            - Set the corresponding cell in the output grid to azure (8).\n7. Return the modified output grid.\n\"\"\"\n\ndef find_largest_monochromatic_rect(grid):\n    \"\"\"\n    Finds the largest contiguous rectangular area of a single non-white color.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict: A dictionary containing the 'r', 'c', 'h', 'w', and 'color'\n              of the largest rectangle, or None if no non-white pixels exist.\n    \"\"\"\n    rows, cols = grid.shape\n    max_area = 0\n    best_rect = None\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color == 0:  # Skip white background\n                continue\n\n            # Check for largest possible rectangle starting at (r, c) with this color\n            max_w = cols - c\n            for h in range(1, rows - r + 1):\n                current_w = max_w\n                for w in range(1, max_w + 1):\n                    # Check if the rectangle (r, c) to (r+h-1, c+w-1) is monochromatic\n                    is_monochromatic = True\n                    # Check the new row/column being added\n                    if w == current_w: # check new row only\n                        for check_c in range(c, c + w):\n                             if grid[r + h - 1, check_c] != color:\n                                is_monochromatic = False\n                                break\n                    if h==1: # check new column only if it's the first row check\n                        if grid[r + h - 1, c + w - 1] != color:\n                                is_monochromatic = False\n\n                    # More thorough check if needed (though optimized checks above should suffice)\n                    # This simplified check might be faster if assumptions hold\n                    # Check the bottom row of the potential rectangle expansion\n                    if h > 1:\n                         for check_c in range(c, c + w):\n                             if grid[r + h - 1, check_c] != color:\n                                 is_monochromatic = False\n                                 current_w = w -1 # Max width possible for this height\n                                 break\n                         if not is_monochromatic: break # Stop increasing width for this height\n\n                    # Check the rightmost column of the potential rectangle expansion\n                    if is_monochromatic and w > 1:\n                         for check_r in range(r, r + h):\n                              if grid[check_r, c + w - 1] != color:\n                                  is_monochromatic = False\n                                  break # stop checking width\n                         if not is_monochromatic:\n                             current_w = w - 1 # update max width\n                             break # Stop increasing width for this height\n\n\n                    if not is_monochromatic:\n                         break # Stop increasing width for this height\n\n\n                    # Update best rectangle if this one is larger\n                    area = h * w\n                    if area > max_area:\n                        max_area = area\n                        best_rect = {'r': r, 'c': c, 'h': h, 'w': w, 'color': color}\n                max_w = current_w # Update the max width possible for next height iteration\n\n    return best_rect\n\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a list of pixel coordinates.\n\n    Args:\n        pixels (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation described above to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify the Canvas Area\n    canvas_info = find_largest_monochromatic_rect(grid)\n    if canvas_info is None:\n        # Handle case with no non-white pixels or only stamps?\n        # Based on examples, there's always a canvas. Assume it exists.\n        # If it could be missing, we'd need different logic.\n        # For now, assume it's found. If not, maybe return empty or original?\n        # Let's assume it's always found based on training data.\n         return [] # Or raise error, depends on spec for invalid input\n\n    canvas_r, canvas_c = canvas_info['r'], canvas_info['c']\n    canvas_h, canvas_w = canvas_info['h'], canvas_info['w']\n    canvas_color = canvas_info['color']\n\n    # 4. Create the initial output grid\n    output_grid = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n\n    # 2. Identify Stamps Area pixels\n    stamp_pixels_coords = []\n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is non-white\n            if grid[r, c] != 0:\n                # Check if pixel is outside the canvas rectangle bounds\n                is_outside_canvas = not (\n                    canvas_r <= r < canvas_r + canvas_h and\n                    canvas_c <= c < canvas_c + canvas_w\n                )\n                if is_outside_canvas:\n                    stamp_pixels_coords.append((r, c))\n\n    # If there are no stamp pixels, return the canvas as is\n    if not stamp_pixels_coords:\n        return output_grid.tolist()\n\n    # 3. Determine the bounding box of the Stamps Area\n    stamp_box = get_bounding_box(stamp_pixels_coords)\n    if stamp_box is None: # Should not happen if stamp_pixels_coords is not empty\n         return output_grid.tolist()\n\n    min_r_stamp, min_c_stamp, max_r_stamp, max_c_stamp = stamp_box\n\n    # 5. & 6. Iterate through the Stamps Area bounding box and transfer patterns\n    for r in range(min_r_stamp, max_r_stamp + 1):\n        for c in range(min_c_stamp, max_c_stamp + 1):\n            # Check if the pixel is within the original grid bounds (might not be if box extends)\n            if 0 <= r < rows and 0 <= c < cols:\n                 input_color = grid[r, c]\n                 # Check if it's a non-white pixel AND truly part of the stamps (not canvas)\n                 is_stamp_pixel = (\n                     input_color != 0 and\n                     not (canvas_r <= r < canvas_r + canvas_h and canvas_c <= c < canvas_c + canvas_w)\n                 )\n\n                 if is_stamp_pixel:\n                    # Calculate relative position within the stamp bounding box\n                    rel_r = r - min_r_stamp\n                    rel_c = c - min_c_stamp\n\n                    # Check if relative position is within the output grid bounds\n                    if 0 <= rel_r < output_grid.shape[0] and 0 <= rel_c < output_grid.shape[1]:\n                        # Set the output pixel to azure (8)\n                        output_grid[rel_r, rel_c] = 8\n\n    # 7. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4505,
    "candidates_token_count": 2085,
    "total_token_count": 6590,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.111026,
  "retries": null
}