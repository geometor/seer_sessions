{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the largest contiguous rectangular area of a single non-white color (the 'Canvas Area').\n2. Creating an output grid with the dimensions and background color of the Canvas Area.\n3. Identifying all Azure (8) colored pixels in the input grid that lie *outside* the Canvas Area ('Azure Stamps').\n4. Determining the bounding box of these Azure Stamps.\n5. Copying the pattern of Azure Stamps, relative to their bounding box's top-left corner, onto the output grid, replacing the background color with Azure (8) at the corresponding relative positions, provided these positions fall within the output grid's bounds.\n\"\"\"\n\ndef find_largest_monochromatic_rect(grid):\n    \"\"\"\n    Finds the largest contiguous rectangular area of a single non-white color.\n    Uses a dynamic programming approach for potentially better efficiency.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict: A dictionary containing the 'r', 'c', 'h', 'w', and 'color'\n              of the largest rectangle, or None if no non-white pixels exist.\n    \"\"\"\n    rows, cols = grid.shape\n    max_area = 0\n    best_rect = None\n\n    # Precompute heights of consecutive same-colored cells above each cell\n    heights = np.zeros_like(grid, dtype=int)\n    colors = np.full_like(grid, -1, dtype=int) # Store color associated with height\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0: # Consider only non-white cells\n                if r > 0 and grid[r, c] == grid[r-1, c]:\n                    heights[r, c] = heights[r-1, c] + 1\n                    colors[r,c] = colors[r-1, c] # Propagate color\n                else:\n                    heights[r, c] = 1\n                    colors[r, c] = grid[r,c] # Start new color streak\n            # else: height remains 0, color remains -1\n\n    # Find largest rectangle in histogram for each row\n    for r in range(rows):\n        stack = [] # Stores indices (index, height, color)\n        for c in range(cols + 1): # Iterate one past the end to flush stack\n            h = heights[r, c] if c < cols else 0\n            color = colors[r,c] if c < cols else -1\n\n            current_pos = c\n            while stack and (stack[-1][1] > h or (stack[-1][1] == h and stack[-1][2] != color) or (stack[-1][2] != color and color != -1 and h > 0)):\n                 # Pop when height decreases OR color changes\n                 # The condition `(stack[-1][2] != color and color != -1 and h > 0)` handles cases\n                 # where the current column starts a new color streak even if height is maintained or increased\n                prev_c, prev_h, prev_color = stack.pop()\n                width = c - stack[-1][0] -1 if stack else c\n                area = prev_h * width\n\n                if prev_color != -1 and area > max_area : # Ensure it's a valid color block\n                    max_area = area\n                    best_rect = {'r': r - prev_h + 1, 'c': stack[-1][0] + 1 if stack else 0,\n                                 'h': prev_h, 'w': width, 'color': prev_color}\n                current_pos = prev_c # Extend back width calculation start point\n\n            # Only push if height > 0 and color is valid\n            if h > 0 and color != -1:\n                 # check if stack top has same height and color, if so, don't push\n                 # this can happen if width extends and color remains same\n                 if not stack or stack[-1][1] != h or stack[-1][2] != color :\n                    stack.append((current_pos, h, color))\n            elif not stack or stack[-1][1] != 0: # push a 0 height marker if needed\n                 stack.append((c,0, -1)) # Push current index with 0 height marker\n\n\n    # Fallback: if DP fails (e.g., edge cases), use a simple scan\n    # This part might be redundant if DP is correct, but acts as safety\n    if best_rect is None:\n         non_white_pixels = np.argwhere(grid != 0)\n         if len(non_white_pixels) > 0:\n              # Find the most frequent non-white color\n              colors, counts = np.unique(grid[grid != 0], return_counts=True)\n              major_color = colors[np.argmax(counts)]\n              # Find bounding box of the major color\n              major_pixels = np.argwhere(grid == major_color)\n              if len(major_pixels) > 0:\n                   min_r = np.min(major_pixels[:, 0])\n                   max_r = np.max(major_pixels[:, 0])\n                   min_c = np.min(major_pixels[:, 1])\n                   max_c = np.max(major_pixels[:, 1])\n                   # Assume it's rectangular for simplicity fallback\n                   best_rect = {'r': min_r, 'c': min_c, 'h': max_r - min_r + 1, 'w': max_c - min_c + 1, 'color': major_color}\n\n\n    # Final fallback: if still None, pick the first non-zero pixel's 1x1 rect\n    if best_rect is None:\n        non_white_coords = np.argwhere(grid != 0)\n        if len(non_white_coords) > 0:\n             first_r, first_c = non_white_coords[0]\n             best_rect = {'r': first_r, 'c': first_c, 'h': 1, 'w': 1, 'color': grid[first_r, first_c]}\n\n    return best_rect\n\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a list of pixel coordinates.\n\n    Args:\n        pixels (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation based on Hypothesis 6.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    azure_color = 8\n\n    # 1. Identify the Canvas Area\n    # Using the more robust histogram method\n    canvas_info = find_largest_monochromatic_rect(grid)\n\n    if canvas_info is None:\n        # Cannot proceed without a canvas, return empty or original?\n        # Based on ARC tasks, a canvas is expected. Let's return empty for invalid state.\n        return []\n\n    canvas_r, canvas_c = canvas_info['r'], canvas_info['c']\n    canvas_h, canvas_w = canvas_info['h'], canvas_info['w']\n    canvas_color = canvas_info['color']\n\n    # 2. Create the initial output grid\n    output_grid = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n\n    # 3. Identify Azure Stamp pixels outside the canvas\n    azure_stamp_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == azure_color:\n                # Check if pixel is outside the canvas rectangle bounds\n                is_outside_canvas = not (\n                    canvas_r <= r < canvas_r + canvas_h and\n                    canvas_c <= c < canvas_c + canvas_w\n                )\n                if is_outside_canvas:\n                    azure_stamp_pixels.append((r, c))\n\n    # 4. Handle No Stamps: If no Azure stamps found, return the canvas as is\n    if not azure_stamp_pixels:\n        return output_grid.tolist()\n\n    # 5. Determine the bounding box of the Azure Stamps\n    stamp_box = get_bounding_box(azure_stamp_pixels)\n    # This check should be redundant because we checked azure_stamp_pixels is not empty\n    # if stamp_box is None:\n    #     return output_grid.tolist()\n    stamp_min_r, stamp_min_c, _, _ = stamp_box # We only need the top-left corner\n\n    # 6. Map Azure Stamps to Output Grid\n    for r_stamp, c_stamp in azure_stamp_pixels:\n        # a. Calculate relative position within the stamp bounding box\n        rel_r = r_stamp - stamp_min_r\n        rel_c = c_stamp - stamp_min_c\n\n        # b. Check if relative position is within the output grid bounds\n        if 0 <= rel_r < canvas_h and 0 <= rel_c < canvas_w:\n            # c. Set the output pixel to azure (8)\n            output_grid[rel_r, rel_c] = azure_color\n\n    # 7. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14462,
    "candidates_token_count": 2287,
    "total_token_count": 16749,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.799466,
  "retries": null
}