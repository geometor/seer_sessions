{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Optional, Set\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the largest contiguous rectangular area of a single non-white color (the 'Canvas').\n2. Determining the minimal bounding box enclosing all azure (8) pixels in the input grid (the 'Stamp Area').\n3. Extracting the pattern of azure pixels within the Stamp Area, maintaining their relative positions.\n4. Creating an output grid with the dimensions and background color of the Canvas.\n5. Overlaying the extracted Azure Pattern onto the output grid, aligning the top-left of the pattern with the top-left of the output grid. Azure pixels from the pattern overwrite the canvas background color within the output grid bounds.\n\"\"\"\n\ndef find_largest_solid_rectangle(grid: np.ndarray) -> Optional[Dict[str, int]]:\n    \"\"\"\n    Finds the largest solid (monochromatic, non-white) rectangular area in the grid.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A dictionary {'r', 'c', 'h', 'w', 'color'} for the largest rectangle,\n        or None if no non-white pixels exist.\n    \"\"\"\n    rows, cols = grid.shape\n    max_area = 0\n    best_rect = None\n\n    # heights[c] stores the continuous height of the current color ending at row r, column c\n    # colors[c] stores the color corresponding to that height\n    heights = np.zeros(cols, dtype=int)\n    colors = np.zeros(cols, dtype=int) # 0 can represent background or uninit\n\n    for r in range(rows):\n        # Update heights and colors for the current row\n        for c in range(cols):\n            if grid[r, c] != 0:  # Non-white pixel\n                if r > 0 and grid[r, c] == grid[r - 1, c]:\n                    heights[c] += 1\n                    # Color remains the same as above, no need to update colors[c] if it tracks the streak\n                else:\n                    heights[c] = 1\n                    colors[c] = grid[r, c] # Start new streak\n            else:\n                heights[c] = 0\n                colors[c] = 0 # Reset color for white pixel\n\n        # Calculate largest rectangle ending at this row using histogram method\n        stack = [] # Stores tuples of (index, height, color)\n        for c in range(cols + 1): # Iterate one past the end to flush the stack\n            h = heights[c] if c < cols else 0\n            color = colors[c] if c < cols else 0 # Use 0 for flush condition\n\n            start_index = c\n            while stack and (stack[-1][1] > h or (stack[-1][1] == h and stack[-1][2] != color and color != 0) or (stack[-1][2] != color and h > 0)):\n                 # Pop when:\n                 # 1. Height decreases.\n                 # 2. Height is same but color changes (and new color isn't background 0)\n                 # 3. Color changes (and current height is > 0, meaning a new block starts)\n\n                prev_c_idx, prev_h, prev_color = stack.pop()\n                width = c - (stack[-1][0] + 1 if stack else 0)\n                area = prev_h * width\n\n                # Check if popped rectangle is valid (non-zero color) and largest so far\n                if prev_color != 0 and area > max_area:\n                    max_area = area\n                    best_rect = {\n                        'r': r - prev_h + 1,\n                        'c': stack[-1][0] + 1 if stack else 0,\n                        'h': prev_h,\n                        'w': width,\n                        'color': prev_color\n                    }\n                # This start_index adjustment is tricky, let's simplify:\n                # The width calculation uses the index before the popped element in the stack.\n                # When pushing, we need the index from where the current height/color starts.\n                # Let's recalculate start_index based on stack top *after* popping.\n                start_index = prev_c_idx # Correct starting pos for potential push\n\n            # Push current bar onto stack if it's not height 0\n            # or if it's different from stack top\n            if c < cols and h > 0 :\n                 # Only push if stack is empty or this bar is different\n                 # (in index, height, or color) from the top\n                 if not stack or stack[-1][1] != h or stack[-1][2] != color:\n                     stack.append((start_index, h, color))\n            elif c < cols and h == 0 and (not stack or stack[-1][1] != 0):\n                 # Push a height 0 marker if needed to separate blocks\n                 stack.append((c, 0, 0))\n\n\n    # Fallback if algorithm fails or grid is simple\n    if best_rect is None:\n        non_white_coords = np.argwhere(grid != 0)\n        if len(non_white_coords) > 0:\n             first_r, first_c = non_white_coords[0]\n             best_rect = {'r': first_r, 'c': first_c, 'h': 1, 'w': 1, 'color': grid[first_r, first_c]}\n\n    return best_rect\n\n\ndef find_pixels_of_color(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with the specified color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(pixels: List[Tuple[int, int]]) -> Optional[Dict[str, int]]:\n    \"\"\"Calculates the bounding box for a list of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return {'r': min_r, 'c': min_c, 'h': max_r - min_r + 1, 'w': max_c - min_c + 1}\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation based on Hypothesis 7.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    azure_color = 8\n    white_color = 0\n\n    # 1. Identify the Canvas\n    canvas_info = find_largest_solid_rectangle(grid)\n\n    if canvas_info is None:\n        # Cannot proceed without a canvas. Maybe return empty or input?\n        # Based on examples, a canvas is expected. Return empty for invalid state.\n        # Or maybe return a 1x1 grid of white if input was all white? Let's assume error state.\n         return [] # Or handle as per specific ARC task requirements if known\n\n    canvas_r, canvas_c = canvas_info['r'], canvas_info['c']\n    canvas_h, canvas_w = canvas_info['h'], canvas_info['w']\n    canvas_color = canvas_info['color']\n\n    # 2. Identify Azure Pixels\n    azure_pixels = find_pixels_of_color(grid, azure_color)\n\n    if not azure_pixels:\n        # No azure pixels, output is just the canvas color/size\n        output_grid = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n        return output_grid.tolist()\n\n    # 3. Determine the Stamp Area (Bounding Box of Azure Pixels)\n    stamp_area = get_bounding_box(azure_pixels)\n    # This check should be redundant because we checked azure_pixels is not empty\n    # if stamp_area is None: return np.full((canvas_h, canvas_w), canvas_color, dtype=int).tolist()\n\n    stamp_r, stamp_c = stamp_area['r'], stamp_area['c']\n    stamp_h, stamp_w = stamp_area['h'], stamp_area['w']\n\n    # 4. Extract the Azure Pattern\n    azure_pattern = np.full((stamp_h, stamp_w), white_color, dtype=int) # Use white as background for pattern\n    for r, c in azure_pixels:\n        relative_row = r - stamp_r\n        relative_col = c - stamp_c\n        # Ensure relative coords are within pattern bounds (should always be true by definition)\n        if 0 <= relative_row < stamp_h and 0 <= relative_col < stamp_w:\n            azure_pattern[relative_row, relative_col] = azure_color\n\n    # 5. Construct the Initial Output Grid\n    output_grid = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n\n    # 6. Overlay the Pattern\n    for rel_r in range(stamp_h):\n        for rel_c in range(stamp_w):\n            if azure_pattern[rel_r, rel_c] == azure_color:\n                # Check if the pattern coordinate maps inside the output grid\n                if 0 <= rel_r < canvas_h and 0 <= rel_c < canvas_w:\n                    output_grid[rel_r, rel_c] = azure_color\n\n    # 7. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24434,
    "candidates_token_count": 2268,
    "total_token_count": 26702,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.458674,
  "retries": null
}