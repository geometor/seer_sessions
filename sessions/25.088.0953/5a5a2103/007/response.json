{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation identifies horizontal and vertical lines of a single 'divider'\ncolor that partition the input grid into rectangular regions. For each horizontal\nband of regions (defined by the horizontal dividers), it identifies the 'source \ncolor' which is the single non-white, non-divider color present in the leftmost \nregion of that band in the input grid. Then, for every region within that same \nhorizontal band, it finds all pixels that are neither white nor the divider color \nin the input grid and recolors them to the identified 'source color' in the \noutput grid. Divider lines and white background pixels remain unchanged.\n\"\"\"\n\ndef find_divider_color_and_lines(grid):\n    \"\"\"\n    Identifies the divider color and the indices of horizontal and vertical divider lines.\n    The divider color must be the unique non-white color forming *all* full-width \n    horizontal lines and *all* full-height vertical lines.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (divider_color, h_div_indices, v_div_indices)\n               divider_color (int): The color used for dividing lines (0-9). Returns None if no clear divider found.\n               h_div_indices (list): Sorted list of row indices containing horizontal dividers.\n               v_div_indices (list): Sorted list of column indices containing vertical dividers.\n    \"\"\"\n    height, width = grid.shape\n    h_lines = collections.defaultdict(list)\n    v_lines = collections.defaultdict(list)\n    all_h_indices = []\n    all_v_indices = []\n\n    # Find all horizontal lines and their colors\n    for r in range(height):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            h_lines[color].append(r)\n            all_h_indices.append(r)\n\n    # Find all vertical lines and their colors\n    for c in range(width):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            v_lines[color].append(c)\n            all_v_indices.append(c)\n\n    # Determine the divider color\n    potential_dividers = []\n    \n    # Consider colors present in horizontal lines\n    for color, rows in h_lines.items():\n        # Check if this color forms ALL horizontal lines\n        if set(rows) == set(all_h_indices):\n             # Check if this color also forms ALL vertical lines (if any exist)\n             if not all_v_indices or (color in v_lines and set(v_lines[color]) == set(all_v_indices)):\n                 potential_dividers.append(color)\n\n    # Consider colors present in vertical lines (only if no h-lines were found or the h-line color didn't match)\n    if not potential_dividers and not all_h_indices:\n         for color, cols in v_lines.items():\n             # Check if this color forms ALL vertical lines\n             if set(cols) == set(all_v_indices):\n                  potential_dividers.append(color)\n\n    # If exactly one consistent divider color is found\n    if len(potential_dividers) == 1:\n        divider_color = potential_dividers[0]\n        # Use the found indices for this color, handling cases where one orientation might be empty\n        h_divs = sorted(h_lines.get(divider_color, [])) \n        v_divs = sorted(v_lines.get(divider_color, []))\n        return divider_color, h_divs, v_divs\n    else:\n        # No single consistent divider color found\n        return None, [], []\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the divider and recoloring logic.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np) # Initialize output as a copy\n    height, width = input_grid_np.shape\n\n    # 1. Identify Grid Structure: Find divider color and lines\n    divider_color, h_divs, v_divs = find_divider_color_and_lines(input_grid_np)\n\n    # If no clear divider structure is found, return the original grid\n    if divider_color is None:\n        # print(\"Warning: No consistent divider color found. Returning input grid.\")\n        return input_grid \n\n    # 2. Define Regions: Calculate region boundaries\n    row_starts = [0] + [r + 1 for r in h_divs]\n    row_ends = [r for r in h_divs] + [height]\n    \n    col_starts = [0] + [c + 1 for c in v_divs]\n    col_ends = [c for c in v_divs] + [width]\n    \n    num_region_rows = len(row_starts)\n    num_region_cols = len(col_starts)\n\n    # 3. Determine Source Colors per Horizontal Band\n    source_color_map = {} # Maps row_band_index to source_color\n    for i in range(num_region_rows):\n        r_start = row_starts[i]\n        r_end = row_ends[i]\n\n        # Skip if this band has zero height (e.g., consecutive dividers)\n        if r_start >= r_end:\n            continue\n\n        # Identify the leftmost region in this band\n        # Ensure there are columns defined\n        if num_region_cols == 0: \n             continue\n        leftmost_c_start = col_starts[0]\n        leftmost_c_end = col_ends[0]\n        \n        # Skip if leftmost region has zero width (e.g., consecutive dividers)\n        if leftmost_c_start >= leftmost_c_end:\n             continue\n\n        # Extract the leftmost region\n        leftmost_region = input_grid_np[r_start:r_end, leftmost_c_start:leftmost_c_end]\n\n        # Find the unique color(s) in the leftmost region, excluding white (0) and the divider color.\n        unique_colors_in_region = np.unique(leftmost_region)\n        potential_source_colors = [c for c in unique_colors_in_region if c != 0 and c != divider_color]\n        \n        # Store the source color if exactly one is found\n        if len(potential_source_colors) == 1:\n            source_color_map[i] = potential_source_colors[0]\n        # else:\n            # Handle cases with zero or multiple non-background/divider colors if necessary\n            # Based on examples, we expect exactly one. If not, this band won't be recolored.\n            # print(f\"Warning: Found {len(potential_source_colors)} potential source colors in band {i}, region 0: {potential_source_colors}. Skipping recoloring for this band.\")\n            pass \n\n    # 4. Recolor Grid based on Source Colors\n    for i in range(num_region_rows): # Iterate through horizontal bands\n        r_start = row_starts[i]\n        r_end = row_ends[i]\n\n        # Skip zero-height bands\n        if r_start >= r_end: continue\n        \n        # Get the source color for this band (if found)\n        source_color = source_color_map.get(i)\n        \n        # If no valid source color was found for this band, skip recoloring it\n        if source_color is None:\n            continue\n\n        # Iterate through all regions (columns) within this band\n        for j in range(num_region_cols):\n            c_start = col_starts[j]\n            c_end = col_ends[j]\n\n            # Skip zero-width regions\n            if c_start >= c_end: continue\n\n            # Iterate through pixels within the current region's boundaries\n            for r in range(r_start, r_end):\n                for c in range(c_start, c_end):\n                    original_color = input_grid_np[r, c]\n                    \n                    # If the pixel is part of a 'content object' (not white, not divider)\n                    if original_color != 0 and original_color != divider_color:\n                        # Recolor it in the output grid using the band's source color\n                        output_grid[r, c] = source_color\n                    # Otherwise (pixel is white or divider), it remains unchanged (already copied)\n\n    # 5. Return Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12073,
    "candidates_token_count": 2108,
    "total_token_count": 14181,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.028335,
  "retries": null
}