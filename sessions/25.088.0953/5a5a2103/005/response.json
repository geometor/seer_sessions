{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation identifies horizontal and vertical lines of a single 'divider'\ncolor that partition the input grid into rectangular regions. For each row of \nregions (defined by the horizontal dividers), it identifies the 'source color' \nwhich is the single non-white, non-divider color present in the leftmost region \nof that row in the input grid. Then, for every region within that same row, it \nfinds all pixels that are neither white nor the divider color in the input grid \nand recolors them to the identified 'source color' in the output grid. Divider \nlines and white background pixels remain unchanged.\n\"\"\"\n\ndef find_divider_color_and_lines(grid):\n    \"\"\"\n    Identifies the divider color and the indices of horizontal and vertical divider lines.\n    A color is considered the divider if it forms all observed full horizontal lines \n    and/or all observed full vertical lines (excluding white color 0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (divider_color, h_div_indices, v_div_indices)\n               divider_color (int): The color used for dividing lines (0-9). Returns None if no clear divider found.\n               h_div_indices (list): List of row indices containing horizontal dividers.\n               v_div_indices (list): List of column indices containing vertical dividers.\n    \"\"\"\n    height, width = grid.shape\n    h_divs = []\n    v_divs = []\n    potential_divider_colors = set()\n\n    # Find all horizontal lines and their colors\n    h_line_colors = {}\n    for r in range(height):\n        unique_colors = np.unique(grid[r, :])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            h_line_colors[r] = color\n            potential_divider_colors.add(color)\n\n    # Find all vertical lines and their colors\n    v_line_colors = {}\n    for c in range(width):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            color = unique_colors[0]\n            v_line_colors[c] = color\n            potential_divider_colors.add(color)\n\n    # Determine the divider color\n    divider_color = None\n    possible_dividers = []\n\n    for color in potential_divider_colors:\n        is_sole_h_color = all(c == color for r, c in h_line_colors.items()) if h_line_colors else True\n        is_sole_v_color = all(c == color for c, c_val in v_line_colors.items()) if v_line_colors else True\n        \n        # A color qualifies if it's the *only* color forming horizontal lines (if any exist)\n        # AND the *only* color forming vertical lines (if any exist).\n        # Or if only one orientation of lines exists, it must be the color for all of them.\n        forms_any_h = any(c == color for r, c in h_line_colors.items())\n        forms_any_v = any(c == color for c, c_val in v_line_colors.items())\n\n        if (forms_any_h or forms_any_v) and is_sole_h_color and is_sole_v_color:\n             possible_dividers.append(color)\n\n    # Expecting only one divider color based on examples\n    if len(possible_dividers) == 1:\n        divider_color = possible_dividers[0]\n        h_divs = [r for r, c in h_line_colors.items() if c == divider_color]\n        v_divs = [c for c, c_val in v_line_colors.items() if c_val == divider_color]\n    # else: # Ambiguous or no clear divider, handle potentially (e.g., return None)\n        # print(f\"Warning: Found {len(possible_dividers)} potential divider colors: {possible_dividers}. Cannot proceed reliably.\")\n        pass \n        \n    return divider_color, sorted(list(set(h_divs))), sorted(list(set(v_divs)))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring shapes within regions based on the \n    color found in the leftmost region of the same row band.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np) # Initialize output as a copy\n    height, width = input_grid_np.shape\n\n    # 1. Identify the divider color and the locations of divider lines.\n    divider_color, h_divs, v_divs = find_divider_color_and_lines(input_grid_np)\n\n    # Handle case where no clear dividers are found \n    if divider_color is None:\n        # Strategy fails if dividers aren't identified. Return input as default.\n        return input_grid \n\n    # 2. Define the boundaries of each region (content areas between dividers).\n    row_starts = [0] + [r + 1 for r in h_divs]\n    row_ends = [r for r in h_divs] + [height]\n    \n    col_starts = [0] + [c + 1 for c in v_divs]\n    col_ends = [c for c in v_divs] + [width]\n    \n    num_region_rows = len(row_starts)\n    num_region_cols = len(col_starts)\n\n    # 3. Iterate through each row of regions (horizontal bands).\n    for i in range(num_region_rows):\n        r_start = row_starts[i]\n        r_end = row_ends[i]\n\n        # Skip if this band has zero height\n        if r_start >= r_end:\n            continue\n\n        # 4. Identify the leftmost region in this band.\n        if not col_starts: # Grid must have width > 0\n             continue\n        leftmost_c_start = col_starts[0]\n        leftmost_c_end = col_ends[0]\n        \n        # Skip if leftmost region has zero width\n        if leftmost_c_start >= leftmost_c_end:\n             continue\n\n        # 5. Extract the leftmost region from the input grid.\n        leftmost_region = input_grid_np[r_start:r_end, leftmost_c_start:leftmost_c_end]\n\n        # 6. Determine the source color for this band.\n        # Find unique colors in the leftmost region, excluding white (0) and the divider color.\n        unique_colors = np.unique(leftmost_region)\n        source_colors = [c for c in unique_colors if c != 0 and c != divider_color]\n        \n        source_color = None\n        if len(source_colors) == 1:\n            source_color = source_colors[0]\n        # else: # Handle cases with zero or multiple non-background/divider colors if necessary\n            # Based on examples, expect exactly one. If not, maybe default or raise error.\n            # For now, if not exactly one, we won't recolor this band.\n            # print(f\"Warning: Found {len(source_colors)} potential source colors in band {i}, region 0: {source_colors}. Skipping recoloring for this band.\")\n            # continue # Skip to the next band if source color is ambiguous\n\n        # If no valid source color found (e.g., leftmost region empty or only bg/divider), skip band\n        if source_color is None:\n            continue\n\n        # 7. Iterate through all regions (columns) within this same band.\n        for j in range(num_region_cols):\n            c_start = col_starts[j]\n            c_end = col_ends[j]\n\n            # Skip if this region has zero width\n            if c_start >= c_end:\n                 continue\n\n            # 8. Identify target pixels within this region in the input grid.\n            # Target pixels are those that are not white (0) and not the divider color.\n            for r_local in range(r_end - r_start):\n                for c_local in range(c_end - c_start):\n                    current_r, current_c = r_start + r_local, c_start + c_local\n                    original_color = input_grid_np[current_r, current_c]\n                    \n                    # 9. Recolor target pixels in the output grid.\n                    if original_color != 0 and original_color != divider_color:\n                        output_grid[current_r, current_c] = source_color\n                    # else: Keep original color (white or divider)\n\n    # 10. Return the modified output grid as a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13206,
    "candidates_token_count": 2157,
    "total_token_count": 15363,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.017402,
  "retries": null
}