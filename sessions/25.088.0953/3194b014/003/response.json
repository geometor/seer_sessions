{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all contiguous blocks of pixels that have the same, non-white color.\nFilter these blocks to find those that form perfect, solid squares (height equals width, and all pixels within the bounding box match the block's color and are part of the block).\nFind the maximum side length among all identified solid squares.\nSelect the solid square(s) that have this maximum side length.\nIf there is only one such square, choose its color.\nIf there are multiple squares with the maximum side length, choose the color of the square with the smallest color index.\nIf no solid squares are found, default to white (0).\nConstruct a 3x3 output grid and fill it entirely with the chosen color.\n\"\"\"\n\ndef find_contiguous_blocks(grid):\n    \"\"\"\n    Finds all contiguous blocks of the same non-background color (0).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              {'color': int, 'coords': set_of_tuples, 'size': int}\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    blocks = []\n    \n    for r in range(height):\n        for c in range(width):\n            # Check if the pixel is non-background (not 0) and not visited\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                component = set()\n                queue = deque([(r, c)])\n                visited.add((r, c))\n                \n                # Breadth-First Search (BFS) to find all connected pixels of the same color\n                while queue:\n                    row, col = queue.popleft()\n                    component.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and if not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            queue.append((nr, nc))\n                \n                if component: # Ensure component is not empty before adding\n                    blocks.append({'color': color, 'coords': component, 'size': len(component)})\n                \n    return blocks\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None, None, None, None, 0, 0\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return min_r, min_c, max_r, max_c, height, width\n\ndef is_solid_square(block, grid):\n    \"\"\"\n    Checks if a component block forms a solid square.\n    \n    Args:\n        block (dict): A dictionary containing 'coords', 'color', 'size'.\n        grid (np.array): The original grid (needed to verify solidity).\n\n    Returns:\n        tuple: (is_square, size, color) or (False, 0, None)\n               is_square is True if it's a solid square.\n               size is the side length if it's a square, otherwise 0.\n               color is the block's color if it's a square, otherwise None.\n    \"\"\"\n    coords = block['coords']\n    color = block['color']\n    pixel_count = block['size']\n\n    if not coords:\n        return False, 0, None\n\n    min_r, min_c, max_r, max_c, height, width = get_bounding_box(coords)\n\n    # 1. Check if bounding box is square\n    if height != width:\n        return False, 0, None\n\n    # 2. Check if number of pixels matches the bounding box area\n    if pixel_count != height * width:\n        return False, 0, None\n        \n    # 3. Check if all pixels within the bounding box match the component's color \n    #    and are actually part of the component (redundant with check 2, but explicit)\n    grid_h, grid_w = grid.shape\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check bounds just in case, though bounding box should be within grid\n            if not (0 <= r < grid_h and 0 <= c < grid_w):\n                return False, 0, None # Should not happen\n            # Check if the grid color matches the block color\n            if grid[r, c] != color:\n                 return False, 0, None # Found a different color within the bbox\n            # Check if this coordinate from the bbox is in the component set\n            if (r, c) not in coords:\n                 return False, 0, None # Found a 'hole' within the bbox\n\n    # If all checks pass, it's a solid square\n    return True, height, color \n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the largest solid square, determining its \n    color (with tie-breaking using the smallest color index), and outputting a \n    3x3 grid filled with that color.\n    \n    Args:\n        input_grid (list of lists): The input grid representation.\n\n    Returns:\n        list of lists: A 3x3 grid filled with the determined color.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Find all contiguous blocks of non-background colors\n    blocks = find_contiguous_blocks(input_grid_np)\n    \n    solid_squares = []\n    # 2. Iterate through blocks to find all solid squares\n    for block in blocks:\n        is_sq, size, sq_color = is_solid_square(block, input_grid_np)\n        if is_sq:\n            solid_squares.append({'color': sq_color, 'size': size})\n\n    # 3. Find the maximum side length among solid squares\n    max_square_size = 0\n    if solid_squares:\n        max_square_size = max(sq['size'] for sq in solid_squares)\n\n    # 4. Filter for squares with the maximum side length\n    largest_squares = [sq for sq in solid_squares if sq['size'] == max_square_size]\n\n    # 5. Determine the output color\n    output_color = 0 # Default to white (background) if no squares found\n    if largest_squares:\n        # If multiple largest squares exist, choose the one with the minimum color index\n        largest_squares.sort(key=lambda x: x['color'])\n        output_color = largest_squares[0]['color']\n        \n    # 6. Create the output grid (3x3) filled with the chosen color\n    output_grid_np = np.full((3, 3), output_color, dtype=int)\n    \n    # 7. Convert back to list of lists for the required output format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16738,
    "candidates_token_count": 1792,
    "total_token_count": 18530,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.264341,
  "retries": null
}