{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify the Canvas:** Scan the input grid to find the largest possible contiguous rectangular area composed of a single, non-white color. Determine its color, its top-left corner coordinates (row `r`, column `c`), its height `h`, and its width `w`. This rectangle is the \"canvas\".\n2.  **Initialize Output:** Create a new output grid with height `h` and width `w`. Fill this entire grid with the color of the identified canvas.\n3.  **Transfer Figures:** Iterate through every pixel in the input grid at position (`in_r`, `in_c`) with color `p_color`.\n4.  **Check Pixel Relevance:** Determine if the current input pixel should be transferred. A pixel is transferred if:\n    *   Its color `p_color` is not white (0), AND\n    *   It is *not* part of the original canvas block identified in step 1. (i.e., it's either outside the canvas bounds `r <= in_r < r+h` and `c <= in_c < c+w`, OR it's inside the bounds but `p_color` is different from the canvas color).\n5.  **Place Pixel:** If the pixel meets the criteria in step 4:\n    *   Calculate its target position in the output grid relative to the canvas's top-left corner: `out_r = in_r - r`, `out_c = in_c - c`.\n    *   Verify that this target position (`out_r`, `out_c`) falls within the bounds of the output grid (i.e., `0 <= out_r < h` and `0 <= out_c < w`).\n    *   If the position is valid, update the output grid at (`out_r`, `out_c`) with the color `p_color`.\n6.  **Final Output:** The resulting output grid after checking all input pixels is the final transformed grid.\n\"\"\"\n\ndef find_largest_rectangle(grid):\n    \"\"\"\n    Finds the largest solid rectangle of a single non-white color in the grid.\n    Uses an optimized approach by expanding from potential top-left corners.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict or None: A dictionary containing the rectangle's color, top-left row 'r',\n                      top-left column 'c', height 'h', and width 'w',\n                      or None if no such rectangle is found.\n    \"\"\"\n    height, width = grid.shape\n    max_area = 0\n    best_rect_info = None\n\n    for r1 in range(height):\n        for c1 in range(width):\n            # Get the color of the potential top-left corner\n            color = grid[r1, c1]\n\n            # Skip if it's the background color (white=0)\n            if color == 0:\n                continue\n\n            # Determine the maximum possible width for this starting cell (r1, c1) in this row (r1)\n            current_max_w = 0\n            for cw in range(c1, width):\n                if grid[r1, cw] == color:\n                    current_max_w += 1\n                else:\n                    break # Color changed, stop extending width for this row\n\n            # Now iterate downwards (increasing height) from r1\n            # maintaining the maximum possible width for the rectangle\n            min_w_so_far = current_max_w\n            for rh in range(r1, height):\n                current_row_w = 0\n                # Calculate the width of the same color in the current row (rh)\n                # starting from c1, up to the minimum width seen so far\n                for cw in range(c1, c1 + min_w_so_far):\n                    if cw < width and grid[rh, cw] == color:\n                        current_row_w += 1\n                    else:\n                        break # Stop if color changes or out of bounds\n\n                # Update the minimum width constraint based on the current row\n                min_w_so_far = min(min_w_so_far, current_row_w)\n\n                if min_w_so_far == 0:\n                    # If the width shrinks to zero, we can't extend this rectangle further down\n                    break\n\n                # Calculate the area of the rectangle ending at this row (rh)\n                # with the current constrained width (min_w_so_far)\n                current_height = rh - r1 + 1\n                area = current_height * min_w_so_far\n\n                # If this rectangle is the largest found so far, store its info\n                if area > max_area:\n                    max_area = area\n                    best_rect_info = {\n                        'color': int(color),\n                        'r': r1,\n                        'c': c1,\n                        'h': current_height,\n                        'w': min_w_so_far\n                    }\n    return best_rect_info\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying the largest non-white solid rectangle (canvas),\n    creating an output grid of that size and color, and overlaying any other non-white\n    pixels from the input onto the output grid, maintaining their relative positions.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    input_height, input_width = grid_np.shape\n\n    # 1. Identify the Canvas\n    canvas_info = find_largest_rectangle(grid_np)\n\n    # Handle case where no suitable rectangle is found (e.g., all white grid)\n    if canvas_info is None:\n        # Based on examples, there's always a canvas. If not, return empty or original?\n        # Returning empty list might be safer if dimensions are unknown.\n        return [] \n\n    canvas_color = canvas_info['color']\n    canvas_r, canvas_c = canvas_info['r'], canvas_info['c']\n    canvas_h, canvas_w = canvas_info['h'], canvas_info['w']\n\n    # 2. Initialize Output grid\n    output_grid_np = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n\n    # 3. & 4. Iterate through input grid to find and transfer figure pixels\n    for in_r in range(input_height):\n        for in_c in range(input_width):\n            pixel_color = grid_np[in_r, in_c]\n\n            # Check if pixel is white (skip if it is)\n            if pixel_color == 0:\n                continue\n\n            # Check if the pixel is part of the original canvas block\n            is_part_of_canvas = (canvas_r <= in_r < canvas_r + canvas_h and\n                                 canvas_c <= in_c < canvas_c + canvas_w and\n                                 pixel_color == canvas_color)\n\n            # If the pixel is non-white AND NOT part of the original canvas block, transfer it\n            if not is_part_of_canvas:\n                # 5. Calculate relative position and place pixel if valid\n                out_r = in_r - canvas_r\n                out_c = in_c - canvas_c\n\n                # Check if the calculated position is within the output grid bounds\n                if 0 <= out_r < canvas_h and 0 <= out_c < canvas_w:\n                    output_grid_np[out_r, out_c] = pixel_color\n\n    # 6. Final Output: Convert numpy array back to list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10979,
    "candidates_token_count": 1811,
    "total_token_count": 12790,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.768494,
  "retries": null
}