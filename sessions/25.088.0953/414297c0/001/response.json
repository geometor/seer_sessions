{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the largest solid, single-colored, non-white rectangle in the input grid.\nThis rectangle defines the background color and dimensions of the output grid.\nThen, iterates through the input grid. Any pixel that is not white (0) and not part of the identified background rectangle is overlaid onto the output grid, maintaining its position relative to the top-left corner of the background rectangle found in the input.\n\"\"\"\n\ndef find_largest_rectangle(grid):\n    \"\"\"\n    Finds the largest solid rectangle of a single non-white color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict or None: A dictionary containing the rectangle's color, top-left row 'r',\n                      top-left column 'c', height 'h', and width 'w',\n                      or None if no such rectangle is found.\n    \"\"\"\n    height, width = grid.shape\n    max_area = 0\n    best_rect_info = None\n\n    # Iterate through all possible top-left corners (r1, c1)\n    for r1 in range(height):\n        for c1 in range(width):\n            # Iterate through all possible bottom-right corners (r2, c2)\n            for r2 in range(r1, height):\n                for c2 in range(c1, width):\n                    # Extract the subgrid\n                    sub_grid = grid[r1:r2+1, c1:c2+1]\n\n                    # Check if the subgrid is valid and potentially a candidate\n                    if sub_grid.size == 0:\n                        continue\n\n                    # Get the potential color from the top-left of the subgrid\n                    color = sub_grid[0, 0]\n\n                    # Rule out white background color\n                    if color == 0:\n                        continue\n\n                    # Check if all elements in the subgrid are the same color\n                    if np.all(sub_grid == color):\n                        # Calculate area\n                        current_height = r2 - r1 + 1\n                        current_width = c2 - c1 + 1\n                        area = current_height * current_width\n\n                        # Update if this is the largest rectangle found so far\n                        if area > max_area:\n                            max_area = area\n                            best_rect_info = {\n                                'color': color,\n                                'r': r1,\n                                'c': c1,\n                                'h': current_height,\n                                'w': current_width\n                            }\n    return best_rect_info\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on overlaying elements onto the largest rectangle.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Find the largest solid non-white rectangle (the canvas)\n    canvas_info = find_largest_rectangle(grid_np)\n\n    if canvas_info is None:\n        # Handle case where no suitable rectangle is found (e.g., return empty or input)\n        # Based on examples, this shouldn't happen, but good practice.\n        return [] # Or perhaps return input_grid\n\n    canvas_color = canvas_info['color']\n    canvas_r, canvas_c = canvas_info['r'], canvas_info['c']\n    canvas_h, canvas_w = canvas_info['h'], canvas_info['w']\n\n    # Initialize the output grid with the canvas color and dimensions\n    output_grid_np = np.full((canvas_h, canvas_w), canvas_color, dtype=int)\n\n    # Iterate through the input grid to find overlay pixels\n    for r in range(height):\n        for c in range(width):\n            pixel_color = grid_np[r, c]\n\n            # Check if the pixel is part of the canvas rectangle area\n            is_in_canvas_area = (canvas_r <= r < canvas_r + canvas_h and\n                                 canvas_c <= c < canvas_c + canvas_w)\n\n            # A pixel is an overlay if it's not white AND\n            # EITHER it's outside the canvas area\n            # OR it's inside the canvas area but has a DIFFERENT color than the canvas\n            # Simplified: If pixel is not white (0) and not the canvas color itself at that location\n            # More precisely: We need to copy any non-white pixel that ISN'T part of the original canvas block\n            # Let's check if the pixel should be considered for overlaying\n            if pixel_color != 0: # Must not be white\n                 # If the pixel is within the bounds of where the canvas *was* in the input...\n                 if is_in_canvas_area:\n                     # ...but its color is different from the canvas color, it's an overlay\n                     if pixel_color != canvas_color:\n                         # Calculate its position relative to the canvas top-left\n                         out_r = r - canvas_r\n                         out_c = c - canvas_c\n                         # Place it on the output grid\n                         output_grid_np[out_r, out_c] = pixel_color\n                 # If the pixel is *outside* the canvas area in the input, it's also potentially an overlay\n                 # but we only care if its corresponding position *would* fall inside the output grid dimensions\n                 else:\n                     # Calculate its hypothetical position relative to the canvas top-left\n                     out_r = r - canvas_r\n                     out_c = c - canvas_c\n                     # Check if this position is valid within the output grid bounds\n                     if 0 <= out_r < canvas_h and 0 <= out_c < canvas_w:\n                         # Place it on the output grid\n                         output_grid_np[out_r, out_c] = pixel_color\n\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4763,
    "candidates_token_count": 1419,
    "total_token_count": 6182,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.967379,
  "retries": null
}