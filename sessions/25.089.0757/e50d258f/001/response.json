{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct contiguous groups (objects) of non-white pixels (color > 0) in the input grid, considering diagonal adjacency.\nCount the number of red pixels (color 2) within each object.\nSelect the object with the maximum count of red pixels. If there's a tie, choose the object whose topmost pixel is highest (minimum row index); if still tied, choose the one whose leftmost pixel is furthest left (minimum column index).\nDetermine the minimal rectangular bounding box enclosing the selected object.\nExtract and return the subgrid corresponding to this bounding box from the input grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all distinct contiguous objects of non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of objects, where each object is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) for a new object\n                current_object = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Keep track of top-left point for tie-breaking\n\n                while q:\n                    row, col = q.popleft()\n                    current_object.append((row, col))\n\n                    # Update top-left point\n                    if row < min_r:\n                        min_r = row\n                        min_c = col\n                    elif row == min_r and col < min_c:\n                        min_c = col\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds and if neighbor is part of the object and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != 0 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if current_object:\n                    # Store the object along with its top-left corner for tie-breaking\n                    objects.append({'coords': current_object, 'top_left': (min_r, min_c)})\n                    \n    return objects\n\ndef count_color(grid, obj_coords, color_val):\n    \"\"\"\n    Counts the occurrences of a specific color within an object's coordinates.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_coords (list): List of (row, col) tuples for the object.\n        color_val (int): The color value to count.\n\n    Returns:\n        int: The count of the specified color.\n    \"\"\"\n    count = 0\n    for r, c in obj_coords:\n        if grid[r, c] == color_val:\n            count += 1\n    return count\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the minimal bounding box for a set of coordinates.\n\n    Args:\n        obj_coords (list): List of (row, col) tuples for the object.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    if not obj_coords:\n        return None # Or handle as appropriate\n\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    \n    return min_row, min_col, max_row, max_col\n\ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts a subgrid based on bounding box coordinates.\n\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        np.array: The extracted subgrid.\n    \"\"\"\n    min_row, min_col, max_row, max_col = bbox\n    return grid[min_row : max_row + 1, min_col : max_col + 1]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the object with the most red pixels (2),\n    handling ties by top-left position, and extracting its bounding box.\n    \n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid (extracted subgrid).\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Find all distinct non-white objects\n    objects = find_objects(grid_np)\n\n    if not objects:\n        # Handle cases with no non-white pixels if necessary\n        # Returning an empty grid or the original might be options.\n        # Based on examples, seems there's always at least one object.\n        return [] # Return empty list for empty grid representation\n\n    # 2. Count red (2) pixels for each object and find the best object\n    best_object_info = None\n    max_red_count = -1\n\n    for obj_info in objects:\n        obj_coords = obj_info['coords']\n        top_left = obj_info['top_left']\n        \n        # 3. Count red pixels\n        red_count = count_color(grid_np, obj_coords, 2)\n\n        # 4. Compare with current best\n        if red_count > max_red_count:\n            max_red_count = red_count\n            best_object_info = obj_info\n        elif red_count == max_red_count:\n            # Tie-breaking: compare top-left corners\n            current_best_top_left = best_object_info['top_left']\n            if top_left[0] < current_best_top_left[0]: # Higher row (smaller index)\n                best_object_info = obj_info\n            elif top_left[0] == current_best_top_left[0]: # Same row\n                if top_left[1] < current_best_top_left[1]: # Further left column (smaller index)\n                    best_object_info = obj_info\n\n    if best_object_info is None:\n         # This case might happen if there are objects but none contain red pixels.\n         # The logic above should still select the top-leftmost object among those with 0 reds.\n         # If objects list was empty, already handled. Let's assume the logic selects one.\n         # If for some reason it's still None (e.g., error in logic), return empty.\n         # Re-evaluating: The loop initializes max_red_count to -1.\n         # If all objects have 0 red pixels, the first object encountered will set max_red_count=0\n         # and become the best_object_info. Subsequent objects with 0 red pixels will be compared\n         # using the tie-breaker. So best_object_info should not be None if objects list is not empty.\n         pass # Should have a best object selected by now if objects existed.\n\n    # 5. Get bounding box of the selected object\n    best_object_coords = best_object_info['coords']\n    bbox = get_bounding_box(best_object_coords)\n    \n    # 6. Extract the subgrid\n    output_grid_np = extract_subgrid(grid_np, bbox)\n    \n    # Convert back to list of lists for the expected output format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2507,
    "candidates_token_count": 1925,
    "total_token_count": 4432,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.820177,
  "retries": null
}