{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies four distinct L-shaped objects (3 pixels of the same non-white color) in the input grid.\nMaps each L-shape to a specific 2x2 quadrant in a 4x4 output grid based on its orientation.\nThe 2x2 representation preserves the object's color and shape, using white (0) for the empty cell within the L-shape's 2x2 bounding box.\n\nMapping rule:\n- L-shape with empty bottom-right corner maps to output top-left quadrant.\n- L-shape with empty top-right corner maps to output bottom-left quadrant.\n- L-shape with empty top-left corner maps to output bottom-right quadrant.\n- L-shape with empty bottom-left corner maps to output top-right quadrant.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'pixels' (list of tuples (r, c)).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n    return objects\n\ndef get_l_shape_details(color, pixels):\n    \"\"\"\n    Determines the 2x2 representation and empty cell position for an L-shape object.\n\n    Args:\n        color (int): The color of the object.\n        pixels (list): List of (row, col) tuples for the object's pixels.\n\n    Returns:\n        tuple: (shape_2x2 (np.array), empty_cell (tuple(r, c))), or None if not a valid L-shape.\n               Empty cell coordinates are relative to the 2x2 shape (0,0), (0,1), (1,0), or (1,1).\n    \"\"\"\n    if len(pixels) != 3:\n        return None, None # Not an L-shape if pixel count is not 3\n\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    if height != 2 or width != 2:\n         return None, None # Not contained within a 2x2 bounding box\n\n    shape_2x2 = np.zeros((2, 2), dtype=int)\n    empty_cell_relative = None\n\n    for r in range(2):\n        for c in range(2):\n            abs_r, abs_c = min_r + r, min_c + c\n            if (abs_r, abs_c) in pixels:\n                shape_2x2[r, c] = color\n            else:\n                # Check if we already found an empty cell - L shapes have only one\n                if empty_cell_relative is not None:\n                    return None, None # More than one empty cell in 2x2 box means not L-shape\n                empty_cell_relative = (r, c)\n\n    if empty_cell_relative is None:\n        # This should not happen if pixel count is 3 and bbox is 2x2\n        return None, None \n\n    return shape_2x2, empty_cell_relative\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the L-shape mapping rule.\n\n    Args:\n        input_grid (np.array): The input grid as a numpy array.\n\n    Returns:\n        np.array: The transformed 4x4 output grid.\n    \"\"\"\n    # Initialize a 4x4 output grid with the background color (white, 0)\n    output_grid = np.zeros((4, 4), dtype=int)\n    \n    # Find all distinct non-background objects in the input grid\n    objects = find_objects(np.array(input_grid))\n    \n    # Expect exactly 4 L-shaped objects\n    if len(objects) != 4:\n        # Handle error or unexpected input - perhaps return empty or input?\n        # For now, proceed assuming valid input structure as per examples.\n        print(f\"Warning: Expected 4 objects, found {len(objects)}\")\n\n    # Process each found object\n    for obj in objects:\n        color = obj['color']\n        pixels = obj['pixels']\n        \n        # Determine the L-shape's 2x2 representation and its orientation (empty cell position)\n        shape_2x2, empty_cell = get_l_shape_details(color, pixels)\n        \n        if shape_2x2 is None or empty_cell is None:\n             # Skip if the object is not a valid L-shape\n            print(f\"Warning: Skipping invalid object with color {color} at {pixels[0]}\")\n            continue\n\n        # Determine the target quadrant based on the empty cell position\n        target_r, target_c = 0, 0 # Default top-left\n        \n        if empty_cell == (1, 1): # Empty bottom-right -> Top-Left\n            target_r, target_c = 0, 0\n        elif empty_cell == (0, 1): # Empty top-right -> Bottom-Left\n            target_r, target_c = 2, 0\n        elif empty_cell == (0, 0): # Empty top-left -> Bottom-Right\n            target_r, target_c = 2, 2\n        elif empty_cell == (1, 0): # Empty bottom-left -> Top-Right\n            target_r, target_c = 0, 2\n        else:\n            # Should not happen with valid L-shapes\n             print(f\"Warning: Unexpected empty cell position {empty_cell} for object color {color}\")\n             continue\n\n        # Place the 2x2 shape into the determined quadrant\n        output_grid[target_r:target_r+2, target_c:target_c+2] = shape_2x2\n            \n    return output_grid.tolist() # Return as list of lists as per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2905,
    "candidates_token_count": 1731,
    "total_token_count": 4636,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.743447,
  "retries": null
}