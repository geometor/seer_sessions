{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation takes an input grid and produces an output grid that is twice the height and twice the width.\nThe output grid is composed of four quadrants, each the size of the input grid.\n1. The top-left quadrant is an identical copy of the input grid.\n2. Identify three key colors from the input grid:\n   - CornerColor: Color at input_grid[0, 0].\n   - EdgeColor: Color at input_grid[0, 1].\n   - CenterColor: Color at input_grid[1, 2] (representative of the central pattern).\n3. The top-right quadrant is generated by applying a color permutation to the input grid:\n   - CornerColor maps to CornerColor.\n   - EdgeColor maps to CenterColor.\n   - CenterColor maps to EdgeColor.\n4. The bottom-left quadrant uses the same color permutation rule as the top-right quadrant.\n5. The bottom-right quadrant is generated by applying a different color permutation to the input grid:\n   - CornerColor maps to CenterColor.\n   - EdgeColor maps to CornerColor.\n   - CenterColor maps to EdgeColor.\nThe final output grid is assembled from these four quadrants.\n\"\"\"\n\ndef _apply_permutation(grid, color_map):\n    \"\"\"\n    Applies a color permutation to a grid based on a provided mapping.\n    \n    Args:\n        grid (np.array): The input grid to permute.\n        color_map (dict): A dictionary mapping original colors to new colors.\n        \n    Returns:\n        np.array: A new grid with colors permuted according to the map.\n    \"\"\"\n    permuted_grid = grid.copy()\n    # Ensure all colors present in the grid are handled, even if not in the explicit map keys.\n    # By default, colors not in the map keys will remain unchanged.\n    # However, for this specific problem, we expect all relevant colors to be mapped.\n    \n    # Create boolean masks for each color in the map's keys\n    masks = {original_color: (grid == original_color) for original_color in color_map.keys()}\n    \n    # Apply the mapping using the masks\n    for original_color, new_color in color_map.items():\n        permuted_grid[masks[original_color]] = new_color\n        \n    return permuted_grid\n\ndef transform(input_grid: np.array) -> np.array:\n    \"\"\"\n    Transforms the input grid by creating a 2x2 tiled output grid\n    with specific color permutations applied to three of the tiles.\n\n    Args:\n        input_grid (np.array): The input N x M grid.\n\n    Returns:\n        np.array: The output 2N x 2M grid.\n    \"\"\"\n    # Determine the dimensions of the input grid\n    n_rows, n_cols = input_grid.shape\n\n    # Create the output grid, twice the size in each dimension\n    output_grid = np.zeros((2 * n_rows, 2 * n_cols), dtype=input_grid.dtype)\n\n    # Identify the three key colors based on specific positions\n    # Add checks for grid size to prevent index errors, though examples are 5x5\n    if n_rows > 0 and n_cols > 0:\n        corner_color = input_grid[0, 0]\n    else:\n        # Handle empty or 1D grid case if necessary, though unlikely in ARC\n        return output_grid # Or raise error\n\n    if n_rows > 0 and n_cols > 1:\n        edge_color = input_grid[0, 1]\n    else:\n        edge_color = corner_color # Fallback if grid is too small\n\n    if n_rows > 1 and n_cols > 2:\n        center_color = input_grid[1, 2]\n    elif n_rows > 1 and n_cols > 1:\n         center_color = input_grid[1,1] # Fallback for slightly smaller grids\n    else:\n        center_color = edge_color # Further fallback\n\n\n    # --- Fill Quadrants ---\n\n    # 1. Top-Left Quadrant: Direct copy\n    output_grid[0:n_rows, 0:n_cols] = input_grid\n\n    # 2. Define Permutation 1 (Top-Right and Bottom-Left)\n    # Corner -> Corner\n    # Edge -> Center\n    # Center -> Edge\n    permutation1_map = {\n        corner_color: corner_color,\n        edge_color: center_color,\n        center_color: edge_color\n    }\n    permuted_grid_1 = _apply_permutation(input_grid, permutation1_map)\n\n    # 3. Fill Top-Right Quadrant\n    output_grid[0:n_rows, n_cols:2*n_cols] = permuted_grid_1\n\n    # 4. Fill Bottom-Left Quadrant\n    output_grid[n_rows:2*n_rows, 0:n_cols] = permuted_grid_1\n\n    # 5. Define Permutation 2 (Bottom-Right)\n    # Corner -> Center\n    # Edge -> Corner\n    # Center -> Edge\n    permutation2_map = {\n        corner_color: center_color,\n        edge_color: corner_color,\n        center_color: edge_color\n    }\n    permuted_grid_2 = _apply_permutation(input_grid, permutation2_map)\n\n    # 6. Fill Bottom-Right Quadrant\n    output_grid[n_rows:2*n_rows, n_cols:2*n_cols] = permuted_grid_2\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3031,
    "candidates_token_count": 1313,
    "total_token_count": 4344,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.956291,
  "retries": null
}