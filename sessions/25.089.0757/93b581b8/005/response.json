{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the unique 2x2 block of non-white pixels (the source_block) in the input grid.\n2. Creating a new output grid of the same dimensions as the input, initialized to all white pixels (0).\n3. Painting four new 2x2 monochromatic blocks at the absolute corners of the output grid.\n4. The color of each new corner block is determined by the pixel diagonally opposite to its relative corner within the source_block.\n   - Top-Left corner block uses the color of the source_block's Bottom-Right pixel (D).\n   - Top-Right corner block uses the color of the source_block's Bottom-Left pixel (C).\n   - Bottom-Left corner block uses the color of the source_block's Top-Right pixel (B).\n   - Bottom-Right corner block uses the color of the source_block's Top-Left pixel (A).\n\"\"\"\n\ndef find_source_block_top_left(grid: np.ndarray) -> tuple[int, int] | None:\n    \"\"\"\n    Finds the top-left coordinate (r, c) of the first 2x2 block \n    where all four pixels are non-white (color != 0).\n    Assumes there is exactly one such block based on the task description.\n    \n    Args:\n        grid: The input grid as a NumPy array.\n        \n    Returns:\n        A tuple (row, col) of the top-left corner, or None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Check if all four cells in the 2x2 block starting at (r, c) are non-white\n            if (grid[r, c] != 0 and \n                grid[r, c+1] != 0 and\n                grid[r+1, c] != 0 and\n                grid[r+1, c+1] != 0):\n                return r, c\n    return None # Should not happen based on task constraints\n\ndef paint_block(grid: np.ndarray, top_left_r: int, top_left_c: int, height: int, width: int, color: int):\n    \"\"\"\n    Fills a rectangular block in the grid with a specified color.\n    Uses NumPy slicing for efficiency. Assumes coordinates and dimensions are valid.\n    \n    Args:\n        grid: The NumPy array representing the grid (modified in-place).\n        top_left_r: The starting row index.\n        top_left_c: The starting column index.\n        height: The height of the block.\n        width: The width of the block.\n        color: The color value to fill the block with.\n    \"\"\"\n    # Ensure indices are within bounds\n    end_r = min(top_left_r + height, grid.shape[0])\n    end_c = min(top_left_c + width, grid.shape[1])\n    start_r = max(0, top_left_r)\n    start_c = max(0, top_left_c)\n\n    if start_r < end_r and start_c < end_c:\n        grid[start_r : end_r, start_c : end_c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid: A list of lists representing the input grid.\n        \n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape # Get grid dimensions\n\n    # 1. Initialize output_grid as a white canvas of the same size\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 2. Locate the source 2x2 block in the input grid\n    block_coord = find_source_block_top_left(input_np)\n    \n    # If no source block is found (unlikely based on examples), return the white grid\n    if block_coord is None:\n        print(\"Warning: No source 2x2 non-white block found.\")\n        return output_grid.tolist() \n        \n    r, c = block_coord\n\n    # 3. Identify the colors A, B, C, D from the source block in the input grid\n    # Ensure coordinates + offset are within bounds (though find_source_block_top_left should guarantee this)\n    if r+1 < H and c+1 < W:\n      color_A = input_np[r, c]       # Top-left\n      color_B = input_np[r, c+1]     # Top-right\n      color_C = input_np[r+1, c]     # Bottom-left\n      color_D = input_np[r+1, c+1]   # Bottom-right\n    else:\n      # This case should not be reached if find_source_block_top_left works correctly\n      print(\"Warning: Source block location is out of expected bounds.\")\n      return output_grid.tolist() \n\n\n    # 4. Define the locations and colors for the new 2x2 corner blocks\n    #    Structure: (top_left_r, top_left_c, color)\n    #    Ensure grid is large enough for 2x2 blocks before painting.\n    if H >= 2 and W >= 2:\n      new_blocks_info = [\n          (0, 0, color_D),       # Top-Left New Block (uses source bottom-right color D)\n          (0, W - 2, color_C),   # Top-Right New Block (uses source bottom-left color C)\n          (H - 2, 0, color_B),   # Bottom-Left New Block (uses source top-right color B)\n          (H - 2, W - 2, color_A) # Bottom-Right New Block (uses source top-left color A)\n      ]\n\n      # 5. Paint the new blocks onto the white output grid\n      for block_r, block_c, block_color in new_blocks_info:\n          paint_block(output_grid, block_r, block_c, 2, 2, block_color)\n    else:\n        # If the grid is too small, no blocks can be painted, return the white grid.\n        print(f\"Warning: Grid size ({H}x{W}) is too small to place 2x2 blocks.\")\n\n\n    # 6. Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5981,
    "candidates_token_count": 1577,
    "total_token_count": 7558,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.498554,
  "retries": null
}