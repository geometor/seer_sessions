{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_connected_component(grid, start_row, start_col):\n    \"\"\"\n    Finds all coordinates of the connected component of the same color\n    starting from (start_row, start_col) using Breadth-First Search (BFS).\n    Considers only 4-directional neighbors (up, down, left, right).\n\n    Args:\n        grid (np.array): The 2D grid of colors.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n\n    Returns:\n        set: A set of (row, col) tuples representing the coordinates\n             of the connected component. Returns an empty set if the\n             start coordinate is out of bounds.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Check if start coordinates are valid\n    if not (0 <= start_row < height and 0 <= start_col < width):\n        return set()\n\n    target_color = grid[start_row, start_col]\n    \n    q = deque([(start_row, start_col)])\n    visited = set([(start_row, start_col)])\n    component_coords = set()\n\n    while q:\n        r, c = q.popleft()\n        \n        # Add the current coordinate to the component set\n        component_coords.add((r, c))\n\n        # Explore neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check neighbor validity: within bounds, not visited, and matches target color\n            if 0 <= nr < height and 0 <= nc < width and \\\n               (nr, nc) not in visited and grid[nr, nc] == target_color:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                \n    return component_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies the connected color blobs originating from the four corners\n    of the input grid and swaps them diagonally. Specifically, the blob\n    originating from the top-left corner is swapped with the blob\n    originating from the bottom-right corner, and the blob originating\n    from the top-right corner is swapped with the blob originating from\n    the bottom-left corner. The pixels that do not belong to any of these\n    four corner blobs remain unchanged. The swap involves changing the\n    color of the pixels within each blob to the color of the diagonally\n    opposite corner's starting pixel.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid_np)\n\n    # Identify the colors at the four corner pixels\n    # These colors determine the target color for the respective swaps\n    c_tl = input_grid_np[0, 0]\n    c_tr = input_grid_np[0, width - 1]\n    c_bl = input_grid_np[height - 1, 0]\n    c_br = input_grid_np[height - 1, width - 1]\n\n    # Find the coordinates of the pixels belonging to each corner blob\n    # using the connected component finding helper function.\n    coords_tl = find_connected_component(input_grid_np, 0, 0)\n    coords_tr = find_connected_component(input_grid_np, 0, width - 1)\n    coords_bl = find_connected_component(input_grid_np, height - 1, 0)\n    coords_br = find_connected_component(input_grid_np, height - 1, width - 1)\n\n    # Create a map to track which corner blob each pixel belongs to.\n    # Initialize with -1 (meaning not part of any tracked corner blob).\n    # Indices: 0=TL, 1=TR, 2=BL, 3=BR\n    corner_map = np.full((height, width), -1, dtype=int) \n\n    # Populate the corner_map. Assign pixels to the first corner blob that finds them.\n    # This implicitly handles cases where blobs might touch or overlap,\n    # though the examples suggest distinct corner blobs.\n    for r, c in coords_tl:\n        corner_map[r, c] = 0 # Mark as belonging to Top-Left blob\n    for r, c in coords_tr:\n        if corner_map[r, c] == -1: # Only mark if not already assigned\n             corner_map[r, c] = 1 # Mark as belonging to Top-Right blob\n    for r, c in coords_bl:\n        if corner_map[r, c] == -1:\n             corner_map[r, c] = 2 # Mark as belonging to Bottom-Left blob\n    for r, c in coords_br:\n        if corner_map[r, c] == -1:\n             corner_map[r, c] = 3 # Mark as belonging to Bottom-Right blob\n\n    # Apply the color swaps to the output grid based on the corner_map.\n    for r in range(height):\n        for c in range(width):\n            origin_corner_index = corner_map[r, c]\n            # If the pixel belonged to the original Top-Left blob...\n            if origin_corner_index == 0: \n                output_grid[r, c] = c_br # ...change its color to the Bottom-Right corner's color.\n            # If the pixel belonged to the original Top-Right blob...\n            elif origin_corner_index == 1: \n                output_grid[r, c] = c_bl # ...change its color to the Bottom-Left corner's color.\n            # If the pixel belonged to the original Bottom-Left blob...\n            elif origin_corner_index == 2: \n                output_grid[r, c] = c_tr # ...change its color to the Top-Right corner's color.\n            # If the pixel belonged to the original Bottom-Right blob...\n            elif origin_corner_index == 3: \n                output_grid[r, c] = c_tl # ...change its color to the Top-Left corner's color.\n            # Else: The pixel wasn't part of any corner blob, so its color remains unchanged\n            # (already handled by initializing output_grid as a copy).\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1874,
    "candidates_token_count": 1566,
    "total_token_count": 3440,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 63.869531,
  "retries": null
}