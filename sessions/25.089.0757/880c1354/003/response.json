{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies the connected color blobs originating from the four corners\nof the input grid. It then recolors the pixels belonging to each of these original corner\nblobs. The new color applied to a blob's pixels is the original color found at the corner\nlocated clockwise relative to the blob's origin corner. Specifically:\n- Pixels originally part of the Top-Left (TL) corner blob are recolored with the original Bottom-Left (BL) corner color.\n- Pixels originally part of the Top-Right (TR) corner blob are recolored with the original Top-Left (TL) corner color.\n- Pixels originally part of the Bottom-Right (BR) corner blob are recolored with the original Top-Right (TR) corner color.\n- Pixels originally part of the Bottom-Left (BL) corner blob are recolored with the original Bottom-Right (BR) corner color.\nPixels that do not belong to any of these four initial corner blobs retain their original color.\n\"\"\"\n\ndef find_connected_component(grid, start_row, start_col):\n    \"\"\"\n    Finds all coordinates of the connected component of the same color\n    starting from (start_row, start_col) using Breadth-First Search (BFS).\n    Considers only 4-directional neighbors (up, down, left, right).\n\n    Args:\n        grid (np.array): The 2D grid of colors.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n\n    Returns:\n        set: A set of (row, col) tuples representing the coordinates\n             of the connected component. Returns an empty set if the\n             start coordinate is out of bounds or if the start pixel's\n             color is the background color (assuming 0 is background,\n             though this function doesn't strictly enforce that - it just\n             finds the component of whatever color is at the start).\n             Returns an empty set if the start coordinate is out of bounds.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Check if start coordinates are valid\n    if not (0 <= start_row < height and 0 <= start_col < width):\n        return set()\n\n    target_color = grid[start_row, start_col]\n    \n    # Optimization: If the target color is the most common one (often background),\n    # BFS can be slow. However, for this specific task, corner blobs are\n    # expected, so we proceed. If issues arise with large background components\n    # from corners, this might need adjustment.\n\n    q = deque([(start_row, start_col)])\n    visited = set([(start_row, start_col)])\n    component_coords = set()\n\n    while q:\n        r, c = q.popleft()\n        \n        # Add the current coordinate to the component set\n        component_coords.add((r, c))\n\n        # Explore neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check neighbor validity: within bounds, not visited, and matches target color\n            if 0 <= nr < height and 0 <= nc < width and \\\n               (nr, nc) not in visited and grid[nr, nc] == target_color:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                \n    return component_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies the connected color blobs originating from the four corners\n    of the input grid and recolors them based on a clockwise rotation of\n    the original corner colors.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # Create a copy of the input grid to modify; this will be the output\n    output_grid = np.copy(input_grid_np)\n\n    # Identify the colors at the four corner pixels\n    # These colors determine the target color for the respective clockwise swaps\n    c_tl = input_grid_np[0, 0]                  # Top-Left color\n    c_tr = input_grid_np[0, width - 1]         # Top-Right color\n    c_bl = input_grid_np[height - 1, 0]        # Bottom-Left color\n    c_br = input_grid_np[height - 1, width - 1] # Bottom-Right color\n\n    # Find the coordinates of the pixels belonging to each corner blob\n    # using the connected component finding helper function.\n    coords_tl = find_connected_component(input_grid_np, 0, 0)\n    coords_tr = find_connected_component(input_grid_np, 0, width - 1)\n    coords_bl = find_connected_component(input_grid_np, height - 1, 0)\n    coords_br = find_connected_component(input_grid_np, height - 1, width - 1)\n\n    # Create a map to track which corner blob each pixel belongs to.\n    # Initialize with -1 (meaning not part of any tracked corner blob).\n    # Indices: 0=TL, 1=TR, 2=BL, 3=BR\n    corner_map = np.full((height, width), -1, dtype=int) \n\n    # Populate the corner_map. Assign pixels to the first corner blob that finds them.\n    # The order matters if blobs overlap, but based on examples, they seem distinct.\n    # Assigning TL first, then TR, BL, BR.\n    for r, c in coords_tl:\n        corner_map[r, c] = 0 # Mark as belonging to Top-Left blob\n    for r, c in coords_tr:\n        if corner_map[r, c] == -1: # Only mark if not already assigned\n             corner_map[r, c] = 1 # Mark as belonging to Top-Right blob\n    for r, c in coords_bl:\n        if corner_map[r, c] == -1:\n             corner_map[r, c] = 2 # Mark as belonging to Bottom-Left blob\n    for r, c in coords_br:\n        if corner_map[r, c] == -1:\n             corner_map[r, c] = 3 # Mark as belonging to Bottom-Right blob\n\n    # Apply the color changes based on the clockwise rotation rule.\n    # Iterate through all pixels, check which corner blob (if any) they\n    # belonged to originally using corner_map, and assign the new color\n    # to the output grid.\n    for r in range(height):\n        for c in range(width):\n            origin_corner_index = corner_map[r, c]\n            \n            # If the pixel belonged to the original Top-Left blob...\n            if origin_corner_index == 0: \n                output_grid[r, c] = c_bl # ...change its color to the original Bottom-Left corner's color.\n            # If the pixel belonged to the original Top-Right blob...\n            elif origin_corner_index == 1: \n                output_grid[r, c] = c_tl # ...change its color to the original Top-Left corner's color.\n            # If the pixel belonged to the original Bottom-Left blob...\n            elif origin_corner_index == 2: \n                output_grid[r, c] = c_br # ...change its color to the original Bottom-Right corner's color.\n            # If the pixel belonged to the original Bottom-Right blob...\n            elif origin_corner_index == 3: \n                output_grid[r, c] = c_tr # ...change its color to the original Top-Right corner's color.\n            # Else (origin_corner_index == -1): \n            # The pixel wasn't part of any corner blob, so its color remains unchanged\n            # (already handled by initializing output_grid as a copy).\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4337,
    "candidates_token_count": 1910,
    "total_token_count": 6247,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.640675,
  "retries": null
}