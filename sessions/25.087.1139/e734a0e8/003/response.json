{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Grid Structure:** Determine the delimiter color (white, 0) and locate the horizontal and vertical delimiter lines. Use these lines to calculate the dimensions (height `cell_h`, width `cell_w`) of the cells within the grid and the top-left starting coordinates (`r_start`, `c_start`) for each cell.\n2.  **Extract Cell Patterns:** Iterate through each identified cell location, extract the content (subgrid) of that cell.\n3.  **Identify Source Pattern:** Store each unique cell pattern encountered and the coordinates of the cell(s) where it appears. The \"source pattern\" is defined as the cell pattern that appears in exactly one cell. Record the content of this source pattern and the coordinates of its cell.\n4.  **Generate Output:** Create the output grid as a copy of the input grid.\n5.  **Copy Source to Targets:** Iterate through all cell coordinates again. For every cell location *except* the source cell location, overwrite the cell's content in the output grid with the source pattern.\n6.  **Return Output:** Return the modified output grid.\n\"\"\"\n\ndef find_cell_structure(grid):\n    \"\"\"\n    Finds the delimiter color, cell dimensions, and cell start coordinates.\n    Assumes a regular grid structure delimited by a single color (usually 0).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (cell_h, cell_w, cell_start_rows, cell_start_cols, delimiter_color)\n               Returns (None, None, None, None, -1) if no clear structure is found.\n    \"\"\"\n    height, width = grid.shape\n    delimiter_color = 0 # Standard ARC delimiter\n\n    # Find horizontal and vertical delimiter lines\n    h_lines = [r for r in range(height) if np.all(grid[r, :] == delimiter_color)]\n    v_lines = [c for c in range(width) if np.all(grid[:, c] == delimiter_color)]\n\n    # Calculate cell dimensions based on spacing between delimiters\n    # Add boundaries to the list of lines\n    h_points = sorted(list(set([-1] + h_lines + [height])))\n    v_points = sorted(list(set([-1] + v_lines + [width])))\n\n    # Calculate gaps between lines\n    h_gaps = [h_points[i+1] - h_points[i] for i in range(len(h_points)-1)]\n    v_gaps = [v_points[i+1] - v_points[i] for i in range(len(v_points)-1)]\n\n    # Filter out gaps of size 1 (the delimiter lines themselves)\n    h_cell_gaps = [g for g in h_gaps if g > 1]\n    v_cell_gaps = [g for g in v_gaps if g > 1]\n\n    # Determine cell height and width (most common gap size)\n    # If no delimiters, the cell is the whole grid\n    cell_h = Counter(h_cell_gaps).most_common(1)[0][0] if h_cell_gaps else height\n    cell_w = Counter(v_cell_gaps).most_common(1)[0][0] if v_cell_gaps else width\n\n    # Determine cell start rows and columns (position after a delimiter or 0)\n    cell_start_rows = sorted(list(set([0] + [r + 1 for r in h_lines])))\n    cell_start_cols = sorted(list(set([0] + [c + 1 for c in v_lines])))\n\n    # Filter out starts that are outside the grid boundaries (can happen if line is at the edge)\n    cell_start_rows = [r for r in cell_start_rows if r < height]\n    cell_start_cols = [c for c in cell_start_cols if c < width]\n\n    # Basic sanity check\n    if not cell_start_rows or not cell_start_cols:\n        # If grid is only delimiter lines, or calculation failed?\n        # Treat as single cell if dimensions match grid size\n        if cell_h == height and cell_w == width:\n             return height, width, [0], [0], delimiter_color\n        else: # Unexpected structure\n             return None, None, None, None, delimiter_color\n\n\n    return cell_h, cell_w, cell_start_rows, cell_start_cols, delimiter_color\n\ndef get_cell_content(grid, r_start, c_start, cell_h, cell_w):\n    \"\"\"Extracts the content of a cell.\"\"\"\n    return grid[r_start : r_start + cell_h, c_start : c_start + cell_w]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: Finds a unique cell pattern (source) and copies\n    its content to all other cell locations in the grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = np.copy(input_grid_np)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Grid Structure\n    cell_h, cell_w, cell_start_rows, cell_start_cols, delim_color = find_cell_structure(input_grid_np)\n\n    # Handle cases where structure finding might fail or is trivial (single cell)\n    if cell_h is None or (len(cell_start_rows) == 1 and len(cell_start_cols) == 1):\n         # If only one cell, no copying is possible/needed. Return original.\n         return input_grid\n\n    # 2. & 3. Extract Cell Patterns and Identify Source\n    cell_patterns = defaultdict(list) # Store pattern_tuple -> list of (r, c) coords\n\n    for r_start in cell_start_rows:\n        for c_start in cell_start_cols:\n            # Ensure cell boundaries are valid before extracting\n            if r_start + cell_h <= height and c_start + cell_w <= width:\n                cell = get_cell_content(input_grid_np, r_start, c_start, cell_h, cell_w)\n                # Use tuple representation for hashing in the dictionary\n                cell_tuple = tuple(map(tuple, cell))\n                cell_patterns[cell_tuple].append((r_start, c_start))\n\n    # Find the source pattern (the one that appears exactly once)\n    source_pattern_tuple = None\n    source_coords = None\n    for pattern, coords_list in cell_patterns.items():\n        if len(coords_list) == 1:\n            source_pattern_tuple = pattern\n            source_coords = coords_list[0] # Get the single (r, c) tuple\n            break # Assume only one unique pattern exists based on examples\n\n    if source_pattern_tuple is None:\n        # No unique pattern found, maybe all cells are the same or structure is wrong?\n        # Return the original grid in this case.\n        return input_grid\n\n    # Convert source pattern tuple back to numpy array for writing\n    source_pattern_np = np.array(source_pattern_tuple, dtype=int)\n    source_r, source_c = source_coords\n\n    # 4. & 5. Copy Source to Targets\n    for r_start in cell_start_rows:\n        for c_start in cell_start_cols:\n            # Check if the current cell is NOT the source cell\n            if r_start == source_r and c_start == source_c:\n                continue # Skip the source cell itself\n\n            # Ensure target cell boundaries are valid before writing\n            if r_start + cell_h <= height and c_start + cell_w <= width:\n                # Overwrite the target cell area in the output grid with the source pattern\n                output_grid_np[r_start : r_start + cell_h, c_start : c_start + cell_w] = source_pattern_np\n\n    # 6. Return the result\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7882,
    "candidates_token_count": 1895,
    "total_token_count": 9777,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 118.780591,
  "retries": null
}