{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  **Analyze Grid Structure:** Identify the delimiter color (white, 0) and the grid lines formed by this color. Determine the uniform height (`cell_h`) and width (`cell_w`) of the cells (subgrids) delimited by these lines, accounting for the 1-pixel thickness of the delimiters. Identify the top-left starting coordinates (`r_start`, `c_start`) of each cell.\n2.  **Extract Cell Patterns:** Iterate through each identified cell location. Extract the `cell_h` x `cell_w` subgrid (pattern) from each cell. Record each unique pattern found and the list of coordinates where it appears. Check if each pattern contains the delimiter color.\n3.  **Identify Source Pattern:** Find the pattern that appears in exactly one cell location. This is the \"source pattern\". Store its content.\n4.  **Identify Target Cells:** Examine every cell location in the input grid. A cell is identified as a \"target cell\" if its pattern meets two conditions:\n    *   a) It is *not* the source pattern.\n    *   b) Its pattern contains at least one pixel matching the delimiter color (white, 0).\n5.  **Construct Output Grid:** Create the output grid as a copy of the input grid.\n6.  **Apply Replacement:** Iterate through the coordinates of all identified \"target cells\". For each target cell location, replace the corresponding `cell_h` x `cell_w` area in the output grid with the source pattern. Cells that are not target cells (including the original source cell and any cells whose patterns do not contain the delimiter color) remain unchanged from the input grid.\n7.  **Return Output:** Return the modified output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_cell_structure(grid):\n    \"\"\"\n    Finds the delimiter color, cell dimensions (accounting for delimiter thickness),\n    and cell start coordinates. Assumes a regular grid structure delimited by a\n    single color (usually 0) with a thickness of 1.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (cell_h, cell_w, cell_start_rows, cell_start_cols, delimiter_color)\n               Returns (None, None, None, None, -1) if no clear structure is found or grid is empty.\n    \"\"\"\n    height, width = grid.shape\n    if height == 0 or width == 0:\n        return None, None, None, None, -1 # Empty grid\n\n    delimiter_color = 0 # Standard ARC delimiter\n\n    # Find horizontal and vertical delimiter lines\n    h_lines = [r for r in range(height) if np.all(grid[r, :] == delimiter_color)]\n    v_lines = [c for c in range(width) if np.all(grid[:, c] == delimiter_color)]\n\n    # Add boundaries to the list of lines\n    h_points = sorted(list(set([-1] + h_lines + [height])))\n    v_points = sorted(list(set([-1] + v_lines + [width])))\n\n    # Calculate gaps between lines (including delimiter thickness)\n    h_gaps = [h_points[i+1] - h_points[i] for i in range(len(h_points)-1)]\n    v_gaps = [v_points[i+1] - v_points[i] for i in range(len(v_points)-1)]\n\n    # Filter out gaps of size 1 (the delimiter lines themselves)\n    # These remaining gaps represent cell_dimension + delimiter_thickness (1)\n    h_cell_gaps_with_delim = [g for g in h_gaps if g > 1]\n    v_cell_gaps_with_delim = [g for g in v_gaps if g > 1]\n\n    # Determine cell height and width by taking the most common gap size and subtracting 1 (for the delimiter)\n    # If no delimiters, the cell is the whole grid\n    if h_cell_gaps_with_delim:\n        most_common_h_gap = Counter(h_cell_gaps_with_delim).most_common(1)[0][0]\n        cell_h = most_common_h_gap - 1\n    else:\n        cell_h = height # No horizontal delimiters\n\n    if v_cell_gaps_with_delim:\n        most_common_v_gap = Counter(v_cell_gaps_with_delim).most_common(1)[0][0]\n        cell_w = most_common_v_gap - 1\n    else:\n        cell_w = width # No vertical delimiters\n\n    # Ensure calculated dimensions are positive\n    if cell_h <= 0 or cell_w <= 0:\n        # This might happen if the gaps are only size 1 (all delimiters) or calculation failed\n         # Fallback: treat as single cell if no delimiters were found initially\n        if not h_lines and not v_lines:\n            return height, width, [0], [0], delimiter_color\n        else: # Structure is unclear or only delimiters\n             return None, None, None, None, delimiter_color\n\n\n    # Determine cell start rows and columns (position after a delimiter or 0)\n    # Handle case where grid starts immediately with content (no leading delimiter)\n    cell_start_rows = [0] if not h_lines or h_lines[0] != 0 else []\n    cell_start_rows.extend([r + 1 for r in h_lines if r + 1 < height])\n    cell_start_rows = sorted(list(set(r for r in cell_start_rows if r < height))) # Ensure within bounds\n\n\n    cell_start_cols = [0] if not v_lines or v_lines[0] != 0 else []\n    cell_start_cols.extend([c + 1 for c in v_lines if c + 1 < width])\n    cell_start_cols = sorted(list(set(c for c in cell_start_cols if c < width))) # Ensure within bounds\n\n    # Basic sanity check\n    if not cell_start_rows or not cell_start_cols:\n         # If grid is only delimiter lines, or calculation failed?\n         # Re-check if it should be treated as a single cell\n         if cell_h == height and cell_w == width and not h_lines and not v_lines:\n             return height, width, [0], [0], delimiter_color\n         else: # Unexpected structure\n              return None, None, None, None, delimiter_color\n\n    # Filter start rows/cols to only include those where a cell of expected size can actually start\n    valid_start_rows = [r for r in cell_start_rows if r + cell_h <= height]\n    valid_start_cols = [c for c in cell_start_cols if c + cell_w <= width]\n\n    # If filtering removed all starts, something is wrong\n    if not valid_start_rows or not valid_start_cols:\n         # One last check: maybe it's a single cell grid without delimiters\n         if not h_lines and not v_lines and cell_h == height and cell_w == width:\n             return height, width, [0], [0], delimiter_color\n         return None, None, None, None, delimiter_color\n\n\n    return cell_h, cell_w, valid_start_rows, valid_start_cols, delimiter_color\n\ndef get_cell_content(grid, r_start, c_start, cell_h, cell_w):\n    \"\"\"Extracts the content of a cell.\"\"\"\n    height, width = grid.shape\n    # We assume r_start, c_start, cell_h, cell_w are valid based on find_cell_structure\n    end_r = r_start + cell_h\n    end_c = c_start + cell_w\n    return grid[r_start : end_r, c_start : end_c]\n\ndef pattern_contains_delimiter(pattern_np, delimiter_color):\n    \"\"\"Checks if a numpy pattern array contains the delimiter color.\"\"\"\n    return np.any(pattern_np == delimiter_color)\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding a unique source pattern and copying it\n    onto cells whose original pattern contained the delimiter color (white, 0).\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = np.copy(input_grid_np) # Create the output grid template\n    height, width = input_grid_np.shape\n\n    # 1. Analyze Grid Structure\n    cell_h, cell_w, cell_start_rows, cell_start_cols, delim_color = find_cell_structure(input_grid_np)\n\n    # If structure is not found or grid is essentially a single cell, return original\n    if cell_h is None or (len(cell_start_rows) * len(cell_start_cols) <= 1):\n         return input_grid # No transformation possible/needed\n\n    # 2. Extract Cell Patterns & Check for Delimiter\n    # Stores pattern_tuple -> {'coords': list_of_(r,c), 'contains_delim': bool}\n    cell_patterns_info = defaultdict(lambda: {'coords': [], 'contains_delim': False})\n\n    for r_start in cell_start_rows:\n        for c_start in cell_start_cols:\n             # Extract cell content\n             cell = get_cell_content(input_grid_np, r_start, c_start, cell_h, cell_w)\n\n             # Check if extracted cell actually has the expected dimensions\n             # This handles potential issues with uneven grids if find_cell_structure logic isn't perfect\n             if cell.shape == (cell_h, cell_w):\n                # Use tuple representation for hashing in the dictionary\n                cell_tuple = tuple(map(tuple, cell))\n                cell_patterns_info[cell_tuple]['coords'].append((r_start, c_start))\n                # Check for delimiter only once per unique pattern\n                if not cell_patterns_info[cell_tuple]['contains_delim']:\n                     cell_patterns_info[cell_tuple]['contains_delim'] = pattern_contains_delimiter(cell, delim_color)\n\n\n    # 3. Identify Source Pattern\n    source_pattern_tuple = None\n    source_pattern_np = None\n    for pattern_tuple, info in cell_patterns_info.items():\n        if len(info['coords']) == 1:\n            source_pattern_tuple = pattern_tuple\n            source_pattern_np = np.array(pattern_tuple, dtype=int)\n            break # Assume only one unique pattern exists based on examples\n\n    if source_pattern_tuple is None:\n        # No unique pattern found. This might be an edge case or error.\n        # Return the original grid as no clear source is defined.\n        return input_grid\n\n    # 4. Identify Target Cell Locations\n    target_locations = []\n    for pattern_tuple, info in cell_patterns_info.items():\n        # A pattern corresponds to target locations if:\n        # a) It's NOT the source pattern\n        # b) It contains the delimiter color\n        if pattern_tuple != source_pattern_tuple and info['contains_delim']:\n            target_locations.extend(info['coords']) # Add all locations with this pattern\n\n    # 5. & 6. Construct Output Grid & Apply Replacement\n    # Output grid is already a copy. Now overwrite target locations.\n    for r_start, c_start in target_locations:\n        # Ensure target cell boundaries are valid before writing\n        # (Should be guaranteed by how start rows/cols and locations were determined)\n        if r_start + cell_h <= height and c_start + cell_w <= width:\n            # Overwrite the target cell area in the output grid with the source pattern\n            output_grid_np[r_start : r_start + cell_h, c_start : c_start + cell_w] = source_pattern_np\n\n    # 7. Return the result\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16277,
    "candidates_token_count": 2813,
    "total_token_count": 19090,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.455121,
  "retries": null
}