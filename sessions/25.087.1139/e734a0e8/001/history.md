
## train_1

**input:**
```
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 0 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 0 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 9 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7 0 7 7 0 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 9 9 9 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 9 7 7 7 0 7 7 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 0 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 0 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 0 7 7 7 9 9 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 9 9 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 9 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 7 7 0 7 7 7 9 9 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 9 9 9 7 0 7 7 7 7 7 0 7 7 7 7 7
7 7 7 7 7 0 7 9 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 9 0 7 7 7 9 9
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 9 7
7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7 0 7 7 7 9 7
7 7 7 7 7 0 7 7 7 7 7 0 7 9 9 9 7 0 7 9 9 9 7
7 7 7 7 7 0 7 7 7 7 7 0 7 9 7 7 7 0 7 9 7 7 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 7 7 9 9 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 9
7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7
7 7 7 9 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 7 7 9 7
7 9 9 9 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 9 9 9 7
7 9 7 7 7 0 7 7 7 7 7 0 7 7 7 7 7 0 7 9 7 7 7
```


## train_2

**input:**
```
7 2 7 0 7 7 7 0 7 7 7
7 2 7 0 7 7 7 0 7 7 7
7 2 7 0 7 7 7 0 7 7 7
0 0 0 0 0 0 0 0 0 0 0
7 7 7 0 7 7 7 0 7 7 7
7 7 7 0 7 0 7 0 7 7 7
7 7 7 0 7 7 7 0 7 7 7
0 0 0 0 0 0 0 0 0 0 0
7 7 7 0 7 7 7 0 7 7 7
7 7 7 0 7 0 7 0 7 0 7
7 7 7 0 7 7 7 0 7 7 7
```


**output:**
```
7 2 7 0 7 7 7 0 7 7 7
7 2 7 0 7 7 7 0 7 7 7
7 2 7 0 7 7 7 0 7 7 7
0 0 0 0 0 0 0 0 0 0 0
7 7 7 0 7 2 7 0 7 7 7
7 7 7 0 7 2 7 0 7 7 7
7 7 7 0 7 2 7 0 7 7 7
0 0 0 0 0 0 0 0 0 0 0
7 7 7 0 7 2 7 0 7 2 7
7 7 7 0 7 2 7 0 7 2 7
7 7 7 0 7 2 7 0 7 2 7
```

Okay, let's break down this task.

**Perception of the Elements:**

1.  **Grid Structure:** Both examples feature input grids composed primarily of an orange background (7) segmented into smaller, equal-sized cells by white lines (0).
    *   Example 1: 23x23 grid divided into 5x5 cells by white lines, forming a 4x4 grid of cells.
    *   Example 2: 11x11 grid divided into 3x3 cells by white lines, forming a 3x3 grid of cells.
2.  **Cell Content:** Most cells initially contain only the orange background color (7).
3.  **Unique Pattern:** In each input grid, exactly one cell contains a distinct shape made of a non-background, non-gridline color.
    *   Example 1: A maroon (9) shape in one 5x5 cell.
    *   Example 2: A red (2) vertical line in one 3x3 cell.
4.  **Transformation:** The core transformation involves identifying this unique pattern shape and replicating it into all the cells that initially contained *only* the background color.
5.  **Preservation:** The original pattern shape in its source cell remains unchanged. The white grid lines remain unchanged. Any cells that contained miscellaneous pixels different from the main pattern (like the scattered orange pixels in example 1, which were actually just the background color) are also treated as target cells for the pattern replication if they don't constitute a distinct *shape* of a different color. However, re-examining Example 1, the cells with only orange (7) *are* the ones getting filled. The cells with stray non-orange colors (none in these examples, but hypothetically) would likely be left alone. The critical factor seems to be identifying the *single* cell containing a non-background shape.

**Facts:**


```yaml
elements:
  - object: grid
    properties:
      - segmented by white (0) lines into smaller cells
      - primary background color is orange (7)
  - object: cell
    properties:
      - subgrid within the main grid
      - defined by white (0) delimiters
      - size is consistent within a given grid (e.g., 5x5 or 3x3)
  - object: pattern_shape
    properties:
      - composed of a single color different from white (0) and orange (7)
      - exists in exactly one cell in the input grid
      - can be any shape (e.g., cluster of maroon '9's, red '2' line)
relationships:
  - white (0) lines define the boundaries of cells.
  - pattern_shape is located within one source cell.
  - target cells are those containing only the background orange (7).
actions:
  - identify: grid structure (cell size, delimiter lines)
  - identify: the unique pattern_shape and its source cell
  - identify: target cells (containing only background color)
  - copy: the pattern_shape from the source cell
  - paste: the copied pattern_shape into each target cell, replacing the background color pixels at corresponding positions.
  - preserve: original source cell, grid lines, and any cells not identified as targets.
```


**Natural Language Program:**

1.  Analyze the input grid to determine the repeating structure: identify the color used for grid lines (white 0) and deduce the size of the cells they delineate.
2.  Scan each delineated cell to find its contents, ignoring the background color (orange 7).
3.  Identify the single cell that contains a shape composed of colors other than the background (orange 7) or grid lines (white 0). This is the "source cell", and the shape within it is the "pattern shape".
4.  Create the output grid, initially identical to the input grid.
5.  Iterate through all cells in the grid again.
6.  For each cell, check if it contains *only* the background color (orange 7).
7.  If a cell contains only the background color, overlay the "pattern shape" (copied from the source cell) onto this cell in the output grid. The pixels of the pattern shape should replace the corresponding background pixels within that cell's boundaries.
8.  Leave the source cell, the grid lines, and any cells that did not contain *only* the background color unchanged from the input grid.
9.  Return the completed output grid.
