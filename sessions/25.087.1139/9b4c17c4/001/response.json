{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous objects of red (2) pixels within the input grid.\nDetermines the background color (blue (1) or gray (8)) immediately surrounding each red object.\nMoves each red object horizontally to an edge of the grid based on its background color:\n- If the background is gray (8), the object moves to the left edge (column 0), aligning its leftmost pixel with column 0.\n- If the background is blue (1), the object moves to the right edge (last column), aligning its rightmost pixel with the last column index.\nThe object's shape, size, and vertical position (row indices) are preserved during the move.\nThe original background layout (blue and gray areas) is maintained, except where objects are moved from or to.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects. Each object is represented as a list of\n              pixel coordinates [(row1, col1), (row2, col2), ...]. Returns\n              an empty list if no objects of the specified color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # Check if the current cell has the target color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                # Found the start of a new object, begin BFS\n                current_object_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_pixels.append((curr_r, curr_c))\n                    # Explore 4 adjacent neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if the neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                # Add the completed object's pixels to the list if it's not empty\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n    return objects\n\ndef get_background_color(grid, obj_pixels):\n    \"\"\"\n    Determines the background color immediately surrounding a given object.\n    It checks the neighbors of the object's pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_pixels (list): List of coordinates [(r, c)] for the object pixels.\n\n    Returns:\n        int: The background color (e.g., 1 for blue, 8 for gray).\n             Returns -1 if no non-object neighbor is found (should not happen\n             based on task constraints).\n    \"\"\"\n    height, width = grid.shape\n    object_color = 2 # We are looking for neighbors of red objects\n    object_coords_set = set(obj_pixels) # Use a set for efficient neighbor checking\n\n    # Iterate through each pixel belonging to the object\n    for r, c in obj_pixels:\n        # Check its 4 adjacent neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is NOT part of the object itself\n                if (nr, nc) not in object_coords_set:\n                     neighbor_color = grid[nr, nc]\n                     # Return the color of the first valid non-object neighbor found\n                     # Assumes the background is consistent around the object.\n                     return neighbor_color\n                     \n    # Fallback case: Should not be reached if objects always have non-object neighbors\n    print(f\"Warning: No background neighbor found for object starting at {obj_pixels[0] if obj_pixels else 'N/A'}\")\n    return -1\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding red objects, determining their\n    surrounding background color, and moving them horizontally to the\n    grid edge corresponding to that background color (left for gray,\n    right for blue), preserving shape and vertical position.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # Create the output grid, initially as a copy of the input\n    output_grid = input_grid_np.copy()\n\n    # Find all distinct red (color 2) objects in the input grid\n    red_objects = find_objects(input_grid_np, 2)\n\n    # Process each found red object\n    for obj_pixels in red_objects:\n        # Skip if the object finding somehow returned an empty list\n        if not obj_pixels:\n            continue\n\n        # Determine the background color surrounding this object\n        background_color = get_background_color(input_grid_np, obj_pixels)\n        \n        # If a valid background color wasn't found, skip this object (with a warning)\n        if background_color == -1 or background_color == 2: # Should be 1 or 8\n             print(f\"Warning: Could not determine valid background (found {background_color}) for object at {obj_pixels[0]}\")\n             continue # Skip processing this object\n\n        # Find the min/max column indices to know the object's horizontal span and reference points\n        min_c = min(c for r, c in obj_pixels)\n        max_c = max(c for r, c in obj_pixels)\n\n        # Erase the object from its original position in the output grid.\n        # Fill the original object locations with their determined background color.\n        for r, c in obj_pixels:\n            output_grid[r, c] = background_color\n\n        # Calculate the required horizontal shift (column offset) based on the background color\n        offset_c = 0\n        if background_color == 8:  # Gray background: move object to left edge\n            # Shift needed to align the object's leftmost pixel (min_c) with column 0\n            offset_c = 0 - min_c\n        elif background_color == 1:  # Blue background: move object to right edge\n            # Shift needed to align the object's rightmost pixel (max_c) with the last column (width - 1)\n            offset_c = (width - 1) - max_c\n        # Note: No 'else' needed here due to the check after get_background_color\n\n        # Draw the object (color 2) at its new, shifted position in the output grid\n        for r, c in obj_pixels:\n            new_c = c + offset_c\n            # Ensure the new column index is within the grid's width bounds\n            if 0 <= new_c < width:\n                output_grid[r, new_c] = 2 # Draw the red pixel at the new location\n            else:\n                # This should ideally not happen if calculations are correct and objects fit\n                 print(f\"Warning: Pixel ({r},{c})'s new calculated column {new_c} is out of bounds [0, {width-1}]\")\n\n    # Convert the final numpy array grid back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4594,
    "candidates_token_count": 1920,
    "total_token_count": 6514,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.429937,
  "retries": null
}