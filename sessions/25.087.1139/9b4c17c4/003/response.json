{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous red (2) objects. For each object, determines the color \n(blue=1 or gray=8) of the immediately surrounding background region. Finds the \nhorizontal boundaries (min and max column) of that specific background region. \nMoves the red object horizontally:\n- If the background is gray (8), the object moves so its leftmost pixel aligns \n  with the minimum column index of the gray background region.\n- If the background is blue (1), the object moves so its rightmost pixel aligns \n  with the maximum column index of the blue background region.\nThe object's shape, size, and vertical position are preserved. The original \nlocation is filled with the background color. Other grid areas remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects. Each object is represented as a list of\n              pixel coordinates [(row1, col1), (row2, col2), ...]. Returns\n              an empty list if no objects of the specified color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # Check if the current cell has the target color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                # Found the start of a new object, begin BFS\n                current_object_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_object_pixels.append((curr_r, curr_c))\n                    # Explore 4 adjacent neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if the neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                # Add the completed object's pixels to the list if it's not empty\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n    return objects\n\ndef get_background_info(grid, obj_pixels):\n    \"\"\"\n    Determines the background color immediately surrounding a given object and\n    finds one coordinate within that background region.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_pixels (list): List of coordinates [(r, c)] for the object pixels.\n\n    Returns:\n        tuple: (background_color, background_coord) where background_coord\n               is a tuple (r, c) of a pixel adjacent to the object belonging\n               to the background. Returns (-1, None) if no non-object neighbor\n               is found or if the neighbor is the object color itself.\n    \"\"\"\n    height, width = grid.shape\n    object_color = 2 # Color of the object we are checking neighbors for\n    object_coords_set = set(obj_pixels) # Use a set for efficient neighbor checking\n\n    # Iterate through each pixel belonging to the object\n    for r, c in obj_pixels:\n        # Check its 4 adjacent neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is NOT part of the object itself\n                if (nr, nc) not in object_coords_set:\n                     neighbor_color = grid[nr, nc]\n                     # We expect background colors 1 (blue) or 8 (gray)\n                     if neighbor_color != object_color:\n                         return neighbor_color, (nr, nc) # Return color and a coordinate\n\n    # Fallback case: No valid background neighbor found\n    print(f\"Warning: No valid background neighbor found for object starting at {obj_pixels[0] if obj_pixels else 'N/A'}\")\n    return -1, None\n\n\ndef find_background_region_bounds(grid, start_coord, background_color):\n    \"\"\"\n    Finds the minimum and maximum column indices of a contiguous region\n    of a specific background color, starting from a given coordinate. Uses BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        start_coord (tuple): A coordinate (r, c) known to be in the region.\n        background_color (int): The color of the background region to trace.\n\n    Returns:\n        tuple: (min_col, max_col) representing the horizontal bounds of the region.\n               Returns (start_coord[1], start_coord[1]) if the region is just\n               the start coordinate or if start_coord is invalid.\n    \"\"\"\n    height, width = grid.shape\n    if not (0 <= start_coord[0] < height and 0 <= start_coord[1] < width and grid[start_coord] == background_color):\n        # Handle cases where the start coordinate is invalid\n        print(f\"Warning: Invalid start_coord {start_coord} or color mismatch for find_background_region_bounds.\")\n        # Attempt to return a minimal valid bound if possible, otherwise indicate error potential\n        if 0 <= start_coord[1] < width:\n           return (start_coord[1], start_coord[1])\n        else:\n           return (0, 0) # Or raise an error\n\n\n    visited = np.zeros_like(grid, dtype=bool)\n    q = deque([start_coord])\n    visited[start_coord] = True\n    min_c = start_coord[1]\n    max_c = start_coord[1]\n\n    while q:\n        curr_r, curr_c = q.popleft()\n\n        # Update horizontal bounds\n        min_c = min(min_c, curr_c)\n        max_c = max(max_c, curr_c)\n\n        # Explore 4 adjacent neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check if the neighbor is within grid bounds, has the background color, and hasn't been visited\n            if (0 <= nr < height and 0 <= nc < width and\n                    grid[nr, nc] == background_color and not visited[nr, nc]):\n                visited[nr, nc] = True\n                q.append((nr, nc))\n\n    return min_c, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving red objects horizontally within their\n    respective background regions (blue or gray) to the region's edge.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Create the output grid, initially as a copy of the input\n    output_grid = input_grid_np.copy()\n\n    # Find all distinct red (color 2) objects in the input grid\n    red_objects = find_objects(input_grid_np, 2)\n\n    # Process each found red object\n    for obj_pixels in red_objects:\n        # Skip if the object finding somehow returned an empty list\n        if not obj_pixels:\n            continue\n\n        # Determine the background color and a starting coordinate within it\n        background_color, bg_start_coord = get_background_info(input_grid_np, obj_pixels)\n\n        # Check if valid background info was found\n        if background_color == -1 or bg_start_coord is None:\n            print(f\"Warning: Could not determine valid background info for object at {obj_pixels[0]}. Skipping object.\")\n            continue # Skip processing this object\n\n        # We only handle blue (1) and gray (8) backgrounds as per the examples\n        if background_color not in [1, 8]:\n            print(f\"Warning: Unexpected background color {background_color} found for object at {obj_pixels[0]}. Skipping object.\")\n            continue\n\n        # Find the horizontal boundaries of this specific background region\n        min_bg_c, max_bg_c = find_background_region_bounds(input_grid_np, bg_start_coord, background_color)\n\n        # Find the min/max column indices of the red object itself\n        min_obj_c = min(c for r, c in obj_pixels)\n        max_obj_c = max(c for r, c in obj_pixels)\n\n        # Calculate the required horizontal shift (column offset)\n        offset_c = 0\n        if background_color == 8:  # Gray background: move object to left edge of region\n            offset_c = min_bg_c - min_obj_c\n        elif background_color == 1:  # Blue background: move object to right edge of region\n            offset_c = max_bg_c - max_obj_c\n            \n        # --- Apply Transformation ---\n        \n        # 1. Erase the object from its original position in the output grid.\n        # Fill the original object locations with their determined background color.\n        for r, c in obj_pixels:\n             # Check bounds just in case, though r,c should be valid from find_objects\n             if 0 <= r < height and 0 <= c < width:\n                 output_grid[r, c] = background_color\n\n        # 2. Draw the object (color 2) at its new, shifted position in the output grid\n        for r, c in obj_pixels:\n            new_c = c + offset_c\n            # Ensure the new column index is within the grid's width bounds\n            if 0 <= new_c < width:\n                 # Check bounds for row as well\n                 if 0 <= r < height:\n                     output_grid[r, new_c] = 2 # Draw the red pixel at the new location\n            else:\n                # This might happen if region detection or shift calculation is flawed\n                 print(f\"Warning: Pixel ({r},{c})'s new calculated column {new_c} is out of bounds [0, {width-1}] during draw\")\n\n    # Convert the final numpy array grid back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8878,
    "candidates_token_count": 2614,
    "total_token_count": 11492,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.202567,
  "retries": null
}