{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a red rectangular frame (color 2) and internal gray content objects (color 5).\nThe transformation involves moving and reflecting these internal objects based on the aspect ratio of the frame's inner space.\n\n1.  **Identify Frame & Inner Space:** Locate the bounding box of all red (2) pixels. Define the 'inner space' as the area one pixel inside this bounding box. If no frame exists or the inner space is invalid, return the original grid.\n2.  **Determine Reflection Rule:** Calculate the height (H) and width (W) of the inner space.\n    *   If W >= H (wider or square): Reflection axis is vertical (objects reflect horizontally). Placement will be Left/Right.\n    *   If H > W (taller): Reflection axis is horizontal (objects reflect vertically). Placement will be Top/Bottom.\n3.  **Identify & Filter Internal Content:** Find all gray (5) objects (4-connectivity). Select only those strictly inside the frame's outer bounding box.\n4.  **Process Each Internal Object:**\n    *   Calculate the object's center relative to the inner space's center.\n    *   Erase the object from its original position within the output grid.\n    *   Create a subgrid containing just the object.\n    *   **If Horizontal Reflection (W >= H):**\n        *   Reflect the object subgrid horizontally (np.fliplr).\n        *   Determine placement side based on the object's horizontal position relative to the inner space center:\n            *   If object center is left of or at the inner center column: Place Left.\n            *   If object center is right of the inner center column: Place Right.\n        *   Calculate the top-left corner for the reflected object:\n            *   Left Placement: Column = frame_min_c - 1 - object_width. Row = object_min_r.\n            *   Right Placement: Column = frame_max_c + 2. Row = object_min_r.\n    *   **If Vertical Reflection (H > W):**\n        *   Reflect the object subgrid vertically (np.flipud).\n        *   Determine placement side based on the object's vertical position relative to the inner space center:\n            *   If object center is above or at the inner center row: Place Top.\n            *   If object center is below the inner center row: Place Bottom.\n        *   Calculate the top-left corner for the reflected object:\n            *   Top Placement: Row = frame_min_r - 1 - object_height. Column = object_min_c.\n            *   Bottom Placement: Row = frame_max_r + 2. Column = object_min_c.\n    *   Draw the reflected object onto the output grid at the calculated position, ensuring it doesn't overwrite the frame and stays within grid bounds.\n5.  Objects outside the frame and the frame itself remain unchanged in the output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color, connectivity=4):\n    \"\"\"\n    Finds all connected objects of a given color using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n        connectivity (int): 4 or 8 for neighbor connectivity.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (list of (r, c) tuples),\n              'bbox' (dictionary with min_r, max_r, min_c, max_c), and 'color'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    else: # Assume 8-connectivity\n        neighbors = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_coords: # Only add if we found coordinates\n                    objects.append({\n                        'coords': obj_coords,\n                        'bbox': {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c},\n                        'color': color\n                    })\n    return objects\n\ndef get_frame_bbox(grid, frame_color=2):\n    \"\"\"\n    Determines the bounding box of the frame structure.\n    Assumes the frame is formed by the extent of all pixels of frame_color.\n    Returns None if no frame pixels are found.\n    \"\"\"\n    coords = np.argwhere(grid == frame_color)\n    if coords.size == 0:\n        return None\n    min_r = np.min(coords[:, 0])\n    max_r = np.max(coords[:, 0])\n    min_c = np.min(coords[:, 1])\n    max_c = np.max(coords[:, 1])\n    return {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c}\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on frame inner aspect ratio.\n    \"\"\"\n    \n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n    frame_color = 2\n    content_color = 5\n    background_color = 0\n\n    # --- Step 1: Identify the Frame ---\n    frame_bbox = get_frame_bbox(input_grid_np, frame_color)\n    if frame_bbox is None:\n        # No frame found, return original grid\n        return input_grid # Return original list grid\n\n    # --- Step 2: Define Inner Space ---\n    inner_min_r = frame_bbox['min_r'] + 1\n    inner_max_r = frame_bbox['max_r'] - 1\n    inner_min_c = frame_bbox['min_c'] + 1\n    inner_max_c = frame_bbox['max_c'] - 1\n\n    # Check if inner space is valid (frame must be at least 3x3)\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n         # Frame too small for an inner space, return original grid.\n         return input_grid # Return original list grid\n\n    # --- Step 3: Determine Reflection Rule ---\n    inner_height = inner_max_r - inner_min_r + 1\n    inner_width = inner_max_c - inner_min_c + 1\n    \n    # Reflect horizontally if wider or square (placement Left/Right)\n    reflect_horizontally = (inner_width >= inner_height) \n    inner_center_c = (inner_min_c + inner_max_c) / 2.0\n    inner_center_r = (inner_min_r + inner_max_r) / 2.0\n\n    # --- Step 4: Identify Content Objects ---\n    content_objects = find_objects(input_grid_np, content_color, connectivity=4)\n\n    # --- Step 5: Filter Internal Objects ---\n    internal_objects = []\n    for obj in content_objects:\n        is_internal = True\n        if not obj['coords']: \n             is_internal = False\n        else:\n            # Check if all coordinates are strictly inside the frame's outer box\n            for r, c in obj['coords']:\n                if not (frame_bbox['min_r'] < r < frame_bbox['max_r'] and\n                        frame_bbox['min_c'] < c < frame_bbox['max_c']):\n                    is_internal = False\n                    break\n        if is_internal:\n            internal_objects.append(obj)\n\n    # --- Step 6: Process Each Internal Object ---\n    for obj in internal_objects:\n        coords = obj['coords']\n        obj_bbox = obj['bbox']\n        obj_height = obj_bbox['max_r'] - obj_bbox['min_r'] + 1\n        obj_width = obj_bbox['max_c'] - obj_bbox['min_c'] + 1\n        \n        # Calculate object center\n        obj_center_c = (obj_bbox['min_c'] + obj_bbox['max_c']) / 2.0\n        obj_center_r = (obj_bbox['min_r'] + obj_bbox['max_r']) / 2.0\n\n        # --- Step 6a: Erase Original ---\n        for r, c in coords:\n            output_grid[r, c] = background_color\n\n        # --- Step 6b: Create object subgrid ---\n        obj_grid = np.zeros((obj_height, obj_width), dtype=int)\n        for r, c in coords:\n            rel_r = r - obj_bbox['min_r']\n            rel_c = c - obj_bbox['min_c']\n            # Ensure relative coordinates are within the subgrid bounds\n            if 0 <= rel_r < obj_height and 0 <= rel_c < obj_width:\n                 obj_grid[rel_r, rel_c] = content_color\n        \n        # --- Step 6c: Apply Reflection and Determine Placement ---\n        reflected_obj_grid = None\n        new_top_left_r, new_top_left_c = -1, -1\n        \n        if reflect_horizontally: # Reflect horizontally, place Left/Right\n            reflected_obj_grid = np.fliplr(obj_grid)\n            # Determine placement based on object center vs inner center column\n            if obj_center_c <= inner_center_c: # Place Left (tie goes to Left)\n                new_top_left_r = obj_bbox['min_r'] # Align vertically\n                new_top_left_c = frame_bbox['min_c'] - 1 - obj_width # Place left of frame with 1 gap\n            else: # Place Right\n                new_top_left_r = obj_bbox['min_r'] # Align vertically\n                new_top_left_c = frame_bbox['max_c'] + 2 # Place right of frame with 1 gap\n        \n        else: # Reflect Vertically (H > W), place Top/Bottom\n            reflected_obj_grid = np.flipud(obj_grid)\n            # Determine placement based on object center vs inner center row\n            if obj_center_r <= inner_center_r: # Place Top (tie goes to Top)\n                new_top_left_r = frame_bbox['min_r'] - 1 - obj_height # Place above frame with 1 gap\n                new_top_left_c = obj_bbox['min_c'] # Align horizontally\n            else: # Place Bottom\n                new_top_left_r = frame_bbox['max_r'] + 2 # Place below frame with 1 gap\n                new_top_left_c = obj_bbox['min_c'] # Align horizontally\n\n        # --- Step 6d: Draw Moved Object ---\n        if reflected_obj_grid is not None and new_top_left_r != -1:\n            reflected_height, reflected_width = reflected_obj_grid.shape\n            for r_rel in range(reflected_height):\n                for c_rel in range(reflected_width):\n                    if reflected_obj_grid[r_rel, c_rel] == content_color:\n                        draw_r = new_top_left_r + r_rel\n                        draw_c = new_top_left_c + c_rel\n                        # Check bounds before drawing\n                        if 0 <= draw_r < height and 0 <= draw_c < width:\n                            # Avoid overwriting the frame itself \n                            # (Check the *original* grid value at the target location \n                            # to allow drawing over erased areas, but not the frame)\n                            if input_grid_np[draw_r, draw_c] != frame_color:\n                                 output_grid[draw_r, draw_c] = content_color\n                            # else: Skip drawing if it would overwrite the frame\n                                \n    # --- Step 7: Return Result ---\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8148,
    "candidates_token_count": 3177,
    "total_token_count": 11325,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 111.466615,
  "retries": null
}