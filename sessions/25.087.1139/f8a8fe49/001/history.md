
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 0 2 0 5 0 0 5 0 2 0 0 0 0
0 0 0 2 0 0 5 0 5 0 2 0 0 0 0
0 0 0 2 0 0 5 0 5 0 2 0 0 0 0
0 0 0 2 0 5 0 0 5 0 2 0 0 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 5 0 2 0 0 0 0 0 0 2 0 5 0 0
5 0 0 2 0 0 0 0 0 0 2 0 5 0 0
5 0 0 2 0 0 0 0 0 0 2 0 5 0 0
0 5 0 2 0 0 0 0 0 0 2 0 5 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 5 5 5 0 0 0 0 0 0
0 0 0 0 0 0 5 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 5 0 5 0 0 0 0 0 0
0 0 0 0 0 0 5 5 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 2 0 0 0 0
0 0 0 0 2 2 2 2 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 2 0 5 0 0 5 0 2 0 0 0 0
0 0 0 2 0 5 5 0 5 0 2 0 0 0 0
0 0 0 2 0 0 5 0 5 0 2 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 5 0 2 0 0 0 0 0 0 2 0 5 0 0
5 5 0 2 0 0 0 0 0 0 2 0 5 0 0
5 0 0 2 0 0 0 0 0 0 2 0 5 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

## Perception

1.  **Input/Output Structure:** Both input and output are grids of the same dimensions (15x15 in all examples).
2.  **Color Palette:** The primary colors used are white (0 - background), red (2), and gray (5).
3.  **Key Objects:**
    *   A prominent "frame" or "container" structure made of red pixels (2) is present in all inputs. Its shape varies slightly (spectacles-like in Ex 1 & 3, rectangular in Ex 2).
    *   One or more distinct objects made of gray pixels (5) are located *inside* the red frame in the input. The shapes of these gray objects vary (L-shapes, T-shape, single pixel, F-like shapes).
4.  **Transformation Core Idea:** The gray objects inside the red frame are moved to the *outside* of the frame in the output. The space they occupied inside the frame becomes white (background). The red frame itself remains unchanged.
5.  **Transformation Details:**
    *   **Removal:** Gray pixels inside the frame are effectively erased (turned white) in the output.
    *   **Movement:** Each gray object is moved outside the frame.
    *   **Reflection/Mirroring:** The gray objects appear reflected in the output. The axis of reflection seems related to the closest boundary of the red frame. Objects near the left/right sides (Ex 1, Ex 3) are reflected *horizontally*. Objects near the top/bottom (Ex 2) are reflected *vertically*.
    *   **Placement:** The reflected gray objects are placed just outside the red frame, seemingly adjacent to the boundary they were "reflected" from, with a consistent one-pixel gap between the object and the frame boundary. The placement preserves the relative axis position (e.g., an object reflected from the left boundary keeps its original row(s) but is placed to the left of the frame).

## YAML Facts


```yaml
task_context:
  description: "Move and reflect objects contained within a frame."
  grid_properties:
    - dimensions_preserved: True
    - background_color: 0 (white)
  objects:
    - id: frame
      color: 2 (red)
      role: container
      properties:
        - shape_varies: True
        - remains_static: True # The frame itself doesn't change position or color
        - defines_boundaries: True # Separates 'inside' from 'outside'
    - id: internal_objects
      color: 5 (gray)
      role: content
      location: initially_inside_frame
      properties:
        - shape_varies: True
        - count_varies: True
        - contiguous: True # Each object is a connected component
      actions:
        - identify_location: relative_to_frame_boundaries
        - remove_from_inside: replace_with_background_color_in_output
        - reflect: based_on_nearest_frame_boundary # Horizontal for side boundaries, Vertical for top/bottom
        - relocate: move_to_outside_frame
        - reposition: place_adjacent_to_reflection_boundary_with_gap # 1 pixel gap
  relationships:
    - type: containment
      subject: frame
      object: internal_objects
      state: input_only # In output, objects are outside
    - type: proximity
      subject: internal_objects
      object: frame_boundaries
      relevance: determines_reflection_axis_and_placement_location
  transformation:
    - step: 1
      action: identify_frame
      input: grid
      output: frame_object, frame_bounding_box
    - step: 2
      action: identify_internal_objects
      input: grid, frame_bounding_box
      output: list_of_gray_objects_inside_frame
    - step: 3
      action: initialize_output_grid
      based_on: input_grid
    - step: 4
      action: clear_internal_area
      target: output_grid
      input: list_of_gray_objects_inside_frame
      effect: pixels_of_internal_objects_set_to_background_color
    - step: 5
      action: process_each_internal_object
      input: gray_object, frame_bounding_box
      sub_actions:
        - determine_nearest_boundary # (top, bottom, left, right)
        - reflect_object # (vertically or horizontally based on boundary)
        - calculate_new_position # (outside frame, adjacent to boundary, 1 pixel gap)
        - draw_transformed_object # (onto output_grid)
```


## Natural Language Program

1.  **Initialize:** Create a new grid (output grid) identical to the input grid.
2.  **Identify Frame:** Locate the connected red (2) pixels forming the frame. Determine its bounding box (minimum and maximum row and column).
3.  **Identify Content:** Find all distinct connected groups of gray (5) pixels that are located entirely *within* the inner area defined by the red frame. Store each object's shape and original location.
4.  **Erase Content Inside Frame:** Iterate through the locations of the identified gray objects found in step 3. For each pixel belonging to these objects, set the corresponding pixel in the *output grid* to white (0).
5.  **Transform and Relocate Content:** For each gray object identified in step 3:
    a.  **Find Nearest Boundary:** Determine which side of the frame's bounding box (top, bottom, left, or right) the object is closest to.
    b.  **Reflect:**
        *   If the nearest boundary is the left or right side, reflect the object's shape *horizontally*.
        *   If the nearest boundary is the top or bottom side, reflect the object's shape *vertically*.
    c.  **Calculate New Position:** Determine the target coordinates for the top-left corner of the reflected object's bounding box on the output grid:
        *   If reflected from the *left* boundary (minimum column `min_c`), place the reflected object so its rightmost column ends at `min_c - 2`. Keep the original row range.
        *   If reflected from the *right* boundary (maximum column `max_c`), place the reflected object so its leftmost column starts at `max_c + 2`. Keep the original row range.
        *   If reflected from the *top* boundary (minimum row `min_r`), place the reflected object so its bottommost row ends at `min_r - 2`. Keep the original column range.
        *   If reflected from the *bottom* boundary (maximum row `max_r`), place the reflected object so its topmost row starts at `max_r + 2`. Keep the original column range.
    d.  **Draw:** Place the reflected gray object onto the *output grid* at the calculated new position.
6.  **Finalize:** The modified output grid is the result.
