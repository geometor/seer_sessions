{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a 'frame' object (color 2) and 'content' objects (color 5) initially located inside the frame.\nThe transformation involves:\n1. Erasing the content objects from their original positions inside the frame (setting them to background color 0).\n2. Determining the closest boundary (top, bottom, left, or right) of the frame to each content object.\n3. Reflecting each content object horizontally if the closest boundary is left/right, or vertically if the closest boundary is top/bottom.\n4. Placing the reflected content object outside the frame, adjacent to the boundary it was reflected from, with a one-pixel gap.\nThe frame itself remains unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all connected objects of a given color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'coords': obj_coords,\n                    'bbox': {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c},\n                    'color': color\n                })\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    max_r = max(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c}\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves and reflects gray objects found inside a red frame to the outside.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n\n    # --- Step 1 & 2: Identify Frame and Content Objects ---\n    frame_objects = find_objects(input_grid_np, 2) # Red color\n    content_objects = find_objects(input_grid_np, 5) # Gray color\n\n    # Assume there is only one frame object for simplicity\n    if not frame_objects:\n        return output_grid # No frame, nothing to do\n\n    frame = frame_objects[0]\n    frame_bbox = frame['bbox']\n    frame_coords_set = set(frame['coords']) # For quick lookup\n\n    internal_objects_to_process = []\n\n    # Identify content objects *inside* the frame\n    # An object is inside if all its pixels are within the frame's bbox *and* not part of the frame itself\n    for obj in content_objects:\n        is_inside = True\n        for r, c in obj['coords']:\n            if not (frame_bbox['min_r'] < r < frame_bbox['max_r'] and\n                    frame_bbox['min_c'] < c < frame_bbox['max_c']):\n                 is_inside = False\n                 break\n            # Double check it's not accidentally overlapping a thick frame part\n            # This check might be redundant if frame finding is robust and only finds the outer layer\n            # if (r,c) in frame_coords_set:\n            #     is_inside = False\n            #     break\n        if is_inside:\n            internal_objects_to_process.append(obj)\n\n    # --- Step 4: Erase Content Inside Frame ---\n    for obj in internal_objects_to_process:\n        for r, c in obj['coords']:\n            output_grid[r, c] = 0 # Set to background white\n\n    # --- Step 5: Transform and Relocate Content ---\n    for obj in internal_objects_to_process:\n        coords = obj['coords']\n        obj_bbox = obj['bbox']\n        obj_height = obj_bbox['max_r'] - obj_bbox['min_r'] + 1\n        obj_width = obj_bbox['max_c'] - obj_bbox['min_c'] + 1\n\n        # --- Step 5a: Find Nearest Boundary ---\n        dist_top = obj_bbox['min_r'] - frame_bbox['min_r']\n        dist_bottom = frame_bbox['max_r'] - obj_bbox['max_r']\n        dist_left = obj_bbox['min_c'] - frame_bbox['min_c']\n        dist_right = frame_bbox['max_c'] - obj_bbox['max_c']\n\n        distances = {\n            'top': dist_top,\n            'bottom': dist_bottom,\n            'left': dist_left,\n            'right': dist_right\n        }\n        # Find the minimum non-negative distance. Handle cases where object touches boundary (dist=1)\n        min_dist = float('inf')\n        nearest_boundary = None\n        for boundary, dist in distances.items():\n             # Consider only positive distances (pixels inside the frame bbox edges)\n             if dist > 0 and dist < min_dist:\n                 min_dist = dist\n                 nearest_boundary = boundary\n             # If multiple boundaries have the same minimum distance, prioritize (e.g., top > bottom > left > right)\n             elif dist > 0 and dist == min_dist:\n                 priority = {'top': 4, 'bottom': 3, 'left': 2, 'right': 1}\n                 if priority.get(boundary, 0) > priority.get(nearest_boundary, 0):\n                     nearest_boundary = boundary\n\n        if nearest_boundary is None: # Should not happen for objects strictly inside\n            continue\n\n        # --- Step 5b: Reflect ---\n        reflected_coords_relative = []\n        for r, c in coords:\n            rel_r = r - obj_bbox['min_r']\n            rel_c = c - obj_bbox['min_c']\n\n            if nearest_boundary in ['left', 'right']: # Horizontal reflection\n                reflected_c = (obj_width - 1) - rel_c\n                reflected_coords_relative.append((rel_r, reflected_c))\n            else: # Vertical reflection ('top', 'bottom')\n                reflected_r = (obj_height - 1) - rel_r\n                reflected_coords_relative.append((reflected_r, rel_c))\n\n        # --- Step 5c: Calculate New Position ---\n        new_top_left_r, new_top_left_c = -1, -1 # Initialize invalid\n\n        if nearest_boundary == 'left':\n            new_top_left_r = obj_bbox['min_r']\n            new_top_left_c = frame_bbox['min_c'] - 1 - obj_width\n        elif nearest_boundary == 'right':\n            new_top_left_r = obj_bbox['min_r']\n            new_top_left_c = frame_bbox['max_c'] + 2\n        elif nearest_boundary == 'top':\n            new_top_left_r = frame_bbox['min_r'] - 1 - obj_height\n            new_top_left_c = obj_bbox['min_c']\n        elif nearest_boundary == 'bottom':\n            new_top_left_r = frame_bbox['max_r'] + 2\n            new_top_left_c = obj_bbox['min_c']\n\n        # --- Step 5d: Draw ---\n        if new_top_left_r >= 0 and new_top_left_c >= 0: # Check if position is valid\n            for rel_r, rel_c in reflected_coords_relative:\n                draw_r, draw_c = new_top_left_r + rel_r, new_top_left_c + rel_c\n                # Check bounds before drawing\n                if 0 <= draw_r < height and 0 <= draw_c < width:\n                    output_grid[draw_r, draw_c] = obj['color'] # Draw gray pixel\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6340,
            "end_index": 6506,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5390,
    "candidates_token_count": 2210,
    "total_token_count": 7600,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.643988,
  "retries": null
}