{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a red rectangular frame (color 2) and internal gray content objects (color 5).\nThe transformation involves moving and reflecting these internal objects based on the aspect ratio of the frame's inner space.\n\n1.  **Identify Frame & Inner Space:** Locate the bounding box of all red (2) pixels. Define the 'inner space' as the area one pixel inside this bounding box.\n2.  **Determine Reflection Rule:** Calculate the height (H) and width (W) of the inner space.\n    *   If W >= H (wider or square): Reflect objects horizontally.\n    *   If H > W (taller): Reflect objects vertically.\n3.  **Identify & Filter Internal Content:** Find all gray (5) objects (4-connectivity). Select only those strictly inside the frame's outer bounding box.\n4.  **Process Each Internal Object:**\n    *   Erase the object from its original position.\n    *   Calculate distances from the object's bounding box to the four inner boundaries (Top, Bottom, Left, Right).\n    *   **If Horizontal Reflection:**\n        *   Choose placement side: Left if distance to Left inner boundary <= distance to Right; otherwise Right.\n        *   Reflect the object horizontally.\n        *   Place the reflected object outside the frame, adjacent to the chosen side (Left/Right) with a 1-pixel gap, aligned vertically with its original position.\n    *   **If Vertical Reflection:**\n        *   Choose placement side: Top if distance to Top inner boundary <= distance to Bottom; otherwise Bottom.\n        *   Reflect the object vertically.\n        *   Place the reflected object outside the frame, adjacent to the chosen side (Top/Bottom) with a 1-pixel gap, aligned horizontally with its original position.\n5.  Objects outside the frame and the frame itself remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color, connectivity=4):\n    \"\"\"\n    Finds all connected objects of a given color using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n        connectivity (int): 4 or 8 for neighbor connectivity.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (list of (r, c) tuples) and\n              'bbox' (dictionary with min_r, max_r, min_c, max_c).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    else: # Assume 8-connectivity\n        neighbors = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_coords: # Only add if we found coordinates\n                    objects.append({\n                        'coords': obj_coords,\n                        'bbox': {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c},\n                        'color': color\n                    })\n    return objects\n\ndef get_frame_bbox(grid, frame_color=2):\n    \"\"\"\n    Determines the bounding box of the frame structure.\n    Assumes the frame is formed by the extent of all pixels of frame_color.\n    \"\"\"\n    coords = np.argwhere(grid == frame_color)\n    if coords.size == 0:\n        return None\n    min_r = np.min(coords[:, 0])\n    max_r = np.max(coords[:, 0])\n    min_c = np.min(coords[:, 1])\n    max_c = np.max(coords[:, 1])\n    return {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c}\n\ndef transform(input_grid):\n    \"\"\"Applies the reflection transformation based on frame inner aspect ratio.\"\"\"\n    \n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n    frame_color = 2\n    content_color = 5\n    background_color = 0\n\n    # --- Step 1: Identify the Frame ---\n    frame_bbox = get_frame_bbox(input_grid_np, frame_color)\n    if frame_bbox is None:\n        # No frame found, return original grid\n        return input_grid \n\n    # --- Step 2: Define Inner Space ---\n    inner_min_r = frame_bbox['min_r'] + 1\n    inner_max_r = frame_bbox['max_r'] - 1\n    inner_min_c = frame_bbox['min_c'] + 1\n    inner_max_c = frame_bbox['max_c'] - 1\n\n    # Check if inner space is valid (frame must be at least 3x3)\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n         # Frame too small for an inner space, treat as no transform needed? Or return original.\n         return input_grid\n\n    # --- Step 3: Determine Reflection Rule ---\n    inner_height = inner_max_r - inner_min_r + 1\n    inner_width = inner_max_c - inner_min_c + 1\n    \n    reflect_horizontally = (inner_width >= inner_height) # Reflect horizontally if wider or square\n\n    # --- Step 4: Identify Content Objects ---\n    content_objects = find_objects(input_grid_np, content_color, connectivity=4)\n\n    # --- Step 5: Filter Internal Objects ---\n    internal_objects = []\n    for obj in content_objects:\n        is_internal = True\n        if not obj['coords']: \n             is_internal = False\n        else:\n            for r, c in obj['coords']:\n                # Check if strictly inside the frame's outer bounding box\n                if not (frame_bbox['min_r'] < r < frame_bbox['max_r'] and\n                        frame_bbox['min_c'] < c < frame_bbox['max_c']):\n                    is_internal = False\n                    break\n        if is_internal:\n            internal_objects.append(obj)\n\n    # --- Step 6 & 7: Process Each Internal Object ---\n    for obj in internal_objects:\n        coords = obj['coords']\n        obj_bbox = obj['bbox']\n        obj_height = obj_bbox['max_r'] - obj_bbox['min_r'] + 1\n        obj_width = obj_bbox['max_c'] - obj_bbox['min_c'] + 1\n\n        # --- Step 7a: Erase Original ---\n        for r, c in coords:\n            output_grid[r, c] = background_color\n\n        # --- Step 7b: Calculate Distances to Inner Boundaries ---\n        dist_T = max(0, obj_bbox['min_r'] - inner_min_r)\n        dist_B = max(0, inner_max_r - obj_bbox['max_r'])\n        dist_L = max(0, obj_bbox['min_c'] - inner_min_c)\n        dist_R = max(0, inner_max_c - obj_bbox['max_c'])\n\n        # --- Create object subgrid ---\n        obj_grid = np.zeros((obj_height, obj_width), dtype=int)\n        for r, c in coords:\n            rel_r = r - obj_bbox['min_r']\n            rel_c = c - obj_bbox['min_c']\n            if 0 <= rel_r < obj_height and 0 <= rel_c < obj_width:\n                 obj_grid[rel_r, rel_c] = content_color\n        \n        # --- Step 7c: Apply Reflection and Determine Placement ---\n        reflected_obj_grid = None\n        new_top_left_r, new_top_left_c = -1, -1\n        \n        if reflect_horizontally:\n            # Reflect horizontally\n            reflected_obj_grid = np.fliplr(obj_grid)\n            # Determine placement: Left or Right\n            if dist_L <= dist_R: # Place Left (tie goes to Left)\n                placement_side = 'left'\n                new_top_left_r = obj_bbox['min_r'] # Align vertically\n                new_top_left_c = frame_bbox['min_c'] - 1 - obj_width # Place left of frame with 1 gap\n            else: # Place Right\n                placement_side = 'right'\n                new_top_left_r = obj_bbox['min_r'] # Align vertically\n                new_top_left_c = frame_bbox['max_c'] + 2 # Place right of frame with 1 gap\n        else: # Reflect Vertically (H > W)\n            # Reflect vertically\n            reflected_obj_grid = np.flipud(obj_grid)\n            # Determine placement: Top or Bottom\n            if dist_T <= dist_B: # Place Top (tie goes to Top)\n                placement_side = 'top'\n                new_top_left_r = frame_bbox['min_r'] - 1 - obj_height # Place above frame with 1 gap\n                new_top_left_c = obj_bbox['min_c'] # Align horizontally\n            else: # Place Bottom\n                placement_side = 'bottom'\n                new_top_left_r = frame_bbox['max_r'] + 2 # Place below frame with 1 gap\n                new_top_left_c = obj_bbox['min_c'] # Align horizontally\n\n        # --- Step 7d: Draw Moved Object ---\n        if reflected_obj_grid is not None and new_top_left_r != -1:\n            reflected_height, reflected_width = reflected_obj_grid.shape\n            for r_rel in range(reflected_height):\n                for c_rel in range(reflected_width):\n                    if reflected_obj_grid[r_rel, c_rel] == content_color:\n                        draw_r = new_top_left_r + r_rel\n                        draw_c = new_top_left_c + c_rel\n                        # Check bounds before drawing\n                        if 0 <= draw_r < height and 0 <= draw_c < width:\n                            # Avoid overwriting the frame itself \n                            if output_grid[draw_r, draw_c] != frame_color:\n                                 output_grid[draw_r, draw_c] = content_color\n                            # else: (optional) handle potential collision with frame - current logic just skips draw\n                                \n    # --- Step 8: Return Result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15938,
    "candidates_token_count": 2839,
    "total_token_count": 18777,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.479067,
  "retries": null
}