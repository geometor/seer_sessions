{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a red rectangular frame (color 2) and gray content objects (color 5) located strictly inside the frame.\nThe transformation involves:\n1. Erasing the internal content objects from their original positions (setting pixels to background color 0).\n2. Determining the closest inner boundary (top, bottom, left, or right) of the frame to each internal content object.\n3. Reflecting each internal content object horizontally if the closest boundary is left/right, or vertically if the closest boundary is top/bottom.\n4. Placing the reflected content object outside the frame, adjacent to the corresponding outer boundary it was reflected from, with a one-pixel gap.\nThe frame itself remains unchanged. Objects outside the frame are also unchanged.\n\"\"\"\n\ndef find_objects(grid, color, connectivity=4):\n    \"\"\"\n    Finds all connected objects of a given color using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n        connectivity (int): 4 or 8 for neighbor connectivity.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (list of (r, c) tuples) and\n              'bbox' (dictionary with min_r, max_r, min_c, max_c).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    else: # Assume 8-connectivity\n        neighbors = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_coords: # Only add if we found coordinates\n                    objects.append({\n                        'coords': obj_coords,\n                        'bbox': {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c},\n                        'color': color\n                    })\n    return objects\n\ndef get_frame_bbox(grid, frame_color=2):\n    \"\"\"\n    Determines the bounding box of the frame structure.\n    Assumes the frame is formed by all pixels of frame_color.\n    \"\"\"\n    coords = np.argwhere(grid == frame_color)\n    if coords.size == 0:\n        return None\n    min_r = np.min(coords[:, 0])\n    max_r = np.max(coords[:, 0])\n    min_c = np.min(coords[:, 1])\n    max_c = np.max(coords[:, 1])\n    return {'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c}\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on frame proximity.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    height, width = output_grid.shape\n    frame_color = 2\n    content_color = 5\n    background_color = 0\n\n    # --- Step 1: Find the Frame ---\n    # Assume the frame is defined by the extent of all red pixels\n    frame_bbox = get_frame_bbox(input_grid_np, frame_color)\n    if frame_bbox is None:\n        return input_grid # No frame found, return original grid\n\n    # --- Step 2: Find Content Objects ---\n    # Use 4-connectivity for content objects based on visual separation in examples\n    content_objects = find_objects(input_grid_np, content_color, connectivity=4)\n\n    # --- Step 3: Identify Internal Content Objects ---\n    internal_objects = []\n    for obj in content_objects:\n        is_internal = True\n        if not obj['coords']: # Skip empty objects if find_objects somehow returns one\n             is_internal = False\n        else:\n            for r, c in obj['coords']:\n                # Check if strictly inside the frame's outer bounding box\n                if not (frame_bbox['min_r'] < r < frame_bbox['max_r'] and\n                        frame_bbox['min_c'] < c < frame_bbox['max_c']):\n                    is_internal = False\n                    break\n        if is_internal:\n            internal_objects.append(obj)\n\n    # --- Step 4: Erase Original Internal Content ---\n    for obj in internal_objects:\n        for r, c in obj['coords']:\n            output_grid[r, c] = background_color\n\n    # --- Step 5: Process Each Internal Object ---\n    for obj in internal_objects:\n        coords = obj['coords']\n        obj_bbox = obj['bbox']\n        obj_height = obj_bbox['max_r'] - obj_bbox['min_r'] + 1\n        obj_width = obj_bbox['max_c'] - obj_bbox['min_c'] + 1\n\n        # --- Step 5a: Calculate Closest Inner Boundary ---\n        # Inner boundary is 1 pixel inside the outer frame bbox\n        inner_min_r = frame_bbox['min_r'] + 1\n        inner_max_r = frame_bbox['max_r'] - 1\n        inner_min_c = frame_bbox['min_c'] + 1\n        inner_max_c = frame_bbox['max_c'] - 1\n\n        # Calculate distances (>= 0)\n        dist_top = max(0, obj_bbox['min_r'] - inner_min_r)\n        dist_bottom = max(0, inner_max_r - obj_bbox['max_r'])\n        dist_left = max(0, obj_bbox['min_c'] - inner_min_c)\n        dist_right = max(0, inner_max_c - obj_bbox['max_c'])\n\n        distances = {\n            'top': dist_top,\n            'bottom': dist_bottom,\n            'left': dist_left,\n            'right': dist_right\n        }\n\n        # Find the minimum distance and the corresponding boundary/boundaries\n        min_dist = float('inf')\n        for dist in distances.values():\n            min_dist = min(min_dist, dist)\n\n        closest_boundaries = [b for b, d in distances.items() if d == min_dist]\n\n        # Prioritize: top > bottom > left > right\n        priority = {'top': 4, 'bottom': 3, 'left': 2, 'right': 1}\n        nearest_boundary = max(closest_boundaries, key=lambda b: priority[b])\n\n        # --- Step 5b: Reflect Object ---\n        # Create a small grid representing the object relative to its bbox\n        obj_grid = np.zeros((obj_height, obj_width), dtype=int)\n        for r, c in coords:\n            rel_r = r - obj_bbox['min_r']\n            rel_c = c - obj_bbox['min_c']\n            if 0 <= rel_r < obj_height and 0 <= rel_c < obj_width:\n                 obj_grid[rel_r, rel_c] = content_color\n\n        # Reflect the object grid\n        reflected_obj_grid = obj_grid\n        if nearest_boundary in ['left', 'right']: # Horizontal reflection\n            reflected_obj_grid = np.fliplr(obj_grid)\n        elif nearest_boundary in ['top', 'bottom']: # Vertical reflection\n            reflected_obj_grid = np.flipud(obj_grid)\n\n        # --- Step 5c: Calculate New Position (Top-Left Anchor) ---\n        # Place with a 1-pixel gap from the outer frame edge\n        # Alignment depends on reflection axis\n        new_top_left_r, new_top_left_c = -1, -1\n\n        if nearest_boundary == 'top':\n            new_top_left_r = frame_bbox['min_r'] - 1 - obj_height\n            new_top_left_c = obj_bbox['min_c'] # Align horizontally with original\n        elif nearest_boundary == 'bottom':\n            new_top_left_r = frame_bbox['max_r'] + 2\n            new_top_left_c = obj_bbox['min_c'] # Align horizontally with original\n        elif nearest_boundary == 'left':\n            new_top_left_r = obj_bbox['min_r'] # Align vertically with original\n            new_top_left_c = frame_bbox['min_c'] - 1 - obj_width\n        elif nearest_boundary == 'right':\n            new_top_left_r = obj_bbox['min_r'] # Align vertically with original\n            new_top_left_c = frame_bbox['max_c'] + 2\n\n        # --- Step 5d: Draw Reflected Object ---\n        reflected_height, reflected_width = reflected_obj_grid.shape\n        for r_rel in range(reflected_height):\n            for c_rel in range(reflected_width):\n                if reflected_obj_grid[r_rel, c_rel] == content_color:\n                    draw_r = new_top_left_r + r_rel\n                    draw_c = new_top_left_c + c_rel\n                    # Check bounds before drawing\n                    if 0 <= draw_r < height and 0 <= draw_c < width:\n                        # Avoid overwriting the frame itself if something goes wrong\n                        if output_grid[draw_r, draw_c] != frame_color:\n                             output_grid[draw_r, draw_c] = content_color\n\n    # Convert back to list of lists for the ARC standard\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15217,
    "candidates_token_count": 2593,
    "total_token_count": 17810,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 113.653715,
  "retries": null
}