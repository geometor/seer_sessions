{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Identify the Background Template:** Find the largest contiguous rectangular block in the input grid composed of a single, non-white (non-zero) color. Note its color, dimensions (height, width), and top-left corner coordinates (row, column).\n2.  **Create the Output Canvas:** Initialize a new grid with the dimensions derived from the background template rectangle, filling it entirely with the template's color.\n3.  **Identify the Foreground Pattern:** Locate all pixels in the *input* grid that have the color Azure (8).\n4.  **Overlay the Pattern with Relative Positioning:** For each Azure (8) pixel found in the input grid at coordinates (input_row, input_col):\n    a. Calculate its position relative to the top-left corner of the identified background rectangle: \n       `relative_row = input_row - background_start_row`\n       `relative_col = input_col - background_start_col`\n    b. If this relative position (`relative_row`, `relative_col`) falls within the bounds of the output canvas (i.e., `0 <= relative_row < output_height` and `0 <= relative_col < output_width`), place an Azure (8) pixel at these relative coordinates in the output canvas.\n\"\"\"\n\ndef find_largest_solid_rectangle(grid):\n    \"\"\"\n    Finds the largest solid rectangle of a single non-white color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (color, (r, c, height, width)) of the largest rectangle, \n               or (-1, (0, 0, 0, 0)) if none found.\n    \"\"\"\n    rows, cols = grid.shape\n    max_area_final = 0\n    best_color_final = -1\n    best_rect_final = (0, 0, 0, 0) # (r, c, h, w)\n\n    # Iterate through all possible top-left corners (r1, c1)\n    for r1 in range(rows):\n        for c1 in range(cols):\n            color = grid[r1, c1]\n            # Skip white background pixels\n            if color == 0:\n                continue\n            \n            # Max width possible starting from (r1, c1) for subsequent rows\n            max_w = cols - c1 \n            # Iterate downwards (r2) to find the height\n            for r2 in range(r1, rows):\n                # Check if the starting pixel of the current row (r2, c1) matches the color\n                if grid[r2, c1] != color:\n                    break # Cannot extend height further with this color\n\n                # Check pixels in the current row r2 from c1 up to the current max_w\n                for c2 in range(c1, c1 + max_w):\n                    if grid[r2, c2] != color:\n                         # Update max width possible for subsequent rows if color breaks\n                         max_w = c2 - c1 \n                         break\n                \n                # If the inner loop didn't break, max_w remains the same\n                \n                # Calculate the dimensions and area of the solid rectangle found so far\n                # Height = number of rows from r1 to r2 inclusive\n                # Width = current max_w\n                current_h = r2 - r1 + 1\n                current_w = max_w \n                area = current_h * current_w\n                \n                # If this rectangle is larger than the best one found so far, update\n                if area > max_area_final:\n                    max_area_final = area\n                    best_color_final = color\n                    best_rect_final = (r1, c1, current_h, current_w)\n\n                # Optimization: if width became 0, no point checking further rows for this (r1,c1)\n                if max_w == 0: \n                     break\n\n    return best_color_final, best_rect_final\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # 1. Identify the Background Template\n    bg_color, (bg_r, bg_c, output_height, output_width) = find_largest_solid_rectangle(grid_np)\n\n    # Handle cases where no suitable background is found\n    if bg_color == -1 or output_height == 0 or output_width == 0:\n         # Based on ARC task structure, a valid background is usually expected.\n         # If this happens, returning an empty grid or the original might be options,\n         # but let's assume valid inputs per ARC design.\n         # Returning a minimal 1x1 white grid as a fallback?\n         # For now, return empty list of lists if failed.\n         print(\"Warning: Could not find a valid background rectangle.\")\n         return [[]] \n\n\n    # 2. Create the Output Canvas\n    output_grid = np.full((output_height, output_width), bg_color, dtype=int)\n\n    # 3. Identify the Foreground Pattern (Azure pixels)\n    # Find coordinates of all Azure (8) pixels in the input grid\n    azure_pixels_coords = np.argwhere(grid_np == 8) # Returns list of [row, col]\n\n    # 4. Overlay the Pattern with Relative Positioning\n    for r_in, c_in in azure_pixels_coords:\n        # Calculate coordinates relative to the background rectangle's top-left corner\n        relative_r = r_in - bg_r\n        relative_c = c_in - bg_c\n\n        # Check if the relative coordinate is within the bounds of the output grid\n        if 0 <= relative_r < output_height and 0 <= relative_c < output_width:\n            # Place the Azure pixel onto the output grid at the relative position\n            output_grid[relative_r, relative_c] = 8 \n\n    # Convert the final NumPy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6313,
    "candidates_token_count": 1431,
    "total_token_count": 7744,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.398151,
  "retries": null
}