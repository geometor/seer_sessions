{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport scipy.stats\n\n\"\"\"\nIdentify the dominant color within distinct regions of the input grid and fill \nthose regions entirely with their dominant color in the output grid. \n\nThe regions form a partition of the grid, either as vertical strips or \nhorizontal strips. The orientation (vertical or horizontal) is determined by \ncomparing the consistency of dominant colors along columns versus rows. The \norientation with fewer changes in dominant color between adjacent columns/rows \nis chosen.\n\nOnce the orientation is determined, the grid is divided into strips based on \nwhere the dominant color changes along that orientation. For each strip (region), \nthe overall most frequent color within that region in the input grid is \ncalculated. The corresponding strip in the output grid is then filled entirely \nwith this dominant color.\n\"\"\"\n\ndef get_dominant_color(region):\n    \"\"\"\n    Finds the most frequent color (mode) in a given region (numpy array).\n    Handles empty regions and potential errors.\n    \"\"\"\n    if region.size == 0:\n        return 0 # Default to white for empty regions, though shouldn't happen with this logic\n    # Use scipy.stats.mode which is efficient and handles ties deterministically (returns smallest value)\n    mode_result = scipy.stats.mode(region, axis=None, keepdims=False)\n    # Check if mode_result is valid before accessing attributes\n    if mode_result and hasattr(mode_result, 'mode') and mode_result.mode is not None:\n         # Ensure mode is treated as a scalar if it's an array with one element\n        dominant_color = np.isscalar(mode_result.mode) and mode_result.mode or mode_result.mode[0]\n        return dominant_color\n    else:\n        # Fallback: Use Counter if mode fails (e.g., older scipy or unexpected input)\n        counts = Counter(region.flatten())\n        if not counts:\n             return 0\n        # most_common returns list of tuples [(element, count)]\n        dominant_color, _ = counts.most_common(1)[0]\n        return dominant_color\n\n\ndef determine_orientation(input_grid):\n    \"\"\"\n    Determines whether to partition the grid vertically or horizontally based\n    on dominant color consistency.\n    \"\"\"\n    height, width = input_grid.shape\n\n    # Calculate dominant color for each column\n    col_doms = []\n    for j in range(width):\n        col_slice = input_grid[:, j:j+1] # Keep as 2D slice for consistency if needed\n        col_doms.append(get_dominant_color(col_slice))\n\n    # Calculate dominant color for each row\n    row_doms = []\n    for i in range(height):\n        row_slice = input_grid[i:i+1, :] # Keep as 2D slice\n        row_doms.append(get_dominant_color(row_slice))\n\n    # Count changes (boundaries) in dominant colors along columns\n    num_vertical_boundaries = 0\n    for j in range(width - 1):\n        if col_doms[j] != col_doms[j+1]:\n            num_vertical_boundaries += 1\n\n    # Count changes (boundaries) in dominant colors along rows\n    num_horizontal_boundaries = 0\n    for i in range(height - 1):\n        if row_doms[i] != row_doms[i+1]:\n            num_horizontal_boundaries += 1\n\n    # Decide orientation: Fewer boundaries suggests more consistent blocks\n    if num_vertical_boundaries <= num_horizontal_boundaries:\n        return 'vertical', col_doms\n    else:\n        return 'horizontal', row_doms\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying dominant color regions (vertical\n    or horizontal strips) and filling them with their respective dominant colors.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    output_grid = np.zeros_like(input_grid_np)\n\n    # 1. Determine the partitioning orientation (vertical or horizontal)\n    orientation, dominant_colors_list = determine_orientation(input_grid_np)\n\n    if orientation == 'vertical':\n        # 2a. Identify vertical boundaries\n        boundaries = [0] + [j + 1 for j in range(width - 1) if dominant_colors_list[j] != dominant_colors_list[j+1]] + [width]\n\n        # 3a. Process each vertical partition (strip)\n        for k in range(len(boundaries) - 1):\n            start_col = boundaries[k]\n            end_col = boundaries[k+1]\n\n            # 4a. Get the region (strip) from the input grid\n            region = input_grid_np[:, start_col:end_col]\n\n            # 5a. Find the overall dominant color for this region\n            dominant_color = get_dominant_color(region)\n\n            # 6a. Fill the corresponding region in the output grid\n            output_grid[:, start_col:end_col] = dominant_color\n\n    else: # orientation == 'horizontal'\n        # 2b. Identify horizontal boundaries\n        boundaries = [0] + [i + 1 for i in range(height - 1) if dominant_colors_list[i] != dominant_colors_list[i+1]] + [height]\n\n        # 3b. Process each horizontal partition (strip)\n        for k in range(len(boundaries) - 1):\n            start_row = boundaries[k]\n            end_row = boundaries[k+1]\n\n            # 4b. Get the region (strip) from the input grid\n            region = input_grid_np[start_row:end_row, :]\n\n            # 5b. Find the overall dominant color for this region\n            dominant_color = get_dominant_color(region)\n\n            # 6b. Fill the corresponding region in the output grid\n            output_grid[start_row:end_row, :] = dominant_color\n\n    # 7. Return the final output grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4549,
    "candidates_token_count": 1433,
    "total_token_count": 5982,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.109279,
  "retries": null
}