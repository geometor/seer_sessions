{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the largest hollow rectangular frame in the input grid. Note its color and determine its bounding box.\nIdentify all non-white 'source' pixels located outside this frame's bounding box.\nCreate a list of the colors of these source pixels.\nSort this list of colors based on the position of their corresponding source pixels: order them by the sum of the row and column index (r + c) of each source pixel, from smallest sum to largest.\nInitialize the output grid as a copy of the input grid.\nIteratively fill the white interior of the frame, layer by layer, using the sorted colors. The layer index for a pixel (r, c) inside the frame is determined by its minimum distance to the inner boundary of the frame. The color for that layer corresponds to the color at that index in the sorted list.\nContinue filling layers inwards until all white pixels within the frame's interior bounding box have been colored or all source colors have been used.\nThe final grid with the filled frame is the output.\n\"\"\"\n\ndef find_frame_and_bounding_box(grid):\n    \"\"\"\n    Finds the most likely frame object (largest single-color rectangle)\n    and its bounding box.\n    Returns the frame color and its outer bounding box (min_r, min_c, max_r, max_c).\n    \"\"\"\n    non_background_pixels = []\n    colors_present = Counter()\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != 0:\n                non_background_pixels.append({'color': color, 'r': r, 'c': c})\n                colors_present[color] += 1\n\n    if not colors_present:\n        return None, None # No frame found\n\n    # Assume the frame is made of the most frequent non-background color\n    # (excluding potential large filled areas if they exist, but seems robust for these examples)\n    # If multiple colors have the same max frequency, choose the one appearing first\n    # in a standard iteration (though arbitrary, needs a tie-breaker). Let's refine later if needed.\n    most_common_color = colors_present.most_common(1)[0][0]\n    frame_color = most_common_color\n\n    frame_pixels_coords = [(p['r'], p['c']) for p in non_background_pixels if p['color'] == frame_color]\n\n    if not frame_pixels_coords:\n         # Fallback if the most common color calculation failed somehow\n         # Or if the structure is very unusual.\n         # Let's try finding the object with the largest bounding box area instead.\n         best_frame_color = -1\n         max_area = -1\n         best_bbox = None\n         unique_colors = [color for color, count in colors_present.items()]\n\n         for color in unique_colors:\n             coords = [(p['r'], p['c']) for p in non_background_pixels if p['color'] == color]\n             if not coords: continue\n             min_r = min(r for r, c in coords)\n             min_c = min(c for r, c in coords)\n             max_r = max(r for r, c in coords)\n             max_c = max(c for r, c in coords)\n             area = (max_r - min_r + 1) * (max_c - min_c + 1)\n             # Add a check for hollowness - crude check: center pixel is background\n             center_r, center_c = (min_r + max_r) // 2, (min_c + max_c) // 2\n             is_hollow = grid[center_r, center_c] == 0 if (min_r < max_r and min_c < max_c) else False\n\n             # Prefer hollow rectangles with larger areas\n             if is_hollow and area > max_area:\n                 max_area = area\n                 best_frame_color = color\n                 best_bbox = (min_r, min_c, max_r, max_c)\n             elif not best_bbox and area > max_area: # Fallback if no hollow found yet\n                 max_area = area\n                 best_frame_color = color\n                 best_bbox = (min_r, min_c, max_r, max_c)\n\n         if best_frame_color != -1:\n             frame_color = best_frame_color\n             frame_bbox = best_bbox\n         else:\n              return None, None # Still couldn't determine frame\n    else:\n        # Calculate bounding box from frame_pixels_coords\n        min_r = min(r for r, c in frame_pixels_coords)\n        min_c = min(c for r, c in frame_pixels_coords)\n        max_r = max(r for r, c in frame_pixels_coords)\n        max_c = max(c for r, c in frame_pixels_coords)\n        frame_bbox = (min_r, min_c, max_r, max_c)\n\n    # Basic validation: check if interior exists and is background\n    if frame_bbox[0] + 1 > frame_bbox[2] - 1 or frame_bbox[1] + 1 > frame_bbox[3] - 1:\n         is_hollow = False # Not wide/tall enough to have an interior\n    else:\n         # Check a point inside the inner box\n         inner_r, inner_c = frame_bbox[0] + 1, frame_bbox[1] + 1\n         is_hollow = grid[inner_r, inner_c] == 0\n\n    # If the most frequent color didn't form a hollow rectangle, potentially re-evaluate.\n    # For now, we assume the initial guess based on frequency or largest BB area is correct per examples.\n    # A more robust solution would involve connected components analysis and shape checking.\n\n    return frame_color, frame_bbox\n\ndef find_source_pixels(grid, frame_bbox):\n    \"\"\"Finds non-background pixels outside the frame's bounding box.\"\"\"\n    source_pixels = []\n    if frame_bbox is None:\n        return [] # No frame, no source relative to frame\n\n    frame_min_r, frame_min_c, frame_max_r, frame_max_c = frame_bbox\n\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            # Check if pixel is outside the frame's bounding box\n            is_outside = (r < frame_min_r or r > frame_max_r or\n                          c < frame_min_c or c > frame_max_c)\n\n            if is_outside and grid[r, c] != 0:\n                source_pixels.append({\n                    'color': grid[r, c],\n                    'r': r,\n                    'c': c,\n                    'sort_key': r + c # Manhattan distance from origin (0,0)\n                })\n    return source_pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding a hollow rectangular frame,\n    identifying external 'source' pixels, sorting their colors by position (r+c),\n    and filling the frame's interior with concentric layers of these colors.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n\n    # 1. Identify the frame and its bounding box\n    frame_color, frame_bbox = find_frame_and_bounding_box(grid)\n\n    # If no frame is found, return the original grid\n    if frame_bbox is None:\n        # Maybe log a warning or handle differently? For now, return copy.\n        return output_grid.tolist()\n\n    frame_min_r, frame_min_c, frame_max_r, frame_max_c = frame_bbox\n\n    # 2. Identify source pixels outside the frame\n    source_pixels = find_source_pixels(grid, frame_bbox)\n\n    # 3. Sort source pixels by r + c and extract colors\n    source_pixels.sort(key=lambda p: p['sort_key'])\n    sorted_colors = [p['color'] for p in source_pixels]\n\n    # If no source pixels found, no filling happens, return copy\n    if not sorted_colors:\n        return output_grid.tolist()\n\n    # 4. Define the interior bounding box (pixels inside the frame walls)\n    inner_min_r = frame_min_r + 1\n    inner_min_c = frame_min_c + 1\n    inner_max_r = frame_max_r - 1\n    inner_max_c = frame_max_c - 1\n\n    # Check if there is an actual interior to fill\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n        return output_grid.tolist() # Frame is too thin, no interior\n\n    # 5. Fill the interior based on distance / layer index\n    for r in range(inner_min_r, inner_max_r + 1):\n        for c in range(inner_min_c, inner_max_c + 1):\n            # Only fill pixels that were originally background color\n            if grid[r, c] == 0:\n                # Calculate distance to the nearest inner wall\n                dist_r_min = r - inner_min_r\n                dist_r_max = inner_max_r - r\n                dist_c_min = c - inner_min_c\n                dist_c_max = inner_max_c - c\n                \n                layer_index = min(dist_r_min, dist_r_max, dist_c_min, dist_c_max)\n\n                # Check if the layer index is valid for the available colors\n                if 0 <= layer_index < len(sorted_colors):\n                    fill_color = sorted_colors[layer_index]\n                    output_grid[r, c] = fill_color\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4319,
    "candidates_token_count": 2378,
    "total_token_count": 6697,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.981456,
  "retries": null
}