{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies a hollow rectangular frame in the input grid, finds non-white 'source' pixels outside this frame, sorts their colors by position (sum of row and column index), and fills the frame's white interior with concentric layers using the sorted colors. The innermost layers reuse the last available source color if the layer index exceeds the number of source colors.\n\"\"\"\n\ndef find_frame_and_bounding_box(grid):\n    \"\"\"\n    Finds the most likely frame object (largest hollow single-color rectangle)\n    and its bounding box.\n    Returns the frame color and its outer bounding box (min_r, min_c, max_r, max_c),\n    or (None, None) if no suitable frame is found.\n\n    Strategy:\n    1. Identify all non-background pixels and their colors/locations.\n    2. Count frequency of each non-background color.\n    3. Prioritize finding hollow rectangles: Iterate through unique colors.\n       For each color, find its bounding box. Check if the center is background.\n       Select the color forming the largest hollow rectangle.\n    4. If no hollow rectangle found, fallback: find the non-background object\n       with the largest bounding box area, even if not hollow. Use its color/bbox.\n    5. If still no object found, return None.\n    \"\"\"\n    non_background_pixels = []\n    colors_present = Counter()\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0:\n                non_background_pixels.append({'color': color, 'r': r, 'c': c})\n                colors_present[color] += 1\n\n    if not colors_present:\n        return None, None # No non-background pixels at all\n\n    best_frame_color = -1\n    best_bbox = None\n    max_hollow_area = -1\n    max_any_area = -1\n    fallback_color = -1\n    fallback_bbox = None\n\n    unique_colors = list(colors_present.keys())\n\n    for color in unique_colors:\n        coords = [(p['r'], p['c']) for p in non_background_pixels if p['color'] == color]\n        if not coords: continue\n\n        min_r = min(r for r, c in coords)\n        min_c = min(c for r, c in coords)\n        max_r = max(r for r, c in coords)\n        max_c = max(c for r, c in coords)\n        bbox = (min_r, min_c, max_r, max_c)\n        area = (max_r - min_r + 1) * (max_c - min_c + 1)\n\n        # Check for hollowness: requires size > 1x1 and inner point is background\n        is_hollow = False\n        if max_r > min_r and max_c > min_c:\n            # Check multiple interior points for robustness? For now, center.\n            # A more robust check would be ensuring all frame pixels are present and interior is empty\n            inner_r_start, inner_c_start = min_r + 1, min_c + 1\n            inner_r_end, inner_c_end = max_r - 1, max_c - 1\n            \n            # Simplistic check: is the top-left inner pixel background?\n            if grid[inner_r_start, inner_c_start] == 0:\n                 is_hollow = True # Assume hollow based on one point for now\n\n                 # More robust check (optional): Verify all interior points are background\n                 # all_interior_bg = True\n                 # for r_in in range(inner_r_start, inner_r_end + 1):\n                 #     for c_in in range(inner_c_start, inner_c_end + 1):\n                 #         if grid[r_in, c_in] != 0:\n                 #             all_interior_bg = False\n                 #             break\n                 #     if not all_interior_bg:\n                 #         break\n                 # is_hollow = all_interior_bg\n\n\n        if is_hollow:\n            if area > max_hollow_area:\n                max_hollow_area = area\n                best_frame_color = color\n                best_bbox = bbox\n        elif area > max_any_area: # Track largest non-hollow as fallback\n             max_any_area = area\n             fallback_color = color\n             fallback_bbox = bbox\n\n    # Prefer hollow frame, otherwise take largest object\n    if best_frame_color != -1:\n        # Further validation: ensure the detected bbox actually forms a rectangle of 'color'\n        is_valid_frame = True\n        # Check horizontal lines\n        for c in range(best_bbox[1], best_bbox[3] + 1):\n            if grid[best_bbox[0], c] != best_frame_color or grid[best_bbox[2], c] != best_frame_color:\n                is_valid_frame = False\n                break\n        # Check vertical lines\n        if is_valid_frame:\n            for r in range(best_bbox[0] + 1, best_bbox[2]):\n                 if grid[r, best_bbox[1]] != best_frame_color or grid[r, best_bbox[3]] != best_frame_color:\n                     is_valid_frame = False\n                     break\n        \n        if is_valid_frame:\n             return best_frame_color, best_bbox\n        else:\n             # Invalid frame structure detected, maybe fall back?\n             # For now, if the largest hollow candidate isn't a proper frame,\n             # we might need a more sophisticated detection or clear failure.\n             # Let's try the non-hollow fallback if the hollow one was invalid.\n             if fallback_color != -1:\n                 # We might want to validate the fallback too, but skipping for now\n                 return fallback_color, fallback_bbox\n             else:\n                 return None, None # No suitable frame found\n\n\n    elif fallback_color != -1:\n        # Use the largest non-hollow object if no hollow ones found\n        # We might not want to fill if it's not hollow, depends on task rules\n        # Based on examples, the task requires a hollow frame to fill.\n        # So, if only a solid object is found, maybe return None for frame?\n        # Re-evaluating: The original code assumed the most frequent color forms the frame.\n        # Let's stick to the \"largest hollow\" priority first. If no hollow frame, fail.\n         return None, None # No hollow frame found\n        # return fallback_color, fallback_bbox # uncomment if solid objects can be 'frames'\n    else:\n        return None, None # No frame found\n\ndef find_source_pixels(grid, frame_bbox):\n    \"\"\"\n    Finds non-white pixels outside the frame's bounding box.\n    Returns a list of dictionaries, each containing color, r, c, and sort_key (r+c).\n    \"\"\"\n    source_pixels = []\n    if frame_bbox is None:\n        # If no frame, consider all non-white pixels as sources?\n        # Or return empty list as per original logic? Let's stick to original.\n        return []\n\n    frame_min_r, frame_min_c, frame_max_r, frame_max_c = frame_bbox\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            # Check if pixel is outside the frame's bounding box\n            is_outside = (r < frame_min_r or r > frame_max_r or\n                          c < frame_min_c or c > frame_max_c)\n\n            if is_outside and grid[r, c] != 0:\n                source_pixels.append({\n                    'color': grid[r, c],\n                    'r': r,\n                    'c': c,\n                    'sort_key': r + c # Manhattan distance from origin (0,0)\n                })\n    return source_pixels\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n\n    # 1. Identify the Frame\n    # Find the hollow rectangular frame object and determine its color and bounding box.\n    frame_color, frame_bbox = find_frame_and_bounding_box(grid)\n\n    # If no frame is found, return the input grid unchanged.\n    if frame_bbox is None:\n        return output_grid.tolist()\n\n    frame_min_r, frame_min_c, frame_max_r, frame_max_c = frame_bbox\n\n    # 2. Find Source Pixels\n    # Identify all non-white pixels located outside the frame's bounding box.\n    source_pixels = find_source_pixels(grid, frame_bbox)\n\n    # 3. Order Source Colors\n    # Create an ordered list of colors from the source pixels, sorted by their position (ascending r + c).\n    source_pixels.sort(key=lambda p: p['sort_key'])\n    sorted_colors = [p['color'] for p in source_pixels]\n\n    # If there are no source pixels, return the input grid unchanged (no colors to fill with).\n    if not sorted_colors:\n        return output_grid.tolist()\n\n    # 4. Prepare Output Grid (already done by copying input)\n\n    # 5. Define the interior bounding box (pixels inside the frame walls)\n    inner_min_r = frame_min_r + 1\n    inner_min_c = frame_min_c + 1\n    inner_max_r = frame_max_r - 1\n    inner_max_c = frame_max_c - 1\n\n    # Check if there is an actual interior to fill\n    if inner_min_r > inner_max_r or inner_min_c > inner_max_c:\n        return output_grid.tolist() # Frame is too thin, no interior\n\n    # 6-9. Fill Interior\n    # Iterate through each pixel location (r, c) within the inner area.\n    for r in range(inner_min_r, inner_max_r + 1):\n        for c in range(inner_min_c, inner_max_c + 1):\n            # Check if the pixel was originally background (white) in the input.\n            if grid[r, c] == 0:\n                # Calculate its 'layer index': minimum distance to the inner boundary.\n                dist_r_min = r - inner_min_r\n                dist_r_max = inner_max_r - r\n                dist_c_min = c - inner_min_c\n                dist_c_max = inner_max_c - c\n                layer_index = min(dist_r_min, dist_r_max, dist_c_min, dist_c_max)\n\n                # Determine the color index, clamping to the available colors.\n                # Use the last color if layer_index >= number of colors.\n                color_index = min(layer_index, len(sorted_colors) - 1)\n\n                # Get the fill color from the sorted list.\n                fill_color = sorted_colors[color_index]\n\n                # Update the output grid with the fill color.\n                output_grid[r, c] = fill_color\n\n    # 10. Return Result\n    # Convert the result back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10997,
    "candidates_token_count": 2726,
    "total_token_count": 13723,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.545197,
  "retries": null
}