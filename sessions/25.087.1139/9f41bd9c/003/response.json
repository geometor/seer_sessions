{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid. The background color is blue (1).\n2. Identify the 'movable shape': Locate all gray (5) pixels and determine their bounding box (min/max row/col). Note the height (`shape_h`) and width (`shape_w`) of this bounding box. Extract the rectangular block of pixels (`shape_content`) from the input grid corresponding to this bounding box.\n3. Identify the 'floor area': Find the uppermost row index (`floor_top_row`) that contains magenta (6) pixels. Assume this marks the top of a solid magenta block at the bottom.\n4. Calculate the target destination for the 'movable shape':\n    a. Calculate the target top row: `target_row = floor_top_row - shape_h`.\n    b. Calculate the target left column: Find the horizontal center of the input grid (`grid_center_c = (grid_width - 1) / 2`) and the horizontal center of the 'movable shape's' initial bounding box (`shape_center_c = (min_col + max_col) / 2`). If `shape_center_c > grid_center_c`, set `target_col = 0`. Otherwise (if `shape_center_c <= grid_center_c`), set `target_col = grid_width - shape_w`.\n5. Clear the original position of the 'movable shape' in the output grid: Fill the area defined by the original bounding box with the background color (blue 1).\n6. Draw the 'movable shape' at the new position: Copy the extracted `shape_content` (including any non-gray pixels within the original bounding box) onto the output grid, starting at the calculated `(target_row, target_col)`.\n7. Modify the top row of the 'floor area': Iterate through each column index `c` from 0 to `grid_width - 1`. If the column `c` falls outside the horizontal range covered by the 'movable shape' in its *new* position (i.e., if `c < target_col` or `c >= target_col + shape_w`), change the pixel color at `(floor_top_row, c)` in the output grid to maroon (9). Pixels in `floor_top_row` that are under the moved shape remain magenta (6).\n\"\"\"\n\n# Helper functions\ndef find_object_bbox(grid, color):\n    \"\"\"Finds the bounding box of the first contiguous object of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None # Object not found\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    # Need to handle potentially multiple disconnected components,\n    # but examples suggest one main gray object.\n    # Assuming the bounding box covers all pixels of that color is sufficient here.\n    return min_r, min_c, max_r, max_c\n\ndef get_object_pixels(grid, bbox):\n    \"\"\"Extracts the pixels within a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef clear_area(grid, bbox, fill_color):\n    \"\"\"Fills a specified bounding box area with a given color.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    grid[min_r:max_r+1, min_c:max_c+1] = fill_color\n\ndef draw_object(grid, obj_pixels, top_left_coord):\n    \"\"\"Draws the object pixels onto the grid at a new location.\"\"\"\n    r_start, c_start = top_left_coord\n    obj_h, obj_w = obj_pixels.shape\n    r_end = r_start + obj_h\n    c_end = c_start + obj_w\n\n    # Ensure we don't draw outside grid bounds (basic clipping)\n    grid_h, grid_w = grid.shape\n    view_h = min(obj_h, grid_h - r_start)\n    view_w = min(obj_w, grid_w - c_start)\n    grid_view = grid[r_start:r_start+view_h, c_start:c_start+view_w]\n    obj_view = obj_pixels[:view_h, :view_w]\n\n    # Only draw if the shapes match (avoid broadcasting errors if clipping occurred unexpectedly)\n    if grid_view.shape == obj_view.shape:\n        grid[r_start:r_start+view_h, c_start:c_start+view_w] = obj_view\n    else:\n        # This case might indicate an issue with target calculation or grid dimensions\n        print(f\"Warning: Shape mismatch during drawing. Grid view: {grid_view.shape}, Obj view: {obj_view.shape}\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Constants for colors\n    BLUE = 1\n    GRAY = 5\n    MAGENTA = 6\n    MAROON = 9\n\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    grid_h, grid_w = output_grid.shape\n\n    # 2. Identify the 'movable shape' (gray object)\n    movable_shape_bbox = find_object_bbox(input_grid, GRAY)\n    if movable_shape_bbox is None:\n        # If no gray object found, return the original grid (or handle as error)\n        print(\"Warning: Gray object not found.\")\n        return output_grid\n\n    min_r, min_c, max_r, max_c = movable_shape_bbox\n    shape_h = max_r - min_r + 1\n    shape_w = max_c - min_c + 1\n    # Extract the actual content within the bounding box from the input grid\n    shape_content = get_object_pixels(input_grid, movable_shape_bbox)\n\n    # 3. Identify the 'floor area' top row\n    magenta_rows, _ = np.where(input_grid == MAGENTA)\n    if magenta_rows.size == 0:\n        # If no magenta floor found, maybe return original grid or error\n        print(\"Warning: Magenta floor area not found.\")\n        # Decide on behavior: return original, or perhaps define a default floor?\n        # Based on examples, assuming it's always present.\n        # As a fallback, maybe use the last row?\n        # For now, returning grid as is if no magenta.\n        return output_grid\n    floor_top_row = np.min(magenta_rows)\n\n    # 4. Calculate the target destination\n    # 4a. Target row\n    target_row = floor_top_row - shape_h\n\n    # 4b. Target column\n    grid_center_c = (grid_w - 1) / 2.0\n    shape_center_c = (min_c + max_c) / 2.0\n\n    if shape_center_c > grid_center_c:\n        # Initial position is right-biased, move to left edge\n        target_col = 0\n    else:\n        # Initial position is left-biased or centered, move to right edge\n        target_col = grid_w - shape_w\n\n    # Check if target position is valid (e.g., target_row is not negative)\n    if target_row < 0:\n        print(f\"Warning: Calculated target row ({target_row}) is out of bounds. Clamping to 0.\")\n        target_row = 0\n    # Target column calculation already ensures it's within bounds based on width\n\n    # 5. Clear the original position in the output grid\n    clear_area(output_grid, movable_shape_bbox, BLUE)\n\n    # 6. Draw the 'movable shape' content at the new position\n    draw_object(output_grid, shape_content, (target_row, target_col))\n\n    # 7. Modify the top row of the 'floor area'\n    for c in range(grid_w):\n        # Check if the column 'c' is *outside* the horizontal span of the moved object\n        is_outside_object = c < target_col or c >= target_col + shape_w\n        # Only change if it was originally magenta and is outside the new object span\n        if is_outside_object and input_grid[floor_top_row, c] == MAGENTA:\n             output_grid[floor_top_row, c] = MAROON\n        # Pixels originally magenta under the object remain magenta (implicitly handled by copy)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10974,
    "candidates_token_count": 2077,
    "total_token_count": 13051,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.94932,
  "retries": null
}