{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid. The background color is assumed to be blue (1).\n2. Identify the 'movable shape': Locate all gray (5) pixels and determine their bounding box (min/max row/col). Note the height (`shape_h`) and width (`shape_w`) of this bounding box. Extract the rectangular block of pixels (`shape_content`) from the input grid corresponding to this bounding box. This block includes any background (blue) pixels within the bounding box.\n3. Identify the 'floor area': Find the uppermost row index (`floor_top_row`) that contains magenta (6) pixels. Assume this marks the top of a solid magenta block at the bottom.\n4. Calculate the target destination for the 'movable shape':\n    a. Calculate the target top row: `target_row = floor_top_row - shape_h`.\n    b. Calculate the target left column: Find the horizontal center of the input grid (`grid_center_c = (grid_width - 1) / 2`) and the horizontal center of the 'movable shape's' initial bounding box (`shape_center_c = (min_col + max_col) / 2`). If `shape_center_c > grid_center_c` (shape starts on the right side), set `target_col = 0` (move to left edge). Otherwise (if `shape_center_c <= grid_center_c`, shape starts on the left or center), set `target_col = grid_width - shape_w` (move to right edge).\n5. Clear the original position of the 'movable shape' in the output grid: Fill the area defined by the original bounding box with the background color (blue 1).\n6. Draw the 'movable shape' at the new position: Copy the entire extracted `shape_content` (including gray and any internal blue pixels) to the output grid, with its top-left corner at the calculated `(target_row, target_col)`.\n7. Modify the top row of the 'floor area': Iterate through each column index `c` from 0 to `grid_width - 1`. If the column `c` falls outside the horizontal range covered by the 'movable shape' in its *new* position (i.e., if `c < target_col` or `c >= target_col + shape_w`) AND the pixel at `(floor_top_row, c)` in the *input* grid was magenta (6), change the pixel color at `(floor_top_row, c)` in the *output* grid to maroon (9). Pixels in `floor_top_row` that were originally magenta and are now under the moved shape remain magenta (6).\n\"\"\"\n\n# Imports\nimport numpy as np\n\n# Constants for colors\nBLUE = 1\nGRAY = 5\nMAGENTA = 6\nMAROON = 9\n\n# Helper functions\ndef find_object_bbox(grid, color):\n    \"\"\"Finds the bounding box of all pixels of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None # Object color not found\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    return min_r, min_c, max_r, max_c\n\ndef get_object_pixels(grid, bbox):\n    \"\"\"Extracts the pixels within a bounding box.\"\"\"\n    if bbox is None:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef clear_area(grid, bbox, fill_color):\n    \"\"\"Fills a specified bounding box area with a given color.\"\"\"\n    if bbox is None:\n        return\n    min_r, min_c, max_r, max_c = bbox\n    grid[min_r:max_r+1, min_c:max_c+1] = fill_color\n\ndef draw_object(grid, obj_pixels, top_left_coord):\n    \"\"\"\n    Draws the entire obj_pixels block onto the grid\n    at the specified top_left_coord.\n    Overwrites existing pixels.\n    \"\"\"\n    r_start, c_start = top_left_coord\n    obj_h, obj_w = obj_pixels.shape\n    grid_h, grid_w = grid.shape\n\n    # Calculate the destination slice boundaries\n    r_end = r_start + obj_h\n    c_end = c_start + obj_w\n\n    # Ensure boundaries are within the grid\n    r_end = min(r_end, grid_h)\n    c_end = min(c_end, grid_w)\n    r_start = max(r_start, 0)\n    c_start = max(c_start, 0)\n\n    # Calculate the source slice boundaries (if object partially off grid)\n    src_r_start = max(0, -top_left_coord[0])\n    src_c_start = max(0, -top_left_coord[1])\n    src_r_end = obj_h - max(0, r_end - grid_h)\n    src_c_end = obj_w - max(0, c_end - grid_w)\n    \n    # Check if there is anything to draw within bounds\n    if r_start < r_end and c_start < c_end:\n        grid[r_start:r_end, c_start:c_end] = obj_pixels[src_r_start:src_r_end, src_c_start:src_c_end]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    grid_h, grid_w = output_grid.shape\n\n    # 2. Identify the 'movable shape' (gray object)\n    movable_shape_bbox = find_object_bbox(input_grid, GRAY)\n    if movable_shape_bbox is None:\n        # If no gray object found, return the original grid (as per observed behavior)\n        return output_grid \n\n    min_r, min_c, max_r, max_c = movable_shape_bbox\n    shape_h = max_r - min_r + 1\n    shape_w = max_c - min_c + 1\n    # Extract the content (including background) within the bounding box\n    shape_content = get_object_pixels(input_grid, movable_shape_bbox)\n\n    # 3. Identify the 'floor area' top row\n    magenta_rows, _ = np.where(input_grid == MAGENTA)\n    if magenta_rows.size == 0:\n        # If no magenta floor found, return original (as per observed behavior)\n        return output_grid \n    floor_top_row = np.min(magenta_rows)\n\n    # 4. Calculate the target destination\n    # 4a. Target row\n    target_row = floor_top_row - shape_h\n\n    # 4b. Target column\n    grid_center_c = (grid_w - 1) / 2.0\n    shape_center_c = (min_c + max_c) / 2.0\n\n    if shape_center_c > grid_center_c:\n        # Initial position is right-biased, move to left edge\n        target_col = 0\n    else:\n        # Initial position is left-biased or centered, move to right edge\n        target_col = grid_w - shape_w\n\n    # Ensure target row is not negative (clamp if necessary)\n    # Although calculation seems to avoid this in examples, good practice.\n    target_row = max(0, target_row) \n\n    # 5. Clear the original position of the *bounding box* in the output grid\n    clear_area(output_grid, movable_shape_bbox, BLUE)\n\n    # 6. Draw the entire 'movable shape' content (including internal blue) at the new position\n    draw_object(output_grid, shape_content, (target_row, target_col))\n\n    # 7. Modify the top row of the 'floor area'\n    for c in range(grid_w):\n        # Check if the column 'c' is *outside* the horizontal span of the moved object's bounding box\n        is_outside_object = c < target_col or c >= target_col + shape_w\n        \n        # Check the color in the *original* grid at this position\n        original_color_at_floor = input_grid[floor_top_row, c]\n\n        # Only change to maroon if it was originally magenta AND is outside the new object span\n        if is_outside_object and original_color_at_floor == MAGENTA:\n             output_grid[floor_top_row, c] = MAROON\n        # Note: If it was originally magenta and is *under* the object's new span,\n        # it should remain magenta. The initial copy handles this base case.\n        # The draw_object function might overwrite it with gray/blue from the shape,\n        # but the floor modification step itself doesn't change these pixels back to magenta.\n        # This behavior matches the examples.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6899,
    "candidates_token_count": 2206,
    "total_token_count": 9105,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.206514,
  "retries": null
}