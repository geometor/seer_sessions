{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid. The background color is blue (1).\n2. Identify the 'movable shape': Locate all gray (5) pixels and determine their bounding box (min/max row/col). Note the height (`shape_h`) and width (`shape_w`) of this bounding box. Extract the rectangular block of pixels (`shape_content`) from the input grid corresponding to this bounding box.\n3. Identify the 'floor area': Find the uppermost row index (`floor_top_row`) that contains magenta (6) pixels. Assume this marks the top of a solid magenta block at the bottom.\n4. Calculate the target destination for the 'movable shape':\n    a. Calculate the target top row: `target_row = floor_top_row - shape_h`.\n    b. Calculate the target left column: Find the horizontal center of the input grid (`grid_center_c = (grid_width - 1) / 2`) and the horizontal center of the 'movable shape's' initial bounding box (`shape_center_c = (min_col + max_col) / 2`). If `shape_center_c > grid_center_c`, set `target_col = 0`. Otherwise (if `shape_center_c <= grid_center_c`), set `target_col = grid_width - shape_w`.\n5. Clear the original position of the 'movable shape' in the output grid: Fill the area defined by the original bounding box with the background color (blue 1).\n6. Draw the 'movable shape' at the new position: Iterate through the pixels within the extracted `shape_content`. If a pixel's color is gray (5), copy it to the corresponding position relative to the calculated `(target_row, target_col)` in the output grid. Other pixels within the `shape_content` (e.g., background blue) are *not* copied; the destination grid retains its background color in those positions.\n7. Modify the top row of the 'floor area': Iterate through each column index `c` from 0 to `grid_width - 1`. If the column `c` falls outside the horizontal range covered by the 'movable shape' in its *new* position (i.e., if `c < target_col` or `c >= target_col + shape_w`), change the pixel color at `(floor_top_row, c)` in the output grid to maroon (9). Pixels in `floor_top_row` that are under the moved shape remain magenta (6).\n\"\"\"\n\n# Imports\nimport numpy as np\n\n# Helper functions\ndef find_object_bbox(grid, color):\n    \"\"\"Finds the bounding box of all pixels of a given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None # Object color not found\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    return min_r, min_c, max_r, max_c\n\ndef get_object_pixels(grid, bbox):\n    \"\"\"Extracts the pixels within a bounding box.\"\"\"\n    if bbox is None:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef clear_area(grid, bbox, fill_color):\n    \"\"\"Fills a specified bounding box area with a given color.\"\"\"\n    if bbox is None:\n        return\n    min_r, min_c, max_r, max_c = bbox\n    grid[min_r:max_r+1, min_c:max_c+1] = fill_color\n\ndef draw_object_selective(grid, obj_pixels, top_left_coord, object_color):\n    \"\"\"\n    Draws only the pixels of 'object_color' from 'obj_pixels' onto the grid\n    at the specified 'top_left_coord'. Other pixels in 'obj_pixels' are ignored,\n    leaving the grid's existing background color intact.\n    \"\"\"\n    r_start, c_start = top_left_coord\n    obj_h, obj_w = obj_pixels.shape\n    grid_h, grid_w = grid.shape\n\n    for r_offset in range(obj_h):\n        for c_offset in range(obj_w):\n            # Calculate target grid coordinates\n            target_r = r_start + r_offset\n            target_c = c_start + c_offset\n\n            # Check if the source pixel is the object color\n            if obj_pixels[r_offset, c_offset] == object_color:\n                # Check if the target coordinates are within grid bounds\n                if 0 <= target_r < grid_h and 0 <= target_c < grid_w:\n                    grid[target_r, target_c] = object_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Constants for colors\n    BLUE = 1\n    GRAY = 5\n    MAGENTA = 6\n    MAROON = 9\n\n    # 1. Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    grid_h, grid_w = output_grid.shape\n\n    # 2. Identify the 'movable shape' (gray object)\n    movable_shape_bbox = find_object_bbox(input_grid, GRAY)\n    if movable_shape_bbox is None:\n        # If no gray object found, return the original grid\n        # print(\"Warning: Gray object not found.\") # Keep commented unless debugging\n        return output_grid # Task seems to assume the object is always present\n\n    min_r, min_c, max_r, max_c = movable_shape_bbox\n    shape_h = max_r - min_r + 1\n    shape_w = max_c - min_c + 1\n    # Extract the content within the bounding box from the input grid\n    shape_content = get_object_pixels(input_grid, movable_shape_bbox)\n\n    # 3. Identify the 'floor area' top row\n    magenta_rows, _ = np.where(input_grid == MAGENTA)\n    if magenta_rows.size == 0:\n        # If no magenta floor found, assume it's always present per examples.\n        # print(\"Warning: Magenta floor area not found.\") # Keep commented unless debugging\n        return output_grid # Or handle error appropriately\n    floor_top_row = np.min(magenta_rows)\n\n    # 4. Calculate the target destination\n    # 4a. Target row\n    target_row = floor_top_row - shape_h\n\n    # 4b. Target column\n    grid_center_c = (grid_w - 1) / 2.0\n    shape_center_c = (min_c + max_c) / 2.0\n\n    if shape_center_c > grid_center_c:\n        # Initial position is right-biased, move to left edge\n        target_col = 0\n    else:\n        # Initial position is left-biased or centered, move to right edge\n        target_col = grid_w - shape_w\n\n    # Ensure target row is not negative (clamp if necessary)\n    if target_row < 0:\n        # print(f\"Warning: Calculated target row ({target_row}) is out of bounds. Clamping to 0.\") # Keep commented\n        target_row = 0\n\n    # 5. Clear the original position of the *bounding box* in the output grid\n    #    We clear the whole bounding box area, not just gray pixels.\n    clear_area(output_grid, movable_shape_bbox, BLUE)\n\n    # 6. Draw only the gray parts of the 'movable shape' content at the new position\n    draw_object_selective(output_grid, shape_content, (target_row, target_col), GRAY)\n\n    # 7. Modify the top row of the 'floor area'\n    for c in range(grid_w):\n        # Check if the column 'c' is *outside* the horizontal span of the moved object's bounding box\n        is_outside_object = c < target_col or c >= target_col + shape_w\n        # Only change if it was originally magenta AND is outside the new object span\n        # Note: We check the *original* grid for magenta color to avoid issues if\n        # the object was initially overlapping the floor row.\n        if is_outside_object and input_grid[floor_top_row, c] == MAGENTA:\n             output_grid[floor_top_row, c] = MAROON\n        # If the pixel was originally magenta and is *under* the object's new span,\n        # it should remain magenta. The copy handles this unless the object overwrites it.\n        # Our selective draw ensures the floor below the object isn't changed unless\n        # the object itself lands on that row (which it does by definition here).\n        # Let's ensure that if a pixel under the object *wasn't* magenta originally, it doesn't become magenta.\n        elif not is_outside_object:\n            # If under the object, ensure it's magenta ONLY IF it was originally magenta.\n            # The initial copy handles this, but being explicit might prevent edge cases.\n            # If the target_row happens to be the floor_top_row, draw_object_selective might\n            # place gray pixels there. The floor modification happens after, so we need to ensure\n            # the rule applies correctly: parts under the object stay magenta *if they were magenta*.\n            # Let's refine the logic slightly:\n            # The floor row modification only applies to pixels that were initially magenta.\n            if input_grid[floor_top_row, c] == MAGENTA:\n                 # If it was magenta and outside, it becomes maroon (handled above).\n                 # If it was magenta and inside, it stays magenta (implicitly handled by copy,\n                 # unless overwritten by the object itself landing exactly on this row,\n                 # which shouldn't happen based on target_row calculation `floor_top_row - shape_h`).\n                 # Let's ensure it stays magenta if under the object.\n                 output_grid[floor_top_row, c] = MAGENTA\n            # else: if it wasn't magenta originally, it stays whatever it became (likely blue from clearing).\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6534,
    "candidates_token_count": 2442,
    "total_token_count": 8976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 106.486755,
  "retries": null
}