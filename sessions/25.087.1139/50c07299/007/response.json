{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Find the diagonal segment of red (2) pixels in the input grid. This segment runs from top-right to bottom-left.\n2. Determine the length (L_in) of the input segment.\n3. Identify the coordinates (r_in, c_in) of the top-rightmost pixel of the input segment (the pixel with the minimum row index).\n4. Calculate the length of the output segment: L_out = L_in + 1.\n5. Calculate the coordinates (r_out, c_out) for the top-rightmost pixel of the output segment using the following formulas:\n   - r_out = r_in - L_out\n   - c_out = c_in + min(L_out, 3) \n   (The column offset is capped at 3).\n6. Initialize an output grid with the same dimensions as the input grid, filled entirely with the background color, orange (7).\n7. Draw the output segment onto the output grid based on its length (L_out):\n   - If L_out is 4: Starting from (r_out, c_out), place L_out red pixels using relative coordinates (r_out + i, c_out - max(0, i - 1)) for i from 0 to L_out - 1.\n   - Otherwise (L_out is 2 or 3): Starting from (r_out, c_out), place L_out red pixels using relative coordinates (r_out + i, c_out - i) for i from 0 to L_out - 1.\n   - Ensure pixel coordinates are within the grid boundaries before drawing.\n8. Return the final output grid.\n\"\"\"\n\ndef find_colored_pixels(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels of a specific color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of (row, column) tuples for pixels matching the color.\n    \"\"\"\n    pixels = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                pixels.append((r, c))\n    return pixels\n\ndef get_segment_properties(pixels):\n    \"\"\"\n    Determines the length and top-right pixel of a diagonal segment.\n    Assumes pixels form a top-right to bottom-left diagonal segment.\n\n    Args:\n        pixels (list): A list of (row, column) coordinates of the segment pixels.\n\n    Returns:\n        tuple: A tuple containing (length, (top_right_row, top_right_col)).\n               Returns (0, (-1, -1)) if no pixels are provided.\n    \"\"\"\n    if not pixels:\n        return 0, (-1, -1) # No segment found\n\n    length = len(pixels)\n    # For a top-right to bottom-left diagonal, the pixel with the minimum row index\n    # is the top-rightmost one (and also has the maximum column index among segment pixels).\n    top_right_pixel = min(pixels, key=lambda p: p[0])\n\n    return length, top_right_pixel\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid. Finds a red diagonal segment,\n    increases its length by one, calculates a new top-right starting position,\n    and draws the new segment on an orange background using a drawing rule\n    that depends on the output segment's length.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Define colors\n    background_color = 7 # orange\n    foreground_color = 2 # red\n\n    # 1. Find red pixels (input segment)\n    red_pixels = find_colored_pixels(input_np, foreground_color)\n\n    # 2. & 3. Determine input segment properties\n    length_in, (r_in, c_in) = get_segment_properties(red_pixels)\n\n    # Handle case where no red segment is found (return a grid filled with background)\n    if length_in == 0:\n        return np.full_like(input_np, background_color).tolist()\n\n    # 4. Calculate output segment length\n    length_out = length_in + 1\n\n    # 5. Calculate output segment top-right position\n    # The row position moves up by the length of the *output* segment.\n    r_out = r_in - length_out\n    # The column position moves right by the length of the *output* segment, but capped at 3.\n    c_out = c_in + min(length_out, 3)\n\n    # 6. Initialize output grid with the background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # 7. Draw the output segment based on its length\n    for i in range(length_out):\n        draw_r = r_out + i\n        \n        # Determine the column offset based on the output length L_out\n        if length_out == 4:\n            # Special drawing rule for length 4\n            col_offset = max(0, i - 1) \n        else:\n            # Standard diagonal drawing rule for length 2 or 3\n            col_offset = i\n            \n        draw_c = c_out - col_offset\n            \n        # Check grid boundaries before drawing the pixel\n        if 0 <= draw_r < rows and 0 <= draw_c < cols:\n            output_grid[draw_r, draw_c] = foreground_color\n\n    # 8. Return the output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7866,
    "candidates_token_count": 1409,
    "total_token_count": 9275,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.010887,
  "retries": null
}