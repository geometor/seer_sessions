{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict\n\n\"\"\"\nThe transformation identifies the group of all non-orange (non-7) pixels in the input grid.\nIt determines which edge of the grid (top, bottom, left, right) contains the most pixels belonging to this group.\nThe entire group of non-orange pixels is then translated rigidly to the corresponding opposite edge of the grid.\nThe output grid is initialized with the background color (orange/7), and then the translated non-orange pixels are drawn onto it.\n\nSpecifically:\n1. Find all coordinates of pixels that are not orange (color 7).\n2. If no such pixels exist, return the input grid unchanged.\n3. Count how many of these non-orange pixels lie on the top edge (row 0), bottom edge (row H-1), left edge (col 0), and right edge (col W-1).\n4. Identify the edge with the maximum count. Use a tie-breaking priority: Bottom > Top > Right > Left.\n5. Calculate the necessary translation vector (dr, dc) to move the entire group of non-orange pixels so that the identified dominant edge aligns with the opposite edge of the grid, while maintaining the group's internal structure.\n   - If the dominant edge is Top, move to the Bottom edge.\n   - If the dominant edge is Bottom, move to the Top edge.\n   - If the dominant edge is Left, move to the Right edge.\n   - If the dominant edge is Right, move to the Left edge.\n6. Create a new grid filled with the background color (orange/7).\n7. Place the non-orange pixels from the input grid into the new grid at their translated coordinates.\n\"\"\"\n\ndef find_object_pixels(grid: np.ndarray, background_color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds coordinates of all non-background pixels.\"\"\"\n    return list(zip(*np.where(grid != background_color)))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box of the given coordinates.\"\"\"\n    if not coords:\n        return -1, -1, -1, -1\n    rows, cols = zip(*coords)\n    return min(rows), max(rows), min(cols), max(cols)\n\ndef count_edge_pixels(coords: List[Tuple[int, int]], H: int, W: int) -> Dict[str, int]:\n    \"\"\"Counts how many coordinates lie on each grid edge.\"\"\"\n    counts = {'top': 0, 'bottom': 0, 'left': 0, 'right': 0}\n    if not coords:\n        return counts\n\n    for r, c in coords:\n        if r == 0:\n            counts['top'] += 1\n        if r == H - 1:\n            counts['bottom'] += 1\n        if c == 0:\n            counts['left'] += 1\n        if c == W - 1:\n            counts['right'] += 1\n    return counts\n\ndef determine_dominant_edge(counts: Dict[str, int]) -> str:\n    \"\"\"Determines the dominant edge based on counts and tie-breaking.\"\"\"\n    # Priority: Bottom > Top > Right > Left\n    max_count = -1\n    dominant_edge = 'none'\n\n    # Check in priority order\n    if counts['bottom'] > max_count:\n        max_count = counts['bottom']\n        dominant_edge = 'bottom'\n    # Important: Use >= for subsequent checks to handle ties correctly according to priority\n    if counts['top'] >= max_count:\n        # If counts['top'] == max_count, it replaces 'bottom' only if 'bottom' wasn't the max\n        # If counts['top'] > max_count, it becomes the new max\n        if counts['top'] > max_count or dominant_edge != 'bottom':\n             max_count = counts['top']\n             dominant_edge = 'top'\n    if counts['right'] >= max_count:\n         if counts['right'] > max_count or dominant_edge not in ['bottom', 'top']:\n            max_count = counts['right']\n            dominant_edge = 'right'\n    if counts['left'] >= max_count:\n        if counts['left'] > max_count or dominant_edge not in ['bottom', 'top', 'right']:\n            # This condition is technically redundant if logic above is correct,\n            # but kept for clarity. If left count is >= current max, and\n            # current max wasn't already set by a higher priority edge,\n            # then left becomes dominant.\n             max_count = counts['left']\n             dominant_edge = 'left'\n\n    # Refined Tie-breaking logic based on priority explicitly\n    max_val = 0\n    for edge in ['top', 'bottom', 'left', 'right']:\n        max_val = max(max_val, counts[edge])\n\n    if counts['bottom'] == max_val:\n        return 'bottom'\n    if counts['top'] == max_val:\n        return 'top'\n    if counts['right'] == max_val:\n        return 'right'\n    if counts['left'] == max_val:\n        return 'left'\n\n    # Should not be reached if there are any edge pixels\n    return 'none'\n\n\ndef calculate_translation(dominant_edge: str, H: int, W: int, min_r: int, max_r: int, min_c: int, max_c: int) -> Tuple[int, int]:\n    \"\"\"Calculates the translation vector (dr, dc) based on the dominant edge.\"\"\"\n    dr, dc = 0, 0\n    if dominant_edge == 'bottom':\n        # Move to top edge: Target min_r is 0\n        dr = 0 - min_r\n    elif dominant_edge == 'top':\n        # Move to bottom edge: Target max_r is H - 1\n        dr = (H - 1) - max_r\n    elif dominant_edge == 'right':\n        # Move to left edge: Target min_c is 0\n        dc = 0 - min_c\n    elif dominant_edge == 'left':\n        # Move to right edge: Target max_c is W - 1\n        dc = (W - 1) - max_c\n    return dr, dc\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Moves the group of non-background pixels based on the dominant edge count\n    to the opposite edge.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    H, W = input_arr.shape\n    background_color = 7\n\n    # Find all non-background pixels\n    object_pixels_coords = find_object_pixels(input_arr, background_color)\n\n    # If no object pixels, return the original grid\n    if not object_pixels_coords:\n        return input_grid\n\n    # Get bounding box of the object pixels\n    min_r, max_r, min_c, max_c = get_bounding_box(object_pixels_coords)\n\n    # Count pixels on each edge\n    edge_counts = count_edge_pixels(object_pixels_coords, H, W)\n\n    # Determine the dominant edge\n    dominant_edge = determine_dominant_edge(edge_counts)\n\n    # If no dominant edge found (e.g., object fully internal), no move\n    if dominant_edge == 'none':\n         return input_grid\n\n    # Calculate the translation vector\n    dr, dc = calculate_translation(dominant_edge, H, W, min_r, max_r, min_c, max_c)\n\n    # Initialize the output grid with the background color\n    output_arr = np.full((H, W), background_color, dtype=int)\n\n    # Copy the object pixels to their new locations\n    for r, c in object_pixels_coords:\n        color = input_arr[r, c]\n        nr, nc = r + dr, c + dc\n\n        # Ensure the new coordinates are within the grid bounds\n        # (Should always be if calculations are correct, but good practice)\n        if 0 <= nr < H and 0 <= nc < W:\n            output_arr[nr, nc] = color\n        # else:\n            # This case indicates an error in translation logic if pixels move out of bounds\n            # print(f\"Warning: Pixel ({r},{c}) moved out of bounds to ({nr},{nc})\")\n\n\n    # Convert back to list of lists for the expected output format\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5234,
    "candidates_token_count": 1986,
    "total_token_count": 7220,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 228.294972,
  "retries": null
}