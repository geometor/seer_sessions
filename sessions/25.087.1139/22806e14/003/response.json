{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nimport math\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent pixel value).\n2. Identify two other distinct colors present in the grid: \n   - `color_A`: The color that forms exactly one contiguous object (using 4-way adjacency).\n   - `color_B`: The color that forms more than one contiguous object.\n3. Create a copy of the input grid to serve as the output grid.\n4. Iterate through each distinct object formed by `color_B`:\n   a. Calculate the geometric center of the object (average row and column index).\n   b. Check if both the average row and column indices are integers (or very close to integers).\n   c. If they are integers, determine the integer coordinate `(center_r, center_c)`.\n   d. Check if the pixel at `(center_r, center_c)` is part of the current `color_B` object being examined.\n   e. If all conditions (integer center within the object) are met, change the color of the pixel at `(center_r, center_c)` in the output grid to `color_A`.\n5. Compare the numerical values of `color_A` and `color_B`.\n6. If `color_A` is numerically less than `color_B`:\n   a. Find the single object originally formed by `color_A`.\n   b. Change the color of all pixels belonging to this `color_A` object to the `background_color` in the output grid.\n7. If `color_A` is not less than `color_B` (i.e., greater than or equal to), the original `color_A` object remains untouched in the output grid (unless its pixel was somehow part of a `color_B` object's center, which is definitionally impossible).\n8. Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using BFS.\n    Contiguity is defined by 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the pixels of a single object. Returns an empty\n                   list if no objects of the specified color are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited,\n            # start a BFS to find the entire object it belongs to.\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)]) # Use deque for efficient queue operations\n                visited[r, c] = True\n                obj_pixels.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds and if the neighbor is the correct color and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_pixels.add((nr, nc))\n                \n                # Add the found object (set of pixels) to the list\n                if obj_pixels: # Ensure we don't add empty sets if logic somehow allows\n                     objects.append(obj_pixels)\n                     \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Handle empty or invalid input early\n    if input_np.size == 0:\n        return []\n        \n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # 1. Find background color (most frequent pixel value)\n    all_pixels = input_np.flatten()\n    # Use max_value + 1 for bins to handle colors 0-9 correctly\n    counts = np.bincount(all_pixels, minlength=10) \n    bg_color = np.argmax(counts)\n    \n    # 2. Find non-background colors and find/count their objects\n    unique_colors = np.unique(all_pixels)\n    non_bg_colors = unique_colors[unique_colors != bg_color]\n    \n    color_a = None\n    color_b = None\n    object_a_pixels = None\n    objects_b = [] # Store list of pixel sets for color_b objects\n\n    for color in non_bg_colors:\n        objects = find_objects(input_np, color)\n        num_objects = len(objects)\n        \n        if num_objects == 1:\n            if color_a is not None:\n                # Found more than one color with a single object, ambiguity\n                # print(f\"Warning: Found multiple colors with 1 object ({color_a}, {color}). Aborting.\")\n                return input_grid # Return original grid if pattern unclear\n            color_a = color\n            object_a_pixels = objects[0] # Store the pixels of the single object\n            \n        elif num_objects > 1:\n            if color_b is not None:\n                # Found more than one color with multiple objects, ambiguity\n                # print(f\"Warning: Found multiple colors with >1 object ({color_b}, {color}). Aborting.\")\n                return input_grid # Return original grid if pattern unclear\n            color_b = color\n            objects_b = objects # Store the list of objects for color_b\n\n    # Check if we successfully identified one color_A and one color_B\n    if color_a is None or color_b is None or object_a_pixels is None:\n        # print(f\"Warning: Could not uniquely identify color_A (found {color_a}) and color_B (found {color_b}). Aborting.\")\n        return input_grid # Return original grid if pattern doesn't match\n\n    # 3. Create output grid (already done with np.copy)\n\n    # 4. Modify centers of B Objects\n    for obj_b_pixels in objects_b:\n        if not obj_b_pixels: continue # Skip empty sets if they somehow occur\n\n        # Calculate geometric center\n        sum_r = sum(r for r, c in obj_b_pixels)\n        sum_c = sum(c for r, c in obj_b_pixels)\n        count = len(obj_b_pixels)\n        \n        if count == 0: continue \n\n        avg_r = sum_r / count\n        avg_c = sum_c / count\n\n        # Check if center has integer coordinates using math.isclose for robustness\n        # Check against rounded values to see if they are the same\n        is_int_center = math.isclose(avg_r, round(avg_r)) and math.isclose(avg_c, round(avg_c))\n\n        if is_int_center:\n            center_r, center_c = int(round(avg_r)), int(round(avg_c))\n            \n            # Check if the integer center pixel is within grid bounds\n            if 0 <= center_r < rows and 0 <= center_c < cols:\n                 # Check if the integer center pixel is part of the current object\n                if (center_r, center_c) in obj_b_pixels:\n                    # Change center pixel color in the output grid to Color A\n                    output_np[center_r, center_c] = color_a\n\n    # 5. & 6. Conditionally Remove A Object\n    if color_a < color_b:\n        # Remove the object A by setting its pixels to background color\n        for r, c in object_a_pixels:\n             # Check bounds just in case, though pixels should be valid\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_np[r, c] = bg_color\n    # 7. Otherwise (color_a >= color_b), do nothing to the A object.\n\n    # 8. Return the modified grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12492,
    "candidates_token_count": 2033,
    "total_token_count": 14525,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.241681,
  "retries": null
}