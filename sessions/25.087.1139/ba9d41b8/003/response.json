{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set\n\n\"\"\"\nIdentifies solid, non-white rectangular blocks in the input grid. \nFor each identified rectangle that has an interior (height > 2 and width > 2), \nit applies a checkerboard pattern to its interior pixels (pixels not on the border). \nThe specific checkerboard pattern depends on the parity of the sum of the coordinates \nof the rectangle's top-left corner (origin). \nIf the origin's coordinate sum (min_r + min_c) is even, interior pixels at (r, c) \nwhere r + c is also even are changed to white (0). \nIf the origin's coordinate sum is odd, interior pixels at (r, c) where r + c is \nalso odd are changed to white (0). \nPixels on the border of the rectangles, pixels in rectangles without an interior, \nand background pixels remain unchanged.\n\"\"\"\n\n\ndef find_solid_rectangles(grid_np: np.ndarray) -> List[Tuple[Tuple[int, int, int, int], int]]:\n    \"\"\"\n    Finds all solid, axis-aligned rectangles of a single non-white color in the grid.\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n\n    Returns:\n        A list where each element is a tuple containing:\n        - A tuple representing the bounding box: (min_row, min_col, max_row, max_col)\n        - An integer representing the color of the rectangle.\n    \"\"\"\n    height, width = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    rectangles = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid_np[r, c]\n            # Check if pixel is non-white (not 0) and hasn't been processed yet\n            if color != 0 and not visited[r, c]:\n                component_pixels: List[Tuple[int, int]] = []\n                q: List[Tuple[int, int]] = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                current_color = color\n\n                # Perform Breadth-First Search (BFS) to find all connected pixels of the same color\n                head = 0\n                while head < len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n                    \n                    # Check if the pixel actually has the component color (important if BFS was initiated on a border pixel of a multi-color shape by mistake, although less likely here)\n                    if grid_np[curr_r, curr_c] != current_color:\n                        # This branch shouldn't be reached with the initial check, but as safeguard\n                        continue \n                        \n                    component_pixels.append((curr_r, curr_c))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check bounds, if neighbor has the same color, and hasn't been visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # After finding the connected component, verify if it forms a solid rectangle\n                is_solid_rectangle = True\n                expected_pixel_count = (max_r - min_r + 1) * (max_c - min_c + 1)\n\n                # Check if the number of pixels in the component matches the bounding box area\n                if len(component_pixels) != expected_pixel_count:\n                    is_solid_rectangle = False\n                else:\n                    # Verify that all pixels *within* the bounding box in the original grid\n                    # actually have the component's color. This confirms solidity.\n                    # We mark these visited pixels during verification to avoid redundant checks.\n                    for check_r in range(min_r, max_r + 1):\n                        for check_c in range(min_c, max_c + 1):\n                            if grid_np[check_r, check_c] != current_color:\n                                is_solid_rectangle = False\n                                break\n                            # Also mark as visited to prevent re-processing pixels of this rectangle\n                            visited[check_r, check_c] = True \n                        if not is_solid_rectangle:\n                            break\n                \n                # If it's a confirmed solid rectangle, store its bounding box and color\n                if is_solid_rectangle:\n                    rectangles.append(((min_r, min_c, max_r, max_c), current_color))\n\n    return rectangles\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies a checkerboard pattern to the interior of solid colored rectangles,\n    with the pattern phase determined by the top-left corner's coordinate parity.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # Initialize the output grid as a copy of the input grid\n    output_grid = grid_np.copy()\n    \n    # Find all solid rectangles in the input grid\n    solid_rectangles = find_solid_rectangles(grid_np)\n\n    # Process each identified solid rectangle\n    for (min_r, min_c, max_r, max_c), color in solid_rectangles:\n        # Check if the rectangle has an interior (height > 2 and width > 2)\n        has_interior = (max_r - min_r > 1) and (max_c - min_c > 1)\n        \n        if has_interior:\n            # Calculate the parity of the top-left corner (origin)\n            origin_parity = (min_r + min_c) % 2\n            \n            # Iterate through the interior pixels of the rectangle\n            # The interior excludes the border rows (min_r, max_r) and columns (min_c, max_c)\n            for r in range(min_r + 1, max_r):\n                for c in range(min_c + 1, max_c):\n                    # Calculate the parity of the current interior pixel's coordinates\n                    pixel_parity = (r + c) % 2\n                    \n                    # Apply the checkerboard pattern based on origin parity:\n                    # If the pixel parity matches the origin parity, change the pixel to white (0)\n                    if pixel_parity == origin_parity:\n                        output_grid[r, c] = 0\n                        \n    # Convert the modified NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14999,
    "candidates_token_count": 1707,
    "total_token_count": 16706,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.469031,
  "retries": null
}