{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule involves identifying two types of structures in the input grid: \"templates\" and \"triggers\".\n\n1.  **Template Identification:**\n    *   A template consists of a single \"inner pixel\" of color C_inner surrounded by an \"outer shape\" made of a single color C_outer (where C_inner != C_outer).\n    *   The key condition is that all non-background neighbors (8-way connectivity, including diagonals) of the inner pixel must belong to the *same* contiguous outer shape of color C_outer.\n    *   Multiple templates might exist in the grid.\n\n2.  **Trigger Identification:**\n    *   A trigger is a single pixel of color C_trigger that has no neighbors (8-way connectivity) of the same color C_trigger.\n    *   A pixel identified as the inner pixel of a template cannot simultaneously be a trigger.\n\n3.  **Transformation Process:**\n    *   Initialize the output grid as a copy of the input grid.\n    *   Find all templates and triggers in the input grid.\n    *   For each identified trigger pixel (color C_trigger at location L_trigger):\n        *   Find all identified templates whose inner pixel color (C_inner) matches C_trigger.\n        *   For each matching template:\n            *   Calculate the relative position of all pixels (inner and outer) in the template with respect to its original inner pixel location (L_inner_original).\n            *   Copy the template structure (inner pixel color C_inner and outer shape color C_outer).\n            *   Paste this copied structure onto the output grid, anchoring it such that the template's inner pixel is placed at the trigger's location (L_trigger). The outer shape pixels are placed relative to this new anchor point.\n            *   Pasting overwrites existing pixel values in the output grid.\n    *   If multiple templates match a trigger, or multiple triggers exist, apply the pasting process for all valid trigger-template pairs. The examples suggest placements are usually distinct, but the rule implies overwriting if overlaps occur.\n    *   The final output grid contains the original grid modified by the pasted templates.\n\"\"\"\n\ndef find_contiguous_object(grid, start_r, start_c, target_color):\n    \"\"\"Finds all connected pixels of target_color starting from (start_r, start_c) using BFS.\"\"\"\n    if grid[start_r, start_c] != target_color:\n        return set()\n\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    object_pixels = set([(start_r, start_c)])\n\n    while q:\n        r, c = q.popleft()\n\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                if 0 <= nr < rows and 0 <= nc < cols and \\\n                   grid[nr, nc] == target_color and \\\n                   (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    object_pixels.add((nr, nc))\n                    q.append((nr, nc))\n    return object_pixels\n\ndef get_neighbors(grid, r, c):\n    \"\"\"Gets coordinates and colors of 8-way neighbors.\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append(((nr, nc), grid[nr, nc]))\n    return neighbors\n\ndef identify_templates_and_triggers(grid):\n    \"\"\"Identifies templates and triggers in the grid.\"\"\"\n    rows, cols = grid.shape\n    templates = []\n    potential_triggers = []\n    template_inner_pixels = set()\n\n    # Step 1: Identify potential templates and their inner pixels\n    for r in range(rows):\n        for c in range(cols):\n            inner_color = grid[r, c]\n            if inner_color == 0:  # Skip background\n                continue\n\n            neighbors = get_neighbors(grid, r, c)\n            non_bg_neighbors = [(loc, color) for loc, color in neighbors if color != 0]\n\n            if not non_bg_neighbors:\n                continue # Isolated pixel, might be a trigger, handle later\n\n            # Check if all non-bg neighbors have the same color C_outer != inner_color\n            first_outer_color = non_bg_neighbors[0][1]\n            if inner_color == first_outer_color:\n                continue # Neighbors are same color as center pixel\n\n            all_same_outer_color = True\n            for _, color in non_bg_neighbors:\n                if color != first_outer_color:\n                    all_same_outer_color = False\n                    break\n\n            if not all_same_outer_color:\n                continue # Neighbors have mixed colors\n\n            # Now check if these neighbors belong to a single contiguous object\n            outer_color = first_outer_color\n            start_nr, start_nc = non_bg_neighbors[0][0]\n            outer_object_pixels = find_contiguous_object(grid, start_nr, start_nc, outer_color)\n\n            # Verify all non_bg_neighbors are part of this single object\n            part_of_same_object = True\n            for loc, _ in non_bg_neighbors:\n                if loc not in outer_object_pixels:\n                    part_of_same_object = False\n                    break\n\n            if part_of_same_object:\n                # Found a template!\n                template_inner_pixels.add((r,c))\n                templates.append({\n                    'inner_color': inner_color,\n                    'inner_loc': (r, c),\n                    'outer_color': outer_color,\n                    'outer_pixels': outer_object_pixels\n                })\n\n    # Step 2: Identify potential triggers (isolated pixels)\n    for r in range(rows):\n        for c in range(cols):\n            trigger_color = grid[r, c]\n            if trigger_color == 0:\n                continue\n\n            neighbors = get_neighbors(grid, r, c)\n            has_same_color_neighbor = False\n            for _, color in neighbors:\n                if color == trigger_color:\n                    has_same_color_neighbor = True\n                    break\n\n            if not has_same_color_neighbor:\n                 potential_triggers.append({\n                    'color': trigger_color,\n                    'loc': (r, c)\n                 })\n\n    # Step 3: Filter triggers - remove any that were template inner pixels\n    triggers = [pt for pt in potential_triggers if pt['loc'] not in template_inner_pixels]\n\n    return templates, triggers\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the template copying transformation based on triggers.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    rows, cols = output_grid.shape\n\n    # Identify all templates and triggers in the original input grid\n    templates, triggers = identify_templates_and_triggers(input_grid_np)\n\n    if not triggers or not templates:\n        # Handle train_1 case specifically if needed, or return copy if no operation\n        # For now, if no templates/triggers match, return copy\n        # Let's check train 1: it might fall here\n        # Train 1 Input analysis:\n        # Green pixel (3) at (2,2) - isolated\n        # Azure object (8) at (2,3), (2,4), (3,2) - surrounds Green? Neighbors of (2,2) are (2,3)=8, (3,2)=8. Yes. Template? inner=3, outer=8\n        # Red pixel (2) at (1,10) - isolated\n        # Yellow pixel (4) at (7,6) - isolated\n        # Red pixel (2) at (7,7) - isolated\n        # Yellow object (4) at (7,8), (8,7), (8,8). Neighbors of (7,7)=2 are (7,6)=4, (7,8)=4, (8,7)=4, (8,8)=4. All yellow=4. Template? inner=2, outer=4\n        # Green pixel (3) at (8,1) - isolated\n        # In Train 1:\n        # Template 1: inner=3 at (2,2), outer=8 (pixels {(2,3), (2,4), (3,2)})\n        # Template 2: inner=2 at (7,7), outer=4 (pixels {(7,6), (7,8), (8,7), (8,8)})\n        # Triggers: Red at (1,10), Yellow at (7,6), Green at (8,1)\n        # Matching:\n        # Trigger Green(3) at (8,1) matches Template 1 (inner=3). Paste T1 anchored at (8,1).\n        # Trigger Red(2) at (1,10) matches Template 2 (inner=2). Paste T2 anchored at (1,10).\n        # This matches the output logic! So train_1 is not an anomaly.\n\n        pass # Continue with the main logic even if empty initially\n\n    # Iterate through triggers and apply matching templates\n    for trigger in triggers:\n        trigger_loc = trigger['loc']\n        trigger_color = trigger['color']\n\n        for template in templates:\n            if template['inner_color'] == trigger_color:\n                # Found a match, paste this template anchored at trigger_loc\n                inner_orig_loc = template['inner_loc']\n                inner_color = template['inner_color']\n                outer_color = template['outer_color']\n                outer_pixels = template['outer_pixels']\n\n                # Calculate offset\n                delta_r = trigger_loc[0] - inner_orig_loc[0]\n                delta_c = trigger_loc[1] - inner_orig_loc[1]\n\n                # Paste inner pixel\n                target_inner_r, target_inner_c = trigger_loc\n                if 0 <= target_inner_r < rows and 0 <= target_inner_c < cols:\n                    output_grid[target_inner_r, target_inner_c] = inner_color\n\n                # Paste outer pixels\n                for (r_orig, c_orig) in outer_pixels:\n                    target_outer_r = r_orig + delta_r\n                    target_outer_c = c_orig + delta_c\n\n                    if 0 <= target_outer_r < rows and 0 <= target_outer_c < cols:\n                        output_grid[target_outer_r, target_outer_c] = outer_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5631,
    "candidates_token_count": 2589,
    "total_token_count": 8220,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.729313,
  "retries": null
}