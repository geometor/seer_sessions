{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all pixels belonging to the source object (green, 3), the target object (red, 2), and obstacles (azure, 8) in the input grid.\nFind the shortest path(s) between any green pixel and any red pixel, moving only through white (0) pixels and avoiding azure (8) pixels (and other non-white pixels). Use 4-directional adjacency (up, down, left, right).\nIf a path exists, determine the minimum path length (number of white cells in the path + 1).\nIdentify all white (0) pixels that lie on any path of this minimum length between a green pixel and a red pixel.\nCreate the output grid by copying the input grid, then change the color of all identified shortest path white pixels to green (3).\nIf no path exists between green and red pixels, return the input grid unchanged.\n\"\"\"\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all pixels of a specific color.\"\"\"\n    rows, cols = grid.shape\n    pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                pixels.append((r, c))\n    return pixels\n\ndef bfs(grid, start_pixels, end_pixels_set, obstacle_color=8, traversable_color=0):\n    \"\"\"\n    Performs a Breadth-First Search to find shortest paths.\n\n    Args:\n        grid: The input numpy array.\n        start_pixels: A list of (row, col) tuples representing starting points.\n        end_pixels_set: A set of (row, col) tuples representing target points.\n        obstacle_color: The color code for obstacles.\n        traversable_color: The color code for traversable cells.\n\n    Returns:\n        A tuple: (min_distance, distances_grid)\n        min_distance: The shortest distance found to any end pixel, or -1 if unreachable.\n        distances_grid: A grid of the same shape as input, storing the shortest distance\n                         from any start_pixel to that cell, or -1 if unreachable.\n    \"\"\"\n    rows, cols = grid.shape\n    distances = np.full((rows, cols), -1, dtype=int)\n    queue = deque()\n    min_dist_to_target = -1\n\n    # Initialize queue and distances for all start pixels\n    for r, c in start_pixels:\n        if 0 <= r < rows and 0 <= c < cols:\n            # Starting pixels themselves are not part of the path length calculation if they are not traversable_color\n            # But BFS starts conceptually *at* them. Let's assume distance 0 for them.\n             distances[r, c] = 0\n             queue.append(((r, c), 0)) # ((row, col), distance)\n\n    # Initialize queue and distances for traversable cells adjacent to start pixels\n    processed_starts = set(start_pixels) # Keep track of starts already added\n    initial_queue_len = len(queue)\n    for _ in range(initial_queue_len):\n         (sr, sc), _ = queue.popleft() # Use the initial starts to find the first step\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n             nr, nc = sr + dr, sc + dc\n             if 0 <= nr < rows and 0 <= nc < cols:\n                cell_val = grid[nr, nc]\n                # Check if it's a traversable cell OR a target cell (targets can be occupied)\n                is_traversable = (cell_val == traversable_color)\n                is_target = (nr, nc) in end_pixels_set\n\n                if (is_traversable or is_target) and distances[nr, nc] == -1:\n                    distances[nr, nc] = 1 # First step onto a valid cell\n                    queue.append(((nr, nc), 1))\n                    processed_starts.add((nr, nc)) # Mark as visited to avoid re-adding\n\n    # Perform BFS\n    while queue:\n        (r, c), dist = queue.popleft()\n\n        # Check if this cell is a target\n        if (r, c) in end_pixels_set:\n            if min_dist_to_target == -1 or dist < min_dist_to_target:\n                 min_dist_to_target = dist\n            # Don't stop; continue BFS to find all cells reachable at potentially minimum distance\n\n        # If we already exceeded the minimum distance found to a target,\n        # we don't need to explore further from this path for finding *shortest* paths cells.\n        # However, we need the full distance map for the backward pass verification.\n        # Let's refine this later if needed for performance. Just continue BFS for now.\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and distances[nr, nc] == -1:\n                cell_val = grid[nr, nc]\n                is_traversable = (cell_val == traversable_color)\n                is_target = (nr, nc) in end_pixels_set # Allow moving onto target cells\n\n                if is_traversable or is_target:\n                     distances[nr, nc] = dist + 1\n                     queue.append(((nr, nc), dist + 1))\n\n    return min_dist_to_target, distances\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by finding the shortest path(s) between green (3)\n    and red (2) pixels through white (0) pixels, avoiding azure (8) pixels,\n    and coloring the white pixels on these paths green (3).\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Key Components\n    green_pixels = find_pixels(input_grid, 3)\n    red_pixels = find_pixels(input_grid, 2)\n    red_pixels_set = set(red_pixels)\n    # Obstacles are implicitly handled by BFS (only allows traversal on white=0 or targets=2)\n    # white_pixels = find_pixels(input_grid, 0) # Not explicitly needed upfront\n\n    if not green_pixels or not red_pixels:\n        return output_grid.tolist() # No start or end points, return original\n\n    # 2. Forward BFS: Find shortest path distance from Green to Red\n    # Start BFS from *adjacent* white/red cells to green cells, or directly from green cells if they are white/red?\n    # The description implies the path is made of *white* cells connecting green to red.\n    # Let's adjust BFS: start points are green, but the path cells counted are white.\n    # Rerun BFS logic: Start search *from* green cells. Distance to first adjacent white/red cell is 1.\n    # Let's stick to the standard BFS: starts are green pixels, targets are red pixels.\n    # Path cost is moves through white pixels.\n\n    min_dist_fwd, dist_from_green = bfs(input_grid, green_pixels, red_pixels_set, obstacle_color=8, traversable_color=0)\n\n    # If no path exists\n    if min_dist_fwd == -1:\n        return output_grid.tolist()\n\n    # 3. Backward BFS: Find shortest path distance from Red (reached at min_dist_fwd) to Green\n    # Identify the red pixels that were reached at the minimum distance\n    target_red_pixels_min_dist = [p for p in red_pixels if dist_from_green[p[0], p[1]] == min_dist_fwd]\n\n    # Perform BFS starting from these specific red pixels\n    # The target for this BFS is technically the green pixels, but we just need distances.\n    # We are looking for white cells reachable from these specific red pixels.\n    min_dist_bwd, dist_from_red = bfs(input_grid, target_red_pixels_min_dist, set(green_pixels), obstacle_color=8, traversable_color=0)\n\n\n    # 4. Identify All Shortest Path Pixels (White cells only)\n    # A white pixel (r, c) is on a shortest path if:\n    # - It's reachable from a green start (dist_from_green[r, c] != -1)\n    # - It's reachable from a red end (dist_from_red[r, c] != -1)\n    # - The sum of distances equals the minimum total distance found (dist_from_green[r, c] + dist_from_red[r, c] == min_dist_fwd)\n    # Note: The distances calculated by BFS count the number of steps/cells.\n    # Example: Green -> White -> Red. Dist Green to White = 1. Dist Red to White = 1. Min Dist = 2. 1+1=2. Correct.\n    # Example: Green -> White1 -> White2 -> Red. Dist G->W1=1, G->W2=2. Dist R->W1=2, R->W2=1. Min Dist = 3.\n    # White1: dist_g=1, dist_r=2. Sum=3. Path cell.\n    # White2: dist_g=2, dist_r=1. Sum=3. Path cell.\n\n    path_color = 3 # Green\n    for r in range(rows):\n        for c in range(cols):\n            # Check if it's a white pixel\n            if input_grid[r, c] == 0:\n                dist_g = dist_from_green[r, c]\n                dist_r = dist_from_red[r, c]\n\n                # Check if reachable from both ends and if the sum matches min_dist\n                if dist_g != -1 and dist_r != -1 and (dist_g + dist_r == min_dist_fwd):\n                    output_grid[r, c] = path_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5249,
    "candidates_token_count": 2406,
    "total_token_count": 7655,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 193.756761,
  "retries": null
}