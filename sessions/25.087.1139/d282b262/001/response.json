{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies connected components of non-background pixels in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of objects. Each object is represented as a dictionary\n              containing 'pixels' (a list of (r, c, color) tuples) and\n              bounding box information ('min_r', 'max_r', 'min_c', 'max_c').\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    color = grid[curr_r, curr_c]\n                    obj_pixels.append((curr_r, curr_c, color))\n\n                    # Update bounds\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Check neighbors (4-directional connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != background_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'pixels': obj_pixels,\n                    'min_r': min_r,\n                    'max_r': max_r,\n                    'min_c': min_c,\n                    'max_c': max_c\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Shifts non-background objects horizontally to the right until they hit\n    the grid boundary or another object. When objects moving rightward would\n    collide in the same row(s), the object that started further left stops\n    just before colliding with the final position of the object that started\n    further to the right.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    background_color = 0\n    output_grid = np.full((rows, cols), background_color, dtype=input_grid.dtype)\n\n    # 1. Identify all distinct objects and their properties\n    objects = find_objects(input_grid)\n    if not objects:\n        return output_grid # Return empty grid if no objects\n\n    # 2. Calculate initial potential shift for each object\n    for i, obj in enumerate(objects):\n        obj['id'] = i # Assign an ID for tracking\n        potential_shift = cols - 1 - obj['max_c']\n        obj['final_shift'] = potential_shift # Initialize final_shift\n\n    # 3. Iteratively resolve collisions until shifts stabilize\n    shifts_changed = True\n    while shifts_changed:\n        shifts_changed = False\n        # Sort objects primarily by initial min_c (left-to-right) to potentially\n        # speed up convergence, though the logic should handle any order.\n        # objects.sort(key=lambda o: o['min_c']) # Optional sort\n\n        for i in range(len(objects)):\n            obj_a = objects[i]\n            potential_a_min_c = obj_a['min_c'] + obj_a['final_shift']\n            potential_a_max_c = obj_a['max_c'] + obj_a['final_shift']\n\n            for j in range(len(objects)):\n                if i == j:\n                    continue\n                obj_b = objects[j]\n\n                # Check for row overlap\n                rows_overlap = max(obj_a['min_r'], obj_b['min_r']) <= min(obj_a['max_r'], obj_b['max_r'])\n                if not rows_overlap:\n                    continue\n\n                potential_b_min_c = obj_b['min_c'] + obj_b['final_shift']\n                potential_b_max_c = obj_b['max_c'] + obj_b['final_shift']\n\n                # Check for potential horizontal collision (only if A is to the left of B initially)\n                # A potential collision occurs if A's potential final position overlaps or is to the right of B's\n                if obj_a['min_c'] < obj_b['min_c']:\n                    # Check if A's potential end position would collide with B's potential end position\n                    # A collision happens if A's right edge would be >= B's left edge in their potential final positions\n                    if potential_a_max_c >= potential_b_min_c:\n                         # A is blocked by B. Calculate the maximum shift A can make.\n                         # A's rightmost column (max_c) must end up at B's leftmost column (min_c) - 1\n                         max_allowed_shift_for_a = potential_b_min_c - 1 - obj_a['max_c']\n\n                         # Ensure shift doesn't become negative if objects are already touching/overlapping somehow (shouldn't happen with rightward shift)\n                         max_allowed_shift_for_a = max(0, max_allowed_shift_for_a)\n\n                         # Update A's shift if the calculated limit is smaller than its current shift\n                         if max_allowed_shift_for_a < obj_a['final_shift']:\n                             obj_a['final_shift'] = max_allowed_shift_for_a\n                             shifts_changed = True # Mark that a shift was adjusted\n\n    # 4. Create the output grid by placing objects at their final positions\n    for obj in objects:\n        shift = obj['final_shift']\n        for r, c, color in obj['pixels']:\n            new_c = c + shift\n            # Ensure the new position is within bounds (should be guaranteed by logic, but good practice)\n            if 0 <= r < rows and 0 <= new_c < cols:\n                output_grid[r, new_c] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4968,
    "candidates_token_count": 1609,
    "total_token_count": 6577,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.175707,
  "retries": null
}