
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 6 0 0 0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 4 3 0 0 0 0 0 0 0 5 7 8 6
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 4 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 5 7 8 6 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 2 4 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 8 6 0 0 0 1 2 4 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 4 3 0 0 0 0 0 0 0 5 7 8 6
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 3 5 1 6 4 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 3 5 1 6 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 5 1 6 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 3 5 1 6 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 3 5 1 6 4 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 4 3 7 8
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0
0 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
1 6 2 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 4 3 7 8
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 6 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 3 7 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 1 6 2 0
0 4 3 7 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
1 6 2 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

**Perception**

1.  **Grid Structure**: The input and output grids have the same dimensions in all examples. The background is consistently white (0).
2.  **Input Elements**: The input grids contain two types of elements:
    *   **Single Pixels**: Isolated non-white pixels scattered across the grid (e.g., the red '2' at (1,2) in `train_1`).
    *   **Horizontal Patterns**: Contiguous horizontal sequences of two or more non-white pixels (e.g., `1 2 4 3` and `5 7 8 6` in the last row of `train_1`). These patterns can appear anywhere, not just the edges.
3.  **Transformation Logic**: The core transformation involves using the single pixels ("markers") to determine where to copy the horizontal patterns.
    *   Each marker pixel's color dictates *which* pattern should be copied. The pattern chosen is one that contains the marker's color.
    *   The marker pixel's location dictates *where* the chosen pattern is copied. The pattern is placed on the same row as the marker, aligned such that the pixel in the copied pattern corresponding to the marker's color lands exactly where the original marker was.
4.  **Output Structure**:
    *   The output grid starts as a copy of the input.
    *   The identified patterns are copied to new locations based on the marker pixels.
    *   The original marker pixels are effectively replaced by the corresponding pixel within the copied pattern.
    *   The original horizontal patterns remain in their initial positions unless overwritten by a newly placed pattern triggered by a marker.
    *   If a copied pattern extends beyond the grid boundaries, it is clipped.

**Facts**


```yaml
elements:
  - type: grid
    background_color: 0 (white)
  - type: pattern
    description: Contiguous horizontal sequence of 2 or more non-white pixels.
    location: Found anywhere in the input grid.
    persistence: Patterns remain in their original location in the output unless overwritten.
  - type: marker
    description: Single non-white pixel not horizontally adjacent to another non-white pixel.
    location: Found anywhere in the input grid except as part of a pattern.
    role: Determines which pattern to copy and where to place it.

actions:
  - action: identify_patterns
    input: input_grid
    output: list of patterns (sequences of colors)
  - action: identify_markers
    input: input_grid
    output: list of markers (color, row, column)
  - action: copy_pattern_to_marker_location
    trigger: each marker (color C, position (r, c))
    steps:
      - Find a pattern P containing color C.
      - Find the index 'idx' of C within P.
      - Calculate the target start column: start_col = c - idx.
      - Place pattern P onto the output grid at row 'r', starting at 'start_col'.
      - Clip the pattern if it extends beyond grid boundaries.
    target: output_grid (initially a copy of input_grid)

relationships:
  - relationship: marker_color_determines_pattern
    source: marker color (C)
    target: pattern (P)
    condition: Pattern P contains color C.
  - relationship: marker_position_determines_placement
    source: marker position (r, c) and pattern P with index idx of marker color C
    target: placement location for P on output grid (row r, starting column c - idx)
```


**Natural Language Program**

1.  Initialize the output grid as an identical copy of the input grid.
2.  Scan the input grid to identify all horizontal sequences of two or more adjacent non-white pixels. Store these sequences as "patterns".
3.  Scan the input grid again to identify all single non-white pixels that do *not* have any non-white horizontal neighbors. Store the color and (row, column) position of each of these "markers".
4.  For each identified marker with color `C` at position `(r, c)`:
    a.  Find a pattern `P` from the list of identified patterns (from step 2) that contains the color `C`. If multiple patterns contain `C`, the first one found is sufficient.
    b.  Find the horizontal index `idx` (0-based) of the first occurrence of color `C` within the pattern `P`.
    c.  Calculate the target starting column for copying the pattern: `target_start_col = c - idx`.
    d.  Iterate through the colors `P[j]` in pattern `P` (where `j` is the index within the pattern, from 0 to length-1):
        i.  Calculate the target column in the output grid: `current_col = target_start_col + j`.
        ii. Check if `current_col` is within the valid column range of the grid (0 <= `current_col` < grid_width).
        iii. If it is within bounds, update the output grid at position `(r, current_col)` with the color `P[j]`.
5.  After processing all markers, return the final output grid.
