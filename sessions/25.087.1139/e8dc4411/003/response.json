{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule identifies a unique 'source' pixel in the input grid, distinguished by its color being neither the predominant background color nor white (0). Based on the color of this source pixel, a specific predefined pattern of relative coordinates is selected. This pattern is then applied relative to the source pixel's location, changing the pixels in the output grid at the calculated target coordinates to the source pixel's color. The background and other elements like white pixels remain unchanged unless overwritten by the pattern application.\n\"\"\"\n\ndef find_most_frequent_color(grid):\n    \"\"\"Finds the most frequent color in the grid, ignoring white (0).\"\"\"\n    # Flatten the grid to easily count colors\n    colors = grid.flatten()\n    # Count occurrences of each color, excluding white (0)\n    color_counts = Counter(c for c in colors if c != 0)\n    # Handle cases where no non-white colors exist (e.g., all white grid)\n    if not color_counts:\n        # If the grid might be entirely white or empty, return 0 as default background\n        # In ARC, typically a dominant background exists.\n        # If only white, returning 0 seems reasonable.\n        all_counts = Counter(colors)\n        if all_counts:\n            return all_counts.most_common(1)[0][0] # Return most frequent overall (likely 0)\n        else:\n            return 0 # Default for empty grid\n    # Return the most frequent non-white color\n    return color_counts.most_common(1)[0][0]\n\ndef find_source_pixel(grid, background_color):\n    \"\"\"Finds the unique pixel that is not the background color and not white (0).\"\"\"\n    source_pixel_info = None\n    found_count = 0\n    # Iterate through each pixel in the grid\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            # Check if the pixel color is neither background nor white\n            if color != background_color and color != 0:\n                # Store the found pixel's info\n                source_pixel_info = {'row': r, 'col': c, 'color': color}\n                found_count += 1\n    # Validate that exactly one source pixel was found\n    if found_count == 1:\n         return source_pixel_info\n    else:\n        # Log a warning or raise an error if 0 or >1 source pixels are found\n        # This indicates the assumption of a unique source pixel is violated.\n        print(f\"Warning/Error: Found {found_count} source pixels. Expected exactly 1.\")\n        return None # Indicate failure to find a unique source\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a color-specific pattern anchored at a unique source pixel.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # 1. Initialize: Create a copy of the input grid for the output\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 2. Identify Background: Find the most common color, ignoring white\n    background_color = find_most_frequent_color(grid)\n\n    # 3. Find Source Pixel: Locate the unique pixel that's not background and not white\n    source_pixel = find_source_pixel(grid, background_color)\n\n    # Proceed only if a unique source pixel was successfully found\n    if source_pixel is None:\n        print(\"Error: Could not find a unique source pixel. Returning original grid.\")\n        # If no unique source, return the unchanged copy\n        return output_grid.tolist()\n\n    source_row = source_pixel['row']\n    source_col = source_pixel['col']\n    source_color = source_pixel['color']\n\n    # 4. Define Color Patterns: Map source colors to sets of relative (dr, dc) coordinates\n    # Corrected pattern for green (3) based on Example 1 analysis\n    patterns = {\n        3: {(0, 0), (1, -1), (1, 0), (1, 1), (2, -2), (2, 0), (3, -3), (3, -2), (3, -1), (4, -4), (4, -2), (5, -4), (5, -3)}, # Green (Corrected)\n        2: {(0, 0), (1, -1), (1, 1), (2, 0), (2, 2), (3, 1), (3, 3), (4, 2), (4, 4), (5, 3), (5, 5), (6, 4), (6, 6)}, # Red\n        8: {(-4, 0), (-4, 1), (-4, 3), (-4, 4), (-3, 0), (-3, 1), (-3, 3), (-3, 4), (-2, 2), (-1, 0), (-1, 1), (-1, 3), (-1, 4), (0, 0), (0, 1), (0, 3), (0, 4)}  # Azure\n    }\n\n    # 5. Select Pattern: Get the pattern corresponding to the source pixel's color\n    selected_pattern = patterns.get(source_color)\n\n    # Proceed only if a pattern is defined for the source color\n    if selected_pattern is None:\n        print(f\"Warning: No pattern defined for source color {source_color}. Returning original grid.\")\n        # If no pattern exists for this color, return the unchanged copy\n        return output_grid.tolist()\n\n    # 6. Apply Pattern: Iterate through each offset in the selected pattern\n    for dr, dc in selected_pattern:\n        # 7. Calculate Target Coordinates: Add offset to source location\n        target_row = source_row + dr\n        target_col = source_col + dc\n\n        # 8. Update Output Grid: Check bounds and apply the source color\n        # Check if the calculated target coordinates are within the grid boundaries\n        if 0 <= target_row < rows and 0 <= target_col < cols:\n            # Change the color of the pixel at the target location in the output grid\n            output_grid[target_row, target_col] = source_color\n\n    # 9. Finalize: Convert the NumPy array back to a list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8122,
    "candidates_token_count": 1550,
    "total_token_count": 9672,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.637291,
  "retries": null
}