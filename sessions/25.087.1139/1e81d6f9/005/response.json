{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the counts and locations of single green and single yellow pixels.\n\n1. Find all single green (3) pixels (pixels with no green neighbors, 8-way adjacency) and their count (N_green).\n2. Find all single yellow (4) pixels (pixels with no yellow neighbors, 8-way adjacency) and their count (N_yellow).\n3. Conditional Transformation:\n   - IF N_green == 2 AND N_yellow == 6:\n     - Identify the top-leftmost single yellow pixel (minimum row, then minimum column).\n     - Change all *other* single yellow pixels to white (0).\n   - ELSE IF N_green == 6 AND N_yellow == 7:\n     - Sort the locations of all single green pixels (by row, then column).\n     - Identify the *second* pixel in the sorted list.\n     - Change all *other* single green pixels to white (0).\n   - ELSE:\n     - Return the input grid unchanged.\n\"\"\"\n\ndef find_single_pixels(grid, target_color):\n    \"\"\"\n    Finds all pixels of a target_color that have no neighbors of the same color (8-way adjacency).\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to search for.\n\n    Returns:\n        list: A list of (row, col) tuples representing the locations of single pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    single_pixel_locations = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == target_color:\n                is_single = True\n                # Check 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue # Skip self\n                        nr, nc = r + dr, c + dc\n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # If a neighbor has the same color, it's not single\n                            if grid[nr, nc] == target_color:\n                                is_single = False\n                                break\n                    if not is_single:\n                        break # Stop checking neighbors for this pixel\n                \n                # If after checking all neighbors, it's still considered single\n                if is_single:\n                    single_pixel_locations.append((r, c))\n                    \n    return single_pixel_locations\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on counts of single green and yellow pixels.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    # Define target colors and replacement color\n    green_color = 3\n    yellow_color = 4\n    replacement_color = 0 # White\n\n    # 1. Find single green pixels and count them\n    single_green_locations = find_single_pixels(input_grid_np, green_color)\n    n_green = len(single_green_locations)\n\n    # 2. Find single yellow pixels and count them\n    single_yellow_locations = find_single_pixels(input_grid_np, yellow_color)\n    n_yellow = len(single_yellow_locations)\n\n    # 3. Apply Conditional Logic\n    \n    # Rule 1: N_green == 2 AND N_yellow == 6\n    if n_green == 2 and n_yellow == 6:\n        # Create the output grid as a copy\n        output_grid_np = np.copy(input_grid_np)\n        \n        # Sort yellow locations to find the top-leftmost\n        single_yellow_locations.sort(key=lambda x: (x[0], x[1]))\n        pixel_to_preserve = single_yellow_locations[0] # Top-leftmost is the first element\n\n        # Change all *other* single yellow pixels to white\n        for r, c in single_yellow_locations:\n            if (r, c) != pixel_to_preserve:\n                output_grid_np[r, c] = replacement_color\n                \n        # Convert the result back to a list of lists and return\n        return output_grid_np.tolist()\n\n    # Rule 2: N_green == 6 AND N_yellow == 7\n    elif n_green == 6 and n_yellow == 7:\n         # Create the output grid as a copy\n        output_grid_np = np.copy(input_grid_np)\n        \n        # Sort green locations to find the second top-leftmost\n        single_green_locations.sort(key=lambda x: (x[0], x[1]))\n        # Check if there are at least two elements before accessing index 1\n        if len(single_green_locations) > 1:\n             pixel_to_preserve = single_green_locations[1] # Second element in sorted list\n        else:\n            # This case shouldn't happen if n_green is 6, but handle defensively\n             return input_grid # Return unchanged if something is wrong\n\n        # Change all *other* single green pixels to white\n        for r, c in single_green_locations:\n            if (r, c) != pixel_to_preserve:\n                output_grid_np[r, c] = replacement_color\n                \n        # Convert the result back to a list of lists and return\n        return output_grid_np.tolist()\n\n    # Default Rule: Otherwise\n    else:\n        # Return the input grid unchanged (as list of lists)\n        return input_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12753,
    "candidates_token_count": 1374,
    "total_token_count": 14127,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.113539,
  "retries": null
}