{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nTransforms the input grid based on the counts and locations of single green and single yellow pixels, with an additional rule for specific counts involving single red and adjacent orange pixels.\n\n1. Find all single green (3) pixels (pixels with no green neighbors, 8-way adjacency) and their count (N_green).\n2. Find all single yellow (4) pixels (pixels with no yellow neighbors, 8-way adjacency) and their count (N_yellow).\n3. Conditional Transformation:\n   - IF N_green == 2 AND N_yellow == 6:\n     - Identify the top-leftmost single yellow pixel (minimum row, then minimum column).\n     - Change all *other* single yellow pixels to white (0).\n   - ELSE IF N_green == 6 AND N_yellow == 7:\n     - Sort the locations of all single green pixels (by row, then column).\n     - Identify the *second* pixel in the sorted list.\n     - Change all *other* single green pixels to white (0).\n   - ELSE IF N_green == 1 AND N_yellow == 2:\n     - Find all single red (2) pixels (using the same \"single\" definition).\n     - Find all orange (7) pixels that are adjacent (8-way) to at least one other orange pixel.\n     - Change all identified single red pixels and all identified adjacent orange pixels to white (0).\n   - ELSE:\n     - Return the input grid unchanged.\n\"\"\"\n\ndef find_single_pixels(grid_np: np.ndarray, target_color: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all pixels of a target_color that have no neighbors of the same color (8-way adjacency).\n\n    Args:\n        grid_np (np.ndarray): The input grid as a numpy array.\n        target_color (int): The color to search for.\n\n    Returns:\n        List[Tuple[int, int]]: A list of (row, col) tuples representing the locations of single pixels.\n    \"\"\"\n    rows, cols = grid_np.shape\n    single_pixel_locations = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid_np[r, c] == target_color:\n                is_single = True\n                # Check 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue # Skip self\n                        nr, nc = r + dr, c + dc\n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # If a neighbor has the same color, it's not single\n                            if grid_np[nr, nc] == target_color:\n                                is_single = False\n                                break\n                    if not is_single:\n                        break # Stop checking neighbors for this pixel\n                \n                # If after checking all neighbors, it's still considered single\n                if is_single:\n                    single_pixel_locations.append((r, c))\n                    \n    return single_pixel_locations\n\ndef find_adjacent_pixels(grid_np: np.ndarray, target_color: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all pixels of a target_color that have at least one neighbor of the same color (8-way adjacency).\n\n    Args:\n        grid_np (np.ndarray): The input grid as a numpy array.\n        target_color (int): The color to search for.\n\n    Returns:\n        List[Tuple[int, int]]: A list of (row, col) tuples representing the locations of pixels \n                                that are part of an adjacent group of the target color.\n    \"\"\"\n    rows, cols = grid_np.shape\n    adjacent_pixel_locations = set() # Use set to store unique locations\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid_np[r, c] == target_color:\n                has_same_color_neighbor = False\n                # Check 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue # Skip self\n                        nr, nc = r + dr, c + dc\n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # If a neighbor has the same color, mark it\n                            if grid_np[nr, nc] == target_color:\n                                has_same_color_neighbor = True\n                                break # Found one neighbor, no need to check others for this pixel\n                    if has_same_color_neighbor:\n                        adjacent_pixel_locations.add((r, c)) # Add this pixel if it has a neighbor\n                        \n    return list(adjacent_pixel_locations)\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rules based on counts of single green/yellow pixels,\n    or single red/adjacent orange pixels for a specific count case.\n\n    Args:\n        input_grid (List[List[int]]): The input grid.\n\n    Returns:\n        List[List[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Create the output grid as a copy initially\n    output_grid_np = np.copy(input_grid_np)\n    \n    # Define target colors and replacement color\n    green_color = 3\n    yellow_color = 4\n    red_color = 2\n    orange_color = 7\n    replacement_color = 0 # White\n\n    # 1. Find single green pixels and count them\n    single_green_locations = find_single_pixels(input_grid_np, green_color)\n    n_green = len(single_green_locations)\n\n    # 2. Find single yellow pixels and count them\n    single_yellow_locations = find_single_pixels(input_grid_np, yellow_color)\n    n_yellow = len(single_yellow_locations)\n\n    # 3. Apply Conditional Logic based on counts\n    \n    # Rule A: N_green == 2 AND N_yellow == 6\n    if n_green == 2 and n_yellow == 6:\n        # Sort yellow locations to find the top-leftmost\n        single_yellow_locations.sort(key=lambda x: (x[0], x[1]))\n        if single_yellow_locations: # Ensure list is not empty\n            pixel_to_preserve = single_yellow_locations[0] # Top-leftmost is the first element\n\n            # Change all *other* single yellow pixels to white\n            for r, c in single_yellow_locations:\n                if (r, c) != pixel_to_preserve:\n                    output_grid_np[r, c] = replacement_color\n        # If list is empty (shouldn't happen if n_yellow==6), grid remains unchanged (copy of input)\n\n    # Rule B: N_green == 6 AND N_yellow == 7\n    elif n_green == 6 and n_yellow == 7:\n        # Sort green locations to find the second top-leftmost\n        single_green_locations.sort(key=lambda x: (x[0], x[1]))\n        # Check if there are at least two elements before accessing index 1\n        if len(single_green_locations) > 1:\n             pixel_to_preserve = single_green_locations[1] # Second element in sorted list\n\n             # Change all *other* single green pixels to white\n             for r, c in single_green_locations:\n                 if (r, c) != pixel_to_preserve:\n                     output_grid_np[r, c] = replacement_color\n        # If less than 2 elements (shouldn't happen if n_green==6), grid remains unchanged\n\n    # Rule C: N_green == 1 AND N_yellow == 2\n    elif n_green == 1 and n_yellow == 2:\n         # Find single red pixels\n         single_red_locations = find_single_pixels(input_grid_np, red_color)\n         # Find orange pixels that are adjacent to other orange pixels\n         adjacent_orange_locations = find_adjacent_pixels(input_grid_np, orange_color)\n\n         # Change all identified single red pixels to white\n         for r, c in single_red_locations:\n              output_grid_np[r, c] = replacement_color\n              \n         # Change all identified adjacent orange pixels to white\n         for r, c in adjacent_orange_locations:\n              output_grid_np[r, c] = replacement_color\n\n    # Default Rule: Otherwise (no counts match the specific rules)\n    # The output grid remains the initial copy of the input grid.\n    \n    # Convert the result back to a list of lists and return\n    return output_grid_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11984,
    "candidates_token_count": 2115,
    "total_token_count": 14099,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.317843,
  "retries": null
}