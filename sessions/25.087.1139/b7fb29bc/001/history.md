
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 3 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 2 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 4 4 4 4 2 4 3 0 0 0
0 0 0 3 2 2 2 2 4 2 4 3 0 0 0
0 0 0 3 4 4 4 2 4 2 4 3 0 0 0
0 0 0 3 4 3 4 2 4 2 4 3 0 0 0
0 0 0 3 4 4 4 2 4 2 4 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 2 4 4 4 2 4 3 0 0 0
0 0 0 3 4 2 4 3 4 2 4 3 0 0 0
0 0 0 3 4 2 4 4 4 2 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 3 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 2 4 2 4 3 4 3 0 0 0
0 0 0 3 4 2 4 2 4 4 4 3 0 0 0
0 0 0 3 4 2 4 2 2 2 2 3 0 0 0
0 0 0 3 4 2 4 4 4 4 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 2 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 2 2 2 2 2 2 2 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

**Perception:**

1.  **Input Grid:** Each input grid consists of a white background (0) with a hollow green rectangle (3) frame. Inside this frame, there are one or more isolated green pixels (3).
2.  **Output Grid:** The output grid retains the green frame exactly as it was in the input. The background outside the frame also remains white. The key change occurs *inside* the frame.
3.  **Transformation:** The area enclosed by the green frame, which was initially white (0) except for the isolated green 'seed' pixels, is filled with a pattern of yellow (4) and red (2) pixels in the output. The original internal green pixels remain green.
4.  **Filling Pattern:** The filling seems to originate from the internal green 'seed' pixels. The color assigned to a filled pixel depends on its distance from the nearest seed pixel.
    *   Pixels directly adjacent (sharing an edge, not just a corner) to a seed pixel become yellow (4).
    *   Pixels directly adjacent to those yellow pixels (and not seeds or already yellow) become red (2).
    *   Pixels directly adjacent to those red pixels become yellow (4) again.
    *   This pattern continues, alternating between yellow (4) and red (2), based on the shortest Manhattan distance to any internal seed pixel. Odd distances result in yellow, and even distances result in red. The filling stops at the green frame boundary.

**YAML Facts:**


```yaml
task_description: Fill the area inside a green frame based on the distance from internal green seed pixels.
elements:
  - object: background
    color: white (0)
  - object: frame
    shape: hollow rectangle
    color: green (3)
    properties:
      - encloses an area
      - remains unchanged in the output
  - object: seed_pixels
    color: green (3)
    location: inside the frame
    properties:
      - isolated pixels in the input
      - act as starting points for filling
      - remain green in the output
  - object: filled_area
    location: inside the frame (originally white pixels)
    properties:
      - filled with alternating colors in the output
      - colors are yellow (4) and red (2)
relationships:
  - type: enclosure
    parent: frame
    child: seed_pixels
  - type: enclosure
    parent: frame
    child: filled_area
  - type: distance_coloring
    source: seed_pixels
    target: filled_area
    details: >
      The color of a pixel in the filled_area is determined by its minimum
      Manhattan distance (d) to any seed_pixel.
      If d=0 (it's a seed pixel), color remains green (3).
      If d > 0 and d is odd, color is yellow (4).
      If d > 0 and d is even, color is red (2).
actions:
  - action: identify
    target: frame
  - action: identify
    target: seed_pixels (green pixels inside the frame)
  - action: calculate_distance
    from: each white pixel inside the frame
    to: all seed_pixels
    metric: Manhattan distance
    result: minimum distance (d) for each white pixel
  - action: color_fill
    target: white pixels inside the frame
    rule: >
      Based on minimum distance (d):
      If d is odd, set color to yellow (4).
      If d is even, set color to red (2).
  - action: preserve
    target: frame pixels
  - action: preserve
    target: seed_pixels
  - action: preserve
    target: background pixels outside the frame
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the coordinates of all green pixels (3) that are *inside* the main green rectangular frame. These are the "seed" pixels. If there are no seed pixels, return the copied input grid.
3.  Identify the coordinates of all white pixels (0) that are *inside* the main green rectangular frame. These are the "target" pixels.
4.  For each target pixel:
    a.  Calculate the Manhattan distance from this target pixel to every seed pixel identified in step 2.
    b.  Find the minimum of these calculated distances. Let this minimum distance be `d`.
    c.  If `d` is odd, change the color of the target pixel in the output grid to yellow (4).
    d.  If `d` is even and greater than 0, change the color of the target pixel in the output grid to red (2).
5.  Return the modified output grid.
