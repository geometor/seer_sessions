{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nFill the area inside a green rectangular frame based on the Manhattan distance \nfrom internal green 'seed' pixels. The frame itself and the seed pixels remain \nunchanged. White pixels inside the frame are colored based on their minimum \nManhattan distance (d) to any seed pixel: yellow (4) if d is odd, red (2) if d \nis even and positive. Pixels outside the frame remain white.\n\"\"\"\n\ndef find_frame_and_seeds(grid):\n    \"\"\"\n    Identifies the frame boundaries and the locations of seed pixels (green pixels inside the frame).\n    Assumes a single rectangular frame made of green pixels (3).\n    \"\"\"\n    green_pixels = np.argwhere(grid == 3)\n    if green_pixels.size == 0:\n        return None, None, [] # No frame found\n\n    min_r, min_c = green_pixels.min(axis=0)\n    max_r, max_c = green_pixels.max(axis=0)\n\n    # Frame boundaries (inclusive)\n    frame_bounds = (min_r, min_c, max_r, max_c)\n    # Inner area boundaries (exclusive of frame)\n    inner_bounds = (min_r + 1, min_c + 1, max_r - 1, max_c - 1)\n\n    seeds = []\n    for r, c in green_pixels:\n        # Check if the green pixel is strictly inside the outer frame boundaries\n        if min_r < r < max_r and min_c < c < max_c:\n            # Ensure it's not part of the frame itself (check if neighbors are also green)\n            # A simpler check for these examples: is it surrounded by non-green inside the frame area?\n            # Or, even simpler: assume any green pixel strictly inside the min/max bounds is a seed.\n            # Let's refine this: identify frame pixels first.\n            is_frame_pixel = (r == min_r or r == max_r or c == min_c or c == max_c)\n            if not is_frame_pixel:\n                 seeds.append((r, c))\n\n    # Re-check frame pixels, they can't be seeds\n    # This simple identification might mistake internal structures for seeds\n    # Let's redefine seeds as *isolated* green pixels within the inner bounds.\n    potential_seeds = []\n    for r in range(inner_bounds[0], inner_bounds[2] + 1):\n         for c in range(inner_bounds[1], inner_bounds[3] + 1):\n             if grid[r, c] == 3:\n                 potential_seeds.append((r,c))\n\n    # If a green pixel inside has green neighbors (part of frame line), it's not a seed\n    seeds = []\n    for r, c in potential_seeds:\n        is_isolated = True\n        # Check 4 neighbors (not diagonal)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds just in case, though they should be within frame\n            if min_r <= nr <= max_r and min_c <= nc <= max_c:\n                 # If a neighbor is green AND is on the frame boundary, this pixel might still be a seed.\n                 # If a neighbor is green AND is *not* on the frame boundary, this pixel is not isolated.\n                 is_neighbor_on_frame = (nr == min_r or nr == max_r or nc == min_c or nc == max_c)\n                 if grid[nr, nc] == 3 and not is_neighbor_on_frame:\n                     is_isolated = False\n                     break\n        if is_isolated:\n            seeds.append((r,c))\n\n\n    return frame_bounds, inner_bounds, seeds\n\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling the area inside a green frame\n    based on the distance to internal green seed pixels.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Find the green frame boundaries and the seed pixels inside it\n    frame_bounds, inner_bounds, seeds = find_frame_and_seeds(input_grid)\n\n    # If no frame or no seeds are found, return the original grid\n    if frame_bounds is None or not seeds:\n        return output_grid\n\n    min_r_inner, min_c_inner, max_r_inner, max_c_inner = inner_bounds\n\n    # Iterate through the pixels *inside* the frame\n    for r in range(min_r_inner, max_r_inner + 1):\n        for c in range(min_c_inner, max_c_inner + 1):\n            # Only process pixels that are currently white (0)\n            if output_grid[r, c] == 0:\n                min_dist = float('inf')\n                current_pos = (r, c)\n\n                # Calculate distance to all seed pixels\n                for seed_pos in seeds:\n                    dist = manhattan_distance(current_pos, seed_pos)\n                    min_dist = min(min_dist, dist)\n\n                # Color the pixel based on the minimum distance\n                if min_dist != float('inf'): # Check if a distance was actually found\n                    if min_dist > 0: # Don't change seeds themselves (though we only target white pixels)\n                        if min_dist % 2 != 0: # Odd distance\n                            output_grid[r, c] = 4 # Yellow\n                        else: # Even distance\n                            output_grid[r, c] = 2 # Red\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4871,
    "candidates_token_count": 1423,
    "total_token_count": 6294,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.02527,
  "retries": null
}