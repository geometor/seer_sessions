
## train_1

**input:**
```
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 2 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
```


**output:**
```
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 8 8 8 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 8 2 8 2 2 2 2 2 2 2 2 8 2 8 0 0
0 0 8 8 8 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
0 0 0 8 0 0 0 0 0 0 0 0 0 0 8 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0
0 8 8 8 0 0 0 8 8 8 0 0 0
8 8 2 8 8 8 8 8 2 8 8 8 8
0 8 8 8 0 0 0 8 8 8 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 8 8 8 0 8 8 8 0 0
8 8 8 8 2 8 8 8 2 8 8 8
0 0 0 8 8 8 0 8 8 8 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0 0 0
8 8 8 8 2 8 8 8 8 8 8 8
0 0 0 8 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples for task `c8cbb738`.

**Perception of Task Elements:**

1.  **Input Grid:** The input grid typically contains a background of white (0), one or more isolated red (2) pixels, and one or more structures (lines in the examples) made of azure (8) pixels.
2.  **Output Grid:** The output grid retains the original azure structures but modifies them. It also adds new red pixels. Specifically, red lines are drawn, and 3x3 square patterns appear.
3.  **Key Colors:** The significant colors are white (0 - background), red (2 - source points), and azure (8 - target structures/lines).
4.  **Transformation Pattern:**
    *   Each isolated red (2) pixel in the input acts as a starting point.
    *   For each red pixel, the transformation identifies the nearest azure (8) pixel in one of the four cardinal directions (up, down, left, right).
    *   A line of red (2) pixels is drawn from the original red pixel's location towards the identified nearest azure pixel. This line stops *just before* reaching the azure pixel's location.
    *   At the location of the target azure (8) pixel, a 3x3 square pattern is drawn, centered on this target location.
    *   This 3x3 square is filled with azure (8), except for its central pixel (the original target location), which is changed to red (2).
    *   This process is repeated for every isolated red (2) pixel found in the input grid. The drawing of lines and squares overwrites any existing pixels in those locations.

**Facts:**


```yaml
Color_Mapping:
  White: 0
  Red: 2
  Azure: 8

Input_Objects:
  - Type: Pixel
    Color: Red (2)
    Property: Isolated (surrounded by White)
    Role: Source_Point
  - Type: Structure (Line or potentially other shapes)
    Color: Azure (8)
    Role: Target_Structure

Output_Changes:
  - Type: Line
    Color: Red (2)
    Origin: Original Red (2) pixel location
    Destination: Location adjacent to the nearest Azure (8) pixel in a cardinal direction
    Action: Drawn between origin and destination
  - Type: Square_Pattern
    Size: 3x3
    Center_Location: Nearest Azure (8) pixel location (target)
    Center_Color: Red (2)
    Border_Color: Azure (8)
    Action: Overwrites the grid area centered on the target location

Relationships:
  - Proximity: Each Red (2) pixel is associated with the single Azure (8) pixel closest to it along a straight horizontal or vertical line.
  - Transformation_Trigger: The presence of isolated Red (2) pixels triggers the line drawing and square pattern creation.

General_Observation:
  - The transformation connects each source Red pixel to the nearest Azure structure element via a Red line and marks the connection point on the Azure structure with a specific 3x3 pattern (Azure border, Red center).
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all locations `(r, c)` in the input grid containing a red (2) pixel. Store these as source points.
3.  Identify all locations `(tr, tc)` in the input grid containing an azure (8) pixel. Store these as potential target points.
4.  For each source point `(r, c)`:
    a.  Find the potential target point `(tr, tc)` that has the minimum Manhattan distance `abs(r - tr) + abs(c - tc)` *only considering paths that are purely horizontal or purely vertical*. This means either `r == tr` (horizontal path) or `c == tc` (vertical path).
    b.  If multiple azure (8) pixels are equidistant along cardinal directions, the examples do not specify a tie-breaking rule, but they consistently show only one clear nearest target. Assume a unique nearest target exists for each source in the cardinal directions. Let the determined nearest target be `(target_r, target_c)`.
    c.  Determine the direction from `(r, c)` to `(target_r, target_c)` (up, down, left, or right).
    d.  Draw a line of red (2) pixels in the output grid starting from `(r, c)` and moving one step at a time in the determined direction, stopping *one step before* reaching `(target_r, target_c)`. Overwrite any existing pixels along this path.
    e.  Define a 3x3 area centered at the target location `(target_r, target_c)`.
    f.  For each pixel within this 3x3 area that falls within the grid boundaries:
        i.  If the pixel is the center `(target_r, target_c)`, set its color to red (2) in the output grid.
        ii. If the pixel is not the center, set its color to azure (8) in the output grid.
5.  Return the modified output grid.
