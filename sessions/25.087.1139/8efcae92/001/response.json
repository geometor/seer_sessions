{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy import ndimage\n\n\"\"\"\nIdentify all distinct contiguous regions (objects) of non-white (0) pixels in the input grid. \nFor each object, count the number of red (2) pixels within its bounding box. \nSelect the object (the rectangular subgrid defined by its bounding box) that has the maximum count of red pixels. \nReturn this selected subgrid as the output.\n\"\"\"\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds connected components (objects) of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color value to treat as background.\n\n    Returns:\n        list: A list where each element represents an object. Each object is a \n              list of (row, col) coordinates belonging to that object. Returns\n              an empty list if no objects are found.\n    \"\"\"\n    # Create a binary mask where non-background cells are True\n    mask = grid != background_color\n    \n    # Label connected components in the mask\n    # structure=np.ones((3,3)) ensures diagonal connectivity is considered\n    labeled_array, num_features = ndimage.label(mask, structure=np.ones((3,3), dtype=bool))\n    \n    if num_features == 0:\n        return []\n\n    # Find the coordinates for each labeled component (object)\n    objects = ndimage.find_objects(labeled_array)\n    \n    # Store objects as lists of coordinates, adjusting slices to coordinates\n    object_coords_list = []\n    for i in range(num_features):\n        label = i + 1 # Labels start from 1\n        coords = np.argwhere(labeled_array == label)\n        object_coords_list.append(coords)\n        \n    return object_coords_list, labeled_array, objects # Return coords, labeled array, and slices\n\ndef get_bounding_box(obj_slice):\n    \"\"\"\n    Gets the bounding box from the slice object returned by ndimage.find_objects.\n    \n    Args:\n        obj_slice (tuple): A tuple of slice objects (one per dimension).\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    min_row = obj_slice[0].start\n    max_row = obj_slice[0].stop # Slice stop is exclusive, so it's max_row index + 1\n    min_col = obj_slice[1].start\n    max_col = obj_slice[1].stop # Slice stop is exclusive, so it's max_col index + 1\n    return min_row, min_col, max_row, max_col\n    \ndef extract_subgrid(grid, bbox):\n    \"\"\"\n    Extracts a subgrid based on the bounding box.\n\n    Args:\n        grid (np.array): The main grid.\n        bbox (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        np.array: The extracted subgrid.\n    \"\"\"\n    min_row, min_col, max_row, max_col = bbox\n    return grid[min_row:max_row, min_col:max_col]\n\ndef count_color(subgrid, color):\n    \"\"\"\n    Counts the occurrences of a specific color in a subgrid.\n\n    Args:\n        subgrid (np.array): The grid or subgrid to count within.\n        color (int): The color value to count.\n\n    Returns:\n        int: The count of the specified color.\n    \"\"\"\n    return np.sum(subgrid == color)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the non-white object with the most \n    red (2) pixels and returning its bounding box content.\n    \n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The 2D output grid, corresponding to the selected object.\n    \"\"\"\n    \n    # Define background and target colors\n    background_color = 0\n    target_color = 2 # Red\n\n    # 1. Find all distinct non-background objects using connected components\n    # We get the list of coordinates for each object, the labeled array, and the slice objects\n    object_coords_list, labeled_array, object_slices = find_objects(input_grid, background_color)\n\n    if not object_coords_list: # Handle case with no objects\n        # Return an empty grid or handle as per specific requirements if needed.\n        # For now, let's assume valid inputs always have objects leading to an output.\n        # Returning the input might be a fallback, but the logic implies selection.\n        # Let's return a 1x1 white grid as a placeholder if no objects are found.\n         return np.array([[0]]) \n\n    max_red_count = -1\n    selected_subgrid = None\n\n    # 2. Iterate through each found object\n    # We use the slices directly provided by find_objects for efficiency\n    for obj_slice in object_slices:\n        \n        # 3. Determine the bounding box for the current object\n        bbox = get_bounding_box(obj_slice)\n        \n        # 4. Extract the subgrid corresponding to the bounding box\n        subgrid = extract_subgrid(input_grid, bbox)\n        \n        # 5. Count the number of red (2) pixels within this subgrid\n        red_count = count_color(subgrid, target_color)\n        \n        # 6. Check if this object has the highest red count found so far\n        if red_count > max_red_count:\n            max_red_count = red_count\n            selected_subgrid = subgrid\n            \n    # 7. Return the subgrid of the object with the maximum red count\n    # If multiple objects have the same max count, the first one encountered is selected.\n    if selected_subgrid is None:\n         # This case should ideally not happen if objects were found, \n         # unless all objects had 0 red pixels.\n         # If all objects have 0 red pixels, the first object's subgrid should be selected.\n         # Let's refine the logic slightly to handle the max_red_count == 0 case.\n         if max_red_count == -1 and object_slices: # No objects triggered the > check, but objects exist\n             first_bbox = get_bounding_box(object_slices[0])\n             selected_subgrid = extract_subgrid(input_grid, first_bbox)\n         elif selected_subgrid is None: # Truly no objects or some error\n             return np.array([[0]]) # Fallback\n             \n    return selected_subgrid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4505,
    "candidates_token_count": 1573,
    "total_token_count": 6078,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.565307,
  "retries": null
}