
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0
0 0 3 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 3 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 4 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 5 0 0
0 0 5 5 5 5 5 5 5 5 5 5 4 0 0
0 0 0 0 0 0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 5 5 5 5 0 0
0 0 3 3 3 3 3 3 3 5 5 5 5 0 0
0 0 3 3 3 3 3 3 3 5 5 5 5 0 0
0 0 3 3 3 3 3 3 3 5 5 5 5 0 0
0 0 3 3 3 3 3 3 3 5 5 5 5 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 5 5 5 5 5 5 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 2 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 2 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 2 2 2 2 2 2 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 5 5 5 5 5 5 5 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 1 0 0 0 4 0 0 0 0
0 0 1 5 5 5 5 5 5 5 5 5 5 4 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 1 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 4
0 6 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 5 5 5 5 5 5 5 5 5 5 5 5 0
0 0 6 5 5 5 5 5 5 5 5 5 5 5 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 5 5 5 4 4 4 4 0
0 0 1 1 1 1 1 5 5 5 4 4 4 4 0
0 0 1 1 1 1 1 5 5 5 4 4 4 4 0
0 0 1 1 1 1 1 5 5 5 4 4 4 4 0
0 0 5 5 5 5 5 5 5 5 4 4 4 4 0
0 0 5 5 5 5 5 5 5 5 4 4 4 4 0
0 0 5 5 5 5 5 5 5 5 4 4 4 4 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 6 6 6 6 5 5 5 5 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## Perception of Task Elements

1.  **Input Grid Structure:** Each input grid consists primarily of a white background (color 0) and a large, contiguous block of gray pixels (color 5). Additionally, there are several isolated pixels of various other colors (non-white, non-gray) scattered outside the main gray block.
2.  **Output Grid Structure:** The output grid retains the overall dimensions and the white background. The main gray block from the input is modified: parts of it are recolored based on the locations of the isolated pixels in the input. The original isolated colored pixels are removed (turned white) in the output.
3.  **Core Object:** The large contiguous block of gray pixels (color 5) acts as the primary object or canvas for the transformation.
4.  **Control Elements:** The isolated colored pixels outside the gray block act as control elements or "markers". Their color and positions determine how the gray block is modified.
5.  **Transformation Logic:**
    *   The markers seem to define rectangular regions. For each distinct color present among the markers, a bounding box is implicitly defined by the minimum and maximum row/column coordinates of all markers of that color.
    *   These bounding boxes are projected onto the main gray block.
    *   A gray pixel within the main block changes its color *only if* it falls within the bounding box of exactly *one* marker color. If a gray pixel falls within the bounding boxes of multiple marker colors (i.e., in an overlapping region), it remains gray. If it falls within no marker bounding boxes, it also remains gray.
    *   The new color assigned to a gray pixel is the color of the unique marker whose bounding box covers it.
    *   The original marker pixels are effectively erased (set to white) in the final output.

## YAML Fact Document


```yaml
Task: Recolor parts of a central gray object based on bounding boxes defined by external marker pixels.

Input_Features:
  - Grid: 2D array of integer colors (0-9).
  - Background: Primarily white pixels (color 0).
  - Target_Object:
      - Type: Single, large, contiguous block of pixels.
      - Color: Always gray (color 5).
      - Role: Canvas for color changes.
  - Marker_Pixels:
      - Type: Isolated pixels or small groups.
      - Color: Various non-white (non-0) and non-gray (non-5) colors.
      - Location: Located outside the boundary of the Target_Object.
      - Role: Define regions for recoloring the Target_Object.

Output_Features:
  - Grid: Same dimensions as input.
  - Background: Retained white pixels (color 0).
  - Modified_Object: The original Target_Object, potentially with sections recolored.
      - Unchanged_Pixels: Gray pixels from the input that were not targeted for recoloring or were in overlapping target regions.
      - Recolored_Pixels: Gray pixels from the input now matching the color of a specific set of markers.
  - Erased_Markers: The locations of the original Marker_Pixels are now white (color 0).

Transformation_Steps:
  1. Identify the main contiguous gray (5) object (Target_Object).
  2. Identify all non-white (0), non-gray (5) pixels outside the Target_Object (Marker_Pixels).
  3. Group Marker_Pixels by their color.
  4. For each unique marker color `C`:
     a. Calculate the minimum bounding box (min_row, max_row, min_col, max_col) enclosing all markers of color `C`. Let this be `BBox_C`.
  5. Determine the set of gray pixels from the Target_Object that fall within each `BBox_C`. Let this be `Target_Pixels_C`.
  6. Initialize the output grid as a copy of the input grid.
  7. For each pixel `(r, c)` that was originally gray in the Target_Object:
     a. Count how many sets `Target_Pixels_C` contain `(r, c)`.
     b. If the count is exactly 1, find the unique color `C_unique` associated with that set. Set `output_grid[r][c] = C_unique`.
     c. If the count is 0 or > 1, keep `output_grid[r][c]` as gray (5).
  8. For every original Marker_Pixel location `(r_marker, c_marker)`:
     a. Set `output_grid[r_marker][c_marker] = 0` (white).

Relationships:
  - Spatial: Marker pixels define rectangular regions via bounding boxes relative to the grid.
  - Influence: Each marker color potentially influences a rectangular subset of the gray Target_Object.
  - Conflict Resolution: Overlap between the influence regions of different marker colors results in no change (pixels remain gray).

Core_Knowledge_Mapping:
  - Objectness: Identifying the contiguous gray object and the distinct marker pixels.
  - Basic Geometry: Using bounding boxes (rectangles) defined by marker coordinates.
  - Topology: Intersection of bounding boxes with the gray object. Concept of overlap between regions.
  - Counting: Determining how many bounding boxes cover a specific gray pixel.

```


## Natural Language Program

1.  Find the largest connected component of gray (5) pixels in the input grid; this is the 'target object'.
2.  Find all pixels in the input grid that are neither white (0) nor gray (5) and are *not* part of the target object; these are the 'marker pixels'.
3.  Group the marker pixels based on their color.
4.  For each distinct color `C` found among the marker pixels:
    a.  Determine the minimum row, maximum row, minimum column, and maximum column coordinates among all marker pixels of color `C`. This defines the 'bounding box' `BBox_C` for color `C`.
5.  Create a new grid, initially identical to the input grid, which will become the output grid.
6.  Iterate through each pixel `(r, c)` that is part of the gray target object in the input grid.
7.  For the current gray pixel `(r, c)`, count how many different marker colors `C` have a bounding box `BBox_C` such that `r` is between `BBox_C`'s min/max rows (inclusive) and `c` is between `BBox_C`'s min/max columns (inclusive). Let this count be `N`.
8.  If `N` is exactly 1, find the unique marker color `C_unique` whose bounding box covers `(r, c)`, and change the color of the pixel `(r, c)` in the output grid to `C_unique`.
9.  If `N` is 0 or greater than 1, the pixel `(r, c)` in the output grid retains its original gray (5) color.
10. After checking all gray pixels, iterate through the locations `(r_m, c_m)` of all original marker pixels identified in step 2. Set the color of these locations `(r_m, c_m)` in the output grid to white (0).
11. The final state of the new grid is the result.
