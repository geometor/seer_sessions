{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by performing a \"gravity\" operation on colored pixels.\n\n1.  Identifies all unique non-background (non-white/0) colors in the input grid.\n2.  For each color, counts its pixels, determines the column they occupy, and finds the lowest row index (max_row) of any pixel of that color.\n3.  Sorts the colors based on their max_row in descending order (lowest in input goes to the bottom of the output).\n4.  Initializes an output grid of the same size as the input, filled with the background color (0).\n5.  Iterates through the sorted colors:\n    a.  Calculates the required layer widths for the pyramid structure using a greedy approach: starting with the largest possible odd width layer that fits the remaining pixel count, then the next largest odd width for the remainder, and so on. Layers are stacked widest at the bottom, narrowest at the top.\n    b.  Draws the layers for the current color onto the output grid, starting from the current available base row and moving upwards. The structure is centered horizontally based on the original column of the pixels.\n    c.  Updates the available base row for the next structure to be stacked on top.\n6.  Returns the final output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\n\ndef get_layer_widths(pixel_count):\n    \"\"\"\n    Determines the odd widths of layers required to form a pyramid\n    structure totaling pixel_count pixels. Uses a greedy approach,\n    starting with the largest possible odd width layer.\n\n    Args:\n        pixel_count: The total number of pixels for the structure.\n\n    Returns:\n        A list of integers representing the odd widths of the layers,\n        ordered from the top layer (narrowest) to the bottom layer (widest).\n        e.g., for pixel_count=9, returns [1, 3, 5].\n        e.g., for pixel_count=4, returns [1, 3].\n        e.g., for pixel_count=5, returns [5].\n    \"\"\"\n    layers_base_to_top = []\n    remaining_pixels = pixel_count\n    \n    # Find potential odd layer widths <= pixel_count\n    potential_widths = []\n    w = 1\n    while w <= pixel_count:\n        potential_widths.append(w)\n        w += 2\n\n    # Greedily select largest possible odd widths starting from the largest potential\n    for width in reversed(potential_widths):\n        if remaining_pixels >= width:\n            layers_base_to_top.append(width)\n            remaining_pixels -= width\n        if remaining_pixels == 0:\n            break\n            \n    # Return layers ordered top-to-bottom (narrowest to widest)\n    return list(reversed(layers_base_to_top))\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the gravity and pyramid formation transformation.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A numpy array representing the output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.zeros_like(input_np)\n\n    # --- Step 1 & 2: Find colors, count pixels, find column and max_row ---\n    color_data = defaultdict(lambda: {'coords': [], 'max_row': -1, 'col': -1})\n    unique_colors = []\n\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != 0:  # If not background\n                if color not in color_data:\n                    unique_colors.append(color)\n                color_data[color]['coords'].append((r, c))\n                color_data[color]['max_row'] = max(color_data[color]['max_row'], r)\n                # Assume all pixels of one color are in the same column\n                if color_data[color]['col'] == -1:\n                     color_data[color]['col'] = c\n                # Optional: Add check if column changes for a color (error?)\n                # elif color_data[color]['col'] != c:\n                #     print(f\"Warning: Color {color} found in multiple columns.\")\n\n\n    # Prepare data for sorting: list of (color, count, col, max_row)\n    processed_colors = []\n    for color in unique_colors:\n        data = color_data[color]\n        count = len(data['coords'])\n        col = data['col']\n        max_row = data['max_row']\n        processed_colors.append({'color': color, 'count': count, 'col': col, 'max_row': max_row})\n\n    # --- Step 3: Sort colors by max_row descending ---\n    sorted_colors = sorted(processed_colors, key=lambda x: x['max_row'], reverse=True)\n\n    # --- Step 4 & 5: Initialize output and draw structures ---\n    current_base_row = height - 1 # Start drawing from the bottom row\n\n    for item in sorted_colors:\n        color = item['color']\n        pixel_count = item['count']\n        center_col = item['col']\n\n        # --- Step 5a: Determine layer widths ---\n        layer_widths = get_layer_widths(pixel_count) # Gets widths [top, ..., bottom] e.g. [1, 3, 5]\n\n        # --- Step 5b & 5c: Draw layers onto output grid ---\n        # Iterate through layers from bottom to top (widest to narrowest)\n        # to place them correctly relative to current_base_row\n        row_to_draw = current_base_row\n        for layer_width in reversed(layer_widths): # Process [5, 3, 1] for example\n            if row_to_draw < 0:\n                 # Should not happen with valid inputs based on ARC constraints\n                 print(\"Warning: Attempting to draw above grid top.\")\n                 break\n\n            start_col = center_col - (layer_width // 2)\n            end_col = start_col + layer_width # Slicing goes up to, but not including, end_col\n\n            # Ensure drawing is within grid bounds horizontally\n            draw_start_col = max(0, start_col)\n            draw_end_col = min(width, end_col)\n            \n            # Check if the calculated slice is valid before applying\n            if draw_start_col < draw_end_col and draw_start_col >= 0 and draw_end_col <= width:\n                 output_grid[row_to_draw, draw_start_col:draw_end_col] = color\n            else:\n                 # This case might indicate an issue if shapes are expected to go off-grid\n                 # or if calculations are wrong. For now, just print a warning.\n                 print(f\"Warning: Layer slice ({draw_start_col}:{draw_end_col}) out of bounds or invalid for row {row_to_draw}.\")\n\n\n            row_to_draw -= 1 # Move up for the next layer (narrower one)\n\n        # Update the base row for the *next* structure to be stacked on top\n        # The next structure starts one row above the top-most row just drawn\n        current_base_row = row_to_draw\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4915,
    "candidates_token_count": 1721,
    "total_token_count": 6636,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 117.242065,
  "retries": null
}