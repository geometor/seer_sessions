{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by applying a gravity-like effect and reshaping pixel groups.\n\n1.  Identifies unique non-background pixel colors in the input grid.\n2.  For each color, counts its total pixels (N), finds the column index of its pixels (assuming they are all in one column), and determines the maximum row index (lowest point) of any pixel of that color.\n3.  Sorts these color groups based on their maximum row index in descending order (lowest in input goes to the bottom of the output).\n4.  Initializes an output grid of the same size as the input, filled with the background color (0).\n5.  Iterates through the sorted color groups:\n    a.  Determines the shape for the current color group based on its pixel count N:\n        i.  If N is a perfect square (e.g., 1, 4, 9), the shape is a symmetric pyramid with layer widths [1, 3, 5, ..., 2*sqrt(N)-1] from top to bottom.\n        ii. If N is not a perfect square, the shape is a single horizontal line of width N.\n    b.  Draws the determined shape onto the output grid, starting from the current available base row and moving upwards. The shape is centered horizontally based on the original column of the pixels. Pyramids are drawn layer by layer, widest at the bottom.\n    c.  Updates the available base row for the next shape to be stacked directly on top of the one just drawn.\n6.  Returns the final output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\nimport math\n\ndef get_layer_widths(pixel_count):\n    \"\"\"\n    Determines the widths of layers for the shape based on pixel count.\n\n    Args:\n        pixel_count: The total number of pixels (N) for the shape.\n\n    Returns:\n        A list of integers representing the widths of the layers,\n        ordered from the top layer (narrowest) to the bottom layer (widest).\n        - If N is a perfect square s*s, returns [1, 3, ..., 2*s-1].\n        - If N is not a perfect square, returns [N].\n    \"\"\"\n    sqrt_count_int = math.isqrt(pixel_count)\n    if sqrt_count_int * sqrt_count_int == pixel_count:\n        # Perfect square -> Pyramid shape\n        side = sqrt_count_int\n        # Generate widths: 1, 3, 5, ..., 2*side - 1\n        return [2 * i - 1 for i in range(1, side + 1)]\n    else:\n        # Not a perfect square -> Line shape\n        return [pixel_count]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the gravity and shape formation transformation.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A numpy array representing the output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Step 1: Initialize output_grid\n    output_grid = np.zeros_like(input_np)\n\n    # Step 2 & 3: Find colors, count pixels, find column and max_row\n    color_data = defaultdict(lambda: {'coords': [], 'max_row': -1, 'col': -1})\n    unique_colors = []\n\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != 0:  # If not background\n                if color not in color_data:\n                    unique_colors.append(color)\n                    # Assume all pixels of one color are in the same column, set on first encounter\n                    color_data[color]['col'] = c\n                color_data[color]['coords'].append((r, c))\n                color_data[color]['max_row'] = max(color_data[color]['max_row'], r)\n                # Optional: Add check if column changes for a color\n                # elif color_data[color]['col'] != c:\n                #     print(f\"Warning: Color {color} found in multiple columns. Using first encountered column {color_data[color]['col']}.\")\n\n\n    # Prepare data for sorting: list of {'color', 'count', 'col', 'max_row'}\n    processed_colors = []\n    for color in unique_colors:\n        data = color_data[color]\n        count = len(data['coords'])\n        col = data['col']\n        max_row = data['max_row']\n        processed_colors.append({'color': color, 'count': count, 'col': col, 'max_row': max_row})\n\n    # Step 4: Sort colors by max_row descending (gravity)\n    sorted_colors = sorted(processed_colors, key=lambda x: x['max_row'], reverse=True)\n\n    # Step 5: Initialize drawing parameters\n    current_base_row = height - 1 # Start drawing from the bottom row\n\n    # Step 6: Iterate through sorted colors and draw shapes\n    for item in sorted_colors:\n        color = item['color']\n        pixel_count = item['count']\n        center_col = item['col'] # Original column acts as center\n\n        # Step 6a & 6b: Determine layer widths based on pixel count\n        layer_widths = get_layer_widths(pixel_count) # Gets widths [top, ..., bottom] e.g. [1, 3, 5] or [N]\n\n        # Step 6c: Draw layers onto output grid\n        # Iterate through layers from bottom to top (widest to narrowest)\n        # to place them correctly relative to current_base_row\n        row_to_draw = current_base_row\n        for layer_width in reversed(layer_widths): # Process widest layer first\n            if row_to_draw < 0:\n                 # Avoid drawing above the grid\n                 print(f\"Warning: Attempting to draw color {color} above grid top (row {row_to_draw}). Skipping layer.\")\n                 break # Stop drawing layers for this color if it goes off top\n\n            # Calculate horizontal placement centered around original column\n            start_col = center_col - (layer_width // 2)\n            end_col = start_col + layer_width # Numpy slice goes up to, but not including, end_col\n\n            # Ensure drawing stays within grid bounds horizontally\n            draw_start_col = max(0, start_col)\n            draw_end_col = min(width, end_col)\n            \n            # Check if the calculated slice is valid before applying\n            if draw_start_col < draw_end_col and 0 <= row_to_draw < height:\n                 output_grid[row_to_draw, draw_start_col:draw_end_col] = color\n            else:\n                 # This case might indicate an issue if shapes are expected to go off-grid\n                 # or if calculations are wrong. Print a warning.\n                 print(f\"Warning: Layer slice ({draw_start_col}:{draw_end_col}) out of bounds or invalid for row {row_to_draw}.\")\n\n            # Move up for the next layer (narrower one)\n            row_to_draw -= 1 \n\n        # Step 6d: Update the base row for the *next* structure to be stacked on top\n        # The next structure starts one row above the top-most row just drawn\n        current_base_row = row_to_draw\n\n    # Step 7: Return the final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11724,
    "candidates_token_count": 1759,
    "total_token_count": 13483,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.865339,
  "retries": null
}