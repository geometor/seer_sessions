{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous regions of blue pixels (1) in the input grid.\nFor each blue region, it checks if the region completely encloses any maroon pixels (9).\nA maroon pixel is considered enclosed if any path from it to the grid boundary must cross a pixel belonging to the blue region being evaluated.\nIf a blue region encloses maroon pixels, all pixels belonging to that region are changed to azure (8) in the output grid.\nOtherwise, the blue region remains unchanged.\nThe background maroon pixels (9) are never modified.\nConnectivity for regions is defined orthogonally (up, down, left, right).\n\"\"\"\n\ndef find_connected_regions(grid, target_color):\n    \"\"\"\n    Finds all contiguous regions of a specific color in the grid using BFS.\n    Connectivity is orthogonal.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color of the pixels to form regions from.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing a single connected region.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new region\n                region_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                region_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor is the target color and not visited\n                            if grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                region_coords.add((nr, nc))\n                regions.append(region_coords)\n    return regions\n\ndef check_enclosure(grid, region_coords_set):\n    \"\"\"\n    Checks if a given region encloses any background (maroon, 9) pixels.\n    Uses a flood fill (BFS) starting from boundary pixels that are NOT part of the region.\n    Any maroon pixel not reached by the flood fill is considered enclosed.\n\n    Args:\n        grid (np.array): The input grid.\n        region_coords_set (set): A set of (row, col) tuples for the region to check.\n\n    Returns:\n        bool: True if the region encloses maroon pixels, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    visited_by_flood = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Initialize queue with boundary pixels NOT in the region being tested\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right boundaries\n             if (r, c) not in region_coords_set and not visited_by_flood[r, c]:\n                 q.append((r, c))\n                 visited_by_flood[r, c] = True\n    for c in range(cols): # Top and bottom boundaries (avoid double-adding corners)\n         for r in [0, rows - 1]:\n             if (r, c) not in region_coords_set and not visited_by_flood[r, c]:\n                 q.append((r, c))\n                 visited_by_flood[r, c] = True\n\n\n    # Perform BFS flood fill from the outside\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If neighbor is reachable (not part of the region barrier) and not visited\n                if (nr, nc) not in region_coords_set and not visited_by_flood[nr, nc]:\n                    visited_by_flood[nr, nc] = True\n                    q.append((nr, nc))\n\n    # Check for any maroon pixels that were NOT visited by the flood fill\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 9 and not visited_by_flood[r, c]:\n                 # Found an enclosed maroon pixel\n                 # We must ensure this maroon pixel wasn't enclosed by *another* barrier\n                 # However, the logic correctly identifies if *any* maroon pixel is unreachable\n                 # from the boundary without crossing the *current* region's pixels.\n                 # If a maroon pixel is unreachable, it must be enclosed by *some* barrier.\n                 # The flood fill explores everything reachable *without* crossing the specific region barrier.\n                 # So if a maroon pixel is not visited, the *current* region must be (part of) its enclosure.\n                 return True\n\n    # No enclosed maroon pixels found\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by changing blue (1) pixels to azure (8)\n    if they form a contiguous region that encloses maroon (9) pixels.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected regions of blue pixels (color 1)\n    blue_regions = find_connected_regions(input_grid, 1)\n\n    # Iterate through each identified blue region\n    for region_coords_set in blue_regions:\n        # Check if this region encloses any maroon (9) pixels\n        if check_enclosure(input_grid, region_coords_set):\n            # If it encloses, change the color of pixels in this region to azure (8)\n            for r, c in region_coords_set:\n                output_grid[r, c] = 8\n                \n    # change output pixels \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4454,
    "candidates_token_count": 1521,
    "total_token_count": 5975,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.387877,
  "retries": null
}