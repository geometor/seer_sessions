
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
3 3 3 2 3 3 3 3 3 3 3 3 3 3
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
4 4 4 4 4 4 4 4 4 2 4 4 4 4
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
0 0 0 4 0 0 0 0 0 3 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
5 5 5 5 2 5 5 5 5 5 5 5 5 5 5 5
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0 5 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 3 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 7 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
3 3 2 3 3 3 3 2 3 3 3 3 3
0 0 5 0 0 0 0 7 0 0 0 3 0
5 5 5 5 5 5 5 2 5 5 5 2 5
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
0 0 5 0 0 0 0 7 0 0 0 3 0
7 7 2 7 7 7 7 7 7 7 7 2 7
0 0 5 0 0 0 0 7 0 0 0 3 0
```

*   **Perception:** The input grid contains a small number of isolated, non-white pixels scattered on a white background. The output grid is generated by drawing lines based on these input pixels. For each non-white pixel in the input, its corresponding row and column in the output grid are filled with that pixel's color. However, where these drawn lines intersect (specifically, at the row of one input pixel and the column of *another* input pixel), the intersection point is colored red (2). The original positions of the input pixels retain their original colors in the output.

*   **Facts:**
    
```yaml
    task_elements:
      - element: background_pixels
        value: white (0)
        role: canvas
      - element: foreground_pixels
        value: non-white colors (1-9)
        role: source_points
        properties:
          - location: (row, column) coordinates
          - color: specific non-white value
    
    actions:
      - action: identify_source_points
        inputs: input_grid
        outputs: list of (row, column, color) tuples for non-white pixels
      - action: initialize_output
        inputs: input_grid_dimensions
        outputs: output_grid filled with white (0)
      - action: draw_lines
        inputs: output_grid, source_points
        description: For each source point (r, c, color), fill the entire row 'r' and the entire column 'c' of the output grid with 'color'. This happens for all points, potentially overwriting previous colors in rows/columns.
      - action: mark_intersections
        inputs: output_grid, source_points
        description: For every distinct pair of source points (r1, c1, color1) and (r2, c2, color2), set the pixels at (r1, c2) and (r2, c1) in the output grid to red (2).
      - action: restore_source_points
        inputs: output_grid, source_points
        description: For each source point (r, c, color), ensure the pixel at (r, c) in the output grid is set to 'color'. This corrects any overwrites from the draw_lines or mark_intersections steps at the original locations.
    
    relationships:
      - type: intersection
        between: pairs of source_points
        result: The grid locations defined by the row of one source point and the column of another source point are marked with a specific color (red).
      - type: projection
        from: source_points
        to: output_grid rows and columns
        result: The row and column corresponding to each source point are filled with that point's color.
    ```


*   **Natural Language Program:**
    1.  Identify the coordinates (row `r`, column `c`) and color `clr` of all non-white pixels in the input grid. Store these as a list of points `P = [(r1, c1, clr1), (r2, c2, clr2), ...]`.
    2.  Create an output grid of the same dimensions as the input grid, initialized with the background color (white, 0).
    3.  For each point `(r, c, clr)` in the list `P`:
        a.  Fill the entire row `r` of the output grid with color `clr`.
        b.  Fill the entire column `c` of the output grid with color `clr`.
    4.  Iterate through all unique pairs of distinct points from the list `P`. For each pair `(r1, c1, clr1)` and `(r2, c2, clr2)`:
        a.  Set the color of the pixel at coordinates `(r1, c2)` in the output grid to red (2).
        b.  Set the color of the pixel at coordinates `(r2, c1)` in the output grid to red (2).
    5.  For each point `(r, c, clr)` in the original list `P`:
        a.  Set the color of the pixel at coordinates `(r, c)` in the output grid back to its original color `clr`.
    6.  Return the final output grid.
