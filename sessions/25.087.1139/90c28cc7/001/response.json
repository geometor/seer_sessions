{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct, contiguous blocks of non-white color in the input grid.\nDetermine the vertical boundaries (top and bottom rows) and horizontal boundaries (leftmost and rightmost columns) for each block.\nCreate sorted lists of unique row and column boundaries (using min_row and max_row+1 for rows, min_col and max_col+1 for columns).\nThese sorted boundaries define intervals. The number of row intervals determines the output height, and column intervals determine the output width.\nConstruct the output grid.\nFor each cell (r, c) in the output grid, determine the corresponding spatial region (intersection of the r-th row interval and c-th column interval) in the input grid.\nFind the input block that occupies this region and assign its color to the output cell (r, c). If a block spans multiple intervals, its color is assigned to all corresponding output cells.\n\"\"\"\n\ndef _bfs(grid, start_row, start_col, visited):\n    \"\"\"Performs Breadth-First Search to find a connected object.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_row, start_col)])\n    color = grid[start_row, start_col]\n    pixels = set()\n    min_r, max_r = start_row, start_row\n    min_c, max_c = start_col, start_col\n    \n    while q:\n        r, c = q.popleft()\n        \n        if not (0 <= r < rows and 0 <= c < cols) or visited[r, c] or grid[r, c] != color:\n            continue\n            \n        visited[r, c] = True\n        pixels.add((r, c))\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n        \n        # Explore neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc] and grid[nr, nc] == color:\n                q.append((nr, nc))\n                \n    return {\n        'color': color,\n        'pixels': pixels,\n        'min_row': min_r,\n        'max_row': max_r,\n        'min_col': min_c,\n        'max_col': max_c\n    }\n\ndef _find_objects(grid):\n    \"\"\"Finds all contiguous non-background objects in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-background (not 0) and not visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj = _bfs(grid, r, c, visited)\n                objects.append(obj)\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by summarizing rectangular blocks based on their\n    spatial intervals.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Find all non-white objects and their properties\n    objects = _find_objects(input_np)\n\n    if not objects:\n        # Handle empty input or input with only background\n        # Returning an empty grid seems appropriate based on the summarization goal.\n        return np.array([[]], dtype=int) \n\n    # Collect all unique row and column boundaries\n    row_boundaries = set()\n    col_boundaries = set()\n    for obj in objects:\n        row_boundaries.add(obj['min_row'])\n        row_boundaries.add(obj['max_row'] + 1) # Use end+1 for interval definition\n        col_boundaries.add(obj['min_col'])\n        col_boundaries.add(obj['max_col'] + 1) # Use end+1 for interval definition\n\n    # Sort boundaries to define intervals\n    sorted_rows = sorted(list(row_boundaries))\n    sorted_cols = sorted(list(col_boundaries))\n    \n    # Remove boundaries outside the overall min/max range if necessary\n    # (though usually defined by the blocks themselves)\n    min_r_overall = min(obj['min_row'] for obj in objects)\n    max_r_overall = max(obj['max_row'] for obj in objects)\n    min_c_overall = min(obj['min_col'] for obj in objects)\n    max_c_overall = max(obj['max_col'] for obj in objects)\n\n    # Filter boundaries to only those within the span of the objects\n    # This handles cases where background padding might create unnecessary boundaries\n    # But the current logic using min/max+1 naturally handles the relevant span.\n    \n    # Map absolute coordinates to boundary indices for easier lookup\n    row_map = {val: i for i, val in enumerate(sorted_rows)}\n    col_map = {val: i for i, val in enumerate(sorted_cols)}\n\n    # Determine output grid size\n    output_height = len(sorted_rows) - 1\n    output_width = len(sorted_cols) - 1\n    \n    # Ensure non-negative dimensions\n    output_height = max(0, output_height)\n    output_width = max(0, output_width)\n\n    # Initialize output grid (e.g., with background color 0)\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # Fill the output grid based on object locations\n    for obj in objects:\n        # Find the start and end indices in the output grid for this object\n        start_row_idx = row_map[obj['min_row']]\n        end_row_idx = row_map[obj['max_row'] + 1] \n        start_col_idx = col_map[obj['min_col']]\n        end_col_idx = col_map[obj['max_col'] + 1]\n\n        # Assign the object's color to the corresponding cells in the output grid\n        output_grid[start_row_idx:end_row_idx, start_col_idx:end_col_idx] = obj['color']\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4844,
    "candidates_token_count": 1553,
    "total_token_count": 6397,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.708049,
  "retries": null
}