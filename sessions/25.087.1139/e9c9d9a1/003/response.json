{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Identifies horizontal green lines (pixel value 3) that divide the grid into vertical bands (Top, Middle, Bottom).\n2. Finds all contiguous rectangular blocks of white pixels (pixel value 0) within these bands.\n3. Determines the horizontal position (Leftmost, Intermediate, Rightmost, or Single) of each white block relative to other white blocks *within the same vertical band*.\n4. Recolors the white blocks based on their vertical band and determined horizontal position:\n    - Top Band: Leftmost/Single -> Red (2), Rightmost -> Yellow (4), Intermediate -> White (0).\n    - Middle Band(s): Intermediate -> Orange (7), Leftmost/Rightmost/Single -> White (0).\n    - Bottom Band: Leftmost/Single -> Blue (1), Rightmost -> Azure (8), Intermediate -> White (0).\n5. Preserves the original green structure and any other non-white pixels.\n\"\"\"\n\ndef find_horizontal_dividers(grid):\n    \"\"\"Finds rows composed entirely of green (3) pixels.\"\"\"\n    dividers = []\n    height, width = grid.shape\n    for r in range(height):\n        if width > 0 and np.all(grid[r, :] == 3): # Check width > 0 to avoid errors on empty rows\n            dividers.append(r)\n    return dividers\n\ndef find_blocks(grid, target_color=0):\n    \"\"\"Finds all contiguous blocks of a target color using BFS.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new block\n                q = deque([(r, c)])\n                visited[r, c] = True\n                coords = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            coords.add((nr, nc))\n                \n                # For ARC tasks, blocks are often rectangular or simple rectilinear shapes.\n                # We store the bounding box and the actual coordinates.\n                blocks.append({\n                    'coords': coords,\n                    'bbox': (min_r, max_r, min_c, max_c)\n                })\n                     \n    return blocks\n\ndef get_vertical_band(bbox, divider_indices, grid_height):\n    \"\"\"Determines the vertical band (Top, Middle, Bottom) of a block.\"\"\"\n    min_r, max_r, _, _ = bbox\n    \n    if not divider_indices: # No dividers\n        # If no dividers, technically there's no defined Top or Bottom relative to dividers.\n        # Classifying as Middle seems reasonable based on observed task behavior, \n        # but this might need adjustment if a task implies otherwise.\n        # Let's assume for this task, no dividers means one single band, treat as 'Middle'.\n        # Alternatively, could treat as Top/Bottom if only Left/Right coloring applies.\n        # Let's stick to 'Middle' for now, aligning with the general pattern.\n        # Revisit if examples contradict. Let's refine this: if no dividers, it's like Top AND Bottom.\n        # Check overall task rules - coloring depends on relative pos.\n        # If only one block, it's 'Single'. If multiple, Leftmost/Rightmost apply.\n        # Let's consider the entire grid as both Top and Bottom simultaneously if no dividers? No.\n        # Simplest: If no dividers, the rules for Top/Bottom (L->R/2, R->Y/4, L->B/1, R->Az/8) might apply directly.\n        # Or maybe only Middle rules (Int->O/7)?\n        # Re-evaluating examples: The structure seems dependent on dividers existing.\n        # If no dividers, maybe no transformation occurs? Or a default one?\n        # Let's assume the task guarantees dividers if band-specific logic is needed.\n        # If not, safe default might be 'Middle' or even skip categorization.\n        # Based on the examples *having* dividers, let's assume dividers are present for band logic.\n        # If dividers ARE present:\n        return \"No Band\" # Should not happen if dividers are guaranteed by task structure\n\n    first_divider = divider_indices[0]\n    last_divider = divider_indices[-1]\n\n    if max_r < first_divider:\n        return \"Top\"\n    elif min_r > last_divider:\n        return \"Bottom\"\n    else: \n        # Must be between dividers. Check if it falls strictly between *any* two dividers.\n        for i in range(len(divider_indices) - 1):\n            if min_r > divider_indices[i] and max_r < divider_indices[i+1]:\n                return \"Middle\"\n        \n        # If not strictly between intermediate dividers, check if it's between the first and last\n        # but might touch one edge (e.g., min_r > first_divider and max_r < last_divider)\n        # The logic above covers this. Any block not fully above the first or fully below the last\n        # must be between some pair of dividers, or between an edge and the first/last divider\n        # if it spanned multiple middle bands (which seems unlikely based on examples).\n        # So, if not Top and not Bottom, it must be Middle.\n        return \"Middle\"\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # 1. Find Horizontal Dividers (green rows)\n    divider_indices = find_horizontal_dividers(grid)\n\n    # 2. Find all white (0) blocks\n    white_blocks = find_blocks(grid, target_color=0)\n\n    # If no white blocks, return the original grid\n    if not white_blocks:\n        return output_grid.tolist() \n\n    # 3. Categorize blocks by vertical band\n    categorized_blocks = []\n    for block in white_blocks:\n        bbox = block['bbox']\n        # Determine the band based on block position relative to dividers\n        band = \"Unknown\" # Default\n        if not divider_indices:\n             # No dividers case - How to handle? Let's assume based on examples that dividers exist.\n             # If this assumption is wrong, we need a rule for grids without dividers.\n             # For now, proceed assuming dividers exist if band logic is relevant.\n             # A safe fallback might be to apply no color changes if no dividers are found.\n             pass # Skip categorization if no dividers? Or treat all as one band?\n             # Let's assume for now the task implies dividers will be present.\n        else:\n            first_divider = divider_indices[0]\n            last_divider = divider_indices[-1]\n            min_r, max_r, _, _ = bbox\n\n            if max_r < first_divider:\n                band = \"Top\"\n            elif min_r > last_divider:\n                band = \"Bottom\"\n            else: # Could be between dividers (Middle)\n                # Check if it's truly between any two consecutive dividers\n                is_middle = False\n                for i in range(len(divider_indices) - 1):\n                     if min_r > divider_indices[i] and max_r < divider_indices[i+1]:\n                         is_middle = True\n                         break\n                # If not strictly between internal dividers, it might be between grid edge and divider,\n                # but Top/Bottom checks already cover grid edges. So if not Top/Bottom, it's Middle.\n                if not is_middle:\n                    # It must be between the first and last divider boundary conceptually\n                     if min_r > first_divider or max_r < last_divider: # Ensure it doesn't span *across* first/last\n                         is_middle = True\n                \n                if is_middle:\n                    band = \"Middle\"\n                else:\n                    # This case (e.g., spanning a divider) seems unlikely in ARC. Defaulting if ambiguous.\n                    band = \"Middle\" # Fallback assumption\n\n        if band != \"Unknown\":\n             categorized_blocks.append({\n                 'coords': block['coords'],\n                 'bbox': bbox,\n                 'band': band,\n                 'min_c': bbox[2], # Store min/max col for easier sorting/comparison\n                 'max_c': bbox[3]\n             })\n\n    # 4. Group blocks by band and determine horizontal position within each band\n    bands = {\"Top\": [], \"Middle\": [], \"Bottom\": []}\n    for block in categorized_blocks:\n        bands[block['band']].append(block)\n\n    final_blocks_info = []\n    for band_name, blocks_in_band in bands.items():\n        if not blocks_in_band:\n            continue\n\n        # Find min starting column and max ending column among blocks *in this band*\n        if len(blocks_in_band) == 1:\n             band_min_c = blocks_in_band[0]['min_c']\n             band_max_c = blocks_in_band[0]['max_c']\n        else:\n            band_min_c = min(b['min_c'] for b in blocks_in_band)\n            band_max_c = max(b['max_c'] for b in blocks_in_band) \n            \n        # Assign horizontal position relative to the band's extent\n        for block in blocks_in_band:\n            is_leftmost = (block['min_c'] == band_min_c)\n            is_rightmost = (block['max_c'] == band_max_c)\n\n            if is_leftmost and is_rightmost: \n                # Covers single block case and multiple blocks tiling the full width\n                position = \"Single\" \n            elif is_leftmost:\n                position = \"Leftmost\"\n            elif is_rightmost:\n                position = \"Rightmost\"\n            else:\n                position = \"Intermediate\"\n            \n            block['position'] = position\n            final_blocks_info.append(block) # Add block with position info\n\n\n    # 5. Apply fill colors based on band and position rules\n    for block in final_blocks_info:\n        band = block['band']\n        position = block['position']\n        coords = block['coords']\n        fill_color = 0 # Default to white (no change)\n\n        if band == \"Top\":\n            if position == \"Leftmost\" or position == \"Single\":\n                fill_color = 2 # Red\n            elif position == \"Rightmost\":\n                fill_color = 4 # Yellow\n            # Intermediate remains white (0)\n        \n        elif band == \"Middle\":\n            # *** Corrected Rule *** Only color Intermediate blocks Orange\n            if position == \"Intermediate\":\n                fill_color = 7 # Orange\n            # Leftmost, Rightmost, Single remain white (0)\n\n        elif band == \"Bottom\":\n            if position == \"Leftmost\" or position == \"Single\":\n                fill_color = 1 # Blue\n            elif position == \"Rightmost\":\n                fill_color = 8 # Azure\n            # Intermediate remains white (0)\n\n        # Fill the block in the output grid only if fill_color needs changing\n        if fill_color != 0:\n            # Use coordinates for accuracy\n            for r_coord, c_coord in coords:\n                 # Check bounds just in case, though coords should be valid\n                 if 0 <= r_coord < height and 0 <= c_coord < width:\n                      output_grid[r_coord, c_coord] = fill_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11933,
    "candidates_token_count": 2968,
    "total_token_count": 14901,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.05284,
  "retries": null
}