{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies horizontal green lines (dividers) that separate the grid into vertical bands (Top, Middle, Bottom).\nFinds all contiguous rectangular blocks of white pixels within these bands.\nDetermines the horizontal position (Leftmost, Intermediate, Rightmost) of each white block within its band.\nRecolors the white blocks based on their vertical band and horizontal position:\n- Top Band: Leftmost -> Red (2), Rightmost -> Yellow (4), Intermediate -> White (0)\n- Middle Bands: All -> Orange (7)\n- Bottom Band: Leftmost -> Blue (1), Rightmost -> Azure (8), Intermediate -> White (0)\nKeeps the original green structure intact.\n\"\"\"\n\ndef find_horizontal_dividers(grid):\n    \"\"\"Finds rows composed entirely of green (3) pixels.\"\"\"\n    dividers = []\n    height, width = grid.shape\n    for r in range(height):\n        if np.all(grid[r, :] == 3):\n            dividers.append(r)\n    return dividers\n\ndef find_blocks(grid, target_color=0):\n    \"\"\"Finds all contiguous blocks of a target color using BFS.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new block\n                q = [(r, c)]\n                visited[r, c] = True\n                coords = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            coords.add((nr, nc))\n                \n                # Check if the block is rectangular (simple check for this task)\n                is_rectangular = True\n                if len(coords) != (max_r - min_r + 1) * (max_c - min_c + 1):\n                    # This simple check might fail for complex shapes, but seems sufficient here\n                    # A more robust check would verify all cells within the bbox are part of coords\n                    # For this task, assuming white blocks are always rectangular fills\n                    pass # Let's assume rectangular for now based on examples\n\n                if is_rectangular:\n                     blocks.append({\n                         'coords': coords,\n                         'bbox': (min_r, max_r, min_c, max_c)\n                     })\n                     \n    return blocks\n\ndef get_vertical_band(bbox, divider_indices, grid_height):\n    \"\"\"Determines the vertical band (Top, Middle, Bottom) of a block.\"\"\"\n    min_r, max_r, _, _ = bbox\n    \n    if not divider_indices: # No dividers, everything is in one band\n        return \"Middle\" # Or could define as Top/Bottom if needed, Middle seems reasonable\n\n    first_divider = divider_indices[0]\n    last_divider = divider_indices[-1]\n\n    if max_r < first_divider:\n        return \"Top\"\n    elif min_r > last_divider:\n        return \"Bottom\"\n    else: # Between or spanning dividers\n        # Check if it's strictly between two dividers or the grid edge and a divider\n        is_middle = False\n        if min_r > first_divider and max_r < last_divider: # Strictly between first and last\n             is_middle = True\n        elif len(divider_indices) > 1: # Check between intermediate dividers\n             for i in range(len(divider_indices) - 1):\n                 if min_r > divider_indices[i] and max_r < divider_indices[i+1]:\n                     is_middle = True\n                     break\n        # If not strictly between, check if it's between a divider and an edge\n        # Note: The logic handles blocks strictly above the first divider (Top)\n        # and strictly below the last divider (Bottom). Anything else is Middle.\n        if not is_middle and not (max_r < first_divider or min_r > last_divider):\n             is_middle = True\n\n        if is_middle:\n             return \"Middle\"\n        else:\n             # This case should ideally not happen if blocks don't cross dividers\n             # If a block somehow spans a divider, classify it based on majority maybe?\n             # For this task, assume blocks are fully within one band defined by dividers.\n             # Defaulting to Middle if ambiguous.\n             return \"Middle\"\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding white blocks enclosed by green lines\n    and coloring them based on their vertical band and horizontal position within the band.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # 1. Find Horizontal Dividers\n    divider_indices = find_horizontal_dividers(grid)\n\n    # 2. Find all white (0) blocks\n    white_blocks = find_blocks(grid, target_color=0)\n\n    if not white_blocks:\n        return output_grid.tolist() # No white blocks to change\n\n    # 3. Categorize blocks by vertical band\n    categorized_blocks = []\n    for block in white_blocks:\n        bbox = block['bbox']\n        band = get_vertical_band(bbox, divider_indices, height)\n        categorized_blocks.append({\n            'bbox': bbox,\n            'coords': block['coords'],\n            'band': band,\n            'min_c': bbox[2], # Store min/max col for easier sorting/comparison\n            'max_c': bbox[3]\n        })\n\n    # 4. Group blocks by band and determine horizontal position\n    bands = {\"Top\": [], \"Middle\": [], \"Bottom\": []}\n    for block in categorized_blocks:\n        bands[block['band']].append(block)\n\n    final_blocks_info = []\n    for band_name, blocks_in_band in bands.items():\n        if not blocks_in_band:\n            continue\n\n        # Find min/max columns within this band\n        if len(blocks_in_band) == 1:\n             min_col_in_band = blocks_in_band[0]['min_c']\n             max_col_in_band = blocks_in_band[0]['max_c'] # For a single block min_c and max_c define its span\n             leftmost_blocks = blocks_in_band\n             rightmost_blocks = blocks_in_band\n        else:\n            min_col_in_band = min(b['min_c'] for b in blocks_in_band)\n            max_col_in_band = max(b['max_c'] for b in blocks_in_band) # Use max_c for rightmost edge\n            \n            leftmost_blocks = [b for b in blocks_in_band if b['min_c'] == min_col_in_band]\n            # Important: Rightmost should be based on the maximum extent (max_c)\n            rightmost_blocks = [b for b in blocks_in_band if b['max_c'] == max_col_in_band]\n\n\n        # Assign horizontal position\n        for block in blocks_in_band:\n            is_leftmost = block in leftmost_blocks\n            is_rightmost = block in rightmost_blocks # Check if it's among those reaching the rightmost extent\n\n            if is_leftmost and is_rightmost: # Single block or blocks spanning the full width available\n                position = \"Single\" # Covers both leftmost and rightmost\n            elif is_leftmost:\n                position = \"Leftmost\"\n            elif is_rightmost:\n                position = \"Rightmost\"\n            else:\n                position = \"Intermediate\"\n            \n            block['position'] = position\n            final_blocks_info.append(block)\n\n\n    # 5. Apply fill colors based on rules\n    for block in final_blocks_info:\n        band = block['band']\n        position = block['position']\n        bbox = block['bbox']\n        coords = block['coords']\n        fill_color = 0 # Default to white\n\n        if band == \"Top\":\n            if position == \"Leftmost\" or position == \"Single\":\n                fill_color = 2 # Red\n            elif position == \"Rightmost\":\n                fill_color = 4 # Yellow\n            # Intermediate remains white (0)\n        elif band == \"Middle\":\n            fill_color = 7 # Orange\n        elif band == \"Bottom\":\n            if position == \"Leftmost\" or position == \"Single\":\n                fill_color = 1 # Blue\n            elif position == \"Rightmost\":\n                fill_color = 8 # Azure\n            # Intermediate remains white (0)\n\n        # Fill the block in the output grid only if fill_color is not white\n        if fill_color != 0:\n            # Use coordinates for accuracy, especially if blocks aren't perfectly rectangular\n            # Though bbox filling is faster if blocks are guaranteed rectangular\n            min_r, max_r, min_c, max_c = bbox\n            output_grid[min_r:max_r+1, min_c:max_c+1] = fill_color\n            # Correct potential overfill if block wasn't truly rectangular\n            # Iterate through the bbox area and only color the actual block coords\n            # This is safer\n            # temp_fill = output_grid[min_r:max_r+1, min_c:max_c+1].copy()\n            # for r_idx in range(temp_fill.shape[0]):\n            #      for c_idx in range(temp_fill.shape[1]):\n            #           grid_r, grid_c = min_r + r_idx, min_c + c_idx\n            #           if (grid_r, grid_c) in coords:\n            #                output_grid[grid_r, grid_c] = fill_color\n            #           else: # This part might be wrong if the original was not 0\n            #                # Instead of resetting, just color the coords:\n            #                pass # Let's stick to bbox filling assuming rectilinearity\n            \n            # Refined filling using coordinates:\n            for r_coord, c_coord in coords:\n                 output_grid[r_coord, c_coord] = fill_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5270,
    "candidates_token_count": 2600,
    "total_token_count": 7870,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.478923,
  "retries": null
}