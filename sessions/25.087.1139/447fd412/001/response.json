{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom skimage import measure\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Identify all red (2) and blue (1) objects in the input grid.\n2.  Determine which red objects are \"isolated,\" meaning they are not adjacent (including diagonally) to any blue pixels from the *original* input grid.\n3.  Copy the input grid to the output grid.\n4.  Process the isolated red objects based on specific pairing configurations or as individuals:\n    a.  **Vertical 1x1 Pair:** If two isolated 1x1 red pixels are found at `(r, c)` and `(r+3, c)`, draw a blue 'T' shape below each. The 'T' consists of a horizontal bar at row `y+1`, columns `c-1` to `c+1`, and a vertical stem at row `y+2`, column `c` (where `y` is the row of the red pixel). Mark these red objects as processed.\n    b.  **Horizontal 2x2 Pair:** If two isolated 2x2 red squares are found starting at `(r, c)` and `(r, c')` (where `c' > c+1`), draw several blue shapes:\n        i.  A connector rectangle from `(r, c+2)` to `(r+1, c'-1)`.\n        ii. A 2x2 blue square centered horizontally below the connector, starting at row `r+2`. Let the connector span columns `col_start = c+2` to `col_end = c'-1`. The center column index needs calculation. If width `w = col_end - col_start + 1`, the center start col is `floor(col_start + w/2 - 1)`. The square is at `(r+2, center_start_col)` to `(r+3, center_start_col+1)`. Let's re-examine example 2: Connector cols 5-8 (width 4). Square cols 6-7. `5 + 4/2 - 1 = 6`. Correct.\n        iii. A rectangle below the square, from `(r+4, c+2)` to `(r+5, c')`. Mark these red objects as processed.\n    c.  **Single Isolated Object:** If an isolated red object was not part of a pair, find its bounding box `(r1, c1, r2, c2)` (inclusive rows/cols). Draw a blue rectangle from `(r1, 0)` to `(r2, c1-1)`. Mark this object as processed.\n5.  Return the modified output grid. All original objects (red and blue) remain in the output.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all connected objects of a specific color.\"\"\"\n    objects = []\n    mask = (grid == color)\n    labeled_grid, num_labels = measure.label(mask, connectivity=2, background=0, return_num=True) # connectivity=2 means 8-way connection\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        # Convert to set of tuples for easier handling\n        objects.append(set(tuple(coord) for coord in coords))\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"Calculates the inclusive bounding box of an object.\"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_shape_size(obj_coords):\n    \"\"\"Gets the size (height, width) from the bounding box.\"\"\"\n    bbox = get_bounding_box(obj_coords)\n    if not bbox:\n        return 0, 0\n    r1, c1, r2, c2 = bbox\n    return r2 - r1 + 1, c2 - c1 + 1\n\ndef is_isolated(grid, red_obj_coords, blue_objects_coords_flat):\n    \"\"\"Checks if a red object is isolated from all blue objects.\"\"\"\n    height, width = grid.shape\n    for r, c in red_obj_coords:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < height and 0 <= nc < width:\n                    if (nr, nc) in blue_objects_coords_flat:\n                        return False # Found adjacent blue pixel\n    return True # No adjacent blue pixels found\n\ndef draw_pixels(grid, coords_to_draw, color):\n    \"\"\"Draws pixels on the grid, respecting boundaries.\"\"\"\n    height, width = grid.shape\n    for r, c in coords_to_draw:\n        if 0 <= r < height and 0 <= c < width:\n            grid[r, c] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all red and blue objects\n    red_objects = find_objects(input_grid, 2)\n    blue_objects = find_objects(input_grid, 1)\n\n    # Create a flat set of all blue coordinates for efficient adjacency checking\n    blue_coords_flat = set()\n    for b_obj in blue_objects:\n        blue_coords_flat.update(b_obj)\n\n    # 2. Identify isolated red objects\n    isolated_red_objects = []\n    for r_obj_coords in red_objects:\n        if is_isolated(input_grid, r_obj_coords, blue_coords_flat):\n            isolated_red_objects.append({\n                \"coords\": r_obj_coords,\n                \"bbox\": get_bounding_box(r_obj_coords),\n                \"shape_size\": get_shape_size(r_obj_coords)\n            })\n\n    # Sort isolated objects by top-left corner (row, then column) for consistent pairing\n    isolated_red_objects.sort(key=lambda x: (x[\"bbox\"][0], x[\"bbox\"][1]))\n\n    processed_indices = set()\n    num_isolated = len(isolated_red_objects)\n    blue_color = 1\n\n    # 4a. Process Vertical 1x1 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects[i]\n        # Check if it's a 1x1 pixel\n        if obj1[\"shape_size\"] == (1, 1):\n            r1, c1, _, _ = obj1[\"bbox\"]\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects[j]\n                if obj2[\"shape_size\"] == (1, 1):\n                    r2, c2, _, _ = obj2[\"bbox\"]\n                    # Check for vertical alignment (same column, 3 rows apart)\n                    if c1 == c2 and r2 == r1 + 3:\n                        # Found a pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # Draw T-shape below obj1\n                        t1_coords = set()\n                        t1_coords.add((r1 + 1, c1 - 1))\n                        t1_coords.add((r1 + 1, c1))\n                        t1_coords.add((r1 + 1, c1 + 1))\n                        t1_coords.add((r1 + 2, c1))\n                        draw_pixels(output_grid, t1_coords, blue_color)\n\n                        # Draw T-shape below obj2\n                        t2_coords = set()\n                        t2_coords.add((r2 + 1, c2 - 1))\n                        t2_coords.add((r2 + 1, c2))\n                        t2_coords.add((r2 + 1, c2 + 1))\n                        t2_coords.add((r2 + 2, c2))\n                        draw_pixels(output_grid, t2_coords, blue_color)\n                        break # obj1 is paired, move to the next i\n\n    # 4b. Process Horizontal 2x2 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects[i]\n        # Check if it's a 2x2 square\n        if obj1[\"shape_size\"] == (2, 2):\n            r1_start, c1_start, r1_end, c1_end = obj1[\"bbox\"]\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects[j]\n                if obj2[\"shape_size\"] == (2, 2):\n                    r2_start, c2_start, r2_end, c2_end = obj2[\"bbox\"]\n                    # Check for horizontal alignment (same rows, obj2 is to the right)\n                    if r1_start == r2_start and r1_end == r2_end and c2_start > c1_end:\n                         # Found a pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # i. Draw connector rectangle\n                        connector_coords = set()\n                        for r in range(r1_start, r1_end + 1):\n                            for c in range(c1_end + 1, c2_start):\n                                connector_coords.add((r, c))\n                        draw_pixels(output_grid, connector_coords, blue_color)\n\n                        # ii. Draw 2x2 square below connector\n                        conn_col_start = c1_end + 1\n                        conn_col_end = c2_start - 1\n                        conn_width = conn_col_end - conn_col_start + 1\n                        # Ensure width > 0 before centering\n                        if conn_width > 0:\n                            square_start_col = conn_col_start + conn_width // 2 -1 # Center calculation\n                            square_coords = set()\n                            for r in range(r1_start + 2, r1_start + 4):\n                                for c in range(square_start_col, square_start_col + 2):\n                                     square_coords.add((r,c))\n                            draw_pixels(output_grid, square_coords, blue_color)\n\n                        # iii. Draw rectangle below square (Matches example 2 output)\n                        # Width seems to span from connector start col to obj2 end col\n                        # Example 2: Conn cols 5-8. Obj2 cols 9-10. Bottom Rect cols 5-10.\n                        # So cols c1_end + 1 to c2_end.\n                        bottom_rect_coords = set()\n                        for r in range(r1_start + 4, r1_start + 6):\n                             for c in range(c1_end + 1, c2_end + 1):\n                                bottom_rect_coords.add((r,c))\n                        draw_pixels(output_grid, bottom_rect_coords, blue_color)\n\n                        break # obj1 is paired, move to the next i\n\n    # 4c. Process Single Isolated Objects\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj = isolated_red_objects[i]\n        r1, c1, r2, c2 = obj[\"bbox\"]\n\n        # Draw rectangle to the left\n        left_rect_coords = set()\n        if c1 > 0: # Only draw if there's space to the left\n            for r in range(r1, r2 + 1):\n                for c in range(0, c1):\n                    left_rect_coords.add((r, c))\n            draw_pixels(output_grid, left_rect_coords, blue_color)\n\n        # Mark as processed (though not strictly necessary in this final loop)\n        processed_indices.add(i)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4882,
    "candidates_token_count": 2922,
    "total_token_count": 7804,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.675245,
  "retries": null
}