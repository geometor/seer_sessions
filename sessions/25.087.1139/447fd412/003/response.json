{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\ntry:\n    # skimage is used for finding connected components (objects)\n    # If running locally, ensure scikit-image is installed: pip install scikit-image\n    from skimage import measure\n    SKIMAGE_AVAILABLE = True\nexcept ImportError:\n    # Fallback if skimage is not available\n    SKIMAGE_AVAILABLE = False\n    print(\"Warning: scikit-image not found. Object detection will be limited.\")\n    # NOTE: A manual implementation of connected components (e.g., BFS/DFS)\n    # would be needed here for a complete fallback. For now, we proceed\n    # assuming skimage is available, as it's crucial for the logic.\n\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Identify all distinct red (2) objects and blue (1) objects in the input grid, considering pixels connected 8-directionally (including diagonals) as part of the same object. Store the coordinates of all pixels belonging to blue objects.\n3.  Determine which red objects are \"isolated\". A red object is isolated if none of its pixels are adjacent (8-directionally) to any pixel belonging to any *original* blue object.\n4.  Create a list of the isolated red objects and sort them based on their top-left corner coordinates (first by row, then by column). Keep track of which isolated objects have been processed.\n5.  Iterate through the sorted list of isolated red objects to find and process specific pairs:\n    *   **Vertical 1x1 Pair:** Search for two *unprocessed* isolated red objects where both are single pixels (1x1), have the same column index `c`, and their row indices `r1`, `r2` satisfy `r2 = r1 + 3`. If found:\n        *   Draw a blue 'T' shape immediately below the first pixel: a horizontal 3-pixel bar at `r1+1` (cols `c-1` to `c+1`) and a vertical 1-pixel stem at `(r1+2, c)`.\n        *   Draw an identical blue 'T' shape relative to the second pixel (rows `r2+1`, `r2+2`).\n        *   Mark both red objects as processed.\n    *   **Horizontal 2x2 Pair:** Search for two *unprocessed* isolated red objects where both are 2x2 squares, located on the same rows `r` and `r+1`, with the second square starting at a column `c2` that is at least 2 columns to the right of the first square's starting column `c1` (i.e., `c2 > c1+1`). Let the first square span columns `c1` to `c1+1` and the second span `c2` to `c2+1`. If found:\n        *   Draw a blue connector rectangle of size 2xN between the squares: rows `r` to `r+1`, columns `c1+2` to `c2-1`.\n        *   Draw a blue 2x2 square centered horizontally below the connector rectangle, starting at row `r+2`.\n        *   Draw a blue bottom rectangle of size 2xM below the square structure: rows `r+4` to `r+5`, columns `c1+2` to `c2+1`.\n        *   Mark both red objects as processed.\n6.  Iterate through the list of isolated red objects again. For any isolated red object that is still *unprocessed*:\n    *   Find its bounding box `(r1, c1, r2, c2)`.\n    *   If its minimum column `c1` is greater than 0, draw a blue rectangle covering all cells from row `r1` to `r2` and column `0` to `c1-1`.\n7.  Return the modified output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color using skimage.measure.label.\n    Connectivity is 8-way (including diagonals).\n    Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n    Returns an empty list if skimage is not available or no objects are found.\n    \"\"\"\n    if not SKIMAGE_AVAILABLE:\n        # Cannot find objects without skimage or a manual implementation\n        return []\n    objects = []\n    mask = (grid == color)\n    # connectivity=2 means 8-way connection (includes diagonals)\n    labeled_grid, num_labels = measure.label(mask, connectivity=2, background=0, return_num=True)\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        # Convert to set of tuples for easier handling and lookup\n        objects.append(set(tuple(coord) for coord in coords))\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the inclusive bounding box (min_row, min_col, max_row, max_col)\n    for a set of object coordinates.\n    Returns None if the object coordinates set is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_shape_size(obj_coords):\n    \"\"\"\n    Gets the size (height, width) of an object based on its bounding box.\n    Returns (0, 0) if the object coordinates set is empty.\n    \"\"\"\n    bbox = get_bounding_box(obj_coords)\n    if not bbox:\n        return 0, 0\n    r1, c1, r2, c2 = bbox\n    return r2 - r1 + 1, c2 - c1 + 1\n\ndef is_isolated(grid, red_obj_coords, blue_coords_flat):\n    \"\"\"\n    Checks if a red object (given by its coordinates) is isolated, meaning\n    none of its pixels are adjacent (8-way) to any blue pixel coordinates\n    provided in blue_coords_flat.\n    \"\"\"\n    height, width = grid.shape\n    for r, c in red_obj_coords:\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip the pixel itself\n                nr, nc = r + dr, c + dc\n                # Check if neighbor is within grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if the neighbor is a blue pixel\n                    if (nr, nc) in blue_coords_flat:\n                        return False # Found adjacent blue pixel, so not isolated\n    return True # No adjacent blue pixels found\n\ndef draw_pixels(grid, coords_to_draw, color):\n    \"\"\"\n    Draws pixels onto the grid at the specified coordinates with the given color.\n    Checks boundaries to avoid errors.\n    \"\"\"\n    height, width = grid.shape\n    for r, c in coords_to_draw:\n        # Ensure coordinates are within the grid boundaries\n        if 0 <= r < height and 0 <= c < width:\n            grid[r, c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid based on isolated red objects.\n    \"\"\"\n    # 1. Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    blue_color = 1 # Define color constants\n    red_color = 2\n\n    # 2. Identify all red and blue objects\n    red_objects = find_objects(input_grid, red_color)\n    blue_objects = find_objects(input_grid, blue_color)\n\n    # Create a flat set of all blue coordinates for efficient adjacency checking\n    blue_coords_flat = set()\n    for b_obj in blue_objects:\n        blue_coords_flat.update(b_obj)\n\n    # 3. Determine which red objects are isolated\n    isolated_red_objects_data = []\n    for r_obj_coords in red_objects:\n        if is_isolated(input_grid, r_obj_coords, blue_coords_flat):\n            bbox = get_bounding_box(r_obj_coords)\n            if bbox: # Ensure object is valid\n                 isolated_red_objects_data.append({\n                    \"coords\": r_obj_coords,\n                    \"bbox\": bbox,\n                    \"shape_size\": get_shape_size(r_obj_coords)\n                })\n\n    # 4. Sort isolated red objects by top-left corner (row, then column)\n    isolated_red_objects_data.sort(key=lambda x: (x[\"bbox\"][0], x[\"bbox\"][1]))\n\n    # Keep track of processed objects (by index in the sorted list)\n    processed_indices = set()\n    num_isolated = len(isolated_red_objects_data)\n\n    # 5. Process pairs first\n    # 5a. Process Vertical 1x1 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects_data[i]\n        # Check if it's a 1x1 pixel\n        if obj1[\"shape_size\"] == (1, 1):\n            r1, c1, _, _ = obj1[\"bbox\"]\n            # Search for a potential pair starting from the next object\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects_data[j]\n                if obj2[\"shape_size\"] == (1, 1):\n                    r2, c2, _, _ = obj2[\"bbox\"]\n                    # Check for vertical alignment (same column, 3 rows apart)\n                    if c1 == c2 and r2 == r1 + 3:\n                        # Found a vertical 1x1 pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # Draw T-shape below obj1\n                        t1_coords = set()\n                        # Horizontal bar: (r1+1, c1-1), (r1+1, c1), (r1+1, c1+1)\n                        # Vertical stem: (r1+2, c1)\n                        t1_coords.add((r1 + 1, c1 - 1))\n                        t1_coords.add((r1 + 1, c1))\n                        t1_coords.add((r1 + 1, c1 + 1))\n                        t1_coords.add((r1 + 2, c1))\n                        draw_pixels(output_grid, t1_coords, blue_color)\n\n                        # Draw T-shape below obj2\n                        t2_coords = set()\n                        # Horizontal bar: (r2+1, c2-1), (r2+1, c2), (r2+1, c2+1) -> (r1+4, c1-1), (r1+4, c1), (r1+4, c1+1)\n                        # Vertical stem: (r2+2, c2) -> (r1+5, c1)\n                        t2_coords.add((r1 + 4, c1 - 1))\n                        t2_coords.add((r1 + 4, c1))\n                        t2_coords.add((r1 + 4, c1 + 1))\n                        t2_coords.add((r1 + 5, c1))\n                        draw_pixels(output_grid, t2_coords, blue_color)\n\n                        # Break inner loop once obj1 is paired\n                        break\n\n    # 5b. Process Horizontal 2x2 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects_data[i]\n        # Check if it's a 2x2 square\n        if obj1[\"shape_size\"] == (2, 2):\n            r1_start, c1_start, r1_end, c1_end = obj1[\"bbox\"] # r1_end=r1_start+1, c1_end=c1_start+1\n            # Search for a potential pair starting from the next object\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects_data[j]\n                if obj2[\"shape_size\"] == (2, 2):\n                    r2_start, c2_start, r2_end, c2_end = obj2[\"bbox\"] # r2_end=r2_start+1, c2_end=c2_start+1\n                    # Check for horizontal alignment (same rows, obj2 is to the right with a gap)\n                    if r1_start == r2_start and c2_start > c1_end + 1: # c2_start must be at least c1_start+2+1 = c1_end+2\n                         # Found a horizontal 2x2 pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # i. Draw connector rectangle (rows r1_start to r1_end, cols c1_end+1 to c2_start-1)\n                        connector_coords = set()\n                        for r in range(r1_start, r1_end + 1):\n                            for c in range(c1_end + 1, c2_start):\n                                connector_coords.add((r, c))\n                        draw_pixels(output_grid, connector_coords, blue_color)\n\n                        # ii. Draw 2x2 square below connector\n                        conn_col_start = c1_end + 1\n                        conn_col_end = c2_start - 1\n                        conn_width = conn_col_end - conn_col_start + 1\n                        # Ensure width > 0 before centering (should be guaranteed by c2_start > c1_end + 1)\n                        if conn_width > 0:\n                            # Calculate top-left corner of the 2x2 square\n                            # Center col index within connector is roughly conn_col_start + conn_width / 2\n                            # For a 2x2 square, we want its left column `square_start_col` such that\n                            # `square_start_col` and `square_start_col+1` are centered.\n                            # Midpoint of connector: conn_col_start + (conn_width - 1) / 2\n                            # Start col for 2x2: floor(Midpoint - 0.5) = floor(conn_col_start + conn_width/2 - 1/2 - 0.5) = floor(conn_col_start + conn_width/2 - 1)\n                            # Example: cols 5-8 (width 4). Mid = 5 + 1.5 = 6.5. square_start = floor(6.5 - 0.5) = 6. Correct.\n                            # Example: cols 5-9 (width 5). Mid = 5 + 2 = 7. square_start = floor(7 - 0.5) = 6. Square at 6,7. Centered? Yes.\n                            # simpler: conn_col_start + (conn_width // 2) - 1\n                            square_start_col = conn_col_start + (conn_width // 2) -1\n                            square_start_row = r1_start + 2\n                            square_coords = set()\n                            for r in range(square_start_row, square_start_row + 2):\n                                for c in range(square_start_col, square_start_col + 2):\n                                     square_coords.add((r,c))\n                            draw_pixels(output_grid, square_coords, blue_color)\n\n                        # iii. Draw bottom rectangle below square structure\n                        # Rows r1_start+4 to r1_start+5 (height 2)\n                        # Cols c1_end+1 to c2_end (c1_start+1+1 to c2_start+1 -> c1_start+2 to c2_start+1)\n                        # Example 2: c1=3, c2=9. c1_end=4, c2_end=10. Cols 5 to 10. Correct.\n                        bottom_rect_start_row = r1_start + 4\n                        bottom_rect_coords = set()\n                        for r in range(bottom_rect_start_row, bottom_rect_start_row + 2):\n                             for c in range(c1_end + 1, c2_end + 1):\n                                bottom_rect_coords.add((r,c))\n                        draw_pixels(output_grid, bottom_rect_coords, blue_color)\n\n                        # Break inner loop once obj1 is paired\n                        break\n\n    # 6. Process Single Isolated Objects (those not part of pairs)\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue # Skip objects already processed as part of a pair\n\n        obj = isolated_red_objects_data[i]\n        r1, c1, r2, c2 = obj[\"bbox\"]\n\n        # Draw blue rectangle to the left of the object's bounding box\n        left_rect_coords = set()\n        if c1 > 0: # Only draw if there's space to the left (column index > 0)\n            for r in range(r1, r2 + 1): # Iterate through rows of the bounding box\n                for c in range(0, c1):   # Iterate through columns from 0 up to (but not including) c1\n                    left_rect_coords.add((r, c))\n            draw_pixels(output_grid, left_rect_coords, blue_color)\n\n        # Mark as processed (technically redundant here, but good practice)\n        processed_indices.add(i)\n\n    # 7. Return the final modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6746,
    "candidates_token_count": 4287,
    "total_token_count": 11033,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.45891,
  "retries": null
}