{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\ntry:\n    # skimage is used for finding connected components (objects)\n    from skimage import measure\n    SKIMAGE_AVAILABLE = True\nexcept ImportError:\n    # Fallback if skimage is not available\n    SKIMAGE_AVAILABLE = False\n    # Basic BFS implementation for connected components as a fallback\n    def bfs_find_objects(grid, color, connectivity=8):\n        \"\"\"\n        Finds connected objects of a specific color using Breadth-First Search.\n        connectivity=8 means 8-way connection (includes diagonals).\n        Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n        \"\"\"\n        objects = []\n        height, width = grid.shape\n        visited = np.zeros((height, width), dtype=bool)\n        \n        for r in range(height):\n            for c in range(width):\n                if grid[r, c] == color and not visited[r, c]:\n                    obj_coords = set()\n                    q = [(r, c)]\n                    visited[r, c] = True\n                    obj_coords.add((r, c))\n                    \n                    while q:\n                        row, col = q.pop(0)\n                        \n                        # Define neighbors based on connectivity\n                        if connectivity == 8:\n                            neighbor_deltas = [(-1, -1), (-1, 0), (-1, 1),\n                                               (0, -1),          (0, 1),\n                                               (1, -1), (1, 0), (1, 1)]\n                        else: # connectivity = 4 (default)\n                             neighbor_deltas = [(-1, 0), (0, -1), (0, 1), (1, 0)]\n\n                        for dr, dc in neighbor_deltas:\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds, color, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n                                \n                    if obj_coords:\n                        objects.append(obj_coords)\n        return objects\n    \n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color. Uses skimage if available,\n    otherwise uses a basic BFS implementation.\n    Connectivity is 8-way (including diagonals).\n    Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n    \"\"\"\n    if SKIMAGE_AVAILABLE:\n        objects = []\n        mask = (grid == color)\n        # connectivity=2 means 8-way connection (includes diagonals)\n        labeled_grid, num_labels = measure.label(mask, connectivity=2, background=0, return_num=True)\n        for i in range(1, num_labels + 1):\n            coords = np.argwhere(labeled_grid == i)\n            # Convert to set of tuples for easier handling and lookup\n            objects.append(set(tuple(coord) for coord in coords))\n        return objects\n    else:\n        # Use BFS fallback if skimage is not present\n        # print(\"Warning: scikit-image not found. Using BFS for object detection.\") # Optional warning\n        return bfs_find_objects(grid, color, connectivity=8)\n\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the inclusive bounding box (min_row, min_col, max_row, max_col)\n    for a set of object coordinates.\n    Returns None if the object coordinates set is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_shape_size(obj_coords):\n    \"\"\"\n    Gets the size (height, width) of an object based on its bounding box.\n    Returns (0, 0) if the object coordinates set is empty.\n    \"\"\"\n    bbox = get_bounding_box(obj_coords)\n    if not bbox:\n        return 0, 0\n    r1, c1, r2, c2 = bbox\n    return r2 - r1 + 1, c2 - c1 + 1\n\ndef get_neighbors(r, c, shape):\n    \"\"\" Gets 8-way neighbors for a coordinate within grid shape. \"\"\"\n    neighbors = set()\n    h, w = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w: # Check bounds\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef is_isolated(grid, red_obj_coords, blue_coords_flat):\n    \"\"\"\n    Checks if a red object (given by its coordinates) is isolated, meaning\n    none of its pixels are adjacent (8-way) to any blue pixel coordinates\n    provided in blue_coords_flat.\n    \"\"\"\n    grid_shape = grid.shape\n    for r, c in red_obj_coords:\n        # Check all 8 neighbors of the current red pixel\n        pixel_neighbors = get_neighbors(r, c, grid_shape)\n        # Check if any neighbor coordinate is in the set of blue coordinates\n        if not pixel_neighbors.isdisjoint(blue_coords_flat):\n            return False # Found adjacent blue pixel, so not isolated\n    return True # No adjacent blue pixels found for any pixel in the red object\n\ndef draw_pixels(grid, coords_to_draw, color):\n    \"\"\"\n    Draws pixels onto the grid at the specified coordinates with the given color.\n    Checks boundaries to avoid errors.\n    \"\"\"\n    height, width = grid.shape\n    for r, c in coords_to_draw:\n        # Ensure coordinates are within the grid boundaries\n        if 0 <= r < height and 0 <= c < width:\n            grid[r, c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transformation Rule:\n    1. Identify red (2) objects and blue (1) pixels in the input.\n    2. Filter red objects to find 'isolated' ones (not 8-way adjacent to any input blue pixel).\n    3. Sort isolated red objects by top-left corner (row, then column).\n    4. Process specific pairs of isolated red objects first:\n        a. Vertical Pair (1x1 pixels, same column 'c', rows 'r1' and 'r1+3'):\n           Draw two blue T-shapes below each pixel.\n        b. Horizontal Pair (2x2 squares, same rows 'r, r+1', columns 'c1' and 'c2' with c2 > c1+1):\n           Draw a blue connector between them, a 2x2 square below the connector, and a wider rectangle below the square.\n    5. Process any remaining (unpaired) isolated red objects:\n        a. If the object's leftmost column 'c1' > 0, draw a blue rectangle from column 0 to c1-1 covering the object's rows.\n    6. Return the modified grid.\n    \"\"\"\n    # 1. Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    blue_color = 1 # Define color constants\n    red_color = 2\n\n    # 2. Identify all red and blue objects/pixels\n    red_objects = find_objects(input_grid, red_color)\n    blue_objects = find_objects(input_grid, blue_color) # Used to find coordinates\n\n    # Create a flat set of all input blue coordinates for efficient adjacency checking\n    blue_coords_flat = set()\n    for b_obj in blue_objects:\n        blue_coords_flat.update(b_obj)\n    # Also add single blue pixels if find_objects missed them (e.g., if no blue objects found)\n    if not blue_coords_flat:\n         blue_coords_flat.update(tuple(coord) for coord in np.argwhere(input_grid == blue_color))\n\n\n    # 3. Determine which red objects are isolated\n    isolated_red_objects_data = []\n    for r_obj_coords in red_objects:\n        if is_isolated(input_grid, r_obj_coords, blue_coords_flat):\n            bbox = get_bounding_box(r_obj_coords)\n            if bbox: # Ensure object is valid\n                 isolated_red_objects_data.append({\n                    \"coords\": r_obj_coords,\n                    \"bbox\": bbox,\n                    \"shape_size\": get_shape_size(r_obj_coords)\n                })\n\n    # 4. Sort isolated red objects by top-left corner (row, then column)\n    isolated_red_objects_data.sort(key=lambda x: (x[\"bbox\"][0], x[\"bbox\"][1]))\n\n    # Keep track of processed objects (by index in the sorted list)\n    processed_indices = set()\n    num_isolated = len(isolated_red_objects_data)\n\n    # 5. Process pairs first\n    # 5a. Process Vertical 1x1 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects_data[i]\n        # Check if it's a 1x1 pixel\n        if obj1[\"shape_size\"] == (1, 1):\n            r1, c1, _, _ = obj1[\"bbox\"]\n            # Search for a potential pair starting from the next object\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects_data[j]\n                if obj2[\"shape_size\"] == (1, 1):\n                    r2, c2, _, _ = obj2[\"bbox\"]\n                    # Check for vertical alignment (same column, 3 rows apart)\n                    if c1 == c2 and r2 == r1 + 3:\n                        # Found a vertical 1x1 pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # Draw T-shape below obj1\n                        t1_coords = set()\n                        # Horizontal bar: (r1+1, c1-1), (r1+1, c1), (r1+1, c1+1)\n                        # Vertical stem: (r1+2, c1)\n                        t1_coords.add((r1 + 1, c1 - 1))\n                        t1_coords.add((r1 + 1, c1))\n                        t1_coords.add((r1 + 1, c1 + 1))\n                        t1_coords.add((r1 + 2, c1))\n                        draw_pixels(output_grid, t1_coords, blue_color)\n\n                        # Draw T-shape below obj2\n                        t2_coords = set()\n                        # Horizontal bar: (r2+1, c2-1), (r2+1, c2), (r2+1, c2+1)\n                        # Vertical stem: (r2+2, c2)\n                        t2_coords.add((r2 + 1, c1 - 1)) # use c1 since c1==c2\n                        t2_coords.add((r2 + 1, c1))\n                        t2_coords.add((r2 + 1, c1 + 1))\n                        t2_coords.add((r2 + 2, c1))\n                        draw_pixels(output_grid, t2_coords, blue_color)\n\n                        # Break inner loop once obj1 is paired\n                        break # Found pair for obj1, move to next i\n\n    # 5b. Process Horizontal 2x2 Pairs\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue\n        obj1 = isolated_red_objects_data[i]\n        # Check if it's a 2x2 square\n        if obj1[\"shape_size\"] == (2, 2) and len(obj1[\"coords\"]) == 4: # Ensure it's exactly 2x2\n            r1_start, c1_start, r1_end, c1_end = obj1[\"bbox\"] # r1_end=r1_start+1, c1_end=c1_start+1\n            # Search for a potential pair starting from the next object\n            for j in range(i + 1, num_isolated):\n                if j in processed_indices:\n                    continue\n                obj2 = isolated_red_objects_data[j]\n                if obj2[\"shape_size\"] == (2, 2) and len(obj2[\"coords\"]) == 4: # Ensure it's exactly 2x2\n                    r2_start, c2_start, r2_end, c2_end = obj2[\"bbox\"] # r2_end=r2_start+1, c2_end=c2_start+1\n                    # Check for horizontal alignment (same rows, obj2 is to the right with a gap)\n                    # c2_start must be at least c1_start+3 (c1_end+2)\n                    if r1_start == r2_start and c2_start > c1_end + 1:\n                        # Found a horizontal 2x2 pair\n                        processed_indices.add(i)\n                        processed_indices.add(j)\n\n                        # i. Draw connector rectangle (rows r1_start to r1_end, cols c1_end+1 to c2_start-1)\n                        conn_col_start = c1_end + 1\n                        conn_col_end = c2_start - 1\n                        connector_coords = set()\n                        for r in range(r1_start, r1_end + 1):\n                            for c in range(conn_col_start, conn_col_end + 1):\n                                connector_coords.add((r, c))\n                        draw_pixels(output_grid, connector_coords, blue_color)\n\n                        # ii. Draw 2x2 square below connector\n                        conn_width = conn_col_end - conn_col_start + 1\n                        if conn_width >= 0: # Should always be true if c2_start > c1_end+1\n                            # Calculate top-left corner of the 2x2 square\n                            # Centered below the connector\n                            # square_start_col = conn_col_start + math.floor((conn_width - 2) / 2) This was causing issues, let's rethink\n                            # Midpoint column index of connector (approx): conn_col_start + (conn_width-1)/2\n                            # We want the 2x2 square's columns sc, sc+1 to be centered around this midpoint.\n                            # Start col for 2x2: floor(Midpoint - 0.5) = floor(conn_col_start + (conn_width-1)/2 - 0.5)\n                            # floor(conn_col_start + conn_width/2 - 1)\n                            # Let's test example 2: c1_start=3, c1_end=4. c2_start=9, c2_end=10.\n                            # conn_col_start = 5. conn_col_end = 8. conn_width = 4.\n                            # Midpoint = 5 + (4-1)/2 = 6.5\n                            # square_start_col = floor(6.5 - 0.5) = 6. Correct square cols: 6, 7.\n                            square_start_col = conn_col_start + math.floor(conn_width / 2) -1 # Adjusted calculation seems correct\n\n                            square_start_row = r1_start + 2\n                            square_coords = set()\n                            for r in range(square_start_row, square_start_row + 2):\n                                for c in range(square_start_col, square_start_col + 2):\n                                     square_coords.add((r,c))\n                            draw_pixels(output_grid, square_coords, blue_color)\n\n                        # iii. Draw bottom rectangle below square structure\n                        # Rows r1_start+4 to r1_start+5 (height 2)\n                        # Cols c1_end+1 to c2_end (conn_col_start to c2_end)\n                        bottom_rect_start_row = r1_start + 4\n                        bottom_rect_coords = set()\n                        for r in range(bottom_rect_start_row, bottom_rect_start_row + 2):\n                             for c in range(conn_col_start, c2_end + 1): # Columns span under connector AND obj2\n                                bottom_rect_coords.add((r,c))\n                        draw_pixels(output_grid, bottom_rect_coords, blue_color)\n\n                        # Break inner loop once obj1 is paired\n                        break # Found pair for obj1, move to next i\n\n    # 6. Process Single Isolated Objects (those not part of pairs)\n    for i in range(num_isolated):\n        if i in processed_indices:\n            continue # Skip objects already processed as part of a pair\n\n        obj = isolated_red_objects_data[i]\n        r1, c1, r2, c2 = obj[\"bbox\"]\n\n        # Draw blue rectangle to the left of the object's bounding box\n        left_rect_coords = set()\n        if c1 > 0: # Only draw if there's space to the left (column index > 0)\n            for r in range(r1, r2 + 1): # Iterate through rows of the bounding box\n                for c in range(0, c1):   # Iterate through columns from 0 up to (but not including) c1\n                    left_rect_coords.add((r, c))\n            draw_pixels(output_grid, left_rect_coords, blue_color)\n\n        # No need to mark as processed here, as we only iterate once more\n\n    # 7. Return the final modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15237,
    "candidates_token_count": 4342,
    "total_token_count": 19579,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.923983,
  "retries": null
}