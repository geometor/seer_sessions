{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n# -*- coding: utf-8 -*-\n\"\"\"\nTransformation Rule:\n1. Identify red (2) objects and blue (1) pixels in the input grid.\n2. Filter red objects to find 'isolated' ones, defined as red objects where none of their constituent pixels are 8-way adjacent to any blue pixel from the input grid.\n3. Sort the isolated red objects based on their top-left bounding box corner (first by row, then by column).\n4. Process pairs of isolated red objects first, marking them as processed to avoid single-object processing later:\n    a. Vertical Pair: Search for two isolated 1x1 red objects located at (r1, c) and (r2, c) where r2 = r1 + 3. If found, draw *one* blue T-shape below the *top* pixel (r1, c). The T-shape consists of pixels (r1+1, c-1), (r1+1, c), (r1+1, c+1) and (r1+2, c). Mark both red objects in the pair as processed. Check for pairs exhaustively among the sorted isolated objects.\n    b. Horizontal Pair: Search for two isolated 2x2 red objects whose bounding boxes are (r_start, c1_start, r_start+1, c1_start+1) and (r_start, c2_start, r_start+1, c2_start+1), where c2_start > c1_start + 2 (meaning there's a horizontal gap between them). If found:\n        i. Draw a blue connector rectangle filling the gap between them: rows r_start to r_start+1, columns (c1_start+1)+1 to c2_start-1.\n        ii. Draw a blue 2x2 square below the connector, centered horizontally. Its top-left corner is at row r_start+2 and column `conn_col_end - 1` (where `conn_col_end` is the last column of the connector).\n        iii. Draw a blue rectangle below the square structure: rows r_start+4 to r_start+5, columns spanning from the start of the connector (c1_start+2) to the end of the second red object (c2_start+1).\n        Mark both red objects in the pair as processed. Check for pairs exhaustively among the sorted isolated objects.\n5. Process any remaining isolated red objects (those not part of a processed pair):\n    a. If the object's leftmost bounding box column `c1` is greater than 0, draw a blue rectangle covering all rows of the object's bounding box (from `r1` to `r2`) and columns from 0 up to (but not including) `c1`.\n6. The background (0) and non-isolated red/blue pixels remain unchanged unless overwritten by the drawing steps. Return the modified grid.\n\"\"\"\n\nimport numpy as np\nimport math\n\ntry:\n    # skimage is used for finding connected components (objects)\n    from skimage import measure\n    SKIMAGE_AVAILABLE = True\nexcept ImportError:\n    # Fallback if skimage is not available\n    SKIMAGE_AVAILABLE = False\n    # Basic BFS implementation for connected components as a fallback\n    def bfs_find_objects(grid, color, connectivity=8):\n        \"\"\"\n        Finds connected objects of a specific color using Breadth-First Search.\n        connectivity=8 means 8-way connection (includes diagonals).\n        Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n        \"\"\"\n        objects = []\n        height, width = grid.shape\n        visited = np.zeros((height, width), dtype=bool)\n\n        for r in range(height):\n            for c in range(width):\n                if grid[r, c] == color and not visited[r, c]:\n                    obj_coords = set()\n                    q = [(r, c)]\n                    visited[r, c] = True\n                    obj_coords.add((r, c))\n\n                    while q:\n                        row, col = q.pop(0)\n\n                        # Define neighbors based on connectivity\n                        if connectivity == 8:\n                            neighbor_deltas = [(-1, -1), (-1, 0), (-1, 1),\n                                               (0, -1),          (0, 1),\n                                               (1, -1), (1, 0), (1, 1)]\n                        else: # connectivity = 4\n                             neighbor_deltas = [(-1, 0), (0, -1), (0, 1), (1, 0)]\n\n                        for dr, dc in neighbor_deltas:\n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds, color, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n\n                    if obj_coords:\n                        objects.append(obj_coords)\n        return objects\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color. Uses skimage if available,\n    otherwise uses a basic BFS implementation.\n    Connectivity is 8-way (including diagonals).\n    Returns a list of sets, where each set contains the (row, col) coordinates of an object.\n    \"\"\"\n    if SKIMAGE_AVAILABLE:\n        objects = []\n        mask = (grid == color)\n        # connectivity=2 means 8-way connection (includes diagonals)\n        labeled_grid, num_labels = measure.label(mask, connectivity=2, background=0, return_num=True)\n        for i in range(1, num_labels + 1):\n            coords = np.argwhere(labeled_grid == i)\n            # Convert to set of tuples for easier handling and lookup\n            objects.append(set(tuple(coord) for coord in coords))\n        return objects\n    else:\n        # Use BFS fallback if skimage is not present\n        return bfs_find_objects(grid, color, connectivity=8)\n\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the inclusive bounding box (min_row, min_col, max_row, max_col)\n    for a set of object coordinates.\n    Returns None if the object coordinates set is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_shape_size(obj_coords):\n    \"\"\"\n    Gets the size (height, width) of an object based on its bounding box.\n    Returns (0, 0) if the object coordinates set is empty.\n    \"\"\"\n    bbox = get_bounding_box(obj_coords)\n    if not bbox:\n        return 0, 0\n    r1, c1, r2, c2 = bbox\n    return r2 - r1 + 1, c2 - c1 + 1\n\ndef get_neighbors(r, c, shape):\n    \"\"\" Gets 8-way neighbors for a coordinate within grid shape. \"\"\"\n    neighbors = set()\n    h, w = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w: # Check bounds\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef is_isolated(grid, red_obj_coords, blue_coords_flat):\n    \"\"\"\n    Checks if a red object (given by its coordinates) is isolated, meaning\n    none of its pixels are adjacent (8-way) to any blue pixel coordinates\n    provided in blue_coords_flat.\n    \"\"\"\n    grid_shape = grid.shape\n    for r, c in red_obj_coords:\n        # Check all 8 neighbors of the current red pixel\n        pixel_neighbors = get_neighbors(r, c, grid_shape)\n        # Check if any neighbor coordinate is in the set of blue coordinates\n        if not pixel_neighbors.isdisjoint(blue_coords_flat):\n            return False # Found adjacent blue pixel, so not isolated\n    return True # No adjacent blue pixels found for any pixel in the red object\n\ndef draw_pixels(grid, coords_to_draw, color):\n    \"\"\"\n    Draws pixels onto the grid at the specified coordinates with the given color.\n    Checks boundaries to avoid errors.\n    \"\"\"\n    height, width = grid.shape\n    for r, c in coords_to_draw:\n        # Ensure coordinates are within the grid boundaries\n        if 0 <= r < height and 0 <= c < width:\n            grid[r, c] = color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    blue_color = 1 # Define color constants\n    red_color = 2\n\n    # Identify all red and blue objects/pixels\n    red_objects = find_objects(input_grid, red_color)\n    blue_objects = find_objects(input_grid, blue_color)\n\n    # Create a flat set of all input blue coordinates for efficient adjacency checking\n    blue_coords_flat = set()\n    for b_obj in blue_objects:\n        blue_coords_flat.update(b_obj)\n    # Add single blue pixels if find_objects missed them (e.g., singletons)\n    blue_coords_flat.update(tuple(coord) for coord in np.argwhere(input_grid == blue_color))\n\n\n    # Determine which red objects are isolated\n    isolated_red_objects_data = []\n    for r_obj_coords in red_objects:\n        if is_isolated(input_grid, r_obj_coords, blue_coords_flat):\n            bbox = get_bounding_box(r_obj_coords)\n            if bbox: # Ensure object is valid\n                 isolated_red_objects_data.append({\n                    \"coords\": r_obj_coords,\n                    \"bbox\": bbox,\n                    \"shape_size\": get_shape_size(r_obj_coords)\n                })\n\n    # Sort isolated red objects by top-left corner (row, then column)\n    isolated_red_"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8641,
    "candidates_token_count": 2463,
    "total_token_count": 11104,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 215.551651,
  "retries": null
}