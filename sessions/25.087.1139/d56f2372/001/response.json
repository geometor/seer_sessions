{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the object in the input grid that contains internal holes \n(white pixels completely surrounded by the object's pixels) and extracts \nthis object into the output grid, cropped to its minimal bounding box.\nAssumes exactly one such object exists.\n\"\"\"\n\n# Helper function to find connected components (objects) based on color\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-white colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white (not 0) and not visited yet, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object\n                objects.append({'color': color, 'coords': coords})\n                \n    return objects\n\n# Helper function to calculate the bounding box of a set of coordinates\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimum and maximum row and column indices for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return min_r, min_c, max_r, max_c\n\n# Helper function to check if an object contains internal holes\ndef has_holes(grid, obj_coords):\n    \"\"\"\n    Checks if an object encloses any white pixels (value 0).\n    It works by flood-filling the background (white pixels) starting from the grid borders.\n    Any white pixel not reached by this fill is considered enclosed.\n    It then checks if any of these enclosed white pixels are adjacent to the object.\n\n    Args:\n        grid (np.array): The input grid.\n        obj_coords (set): The coordinates {(row, col), ...} of the object being checked.\n\n    Returns:\n        bool: True if the object encloses at least one white pixel, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    \n    # 1. Perform flood fill (BFS) from background (white pixels on the border)\n    # visited_background tracks white pixels reachable from the outside.\n    visited_background = np.zeros_like(grid, dtype=bool)\n    q = deque()\n    \n    # Initialize queue with all white border pixels\n    for r in range(height):\n        if grid[r, 0] == 0 and not visited_background[r, 0]:\n            visited_background[r, 0] = True\n            q.append((r, 0))\n        if grid[r, width - 1] == 0 and not visited_background[r, width - 1]:\n             visited_background[r, width - 1] = True\n             q.append((r, width - 1))\n    for c in range(1, width - 1): # Avoid checking corners twice\n        if grid[0, c] == 0 and not visited_background[0, c]:\n            visited_background[0, c] = True\n            q.append((0, c))\n        if grid[height - 1, c] == 0 and not visited_background[height - 1, c]:\n             visited_background[height - 1, c] = True\n             q.append((height - 1, c))\n\n    # BFS traversal for background white pixels\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if it's white, and if not already visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and not visited_background[nr, nc]:\n                visited_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # 2. Find enclosed white pixels (white pixels not visited by the background fill)\n    enclosed_white_coords = set()\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 0 and not visited_background[r, c]:\n                enclosed_white_coords.add((r,c))\n\n    if not enclosed_white_coords:\n        return False # No enclosed white pixels anywhere in the grid\n\n    # 3. Check if any of these enclosed white pixels are adjacent to *this* object\n    for r_enclosed, c_enclosed in enclosed_white_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_enclosed + dr, c_enclosed + dc\n            # Check if the neighbor coordinate belongs to the object\n            if (nr, nc) in obj_coords: \n                 # Found an enclosed white pixel adjacent to this object\n                 return True \n\n    # If no enclosed white pixel was found adjacent to this object's coordinates\n    return False\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Identifies the object in the input grid that contains internal holes \n    (white pixels completely surrounded by the object's pixels) and extracts \n    this object into the output grid, cropped to its minimal bounding box.\n    Assumes exactly one such object exists based on training examples.\n\n    Args:\n        input_grid_list (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the extracted object within its bounding box, \n              or an empty list if no suitable object is found (unexpected case).\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    \n    # Step 1: Find all distinct colored objects in the grid\n    objects = find_objects(input_grid)\n    \n    # Step 2: Identify the object that has internal holes\n    target_object = None\n    for obj in objects:\n        # Check if the object encloses any white pixels using the helper function\n        if has_holes(input_grid, obj['coords']):\n            target_object = obj\n            # Assumption: Only one object will satisfy the condition per the examples\n            break \n            \n    # Step 3: Handle the case where no target object is found (error or unexpected input)\n    if target_object is None:\n        print(\"Warning: No object with holes found. Returning empty grid.\")\n        return [] \n\n    # Step 4: Determine the bounding box of the identified target object\n    bounding_box = get_bounding_box(target_object['coords'])\n    if bounding_box is None: # Should not happen if target_object is not None\n         print(\"Warning: Found object but failed to get bounding box. Returning empty grid.\")\n         return []\n    min_r, min_c, max_r, max_c = bounding_box\n    \n    # Step 5: Extract the subgrid corresponding to the bounding box from the input grid\n    # NumPy slicing is [start_row:end_row+1, start_col:end_col+1]\n    output_grid_np = input_grid[min_r:max_r+1, min_c:max_c+1]\n    \n    # Step 6: Convert the resulting NumPy array back to a list of lists for the output\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4130,
    "candidates_token_count": 2131,
    "total_token_count": 6261,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.83391,
  "retries": null
}