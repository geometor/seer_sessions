{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRecolors azure (8) objects in a grid based on their count (N), sort order (top-left, row-major), and the grid's height (H).\n\n1. Find all distinct contiguous objects of azure (8) pixels using 4-way connectivity.\n2. Count the total number of objects (N).\n3. Sort the objects based on their top-most, left-most pixel (row-major order).\n4. Determine the height (H) of the input grid.\n5. Determine the color sequence based on N and H:\n   - If N = 3: sequence = [Blue(1), Blue(1), Green(3)]\n   - If N = 4 and H < 15: sequence = [Red(2), Blue(1), Green(3), Blue(1)]\n   - If N = 4 and H >= 15: sequence = [Yellow(4), Green(3), Red(2), Blue(1)]\n6. Replace the azure (8) pixels of the k-th sorted object with the k-th color from the determined sequence.\n7. Keep the background white (0) pixels unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              'coords': A list of (row, col) tuples for the object's pixels.\n              'top_left': A tuple (row, col) for the top-most, left-most pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                current_object_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Initialize top-left for this object\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.append((row, col))\n\n                    # Update object's top-left coordinate during BFS\n                    if row < min_r:\n                        min_r, min_c = row, col\n                    elif row == min_r and col < min_c:\n                        min_c = col\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if current_object_coords:\n                    objects.append({\n                        'coords': current_object_coords,\n                        'top_left': (min_r, min_c)\n                    })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding azure objects, sorting them,\n    and recoloring them based on their count and grid height.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Start with a copy to preserve background\n\n    # Define the target color (azure)\n    target_color = 8\n    grid_height = grid.shape[0] # Get grid height (H)\n\n    # 1. Identify all distinct contiguous azure objects and their top-left point\n    objects_data = find_objects(grid, target_color)\n    num_objects = len(objects_data) # 2. Count objects (N)\n\n    # If no objects found, return the original grid\n    if num_objects == 0:\n        return input_grid # Or output_grid.tolist()\n\n    # 3. Sort the objects based on their top-left coordinate (row-major)\n    sorted_objects_data = sorted(objects_data, key=lambda x: (x['top_left'][0], x['top_left'][1]))\n\n    # 4. & 5. Determine the color sequence based on N and grid height (H)\n    color_sequence = []\n    if num_objects == 3:\n        # [Blue, Blue, Green]\n        color_sequence = [1, 1, 3]\n    elif num_objects == 4:\n        if grid_height < 15:\n            # [Red, Blue, Green, Blue]\n            color_sequence = [2, 1, 3, 1]\n        else: # grid_height >= 15\n            # [Yellow, Green, Red, Blue]\n            color_sequence = [4, 3, 2, 1]\n    else:\n        # Handle unexpected number of objects - return original grid?\n        # Based on the examples, only N=3 and N=4 are expected.\n        # Returning the original grid in this case.\n        print(f\"Warning: Unexpected number of objects ({num_objects}). Expected 3 or 4. Returning original grid.\")\n        return input_grid\n\n    # 6. & 8. Recolor the objects in the output grid\n    for i, obj_data in enumerate(sorted_objects_data):\n        if i < len(color_sequence): # Safety check\n            color_to_apply = color_sequence[i]\n            for r, c in obj_data['coords']:\n                output_grid[r, c] = color_to_apply\n        else:\n            # Should not happen if logic above is correct, but good practice\n            print(f\"Warning: More objects found than colors in sequence for N={num_objects}.\")\n            break # Stop coloring if sequence runs out\n\n    # 7. Background pixels (0) are already preserved from the initial copy.\n\n    # 10. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18120,
    "candidates_token_count": 1506,
    "total_token_count": 19626,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.172671,
  "retries": null
}