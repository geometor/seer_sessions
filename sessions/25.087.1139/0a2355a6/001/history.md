
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 8 8 8 8 8 0 0 8 0 8 0 0
0 0 8 0 0 0 8 0 0 8 8 8 0 0
0 0 8 8 8 8 8 0 0 8 0 8 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0
0 0 0 8 8 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 8 8 0 8 0 0 8 8 8 0
0 0 0 0 0 8 8 8 0 0 8 0 8 0
0 0 0 0 0 0 0 0 0 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 1 1 1 1 1 0 0 2 0 2 0 0
0 0 1 0 0 0 1 0 0 2 2 2 0 0
0 0 1 1 1 1 1 0 0 2 0 2 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0
0 0 0 3 3 3 0 3 0 0 1 1 1 0
0 0 0 0 0 3 3 3 0 0 1 0 1 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 8 0 8 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 8 0 0 0 8 8 8
0 0 8 0 8 0 0 0 8 0 8
0 0 8 8 8 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 0 0 0 0 0 0 0
8 0 8 0 0 0 8 8 8 8 0
8 8 8 8 8 0 8 0 0 8 0
8 0 0 0 8 0 8 0 0 8 0
8 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0
0 0 2 0 2 0 2 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0
0 0 2 0 2 0 0 0 1 1 1
0 0 2 0 2 0 0 0 1 0 1
0 0 2 2 2 0 0 0 1 1 1
0 0 0 0 0 0 0 0 0 0 0
3 3 3 0 0 0 0 0 0 0 0
3 0 3 0 0 0 1 1 1 1 0
3 3 3 3 3 0 1 0 0 1 0
3 0 0 0 3 0 1 0 0 1 0
3 3 3 3 3 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 8 8 8 0 0 0 0 0 0 0 0 0
0 0 8 0 8 8 8 8 8 8 8 8 0 0
0 0 8 8 8 0 8 0 0 8 0 8 0 0
0 0 0 0 8 8 8 8 8 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 0 0 0 8 8 8 8 0
0 8 0 0 8 0 0 0 0 8 0 0 8 0
0 8 8 8 8 0 0 0 0 8 0 0 8 0
0 8 0 0 8 0 0 0 8 8 8 8 8 0
0 8 8 8 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 0 0
0 0 8 8 8 0 0 0 8 0 0 8 0 0
0 0 8 0 8 0 0 0 8 8 8 8 0 0
0 0 8 8 8 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 4 4 4 0 0 0 0 0 0 0 0 0
0 0 4 0 4 4 4 4 4 4 4 4 0 0
0 0 4 4 4 0 4 0 0 4 0 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 0 0 0 0 2 2 2 2 0
0 3 0 0 3 0 0 0 0 2 0 0 2 0
0 3 3 3 3 0 0 0 0 2 0 0 2 0
0 3 0 0 3 0 0 0 2 2 2 2 2 0
0 3 3 3 3 0 0 0 2 0 2 0 0 0
0 0 0 0 0 0 0 0 2 2 2 2 0 0
0 0 1 1 1 0 0 0 2 0 0 2 0 0
0 0 1 0 1 0 0 0 2 2 2 2 0 0
0 0 1 1 1 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 8 0 0 8
0 0 8 8 8 0 0 8 8 8 8
0 0 8 0 8 0 0 0 0 0 0
0 0 8 8 8 0 8 8 8 0 0
0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 8 8 8 0 0
```


**output:**
```
0 0 0 0 0 0 0 1 1 1 1
0 0 0 0 0 0 0 1 0 0 1
0 0 1 1 1 0 0 1 1 1 1
0 0 1 0 1 0 0 0 0 0 0
0 0 1 1 1 0 3 3 3 0 0
0 0 0 0 0 0 3 0 3 0 0
0 0 0 0 0 0 3 3 3 0 0
0 0 0 0 0 0 3 0 3 0 0
0 0 0 0 0 0 3 3 3 0 0
```

## Perception

The task involves identifying distinct objects composed of azure (8) pixels within an input grid. These objects retain their shape and relative position in the output grid but change color. The background remains white (0). The transformation rule appears to depend on the *number* of distinct azure objects found in the input and their *spatial order*.

1.  **Object Identification**: The first step is to find all contiguous groups of azure (8) pixels. Each such group constitutes a distinct object.
2.  **Object Ordering**: The identified objects need to be sorted. The examples suggest sorting based on the top-most, then left-most pixel of each object's bounding box (or simply the first pixel encountered in a top-to-bottom, left-to-right scan).
3.  **Color Assignment**: A specific sequence of colors (blue=1, red=2, green=3, yellow=4) is assigned to the sorted objects. The exact sequence depends on the total number (N) of objects found.
    *   If N=3, the sequence is [Blue(1), Blue(1), Green(3)].
    *   If N=4, the sequence is [Red(2), Blue(1), Green(3), Blue(1)].
    *   If N=5, the sequence is [Yellow(4), Yellow(4), Green(3), Red(2), Blue(1)].
4.  **Output Generation**: The output grid is created by replacing the azure (8) pixels of each identified object with the color assigned to it based on its position in the sorted order and the N-dependent color sequence.

## Facts


```yaml
Input:
  grid_elements:
    - type: pixel
      color: white (0)
      role: background
    - type: pixel
      color: azure (8)
      role: object_component
  objects:
    - type: contiguous_group
      description: Shapes formed by connected azure (8) pixels.
      properties:
        - shape
        - position (defined by top-left coordinate)
        - count (N)

Output:
  grid_elements:
    - type: pixel
      color: white (0)
      role: background
    - type: pixel
      colors: [blue (1), red (2), green (3), yellow (4)]
      role: object_component
  objects:
    - type: contiguous_group
      description: Shapes identical to input objects but with new colors.
      properties:
        - shape (preserved from input)
        - position (preserved from input)
        - color (determined by rule)

Transformation:
  action: identify_objects
  input: input_grid
  criteria: contiguous azure (8) pixels
  output: list_of_objects (N objects)

  action: sort_objects
  input: list_of_objects
  criteria: top-left coordinate (row first, then column)
  output: sorted_list_of_objects

  action: determine_color_sequence
  input: N (count of objects)
  output: color_sequence (list of N colors)
  rule:
    - N=3 -> [1, 1, 3]
    - N=4 -> [2, 1, 3, 1]
    - N=5 -> [4, 4, 3, 2, 1]
    - Note: The specific colors are Blue(1), Red(2), Green(3), Yellow(4).

  action: recolor_objects
  input: sorted_list_of_objects, color_sequence
  process: Assign the k-th color from color_sequence to the k-th object in sorted_list_of_objects.
  output: output_grid (where each object's azure pixels are replaced by its assigned color)

Relationships:
  - Each azure object in the input maps uniquely to a colored object in the output.
  - The shape and position of objects are preserved.
  - The color assigned to an object depends on the total number of objects (N) and the object's rank in the sorted order.
```


## Natural Language Program

1.  Identify all distinct contiguous objects composed of azure (8) pixels in the input grid. Count the total number of objects found, let this be N.
2.  For each object, determine its top-most, left-most coordinate (the minimum row index, and for that row, the minimum column index containing an azure pixel of that object).
3.  Sort the objects based on their top-left coordinates, primarily by row index (ascending) and secondarily by column index (ascending).
4.  Determine the sequence of colors to assign based on the total number of objects (N):
    *   If N = 3, the color sequence is [Blue, Blue, Green].
    *   If N = 4, the color sequence is [Red, Blue, Green, Blue].
    *   If N = 5, the color sequence is [Yellow, Yellow, Green, Red, Blue].
    *   (Assuming the colors map as Blue=1, Red=2, Green=3, Yellow=4).
5.  Create the output grid, initially identical to the input grid.
6.  Iterate through the sorted objects from 1 to N. For the k-th object in the sorted list, replace all its azure (8) pixels in the output grid with the k-th color from the determined color sequence.
7.  Keep all original white (0) pixels unchanged.
8.  Return the final modified grid as the output.
