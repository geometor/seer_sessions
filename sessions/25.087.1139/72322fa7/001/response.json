{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom copy import deepcopy\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as an identical copy of the input grid.\n2. Identify all distinct \"source patterns\" present in the input grid. A source pattern is a small, recognizable motif like `X C X` (horizontal or vertical) or a plus shape centered on `C` with arms `X`, where `C` and `X` are non-white colors. Note the central color `C` and the structural/flanking color `X` for each source pattern. The known source patterns are:\n    - Horizontal `4 8 4` (Yellow-Azure-Yellow): C=8, X=4\n    - Vertical `1 3 1` (Blue-Green-Blue): C=3, X=1\n    - Plus shape `8 6 8` (Azure-Magenta-Azure arms/center): C=6, X=8\n    - Horizontal `8 2 8` (Azure-Red-Azure): C=2, X=8\n3. Identify all \"target markers\" in the input grid. A target marker is either:\n    a. An isolated single pixel of color `C`, where `C` matches the central color of at least one identified source pattern. A pixel is isolated if all 8 neighbors are white (0).\n    b. A three-pixel sequence `X 0 X` (either horizontal `[X, 0, X]` or vertical `[[X], [0], [X]]`), where `X` matches the structural/flanking color of at least one identified source pattern. The center of this marker is the location of the white (0) pixel.\n4. For each identified target marker:\n    a. Determine the corresponding source pattern:\n        i. If the marker is an isolated pixel `C`, select the source pattern whose central color is `C`.\n        ii. If the marker is `X 0 X`, select the source pattern whose structural/flanking color is `X`. (Assume only one such source pattern exists for each relevant `C` or `X` in a given input).\n    b. Determine the center location of the target marker (the position of the isolated pixel `C` or the central `0` in `X 0 X`).\n    c. Copy the selected source pattern onto the output grid, centering the pattern at the determined target marker location. Overwrite any existing pixels at the destination.\n5. Return the modified output grid.\n\"\"\"\n\ndef is_valid(r, c, height, width):\n    \"\"\"Checks if coordinates (r, c) are within the grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef find_source_patterns(grid):\n    \"\"\"\n    Identifies all predefined source patterns within the grid.\n\n    Returns:\n        tuple: (patterns_by_center, patterns_by_flank)\n            patterns_by_center (dict): Maps central color C to pattern data.\n            patterns_by_flank (dict): Maps flanking/structural color X to pattern data.\n            pattern_data (dict): Contains 'pattern_rel' (list of (dr, dc, color)), 'C', 'X'.\n    \"\"\"\n    height, width = grid.shape\n    patterns_by_center = {}\n    patterns_by_flank = {}\n    \n    # Define known pattern structures relative to center (0,0)\n    # Format: (C, X, [(dr, dc, expected_color), ...])\n    known_patterns_defs = [\n        (8, 4, [(0, -1, 4), (0, 0, 8), (0, 1, 4)]),  # 4 8 4 horizontal\n        (3, 1, [(-1, 0, 1), (0, 0, 3), (1, 0, 1)]),  # 1 3 1 vertical\n        (6, 8, [(-1, 0, 8), (1, 0, 8), (0, -1, 8), (0, 1, 8), (0, 0, 6)]), # 8 6 8 plus\n        (2, 8, [(0, -1, 8), (0, 0, 2), (0, 1, 8)]),  # 8 2 8 horizontal\n    ]\n\n    # Iterate through potential centers in the grid\n    for r in range(height):\n        for c in range(width):\n            # Check if the current cell could be the center of any known pattern\n            for C, X, pattern_rel in known_patterns_defs:\n                # The center pixel must match the pattern's center color\n                center_pixel_def = next((p for p in pattern_rel if p[0] == 0 and p[1] == 0), None)\n                if center_pixel_def is None or grid[r, c] != center_pixel_def[2]:\n                    continue # Optimization: skip if center pixel doesn't match\n\n                match = True\n                actual_pixels_rel = []\n                for dr, dc, expected_color in pattern_rel:\n                    nr, nc = r + dr, c + dc\n                    # Check if the relative position is valid and has the expected color\n                    if not is_valid(nr, nc, height, width) or grid[nr, nc] != expected_color:\n                        match = False\n                        break\n                    actual_pixels_rel.append((dr, dc, expected_color))\n                \n                # If all parts of the pattern matched\n                if match:\n                    pattern_data = {'pattern_rel': actual_pixels_rel, 'C': C, 'X': X}\n                    # Store the found pattern data, indexed by C and X\n                    # If multiple patterns share C or X, the last one found will overwrite previous ones.\n                    # This seems acceptable based on the problem's examples.\n                    if C is not None:\n                        patterns_by_center[C] = pattern_data\n                    if X is not None:\n                        # Handle the case where X=8 maps to two patterns (plus and horiz).\n                        # The problem seems deterministic; perhaps only one X=8 pattern exists per input,\n                        # or the marker type implicitly disambiguates (though not stated).\n                        # Let's assume the last found for a given X is sufficient or contextually correct.\n                        patterns_by_flank[X] = pattern_data\n                        \n    return patterns_by_center, patterns_by_flank\n\ndef find_target_markers(grid):\n    \"\"\"\n    Identifies target markers (isolated pixels or X 0 X patterns).\n\n    Returns:\n        list: A list of tuples: (marker_type, color, center_r, center_c)\n              marker_type is 'isolated' or 'placeholder'.\n              color is C for isolated, X for placeholder.\n    \"\"\"\n    height, width = grid.shape\n    markers = []\n    \n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            \n            # Check for isolated non-white pixel\n            if color != 0:\n                is_isolated = True\n                # Check all 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = r + dr, c + dc\n                        # If a neighbor is within bounds and not white, it's not isolated\n                        if is_valid(nr, nc, height, width) and grid[nr, nc] != 0:\n                            is_isolated = False\n                            break\n                    if not is_isolated:\n                        break\n                # If all neighbors were checked and none were non-white\n                if is_isolated:\n                    markers.append(('isolated', color, r, c))\n                    # If it's an isolated marker, don't check if it's also a placeholder center\n                    continue \n\n            # Check for placeholder pattern X 0 X centered at (r, c) if current cell is white\n            if color == 0:\n                # Check Horizontal: X 0 X\n                # Check if left and right neighbors are valid, non-white, and equal\n                c_left, c_right = c - 1, c + 1\n                if is_valid(r, c_left, height, width) and is_valid(r, c_right, height, width):\n                    left_color = grid[r, c_left]\n                    right_color = grid[r, c_right]\n                    if left_color != 0 and left_color == right_color:\n                        # Found horizontal placeholder\n                        markers.append(('placeholder', left_color, r, c))\n                        # Prioritize horizontal if both exist? Examples don't show overlap. Let's allow both potential matches.\n                        # No 'continue' here allows checking vertical too, though unlikely relevant based on examples.\n\n                # Check Vertical: X / 0 / X\n                # Check if top and bottom neighbors are valid, non-white, and equal\n                r_top, r_bottom = r - 1, r + 1\n                if is_valid(r_top, c, height, width) and is_valid(r_bottom, c, height, width):\n                    top_color = grid[r_top, c]\n                    bottom_color = grid[r_bottom, c]\n                    if top_color != 0 and top_color == bottom_color:\n                        # Found vertical placeholder\n                        markers.append(('placeholder', top_color, r, c))\n\n    return markers\n\ndef stamp_pattern(grid, center_r, center_c, pattern_rel):\n    \"\"\"Stamps the pattern onto the grid centered at the given coordinates.\"\"\"\n    height, width = grid.shape\n    for dr, dc, color in pattern_rel:\n        r, c = center_r + dr, center_c + dc\n        # Ensure the target pixel is within grid bounds before writing\n        if is_valid(r, c, height, width):\n            grid[r, c] = color\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule: finds source patterns and target markers,\n    then copies the corresponding patterns to the marker locations.\n    \"\"\"\n    # Convert list of lists to numpy array for easier manipulation\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Initialize output grid as a deep copy of the input\n    output_grid = deepcopy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all unique source patterns present in the input grid\n    patterns_by_center, patterns_by_flank = find_source_patterns(input_grid)\n\n    # 2. Find all target markers (isolated pixels or placeholders)\n    markers = find_target_markers(input_grid)\n\n    # 3. For each marker, find the corresponding pattern and stamp it\n    for marker_type, color, center_r, center_c in markers:\n        pattern_data = None\n        # Match marker to pattern based on type and color\n        if marker_type == 'isolated':\n            # Isolated marker color C should match pattern's central color C\n            if color in patterns_by_center:\n                pattern_data = patterns_by_center[color]\n        elif marker_type == 'placeholder':\n            # Placeholder marker color X should match pattern's flanking color X\n            if color in patterns_by_flank:\n                pattern_data = patterns_by_flank[color]\n\n        # If a corresponding pattern was found for the marker\n        if pattern_data:\n            # Stamp the found pattern onto the output grid centered at the marker location\n            stamp_pattern(output_grid, center_r, center_c, pattern_data['pattern_rel'])\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5370,
    "candidates_token_count": 2738,
    "total_token_count": 8108,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 215.720232,
  "retries": null
}