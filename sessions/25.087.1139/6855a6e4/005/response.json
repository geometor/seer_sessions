{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRelocates gray (5) objects into a central gap defined by static red (2) structures.\n\nThe transformation follows these steps:\n\n1.  **Identify Static Structures and Gap:**\n    *   Locate all red (2) pixels. These remain fixed.\n    *   Determine the bounding box of red pixels (`min_r`, `max_r`, `min_c`, `max_c`).\n    *   Search for a contiguous block of empty (white, 0) rows strictly *inside* the vertical span of the red bounding box (`min_r + 1` to `max_r - 1`). If found, this is a **horizontal gap** (Vertical Separation). Record its top (`gap_min_r`) and bottom (`gap_max_r`) rows.\n    *   If no horizontal gap, search for a contiguous block of empty (white, 0) columns strictly *inside* the horizontal span of the red bounding box (`min_c + 1` to `max_c - 1`). If found, this is a **vertical gap** (Horizontal Separation). Record its leftmost (`gap_min_c`) and rightmost (`gap_max_c`) columns.\n    *   If no gap is found, return the grid with only red pixels.\n\n2.  **Identify Mobile Objects:**\n    *   Find all distinct connected groups (objects) of gray (5) pixels in the *original* input grid using 8-way connectivity (including diagonals). Record the coordinates for each object.\n\n3.  **Initialize Output Grid:**\n    *   Create an output grid of the same dimensions as the input, filled with white (0).\n    *   Copy all red (2) pixels from the input to the output grid.\n\n4.  **Calculate Relocation Shift for Each Gray Object:**\n    *   For each gray object:\n        *   Determine its bounding box (`obj_min_r`, `obj_max_r`, `obj_min_c`, `obj_max_c`).\n        *   Initialize shift `delta_r = 0`, `delta_c = 0`.\n        *   **If Vertical Separation (Horizontal Gap):**\n            *   Object Above (`obj_max_r < gap_min_r`): Align object's top edge with gap's top edge. `delta_r = gap_min_r - obj_min_r`.\n            *   Object Below (`obj_min_r > gap_max_r`): Align object's bottom edge with gap's bottom edge. `delta_r = gap_max_r - obj_max_r`.\n        *   **If Horizontal Separation (Vertical Gap):**\n            *   Object Left (`obj_max_c < gap_min_c`): Align object's left edge with gap's left edge. `delta_c = gap_min_c - obj_min_c`.\n            *   Object Right (`obj_min_c > gap_max_c`): Align object's right edge with gap's right edge. `delta_c = gap_max_c - obj_max_c`.\n\n5.  **Apply Shift and Paint Objects:**\n    *   For each gray object and its calculated shift (`delta_r`, `delta_c`):\n        *   For each pixel `(r, c)` belonging to the object, calculate the new position `(new_r, new_c) = (r + delta_r, c + delta_c)`.\n        *   If the new position is within grid bounds, paint the pixel `(new_r, new_c)` gray (5) on the output grid.\n\n6.  **Return Result:** The final output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid.\n    Connectivity includes diagonals (8 neighbors).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set[tuple[int, int]]]: A list where each element is a set\n                                      of (row, col) coordinates for one object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # If this pixel is the right color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is the right color and unvisited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by relocating gray objects into a gap\n    defined by red structures.\n\n    Args:\n        input_grid_list (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n\n    # --- 1. Identify Static Structures (Red Pixels) ---\n    red_coords = np.argwhere(input_grid == 2)\n\n    # Initialize output grid - start with white, add red pixels\n    output_grid = np.zeros_like(input_grid, dtype=int)\n    if red_coords.size > 0:\n        for r, c in red_coords:\n            output_grid[r, c] = 2\n    else:\n        # Edge case: No red pixels, no gap defined. Return blank grid.\n        return output_grid.tolist()\n\n    # --- 2. Identify Mobile Objects (Gray Pixels) ---\n    gray_objects = find_objects(input_grid, 5)\n    if not gray_objects:\n        # Edge case: No gray objects to move. Return grid with only red pixels.\n        return output_grid.tolist()\n\n    # --- Continue Step 1: Find the Gap ---\n    min_r, min_c = red_coords.min(axis=0)\n    max_r, max_c = red_coords.max(axis=0)\n\n    separation_axis = None\n    gap_min_r, gap_max_r = -1, -1\n    gap_min_c, gap_max_c = -1, -1\n\n    # Check for horizontal gap (Vertical Separation)\n    # Check rows strictly *between* min_r and max_r\n    if max_r > min_r + 1: # Need at least one row between bounds\n        potential_gap_rows = list(range(min_r + 1, max_r))\n        current_gap_start = -1\n        for r in potential_gap_rows:\n            # Check if the row is empty *within the horizontal bounds* of red pixels\n            is_empty_in_bounds = not np.any(input_grid[r, min_c:max_c+1] == 2) # Check only for red, gap can have other colors potentially? No, examples imply empty=white. Let's assume gap must be white.\n            is_empty_in_bounds = not np.any(input_grid[r, :] != 0) # More strict: entire row must be white? No, just within the red structure bounds.\n            is_empty_in_bounds = not np.any(input_grid[r, min_c:max_c+1] != 0) # Check for non-white within red bounds\n\n            if is_empty_in_bounds:\n                if current_gap_start == -1:\n                    current_gap_start = r\n                # If this is the last potential row or the next row is not empty, finalize gap\n                if r == potential_gap_rows[-1] or np.any(input_grid[r+1, min_c:max_c+1] != 0):\n                    gap_min_r = current_gap_start\n                    gap_max_r = r\n                    separation_axis = 'vertical'\n                    break # Found the first contiguous horizontal gap\n            else:\n                 current_gap_start = -1 # Reset if row is not empty\n\n\n    # Check for vertical gap (Horizontal Separation) only if no horizontal gap was found\n    if separation_axis is None and max_c > min_c + 1: # Need at least one col between bounds\n        potential_gap_cols = list(range(min_c + 1, max_c))\n        current_gap_start = -1\n        for c in potential_gap_cols:\n            # Check if the col is empty *within the vertical bounds* of red pixels\n            is_empty_in_bounds = not np.any(input_grid[min_r:max_r+1, c] != 0) # Check for non-white within red bounds\n            if is_empty_in_bounds:\n                 if current_gap_start == -1:\n                     current_gap_start = c\n                 # If this is the last potential col or the next col is not empty, finalize gap\n                 if c == potential_gap_cols[-1] or np.any(input_grid[min_r:max_r+1, c+1] != 0):\n                     gap_min_c = current_gap_start\n                     gap_max_c = c\n                     separation_axis = 'horizontal'\n                     break # Found the first contiguous vertical gap\n            else:\n                 current_gap_start = -1 # Reset if col is not empty\n\n    # If no gap is found after checking both directions\n    if separation_axis is None:\n        # Edge case: No gap found. Return grid with only red pixels.\n        return output_grid.tolist()\n\n    # --- 4 & 5. Calculate Shift and Relocate Gray Objects ---\n    for obj_coords in gray_objects:\n        if not obj_coords: continue # Skip empty sets if they somehow occur\n\n        # Calculate object bounding box\n        obj_rows = [r for r, c in obj_coords]\n        obj_cols = [c for r, c in obj_coords]\n        obj_min_r, obj_max_r = min(obj_rows), max(obj_rows)\n        obj_min_c, obj_max_c = min(obj_cols), max(obj_cols)\n\n        delta_r = 0\n        delta_c = 0\n\n        # Calculate shift based on gap type and object position (Corrected Logic)\n        if separation_axis == 'vertical': # Horizontal Gap\n            if obj_max_r < gap_min_r: # Object is above gap\n                # Align object's top edge (obj_min_r) with gap's top edge (gap_min_r)\n                delta_r = gap_min_r - obj_min_r\n            elif obj_min_r > gap_max_r: # Object is below gap\n                # Align object's bottom edge (obj_max_r) with gap's bottom edge (gap_max_r)\n                delta_r = gap_max_r - obj_max_r\n            else: # Object overlaps gap - unexpected based on examples, skip this object\n                continue\n\n        elif separation_axis == 'horizontal': # Vertical Gap\n            if obj_max_c < gap_min_c: # Object is left of gap\n                # Align object's left edge (obj_min_c) with gap's left edge (gap_min_c)\n                delta_c = gap_min_c - obj_min_c\n            elif obj_min_c > gap_max_c: # Object is right of gap\n                # Align object's right edge (obj_max_c) with gap's right edge (gap_max_c)\n                delta_c = gap_max_c - obj_max_c\n            else: # Object overlaps gap - unexpected based on examples, skip this object\n                continue\n\n        # Apply the shift to each pixel of the object and paint it on the output grid\n        for r, c in obj_coords:\n            new_r, new_c = r + delta_r, c + delta_c\n            # Check bounds before writing to output grid\n            if 0 <= new_r < height and 0 <= new_c < width:\n                # Check for potential overwrites? Examples suggest gray objects don't overlap red after moving.\n                # If the target cell is already red, maybe don't overwrite?\n                # Let's assume gray overwrites white, but not red.\n                # Re-evaluation: The examples DO show gray sometimes overwriting red boundary pixels in the output.\n                # So, allow overwriting.\n                output_grid[new_r, new_c] = 5\n            # else: Pixel moves out of bounds - ignore it.\n\n    # --- 6. Return Result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18541,
    "candidates_token_count": 3151,
    "total_token_count": 21692,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.31026,
  "retries": null
}