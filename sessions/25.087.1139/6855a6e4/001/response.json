{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis module transforms an input grid based on the spatial relationship between static red (2) pixels and mobile gray (5) pixels.\n\nThe transformation relocates the gray pixels based on how the red pixel structures are separated:\n\n1.  **Identify Elements**: Locate all red and gray pixels.\n2.  **Clear Original Gray**: Create an intermediate grid by setting original gray pixel locations to white (0).\n3.  **Analyze Red Separation**: Determine if the red structures are primarily separated by empty vertical columns (horizontal separation) or empty horizontal rows (vertical separation).\n    *   Find the bounding box of all red pixels.\n    *   Check for rows within the bounding box (excluding top/bottom) that contain no red pixels. If found, assume vertical separation.\n    *   Otherwise, check for columns within the bounding box (excluding left/right) that contain no red pixels. If found, assume horizontal separation.\n4.  **Apply Transformation**:\n    *   **Horizontal Separation**: Find the vertical gap columns between red structures. Find the inner vertical extent (rows) defined by the red pixels adjacent to this gap. Fill the rectangular area defined by the gap columns and the inner rows with gray (5).\n    *   **Vertical Separation**: Find the horizontal gap rows between red structures. Identify individual connected gray objects from the input grid. Translate each gray object vertically to fill the gap. Objects above the gap move down to the top of the gap; objects below the gap move up to the bottom of the gap. Their horizontal position and shape are preserved.\n5.  **Return Result**: The grid with relocated gray pixels.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid.\n    Connectivity includes diagonals (8 neighbors).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set[tuple[int, int]]]: A list where each element is a set\n                                      of (row, col) coordinates for one object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # If this pixel is the right color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]  # Queue for BFS\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is the right color and unvisited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Relocates gray pixels based on the spatial arrangement of static red pixels.\n\n    Args:\n        input_grid_list (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # --- 1. Identify Elements ---\n    red_coords = np.argwhere(input_grid == 2)\n    gray_coords = np.argwhere(input_grid == 5)\n\n    # Handle edge case: no gray pixels to move\n    if gray_coords.size == 0:\n        return output_grid.tolist()\n\n    # --- 2. Clear Original Gray ---\n    for r, c in gray_coords:\n        output_grid[r, c] = 0 # Set to white\n\n    # Handle edge case: no red pixels to guide movement (shouldn't happen based on examples)\n    if red_coords.size == 0:\n        # Or maybe just return the grid with gray removed? Let's stick to removing gray.\n        return output_grid.tolist()\n\n    # --- 3. Analyze Red Separation ---\n    min_r, min_c = red_coords.min(axis=0)\n    max_r, max_c = red_coords.max(axis=0)\n\n    separation_axis = None\n    gap_min_r, gap_max_r = -1, -1\n    gap_min_c, gap_max_c = -1, -1\n\n    # Check for horizontal gap (Vertical Separation)\n    h_gap_rows = [r for r in range(min_r + 1, max_r) if not np.any(input_grid[r, min_c:max_c+1] == 2)]\n    if h_gap_rows:\n        separation_axis = 'vertical'\n        # Find the contiguous block of gap rows\n        # Assume the first block found is the relevant one if multiple exist\n        start_r = h_gap_rows[0]\n        end_r = start_r\n        for i in range(1, len(h_gap_rows)):\n            if h_gap_rows[i] == end_r + 1:\n                end_r = h_gap_rows[i]\n            else:\n                 # Stop if the gap rows are not contiguous\n                 # This simplistic approach assumes one primary gap.\n                 break\n        gap_min_r = start_r\n        gap_max_r = end_r\n\n\n    # Check for vertical gap (Horizontal Separation) only if no horizontal gap was found\n    if separation_axis is None:\n        v_gap_cols = [c for c in range(min_c + 1, max_c) if not np.any(input_grid[min_r:max_r+1, c] == 2)]\n        if v_gap_cols:\n            separation_axis = 'horizontal'\n            # Find the contiguous block of gap columns\n            start_c = v_gap_cols[0]\n            end_c = start_c\n            for i in range(1, len(v_gap_cols)):\n                 if v_gap_cols[i] == end_c + 1:\n                     end_c = v_gap_cols[i]\n                 else:\n                     # Stop if the gap columns are not contiguous\n                     break\n            gap_min_c = start_c\n            gap_max_c = end_c\n\n    # --- 4. Apply Transformation ---\n\n    if separation_axis == 'horizontal':\n        # Find inner vertical extent based on red pixels adjacent to the gap\n        rows_with_adjacent_red = set()\n        # Check column left of gap (if exists)\n        if gap_min_c > 0:\n            for r in range(height):\n                 if input_grid[r, gap_min_c - 1] == 2:\n                     rows_with_adjacent_red.add(r)\n        # Check column right of gap (if exists)\n        if gap_max_c < width - 1:\n             for r in range(height):\n                 if input_grid[r, gap_max_c + 1] == 2:\n                     rows_with_adjacent_red.add(r)\n\n        if rows_with_adjacent_red:\n             inner_min_r = min(rows_with_adjacent_red)\n             inner_max_r = max(rows_with_adjacent_red)\n             # Fill the rectangle with gray\n             output_grid[inner_min_r : inner_max_r + 1, gap_min_c : gap_max_c + 1] = 5\n        else:\n            # Fallback or error case: couldn't determine bounds for filling\n            # Revert to original state (or just gray removed state)? Keep gray removed.\n            pass\n\n\n    elif separation_axis == 'vertical':\n        # Find original gray objects\n        gray_objects = find_objects(input_grid, 5)\n\n        for obj_coords in gray_objects:\n            if not obj_coords: continue # Skip empty objects if any\n\n            obj_rows = [r for r, c in obj_coords]\n            obj_min_r = min(obj_rows)\n            obj_max_r = max(obj_rows)\n            delta_r = 0\n\n            # Determine if object is above or below the gap and calculate shift\n            if obj_max_r < gap_min_r: # Object is above gap\n                delta_r = gap_min_r - obj_min_r # Shift down\n            elif obj_min_r > gap_max_r: # Object is below gap\n                delta_r = gap_max_r - obj_max_r # Shift up\n\n            # Apply the shift to each pixel of the object\n            for r, c in obj_coords:\n                new_r = r + delta_r\n                # Ensure the new position is within bounds (should be if gap logic is correct)\n                if 0 <= new_r < height:\n                    output_grid[new_r, c] = 5\n\n    # If separation_axis is None, no transformation is applied beyond removing gray.\n\n    # --- 5. Return Result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5046,
    "candidates_token_count": 2266,
    "total_token_count": 7312,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.004181,
  "retries": null
}