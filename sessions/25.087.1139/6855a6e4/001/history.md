
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 2 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 2 0 5 0
5 5 0 2 0 0 0 0 0 0 0 2 0 5 5
5 5 0 2 0 0 0 0 0 0 0 2 0 5 5
0 0 0 2 0 0 0 0 0 0 0 2 0 5 0
0 0 0 2 2 0 0 0 0 0 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0 2 2 0 0 0
0 0 0 2 0 0 0 0 0 5 0 2 0 0 0
0 0 0 2 0 5 5 0 5 5 0 2 0 0 0
0 0 0 2 0 5 5 0 5 5 0 2 0 0 0
0 0 0 2 0 0 0 0 0 5 0 2 0 0 0
0 0 0 2 2 0 0 0 0 0 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 5 0 2 0 0 0 0 0 0 2 0 5 0 0
5 5 0 2 0 0 0 0 0 0 2 0 5 5 0
0 5 0 2 0 0 0 0 0 0 2 0 0 5 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 2 0 5 0 0 5 0 2 0 0 0 0
0 0 0 2 0 5 5 5 5 0 2 0 0 0 0
0 0 0 2 0 5 0 5 0 0 2 0 0 0 0
0 0 0 2 2 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception**: The task involves manipulating gray pixels based on the configuration of static red pixels within a grid. The background is white. In all examples, the red pixels form shapes that remain unchanged. The gray pixels, however, change their positions. The transformation seems to depend on the spatial relationship between the red shapes.

*   **Analysis**:
    *   **Static Elements**: Red pixels (color 2) define fixed structures.
    *   **Mobile Elements**: Gray pixels (color 5) are the objects that move.
    *   **Transformation Rule**: The core transformation involves relocating the gray pixels. Their original positions become white (color 0). The destination depends on the arrangement of the red shapes.
        *   **Horizontal Separation (train_1, train_3)**: When red shapes are separated horizontally, creating a vertical gap between them, the gray pixels are moved to fill the rectangular area constituting this central gap. The vertical bounds of this filled rectangle correspond to the inner vertical extent of the red shapes (excluding potentially flat top/bottom parts of the shapes).
        *   **Vertical Separation (train_2)**: When red shapes are separated vertically, creating a horizontal gap (empty rows) between them, the gray pixels are translated vertically. Gray objects originally above the top red shape move down to occupy the highest available rows in the gap. Gray objects originally below the bottom red shape move up to occupy the lowest available rows in the gap. The horizontal position and the shape/size of the gray objects are preserved during this translation.

*   **YAML Facts**:
    
```yaml
    task_description: Relocate gray pixels based on the spatial arrangement of static red pixels.
    elements:
      - object: background
        color: white (0)
      - object: static_structure
        color: red (2)
        properties:
          - forms shapes (e.g., 'U', rectangles)
          - position is fixed
          - defines spatial context for gray pixel movement
      - object: mobile_element
        color: gray (5)
        properties:
          - position changes
          - original location becomes white (0)
          - destination depends on red structure configuration
    relationships:
      - spatial_relation: separation_axis
        between: red shapes
        determines: transformation type (fill vs. translate)
        values: [horizontal, vertical]
      - spatial_relation: gap
        between: red shapes
        defines: target region for gray pixels
    actions:
      - action: identify_elements
        inputs: [input_grid]
        outputs: [red_pixels, gray_pixels]
      - action: determine_red_configuration
        inputs: [red_pixels]
        outputs: [separation_axis, gap_region, inner_bounds (if horizontal sep.)]
      - action: clear_original_gray
        inputs: [input_grid, gray_pixels]
        outputs: [intermediate_grid (no gray pixels)]
      - action: apply_transformation
        inputs: [intermediate_grid, gray_pixels, separation_axis, gap_region, inner_bounds]
        logic:
          - if separation_axis is horizontal: fill gap_region (bounded by inner_bounds) with gray
          - if separation_axis is vertical: translate original gray shapes to fill gap_region from top/bottom edges
        outputs: [output_grid]

    ```


*   **Natural Language Program**:
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the locations of all red (2) pixels and all gray (5) pixels in the input grid.
    3.  Change the color of all cells in the output grid corresponding to the original gray pixel locations to white (0).
    4.  Analyze the configuration of the red pixels to determine if they form components primarily separated horizontally or vertically.
    5.  **If red components are separated horizontally:**
        a.  Determine the columns forming the empty vertical gap between the red components (`gap_min_c`, `gap_max_c`).
        b.  Determine the common inner row range of the red components, typically excluding horizontal end-caps (`inner_min_r`, `inner_max_r`).
        c.  Fill the rectangular region in the output grid defined by rows `inner_min_r` to `inner_max_r` and columns `gap_min_c` to `gap_max_c` with gray (5).
    6.  **If red components are separated vertically:**
        a.  Determine the rows forming the empty horizontal gap between the top and bottom red components (`gap_min_r`, `gap_max_r`).
        b.  For each distinct connected gray object in the *input* grid:
            i.  Determine its original bounding box (`obj_min_r`, `obj_max_r`).
            ii. If the object was entirely above the gap (`obj_max_r < gap_min_r`), calculate the downward shift needed to place its top edge at `gap_min_r`: `delta_r = gap_min_r - obj_min_r`.
            iii. If the object was entirely below the gap (`obj_min_r > gap_max_r`), calculate the upward shift needed to place its bottom edge at `gap_max_r`: `delta_r = gap_max_r - obj_max_r`.
            iv. For each pixel `(r, c)` belonging to this gray object in the input, set the pixel at `(r + delta_r, c)` in the output grid to gray (5).
    7.  Return the final output grid.
