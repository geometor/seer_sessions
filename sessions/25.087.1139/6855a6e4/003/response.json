{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nRelocates gray (5) objects into the gap defined by static red (2) structures.\n\nThe transformation follows these steps:\n\n1.  **Identify Structures**: Locate all red (2) pixels and all gray (5) pixels in the input grid. Red pixels remain fixed.\n2.  **Find the Gap**: Analyze the arrangement of red pixels to find the empty space (gap) separating them.\n    *   Determine the bounding box of all red pixels.\n    *   Check for a contiguous block of empty rows strictly *inside* the vertical span of the red bounding box. If found, this is a horizontal gap (Vertical Separation). Record the gap's top (`gap_min_r`) and bottom (`gap_max_r`) rows.\n    *   If no horizontal gap, check for a contiguous block of empty columns strictly *inside* the horizontal span of the red bounding box. If found, this is a vertical gap (Horizontal Separation). Record the gap's leftmost (`gap_min_c`) and rightmost (`gap_max_c`) columns.\n3.  **Identify Gray Objects**: Find all distinct connected groups (objects) of gray pixels from the *original* input grid using 8-way connectivity (including diagonals).\n4.  **Initialize Output**: Create an output grid containing only the static red pixels, with all other cells set to white (0).\n5.  **Relocate Gray Objects**: Move each identified gray object into the determined gap based on the separation type:\n    *   **If Vertical Separation (Horizontal Gap):**\n        *   For each gray object, determine if its original position was above or below the gap.\n        *   If above (`obj_max_r < gap_min_r`), calculate the downward vertical shift (`delta_r`) needed to place the object's bottom edge at row `gap_min_r - 1`.\n        *   If below (`obj_min_r > gap_max_r`), calculate the upward vertical shift (`delta_r`) needed to place the object's top edge at row `gap_max_r + 1`.\n        *   Apply the shift: For each pixel `(r, c)` in the object, paint the pixel at `(r + delta_r, c)` gray (5) in the output grid. Maintain the object's shape and horizontal position.\n    *   **If Horizontal Separation (Vertical Gap):**\n        *   For each gray object, determine if its original position was to the left or right of the gap.\n        *   If left (`obj_max_c < gap_min_c`), calculate the rightward horizontal shift (`delta_c`) needed to place the object's right edge at column `gap_min_c - 1`.\n        *   If right (`obj_min_c > gap_max_c`), calculate the leftward horizontal shift (`delta_c`) needed to place the object's left edge at column `gap_max_c + 1`.\n        *   Apply the shift: For each pixel `(r, c)` in the object, paint the pixel at `(r, c + delta_c)` gray (5) in the output grid. Maintain the object's shape and vertical position.\n6.  **Return Result**: The output grid containing the static red pixels and the relocated gray objects.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected objects of a specific color in the grid.\n    Connectivity includes diagonals (8 neighbors).\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set[tuple[int, int]]]: A list where each element is a set\n                                      of (row, col) coordinates for one object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # If this pixel is the right color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]  # Queue for BFS\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is the right color and unvisited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Relocates gray objects into the gap defined by static red structures.\n\n    Args:\n        input_grid_list (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n\n    # --- 1. Identify Structures ---\n    red_coords = np.argwhere(input_grid == 2)\n    # We need gray objects later, using the original grid\n\n    # --- Initialize Output Grid (Keep red, clear everything else) ---\n    output_grid = np.zeros_like(input_grid, dtype=int) # Initialize with white (0)\n    if red_coords.size > 0:\n        for r, c in red_coords:\n            output_grid[r, c] = 2 # Keep red pixels\n\n    # --- 3. Identify Gray Objects ---\n    gray_objects = find_objects(input_grid, 5)\n\n    # Handle edge case: no gray objects to move\n    if not gray_objects:\n        return output_grid.tolist()\n\n    # Handle edge case: no red pixels to define a gap\n    if red_coords.size == 0:\n        # No gap defined, unclear what to do. Return grid with only red (which is none).\n        # Or maybe return the original gray positions? Based on examples, seems red is always present.\n        # Let's return the grid with only red (i.e., empty if no red).\n         return output_grid.tolist() # Or maybe input_grid.tolist()? Let's stick to the initialized grid.\n\n    # --- 2. Find the Gap ---\n    min_r, min_c = red_coords.min(axis=0)\n    max_r, max_c = red_coords.max(axis=0)\n\n    separation_axis = None\n    gap_min_r, gap_max_r = -1, -1\n    gap_min_c, gap_max_c = -1, -1\n\n    # Check for horizontal gap (Vertical Separation)\n    h_gap_rows = [r for r in range(min_r + 1, max_r) if not np.any(input_grid[r, min_c:max_c+1] == 2)]\n    if h_gap_rows:\n        # Find the first contiguous block of gap rows\n        start_r = h_gap_rows[0]\n        end_r = start_r\n        for i in range(1, len(h_gap_rows)):\n            if h_gap_rows[i] == end_r + 1:\n                end_r = h_gap_rows[i]\n            else:\n                 break # Stop if the gap rows are not contiguous\n        # Check if the gap found is truly internal (not touching the bbox edges implicitly)\n        # This is implicitly handled by range(min_r + 1, max_r)\n        if end_r >= start_r: # Ensure at least one gap row found\n             separation_axis = 'vertical'\n             gap_min_r = start_r\n             gap_max_r = end_r\n\n    # Check for vertical gap (Horizontal Separation) only if no horizontal gap was found\n    if separation_axis is None:\n        v_gap_cols = [c for c in range(min_c + 1, max_c) if not np.any(input_grid[min_r:max_r+1, c] == 2)]\n        if v_gap_cols:\n            # Find the first contiguous block of gap columns\n            start_c = v_gap_cols[0]\n            end_c = start_c\n            for i in range(1, len(v_gap_cols)):\n                 if v_gap_cols[i] == end_c + 1:\n                     end_c = v_gap_cols[i]\n                 else:\n                     break # Stop if the gap columns are not contiguous\n            # Check if the gap found is truly internal\n            if end_c >= start_c: # Ensure at least one gap column found\n                 separation_axis = 'horizontal'\n                 gap_min_c = start_c\n                 gap_max_c = end_c\n\n    # If no gap is found, return the grid with only red pixels\n    if separation_axis is None:\n        return output_grid.tolist()\n\n    # --- 5. Relocate Gray Objects ---\n    for obj_coords in gray_objects:\n        if not obj_coords: continue # Skip empty objects if any\n\n        obj_rows = [r for r, c in obj_coords]\n        obj_cols = [c for r, c in obj_coords]\n        obj_min_r, obj_max_r = min(obj_rows), max(obj_rows)\n        obj_min_c, obj_max_c = min(obj_cols), max(obj_cols)\n\n        delta_r = 0\n        delta_c = 0\n\n        if separation_axis == 'vertical':\n            # Determine if object is above or below the gap and calculate vertical shift\n            if obj_max_r < gap_min_r: # Object is above gap\n                # Target bottom row of object is gap_min_r - 1\n                delta_r = (gap_min_r - 1) - obj_max_r\n            elif obj_min_r > gap_max_r: # Object is below gap\n                # Target top row of object is gap_max_r + 1\n                delta_r = (gap_max_r + 1) - obj_min_r\n            else: # Object overlaps gap - behavior undefined? Assume skip or error. Let's skip.\n                continue\n\n        elif separation_axis == 'horizontal':\n            # Determine if object is left or right of the gap and calculate horizontal shift\n            if obj_max_c < gap_min_c: # Object is left of gap\n                # Target right col of object is gap_min_c - 1\n                delta_c = (gap_min_c - 1) - obj_max_c\n            elif obj_min_c > gap_max_c: # Object is right of gap\n                # Target left col of object is gap_max_c + 1\n                delta_c = (gap_max_c + 1) - obj_min_c\n            else: # Object overlaps gap - behavior undefined? Assume skip or error. Let's skip.\n                continue\n\n        # Apply the shift to each pixel of the object and paint it on the output grid\n        for r, c in obj_coords:\n            new_r, new_c = r + delta_r, c + delta_c\n            # Check bounds before writing to output grid\n            if 0 <= new_r < height and 0 <= new_c < width:\n                output_grid[new_r, new_c] = 5\n            # else: Pixel moves out of bounds - ignore it? This shouldn't happen if logic is correct for internal gaps.\n\n    # --- 6. Return Result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9575,
    "candidates_token_count": 2822,
    "total_token_count": 12397,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.896009,
  "retries": null
}