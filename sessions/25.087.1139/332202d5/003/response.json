{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom typing import List, Tuple, Dict\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify the Control Column:** Locate the vertical column (`azure_col`) characterized by containing both 'azure' (8) and 'blue' (1) pixels. This column acts as a control axis. The background color is often 'orange' (7) but can vary; assume it's the most frequent color overall or specifically avoid 1 and 8 when identifying marker colors.\n\n2.  **Identify Marker Rows and Colors:** Scan the input grid row by row. A row `r` is a 'marker row' if the pixel at `input[r, azure_col]` is 'blue' (1). For each marker row, determine its associated 'marker color'. This is the predominant color in the row *other than* 'blue' (1) and the likely background color (e.g., 'orange' 7, or simply not 1 or 8). Store these findings, mapping marker row indices to their colors (e.g., `{marker_row_index: marker_color}`).\n\n3.  **Determine Row Color Based on Proximity to Markers:**\n    a.  Initialize an output grid of the same dimensions as the input.\n    b.  Iterate through each row index `r` of the grid.\n    c.  **If `r` is a marker row index:**\n        i.  Fill the entire row `r` in the output grid with 'blue' (1).\n        ii. Set the pixel at `output[r, azure_col]` to 'azure' (8).\n    d.  **If `r` is *not* a marker row index:**\n        i.  Calculate the vertical distance from row `r` to every marker row `m`: `distance = abs(r - m)`.\n        ii. Find the minimum distance (`min_dist`) among these.\n        iii. Identify all marker rows (`closest_markers`) that are at this `min_dist` from row `r`.\n        iv. **Single Closest Marker:** If there is only one closest marker (`len(closest_markers) == 1`):\n            - Get the `marker_color` associated with this single closest marker.\n            - Fill the entire row `r` in the output grid with this `marker_color`.\n            - Set the pixel at `output[r, azure_col]` to 'blue' (1).\n        v.  **Multiple Closest Markers (Tie):** If there are multiple closest markers (`len(closest_markers) > 1`):\n            - Check the `marker_color` associated with each of the tied closest markers.\n            - **If all tied markers have the *same* `marker_color`:**\n                - Fill the entire row `r` in the output grid with this common `marker_color`.\n                - Set the pixel at `output[r, azure_col]` to 'blue' (1).\n            - **If the tied markers have *different* `marker_colors`:**\n                - Fill the entire row `r` in the output grid with 'blue' (1). (The pixel at `azure_col` will also be 'blue').\n\n4.  **Return the Output Grid:** The fully processed grid is the result.\n\"\"\"\n\nimport numpy as np\nimport math\nfrom collections import Counter\n\ndef find_azure_col(grid: np.ndarray) -> int:\n    \"\"\"Finds the column index containing the vertical control line (azure 8 and blue 1).\"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        col_vals = grid[:, c]\n        counts = np.bincount(col_vals, minlength=10)\n        # A column is the control column if it contains both 8 and 1\n        if counts[8] > 0 and counts[1] > 0:\n            # Further check: ensure it's not just random 8s and 1s, but a dominant feature.\n            # Often the rest is background (e.g., 7).\n            # If the count of 8 + count of 1 is significant fraction of height, likely it.\n             if counts[8] + counts[1] >= 1: # Simple check, might need refinement if noisy\n                # Check if other numbers are mostly a single background color (like 7)\n                other_colors = [val for val in col_vals if val != 8 and val != 1]\n                if not other_colors or len(set(other_colors)) <= 1:\n                     return c\n\n    # Fallback if primary check fails (e.g., no background color in the column)\n    for c in range(width):\n        col_vals = grid[:, c]\n        counts = np.bincount(col_vals, minlength=10)\n        if counts[8] > 0 and counts[1] > 0:\n            return c\n\n    raise ValueError(\"Control column (containing 8s and 1s) not found.\")\n\ndef find_marker_rows_and_colors(grid: np.ndarray, azure_col: int) -> Dict[int, int]:\n    \"\"\"Finds marker rows (blue '1' at azure_col) and their associated dominant color.\"\"\"\n    marker_info = {}\n    height = grid.shape[0]\n    # Determine potential background color (most frequent color overall?)\n    # Simplified: Assume 7 is background if present, otherwise look for non-1/non-8.\n    background_color = 7 # Default assumption based on examples\n    if 7 not in grid:\n         # If 7 isn't present, maybe the background is 0 or something else?\n         # For now, just avoid 1 and 8.\n         background_color = -1 # Indicate no specific background color to ignore\n\n    for r in range(height):\n        if grid[r, azure_col] == 1:\n            marker_color = -1\n            row_vals = grid[r, :]\n            unique_colors = np.unique(row_vals)\n\n            # Find the color that isn't blue (1) and isn't the azure_col marker (1)\n            # and isn't the background color (7 or -1 if undetermined)\n            possible_colors = [c for c in unique_colors if c != 1 and c != background_color and c != 8] # Also exclude 8 just in case\n\n            if len(possible_colors) == 1:\n                marker_color = possible_colors[0]\n            elif len(possible_colors) > 1:\n                 # If multiple possibilities, pick the most frequent one in the row (excluding 1 and background)\n                 row_counts = Counter(row_vals)\n                 best_color = -1\n                 max_count = -1\n                 for color in possible_colors:\n                     if row_counts[color] > max_count:\n                         max_count = row_counts[color]\n                         best_color = color\n                 marker_color = best_color\n            # If no other color found (row is all 1s or 1s and background), this is unexpected.\n            # Let's stick to requiring a distinct marker color.\n\n            if marker_color != -1:\n                marker_info[r] = marker_color\n            else:\n                 # If still -1, try finding any color != 1 in the row\n                 fallback_colors = [c for c in unique_colors if c != 1]\n                 if fallback_colors:\n                     # Take the first one? Or most frequent? Let's try first.\n                     marker_color = fallback_colors[0]\n                     marker_info[r] = marker_color\n                 # If row is ONLY 1s, this is an issue. Raise error? Or default?\n                 # Based on examples, a marker color should always exist.\n                 # else: raise ValueError(f\"Marker row {r} has no identifiable marker color.\")\n\n\n    if not marker_info:\n        raise ValueError(\"No marker rows (blue '1' in control column) found.\")\n\n    return marker_info\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on marker rows defined by a control column.\n    Rows in the output grid are colored based on the color of the nearest marker row.\n    Marker rows themselves become blue, intersecting the control column as azure.\n    Rows equidistant between markers of different colors also become blue.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the control column\n    try:\n        azure_col = find_azure_col(input_np)\n    except ValueError as e:\n        # Handle error: perhaps return input or a default grid?\n        print(f\"Error finding control column: {e}\")\n        # Return input unchanged if control column not found?\n        return input_grid\n\n    # 2. Find marker rows and their colors\n    try:\n        marker_info = find_marker_rows_and_colors(input_np, azure_col)\n        marker_rows = sorted(marker_info.keys())\n    except ValueError as e:\n         # Handle error: No markers found\n        print(f\"Error finding markers: {e}\")\n        # What should happen if no markers? Fill with background? Return input?\n        # Let's assume fill with a default (e.g., 0)\n        return np.zeros_like(input_np).tolist()\n\n    # 3. Fill rows based on proximity to markers\n    for r in range(height):\n        if r in marker_info:\n            # 3.c. Marker row itself\n            output_np[r, :] = 1  # Fill row with blue\n            output_np[r, azure_col] = 8  # Set intersection to azure\n        else:\n            # 3.d. Non-marker row: Find closest marker(s)\n            min_dist = float('inf')\n            closest_markers = []\n            for m_row in marker_rows:\n                dist = abs(r - m_row)\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_markers = [m_row]\n                elif dist == min_dist:\n                    closest_markers.append(m_row)\n\n            if len(closest_markers) == 1:\n                # 3.d.iv. Single Closest Marker\n                m_closest = closest_markers[0]\n                fill_color = marker_info[m_closest]\n                output_np[r, :] = fill_color\n                output_np[r, azure_col] = 1 # Set control column pixel to blue\n            else:\n                # 3.d.v. Multiple Closest Markers (Tie)\n                tied_colors = {marker_info[m] for m in closest_markers}\n                if len(tied_colors) == 1:\n                    # Tie with Same Colors\n                    fill_color = list(tied_colors)[0]\n                    output_np[r, :] = fill_color\n                    output_np[r, azure_col] = 1 # Set control column pixel to blue\n                else:\n                    # Tie with Different Colors\n                    output_np[r, :] = 1 # Fill row with blue\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7266,
    "candidates_token_count": 2608,
    "total_token_count": 9874,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.649713,
  "retries": null
}