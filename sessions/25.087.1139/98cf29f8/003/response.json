{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies two distinct non-white objects in the input grid. One object is a solid rectangle (the mask), and the other is the target object.\nThe output grid displays the mask object, but replaces the pixels where the target object overlaps the mask with the target object's color.\nEssentially, the mask acts as a window or stencil, revealing the part of the target object that falls within its boundaries, while the rest of the mask remains visible. Pixels outside the mask area are white (background).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds distinct contiguous objects of non-background colors (non-zero).\n    Uses 4-connectivity (up, down, left, right).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'pixels' (set of (row, col) tuples).\n    \"\"\"\n    objects = []\n    visited = np.zeros(grid.shape, dtype=bool)\n    rows, cols = grid.shape\n    \n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-white (0) and not visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found object to the list\n                objects.append({'color': color, 'pixels': obj_pixels})\n                \n    return objects\n\ndef is_rectangle(obj_pixels_set):\n    \"\"\"\n    Checks if a set of pixels forms a solid rectangle.\n\n    Args:\n        obj_pixels_set (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        bool: True if the pixels form a solid rectangle, False otherwise.\n    \"\"\"\n    if not obj_pixels_set:\n        return False\n        \n    # Find the bounding box of the object\n    min_r = min(r for r, c in obj_pixels_set)\n    max_r = max(r for r, c in obj_pixels_set)\n    min_c = min(c for r, c in obj_pixels_set)\n    max_c = max(c for r, c in obj_pixels_set)\n    \n    # Calculate the expected number of pixels for a solid rectangle within the bounding box\n    expected_count = (max_r - min_r + 1) * (max_c - min_c + 1)\n    \n    # Check if the number of actual pixels matches the expected count\n    if len(obj_pixels_set) != expected_count:\n        return False\n        \n    # Double-check if all pixels within the bounding box are present in the set\n    # This check is somewhat redundant if the count matches, but ensures solidity.\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if (r, c) not in obj_pixels_set:\n                return False \n                \n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a mask effect: displays a rectangular object, replacing pixels\n    where a second object overlaps with the second object's color.\n\n    Args:\n        input_grid (np.ndarray): The input grid containing two non-white objects,\n                                 one of which is a solid rectangle.\n\n    Returns:\n        np.ndarray: The output grid with the mask effect applied.\n    \"\"\"\n    # Initialize output_grid with the same shape as input, filled with white (0)\n    output_grid = np.zeros_like(input_grid)\n    \n    # Find all non-white objects in the input grid\n    objects = find_objects(input_grid)\n    \n    # Expect exactly two non-white objects based on the task examples\n    if len(objects) != 2:\n        # Return the empty grid or input grid if assumption fails.\n        # Returning empty grid might be safer if the logic relies heavily on 2 objects.\n        print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning empty grid.\")\n        return output_grid\n\n    # Identify the mask (rectangle) and target objects\n    mask_obj = None\n    target_obj = None\n    \n    # Check which object is the rectangle\n    if is_rectangle(objects[0]['pixels']):\n        mask_obj = objects[0]\n        target_obj = objects[1]\n    elif is_rectangle(objects[1]['pixels']):\n        mask_obj = objects[1]\n        target_obj = objects[0]\n    else:\n        # Handle case where neither or both are rectangles\n        print(\"Warning: Could not uniquely identify a single rectangular mask object. Returning empty grid.\")\n        return output_grid\n\n    # --- Apply the transformation ---\n\n    # 1. Draw the complete mask object onto the output grid first.\n    mask_color = mask_obj['color']\n    mask_pixels_coords = mask_obj['pixels']\n    for r, c in mask_pixels_coords:\n        output_grid[r, c] = mask_color\n        \n    # 2. Iterate through the target object's pixels.\n    target_color = target_obj['color']\n    target_pixels_coords = target_obj['pixels']\n    for r, c in target_pixels_coords:\n        # 3. Check if the target pixel's location overlaps with the mask object's area.\n        if (r, c) in mask_pixels_coords:\n            # 4. If it overlaps, overwrite the mask color with the target color at that position.\n            output_grid[r, c] = target_color\n\n    # Pixels outside the mask remain white (0) as initialized.\n    # Pixels of the mask not overlapped by the target retain the mask color.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6993,
    "candidates_token_count": 1558,
    "total_token_count": 8551,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 122.161371,
  "retries": null
}