{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify the sequence of nested frame colors in the input grid, starting from the outermost azure (8) background connected to the border and moving inwards. If the color red (2) is present anywhere in this sequence of frame colors, output a 1x1 grid containing red (2). Otherwise, output an empty grid.\n\"\"\"\n\nimport numpy as np\nimport collections\n\ndef transform(input_grid):\n    \"\"\"\n    Finds the sequence of nested frame colors inward from the azure border.\n    Outputs [[2]] if red is found in the sequence, otherwise [].\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: [[2]] if red is in the frame sequence, otherwise [].\n    \"\"\"\n    try:\n        grid = np.array(input_grid, dtype=int)\n        if grid.size == 0:\n            return [] # Handle empty input\n        rows, cols = grid.shape\n    except Exception:\n        return [] # Invalid grid format\n\n    # Initialize data structures\n    q = collections.deque()\n    visited = np.zeros_like(grid, dtype=bool) # Tracks globally visited cells\n    frame_colors_sequence = []\n    background_color = 8\n    found_colors = {background_color} # Keep track of colors identified as background or frames\n\n    # --- Step 1: Find initial Azure background connected to border ---\n    initial_boundary_cells = []\n    # Initialize queue with border azure cells\n    for r in range(rows):\n        for c in [0, cols - 1]: # First and last columns\n            if 0 <= r < rows and 0 <= c < cols:\n                if grid[r, c] == background_color and not visited[r, c]:\n                    q.append((r, c))\n                    visited[r, c] = True\n    for c in range(cols): # First and last rows (avoid double-adding corners)\n         for r in [0, rows - 1]:\n             if 0 <= r < rows and 0 <= c < cols:\n                if grid[r, c] == background_color and not visited[r, c]:\n                    q.append((r, c))\n                    visited[r, c] = True\n\n    if not q:\n         # No azure background connected to border found\n         return []\n\n    # --- Step 2: Perform BFS to identify the full background region adjacent to the border ---\n    # This ensures we start the frame search from the complete outer layer\n    background_bfs_q = q.copy()\n    current_boundary_pixels = list(q) # Initial set of pixels forming the boundary\n\n    while background_bfs_q:\n        r, c = background_bfs_q.popleft()\n        # Store the coordinate as part of the current boundary\n        # No, current_boundary_pixels should be the starting points for the *next* search\n        # We need to find neighbors of the *entire* background region\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and not visited[nr, nc]:\n                visited[nr, nc] = True\n                background_bfs_q.append((nr, nc))\n                # Add newly found background cells to the list from which we'll search for the first frame\n                current_boundary_pixels.append((nr,nc))\n\n    current_layer_color = background_color\n\n    # --- Step 3: Iteratively find frame layers ---\n    while True:\n        next_layer_candidates = {} # Stores {color: set_of_coords} for adjacent, unvisited, new colors\n        \n        # Use a temporary queue for searching neighbors of the *entire* current boundary\n        search_q = collections.deque(current_boundary_pixels)\n        processed_in_search = set(current_boundary_pixels) # Prevent re-adding to search queue\n\n        # Explore neighbors of all pixels in the current boundary layer\n        while search_q:\n            r, c = search_q.popleft()\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_color = grid[nr, nc]\n                    neighbor_coords = (nr, nc)\n\n                    # Check if neighbor is a new color and hasn't been visited yet\n                    if neighbor_color != current_layer_color and \\\n                       neighbor_color not in found_colors and \\\n                       not visited[nr, nc]:\n                        \n                        if neighbor_color not in next_layer_candidates:\n                            next_layer_candidates[neighbor_color] = set()\n                        # Store the coordinate of this newly found adjacent pixel\n                        next_layer_candidates[neighbor_color].add(neighbor_coords)\n                    # Note: We don't need to expand within the current_layer_color here,\n                    # as the initial background BFS and subsequent layer preparations handle finding all relevant pixels.\n\n        # --- Step 4: Analyze candidates for the next layer ---\n        if not next_layer_candidates:\n            # No new adjacent colors found, all frames identified\n            break\n\n        # Check if exactly one new frame color was found adjacent to the current layer\n        if len(next_layer_candidates) != 1:\n            # Ambiguous structure based on training examples (expecting perfect nesting)\n            # This indicates either an error in logic or an input structure not covered by examples.\n            # Based on the problem derivation, this shouldn't happen for valid inputs yielding [[2]].\n            # We'll stop and won't produce [[2]] in this case.\n            # print(f\"Ambiguity: Found {len(next_layer_candidates)} candidates {list(next_layer_candidates.keys())} adjacent to color {current_layer_color}.\")\n            return [] # Return empty list for ambiguous cases or non-perfect frames\n\n        # Identify the single next frame color and its starting coordinates\n        next_frame_color = list(next_layer_candidates.keys())[0]\n        next_boundary_start_coords = list(next_layer_candidates[next_frame_color])\n\n        # Add the found frame color to the sequence and mark it as found\n        frame_colors_sequence.append(next_frame_color)\n        found_colors.add(next_frame_color)\n\n        # Mark the starting pixels of this new frame as visited globally\n        for nr_next, nc_next in next_boundary_start_coords:\n            visited[nr_next, nc_next] = True\n\n        # --- Step 5: Prepare for the next iteration ---\n        # The new boundary consists of the pixels we just found and marked visited\n        current_boundary_pixels = next_boundary_start_coords\n        current_layer_color = next_frame_color\n\n        # If for some reason the list of starting coords is empty, break\n        if not current_boundary_pixels:\n             break\n\n    # --- Step 6: Check if Red (2) is in the sequence ---\n    target_color = 2\n    if target_color in frame_colors_sequence:\n        output_grid = [[target_color]]\n    else:\n        # Red was not found in the sequence, or no frames were found\n        output_grid = []\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12178,
    "candidates_token_count": 1735,
    "total_token_count": 13913,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.281685,
  "retries": null
}