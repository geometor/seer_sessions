
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 7 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 5 5 5 2 5 5 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 8 0 0 0 5 0 0 7 0 0 0
0 0 0 6 6 6 6 6 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 8 8 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 5 5 2 5 5 5 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 4 0 0 5 0 0 0 3 0 0 0 0 0
0 0 6 6 6 6 6 6 6 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 6 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 9 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 5 5 5 2 5 5 5 5 5 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 1 0 0 0 5 0 0 0 0 0 6 0 0
0 0 9 9 9 9 9 9 9 9 9 9 9 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception of Task Elements:**
    *   The input grids contain a sparse distribution of single, non-white pixels on a white background.
    *   Each input grid has exactly five non-white pixels. One of these pixels is always red (color 2).
    *   The output grids feature a rectangular frame structure with internal lines forming a cross.
    *   The colors and positions of the input pixels determine the size, position, and coloration of the output structure.
    *   The rectangle's boundaries (top, bottom, left, right) are defined by the outermost input pixels in each respective direction. The color of each boundary corresponds to the color of the pixel that defines that boundary extremum.
    *   A cross shape, colored gray (color 5), is drawn within the rectangle. The intersection of the cross aligns with the original position of the red (color 2) input pixel.
    *   The red (color 2) pixel is placed at the intersection of the gray cross, overwriting the gray pixel at that location.
    *   Other input pixels (those not defining boundaries and not the red pixel) do not directly appear in the output structure, but their positions contribute to determining the bounding box.

*   **YAML Facts:**
    
```yaml
    task_description: Construct a framed cross structure based on the spatial extent and specific pixel colors/locations from the input.

    elements:
      - element: background
        color: white (0)
        role: canvas
      - element: input_pixels
        description: Sparse, single non-white pixels.
        count: 5 per example
        properties:
          - color: non-white (1-9)
          - position: (row, column)
        relationships:
          - one pixel is always red (2), defining the center of the cross.
          - pixels at min/max row/column define the bounding box and boundary colors.
      - element: output_structure
        description: A hollow rectangle with an internal cross.
        components:
          - component: bounding_box
            shape: rectangle
            properties:
              - top_row: determined by the minimum row index of any input pixel.
              - bottom_row: determined by the maximum row index of any input pixel.
              - left_col: determined by the minimum column index of any input pixel.
              - right_col: determined by the maximum column index of any input pixel.
          - component: boundaries
            description: The four sides of the bounding box.
            properties:
              - top_boundary_color: color of the input pixel at the minimum row index.
              - bottom_boundary_color: color of the input pixel at the maximum row index.
              - left_boundary_color: color of the input pixel at the minimum column index.
              - right_boundary_color: color of the input pixel at the maximum column index.
          - component: cross
            shape: "+" sign formed by a horizontal and a vertical line intersecting.
            properties:
              - color: gray (5)
              - horizontal_line_row: row index of the input red (2) pixel.
              - vertical_line_col: column index of the input red (2) pixel.
              - extent: spans between the bounding box edges.
          - component: center_pixel
            description: The pixel at the intersection of the cross.
            properties:
              - color: red (2)
              - position: original coordinates of the input red (2) pixel.
              - action: Overwrites the gray pixel at the cross intersection.

    actions:
      - action: identify_pixels
        input: input grid
        output: list of non-white pixels with their colors and coordinates.
      - action: find_red_pixel
        input: list of non-white pixels
        output: coordinates of the red (2) pixel.
      - action: determine_bounding_box
        input: list of non-white pixels
        output: min_row, max_row, min_col, max_col coordinates.
      - action: determine_boundary_colors
        input: list of non-white pixels and bounding box coordinates
        output: colors for top, bottom, left, right boundaries based on pixels at extremal coordinates.
      - action: construct_output_grid
        input: grid dimensions, bounding box, boundary colors, red pixel coordinates
        steps:
          - Initialize output grid with white (0).
          - Draw top boundary (row min_row, from min_col to max_col) with top_color.
          - Draw bottom boundary (row max_row, from min_col to max_col) with bottom_color.
          - Draw left boundary (col min_col, from min_row to max_row) with left_color.
          - Draw right boundary (col max_col, from min_row to max_row) with right_color.
          - Draw horizontal gray cross line (row red_row, from min_col to max_col) with gray (5).
          - Draw vertical gray cross line (col red_col, from min_row to max_row) with gray (5).
          - Place red pixel (color 2) at (red_row, red_col).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid with the same dimensions as the input grid, filled entirely with white (0) pixels.
    2.  Identify all non-white pixels in the input grid and record their colors and coordinates (row, column).
    3.  Find the specific coordinates (`red_row`, `red_col`) of the red (2) pixel among the identified non-white pixels.
    4.  Determine the bounding box of all non-white pixels:
        *   Find the minimum row index (`min_row`).
        *   Find the maximum row index (`max_row`).
        *   Find the minimum column index (`min_col`).
        *   Find the maximum column index (`max_col`).
    5.  Determine the colors for the boundaries by finding the colors of the input pixels located at these extremal coordinates:
        *   `top_color`: Color of a pixel at `min_row`.
        *   `bottom_color`: Color of a pixel at `max_row`.
        *   `left_color`: Color of a pixel at `min_col`.
        *   `right_color`: Color of a pixel at `max_col`. (If multiple pixels share an extremum coordinate, use the color of any one of them).
    6.  Draw the top boundary line in the output grid: Fill pixels from (`min_row`, `min_col`) to (`min_row`, `max_col`) with `top_color`.
    7.  Draw the bottom boundary line: Fill pixels from (`max_row`, `min_col`) to (`max_row`, `max_col`) with `bottom_color`.
    8.  Draw the left boundary line: Fill pixels from (`min_row`, `min_col`) to (`max_row`, `min_col`) with `left_color`.
    9.  Draw the right boundary line: Fill pixels from (`min_row`, `max_col`) to (`max_row`, `max_col`) with `right_color`.
    10. Draw the horizontal line of the cross: Fill pixels from (`red_row`, `min_col`) to (`red_row`, `max_col`) with gray (5).
    11. Draw the vertical line of the cross: Fill pixels from (`min_row`, `red_col`) to (`max_row`, `red_col`) with gray (5).
    12. Place the central pixel: Set the pixel at (`red_row`, `red_col`) in the output grid to red (2), overwriting any previously placed color (boundary or gray cross).
