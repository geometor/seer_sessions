
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 1 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 2
```


**output:**
```
1 1 1 1 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 4 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3
```


**output:**
```
2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
4 4 4 4 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 1 0 1 0 0 0 0 0 4
```


**output:**
```
3 3 3 3 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 3 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 4 4 4 4
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 4 4 4 4
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 4 4 4 4
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 4 4 4 4
```

Okay, let's break down the task based on the provided examples.

**Perception of the Elements:**

1.  **Grid Size Transformation:** The output grid is consistently twice the height and twice the width of the input grid. If the input is HxW, the output is (2H)x(2W). In the examples, 10x10 inputs become 20x20 outputs.
2.  **Object Identification:** The inputs contain isolated, single pixels of non-white colors (Blue, Red, Green, Yellow, Azure) scattered on a white background (color 0). These single colored pixels can be considered the primary objects.
3.  **Object Transformation:** Each non-white input pixel seems to "expand" into a larger square block in the output grid.
4.  **Block Size:** Observing the outputs, each input pixel corresponds to a 4x4 block of the *same* color in the output.
5.  **Positional Mapping:** The position of the 4x4 block in the output grid is directly related to the position of the original single pixel in the input grid. If an input pixel is at `(r, c)` (using 0-based indexing), the corresponding 4x4 block in the output starts at `(2*r, 2*c)`.
6.  **Background Preservation:** The background color (white, 0) from the input effectively expands to fill the space in the larger output grid that isn't occupied by the colored 4x4 blocks.

**Facts Documentation:**


```yaml
task_context:
  grid_dimensionality: 2D
  color_palette: 0-9 (white background with sparse colored pixels)

input_elements:
  - object: Input Grid
    properties:
      - type: 2D array
      - size: variable (e.g., 10x10 in examples)
      - content: contains background pixels and isolated colored pixels
  - object: Background Pixel
    properties:
      - color: 0 (white)
  - object: Colored Pixel
    properties:
      - color: 1-9 (non-white)
      - size: 1x1
      - position: (row, column) coordinates (0-based index)
      - relationship: isolated from other colored pixels

output_elements:
  - object: Output Grid
    properties:
      - type: 2D array
      - size: scaled version of Input Grid (2*height, 2*width)
      - content: contains background pixels and expanded colored blocks
  - object: Background Pixel
    properties:
      - color: 0 (white)
  - object: Colored Block
    properties:
      - color: 1-9 (matches the color of the corresponding input pixel)
      - size: 4x4
      - position: top-left (Row, Column) coordinates (0-based index)
      - relationship: derived from a single Colored Pixel in the input

transformation:
  actions:
    - name: Scaling
      input: Input Grid
      output: Output Grid
      details: Output grid dimensions are double the input grid dimensions (height * 2, width * 2).
    - name: Mapping and Expansion
      input: Colored Pixel at (r, c) with color C
      output: Colored Block of color C
      details: Each non-white input pixel is mapped to a 4x4 block in the output.
    - name: Positioning
      input: Input pixel position (r, c)
      output: Output block top-left position (R, C)
      details: The top-left corner (R, C) of the 4x4 output block is determined by the input pixel position (r, c) using the formula R = 2*r, C = 2*c.
    - name: Filling
      input: Output Grid, Colored Blocks
      output: Final Output Grid
      details: Initialize the output grid with the background color (white). Place the 4x4 colored blocks at their calculated positions.

relationships:
  - input_pixel_to_output_block: Each non-white pixel in the input corresponds one-to-one with a 4x4 block of the same color in the output.
  - coordinate_mapping: The top-left coordinate of the output block `(R, C)` is derived from the input pixel coordinate `(r, c)` by `(R, C) = (2*r, 2*c)`.
```


**Natural Language Program:**

1.  Accept the input grid.
2.  Determine the height (H) and width (W) of the input grid.
3.  Create a new output grid with dimensions (2\*H) rows and (2\*W) columns. Initialize all cells of this output grid to the background color (white, 0).
4.  Iterate through each cell of the input grid, examining its row index `r` (from 0 to H-1) and column index `c` (from 0 to W-1).
5.  Identify the color `C` of the input cell at `(r, c)`.
6.  Check if the color `C` is not the background color (i.e., `C != 0`).
7.  If the color `C` is not the background color:
    a. Calculate the starting row `R` and starting column `C_start` for the corresponding 4x4 block in the output grid using the mapping: `R = 2 * r` and `C_start = 2 * c`.
    b. Fill the 4x4 area in the output grid starting at `(R, C_start)` with the color `C`. This involves setting the color `C` for all cells `(row_out, col_out)` where `R <= row_out < R + 4` and `C_start <= col_out < C_start + 4`.
8.  After iterating through all input cells, return the completed output grid.
