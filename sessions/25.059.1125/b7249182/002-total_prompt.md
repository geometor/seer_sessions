# b7249182 • 002 • example_3 • investigate_coder

---

## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=640x896 at 0x7F4C1B700250>

**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0
0 0 2 0 0 0 2 0 0 0
0 0 8 0 0 0 8 0 0 0
0 0 8 8 8 8 8 0 0 0
0 0 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0
0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=640x896 at 0x7F4C1B701850>

## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=832x640 at 0x7F4C1B700BD0>

**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 3 3 1 1 0 0 0 0
0 0 0 0 0 3 0 0 1 0 0 0 0
0 3 3 3 3 3 0 0 1 1 1 1 1
0 0 0 0 0 3 0 0 1 0 0 0 0
0 0 0 0 0 3 3 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=832x640 at 0x7F4C1B700650>

## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1152x640 at 0x7F4C1B703CD0>

**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 5 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 0 0 8 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 8 8 8 8 8 8 0
0 0 0 0 0 0 0 0 5 0 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 5 5 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1152x640 at 0x7F4C1B6BCAD0>
<PIL.Image.Image image mode=RGB size=2752x1872 at 0x7F4C231AACD0>Okay, here's my analysis of the provided input-output examples, structured as a report:

**Perception of Elements:**

The task involves 2D grids containing single-digit integers (0-9), representing different colors. The transformation seems to involve identifying specific colored pixels in the input and creating cross-like shapes of those colors in the output, centered on the original pixel locations. The size and orientation of the cross appear to be consistent within each example and across examples, but the input grids vary in dimension. There's likely a fixed cross pattern that's applied whenever a non-zero pixel is encountered in the input.

**YAML Fact Documentation:**


```yaml
facts:
  - observation: |
      Input and output grids are 2D arrays of integers, representing colors.
  - object_identification: |
      Non-zero pixels in the input grid are treated as seed points.
  - object_properties:
      - seed_color: Color of the seed pixel (input).
      - cross_color:  Same as seed_color (output).
      - cross_shape: A cross or plus (+) shape.
      - cross_size: A fixed size, extending two pixels in each cardinal direction from the center.
  - action: |
      Create a cross shape in the output grid, centered on the seed point.
  - relationship: |
       The color of the cross in the output corresponds to the color of the seed pixel in the input.
       All non-zero pixels are converted.
       The arms of each colored cross extend for a fixed distance, or until
       they meet the edge of the grid.
       The background remains unchanged (color 0)
```


**Natural Language Program:**

1.  **Iterate** through each pixel of the input grid.
2.  **Identify** seed pixels: If a pixel has a non-zero value (representing a color other than the background), consider it a "seed point."
3.  **For each seed point:**
    *   **Center Cross:** In the output grid, at the same coordinates as the seed point, place a pixel of the same color.
    *   **Extend Arms:** Extend "arms" of the cross outwards from the center, two pixels up, down, left, and right. Each arm pixel should have the same color as the seed point.
    *   **Handle Grid Boundaries**: If the extension of an arm would go beyond the boundaries of the grid, stop the extension at the edge.
4. **Background**: If no cross is formed for that coordinate, set the value to 0.

This program describes a process of identifying colored pixels and rendering a fixed-size cross pattern of the same color, centered at those locations in the output grid.

**INSTRUCTIONS**

- generate a Python module to represent the natural language program 
- follow the template below
- all common math and science libraries are available
- create docstring only at top - but comment the workflow in the function
- use helper functions for common operations like finding objects, counting,
  measuring, moving, etc. 

remember - we are working iteratively - so this code will inform your future
self as we converge on the solution

*template:*

```python
"""
{{ natural language description of the transformation rule }}
"""

{{ imports }}

def transform(input_grid):
    # initialize output_grid

    # change output pixels 

    return output_grid

```
