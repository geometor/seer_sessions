{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Identify contiguous regions of magenta (6) and gray (5) pixels. White (0) is the background.\n2.  **Remove Gray:** Remove all gray objects from the grid.\n3.  **Rotate Magenta:** Rotate the magenta object 90 degrees counter-clockwise. The center of rotation is the magenta pixel in the input grid which, after rotation, would be the lowest of the topmost magenta pixels of the output grid.\n4.  **Adjust After Rotation:** After rotating, shift the entire magenta object down by one row, *if* after the rotation, the bottom edge of the magenta object is on the same row as the bottom edge of the *unrotated* magenta object.  If not, leave as rotated.\n5.  **Output:** The final grid contains only the rotated and potentially adjusted magenta object on the white background.\n\"\"\"\n\nimport numpy as np\n\ndef find_object(grid, color):\n    coords = np.argwhere(grid == color)\n    if coords.size == 0:\n        return None\n    return coords\n\ndef rotate_point(point, center):\n    \"\"\"Rotates a point 90 degrees counter-clockwise around a center.\"\"\"\n    row, col = point\n    center_row, center_col = center\n    translated_row = row - center_row\n    translated_col = col - center_col\n    rotated_row = -translated_col\n    rotated_col = translated_row\n    new_row = rotated_row + center_row\n    new_col = rotated_col + center_col\n    return (new_row, new_col)\n\ndef get_rotation_center(magenta_coords, output_coords):\n    \"\"\"\n    Calculates the center of rotation. The center is defined as the magenta\n    pixel that, after a 90 degree counter clockwise rotation, ends at the\n    lowest of the top-most pixels of the output\n    \"\"\"\n\n    #find top row of the output\n    min_row_out = min(output_coords, key=lambda item: item[0])[0]\n    top_output_coords = [ (r,c) for r,c in output_coords if r == min_row_out ]\n    #of the top row, find lowest (right-most)\n    lowest_top = max(top_output_coords, key=lambda item: item[1])\n\n    #find matching pixel in input\n    for r, c in magenta_coords:\n      rotated_r, rotated_c = rotate_point( (r,c), (r,c) )\n      if (rotated_r, rotated_c) == lowest_top:\n        return (r,c)\n\n    return None\n\n\ndef rotate_magenta_object(grid, magenta_coords, center):\n    \"\"\"Rotates the magenta object 90 degrees counter-clockwise.\"\"\"\n    rotated_grid = np.copy(grid)\n    if center is None:\n        return rotated_grid, []  # No magenta object to rotate\n\n    new_magenta_coords = []\n    for r, c in magenta_coords:\n        rotated_grid[r, c] = 0  # Clear the original magenta pixel\n\n    for r, c in magenta_coords:\n        new_r, new_c = rotate_point((r, c), center)\n        new_magenta_coords.append((new_r, new_c))\n\n    return rotated_grid, new_magenta_coords\n\ndef adjust_after_rotation(grid, original_coords, rotated_coords):\n    \"\"\"\n    Shifts the rotated object down by one row if the bottom edge of the\n    rotated object is on the same row as the bottom edge of the original\n    object.\n    \"\"\"\n    if not original_coords or not rotated_coords:\n        return grid\n\n    original_bottom_row = max(original_coords, key=lambda item: item[0])[0]\n    rotated_bottom_row = max(rotated_coords, key=lambda item: item[0])[0]\n\n    if original_bottom_row == rotated_bottom_row:\n        shifted_coords = [(r + 1, c) for r, c in rotated_coords]\n        #clear existing\n        for r, c in rotated_coords:\n            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:\n                grid[r,c] = 0\n\n        #add shifted\n        for r, c in shifted_coords:\n            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:\n                grid[r, c] = 6\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n\n    # Find and Remove Gray (5)\n    gray_coords = find_object(output_grid, 5)\n    if gray_coords is not None:\n        for r, c in gray_coords:\n            output_grid[r, c] = 0\n\n    # Find Magenta (6)\n    magenta_coords = find_object(output_grid, 6)\n    if magenta_coords is None:\n        return output_grid #no magenta, return\n\n    #predict output coords\n    rotated_grid, predicted_coords = rotate_magenta_object(output_grid, magenta_coords, magenta_coords[0])\n    valid_predicted_coords = []\n    for r,c in predicted_coords:\n      if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n          rotated_grid[r,c] = 6 #temp set to find center\n          valid_predicted_coords.append( (r,c) )\n\n    # Rotate Magenta Object\n    center = get_rotation_center(magenta_coords, valid_predicted_coords)\n    rotated_grid, new_magenta_coords = rotate_magenta_object(output_grid, magenta_coords, center)\n    output_grid = rotated_grid\n\n    #set new magenta pixels - within bounds\n    valid_new_magenta_coords = []\n    for r,c in new_magenta_coords:\n      if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n          output_grid[r,c] = 6\n          valid_new_magenta_coords.append( (r,c) )\n\n\n    # Adjust After Rotation\n    adjust_after_rotation(output_grid, magenta_coords, valid_new_magenta_coords)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5017,
    "candidates_token_count": 1496,
    "total_token_count": 6513,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 12.934736,
  "response_file": "022-response.json"
}