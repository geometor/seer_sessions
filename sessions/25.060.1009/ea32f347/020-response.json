{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Gray Blocks:** Locate all contiguous regions of gray (5) pixels within the input grid.\n\n2.  **Classify Orientation:** For each identified gray block, determine its orientation:\n    *   **Horizontal:** If the block is wider than it is tall.\n    *   **Vertical:** If the block is taller than it is wide.\n\n3.  **Recolor Vertical Blocks:** Transform all pixels within vertical gray blocks to yellow (4).\n\n4.  **Recolor Horizontal Blocks:**\n    *   Identify sets of *vertically stacked* horizontal gray blocks. Blocks are considered stacked if they have at least one pixel in the same column and are either adjacent or separated only by rows of non-gray pixels.\n    *    Within each stack:\n        *   Recolor the **topmost** horizontal block to blue (1).\n        *   Recolor the **bottommost** horizontal block to red (2).\n        *    Blocks that are neither top nor bottom remain unchanged.\n\n5.  **Preserve Other Colors:** Ensure that all pixels which were not part of a gray block in the input grid retain their original colors.\n\"\"\"\n\nimport numpy as np\n\ndef find_contiguous_blocks(grid, color):\n    # Find contiguous blocks of a given color in the grid.\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    def dfs(r, c, current_block):\n        if (r < 0 or r >= grid.shape[0] or c < 0 or c >= grid.shape[1] or\n                visited[r, c] or grid[r, c] != color):\n            return\n        visited[r, c] = True\n        current_block.append((r, c))\n        dfs(r + 1, c, current_block)\n        dfs(r - 1, c, current_block)\n        dfs(r, c + 1, current_block)\n        dfs(r, c - 1, current_block)\n\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] == color and not visited[r, c]:\n                current_block = []\n                dfs(r, c, current_block)\n                blocks.append(current_block)\n    return blocks\n\ndef classify_orientation(block):\n    # Classify the orientation of a block as horizontal or vertical.\n    rows, cols = zip(*block)\n    height = max(rows) - min(rows) + 1\n    width = max(cols) - min(cols) + 1\n    return \"horizontal\" if width > height else \"vertical\"\n\ndef are_blocks_stacked(block1, block2, grid):\n    # Check if two horizontal blocks are vertically stacked.\n    cols1 = set([c for r, c in block1])\n    cols2 = set([c for r, c in block2])\n\n    # Check for shared columns\n    if not cols1.intersection(cols2):\n        return False\n\n    # get rows and sort\n    rows1 = sorted(list(set([r for r,c in block1])))\n    rows2 = sorted(list(set([r for r,c in block2])))\n   \n    # Check for adjacency or separation by non-gray pixels\n    if rows1[-1] < rows2[0]: # block 1 is above\n      for r in range(rows1[-1] + 1, rows2[0]):\n        for c in cols1.intersection(cols2):\n          if grid[r,c] == 5:\n            return False # separated by gray\n      return True\n    elif rows2[-1] < rows1[0]:\n      for r in range(rows2[-1] + 1, rows1[0]): # block 2 is above\n        for c in cols1.intersection(cols2):\n          if grid[r,c] == 5:\n            return False\n      return True\n          \n    return False\n\ndef get_stacked_horizontal_blocks(horizontal_blocks, grid):\n    # Group horizontal blocks into vertically stacked sets.\n    stacked_sets = []\n    processed = [False] * len(horizontal_blocks)\n\n    for i in range(len(horizontal_blocks)):\n        if not processed[i]:\n            current_stack = [horizontal_blocks[i]]\n            processed[i] = True\n            for j in range(i + 1, len(horizontal_blocks)):\n                if not processed[j]:\n                    for block in current_stack:\n                        if are_blocks_stacked(block, horizontal_blocks[j], grid):\n                            current_stack.append(horizontal_blocks[j])\n                            processed[j] = True\n                            break  # Move to the next block after finding a match\n            stacked_sets.append(current_stack)\n    return stacked_sets\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    gray_blocks = find_contiguous_blocks(output_grid, 5)\n\n    # get horizontal and vertical blocks\n    horizontal_blocks = []\n    for block in gray_blocks:\n        if classify_orientation(block) == \"vertical\":\n            for r, c in block:\n                output_grid[r,c] = 4 # recolor vertical\n        else:\n          horizontal_blocks.append(block)\n\n    # get stacked sets\n    stacked_sets = get_stacked_horizontal_blocks(horizontal_blocks, output_grid)\n\n    # recolor horizontal based on stacking\n    for stack in stacked_sets:\n      if len(stack) > 0:\n        # find min and max rows - top and bottom\n        min_row = min([min(list(zip(*block))[0]) for block in stack])\n        max_row = max([max(list(zip(*block))[0]) for block in stack])\n\n        for block in stack:\n          block_min_row = min(list(zip(*block))[0])\n          # recolor top and bottom\n          if block_min_row == min_row:\n            for r, c in block:\n              output_grid[r,c] = 1 # top\n          elif block_min_row == max_row:\n            for r,c in block:\n              output_grid[r,c] = 2  # bottom\n          # else leave the same\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3554,
    "candidates_token_count": 1473,
    "total_token_count": 5027,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 13.707346,
  "response_file": "020-response.json"
}