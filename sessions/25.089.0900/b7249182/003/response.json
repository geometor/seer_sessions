{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThis transformation rule identifies two distinct non-background colored pixels \nin the input grid. Based on their relative positions (same row or same column), \nit draws two 'staple' or 'U' shapes. \n\nIf the pixels are in the same row (horizontal orientation):\n- Two vertical segments of length 5 are drawn, centered on the shared row (vr), \n  with their columns (vc_left, vc_right) offset from the midpoint column (mc).\n- Each original pixel is connected to the center of its corresponding vertical \n  segment by a horizontal line.\n- Two horizontal 'prongs' extend from the top ends of the vertical segments \n  towards the midpoint column.\n- Two horizontal 'prongs' extend from the bottom ends of the vertical segments \n  towards the midpoint column.\n\nIf the pixels are in the same column (vertical orientation):\n- Two horizontal segments of length 5 are drawn, centered on the shared column (hc), \n  with their rows (hr_top, hr_bottom) offset from the midpoint row (mr).\n- Each original pixel is connected to the center of its corresponding horizontal \n  segment by a vertical line.\n- Two vertical 'prongs' extend from the left ends of the horizontal segments \n  towards the midpoint row.\n- Two vertical 'prongs' extend from the right ends of the horizontal segments \n  towards the midpoint row.\n\nThe color of each staple shape corresponds to the color of its originating pixel. \nThe prongs meet or approach each other near the midpoint line/column.\n\"\"\"\n\ndef find_colored_pixels(grid):\n    \"\"\"Finds all non-background (non-zero) pixels.\"\"\"\n    pixels = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] != 0:\n                pixels.append({'row': r, 'col': c, 'color': grid[r, c]})\n    # Sort by row then column for consistent ordering if needed, though logic later handles position\n    pixels.sort(key=lambda p: (p['row'], p['col']))\n    return pixels\n\ndef draw_pixel(grid, r, c, color):\n    \"\"\"Draws a pixel if within grid bounds.\"\"\"\n    rows, cols = grid.shape\n    if 0 <= r < rows and 0 <= c < cols:\n        grid[r, c] = color\n\ndef draw_vline(grid, r_start, r_end, c, color):\n    \"\"\"Draws a vertical line.\"\"\"\n    for r in range(min(r_start, r_end), max(r_start, r_end) + 1):\n        draw_pixel(grid, r, c, color)\n\ndef draw_hline(grid, r, c_start, c_end, color):\n    \"\"\"Draws a horizontal line.\"\"\"\n    for c in range(min(c_start, c_end), max(c_start, c_end) + 1):\n        draw_pixel(grid, r, c, color)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by drawing connected staple shapes based on two anchor pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_grid = np.zeros_like(input_np)\n\n    # Find the two anchor pixels\n    pixels = find_colored_pixels(input_np)\n    if len(pixels) != 2:\n        # Return empty grid if not exactly two anchor pixels are found\n        return output_grid.tolist() \n\n    p1 = pixels[0]\n    p2 = pixels[1]\n    \n    # Calculate midpoint (can be float)\n    mr = (p1['row'] + p2['row']) / 2.0\n    mc = (p1['col'] + p2['col']) / 2.0\n\n    # Determine orientation and draw shapes\n    if p1['row'] == p2['row']:  # Horizontal orientation\n        vr = p1['row'] # Center row is the shared row\n        \n        # Assign left/right based on column\n        p_left, p_right = (p1, p2) if p1['col'] < p2['col'] else (p2, p1)\n        color_left, color_right = p_left['color'], p_right['color']\n        c_left, c_right = p_left['col'], p_right['col']\n\n        # Calculate center columns for the vertical staple legs\n        # These columns are where the 5-pixel vertical segments are centered.\n        vc_left = math.floor(mc - 1) \n        vc_right = math.ceil(mc + 1) \n        \n        # --- Draw Left Staple (p_left) ---\n        # 1. Main vertical segment (length 5)\n        draw_vline(output_grid, vr - 2, vr + 2, vc_left, color_left)\n        # 2. Connector horizontal segment (from original pixel to main segment center)\n        draw_hline(output_grid, vr, c_left, vc_left, color_left)\n        # 3. Top prong horizontal segment (from top of main segment towards midpoint)\n        draw_hline(output_grid, vr - 2, vc_left, math.floor(mc), color_left)\n        # 4. Bottom prong horizontal segment (from bottom of main segment towards midpoint)\n        draw_hline(output_grid, vr + 2, vc_left, math.floor(mc), color_left)\n\n        # --- Draw Right Staple (p_right) ---\n         # 1. Main vertical segment (length 5)\n        draw_vline(output_grid, vr - 2, vr + 2, vc_right, color_right)\n        # 2. Connector horizontal segment (from original pixel to main segment center)\n        draw_hline(output_grid, vr, c_right, vc_right, color_right)\n        # 3. Top prong horizontal segment (from midpoint towards top of main segment)\n        draw_hline(output_grid, vr - 2, math.ceil(mc), vc_right, color_right)\n        # 4. Bottom prong horizontal segment (from midpoint towards bottom of main segment)\n        draw_hline(output_grid, vr + 2, math.ceil(mc), vc_right, color_right)\n\n\n    elif p1['col'] == p2['col']:  # Vertical orientation\n        hc = p1['col'] # Center column is the shared column\n        \n        # Assign top/bottom based on row\n        p_top, p_bottom = (p1, p2) if p1['row'] < p2['row'] else (p2, p1)\n        color_top, color_bottom = p_top['color'], p_bottom['color']\n        r_top, r_bottom = p_top['row'], p_bottom['row']\n\n        # Calculate center rows for the horizontal staple bases\n        # These rows are where the 5-pixel horizontal segments are centered.\n        hr_top = math.floor(mr - 1)\n        hr_bottom = math.ceil(mr + 1)\n\n        # --- Draw Top Staple (p_top) ---\n        # 1. Main horizontal segment (length 5)\n        draw_hline(output_grid, hr_top, hc - 2, hc + 2, color_top)\n        # 2. Connector vertical segment (from original pixel to main segment center)\n        draw_vline(output_grid, r_top, hr_top, hc, color_top)\n        # 3. Left prong vertical segment (from left of main segment towards midpoint)\n        draw_vline(output_grid, hr_top, math.floor(mr), hc - 2, color_top)\n        # 4. Right prong vertical segment (from right of main segment towards midpoint)\n        draw_vline(output_grid, hr_top, math.floor(mr), hc + 2, color_top)\n\n        # --- Draw Bottom Staple (p_bottom) ---\n        # 1. Main horizontal segment (length 5)\n        draw_hline(output_grid, hr_bottom, hc - 2, hc + 2, color_bottom)\n        # 2. Connector vertical segment (from original pixel to main segment center)\n        draw_vline(output_grid, r_bottom, hr_bottom, hc, color_bottom)\n        # 3. Left prong vertical segment (from midpoint towards left of main segment)\n        draw_vline(output_grid, math.ceil(mr), hr_bottom, hc - 2, color_bottom)\n        # 4. Right prong vertical segment (from midpoint towards right of main segment)\n        draw_vline(output_grid, math.ceil(mr), hr_bottom, hc + 2, color_bottom)\n\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14634,
    "candidates_token_count": 2087,
    "total_token_count": 16721,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.937495,
  "retries": 1
}