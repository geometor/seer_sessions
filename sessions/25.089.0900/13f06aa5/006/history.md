
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 4 4 1 4 4 2 2
2 2 2 2 2 2 2 2 4 4 4 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 2 2 2 2 2
2 4 4 2 2 2 2 2 2 2 2 2 2 2
2 4 8 2 2 2 2 2 2 2 2 2 2 2
2 4 4 2 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 0
2 2 2 2 2 2 2 2 2 1 2 2 2 8
2 2 2 2 2 2 2 2 2 2 2 2 2 8
2 2 2 2 2 2 2 4 4 1 4 4 2 8
2 2 2 2 2 2 2 2 4 4 4 2 2 8
2 2 2 2 2 2 2 2 2 2 2 2 2 8
2 2 4 2 2 2 2 2 2 2 2 2 2 8
2 4 4 2 2 2 2 2 2 2 2 2 2 8
2 4 8 2 8 2 8 2 8 2 8 2 8 8
2 4 4 2 2 2 2 2 2 2 2 2 2 8
2 2 4 2 2 2 2 2 2 2 2 2 2 8
2 2 2 2 2 2 2 2 2 2 2 2 2 8
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 8 8 3 8 8 1
1 1 1 8 8 1 1 1 8 8 8 1 1
1 1 1 2 8 1 1 1 1 1 1 1 1
1 1 1 8 8 1 1 1 1 1 1 1 1
1 1 1 8 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
0 3 3 3 3 3 3 3 3 3 3 3 3
2 1 1 1 1 1 1 1 1 3 1 1 1
2 1 1 1 1 1 1 1 1 1 1 1 1
2 1 1 8 1 1 1 8 8 3 8 8 1
2 1 1 8 8 1 1 1 8 8 8 1 1
2 2 1 2 8 1 1 1 1 1 1 1 1
2 1 1 8 8 1 1 1 1 1 1 1 1
2 1 1 8 1 1 1 1 1 1 1 1 1
2 1 1 1 1 1 1 1 1 1 1 1 1
2 1 1 1 1 1 1 1 1 1 1 1 1
2 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3
3 3 3 1 1 6 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3 3
3 3 3 1 1 6 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3
6 6 6 6 6 6 6 6 6 6 6 6
```

Okay, let's analyze the task examples.

**Perception of Elements:**

1.  **Grid Structure:** The inputs and outputs are grids of colored pixels. The size of the grid remains the same between input and output.
2.  **Background Color:** Each input grid has a dominant background color (Red in Ex1, Blue in Ex2, Green in Ex3). This background color plays a role in the transformation.
3.  **Objects:** There are distinct objects made of colors different from the background. Some objects fully enclose a pixel of another color.
    *   Example 1: Yellow (4) objects enclose Blue (1) and Azure (8). Background is Red (2).
    *   Example 2: Azure (8) objects enclose Green (3) and Red (2). Background is Blue (1).
    *   Example 3: A Blue (1) object encloses Magenta (6). Background is Green (3).
4.  **Key Feature:** The core transformation seems triggered by these "contained" pixels â€“ single pixels completely surrounded by another color, which is itself distinct from the background.
5.  **Transformation Actions:**
    *   The contained pixel is removed (replaced by the background color).
    *   The color of the contained pixel (let's call it C1) is projected onto one of the grid's outer edges.
    *   The specific edge depends on the color C1: Blue(1)/Green(3) -> Top, Red(2) -> Left, Azure(8) -> Right, Magenta(6) -> Bottom.
    *   The position on the edge depends on the original position of C1: for Top/Bottom edges, the projection appears in the same column; for Left/Right edges, it appears in the same row.
    *   If two contained pixels exist and their projections land on intersecting edges (e.g., Top and Left, or Top and Right), the corner pixel at the intersection becomes White (0).
    *   The Magenta (6) case has an additional effect: the entire target edge row (Bottom) is filled with Magenta, and Magenta pixels are placed periodically down the original column below the original contained pixel's location.
    *   The containing object (color C2) and other parts of the grid remain unchanged unless overwritten by a projection or the background color fill.

**Facts (YAML):**


```yaml
task_description: Find pixels completely enclosed by an object of a different color (which is not the background color), replace the enclosed pixel with the background color, and project its original color onto a specific edge of the grid based on the color itself. Handle corner intersections and special rules for Magenta.

definitions:
  background_color: The most frequent color in the input grid.
  contained_pixel: A pixel at (r, c) with color C1 whose 8 direct neighbors all have color C2, where C2 is not the background_color.
  container_object: The object made of color C2 surrounding the contained_pixel.

transformations:
  - operation: find_contained_pixels
    description: Identify all contained_pixels, recording their color (C1), row (r), and column (c).
  - operation: process_contained_pixels
    description: For each contained pixel (C1, r, c) found:
      - action: replace_pixel
        location: (r, c)
        new_color: background_color
      - action: determine_projection
        based_on: C1
        rules:
          - color: Blue (1)
            target_edge: Top row (row 0)
            target_coord: (0, c)
          - color: Red (2)
            target_edge: Left column (col 0)
            target_coord: (r, 0)
          - color: Green (3)
            target_edge: Top row (row 0)
            target_coord: (0, c)
          - color: Azure (8)
            target_edge: Right column (col width-1)
            target_coord: (r, width-1)
          - color: Magenta (6)
            target_edge: Bottom row (row height-1)
            target_coord: (height-1, c)
            additional_actions:
              - fill_row:
                  row_index: height-1
                  color: Magenta (6)
              - place_pixels:
                  column_index: c
                  start_row: r + 2
                  step: 2
                  end_row: height - 2 # Inclusive or exclusive? Output suggests up to row 12 when height=15, r=2. So up to height-3? No, Ex3 output has (12, 5) filled. Let's say up to height-2 inclusive.
                  color: Magenta (6)
  - operation: apply_projections
    description: Paint the target_coord on the output grid with the color C1 for all non-Magenta projections. Magenta projections are handled during its special processing.
  - operation: handle_intersections
    description: If projections occurred onto two intersecting edges (e.g., Top and Left), set the corner pixel (e.g., (0,0)) to White (0). This applies to Top/Left, Top/Right corners based on examples.

unchanged_elements:
  - All pixels not part of a contained_pixel replacement or an edge/corner/Magenta projection remain the same as the input. This includes the container_object pixels (C2).

grid_properties:
  - dimensions: Input and output grids have the same height and width.
```


**Natural Language Program:**

1.  Initialize the output grid as an identical copy of the input grid.
2.  Determine the background color by finding the most frequent color in the input grid.
3.  Scan the input grid to locate all 'contained pixels'. A pixel at coordinates (`r`, `c`) with color `C1` is considered 'contained' if all eight of its immediate neighbors (horizontally, vertically, and diagonally) have the same color `C2`, where `C2` is different from the background color. Record the color `C1`, row `r`, and column `c` for each contained pixel found.
4.  Create a list to store details of the projections to be made later (color, target row, target column).
5.  Iterate through the recorded contained pixels (`C1`, `r`, `c`):
    a.  In the output grid, change the color of the pixel at (`r`, `c`) to the background color.
    b.  Based on the color `C1`:
        i.  If `C1` is Blue (1) or Green (3), add projection details (`C1`, 0, `c`) to the list.
        ii. If `C1` is Red (2), add projection details (`C1`, `r`, 0) to the list.
        iii.If `C1` is Azure (8), add projection details (`C1`, `r`, grid\_width - 1) to the list.
        iv. If `C1` is Magenta (6):
            1.  Fill the *entire* bottom row (row `grid_height - 1`) of the output grid with Magenta (6).
            2.  Starting from row `r + 2`, proceeding downwards in steps of 2, change the color of pixels in column `c` to Magenta (6), stopping at or before row `grid_height - 1`. (Effectively, fill (r+2, c), (r+4, c), ... as long as the row index is less than `grid_height - 1`).
            3.  (Note: The specific pixel (height-1, c) will also be set by the row fill).
6.  Apply the standard projections: Iterate through the projection list created in step 4. For each entry (`Color`, `TargetRow`, `TargetCol`), set the pixel at (`TargetRow`, `TargetCol`) in the output grid to `Color`.
7.  Check for and resolve corner intersections caused by projections:
    a.  If projections placed colors on both the Top edge (row 0) and the Left edge (column 0), set the pixel at (0, 0) to White (0).
    b.  If projections placed colors on both the Top edge (row 0) and the Right edge (column `grid_width - 1`), set the pixel at (0, `grid_width - 1`) to White (0).
8.  The final state of the output grid is the result.
```python
import numpy as np
from collections import Counter

"""
Identify pixels completely enclosed by an object of a different color (where the enclosing object's color is not the background color). 
Replace the enclosed pixel with the background color.
Project the original color (C1) of the enclosed pixel onto a specific edge of the grid:
- Blue(1) or Green(3) -> Top edge, same column.
- Red(2) -> Left edge, same row.
- Azure(8) -> Right edge, same row.
- Magenta(6) -> Special handling: Fill the entire bottom row with Magenta(6), and place Magenta(6) pixels periodically down the original column below the enclosed pixel's location (every 2 rows, starting r+2, stopping before the last row).
Apply the projections to the output grid.
If projections land on both the Top and Left edges, set the top-left corner (0, 0) to White(0).
If projections land on both the Top and Right edges, set the top-right corner (0, width-1) to White(0).
Pixels not otherwise modified remain unchanged.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid."""
    # Using Counter is slightly more direct for finding the most common element
    counts = Counter(grid.flatten())
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_contained_pixels(grid, background_color):
    """Finds pixels fully enclosed by 8 neighbors of the same non-background color."""
    height, width = grid.shape
    contained = []
    # Iterate only over pixels that *can* have 8 neighbors (1 to height-2, 1 to width-2)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            center_color = grid[r, c]
            
            # Optimization: If center pixel is background, it cannot be a contained pixel C1
            if center_color == background_color:
                continue

            # Get potential container color C2 from the first neighbor (top-left)
            container_color = grid[r-1, c-1] 

            # C2 cannot be the background color
            if container_color == background_color:
                continue
                
            # C2 cannot be the same as the center color C1
            if container_color == center_color:
                continue

            # Check if all 8 neighbors match the potential container color C2
            all_neighbors_match = True
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    # Inner loop guarantees neighbors are within bounds
                    if grid[r + dr, c + dc] != container_color:
                        all_neighbors_match = False
                        break
                if not all_neighbors_match:
                    break
            
            # If all neighbors match and meet criteria, it's a contained pixel
            if all_neighbors_match:
                # Store C1 (center color) and its location (r, c)
                contained.append({'C1': center_color, 'r': r, 'c': c}) 
                
    return contained

def transform(input_grid):
    """
    Applies the transformation rule based on contained pixels and projections.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = output_grid.shape

    # Determine the background color
    background_color = find_background_color(input_grid_np)

    # Find all contained pixels
    contained_pixels = find_contained_pixels(input_grid_np, background_color)

    # Store details for standard projections
    projections_to_make = []
    # Track which edges received standard projections for intersection checks
    projected_top = False
    projected_left = False
    projected_right = False

    # Process each contained pixel
    for item in contained_pixels:
        C1, r, c = item['C1'], item['r'], item['c']

        # Step 1: Replace the contained pixel with the background color
        output_grid[r, c] = background_color

        # Step 2: Determine projection target or special actions based on C1
        if C1 == 1 or C1 == 3: # Blue (1) or Green (3) -> Top edge
            target_r, target_c = 0, c
            projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
            projected_top = True # Mark that a projection hit the top edge
        elif C1 == 2: # Red (2) -> Left edge
            target_r, target_c = r, 0
            projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
            projected_left = True # Mark that a projection hit the left edge
        elif C1 == 8: # Azure (8) -> Right edge
            target_r, target_c = r, width - 1
            projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
            projected_right = True # Mark that a projection hit the right edge
        elif C1 == 6: # Magenta (6) -> Special rules
            # Action 1: Fill the entire bottom row with Magenta (6)
            if height > 0: # Check if grid has rows
                output_grid[height - 1, :] = 6
            
            # Action 2: Place Magenta (6) periodically down the original column 'c'
            # Start at r+2, step by 2, stop *before* the last row (height-1)
            for row_idx in range(r + 2, height - 1, 2):
                 # The range ensures row_idx is always < height - 1
                 output_grid[row_idx, c] = 6
            # Note: Magenta doesn't add to projections_to_make and doesn't trigger corner intersections itself

    # Step 3: Apply the standard projections collected earlier
    for proj in projections_to_make:
        # Check bounds just in case, though logic should ensure validity
        if 0 <= proj['r'] < height and 0 <= proj['c'] < width:
            output_grid[proj['r'], proj['c']] = proj['color']

    # Step 4: Handle corner intersections caused by standard projections
    # Check Top-Left corner
    if projected_top and projected_left:
        if 0 < height and 0 < width: # Ensure grid is at least 1x1
             output_grid[0, 0] = 0 # White

    # Check Top-Right corner
    if projected_top and projected_right:
        if 0 < height and width > 0: # Ensure grid has a top-right corner index
            output_grid[0, width - 1] = 0 # White

    return output_grid.tolist() # Return as list of lists
```
```python
import numpy as np
from collections import Counter

"""
Identify isolated pixels (triggers), replace them with the background color, and project their original color onto a grid edge based on the color. 
A trigger pixel is a non-background pixel where none of its 8 neighbors share its color.
Projection Rules:
- Blue(1) or Green(3) -> Top edge, same column.
- Red(2) -> Left edge, same row.
- Azure(8) -> Right edge, same row.
- Magenta(6) -> Special handling: Fill the entire bottom row with Magenta(6), and place Magenta(6) pixels periodically down the original column below the trigger pixel's location (every 2 rows, starting r+2, stopping before the last row).
Apply standard projections after finding all triggers.
Handle corner intersections: If standard projections land on both Top and Left edges, set top-left (0,0) to White(0). If on Top and Right, set top-right (0, width-1) to White(0).
Pixels not otherwise modified remain unchanged.
"""

def find_background_color(grid_np):
    """Finds the most frequent color in the grid."""
    if grid_np.size == 0:
        return 0 # Default for empty grid
    counts = Counter(grid_np.flatten())
    # If multiple colors have the same max frequency, Counter returns one arbitrarily, which is fine.
    background_color = counts.most_common(1)[0][0]
    return background_color

def transform(input_grid):
    """
    Applies the transformation rule based on isolated trigger pixels and projections.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_grid_np)
    height, width = output_grid.shape

    if height == 0 or width == 0:
        return [] # Handle empty grid case

    # Determine the background color
    background_color = find_background_color(input_grid_np)

    # Store details for standard projections
    projections_to_make = []
    # Track which edges received standard projections for intersection checks
    projected_top = False
    projected_left = False
    projected_right = False

    # Iterate through each pixel to find triggers
    for r in range(height):
        for c in range(width):
            C1 = input_grid_np[r, c]

            # Condition 1: Must not be background color
            if C1 == background_color:
                continue

            # Condition 2: Check neighbors - none should match C1
            is_trigger = True
            found_any_neighbor = False # Ensure pixel is not truly isolated in a 1x1 grid situation (unlikely in ARC but good practice)
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = r + dr, c + dc

                    # Check if neighbor is within bounds
                    if 0 <= nr < height and 0 <= nc < width:
                        found_any_neighbor = True
                        if input_grid_np[nr, nc] == C1:
                            is_trigger = False
                            break # Found a neighbor with same color, not a trigger
            
            if not found_any_neighbor and (height > 1 or width > 1):
                 # If no neighbors exist (e.g., 1x1 grid) it cannot be isolated *from neighbors*
                 # We only consider pixels with potential neighbors as triggers based on this rule
                 is_trigger = False

            if is_trigger:
                 # If the loop completed without finding a neighbor of color C1, it's a trigger
                
                # Action 1: Replace trigger pixel with background color in output grid
                output_grid[r, c] = background_color

                # Action 2: Determine projection or special action based on C1
                if C1 == 1 or C1 == 3: # Blue (1) or Green (3) -> Top edge
                    target_r, target_c = 0, c
                    projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
                    projected_top = True 
                elif C1 == 2: # Red (2) -> Left edge
                    target_r, target_c = r, 0
                    projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
                    projected_left = True 
                elif C1 == 8: # Azure (8) -> Right edge
                    target_r, target_c = r, width - 1
                    projections_to_make.append({'color': C1, 'r': target_r, 'c': target_c})
                    projected_right = True 
                elif C1 == 6: # Magenta (6) -> Special rules (apply directly to output_grid)
                    # Fill the entire bottom row
                    if height > 0: 
                        output_grid[height - 1, :] = 6
                    
                    # Place Magenta periodically down the original column 'c'
                    # Start at r+2, step by 2, stop *before* the last row (height-1)
                    for row_idx in range(r + 2, height - 1, 2):
                        # Check col bounds just in case, though 'c' comes from valid coords
                        if 0 <= c < width:
                            output_grid[row_idx, c] = 6

    # Apply the collected standard projections after finding all triggers
    for proj in projections_to_make:
        # Check bounds just in case, though logic should ensure validity
        if 0 <= proj['r'] < height and 0 <= proj['c'] < width:
            output_grid[proj['r'], proj['c']] = proj['color']

    # Handle corner intersections caused by standard projections
    # Check Top-Left corner
    if projected_top and projected_left:
        if height > 0 and width > 0: # Ensure grid is at least 1x1
             output_grid[0, 0] = 0 # White

    # Check Top-Right corner
    if projected_top and projected_right:
        if height > 0 and width > 0: # Ensure grid has a top-right corner index
            output_grid[0, width - 1] = 0 # White

    return output_grid.tolist() # Return as list of lists
```
```python
import numpy as np
from collections import Counter

"""
Identify unique non-background pixels (triggers), and based on the trigger color, fill a corresponding edge of the grid with that color. 
A trigger pixel is one whose color is not the background color and appears exactly once in the entire grid.
Projection/Fill Rules:
- Blue(1) or Green(3) -> Fill Top edge (row 0).
- Red(2) -> Fill Left edge (column 0).
- Azure(8) -> Fill Right edge (column width-1).
- Magenta(6) -> Fill Bottom edge (row height-1). 
  Additionally, fill pixels in the original trigger column 'c' at rows r+2, r+4, ... up to height-2 with Magenta(6).
Handle corner intersections: 
- If Top and Left edges are filled, set top-left (0,0) to White(0). 
- If Top and Right edges are filled, set top-right (0, width-1) to White(0).
The output grid starts as a copy of the input, and pixels are overwritten by the edge/column/corner fills.
"""

def find_background_color(grid_np):
    """Finds the most frequent color in the grid."""
    if grid_np.size == 0:
        return 0 # Default for empty grid
    counts = Counter(grid_np.flatten())
    # If multiple colors have the same max frequency, Counter returns one arbitrarily, which is fine.
    background_color = counts.most_common(1)[0][0]
    return background_color

def transform(input_grid):
    """
    Applies the transformation rule based on unique trigger pixels and edge fills.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    height, width = input_grid_np.shape

    if height == 0 or width == 0:
        return [] # Handle empty grid case

    # Initialize output grid as a copy of the input
    output_grid = np.copy(input_grid_np)

    # Determine the background color
    background_color = find_background_color(input_grid_np)

    # Count occurrences of each color
    color_counts = Counter(input_grid_np.flatten())

    # Find trigger pixels (color != background, count == 1)
    triggers = []
    for r in range(height):
        for c in range(width):
            color_C1 = input_grid_np[r, c]
            if color_C1 != background_color and color_counts[color_C1] == 1:
                triggers.append({'C1': color_C1, 'r': r, 'c': c})

    # Keep track of which edges have been filled
    filled_top = False
    filled_left = False
    filled_right = False
    # filled_bottom = False # Not needed for corner checks, but Magenta fills it

    # Process each trigger pixel
    for trigger in triggers:
        C1, r, c = trigger['C1'], trigger['r'], trigger['c']

        # Apply edge fill based on C1
        if C1 == 1 or C1 == 3: # Blue (1) or Green (3) -> Fill Top edge
            if height > 0: # Ensure there is a top row
                output_grid[0, :] = C1
                filled_top = True
        elif C1 == 2: # Red (2) -> Fill Left edge
             if width > 0: # Ensure there is a left column
                output_grid[:, 0] = C1
                filled_left = True
        elif C1 == 8: # Azure (8) -> Fill Right edge
            if width > 0: # Ensure there is a right column
                output_grid[:, width - 1] = C1
                filled_right = True
        elif C1 == 6: # Magenta (6) -> Fill Bottom edge + special column fill
            # Fill bottom edge
            if height > 0: # Ensure there is a bottom row
                output_grid[height - 1, :] = 6
                # filled_bottom = True # Track if needed later

            # Special column fill below the trigger
            # Start at r+2, step by 2, stop *before* the last row (height-1)
            for row_idx in range(r + 2, height - 1, 2):
                 # Check col bounds just in case (should be valid)
                 if 0 <= c < width:
                    output_grid[row_idx, c] = 6

    # Handle corner intersections after all edges are processed
    # Check Top-Left corner (White = 0)
    if filled_top and filled_left:
        if height > 0 and width > 0: # Ensure corner exists
             output_grid[0, 0] = 0 

    # Check Top-Right corner (White = 0)
    if filled_top and filled_right:
        if height > 0 and width > 0: # Ensure corner exists
            output_grid[0, width - 1] = 0 

    # Return the modified grid as a list of lists
    return output_grid.tolist()
```
