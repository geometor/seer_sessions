{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef _find_reachable_pixels(grid):\n    \"\"\"\n    Finds pixels reachable from the border without crossing blue (1) pixels.\n    Uses Breadth-First Search (BFS).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: A boolean mask where True indicates a reachable pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    queue = deque()\n\n    # Add border cells that are not blue (1) to the queue\n    for r in range(rows):\n        if grid[r, 0] != 1:\n            queue.append((r, 0))\n            reachable_mask[r, 0] = True\n        if grid[r, cols - 1] != 1:\n            queue.append((r, cols - 1))\n            reachable_mask[r, cols - 1] = True\n    for c in range(1, cols - 1):\n        if grid[0, c] != 1:\n            queue.append((0, c))\n            reachable_mask[0, c] = True\n        if grid[rows - 1, c] != 1:\n            queue.append((rows - 1, c))\n            reachable_mask[rows - 1, c] = True\n\n    # Perform BFS\n    while queue:\n        r, c = queue.popleft()\n\n        # Check neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not already visited, and if not blue\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not reachable_mask[nr, nc] and grid[nr, nc] != 1:\n                reachable_mask[nr, nc] = True\n                queue.append((nr, nc))\n\n    return reachable_mask\n\ndef _manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify regions: 'background' (reachable from border without crossing blue),\n       'containers' (blue pixels), and 'enclosed' (unreachable non-blue pixels).\n    2. Identify 'seed' pixels: non-white, non-blue pixels in the background.\n    3. Fill background white pixels: Each white background pixel takes the color\n       of the nearest seed pixel (Manhattan distance, tie-breaking by row then column).\n    4. Transform containers and enclosed areas:\n        a. Find all 'internal colors' (non-white, non-blue colors in the enclosed area).\n        b. Determine 'wall_color' for blue pixels: Red (2) if Red (2) is an internal color, else Azure (8).\n        c. Determine 'fill_color' for enclosed white pixels: Green (3) if Green (3) is internal,\n           else Magenta (6) if Magenta (6) is internal, else Azure (8).\n        d. Update blue pixels to 'wall_color'.\n        e. Update enclosed white pixels to 'fill_color'.\n        f. Other pixels (seeds, internal colors) keep their original color.\n    \"\"\"\n    \n    input_grid = np.array(input_grid)\n    rows, cols = input_grid.shape\n    output_grid = np.copy(input_grid) # Initialize output grid as a copy\n\n    # 1. Identify Regions using reachability\n    reachable_mask = _find_reachable_pixels(input_grid)\n    enclosed_mask = ~reachable_mask & (input_grid != 1)\n\n    # 2. Identify Seeds\n    seeds = []\n    for r in range(rows):\n        for c in range(cols):\n            if reachable_mask[r, c] and input_grid[r, c] != 0 and input_grid[r, c] != 1:\n                seeds.append({'pos': (r, c), 'color': input_grid[r, c]})\n\n    # 3. Fill Background White Pixels (Voronoi Fill)\n    if seeds: # Only fill if there are seeds\n        for r in range(rows):\n            for c in range(cols):\n                if reachable_mask[r, c] and input_grid[r, c] == 0:\n                    min_dist = float('inf')\n                    nearest_seeds = []\n                    for seed in seeds:\n                        dist = _manhattan_distance((r, c), seed['pos'])\n                        if dist < min_dist:\n                            min_dist = dist\n                            nearest_seeds = [seed]\n                        elif dist == min_dist:\n                            nearest_seeds.append(seed)\n\n                    # Tie-breaking: lowest row, then lowest column\n                    best_seed = min(nearest_seeds, key=lambda s: (s['pos'][0], s['pos'][1]))\n                    output_grid[r, c] = best_seed['color']\n\n    # 4a. Find all internal colors\n    internal_colors = set()\n    enclosed_white_pixels = []\n    blue_pixels = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if enclosed_mask[r, c]:\n                if input_grid[r,c] != 0: # non-white enclosed are internal colors\n                   internal_colors.add(input_grid[r, c])\n                else: # white enclosed\n                    enclosed_white_pixels.append((r,c))\n            elif input_grid[r, c] == 1: # Container pixel\n                blue_pixels.append((r,c))\n\n    # 4b. Determine wall_color\n    wall_color = 8 # Default Azure\n    if 2 in internal_colors: # If Red is present\n        wall_color = 2\n\n    # 4c. Determine fill_color\n    fill_color = 8 # Default Azure\n    if 3 in internal_colors:\n        fill_color = 3\n    elif 6 in internal_colors:\n        fill_color = 6\n    elif 8 in internal_colors:\n         # If only 8 is present among 3,6,8, fill is 8 (already default)\n         pass \n    # If none of 3, 6, 8 are present, but other internal colors (like 2) might be, \n    # the examples suggest 8 is still the fill color (e.g., train_1).\n    # If there are no internal colors at all, what should the fill be?\n    # Examples imply there *are* internal colors if there's enclosed space.\n    # If there happens to be enclosed white space but NO internal colors (unlikely based on examples)\n    # let's default to Azure(8) as per the priority logic.\n\n\n    # 4d. Update blue pixels\n    for r, c in blue_pixels:\n        output_grid[r, c] = wall_color\n\n    # 4e. Update enclosed white pixels\n    for r, c in enclosed_white_pixels:\n        output_grid[r, c] = fill_color\n\n    # 4f. Other pixels (seeds, internal colors) retain their original color (already handled by copying)\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4831,
    "candidates_token_count": 1766,
    "total_token_count": 6597,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 120.626557,
  "retries": 2
}