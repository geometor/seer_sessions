{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n# Optional: from scipy.ndimage import label\n\n\"\"\"\nTransforms the input grid based on partitioning pixels into roles relative to blue(1) walls.\n1.  Identify regions: 'reachable' (from border without crossing blue), 'enclosed' (not reachable).\n2.  Categorize non-white(0), non-blue(1) 'active pixels' into:\n    - 'Strictly_Enclosed': Active pixel in an enclosed region.\n    - 'Adjacent': Active pixel in a reachable region, but 4-adjacent to a blue(1) pixel.\n    - 'External': Active pixel in a reachable region, not adjacent to blue(1).\n3.  Determine Wall Color: Blue(1) pixels change to Red(2) if Red(2) is the only non-Azure(8) color among all Strictly_Enclosed and Adjacent active pixels; otherwise, they change to Azure(8).\n4.  Determine Fill Color: White(0) pixels in enclosed regions are filled based on the colors of Strictly_Enclosed active pixels (priority: Green(3) > Magenta(6) > Azure(8)). If no Strictly_Enclosed active pixels exist, use Adjacent active pixels with the same priority. Defaults to Azure(8).\n5.  Fill Outside Area: White(0) pixels in reachable regions are filled using Voronoi tessellation based on External active pixels as seeds (Manhattan distance, tie-break by row then column).\n6.  Active pixels generally retain their original color.\n\"\"\"\n\ndef _find_reachable_pixels(grid):\n    \"\"\"\n    Finds pixels reachable from the border without crossing blue (1) pixels.\n    Uses Breadth-First Search (BFS) on non-blue cells starting from the border.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: A boolean mask where True indicates a reachable pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    queue = deque()\n\n    # Add border cells that are not blue (1) to the queue and mark as reachable\n    for r in range(rows):\n        if grid[r, 0] != 1:\n            if not reachable_mask[r, 0]:\n                queue.append((r, 0))\n                reachable_mask[r, 0] = True\n        if grid[r, cols - 1] != 1:\n             if not reachable_mask[r, cols - 1]:\n                queue.append((r, cols - 1))\n                reachable_mask[r, cols - 1] = True\n    for c in range(1, cols - 1):\n        if grid[0, c] != 1:\n            if not reachable_mask[0, c]:\n                queue.append((0, c))\n                reachable_mask[0, c] = True\n        if grid[rows - 1, c] != 1:\n            if not reachable_mask[rows - 1, c]:\n                queue.append((rows - 1, c))\n                reachable_mask[rows - 1, c] = True\n\n    # Perform BFS\n    while queue:\n        r, c = queue.popleft()\n\n        # Check neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not already visited, and if not blue\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not reachable_mask[nr, nc] and grid[nr, nc] != 1:\n                reachable_mask[nr, nc] = True\n                queue.append((nr, nc))\n\n    return reachable_mask\n\ndef _get_neighbors(pos, rows, cols):\n    \"\"\"Gets 4-directional neighbors within grid bounds.\"\"\"\n    r, c = pos\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef _categorize_active_pixels(grid, reachable_mask):\n    \"\"\"\n    Categorizes active pixels (non-0, non-1) into Strictly_Enclosed, Adjacent, or External.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        reachable_mask (np.ndarray): Boolean mask of reachable pixels.\n\n    Returns:\n        tuple: Three lists of dictionaries: enclosed_active, adjacent_active, external_active.\n               Each dictionary: {'pos': (r, c), 'color': color}\n    \"\"\"\n    rows, cols = grid.shape\n    enclosed_active = []\n    adjacent_active = []\n    external_active = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and color != 1: # Is an active pixel\n                pos = (r, c)\n                is_reachable = reachable_mask[r, c]\n\n                if not is_reachable:\n                    enclosed_active.append({'pos': pos, 'color': color})\n                else:\n                    is_adjacent = False\n                    for nr, nc in _get_neighbors(pos, rows, cols):\n                        if grid[nr, nc] == 1:\n                            is_adjacent = True\n                            break\n                    if is_adjacent:\n                        adjacent_active.append({'pos': pos, 'color': color})\n                    else:\n                        external_active.append({'pos': pos, 'color': color})\n\n    return enclosed_active, adjacent_active, external_active\n\ndef _manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    # Convert to numpy array and initialize output\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # --- Step 1 & 2: Identify Regions and Categorize Active Pixels ---\n    reachable_mask = _find_reachable_pixels(grid)\n    enclosed_active, adjacent_active, external_active = _categorize_active_pixels(grid, reachable_mask)\n\n    # --- Step 3: Determine Transformation Colors ---\n\n    # Wall Color Calculation\n    wall_influencer_colors = set(p['color'] for p in enclosed_active) | set(p['color'] for p in adjacent_active)\n    non_azure_wall_colors = wall_influencer_colors - {8} # Remove Azure(8) if present\n    if non_azure_wall_colors == {2}: # Only Red(2) remains (or was the only one)\n        wall_color = 2\n    else:\n        wall_color = 8 # Default to Azure\n\n    # Fill Color Calculation\n    fill_influencer_colors = set(p['color'] for p in enclosed_active)\n    if not fill_influencer_colors: # If no strictly enclosed active pixels, use adjacent ones\n         fill_influencer_colors = set(p['color'] for p in adjacent_active)\n\n    fill_color = 8 # Default Azure\n    if 3 in fill_influencer_colors:\n        fill_color = 3\n    elif 6 in fill_influencer_colors:\n        fill_color = 6\n    elif 8 in fill_influencer_colors: # Explicitly check if 8 is present for fill\n         fill_color = 8\n    # If none of 3, 6, 8 are present, it remains the default Azure(8)\n\n\n    # --- Step 4: Apply Voronoi Fill for External Area ---\n    seeds = external_active # Use only external pixels as seeds\n    if seeds: # Only fill if there are seeds\n        for r in range(rows):\n            for c in range(cols):\n                # Fill only reachable white pixels\n                if reachable_mask[r, c] and grid[r, c] == 0:\n                    min_dist = float('inf')\n                    nearest_seeds = []\n                    for seed in seeds:\n                        dist = _manhattan_distance((r, c), seed['pos'])\n                        if dist < min_dist:\n                            min_dist = dist\n                            nearest_seeds = [seed]\n                        elif dist == min_dist:\n                            nearest_seeds.append(seed)\n\n                    # Tie-breaking: lowest row, then lowest column\n                    best_seed = min(nearest_seeds, key=lambda s: (s['pos'][0], s['pos'][1]))\n                    output_grid[r, c] = best_seed['color']\n\n    # --- Step 5: Apply Wall and Enclosed Area Transformations ---\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 1: # Original blue wall pixel\n                output_grid[r, c] = wall_color\n            elif grid[r, c] == 0 and not reachable_mask[r, c]: # Original enclosed white pixel\n                output_grid[r, c] = fill_color\n\n    # Active pixels retain original colors unless overwritten by wall color (handled by initialization and subsequent steps)\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17168,
    "candidates_token_count": 2215,
    "total_token_count": 19383,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.04276,
  "retries": 1
}