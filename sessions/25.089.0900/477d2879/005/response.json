{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on partitioning pixels relative to blue(1) walls.\n\n1.  Partition the grid into 'reachable' (from border, avoiding blue walls) and \n    'enclosed' (not reachable) areas using BFS. Blue pixels are 'walls'.\n2.  Categorize non-white(0), non-blue(1) 'active pixels':\n    - 'External Seeds': Reachable and not 4-directionally adjacent to any blue pixel.\n    - 'Internal Influencers': Enclosed.\n3.  Determine Wall Color: Walls (blue pixels) become Red(2) if any Red(2) \n    'Internal Influencer' is adjacent to a wall pixel; otherwise, they become Azure(8).\n4.  Determine Fill Color: Enclosed white(0) pixels are filled based on the colors \n    of 'Internal Influencers' (priority: Green(3) > Magenta(6) > Azure(8)). \n    Defaults to Azure(8).\n5.  Fill Reachable Area: Reachable white(0) pixels are filled using Voronoi \n    tessellation based on 'External Seeds' (Manhattan distance, tie-break by row then column).\n6.  Active pixels (seeds, influencers) retain their original color.\n\"\"\"\n\ndef _find_reachable_pixels(grid):\n    \"\"\"\n    Finds pixels reachable from the border without crossing blue (1) pixels.\n    Uses Breadth-First Search (BFS) on non-blue cells starting from the border.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: A boolean mask where True indicates a reachable pixel.\n                    Blue pixels themselves will always be False in this mask.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    queue = deque()\n\n    # Add border cells that are not blue (1) to the queue and mark as reachable\n    for r in range(rows):\n        # Left border\n        if grid[r, 0] != 1:\n            if not reachable_mask[r, 0]:\n                queue.append((r, 0))\n                reachable_mask[r, 0] = True\n        # Right border\n        if grid[r, cols - 1] != 1:\n             if not reachable_mask[r, cols - 1]:\n                queue.append((r, cols - 1))\n                reachable_mask[r, cols - 1] = True\n    for c in range(1, cols - 1): # Avoid double-adding corners\n        # Top border\n        if grid[0, c] != 1:\n            if not reachable_mask[0, c]:\n                queue.append((0, c))\n                reachable_mask[0, c] = True\n        # Bottom border\n        if grid[rows - 1, c] != 1:\n            if not reachable_mask[rows - 1, c]:\n                queue.append((rows - 1, c))\n                reachable_mask[rows - 1, c] = True\n\n    # Perform BFS\n    while queue:\n        r, c = queue.popleft()\n\n        # Check neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if not already visited, and importantly, if not blue (the wall)\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not reachable_mask[nr, nc] and grid[nr, nc] != 1:\n                reachable_mask[nr, nc] = True\n                queue.append((nr, nc))\n\n    return reachable_mask\n\ndef _get_neighbors(pos, rows, cols, directions=4):\n    \"\"\"Gets neighbors within grid bounds.\"\"\"\n    r, c = pos\n    neighbors = []\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    if directions == 8:\n        moves.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])\n        \n    for dr, dc in moves:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef _manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules defined in the module docstring.\n    \"\"\"\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify Reachable Area\n    reachable_mask = _find_reachable_pixels(grid)\n\n    # 2. Categorize Active Pixels and store wall locations\n    external_seeds = []\n    internal_influencers = []\n    blue_pixel_coords = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            pos = (r, c)\n\n            if color == 1:\n                blue_pixel_coords.append(pos)\n                continue\n            if color == 0:\n                continue\n\n            # --- It's an active pixel (non-0, non-1) ---\n            pixel_info = {'pos': pos, 'color': color}\n            is_reachable = reachable_mask[r, c]\n\n            if not is_reachable:\n                internal_influencers.append(pixel_info)\n            else:\n                # Check if adjacent to any blue pixel\n                is_adjacent_to_blue = False\n                for nr, nc in _get_neighbors(pos, rows, cols):\n                    if grid[nr, nc] == 1:\n                        is_adjacent_to_blue = True\n                        break\n                \n                if is_adjacent_to_blue:\n                    # It's reachable but adjacent to blue - not a seed\n                    # Store it if needed for other rules, currently unused directly\n                    pass \n                else:\n                    # Reachable and not adjacent to blue - it's an external seed\n                    external_seeds.append(pixel_info)\n\n    # 3. Determine Wall Transformation Color\n    wall_color = 8 # Default Azure\n    red_influencer_adjacent_to_wall = False\n    for influencer in internal_influencers:\n        if influencer['color'] == 2: # Check only Red internal influencers\n            # Check if this Red influencer is adjacent to any blue wall pixel\n            for br, bc in blue_pixel_coords:\n                 dist = _manhattan_distance(influencer['pos'], (br, bc))\n                 if dist == 1: # Adjacent\n                      red_influencer_adjacent_to_wall = True\n                      break # Found one, no need to check further for this influencer\n            if red_influencer_adjacent_to_wall:\n                 break # Found one overall, no need to check other influencers\n\n    if red_influencer_adjacent_to_wall:\n        wall_color = 2\n\n    # 4. Determine Enclosed Fill Color\n    internal_colors_set = set(p['color'] for p in internal_influencers)\n    fill_color = 8 # Default Azure\n    if 3 in internal_colors_set:\n        fill_color = 3\n    elif 6 in internal_colors_set:\n        fill_color = 6\n    elif 8 in internal_colors_set:\n        fill_color = 8\n    # If none of 3, 6, 8 are present, it remains the default Azure(8)\n\n    # 5. Apply Transformations to Output Grid\n    \n    # 5a. Voronoi fill for reachable white pixels\n    if external_seeds: # Only fill if there are seeds\n        for r in range(rows):\n            for c in range(cols):\n                # Fill only reachable white pixels\n                if reachable_mask[r, c] and grid[r, c] == 0:\n                    min_dist = float('inf')\n                    nearest_seeds = []\n                    for seed in external_seeds:\n                        dist = _manhattan_distance((r, c), seed['pos'])\n                        if dist < min_dist:\n                            min_dist = dist\n                            nearest_seeds = [seed]\n                        elif dist == min_dist:\n                            nearest_seeds.append(seed)\n\n                    # Tie-breaking: lowest row, then lowest column\n                    best_seed = min(nearest_seeds, key=lambda s: (s['pos'][0], s['pos'][1]))\n                    output_grid[r, c] = best_seed['color']\n\n    # 5b. Apply wall and enclosed fill colors\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 1: # Original blue wall pixel\n                output_grid[r, c] = wall_color\n            elif grid[r, c] == 0 and not reachable_mask[r, c]: # Original enclosed white pixel\n                output_grid[r, c] = fill_color\n            # Active pixels retain original colors (handled by initial copy)\n            # Reachable white pixels were handled in step 5a\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21071,
    "candidates_token_count": 2222,
    "total_token_count": 23293,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.621089,
  "retries": 1
}