{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set\n\ndef find_colors(grid: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Identifies the background color (0) and the two foreground colors (C1, C2).\n\n    C2 is identified as the color forming vertical lines in columns containing\n    only C2 and the background color. C1 is the other non-background color.\n\n    Returns:\n        Tuple[int, int, int]: (background_color, C1, C2)\n    \"\"\"\n    unique_colors = np.unique(grid)\n    background_color = 0\n    foreground_colors = sorted([c for c in unique_colors if c != background_color])\n\n    if len(foreground_colors) != 2:\n        # Fallback or error handling if assumption of 2 foreground colors fails\n        # For now, let's assume the first is C1, second is C2 if possible\n        if len(foreground_colors) == 1:\n             return background_color, foreground_colors[0], foreground_colors[0] # Handle edge case?\n        elif len(foreground_colors) > 1:\n             # Default assumption if identification fails\n             print(\"Warning: Could not reliably identify C1 and C2 based on external lines. Assuming C1={}, C2={}\".format(foreground_colors[0], foreground_colors[1]))\n             return background_color, foreground_colors[0], foreground_colors[1]\n        else:\n             raise ValueError(\"No foreground colors found.\")\n\n\n    C1, C2 = -1, -1\n\n    rows, cols = grid.shape\n    for c_idx in range(cols):\n        col_data = grid[:, c_idx]\n        unique_in_col = np.unique(col_data)\n        non_bg_in_col = [c for c in unique_in_col if c != background_color]\n\n        # Check if this column contains only background and ONE foreground color\n        if len(non_bg_in_col) == 1:\n            potential_c2 = non_bg_in_col[0]\n            # Check if this color exists elsewhere with the other foreground color\n            other_fg_color = -1\n            for fg in foreground_colors:\n                if fg != potential_c2:\n                    other_fg_color = fg\n                    break\n\n            # Does the other foreground color exist in the grid?\n            if other_fg_color != -1 and np.any(grid == other_fg_color):\n                 # Is potential_c2 truly isolated in this column?\n                 # A simple check: if the column consists *only* of 0s and potential_c2\n                 is_isolated_col = True\n                 for val in unique_in_col:\n                     if val != 0 and val != potential_c2:\n                         is_isolated_col = False\n                         break\n                 if is_isolated_col:\n                    # Found C2 based on isolated vertical line characteristic\n                    C2 = potential_c2\n                    C1 = other_fg_color\n                    break # Found C1 and C2\n\n    # If the above logic failed (e.g., no perfectly isolated column)\n    if C1 == -1 or C2 == -1:\n        # Fallback: Use the sorted order. This might be wrong if C1 < C2.\n        # A better fallback might be needed based on other structural properties.\n         print(\"Warning: Fallback color identification used. Assuming C1={}, C2={}\".format(foreground_colors[0], foreground_colors[1]))\n         C1 = foreground_colors[0]\n         C2 = foreground_colors[1]\n\n\n    return background_color, C1, C2\n\ndef find_structure_properties(grid: np.ndarray, C1: int, C2: int, background_color: int) -> Dict:\n    \"\"\"\n    Finds key properties of the H-like structure and external lines.\n    \"\"\"\n    properties = {}\n    rows, cols = grid.shape\n\n    # Find crossbar row (assuming it's the row containing C1)\n    c1_rows, _ = np.where(grid == C1)\n    if not len(c1_rows):\n         raise ValueError(\"Cannot find C1 in the grid.\")\n    properties['crossbar_row'] = c1_rows[0] # Assume first row with C1 is the crossbar\n\n    # Find C1 post columns on the crossbar\n    crossbar_data = grid[properties['crossbar_row'], :]\n    c1_cols_on_crossbar = np.where(crossbar_data == C1)[0]\n    if not len(c1_cols_on_crossbar):\n         # This might happen if C1 is not on the identified 'crossbar' based on first occurrence.\n         # Re-evaluate crossbar finding or handle error.\n         # Let's search all rows for C1 to define posts, assuming H structure\n         all_c1_rows, all_c1_cols = np.where(grid == C1)\n         if not len(all_c1_cols): raise ValueError(\"C1 not found\")\n         # Assume crossbar is where C1 has min/max column extent\n         properties['left_post_col'] = np.min(all_c1_cols)\n         properties['right_post_col'] = np.max(all_c1_cols)\n         # Need to redefine crossbar row potentially based on where C2 connects these?\n         # For now, stick to the first C1 row found. Revisit if needed.\n         print(f\"Warning: C1 not found on initial crossbar row guess ({properties['crossbar_row']}). Using overall min/max C1 columns.\")\n         properties['left_post_col'] = np.min(c1_cols_on_crossbar) if len(c1_cols_on_crossbar) else 0 # Needs better handling\n         properties['right_post_col'] = np.max(c1_cols_on_crossbar) if len(c1_cols_on_crossbar) else cols -1# Needs better handling\n    else:\n        properties['left_post_col'] = np.min(c1_cols_on_crossbar)\n        properties['right_post_col'] = np.max(c1_cols_on_crossbar)\n\n\n    # Find right edge of the structure on the crossbar row\n    non_bg_cols_on_crossbar = np.where(crossbar_data != background_color)[0]\n    properties['right_edge_col'] = np.max(non_bg_cols_on_crossbar) if len(non_bg_cols_on_crossbar) > 0 else properties['right_post_col']\n\n    # Find external C2 lines column and rows\n    properties['external_line_col'] = -1\n    properties['external_line_rows'] = []\n    for c_idx in range(cols):\n        col_data = grid[:, c_idx]\n        unique_in_col = np.unique(col_data)\n        # Check if this column contains ONLY C2 and background\n        if all(uc == C2 or uc == background_color for uc in unique_in_col) and C2 in unique_in_col:\n             # Check if this C2 column is truly separate (not touching C1 maybe?)\n             # For simplicity, assume the first such column found is it.\n             # A more robust check might involve connectivity analysis.\n             is_external = True\n             # Rough check: ensure C1 is not adjacent horizontally\n             if c_idx > 0 and np.any(grid[:, c_idx-1] == C1): is_external = False\n             if c_idx < cols - 1 and np.any(grid[:, c_idx+1] == C1): is_external = False\n             # Rough check: ensure it's not the central C2 line (often shares column with C1/C2 on crossbar)\n             if grid[properties['crossbar_row'], c_idx] != background_color:\n                 is_external = False # If part of the crossbar structure, likely not external\n\n             # A simpler primary assumption: The column identified during C1/C2 distinction is the external one.\n             # Let's refine the C1/C2 identification step to return this column.\n\n             # Re-evaluating external line finding:\n             # Find all C2 locations\n             c2_rows, c2_cols = np.where(grid == C2)\n             c2_coords = set(zip(c2_rows, c2_cols))\n\n             # Find all C1 locations\n             c1_rows_all, c1_cols_all = np.where(grid == C1)\n             c1_coords = set(zip(c1_rows_all, c1_cols_all))\n\n             # Find connected components of C1 and C2 together\n             q = list(c1_coords) # Start BFS/DFS from C1 pixels\n             main_structure_coords = set(c1_coords)\n             visited = set(c1_coords)\n\n             while q:\n                 r, c = q.pop(0)\n                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-way connectivity\n                     nr, nc = r + dr, c + dc\n                     if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                          coord = (nr, nc)\n                          # If neighbor is C1 or C2, add to structure\n                          if grid[nr, nc] == C1 or grid[nr, nc] == C2:\n                              if coord not in main_structure_coords:\n                                  main_structure_coords.add(coord)\n                                  q.append(coord)\n                          visited.add(coord) # Mark visited even if background\n\n             # External C2 coords are those C2 coords not in the main structure\n             external_c2_coords = c2_coords - main_structure_coords\n\n             if external_c2_coords:\n                 # Assume all external C2 pixels are in the same column\n                 properties['external_line_col'] = list(external_c2_coords)[0][1]\n                 properties['external_line_rows'] = sorted([r for r, c in external_c2_coords])\n             else:\n                 # No external lines found\n                 properties['external_line_col'] = -1\n                 properties['external_line_rows'] = []\n                 print(\"Warning: No external C2 lines identified.\")\n\n\n    # Find internal C2 column (the one part of the H structure, not external)\n    properties['internal_c2_col'] = -1\n    internal_c2_candidates = []\n    for c_idx in range(cols):\n        # Must contain C2\n        if np.any(grid[:, c_idx] == C2):\n             # Must not be the external line column\n             if c_idx != properties['external_line_col']:\n                 # Must have C2 pixels NOT on the crossbar row\n                 if np.any(grid[grid[:, c_idx] == C2, c_idx] != properties['crossbar_row']):\n                     # Check if this column is part of the main structure found via BFS\n                     col_coords = set([(r, c_idx) for r in range(rows)])\n                     if any(coord in main_structure_coords for coord in col_coords if grid[coord[0], coord[1]] == C2):\n                          internal_c2_candidates.append(c_idx)\n\n\n    if len(internal_c2_candidates) == 1:\n         properties['internal_c2_col'] = internal_c2_candidates[0]\n    elif len(internal_c2_candidates) > 1:\n        # Ambiguous - pick the one closest to the center? Or the one on the crossbar?\n        # Let's pick the one present on the crossbar row.\n        for c_idx in internal_c2_candidates:\n            if grid[properties['crossbar_row'], c_idx] == C2:\n                properties['internal_c2_col'] = c_idx\n                break\n        if properties['internal_c2_col'] == -1: # If none on crossbar, just pick first?\n             properties['internal_c2_col'] = internal_c2_candidates[0]\n             print(f\"Warning: Multiple internal C2 column candidates. Chose {properties['internal_c2_col']}.\")\n    else:\n        # No internal C2 line found separate from external?\n        print(\"Warning: No internal C2 vertical line identified.\")\n        # This might happen if C2 is only on the crossbar, or only external\n\n\n    return properties\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the observed pattern:\n    1. Identifies background (0), main structure color (C1), and secondary color (C2).\n    2. Locates the central H-like structure and external C2 vertical lines.\n    3. Clears the internal vertical C2 line segment within the H-structure (pixels not on the crossbar).\n    4. Modifies the crossbar row: colors pixels between the C1 'posts' (inclusive) with C1.\n    5. Moves the external C2 vertical lines to the column corresponding to the rightmost edge of the H-structure's crossbar.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    if np.all(grid == 0): # Handle empty grid case\n        return input_grid\n\n    # 1. Identify colors\n    try:\n        background_color, C1, C2 = find_colors(grid)\n    except ValueError as e:\n        print(f\"Error identifying colors: {e}. Returning input.\")\n        return input_grid\n    except Exception as e:\n        print(f\"Unexpected error identifying colors: {e}. Returning input.\")\n        # Fallback identification needed here based on simple counts?\n        unique_colors = np.unique(grid)\n        foreground_colors = sorted([c for c in unique_colors if c != 0])\n        if len(foreground_colors) == 2:\n             C1, C2 = foreground_colors\n             print(f\"Fallback color ID: C1={C1}, C2={C2}\")\n        else:\n             print(\"Cannot determine C1/C2 with fallback.\")\n             return input_grid # Cannot proceed\n\n    # 2. Locate structure properties\n    try:\n        props = find_structure_properties(grid, C1, C2, background_color)\n        crossbar_row = props['crossbar_row']\n        left_post_col = props['left_post_col']\n        right_post_col = props['right_post_col']\n        right_edge_col = props['right_edge_col']\n        internal_c2_col = props['internal_c2_col']\n        external_line_col = props['external_line_col']\n        external_line_rows = props['external_line_rows']\n\n    except ValueError as e:\n         print(f\"Error finding structure properties: {e}. Returning input.\")\n         return input_grid\n    except KeyError as e:\n         print(f\"Error accessing structure property: {e}. Returning input.\")\n         return input_grid\n\n    # 3. Clear internal C2 vertical line (off-crossbar part)\n    if internal_c2_col != -1:\n        for r in range(rows):\n            if r != crossbar_row and output_grid[r, internal_c2_col] == C2:\n                output_grid[r, internal_c2_col] = background_color\n\n    # 4. Modify crossbar\n    # Ensure indices are valid before slicing/iteration\n    if 0 <= crossbar_row < rows and 0 <= left_post_col <= right_post_col < cols:\n        for c in range(left_post_col, right_post_col + 1):\n            # Only change if the column is valid\n            if 0 <= c < cols:\n                output_grid[crossbar_row, c] = C1\n    else:\n        print(f\"Warning: Invalid crossbar indices: row={crossbar_row}, left={left_post_col}, right={right_post_col}. Skipping modification.\")\n\n\n    # 5. Move external C2 lines\n    if external_line_col != -1 and external_line_rows:\n        # Ensure target column is valid\n        if 0 <= right_edge_col < cols:\n             # Clear original location\n            for r in external_line_rows:\n                 if 0 <= r < rows and 0 <= external_line_col < cols:\n                     output_grid[r, external_line_col] = background_color\n             # Draw at new location\n            for r in external_line_rows:\n                 if 0 <= r < rows:\n                     output_grid[r, right_edge_col] = C2\n        else:\n            print(f\"Warning: Invalid target column for external lines: {right_edge_col}. Skipping move.\")\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4332,
    "candidates_token_count": 4014,
    "total_token_count": 8346,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 150.024926,
  "retries": 2
}