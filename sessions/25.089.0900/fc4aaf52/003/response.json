{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Determine the background color by identifying the most frequent color in the input grid (expected to be azure, 8).\n2. Identify all pixels in the input grid that are not the background color; these form the 'source object'. Collect their coordinates (row, col) and original colors.\n3. Identify the set of unique colors present in the source object (expected to be exactly two distinct non-background colors).\n4. Find the 'anchor pixel' of the source object: the pixel with the minimum row index, and among those, the minimum column index. Note its color ('anchor_color').\n5. Determine the horizontal shift distance (`dx`) based on the `anchor_color`: if white (0), `dx` is 3; if blue (1), `dx` is 5.\n6. Create a 'color map' dictionary: map the first non-background color found in the object to the second, and map the second back to the first.\n7. Create a new output grid of the same dimensions as the input grid, filled entirely with the background color.\n8. For each pixel from the source object at input coordinate (row, col) with an `original_color`:\n    a. Look up its corresponding `mapped_color` using the color map.\n    b. Calculate the target column: `new_col = col + dx`.\n    c. If `new_col` is within the grid's width boundaries, set the pixel at coordinate (row, `new_col`) in the output grid to the `mapped_color`.\n9. The resulting grid is the final output.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_object_pixels_and_colors(grid, background_color):\n    \"\"\"\n    Finds all non-background pixels and the unique non-background colors.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The identified background color.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of (row, col, color) tuples for each object pixel.\n            - set: A set of unique non-background colors found.\n            Returns ([], set()) if no object pixels are found.\n    \"\"\"\n    height, width = grid.shape\n    object_pixels = []\n    object_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                object_pixels.append((r, c, color))\n                object_colors.add(color)\n    return object_pixels, object_colors\n\ndef find_anchor_pixel(object_pixels):\n    \"\"\"\n    Finds the anchor pixel (top-most, then left-most) of an object.\n\n    Args:\n        object_pixels (list): A list of (row, col, color) tuples.\n\n    Returns:\n        tuple: The (row, col, color) of the anchor pixel, or None if list is empty.\n    \"\"\"\n    if not object_pixels:\n        return None\n\n    min_row = min(p[0] for p in object_pixels)\n    top_row_pixels = [p for p in object_pixels if p[0] == min_row]\n    min_col = min(p[1] for p in top_row_pixels)\n\n    # Find the specific pixel matching min_row and min_col\n    for p in top_row_pixels:\n        if p[1] == min_col:\n            return p # Returns (row, col, color)\n\n    return None # Should not happen if object_pixels is not empty\n\ndef get_shift_amount(anchor_color):\n    \"\"\"\n    Determines the horizontal shift based on the anchor color.\n\n    Args:\n        anchor_color (int): The color of the anchor pixel.\n\n    Returns:\n        int: The horizontal shift distance (dx). Returns 0 if color is unmapped.\n    \"\"\"\n    if anchor_color == 0: # white\n        return 3\n    elif anchor_color == 1: # blue\n        return 5\n    else:\n        # Default or error case - return 0 shift if color not mapped\n        print(f\"Warning: Unhandled anchor color {anchor_color}, returning shift 0.\")\n        return 0\n\ndef create_color_swap_map(object_colors):\n    \"\"\"\n    Creates a map to swap the two colors found in the object.\n\n    Args:\n        object_colors (set): A set containing the two unique non-background colors.\n\n    Returns:\n        dict: A dictionary mapping color_a -> color_b and color_b -> color_a.\n              Returns an empty dict if not exactly two colors are provided.\n    \"\"\"\n    if len(object_colors) != 2:\n        print(f\"Warning: Expected exactly 2 object colors, found {len(object_colors)}. Cannot create swap map.\")\n        return {}\n    color_list = list(object_colors)\n    return {color_list[0]: color_list[1], color_list[1]: color_list[0]}\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    height, width = input_grid_np.shape\n\n    # 1. Identify background color (most frequent)\n    colors, counts = np.unique(input_grid_np, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find object pixels and their unique colors\n    source_object_pixels, source_object_colors = find_object_pixels_and_colors(input_grid_np, background_color)\n\n    # Handle cases where no object is found\n    if not source_object_pixels:\n        print(\"Warning: No object pixels found. Returning input grid.\")\n        return input_grid # Or return a grid filled with background_color\n\n    # 3. Create the color swap map\n    color_map = create_color_swap_map(source_object_colors)\n    if not color_map:\n         print(\"Warning: Could not create color map. Returning input grid.\")\n         return input_grid # Cannot proceed without a valid map\n\n    # 4. Find the anchor pixel and its color\n    anchor = find_anchor_pixel(source_object_pixels)\n    if not anchor:\n        # This case should technically be covered by the check for empty source_object_pixels\n        print(\"Warning: Could not find anchor pixel. Returning input grid.\")\n        return input_grid\n    anchor_color = anchor[2]\n\n    # 5. Determine the horizontal shift (dx)\n    dx = get_shift_amount(anchor_color)\n\n    # 6. Create the output grid, initialized with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 7. Translate the object, applying the color swap\n    for r, c, original_color in source_object_pixels:\n        # a. Look up mapped color\n        mapped_color = color_map.get(original_color, original_color) # Default to original if somehow not in map\n\n        # b. Calculate new column\n        new_c = c + dx\n\n        # c. Place mapped color if within bounds\n        if 0 <= new_c < width:\n            output_grid[r, new_c] = mapped_color\n        else:\n             # Optional: Handle pixels moving out of bounds\n             # print(f\"Info: Pixel at ({r}, {c}) moved out of bounds to ({r}, {new_c}).\")\n             pass\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18680,
    "candidates_token_count": 1770,
    "total_token_count": 20450,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.811828,
  "retries": 1
}