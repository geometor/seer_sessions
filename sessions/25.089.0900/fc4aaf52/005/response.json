{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Determine the background color by identifying the most frequent color in the input grid (expected to be azure, 8).\n2. Identify all pixels in the input grid that are not the background color; these form the 'source object'. Collect their coordinates (row, col) and original colors.\n3. Identify the set of unique colors present in the source object. Verify that there are exactly two distinct non-background colors.\n4. Create a 'color swap map' dictionary: map the first non-background color to the second, and map the second back to the first.\n5. Find the 'anchor pixel' of the source object: the pixel with the minimum row index, and among those, the minimum column index. Note its color ('anchor_color').\n6. Determine the horizontal shift distance (`dx`) based on the `anchor_color`: if white (0), `dx` is 3; if blue (1), `dx` is 5.\n7. Create a new output grid of the same dimensions as the input grid, filled entirely with the background color.\n8. For each pixel from the source object at input coordinate (row, col) with an `original_color`:\n    a. Look up its corresponding `mapped_color` using the color swap map.\n    b. Calculate the target column: `new_col = col + dx`.\n    c. If `new_col` is within the grid's width boundaries, set the pixel at coordinate (row, `new_col`) in the output grid to the `mapped_color`.\n9. The resulting grid is the final output.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_object_pixels_and_colors(grid, background_color):\n    \"\"\"\n    Finds all non-background pixels and the unique non-background colors.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The identified background color.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of (row, col, color) tuples for each object pixel.\n            - set: A set of unique non-background colors found.\n            Returns ([], set()) if no object pixels are found.\n    \"\"\"\n    height, width = grid.shape\n    object_pixels = []\n    object_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                object_pixels.append((r, c, color))\n                object_colors.add(color)\n    return object_pixels, object_colors\n\ndef find_anchor_pixel(object_pixels):\n    \"\"\"\n    Finds the anchor pixel (top-most, then left-most) of an object.\n\n    Args:\n        object_pixels (list): A list of (row, col, color) tuples.\n\n    Returns:\n        tuple: The (row, col, color) of the anchor pixel, or None if list is empty.\n    \"\"\"\n    if not object_pixels:\n        return None\n\n    min_row = min(p[0] for p in object_pixels)\n    top_row_pixels = [p for p in object_pixels if p[0] == min_row]\n    min_col = min(p[1] for p in top_row_pixels)\n\n    # Find the specific pixel matching min_row and min_col\n    for p in top_row_pixels:\n        if p[1] == min_col:\n            return p # Returns (row, col, color)\n\n    # Should not be reached if object_pixels is not empty and logic is sound\n    return None \n\ndef get_shift_amount(anchor_color):\n    \"\"\"\n    Determines the horizontal shift based on the anchor color.\n\n    Args:\n        anchor_color (int): The color of the anchor pixel.\n\n    Returns:\n        int: The horizontal shift distance (dx). Returns 0 if color is unmapped.\n    \"\"\"\n    if anchor_color == 0: # white\n        return 3\n    elif anchor_color == 1: # blue\n        return 5\n    else:\n        # Default or error case - handle unexpected anchor colors\n        # Based on the examples, only 0 and 1 are expected anchors.\n        # If other colors appear, the rule might be incomplete.\n        # For robustness, return 0 shift if unmapped.\n        # print(f\"Warning: Unhandled anchor color {anchor_color}, returning shift 0.\")\n        return 0\n\ndef create_color_swap_map(object_colors):\n    \"\"\"\n    Creates a map to swap the two colors found in the object.\n\n    Args:\n        object_colors (set): A set containing the two unique non-background colors.\n\n    Returns:\n        dict: A dictionary mapping color_a -> color_b and color_b -> color_a.\n              Returns an empty dict if not exactly two colors are provided.\n    \"\"\"\n    if len(object_colors) != 2:\n        # print(f\"Warning: Expected exactly 2 object colors, found {len(object_colors)}. Cannot create swap map.\")\n        return {} # Return empty map to signal failure\n    color_list = list(object_colors)\n    return {color_list[0]: color_list[1], color_list[1]: color_list[0]}\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient operations\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify background color (most frequent)\n    colors, counts = np.unique(input_grid_np, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find object pixels and their unique colors\n    source_object_pixels, source_object_colors = find_object_pixels_and_colors(input_grid_np, background_color)\n\n    # Handle cases where no object is found or requirements aren't met\n    if not source_object_pixels:\n        # print(\"Warning: No object pixels found. Returning input grid as is.\")\n        return input_grid # Return original grid if no object\n\n    # 3. Create the color swap map (requires exactly 2 colors)\n    color_map = create_color_swap_map(source_object_colors)\n    if not color_map:\n         # print(\"Warning: Could not create color map (requires 2 distinct object colors). Returning input grid as is.\")\n         return input_grid # Cannot proceed without a valid map\n\n    # 4. Find the anchor pixel and its color\n    anchor = find_anchor_pixel(source_object_pixels)\n    # If source_object_pixels is not empty, anchor should always be found.\n    # Adding a check for robustness, though it shouldn't be needed if prior logic holds.\n    if not anchor:\n        # print(\"Error: Could not find anchor pixel despite object presence. Returning input grid.\")\n        return input_grid\n    anchor_color = anchor[2]\n\n    # 5. Determine the horizontal shift (dx) based on anchor color\n    dx = get_shift_amount(anchor_color)\n\n    # 6. Create the output grid, initialized with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 7. Translate the object, applying the color swap\n    for r, c, original_color in source_object_pixels:\n        # a. Look up mapped color using the swap map\n        # Use .get() with default just in case, though map should be complete\n        mapped_color = color_map.get(original_color, original_color) \n\n        # b. Calculate new column after horizontal shift\n        new_c = c + dx\n\n        # c. Place mapped color in the output grid if the new position is within bounds\n        if 0 <= new_c < width:\n            output_grid[r, new_c] = mapped_color\n        # else:\n             # Optional: Handle pixels moving out of bounds (not observed in examples)\n             # print(f\"Info: Pixel at ({r}, {c}) moved out of bounds to ({r}, {new_c}).\")\n             # pass\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25298,
    "candidates_token_count": 1950,
    "total_token_count": 27248,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.185324,
  "retries": 1
}