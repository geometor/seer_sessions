
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 0 0 1 1 1 0
0 1 2 2 1 0 0 1 2 1 0
0 1 2 2 1 0 0 1 1 1 0
0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 3 2 1 0 0 0 0
0 0 1 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 3 2 2 3 2 1 0 0 0 0
0 1 2 3 3 3 3 2 1 0 0 0 0
0 1 2 2 2 2 2 2 1 0 0 0 0
0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 1 2 1 0 0
0 0 0 0 0 0 0 0 1 1 1 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 2 2 3 2 1 0 0 0 0
0 0 1 2 3 3 3 3 2 1 0 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 3 3 3 2 1 0 0 0
0 0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 0 0 0
```

Okay, let's break down the transformation process for this task.

**Perception**

The input grids contain one or more solid rectangular shapes composed of blue pixels (1) on a white background (0). The transformation modifies the colors *inside* these blue rectangles based on the pixel's distance from the rectangle's edge. The background remains unchanged. The edge pixels of the original blue rectangle remain blue (1) in the output. Pixels one step inside the edge become red (2). Pixels two steps inside become green (3). Pixels three steps inside become red (2) again, suggesting a repeating pattern (red, green, red, green...) for increasing distances from the edge, starting with red at distance 1.

**Facts**


```yaml
Input Grid:
  - Contains a background color: white (0).
  - Contains foreground objects: solid rectangles made of blue pixels (1).
  - Multiple objects can exist in one grid.

Output Grid:
  - Background color remains white (0).
  - The original blue rectangles are modified internally.
  - The pixels' colors within the original blue rectangular areas depend on their position relative to the edge of that rectangle.

Transformation Rule:
  - Identify each contiguous blue rectangle.
  - For each pixel that was originally blue:
    - Calculate the minimum distance (number of horizontal/vertical steps) from this pixel to the nearest edge of its containing blue rectangle. An edge is defined as a blue pixel adjacent (horizontally or vertically) to a non-blue pixel or the grid boundary.
    - Assign a new color based on this minimum distance `d`:
      - If `d == 0` (pixel is on the edge): color remains 1 (blue).
      - If `d == 1`: color becomes 2 (red).
      - If `d >= 2`:
        - If `d` is even: color becomes 3 (green).
        - If `d` is odd: color becomes 2 (red).
  - Pixels originally white (0) remain white (0).
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the output grid.
2.  Iterate through each pixel of the input grid.
3.  If the current pixel is blue (1):
    a.  Identify the bounds (minimum row, maximum row, minimum column, maximum column) of the solid blue rectangle this pixel belongs to. (*Assumption: Input shapes are solid rectangles. A flood fill or similar connectivity check might be needed if shapes could be non-rectangular or have holes, but based on examples, rectangles are sufficient.*)
    b.  Calculate the minimum distance `d` from the current pixel's coordinates `(r, c)` to the boundary of its identified rectangle. The distance is `min(r - min_row, max_row - r, c - min_col, max_col - c)`.
    c.  Determine the color for the corresponding pixel in the output grid based on the distance `d`:
        i.  If `d == 0`, set the output pixel color to 1 (blue).
        ii. If `d == 1`, set the output pixel color to 2 (red).
        iii.If `d >= 2`, set the output pixel color to 3 (green) if `d` is even, or 2 (red) if `d` is odd.
4.  If the current pixel is not blue (i.e., it's white (0)), keep its color unchanged in the output grid.
5.  Return the modified output grid.
