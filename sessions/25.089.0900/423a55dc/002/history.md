
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0
8 0 0 0 8 0 0 0 0 0 0
0 8 0 0 0 8 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
6 6 6 0 0 0 0 0 0 0 0
0 6 0 6 0 0 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0 0
0 0 0 6 0 6 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0
0 0 0 0 0 0 3 3 0 3 3 0 0
0 0 0 0 0 0 3 0 0 0 3 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0
0 0 0 0 3 3 0 3 3 0 0 0 0
0 0 0 0 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 2 2 0 0 2 0 0 0 0
0 0 0 0 0 2 0 0 2 2 0 0 0
0 0 0 0 0 2 0 0 0 2 0 0 0
0 0 0 0 0 2 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0 0 0 0
2 0 0 0 2 0 0 0 0 0 0 0 0
0 2 2 0 0 2 0 0 0 0 0 0 0
0 0 0 2 0 0 2 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0
0 8 8 8 0 0 0
0 8 8 8 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0
8 8 8 0 0 0 0
0 8 8 8 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```

## Perception

1.  **Grid Structure:** The input and output are 2D grids containing integer values representing colors. The background color is white (0).
2.  **Objects:** Each input grid features a single, contiguous object composed of a single non-white color (azure, magenta, green, red). The shape and position of this object vary across examples.
3.  **Transformation:** The core transformation involves shifting the object horizontally within the grid. The object's shape, color, and vertical position remain unchanged.
4.  **Shift Pattern:** The shift is consistently towards the left edge (column 0).
5.  **Shift Mechanism:** Closer inspection reveals that the shift is applied independently to each row containing parts of the object. For a given row, all its pixels (including white pixels *within* the original horizontal span of the object in that row, although this doesn't affect the outcome here as only non-white pixels move) are shifted left.
6.  **Shift Magnitude:** The magnitude of the leftward shift for each row is determined by the column index of the *first* (left-most) non-white pixel in that specific row in the input grid. This ensures that the left-most part of the object in that row aligns with column 0 in the output grid.
7.  **Background:** Rows containing only the background color (white, 0) are unaffected and remain unchanged in the output.

## YAML Facts


```yaml
task_type: object_transformation
background_color: 0 # white
objects:
  - role: primary
    count: 1 # Always one object per grid
    attributes:
      - color: non-zero (varies: 8, 6, 3, 2)
      - shape: contiguous, variable (letters, blocks)
      - structure: solid or hollow
actions:
  - name: horizontal_shift
    target: primary_object
    direction: left
    granularity: per_row # Each row is shifted independently
    magnitude_rule: |
      For each row containing non-white pixels, the shift amount
      is equal to the column index of the left-most non-white
      pixel in that row.
    effect: |
      Moves the left-most non-white pixel of each object row
      to column 0. Pixels maintain their relative horizontal
      positions within the row after the shift.
relationships:
  - type: positional
    scope: row
    rule: |
      The horizontal position of pixels in the output row depends
      only on their horizontal position and the position of the
      left-most non-white pixel in the corresponding input row.
output_grid:
  - property: dimensions
    value: same_as_input
  - property: background
    value: preserved
  - property: object_content
    value: |
      Contains the primary object shifted according to the
      per-row horizontal_shift action.
```


## Natural Language Program

1.  Initialize an output grid with the same dimensions as the input grid, filled with the background color (white, 0).
2.  Iterate through each row of the input grid, keeping track of the row index.
3.  For each row:
    a.  Find the column index of the first (left-most) non-white pixel in that row.
    b.  If no non-white pixel is found (the row is entirely white), copy the row directly to the corresponding row in the output grid and proceed to the next row.
    c.  If a non-white pixel is found at `first_col_index`:
        i.  Calculate the horizontal shift amount: `shift = -first_col_index`.
        ii. Iterate through the pixels of the current input row, keeping track of the column index `col`.
        iii. If the pixel at `(row, col)` is non-white:
            *   Calculate the new column index: `new_col = col + shift`.
            *   Set the pixel at `(row, new_col)` in the output grid to the color of the input pixel at `(row, col)`.
4.  Return the completed output grid.
```python
import numpy as np

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by shifting the non-background pixels
    in each row to the left. The amount of shift for a given row
    is determined by the column index of the left-most non-background
    pixel in that row, such that this pixel ends up in column 0
    in the output grid. Rows containing only background pixels remain
    unchanged.

    Args:
        input_grid: A 2D NumPy array representing the input grid.

    Returns:
        A 2D NumPy array representing the transformed output grid.
    """
    # Get the dimensions of the input grid
    height, width = input_grid.shape

    # Initialize an output grid with the same dimensions, filled with the background color (0)
    output_grid = np.zeros_like(input_grid)

    # Iterate through each row of the input grid
    for r in range(height):
        # Get the current row
        row = input_grid[r, :]

        # Find the indices of non-background (non-zero) pixels in the current row
        non_zero_indices = np.where(row != 0)[0]

        # If there are no non-zero pixels, the row is entirely background
        if len(non_zero_indices) == 0:
            # Copy the background row directly (already initialized to 0, so technically optional)
            # output_grid[r, :] = 0 
            continue # Proceed to the next row
        else:
            # Find the column index of the first (left-most) non-zero pixel
            first_col_index = non_zero_indices[0]

            # Calculate the horizontal shift amount needed to move the first non-zero pixel to column 0
            shift = -first_col_index

            # Iterate through the pixels of the current input row
            for c in range(width):
                # Get the color of the pixel
                color = input_grid[r, c]

                # If the pixel is not background
                if color != 0:
                    # Calculate the new column index after applying the shift
                    new_col = c + shift
                    
                    # Ensure the new column index is within the grid bounds
                    # (Should always be true with this logic, but good practice)
                    if 0 <= new_col < width:
                        # Place the pixel's color at the new position in the output grid
                        output_grid[r, new_col] = color

    # Return the completed output grid
    return output_grid
```
