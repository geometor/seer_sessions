
## train_1

**input:**
```
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 2 0 2 0 0 0 0 2 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 2 0 2 1 1 1 1 2 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0
0 0 2 0 2 0 0 2 0 2 0 0 2 0 2 0
0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 2 0 0 0 0 0 0
0 2 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0
0 0 2 0 2 1 1 2 0 2 1 1 2 0 2 0
0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 2 0 0 0 0 0 0
0 2 0 2 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 2 0 0 0 0 2 0 2 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 2 0 0 0 0 2 0 2 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 2 1 1 1 1 2 0 2 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 0 1 0 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 0 1 0 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 2 0 2 1 1 1 1 2 0 2 0 0
0 0 0 0 2 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## Perception

1.  **Input/Output Structure:** Both input and output are grids of pixels, primarily white (0), with some red (2) pixels. The output grids additionally contain blue (1) pixels.
2.  **Input Objects:** The input grids contain multiple instances of a specific shape made of red (2) pixels. This shape resembles a plus sign '+' or sometimes an 'H' where the central horizontal bar is missing. More accurately, it's a central red pixel with single red pixels directly above, below, left, and right of it. The background is white (0).
3.  **Transformation:** The transformation involves adding blue (1) pixels to the grid. These blue pixels form straight lines, either horizontal or vertical.
4.  **Relationship:** The blue lines appear *between* pairs of the red '+' shapes present in the input.
5.  **Conditions for Transformation:**
    *   A blue line is drawn between the *center* pixels of two red '+' shapes *only if* these center pixels lie on the same row (horizontal alignment) or the same column (vertical alignment).
    *   The blue line fills the white (0) pixels strictly *between* the two center pixels along that row or column. The center pixels themselves remain red.
    *   No other pixels are changed.

## Facts


```yaml
Objects:
  - type: Shape
    color: red (2)
    structure: 5-pixel plus sign (center pixel with N, S, E, W neighbors)
    alias: red_plus
  - type: Background
    color: white (0)
  - type: Line
    color: blue (1)
    location: Output grid only
    role: Connector

Relationships:
  - type: Alignment
    between: center pixels of red_plus shapes
    qualifier: Horizontal (same row) or Vertical (same column)
    required_for: Action

Actions:
  - name: IdentifyObjects
    target: red_plus shapes
    method: Locate the central pixel of each 5-pixel red plus shape.
  - name: FindAlignedPairs
    target: Pairs of red_plus shapes
    condition: Center pixels are horizontally or vertically aligned.
  - name: DrawLine
    color: blue (1)
    from: Center pixel of first red_plus in an aligned pair
    to: Center pixel of second red_plus in the aligned pair
    path: Straight line (horizontal or vertical) along the alignment axis.
    constraint: Fill only the white (0) background pixels strictly *between* the two center pixels. Do not overwrite the red pixels.

GridProperties:
  - Size: Variable (input and output have the same dimensions)
  - ColorsUsed: Input (white, red), Output (white, red, blue)
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all instances of the 'red plus' shape in the input grid. A 'red plus' shape consists of a central red (2) pixel and four adjacent red (2) pixels (up, down, left, right). Record the coordinates of the *center* pixel for each identified shape.
3.  Iterate through all unique pairs of the identified center pixels.
4.  For each pair of center pixels (P1 at (r1, c1) and P2 at (r2, c2)):
    a.  Check if they are horizontally aligned (r1 == r2) and have at least one white (0) pixel between them (abs(c1 - c2) > 1).
    b.  If horizontally aligned, fill all white (0) pixels in the output grid at row r1 between column c1 and column c2 (exclusive of c1 and c2) with blue (1).
    c.  Check if they are vertically aligned (c1 == c2) and have at least one white (0) pixel between them (abs(r1 - r2) > 1).
    d.  If vertically aligned, fill all white (0) pixels in the output grid at column c1 between row r1 and row r2 (exclusive of r1 and r2) with blue (1).
5.  Return the modified output grid.
```python
import numpy as np
from itertools import combinations

"""
Identifies all 'red plus' shapes (a central red pixel with red N, S, E, W neighbors) in the input grid. 
For every pair of these shapes whose centers are aligned either horizontally or vertically, 
draws a blue line connecting the centers by changing the intervening white background pixels to blue.
"""

def find_plus_centers(grid):
    """
    Finds the coordinates of the center pixel of all 'red plus' shapes.
    A 'red plus' shape is defined as a red (2) pixel surrounded by red (2) pixels 
    directly above, below, left, and right.
    """
    centers = []
    height, width = grid.shape
    # Iterate through possible center locations (avoiding edges)
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            # Check if the current pixel is red
            if grid[r, c] == 2:
                # Check if all four cardinal neighbors are also red
                if (grid[r - 1, c] == 2 and
                    grid[r + 1, c] == 2 and
                    grid[r, c - 1] == 2 and
                    grid[r, c + 1] == 2):
                    centers.append((r, c))
    return centers

def transform(input_grid):
    """
    Transforms the input grid by connecting aligned 'red plus' shapes with blue lines.

    Args:
        input_grid (list of lists): The input grid represented as a 2D list.

    Returns:
        list of lists: The transformed grid with blue lines added.
    """
    # Convert input to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)
    output_grid = grid_np.copy()
    height, width = grid_np.shape

    # Find the centers of all red plus shapes
    centers = find_plus_centers(grid_np)

    # Iterate through all unique pairs of centers
    for (r1, c1), (r2, c2) in combinations(centers, 2):
        # Check for horizontal alignment
        if r1 == r2 and abs(c1 - c2) > 1:
            # Determine the start and end columns for the line
            start_c = min(c1, c2) + 1
            end_c = max(c1, c2)
            # Fill the gap with blue (1) if the pixel is currently white (0)
            for c in range(start_c, end_c):
                if output_grid[r1, c] == 0:
                    output_grid[r1, c] = 1
                    
        # Check for vertical alignment
        elif c1 == c2 and abs(r1 - r2) > 1:
            # Determine the start and end rows for the line
            start_r = min(r1, r2) + 1
            end_r = max(r1, r2)
            # Fill the gap with blue (1) if the pixel is currently white (0)
            for r in range(start_r, end_r):
                if output_grid[r, c1] == 0:
                    output_grid[r, c1] = 1

    # Convert the result back to a list of lists
    return output_grid.tolist()
```
