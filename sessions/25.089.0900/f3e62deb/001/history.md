
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 8 0 8 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 4 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 8 8 8 0 0 0 0
0 0 0 8 0 8 0 0 0 0
0 0 0 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 6 0 6 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 6 6 6 0 0 0
0 0 0 0 6 0 6 0 0 0
0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 6 6 6 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0
0 0 6 6 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_6

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 8 0 8 0 0 0 0 0
0 0 8 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 8 0 8
0 0 0 0 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task examples.

**Perception of Task Elements:**

1.  **Input Grids:** Each input grid contains a single object composed of non-white pixels set against a white background (color 0). The grid size is consistently 10x10 in the examples.
2.  **Object Shape:** The object in all examples has the same shape: a 3x3 square with the center pixel removed (matching the background color). It resembles a hollow square or the letter 'B' without the vertical bar fully closed.
3.  **Object Color:** The color of the object varies between examples: Azure (8), Yellow (4), and Magenta (6).
4.  **Output Grids:** Each output grid is the same size as the input and contains the *same* object (identical shape and color) as the input, but positioned differently. The background remains white.
5.  **Transformation:** The core transformation is the movement (translation) of the single object within the grid. The object itself is not rotated, scaled, or altered in color or shape.
6.  **Movement Pattern:** The direction and destination of the movement appear to be determined by the *color* of the object.
    *   **Azure (8) objects:** Move horizontally to the far right edge of the grid, maintaining their original row position. (Examples 1, 3, 6)
    *   **Yellow (4) objects:** Move vertically to the bottom edge of the grid, maintaining their original column position. (Example 2)
    *   **Magenta (6) objects:** Move vertically to the top edge of the grid, maintaining their original column position. (Examples 4, 5)

**YAML Fact Documentation:**


```yaml
task_description: Move a single colored object within the grid based on its color.
grid_properties:
  size: 10x10 (in examples)
  background_color: white (0)
object:
  count: 1 per grid
  shape: 3x3 square with a white center pixel
  colors_observed: [azure (8), yellow (4), magenta (6)]
  properties_preserved:
    - shape
    - color
    - size (3x3)
transformation:
  type: translation (movement)
  rule: Based on object color
  details:
    - color: azure (8)
      action: Move horizontally
      destination: Align object's left edge with (grid_width - object_width) column, keep original row. (Effectively flush right)
    - color: yellow (4)
      action: Move vertically
      destination: Align object's top edge with (grid_height - object_height) row, keep original column. (Effectively flush bottom)
    - color: magenta (6)
      action: Move vertically
      destination: Align object's top edge with row 0, keep original column. (Effectively flush top)
```


**Natural Language Program:**

1.  Identify the single contiguous block of non-white pixels in the input grid. Note its color, shape, and bounding box (top row, leftmost column, height, width).
2.  Get the dimensions (height and width) of the input grid.
3.  Create a new output grid of the same dimensions, filled entirely with the background color (white, 0).
4.  Determine the object's color:
    *   If the color is Azure (8), calculate the new top-left position: the new row is the same as the original top row, and the new column is the grid width minus the object width.
    *   If the color is Yellow (4), calculate the new top-left position: the new row is the grid height minus the object height, and the new column is the same as the original leftmost column.
    *   If the color is Magenta (6), calculate the new top-left position: the new row is 0, and the new column is the same as the original leftmost column.
5.  Copy the pixels forming the object from their original positions in the input grid to the calculated new positions in the output grid.
