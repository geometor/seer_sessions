{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms an input grid based on the positions of azure (8) and red (2) pixels, following one of two modes or a fallback:\n\n1.  **Mode 1 (Vertical Shift):** Triggered if azure (8) pixels exist in the first row (row 0).\n    *   An initial vertical pattern 'P' is defined by the columns of azure pixels in the first row.\n    *   This pattern propagates downwards. For each row 'r':\n        *   Check if the *input* row 'r' contains any red (2) pixels (triggers).\n        *   If triggers exist, find the one with the smallest column index 'c_trig'.\n        *   Compare 'c_trig' to the grid's horizontal midpoint 'M = width / 2'.\n        *   If 'c_trig < M', shift the pattern 'P' right by 1 column for this row and subsequent rows (add 1 to each column index, discard indices >= width).\n        *   If 'c_trig >= M', shift the pattern 'P' left by 1 column for this row and subsequent rows (subtract 1 from each column index, discard indices < 0).\n        *   Apply the current (potentially shifted) pattern 'P' to the output grid's row 'r': For each column 'c' in 'P', if the corresponding *input* pixel `input[r, c]` is white (0), set the *output* pixel `output[r, c]` to azure (8). This preserves non-white input pixels (like the red triggers).\n\n2.  **Mode 2 (Horizontal Blocks):** Triggered if Mode 1 is not met and azure (8) pixels exist in the first column (col 0).\n    *   Each azure pixel in the first column at row `r` triggers the drawing of three horizontal, 4-pixel-wide azure blocks in the output grid:\n        *   Block 1: Starts at `(r, 0)` (cols 0-3)\n        *   Block 2: Starts at `(r-1, 4)` (cols 4-7), if `r-1 >= 0`\n        *   Block 3: Starts at `(r-2, 8)` (cols 8-11), if `r-2 >= 0`\n    *   These blocks overwrite any existing content in the output grid at their locations. All other input pixels are preserved.\n\n3.  **Fallback:** If neither Mode 1 nor Mode 2 conditions are met, the output grid is identical to the input grid.\n\"\"\"\n\nimport numpy as np\nimport copy # Although numpy copy is used, keeping it in case needed elsewhere.\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a 2D list of integers.\n\n    Returns:\n        list[list[int]]: The transformed grid as a 2D list of integers.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n    \n    # --- Check conditions and apply transformations ---\n\n    # Condition for Mode 1: Azure (8) in the first row (row 0)\n    first_row = input_np[0, :]\n    if 8 in first_row:\n        # --- Mode 1: Vertical Shift ---\n        \n        # Calculate grid midpoint (column index)\n        midpoint = cols / 2.0\n        \n        # Find initial pattern columns from the first row\n        current_pattern_cols = set(np.where(first_row == 8)[0])\n\n        # Iterate through rows from top to bottom\n        for r in range(rows):\n            # Check if the *input* grid's current row `r` contains any red (2) pixels\n            trigger_indices = np.where(input_np[r, :] == 2)[0]\n            \n            # If triggers are found in this row, update the pattern *before* applying it\n            if len(trigger_indices) > 0:\n                # Find the column index of the first (leftmost) trigger\n                c_trig = np.min(trigger_indices)\n                \n                # Determine shift direction and update pattern\n                next_pattern_cols = set()\n                if c_trig < midpoint: # Shift right\n                    for c in current_pattern_cols:\n                        if c + 1 < cols: # Check upper bound\n                            next_pattern_cols.add(c + 1)\n                else: # c_trig >= midpoint: Shift left\n                    for c in current_pattern_cols:\n                        if c - 1 >= 0: # Check lower bound\n                            next_pattern_cols.add(c - 1)\n                            \n                # Update the pattern for this row and subsequent rows\n                current_pattern_cols = next_pattern_cols\n                \n            # Apply the current (potentially updated) pattern to this row in the output grid\n            # Only change pixels that were originally white (0) in the input\n            for c in current_pattern_cols:\n                # Ensure column index is valid (although shift logic should handle this)\n                if 0 <= c < cols:\n                    if input_np[r, c] == 0:\n                        output_np[r, c] = 8\n                        \n        # Return the result for Mode 1\n        return output_np.tolist()\n\n    # Condition for Mode 2: No azure in row 0, BUT azure (8) in the first column (col 0)\n    # This check only happens if Mode 1 condition was false\n    first_col = input_np[:, 0]\n    if 8 in first_col:\n        # --- Mode 2: Horizontal Blocks ---\n        \n        # Find all trigger row indices `r` where input[r, 0] is azure (8)\n        trigger_rows = np.where(first_col == 8)[0]\n\n        # For each trigger row, draw the three horizontal blocks\n        for r in trigger_rows:\n            # Draw Block 1: starts at (r, 0), length 4 (cols 0-3)\n            # Overwrites existing pixels in output_np\n            c_start, c_end = 0, min(4, cols)\n            if c_start < c_end : # Ensure there's actually a range to draw\n                output_np[r, c_start:c_end] = 8\n                 \n            # Draw Block 2: starts at (r-1, 4), length 4 (cols 4-7)\n            if r - 1 >= 0: # Check row boundary\n                 c_start, c_end = 4, min(8, cols)\n                 if c_start < c_end :\n                     output_np[r - 1, c_start:c_end] = 8\n\n            # Draw Block 3: starts at (r-2, 8), length 4 (cols 8-11)\n            if r - 2 >= 0: # Check row boundary\n                 c_start, c_end = 8, min(12, cols)\n                 if c_start < c_end :\n                     output_np[r - 2, c_start:c_end] = 8\n\n        # Return the result for Mode 2\n        return output_np.tolist()\n\n    # --- Fallback ---\n    # If neither Mode 1 nor Mode 2 conditions were met,\n    # return the initial copy of the input grid (which is already in output_np).\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14233,
    "candidates_token_count": 1794,
    "total_token_count": 16027,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.862685,
  "retries": 1
}