{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms an input grid based on the positions of azure (8) and red (2) pixels, following one of two modes or a fallback:\n\n1.  **Mode 1 (Vertical Shift):** Triggered if azure (8) pixels exist in the first row (row 0).\n    *   An initial vertical pattern is defined by the columns of azure pixels in the first row.\n    *   This pattern propagates downwards. For each row, white (0) pixels in the input grid at the pattern's columns are changed to azure (8) in the output grid.\n    *   If a row in the *input* grid contains a red (2) pixel, the pattern for subsequent rows shifts one column to the left (negative indices are discarded).\n    *   Non-white pixels from the input (like the red triggers) are preserved unless overwritten by the propagated pattern (which only happens if they were white initially).\n\n2.  **Mode 2 (Horizontal Blocks):** Triggered if Mode 1 is not met and azure (8) pixels exist in the first column (col 0).\n    *   Each azure pixel in the first column at row `r` triggers the drawing of three horizontal, 4-pixel-wide azure blocks in the output grid:\n        *   Block 1: Starts at `(r, 0)`\n        *   Block 2: Starts at `(r-1, 4)` (if `r-1 >= 0`)\n        *   Block 3: Starts at `(r-2, 8)` (if `r-2 >= 0`)\n    *   These blocks overwrite any existing content in the output grid at their locations. All other input pixels are preserved.\n\n3.  **Fallback:** If neither Mode 1 nor Mode 2 conditions are met, the output grid is identical to the input grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a 2D list of integers.\n\n    Returns:\n        list[list[int]]: The transformed grid as a 2D list of integers.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n\n    # --- Check conditions and apply transformations ---\n\n    # Condition for Mode 1: Azure (8) in the first row (row 0)\n    first_row = input_np[0, :]\n    if 8 in first_row:\n        # --- Mode 1: Vertical Shift ---\n        \n        # Find initial pattern columns from the first row\n        current_pattern_cols = set(np.where(first_row == 8)[0])\n\n        # Iterate through rows from top to bottom\n        for r in range(rows):\n            # Apply the current pattern to this row in the output grid\n            # Only change pixels that were originally white (0)\n            for c in current_pattern_cols:\n                # Ensure column index is valid before accessing\n                if 0 <= c < cols:\n                    if input_np[r, c] == 0:\n                        output_np[r, c] = 8\n            \n            # Check if the *input* grid's current row `r` contains any red (2) pixels\n            # This determines the pattern for the *next* row\n            if 2 in input_np[r, :]:\n                # Update pattern for the next row by shifting all columns left by 1\n                next_pattern_cols = set()\n                for c in current_pattern_cols:\n                    if c - 1 >= 0: # Discard resulting negative indices\n                        next_pattern_cols.add(c - 1)\n                # Update the pattern for the next iteration\n                current_pattern_cols = next_pattern_cols \n                \n        # Return the result for Mode 1\n        return output_np.tolist() \n\n    # Condition for Mode 2: No azure in row 0, BUT azure (8) in the first column (col 0)\n    # This check only happens if Mode 1 condition was false\n    first_col = input_np[:, 0]\n    if 8 in first_col:\n        # --- Mode 2: Horizontal Blocks ---\n        \n        # Find all trigger row indices `r` where input[r, 0] is azure (8)\n        trigger_rows = np.where(first_col == 8)[0]\n\n        # For each trigger row, draw the three horizontal blocks\n        for r in trigger_rows:\n            # Draw Block 1: starts at (r, 0), length 4\n            # Overwrites existing pixels in output_np\n            for c_offset in range(4):\n                 c = 0 + c_offset\n                 if c < cols: # Check column boundary\n                     output_np[r, c] = 8\n                 \n            # Draw Block 2: starts at (r-1, 4), length 4\n            if r - 1 >= 0: # Check row boundary\n                 for c_offset in range(4):\n                     c = 4 + c_offset\n                     if c < cols: # Check column boundary\n                         output_np[r - 1, c] = 8\n\n            # Draw Block 3: starts at (r-2, 8), length 4\n            if r - 2 >= 0: # Check row boundary\n                 for c_offset in range(4):\n                     c = 8 + c_offset\n                     if c < cols: # Check column boundary\n                         output_np[r - 2, c] = 8\n\n        # Return the result for Mode 2\n        return output_np.tolist()\n\n    # --- Fallback ---\n    # If neither Mode 1 nor Mode 2 conditions were met,\n    # return the initial copy of the input grid.\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4675,
    "candidates_token_count": 1389,
    "total_token_count": 6064,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.622232,
  "retries": 1
}