{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation reflects non-white (0) and non-blue (1) pixels across a\nhorizontal blue line (color 1) while swapping specific pairs of colors.\n\n1. Find the row index of the horizontal blue line.\n2. Initialize an output grid of the same dimensions as the input, filled with white (0).\n3. Copy the blue line from the input to the output grid.\n4. Define the color swap pairs: Azure(8) <-> Yellow(4), Red(2) <-> Green(3), Gray(5) <-> Magenta(6).\n5. Iterate through each pixel of the input grid.\n6. If a pixel is neither white (0) nor blue (1):\n   a. Calculate its vertical distance from the blue line.\n   b. Determine the reflected row index by mirroring the distance across the blue line.\n   c. Determine the swapped color based on the original color using the defined pairs.\n   d. Place the swapped color at the reflected position (same column, reflected row) in the output grid.\n7. Return the output grid.\n\"\"\"\n\n# Define the color swapping pairs\nCOLOR_SWAP_MAP = {\n    8: 4,  # Azure -> Yellow\n    4: 8,  # Yellow -> Azure\n    2: 3,  # Red -> Green\n    3: 2,  # Green -> Red\n    5: 6,  # Gray -> Magenta\n    6: 5,  # Magenta -> Gray\n    # Add other colors here if needed, mapping them to themselves if they don't swap\n    0: 0,  # White maps to White (background)\n    1: 1,  # Blue maps to Blue (reflection line)\n    7: 7,  # Orange maps to Orange (example not seen, but logical)\n    9: 9   # Maroon maps to Maroon (example not seen, but logical)\n}\n\ndef find_blue_line_row(grid):\n    \"\"\"Finds the row index of the first horizontal line of blue pixels (1).\"\"\"\n    for r in range(grid.shape[0]):\n        if np.all(grid[r, :] == 1):\n            return r\n        # Check if at least one blue pixel exists in the row (might be sufficient for some ARC tasks)\n        # More robust check might be needed depending on variations,\n        # but examples show full blue lines.\n        if 1 in grid[r,:]:\n             # Check if the entire row is either blue (1) or white (0)\n             # This handles cases where the line doesn't span the whole grid width\n             is_line = True\n             for c in range(grid.shape[1]):\n                 if grid[r, c] != 1 and grid[r,c] != 0:\n                    is_line = False\n                    break\n             if is_line and np.any(grid[r,:] == 1): # Ensure there's at least one blue pixel\n                 return r\n\n\n    # Check columns if no horizontal line found (less likely based on description)\n    # for c in range(grid.shape[1]):\n    #     if np.all(grid[:, c] == 1):\n    #         # Handle vertical line case if necessary\n    #         pass # Not needed for this specific task description\n\n    return -1 # Indicate not found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection and color swap transformation based on a horizontal blue line.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output grid with background color (white, 0)\n    output_np = np.zeros_like(input_np)\n\n    # Find the row index of the blue line\n    blue_line_row = find_blue_line_row(input_np)\n\n    if blue_line_row == -1:\n        # Handle error: Blue line not found. Maybe return input or raise error.\n        # For ARC, often returning the input or an empty grid might be expected.\n        # Based on examples, assume it's always present.\n        print(\"Error: Blue line not found!\")\n        return input_grid # Or handle differently\n\n    # Copy the blue line itself to the output grid\n    # We only copy the blue pixels, preserving the white background where the input might have 0s on the line row\n    for c in range(width):\n        if input_np[blue_line_row, c] == 1:\n             output_np[blue_line_row, c] = 1\n\n\n    # Iterate through each pixel of the input grid\n    for r in range(height):\n        for c in range(width):\n            original_color = input_np[r, c]\n\n            # Skip background (white) and the blue line itself\n            if original_color == 0 or r == blue_line_row:\n                continue\n\n            # Calculate distance from the blue line\n            # Positive distance means below the line, negative means above\n            dist = r - blue_line_row\n\n            # Calculate the reflected row index\n            reflected_r = blue_line_row - dist\n\n            # Check if the reflected row is within grid bounds\n            if 0 <= reflected_r < height:\n                # Get the swapped color\n                swapped_color = COLOR_SWAP_MAP.get(original_color, original_color) # Default to original if not in map\n\n                # Place the swapped color at the reflected position in the output grid\n                # Important: Only place if the target cell is currently background (0)\n                # or if this is the intended behavior based on potential overlaps.\n                # The examples suggest overwriting is fine.\n                output_np[reflected_r, c] = swapped_color\n\n    # Convert back to list of lists if required by the ARC environment\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3990,
    "candidates_token_count": 1337,
    "total_token_count": 5327,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.888478,
  "retries": 1
}