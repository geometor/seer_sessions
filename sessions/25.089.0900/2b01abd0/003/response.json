{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation identifies a primary axis line (horizontal or vertical) composed \nof blue (1) and white (0) pixels, selecting the one with the most blue pixels. \nIt then reflects all non-white, non-axis pixels across this line, swapping \ntheir colors according to specific pairs: Azure(8) <-> Yellow(4), \nRed(2) <-> Green(3), Gray(5) <-> Magenta(6). The axis line itself (only the \nblue pixels) is preserved in the output.\n\"\"\"\n\n# Define the color swapping pairs\nCOLOR_SWAP_MAP = {\n    8: 4,  # Azure -> Yellow\n    4: 8,  # Yellow -> Azure\n    2: 3,  # Red -> Green\n    3: 2,  # Green -> Red\n    5: 6,  # Gray -> Magenta\n    6: 5,  # Magenta -> Gray\n    # Identity mappings for other colors (including background and axis color)\n    0: 0,\n    1: 1,\n    7: 7,\n    9: 9\n}\n\ndef find_reflection_axis(grid):\n    \"\"\"\n    Finds the reflection axis (a line of blue(1) and white(0) pixels).\n    Selects the axis (horizontal or vertical) with the maximum number of blue pixels.\n    \"\"\"\n    height, width = grid.shape\n    best_axis_type = None\n    best_axis_idx = -1\n    max_blue_count = 0\n\n    # Check horizontal candidates\n    for r in range(height):\n        is_potential_axis = True\n        blue_count = 0\n        for c in range(width):\n            pixel = grid[r, c]\n            if pixel == 1:\n                blue_count += 1\n            elif pixel != 0: # Must be only 0s and 1s\n                is_potential_axis = False\n                break\n        if is_potential_axis and blue_count > 0:\n            if blue_count > max_blue_count:\n                 max_blue_count = blue_count\n                 best_axis_type = 'horizontal'\n                 best_axis_idx = r\n            # Simple tie-breaking: prefer horizontal if counts are equal\n            elif blue_count == max_blue_count and best_axis_type == 'vertical':\n                 best_axis_type = 'horizontal'\n                 best_axis_idx = r\n\n\n    # Check vertical candidates\n    for c in range(width):\n        is_potential_axis = True\n        blue_count = 0\n        for r in range(height):\n             pixel = grid[r, c]\n             if pixel == 1:\n                 blue_count += 1\n             elif pixel != 0: # Must be only 0s and 1s\n                is_potential_axis = False\n                break\n        if is_potential_axis and blue_count > 0:\n             if blue_count > max_blue_count:\n                 max_blue_count = blue_count\n                 best_axis_type = 'vertical'\n                 best_axis_idx = c\n             # Tie-breaking already handled (prefer horizontal if equal)\n\n    return best_axis_type, best_axis_idx\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection and color swap transformation based on the identified axis.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # initialize output_grid with background color (white, 0)\n    output_np = np.zeros_like(input_np)\n\n    # Find the axis of reflection\n    axis_type, axis_idx = find_reflection_axis(input_np)\n\n    if axis_type is None:\n        # No axis found - return the input grid or an empty grid?\n        # Based on examples, an axis should always be present.\n        # Returning input might be safer for unexpected cases.\n        print(\"Warning: No reflection axis found.\")\n        return input_grid\n\n    # Copy the blue pixels from the axis line to the output grid\n    if axis_type == 'horizontal':\n        for c in range(width):\n            if input_np[axis_idx, c] == 1:\n                output_np[axis_idx, c] = 1\n    elif axis_type == 'vertical':\n        for r in range(height):\n            if input_np[r, axis_idx] == 1:\n                output_np[r, axis_idx] = 1\n\n    # Iterate through each pixel of the input grid to reflect and swap\n    for r in range(height):\n        for c in range(width):\n            original_color = input_np[r, c]\n\n            # Skip background color (0)\n            if original_color == 0:\n                continue\n\n            # Skip pixels on the axis line itself\n            if axis_type == 'horizontal' and r == axis_idx:\n                continue\n            if axis_type == 'vertical' and c == axis_idx:\n                continue\n\n            # Calculate reflected position\n            reflected_r, reflected_c = r, c # Initialize\n            if axis_type == 'horizontal':\n                reflected_r = (2 * axis_idx) - r\n            elif axis_type == 'vertical':\n                reflected_c = (2 * axis_idx) - c\n\n            # Check if the reflected position is within grid bounds\n            if 0 <= reflected_r < height and 0 <= reflected_c < width:\n                # Get the swapped color\n                swapped_color = COLOR_SWAP_MAP.get(original_color, original_color)\n\n                # Place the swapped color at the reflected position in the output grid\n                output_np[reflected_r, reflected_c] = swapped_color\n\n    # Convert back to list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17508,
    "candidates_token_count": 1369,
    "total_token_count": 18877,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.748426,
  "retries": 1
}