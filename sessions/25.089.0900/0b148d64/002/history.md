
## train_1

**input:**
```
2 0 2 2 2 2 0 0 0 0 2 0 2 2 2 2 0 0 2
2 2 2 2 0 2 2 0 0 0 0 2 2 2 2 2 0 0 0
0 0 2 2 0 2 0 0 0 0 2 2 2 0 2 2 2 2 2
2 0 2 0 2 2 0 0 0 0 0 2 2 2 2 2 2 0 0
0 2 0 2 2 2 2 0 0 0 0 0 0 2 2 0 2 2 2
2 2 2 0 2 0 2 0 0 0 2 0 2 2 2 2 0 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 2 0 0 0 2 0 0 0 0 3 3 3 3 3 0 3 3
0 2 2 0 0 2 2 0 0 0 3 3 3 0 0 0 3 3 0
0 2 2 0 0 2 0 0 0 0 3 3 3 0 3 0 3 0 0
2 2 2 0 0 2 2 0 0 0 3 3 0 0 0 3 3 3 3
2 0 0 2 2 2 0 0 0 0 3 0 0 0 3 0 3 0 3
2 0 2 0 0 0 2 0 0 0 0 3 3 0 3 3 3 0 3
0 2 2 0 2 2 0 0 0 0 0 3 3 0 0 3 0 3 0
```


**output:**
```
0 3 3 3 3 3 0 3 3
3 3 3 0 0 0 3 3 0
3 3 3 0 3 0 3 0 0
3 3 0 0 0 3 3 3 3
3 0 0 0 3 0 3 0 3
0 3 3 0 3 3 3 0 3
0 3 3 0 0 3 0 3 0
```


## train_2

**input:**
```
8 8 8 8 8 0 8 8 8 8 0 0 0 0 8 8 8 8 0 8 8
8 0 0 8 0 8 0 8 8 8 0 0 0 0 8 8 8 0 0 0 8
8 8 8 0 0 0 8 8 8 8 0 0 0 0 8 8 0 8 8 8 8
8 8 0 8 8 8 8 0 8 8 0 0 0 0 8 8 0 0 0 8 8
8 8 8 8 0 8 8 0 8 8 0 0 0 0 8 8 8 0 8 8 8
0 0 0 8 8 0 8 0 0 8 0 0 0 0 8 0 0 0 8 0 0
8 8 8 8 0 0 8 0 8 0 0 0 0 0 8 8 8 0 8 8 8
8 0 0 8 0 0 8 8 0 8 0 0 0 0 8 0 8 8 8 8 8
8 8 8 8 8 8 0 8 0 0 0 0 0 0 8 8 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 2 2 2 2 0 0 0 0 8 8 0 8 8 0 8
2 0 2 2 2 0 0 2 2 2 0 0 0 0 8 8 8 8 0 8 0
0 2 2 2 2 2 2 0 2 0 0 0 0 0 8 8 8 0 0 0 8
2 2 2 2 0 2 2 2 2 2 0 0 0 0 8 8 0 8 8 8 0
2 2 2 2 2 2 0 2 0 0 0 0 0 0 8 8 8 8 8 0 0
2 2 2 2 2 0 2 0 2 2 0 0 0 0 8 0 8 0 8 8 8
2 2 0 2 2 0 0 0 0 0 0 0 0 0 8 8 0 8 0 0 8
0 2 2 0 0 2 2 0 0 2 0 0 0 0 8 0 0 0 8 8 0
2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 8 8 0 0 8 8
2 0 2 2 0 2 2 2 2 2 0 0 0 0 8 8 8 0 8 8 8
```


**output:**
```
0 2 2 2 0 0 2 2 2 2
2 0 2 2 2 0 0 2 2 2
0 2 2 2 2 2 2 0 2 0
2 2 2 2 0 2 2 2 2 2
2 2 2 2 2 2 0 2 0 0
2 2 2 2 2 0 2 0 2 2
2 2 0 2 2 0 0 0 0 0
0 2 2 0 0 2 2 0 0 2
2 2 2 2 2 2 2 2 2 2
2 0 2 2 0 2 2 2 2 2
```


## train_3

**input:**
```
0 1 0 1 1 1 0 0 1 1 0 1 0 0 0 0 0
1 0 1 0 0 0 0 0 1 1 1 1 1 1 0 1 1
1 1 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1
1 1 0 0 1 1 0 0 1 1 0 1 1 1 1 1 1
0 1 1 1 0 0 0 0 1 1 0 0 0 1 1 1 0
1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 1 1
0 0 0 1 1 0 0 0 1 1 1 0 0 1 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
4 0 0 4 0 4 0 0 1 0 0 1 1 1 1 1 1
4 4 4 4 0 4 0 0 1 0 1 1 1 1 1 1 0
4 0 4 0 0 4 0 0 0 1 0 0 1 1 1 1 1
0 4 4 4 4 0 0 0 1 1 0 0 1 0 1 0 1
4 4 4 0 4 4 0 0 1 1 1 1 1 1 1 1 0
0 4 4 4 4 0 0 0 0 1 0 0 0 0 1 1 1
0 4 4 4 0 4 0 0 0 1 0 1 0 1 1 1 0
0 4 0 0 0 0 0 0 1 0 1 1 1 0 1 0 1
4 4 0 4 0 4 0 0 1 1 1 0 0 1 1 1 0
```


**output:**
```
4 0 0 4 0 4
4 4 4 4 0 4
4 0 4 0 0 4
0 4 4 4 4 0
4 4 4 0 4 4
0 4 4 4 4 0
0 4 4 4 0 4
0 4 0 0 0 0
4 4 0 4 0 4
```

*   **Perception:**
    *   Each input grid contains two distinct colored patterns, separated vertically by one or more rows composed entirely of white pixels (0).
    *   The upper pattern uses one primary color (e.g., red in train_1, azure in train_2, blue in train_3) mixed with white.
    *   The lower pattern uses a *different* primary color (e.g., green in train_1, red in train_2, yellow in train_3) mixed with white.
    *   The output grid corresponds exactly to the lower pattern found in the input grid.
    *   The transformation involves identifying the block of separator rows (all white) and then extracting the content found below this separator.
    *   The extraction preserves the dimensions and colors (including internal white pixels) of the lower pattern. The boundaries for extraction are determined by the minimum bounding box containing all non-white pixels within the rows belonging to the lower pattern.

*   **Facts:**
    
```yaml
    task_description: Extract the lower pattern from an input grid, where patterns are separated by horizontal white space.

    elements:
      - element: grid
        role: input
        properties:
          - contains two distinct non-white patterns (upper and lower)
          - patterns are separated by one or more rows of only white pixels
          - each pattern consists of one primary non-white color and white pixels

      - element: grid
        role: output
        properties:
          - is a subgrid of the input
          - corresponds exactly to the lower pattern identified in the input
          - dimensions match the bounding box of the non-white pixels in the lower pattern section of the input

    relationships:
      - type: separation
        between: upper pattern, lower pattern
        via: horizontal rows of white pixels (value 0)
      - type: extraction
        source: input grid
        target: output grid
        details: The output grid is the minimal bounding box containing all non-white pixels found in the rows below the separating white rows in the input grid.

    actions:
      - action: locate_separator
        description: Find the contiguous block of rows containing only white pixels. Identify the last row index of this block.
      - action: identify_lower_pattern_rows
        description: Find the range of rows below the separator block that contain at least one non-white pixel.
      - action: identify_lower_pattern_columns
        description: Within the identified lower pattern rows, find the range of columns that contain at least one non-white pixel.
      - action: extract_subgrid
        description: Copy the portion of the input grid defined by the identified row and column ranges to create the output grid.
    ```


*   **Natural Language Program:**
    1.  Scan the input grid row by row from top to bottom.
    2.  Identify the first contiguous block of one or more rows where all pixels are white (0). Record the row index of the *last* row in this separator block.
    3.  Consider only the rows *below* this separator block.
    4.  Find the minimum row index (`row_start`) and maximum row index (`row_end`) of rows in this lower section that contain at least one non-white pixel.
    5.  Within the rows from `row_start` to `row_end` (inclusive), find the minimum column index (`col_start`) and maximum column index (`col_end`) that contain a non-white pixel.
    6.  Extract the subgrid from the input grid starting at `row_start`, ending at `row_end`, starting at `col_start`, and ending at `col_end`. This extracted subgrid is the output.
```python
import numpy as np

"""
Extract the lower pattern from an input grid, where patterns are separated by horizontal white space.

1.  Scan the input grid row by row from top to bottom.
2.  Identify the first contiguous block of one or more rows where all pixels are white (0). Record the row index of the *last* row in this separator block.
3.  Consider only the rows *below* this separator block.
4.  Find the minimum row index (`row_start`) and maximum row index (`row_end`) of rows in this lower section that contain at least one non-white pixel.
5.  Within the rows from `row_start` to `row_end` (inclusive), find the minimum column index (`col_start`) and maximum column index (`col_end`) that contain a non-white pixel.
6.  Extract the subgrid from the input grid starting at `row_start`, ending at `row_end`, starting at `col_start`, and ending at `col_end`. This extracted subgrid is the output.
"""

def find_separator_end_row(grid_np):
    """Finds the index of the last row of the first horizontal block of all-white rows."""
    in_separator = False
    separator_end_row = -1
    num_rows = grid_np.shape[0]

    for r in range(num_rows):
        is_all_white = np.all(grid_np[r, :] == 0)
        if is_all_white:
            if not in_separator:
                in_separator = True # Start of a potential separator block
            separator_end_row = r # Update the end row as long as we see white rows
        elif in_separator:
            # We found a non-white row *after* being in a separator block
            return separator_end_row # The previous row was the end
        # else: not in separator and not all white, continue scanning

    # If the grid ends with a separator block
    if in_separator:
        return separator_end_row

    # Should not happen based on task description, but return -1 if no separator found
    return -1 

def find_bounding_box(grid_np):
    """Finds the bounding box (min_row, max_row, min_col, max_col) of non-white pixels."""
    non_white_coords = np.argwhere(grid_np != 0)
    if non_white_coords.size == 0:
        return None # No non-white pixels
    min_row = np.min(non_white_coords[:, 0])
    max_row = np.max(non_white_coords[:, 0])
    min_col = np.min(non_white_coords[:, 1])
    max_col = np.max(non_white_coords[:, 1])
    return min_row, max_row, min_col, max_col


def transform(input_grid):
    """
    Extracts the lower pattern from an input grid separated by white space.
    """
    # Convert input to numpy array for easier processing
    grid_np = np.array(input_grid, dtype=int)
    num_rows, num_cols = grid_np.shape

    # 1 & 2. Find the end row of the separator block
    separator_end = find_separator_end_row(grid_np)

    # Handle case where no separator is found (though unlikely per examples)
    if separator_end == -1 or separator_end == num_rows - 1:
        # No separator or separator is at the very bottom, meaning no lower pattern
        # Or maybe the lower pattern starts immediately after? Let's assume no lower pattern.
        # Returning an empty grid might be appropriate, or perhaps the original grid
        # if the rules were different. Based on examples, a separator exists.
        # If the separator is the last row, there's nothing below it.
        return [] 

    # 3. Define the region below the separator
    lower_region_start_row = separator_end + 1
    lower_region_np = grid_np[lower_region_start_row:, :]

    # Check if the lower region is empty
    if lower_region_np.shape[0] == 0:
         return [] # No rows below separator

    # 4 & 5. Find the bounding box of non-white pixels *within the lower region*
    bounding_box = find_bounding_box(lower_region_np)

    # Handle case where the lower region is all white
    if bounding_box is None:
        return [] # No pattern found below separator

    min_r_local, max_r_local, min_c, max_c = bounding_box

    # 6. Extract the subgrid defined by the bounding box from the lower region
    # Note: The row indices from find_bounding_box are relative to lower_region_np
    output_grid_np = lower_region_np[min_r_local : max_r_local + 1, min_c : max_c + 1]

    # Convert back to list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
