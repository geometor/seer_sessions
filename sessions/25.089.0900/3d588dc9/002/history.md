
## train_1

**input:**
```
7 7 7 7 1 1 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 1 1 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 0 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 0 7 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 3 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 5 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 7 5 5 5
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
7 7 7 7 7 0 0 0 0 0 0 7 7 7 7 7
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 1 1 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 1 1 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 3 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 5 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 7 5 5 5
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
7 7 7 7 7 0 0 0 0 0 0 7 7 7 7 7
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
9 9 9 9 7 7 7 0 0 0 0 7 7 7 7 7
9 9 9 7 7 7 7 0 0 0 0 0 0 7 7 7
9 9 7 7 7 7 7 0 0 0 0 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 0
5 5 5 5 5 5 5 7 7 0 0 0 0 7 7 7
5 5 5 5 5 5 7 7 7 0 0 0 0 0 0 7
5 5 5 5 5 7 7 7 7 0 0 0 0 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
9 9 9 9 7 7 7 0 0 0 0 7 7 7 7 7
9 9 9 7 7 7 7 0 0 0 0 0 0 7 7 7
9 9 7 7 7 7 7 0 0 0 0 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 0
5 5 5 5 5 5 5 7 7 6 0 0 0 7 7 7
5 5 5 5 5 5 7 7 7 6 0 0 0 7 7 7
5 5 5 5 5 7 7 7 7 6 0 0 0 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's break down the transformation process for this task.

## Perception

1.  **Background:** The grid background is consistently orange (7).
2.  **Objects:** The grids contain various distinct objects composed of contiguous pixels of the same color (blue, red, green, yellow, gray, azure, maroon, white).
3.  **Key Objects:** The transformation consistently involves interaction or relationship between a gray (5) object and one specific white (0) object. Other colored objects seem irrelevant to the change.
4.  **Transformation:** A single column within the selected white object is changed to magenta (6). The rest of the grid remains unchanged.
5.  **Selection Logic:** The white object that gets modified appears to be selected based on its spatial relationship with the gray object. Specifically, it must share at least one row with the gray object and be the closest horizontally among those that share rows.
6.  **Modification Logic:** The column within the selected white object that gets changed to magenta is the one closest to the gray object. If the white object is to the left of the gray object, its rightmost column changes. If the white object is to the right of the gray object, its leftmost column changes.

## Facts YAML


```yaml
elements:
  - role: background
    color: 7 # orange
  - role: primary_actor
    color: 5 # gray
    attributes: [object]
  - role: target_object
    color: 0 # white
    attributes: [object]
  - role: modification_color
    color: 6 # magenta
  - role: distractor_objects
    color: [1, 2, 3, 4, 8, 9] # blue, red, green, yellow, azure, maroon
    attributes: [object, irrelevant]

relationships:
  - type: spatial
    description: Focus on the relative positions (rows, columns, distance) between the gray object and various white objects.
  - type: selection_criteria
    condition: Select the white object that shares at least one row with the gray object AND has the minimum horizontal distance (gap) to the gray object.
  - type: modification_location
    condition: The column to modify within the selected white object is the one immediately adjacent (horizontally) to the gray object's bounding box, or closest if there's a gap.

actions:
  - name: identify_objects
    inputs: [input_grid]
    outputs: [gray_object_location, white_object_locations]
  - name: select_target_white_object
    inputs: [gray_object_location, white_object_locations]
    criteria: [shares_row_with_gray, minimum_horizontal_distance_to_gray]
    outputs: [selected_white_object_location]
  - name: determine_modification_column
    inputs: [gray_object_location, selected_white_object_location]
    outputs: [column_index_to_modify]
  - name: apply_modification
    inputs: [input_grid, selected_white_object_location, column_index_to_modify, modification_color]
    outputs: [output_grid]
    action: Change the color of pixels in the specified column of the selected white object to magenta (6).

transformation_summary:
   Find the gray object and all white objects. Select the white object that shares rows with the gray object and is horizontally closest. Change the column of this white object that is nearest to the gray object to magenta.

```


## Natural Language Program

1.  Identify the single contiguous object composed of gray (5) pixels. Determine its row and column boundaries.
2.  Identify all distinct contiguous objects composed of white (0) pixels. Determine the row and column boundaries for each.
3.  Filter the white objects to find only those that share at least one row with the gray object.
4.  Calculate the minimum horizontal distance (gap size) between the gray object's column range and each filtered white object's column range.
5.  Select the white object that has the smallest minimum horizontal distance calculated in the previous step. (If there's a tie for minimum distance, assume there isn't one based on examples, or a tie-breaker like largest object size might be needed, but stick to minimum distance for now).
6.  Compare the column range of the selected white object with the column range of the gray object to determine if the white object is to the left or right of the gray object.
7.  If the selected white object is to the left of the gray object, identify the rightmost column index within the selected white object's boundary.
8.  If the selected white object is to the right of the gray object, identify the leftmost column index within the selected white object's boundary.
9.  Create the output grid by copying the input grid.
10. Modify the output grid by changing the color of all pixels within the selected white object that fall into the identified column (from step 7 or 8) to magenta (6).
```python
import numpy as np
from collections import deque

"""
Identify the single contiguous object composed of gray (5) pixels and all 
contiguous objects composed of white (0) pixels. Determine their bounding boxes.
Filter the white objects to find only those that share at least one row with the 
gray object. From this filtered set, select the white object that has the 
minimum horizontal distance (gap size) to the gray object. Determine if the 
selected white object is to the left or right of the gray object. If it's to 
the left, identify its rightmost column index. If it's to the right, identify 
its leftmost column index. Create the output grid by copying the input grid. 
Modify the output grid by changing the color of all pixels within the selected 
white object that fall into the identified column to magenta (6).
"""

def find_objects(grid, color):
    """
    Finds all contiguous objects of a specific color in the grid.

    Args:
        grid (np.array): The input grid.
        color (int): The color of the objects to find.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'coords' (a set of (r, c) tuples) and 'bbox'
              (a dictionary with 'row_min', 'row_max', 'col_min', 'col_max').
    """
    height, width = grid.shape
    visited = np.zeros((height, width), dtype=bool)
    objects = []

    for r in range(height):
        for c in range(width):
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.popleft()
                    obj_coords.add((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4-directional neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < height and 0 <= nc < width and \
                           grid[nr, nc] == color and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                if obj_coords:
                    bbox = {'row_min': min_r, 'row_max': max_r, 'col_min': min_c, 'col_max': max_c}
                    objects.append({'coords': obj_coords, 'bbox': bbox})
    return objects

def check_row_overlap(box1, box2):
    """Checks if two bounding boxes overlap vertically."""
    return not (box1['row_max'] < box2['row_min'] or box1['row_min'] > box2['row_max'])

def horizontal_distance(box1, box2):
    """Calculates the minimum horizontal gap between two bounding boxes."""
    if box1['col_max'] < box2['col_min']:
        # box1 is to the left of box2
        return box2['col_min'] - box1['col_max'] - 1
    elif box2['col_max'] < box1['col_min']:
        # box2 is to the left of box1
        return box1['col_min'] - box2['col_max'] - 1
    else:
        # Boxes overlap horizontally or touch
        return 0 # Or could return a negative value for overlap, but 0 is fine for finding minimum gap

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    output_grid = np.copy(input_grid)
    gray_color = 5
    white_color = 0
    magenta_color = 6

    # 1. Identify the gray object
    gray_objects = find_objects(input_grid, gray_color)
    if not gray_objects:
        return output_grid # No gray object, no change
    # Assuming only one gray object based on examples
    gray_obj = gray_objects[0]
    gray_bbox = gray_obj['bbox']

    # 2. Identify all white objects
    white_objects = find_objects(input_grid, white_color)
    if not white_objects:
        return output_grid # No white objects, no change

    # 3. Filter white objects that share rows with the gray object
    candidate_white_objects = []
    for w_obj in white_objects:
        if check_row_overlap(gray_bbox, w_obj['bbox']):
            candidate_white_objects.append(w_obj)

    if not candidate_white_objects:
        return output_grid # No white objects share rows with gray object

    # 4. Calculate horizontal distance and find the closest white object
    min_dist = float('inf')
    selected_white_obj = None
    for w_obj in candidate_white_objects:
        dist = horizontal_distance(gray_bbox, w_obj['bbox'])
        # Ensure distance is non-negative (i.e., they don't overlap horizontally)
        # Although the description implies closest, the examples show modification only happens when separated
        if dist >= 0 and dist < min_dist:
            min_dist = dist
            selected_white_obj = w_obj
        # Tie-breaking: if distances are equal, current logic picks the first one found.
        # Could add other criteria if needed (e.g., largest object, highest object). Based on examples, simple min distance seems sufficient.

    if selected_white_obj is None:
        return output_grid # No suitable white object found

    # 5. Determine which column to modify
    selected_bbox = selected_white_obj['bbox']
    col_to_modify = -1
    if selected_bbox['col_max'] < gray_bbox['col_min']:
        # White object is to the left of gray object
        col_to_modify = selected_bbox['col_max']
    elif selected_bbox['col_min'] > gray_bbox['col_max']:
        # White object is to the right of gray object
        col_to_modify = selected_bbox['col_min']
    else:
         # This case (horizontal overlap) should ideally not happen based on selection criteria,
         # but if it did, no modification would occur according to the rule's interpretation.
         return output_grid

    # 6. Apply the modification
    if col_to_modify != -1:
        for r, c in selected_white_obj['coords']:
            if c == col_to_modify:
                output_grid[r, c] = magenta_color

    return output_grid
```
