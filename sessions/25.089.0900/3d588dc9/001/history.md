
## train_1

**input:**
```
7 7 7 7 1 1 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 1 1 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 0 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 0 7 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 3 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 0 7 7 7 7 7 5 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 7 5 5 5
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
7 7 7 7 7 0 0 0 0 0 0 7 7 7 7 7
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 1 1 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 1 1 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 1 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 3 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 7 7 7 7 7 7
7 7 0 0 6 7 7 7 7 7 5 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 5 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 5 5 5 5
7 7 7 7 7 7 7 7 7 7 7 7 7 5 5 5
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
7 7 7 7 7 0 0 0 0 0 0 7 7 7 7 7
7 7 7 7 7 0 0 0 0 7 7 7 7 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
9 9 9 9 7 7 7 0 0 0 0 7 7 7 7 7
9 9 9 7 7 7 7 0 0 0 0 0 0 7 7 7
9 9 7 7 7 7 7 0 0 0 0 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 0
5 5 5 5 5 5 5 7 7 0 0 0 0 7 7 7
5 5 5 5 5 5 7 7 7 0 0 0 0 0 0 7
5 5 5 5 5 7 7 7 7 0 0 0 0 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
9 9 9 9 7 7 7 0 0 0 0 7 7 7 7 7
9 9 9 7 7 7 7 0 0 0 0 0 0 7 7 7
9 9 7 7 7 7 7 0 0 0 0 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 0
5 5 5 5 5 5 5 7 7 6 0 0 0 7 7 7
5 5 5 5 5 5 7 7 7 6 0 0 0 7 7 7
5 5 5 5 5 7 7 7 7 6 0 0 0 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's break down the transformation process for this task.

## Perception

1.  **Background:** The grid background is consistently orange (7).
2.  **Objects:** The grids contain various distinct objects composed of contiguous pixels of the same color (blue, red, green, yellow, gray, azure, maroon, white).
3.  **Key Objects:** The transformation consistently involves interaction or relationship between a gray (5) object and one specific white (0) object. Other colored objects seem irrelevant to the change.
4.  **Transformation:** A single column within the selected white object is changed to magenta (6). The rest of the grid remains unchanged.
5.  **Selection Logic:** The white object that gets modified appears to be selected based on its spatial relationship with the gray object. Specifically, it must share at least one row with the gray object and be the closest horizontally among those that share rows.
6.  **Modification Logic:** The column within the selected white object that gets changed to magenta is the one closest to the gray object. If the white object is to the left of the gray object, its rightmost column changes. If the white object is to the right of the gray object, its leftmost column changes.

## Facts YAML


```yaml
elements:
  - role: background
    color: 7 # orange
  - role: primary_actor
    color: 5 # gray
    attributes: [object]
  - role: target_object
    color: 0 # white
    attributes: [object]
  - role: modification_color
    color: 6 # magenta
  - role: distractor_objects
    color: [1, 2, 3, 4, 8, 9] # blue, red, green, yellow, azure, maroon
    attributes: [object, irrelevant]

relationships:
  - type: spatial
    description: Focus on the relative positions (rows, columns, distance) between the gray object and various white objects.
  - type: selection_criteria
    condition: Select the white object that shares at least one row with the gray object AND has the minimum horizontal distance (gap) to the gray object.
  - type: modification_location
    condition: The column to modify within the selected white object is the one immediately adjacent (horizontally) to the gray object's bounding box, or closest if there's a gap.

actions:
  - name: identify_objects
    inputs: [input_grid]
    outputs: [gray_object_location, white_object_locations]
  - name: select_target_white_object
    inputs: [gray_object_location, white_object_locations]
    criteria: [shares_row_with_gray, minimum_horizontal_distance_to_gray]
    outputs: [selected_white_object_location]
  - name: determine_modification_column
    inputs: [gray_object_location, selected_white_object_location]
    outputs: [column_index_to_modify]
  - name: apply_modification
    inputs: [input_grid, selected_white_object_location, column_index_to_modify, modification_color]
    outputs: [output_grid]
    action: Change the color of pixels in the specified column of the selected white object to magenta (6).

transformation_summary:
   Find the gray object and all white objects. Select the white object that shares rows with the gray object and is horizontally closest. Change the column of this white object that is nearest to the gray object to magenta.

```


## Natural Language Program

1.  Identify the single contiguous object composed of gray (5) pixels. Determine its row and column boundaries.
2.  Identify all distinct contiguous objects composed of white (0) pixels. Determine the row and column boundaries for each.
3.  Filter the white objects to find only those that share at least one row with the gray object.
4.  Calculate the minimum horizontal distance (gap size) between the gray object's column range and each filtered white object's column range.
5.  Select the white object that has the smallest minimum horizontal distance calculated in the previous step. (If there's a tie for minimum distance, assume there isn't one based on examples, or a tie-breaker like largest object size might be needed, but stick to minimum distance for now).
6.  Compare the column range of the selected white object with the column range of the gray object to determine if the white object is to the left or right of the gray object.
7.  If the selected white object is to the left of the gray object, identify the rightmost column index within the selected white object's boundary.
8.  If the selected white object is to the right of the gray object, identify the leftmost column index within the selected white object's boundary.
9.  Create the output grid by copying the input grid.
10. Modify the output grid by changing the color of all pixels within the selected white object that fall into the identified column (from step 7 or 8) to magenta (6).
