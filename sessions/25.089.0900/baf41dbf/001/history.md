
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 6 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 6 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 6 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 6 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 0 0 3 0 3 0 0 6 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 6 0 0 3 0 0 3 0 3 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 6 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 6 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception of the Elements:**

The input grids contain one or more hollow rectangles constructed from green (3) pixels and one or more isolated magenta (6) pixels. The background is white (0).
The output grids show the same magenta pixels in their original positions, but the green rectangles have been modified. They appear to be "extruded" or "extended" either horizontally or vertically. The direction and extent of the extension seem to depend on the position of the magenta pixels relative to the green pixels. Specifically, the extension seems to fill the space between one side of the rectangle and a boundary defined by a magenta pixel.

**YAML Facts:**


```yaml
Objects:
  - Type: HollowRectangle
    Color: Green (3)
    Properties:
      - Defined by horizontal and vertical segments of green pixels.
      - Interior is typically white (0).
      - Position and dimensions vary.
  - Type: Marker
    Color: Magenta (6)
    Properties:
      - Single pixel.
      - Position varies.

Relationships:
  - Alignment:
      - Horizontal: A Marker shares the same row index as at least one pixel of a HollowRectangle.
      - Vertical: A Marker shares the same column index as at least one pixel of a HollowRectangle.
  - Spatial: Markers can be inside, outside, horizontally aligned, or vertically aligned with the bounding box of the green pixels.

Actions:
  - Identify: Locate all HollowRectangles and Markers in the input grid.
  - Analyze Alignment: Determine if any Markers are horizontally aligned with any green pixels. Determine if any Markers are vertically aligned with any green pixels.
  - Prioritize Direction: Horizontal alignment takes precedence over vertical alignment.
  - Determine Target Boundary:
      - If horizontal alignment exists: Find the horizontally aligned Marker furthest from the green shapes (max or min column index). The target boundary is the column adjacent (column-1 for right, column+1 for left) to this Marker.
      - If only vertical alignment exists: Find the vertically aligned Marker furthest from the green shapes (max or min row index). The target boundary is the row adjacent (row-1 for bottom, row+1 for top) to this Marker.
  - Modify Rectangles:
      - For each HollowRectangle:
          - Extend the side(s) facing the target boundary (e.g., extend the right vertical segment if the target boundary is to the right) to reach the target boundary column/row.
          - Fill the newly created area between the original side and the extended side with green (3) pixels.
  - Preserve: Keep the Marker pixels unchanged in the output grid.

```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the locations of all green (3) pixels and all magenta (6) pixels in the input grid.
3.  Determine if any magenta pixel is horizontally aligned (shares a row) with any green pixel. Let `H_aligned_markers` be the set of such magenta pixels.
4.  Determine if any magenta pixel is vertically aligned (shares a column) with any green pixel. Let `V_aligned_markers` be the set of such magenta pixels.
5.  If `H_aligned_markers` is not empty (horizontal alignment takes priority):
    a.  Find the bounding box (min/max row/col) of all green pixels.
    b.  Find the magenta pixel `m_h = (r_h, c_h)` in `H_aligned_markers` which has the column index `c_h` furthest from the green bounding box columns.
    c.  If `c_h` is greater than the maximum column of the green bounding box, the target boundary column `c_target` is `c_h - 1`. The direction is right.
    d.  If `c_h` is less than the minimum column of the green bounding box, the target boundary column `c_target` is `c_h + 1`. The direction is left.
    e.  Iterate through all grid cells `(r, c)` between the original green bounding box boundary (left or right side, corresponding to the direction) and the `c_target` column (inclusive), and within the row range of the original green bounding box. If a cell `(r, c)` is horizontally adjacent to an existing green pixel or part of the extension path, change its color to green (3) in the output grid. (Effectively, for each row `r` within the original green shape's vertical span, fill the cells from the original vertical edge column up to `c_target` with green).
6.  Else if `V_aligned_markers` is not empty (no horizontal alignment, check vertical):
    a.  Find the bounding box (min/max row/col) of all green pixels.
    b.  Find the magenta pixel `m_v = (r_v, c_v)` in `V_aligned_markers` which has the row index `r_v` furthest from the green bounding box rows.
    c.  If `r_v` is greater than the maximum row of the green bounding box, the target boundary row `r_target` is `r_v - 1`. The direction is down.
    d.  If `r_v` is less than the minimum row of the green bounding box, the target boundary row `r_target` is `r_v + 1`. The direction is up.
    e.  Iterate through all grid cells `(r, c)` between the original green bounding box boundary (top or bottom side, corresponding to the direction) and the `r_target` row (inclusive), and within the column range of the original green bounding box. If a cell `(r, c)` is vertically adjacent to an existing green pixel or part of the extension path, change its color to green (3) in the output grid. (Effectively, for each column `c` within the original green shape's horizontal span, fill the cells from the original horizontal edge row up to `r_target` with green).
7.  If neither `H_aligned_markers` nor `V_aligned_markers` is empty, do nothing (output remains the initial copy of the input).
8.  Return the modified output grid.
