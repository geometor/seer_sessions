{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_enclosed_region(grid, r, c, processed_mask):\n    \"\"\"\n    Performs a Breadth-First Search (BFS) starting from (r, c) to find a potentially \n    enclosed region of the same color, checking the color(s) of its adjacent boundary.\n\n    The region is considered enclosed if:\n    1. The BFS explores all contiguous pixels of the starting color ('target_color').\n    2. During the BFS, it only encounters adjacent pixels of *one* specific non-white, \n       non-target color ('boundary_color').\n    3. The BFS does not reach the grid boundary or a white (0) pixel directly from \n       a pixel of 'target_color'.\n\n    Args:\n        grid (np.array): The input grid.\n        r (int): Starting row index.\n        c (int): Starting column index.\n        processed_mask (np.array): Boolean mask indicating pixels that have already \n                                   been processed (e.g., identified as part of a \n                                   previously found enclosed region).\n\n    Returns:\n        tuple: (is_enclosed, enclosed_pixels_set)\n               is_enclosed (bool): True if the region starting at (r, c) is enclosed\n                                   by a single non-white color different from its own, \n                                   False otherwise.\n               enclosed_pixels_set (set): A set of coordinates {(row, col)} belonging\n                                          to the contiguous region of 'target_color' \n                                          if is_enclosed is True, otherwise an empty set.\n    \"\"\"\n    H, W = grid.shape\n    target_color = grid[r, c]\n\n    # Cannot be enclosed if starting on white or already processed as enclosed\n    if target_color == 0 or processed_mask[r, c]:\n        return False, set()\n\n    queue = deque([(r, c)])\n    # visited_this_fill tracks pixels visited *during this specific BFS*\n    visited_this_fill = set([(r, c)]) \n    # potential_enclosed_pixels stores coordinates of the contiguous target_color region found\n    potential_enclosed_pixels = set([(r, c)])\n    # boundary_color stores the color of the single enclosing boundary, if found\n    boundary_color = None\n    # escaped flag is set if the region touches the grid edge, white pixels, or has a multi-colored boundary\n    escaped = False\n\n    while queue:\n        curr_r, curr_c = queue.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check if neighbor is outside the grid bounds -> Escape condition\n            if not (0 <= nr < H and 0 <= nc < W):\n                escaped = True\n                break # Reached grid edge\n\n            neighbor_coord = (nr, nc)\n            \n            # Skip if already visited in this specific BFS run\n            if neighbor_coord in visited_this_fill:\n                continue \n\n            neighbor_color = grid[nr, nc]\n\n            # If neighbor is white (background) -> Escape condition\n            if neighbor_color == 0:\n                escaped = True\n                break # Reached background\n\n            # If neighbor is the same color as the target region\n            if neighbor_color == target_color:\n                 # Add to BFS queue and track only if not already processed globally\n                if not processed_mask[nr, nc]: \n                    visited_this_fill.add(neighbor_coord)\n                    potential_enclosed_pixels.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n                # If it *is* processed, we've reached a previously handled region.\n                # This shouldn't happen if the starting check `processed_mask[r, c]` works,\n                # unless regions touch. We treat it as non-enclosed for safety, though\n                # this specific case might not occur in the examples.\n                # else: \n                #    escaped = True\n                #    break\n\n            # If neighbor is a different, non-white color (potential boundary)\n            else: \n                # This is the first boundary pixel encountered\n                if boundary_color is None:\n                    boundary_color = neighbor_color\n                # If this boundary pixel has a different color than previously found ones -> Escape condition\n                elif neighbor_color != boundary_color:\n                    escaped = True # Boundary is not monochromatic\n                    break\n                # Note: Boundary pixels are *not* added to the queue or visited_this_fill\n\n        if escaped:\n            break # Stop BFS immediately if an escape condition is met\n\n    # If we escaped, or if we never encountered any boundary pixels (e.g., a single pixel alone), it's not enclosed.\n    if escaped or boundary_color is None:\n        return False, set()\n    else:\n        # Successfully explored the region without escaping, and found a single boundary color.\n        return True, potential_enclosed_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies contiguous regions of pixels that are fully enclosed by a boundary \n    composed of a single, different non-white color. Changes the color of all \n    pixels within each such enclosed region to white (0). Pixels forming the \n    boundaries and pixels in regions that are not enclosed (touch the grid edge, \n    touch white pixels, or have multi-colored boundaries) remain unchanged.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    # Create a copy to modify, preserving the original input grid structure for checks\n    output_grid = np.copy(grid)\n    # Create a mask to keep track of pixels that have been identified as part \n    # of an enclosed region and set to white. This prevents redundant checks.\n    processed_mask = np.zeros((H, W), dtype=bool) \n\n    # Iterate through each pixel in the grid\n    for r in range(H):\n        for c in range(W):\n            # Check if this pixel could be the start of an enclosed region:\n            # - Must not be white (background)\n            # - Must not have already been processed as part of a found enclosed region\n            if grid[r, c] != 0 and not processed_mask[r, c]:\n                \n                # Perform BFS to check for enclosure and get the region's pixels if enclosed\n                is_enclosed, enclosed_pixels = find_enclosed_region(grid, r, c, processed_mask)\n\n                # If the region starting at (r, c) is confirmed to be enclosed\n                if is_enclosed:\n                    # Iterate through all pixels identified as belonging to this enclosed region\n                    for er, ec in enclosed_pixels:\n                        # Change the color of these pixels to white (0) in the output grid\n                        output_grid[er, ec] = 0\n                        # Mark these pixels as processed in the mask to avoid re-checking\n                        processed_mask[er, ec] = True\n                # If not enclosed, we do nothing to the output grid for this region, \n                # and we don't mark the pixels in processed_mask (as they might be part\n                # of a boundary for *another* region check). The loop will continue,\n                # potentially starting checks from other pixels in this same non-enclosed region,\n                # but the `find_enclosed_region` will correctly identify them as not enclosed each time.\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4568,
    "candidates_token_count": 1780,
    "total_token_count": 6348,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 52.576342,
  "retries": 1
}