{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies contiguous regions of pixels (sharing the same non-white color) \nthat are fully enclosed. Enclosure is defined by failing an \"escape test\": \na region is enclosed if a search starting from within the region cannot reach \nthe grid edge or any background (0) pixel, where the search is blocked *only* \nby adjacent pixels of a single, uniform, non-background color (the boundary color). \nIf a region is identified as enclosed, all pixels within that region are \nchanged to white (0) in the output grid. Pixels forming the boundaries \nand pixels in regions that are not enclosed remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_contiguous_region(grid, start_r, start_c, processed_mask):\n    \"\"\"\n    Finds all connected pixels of the same color as the starting pixel using BFS.\n    Marks found pixels as processed in the mask. Helper for transform.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        processed_mask (np.array): Boolean mask to mark processed pixels.\n\n    Returns:\n        tuple: (region_pixels, target_color)\n               region_pixels (set): A set of coordinates {(r, c)} belonging to \n                                    the contiguous region. Empty if start pixel\n                                    is background or already processed.\n               target_color (int): The color of the found region, or -1 if no\n                                   region found.\n    \"\"\"\n    H, W = grid.shape\n    \n    # Avoid processing background or already processed pixels\n    if grid[start_r, start_c] == 0 or processed_mask[start_r, start_c]:\n        return set(), -1\n\n    target_color = grid[start_r, start_c]\n    region_pixels = set()\n    queue = deque([(start_r, start_c)])\n    \n    # Mark the starting pixel as processed immediately and add to region\n    processed_mask[start_r, start_c] = True\n    region_pixels.add((start_r, start_c))\n\n    while queue:\n        curr_r, curr_c = queue.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check if neighbor is within bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_coord = (nr, nc)\n                # Check if neighbor has the target color and hasn't been processed yet\n                if grid[nr, nc] == target_color and not processed_mask[nr, nc]:\n                    processed_mask[nr, nc] = True # Mark as processed\n                    region_pixels.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n    \n    return region_pixels, target_color\n\n\ndef _check_enclosure(grid, region_pixels, target_color):\n    \"\"\"\n    Checks if a given region is fully enclosed according to the escape test rules.\n    Helper for transform.\n\n    Args:\n        grid (np.array): The input grid.\n        region_pixels (set): Set of coordinates {(r, c)} for the region.\n        target_color (int): The color of the region being checked.\n\n    Returns:\n        bool: True if the region is enclosed, False otherwise.\n    \"\"\"\n    H, W = grid.shape\n    potential_boundary_colors = set()\n    \n    # 1. Identify all potential boundary colors adjacent to the region\n    for r, c in region_pixels:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundary conditions for neighbor\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_coord = (nr, nc)\n                # If neighbor is outside the region and not background\n                if neighbor_coord not in region_pixels:\n                    neighbor_color = grid[nr, nc]\n                    if neighbor_color != 0: # Exclude background from boundary colors\n                         potential_boundary_colors.add(neighbor_color)\n            # Note: touching the edge or background directly doesn't automatically disqualify\n            #       enclosure here, that's checked in the escape test.\n\n    # 2. Check if there's exactly one potential boundary color\n    if len(potential_boundary_colors) != 1:\n        return False # Not enclosed if zero or multiple boundary colors\n        \n    the_boundary_color = potential_boundary_colors.pop() # Get the single boundary color\n\n    # 3. Perform the Escape Test using BFS\n    queue = deque(region_pixels) # Start BFS from all pixels in the region\n    visited_escape_test = set(region_pixels) # Track visited cells during this test\n    \n    while queue:\n        curr_r, curr_c = queue.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check 3a: Escape via grid edge\n            if not (0 <= nr < H and 0 <= nc < W):\n                return False # Escaped! Not enclosed.\n\n            neighbor_coord = (nr, nc)\n            \n            # Skip if already visited during this escape test\n            if neighbor_coord in visited_escape_test:\n                 continue\n\n            neighbor_color = grid[nr, nc]\n\n            # Check 3b: Escape via background pixel\n            if neighbor_color == 0:\n                return False # Escaped! Not enclosed.\n\n            # Check 3c: Blocked by the boundary color\n            if neighbor_color == the_boundary_color:\n                # Don't add boundary pixels to visited or queue - path is blocked here\n                continue \n            \n            # Check 3d: Found a non-boundary, non-background, non-region pixel?\n            # This implies the region check or boundary color identification might have missed something,\n            # or the grid structure is unexpected (e.g. another region touching without boundary).\n            # Treat this cautiously as not enclosed. (Though this might not be strictly necessary\n            # if the initial boundary check is robust). Let's assume this shouldn't happen\n            # if the boundary identification is correct.\n            # if neighbor_coord not in region_pixels: # Already covered by boundary check\n            #      pass \n\n            # If neighbor is traversable (not edge, background, or boundary) and not visited, explore it\n            visited_escape_test.add(neighbor_coord)\n            queue.append(neighbor_coord)\n\n    # If the BFS completes without returning False, it means no escape path was found.\n    return True # Enclosed!\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding enclosed regions and setting their pixels to white (0).\n    \"\"\"\n    # Convert input list of lists to NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    \n    # Create a copy to modify for the output\n    output_grid = np.copy(grid)\n    \n    # Create a mask to track pixels already assigned to a processed region\n    processed_mask = np.zeros((H, W), dtype=bool) \n\n    # Iterate through each pixel in the grid\n    for r in range(H):\n        for c in range(W):\n            # Only start processing if the pixel is non-white and not already processed\n            if grid[r, c] != 0 and not processed_mask[r, c]:\n                \n                # Step 1: Find the entire contiguous region starting from (r, c)\n                # This function also marks the found region in processed_mask.\n                region_pixels, target_color = _find_contiguous_region(grid, r, c, processed_mask)\n\n                # Proceed only if a valid region was found\n                if region_pixels: \n                    # Step 2: Check if this identified region is enclosed\n                    is_enclosed = _check_enclosure(grid, region_pixels, target_color)\n\n                    # Step 3: If the region is enclosed, change its pixels to white (0) in the output grid\n                    if is_enclosed:\n                        for pr, pc in region_pixels:\n                            output_grid[pr, pc] = 0\n\n    # Convert the final NumPy array back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20928,
    "candidates_token_count": 2034,
    "total_token_count": 22962,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.88137,
  "retries": 1
}