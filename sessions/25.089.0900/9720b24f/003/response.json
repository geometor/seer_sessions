{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef check_enclosure_and_get_region(grid, start_r, start_c):\n    \"\"\"\n    Performs a BFS starting from (start_r, start_c) to find the contiguous region \n    of the same color and determine if it's enclosed by a single other non-white color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n\n    Returns:\n        tuple: (is_enclosed, region_pixels)\n               is_enclosed (bool): True if the region is enclosed, False otherwise.\n               region_pixels (set): Set of coordinates {(r, c)} belonging to the \n                                     contiguous region starting at (start_r, start_c).\n                                     Returns the region regardless of enclosure status.\n    \"\"\"\n    H, W = grid.shape\n    target_color = grid[start_r, start_c]\n\n    # Should not be called on white pixels, but as a safeguard:\n    if target_color == 0:\n        return False, set()\n\n    queue = deque([(start_r, start_c)])\n    # Tracks pixels visited during this specific BFS to avoid cycles within the search\n    visited_during_search = set([(start_r, start_c)]) \n    # Stores coordinates of the contiguous target_color region found\n    region_pixels = set([(start_r, start_c)])\n    # Stores the colors of adjacent, non-target, non-white pixels\n    boundary_colors = set()\n    # Flag set if the search reaches the grid edge or a white pixel \n    # *directly from* a pixel of target_color\n    is_escaped = False\n\n    while queue:\n        curr_r, curr_c = queue.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check 1: Is neighbor outside the grid? -> Escape condition\n            if not (0 <= nr < H and 0 <= nc < W):\n                is_escaped = True\n                break # Reached grid edge from a target pixel\n\n            neighbor_color = grid[nr, nc]\n            neighbor_coord = (nr, nc)\n\n            # Check 2: Is neighbor white (background)? -> Escape condition\n            if neighbor_color == 0:\n                is_escaped = True\n                break # Reached background from a target pixel\n\n            # Check 3: Is neighbor the same color as the target region?\n            if neighbor_color == target_color:\n                # If not already visited in this search, add to queue and sets\n                if neighbor_coord not in visited_during_search:\n                    visited_during_search.add(neighbor_coord)\n                    region_pixels.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n            \n            # Check 4: Is neighbor a different, non-white color? -> Potential boundary\n            else: \n                boundary_colors.add(neighbor_color)\n\n        # If an escape condition was met during neighbor checks, stop the BFS early\n        if is_escaped:\n            break \n\n    # Determine enclosure based on BFS results\n    # Condition: Not escaped AND exactly one boundary color was found\n    is_enclosed = (not is_escaped) and (len(boundary_colors) == 1)\n    \n    return is_enclosed, region_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies contiguous regions of pixels that are fully enclosed by a boundary \n    composed of a single, different non-white color. Changes the color of all \n    pixels within each such enclosed region to white (0). Pixels forming the \n    boundaries and pixels in regions that are not enclosed (touch the grid edge, \n    touch white pixels, or have multi-colored/no boundaries) remain unchanged.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    \n    # Create a copy of the grid to modify and return\n    output_grid = np.copy(grid)\n    \n    # Create a mask to keep track of pixels that have already been processed \n    # (either identified as enclosed or checked as part of a region).\n    # This prevents redundant BFS calls for pixels in the same region.\n    processed_mask = np.zeros((H, W), dtype=bool) \n\n    # Iterate through each pixel in the grid\n    for r in range(H):\n        for c in range(W):\n            # Process only non-white pixels that haven't been processed yet\n            if grid[r, c] != 0 and not processed_mask[r, c]:\n                \n                # Perform BFS to check for enclosure and get the region's pixels\n                is_enclosed, region_pixels = check_enclosure_and_get_region(grid, r, c)\n\n                # Mark all pixels in the found region as processed, regardless of enclosure status,\n                # to avoid re-checking them later.\n                for pr, pc in region_pixels:\n                    processed_mask[pr, pc] = True\n\n                # If the region starting at (r, c) is confirmed to be enclosed\n                if is_enclosed:\n                    # Iterate through all pixels identified as belonging to this enclosed region\n                    for er, ec in region_pixels:\n                        # Change the color of these pixels to white (0) in the output grid\n                        output_grid[er, ec] = 0\n                        # Note: processed_mask was already updated for these pixels above.\n\n    # Convert the final NumPy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16374,
    "candidates_token_count": 1370,
    "total_token_count": 17744,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.917618,
  "retries": 1
}