{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies contiguous regions of pixels (sharing the same non-white color) \nthat are fully enclosed by a boundary composed entirely of a single, different, \nnon-white color. The enclosure must be complete, meaning the enclosed region \ncannot touch the grid border or any white (0) pixels. \nIf a region is identified as enclosed, all pixels within that region are \nchanged to white (0) in the output grid. Pixels forming the boundaries \nand pixels in regions that are not enclosed remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_contiguous_region(grid, start_r, start_c, processed_mask):\n    \"\"\"\n    Finds all connected pixels of the same color as the starting pixel using BFS.\n    Marks found pixels as processed in the mask.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        processed_mask (np.array): Boolean mask to mark processed pixels.\n\n    Returns:\n        set: A set of coordinates {(r, c)} belonging to the contiguous region.\n             Returns an empty set if the starting pixel is already processed or white.\n    \"\"\"\n    H, W = grid.shape\n    target_color = grid[start_r, start_c]\n\n    # Avoid processing background or already processed pixels\n    if target_color == 0 or processed_mask[start_r, start_c]:\n        return set()\n\n    region_pixels = set()\n    queue = deque([(start_r, start_c)])\n    \n    # Mark the starting pixel as processed immediately\n    processed_mask[start_r, start_c] = True\n    region_pixels.add((start_r, start_c))\n\n    while queue:\n        curr_r, curr_c = queue.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = curr_r + dr, curr_c + dc\n\n            # Check if neighbor is within bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbor_coord = (nr, nc)\n                # Check if neighbor has the target color and hasn't been processed yet\n                if grid[nr, nc] == target_color and not processed_mask[nr, nc]:\n                    processed_mask[nr, nc] = True # Mark as processed\n                    region_pixels.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n    \n    return region_pixels\n\ndef check_region_enclosure(grid, region_pixels, target_color):\n    \"\"\"\n    Checks if a given region is fully enclosed by a single, non-white color\n    different from the target color.\n\n    Args:\n        grid (np.array): The input grid.\n        region_pixels (set): Set of coordinates {(r, c)} for the region.\n        target_color (int): The color of the region being checked.\n\n    Returns:\n        bool: True if the region is enclosed, False otherwise.\n    \"\"\"\n    H, W = grid.shape\n    adjacent_boundary_pixels = set() # Store coords of adjacent pixels not in the region\n    boundary_colors = set()         # Store colors of those adjacent pixels\n    is_escaped = False              # Flag if region touches edge or background\n\n    # Find all pixels adjacent to the region\n    for r, c in region_pixels:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check 1: Neighbor is out of bounds -> Escape condition\n            if not (0 <= nr < H and 0 <= nc < W):\n                is_escaped = True\n                break # Reached grid edge\n\n            neighbor_coord = (nr, nc)\n            \n            # Check 2: Neighbor is inside the region itself -> Skip\n            if neighbor_coord in region_pixels:\n                continue\n\n            # Check 3: Neighbor is white (background) -> Escape condition\n            if grid[nr, nc] == 0:\n                is_escaped = True\n                break # Reached background\n\n            # If neighbor is adjacent, not background, and not part of the region, \n            # it's a potential boundary pixel.\n            adjacent_boundary_pixels.add(neighbor_coord)\n\n        if is_escaped: # Stop checking neighbors if escaped\n            break\n            \n    # If escaped, the region is not enclosed\n    if is_escaped:\n        return False\n\n    # If no adjacent boundary pixels were found (e.g., region fills the whole grid or is isolated somehow?)\n    # This shouldn't happen if it didn't escape, but handle defensively.\n    if not adjacent_boundary_pixels:\n        return False\n\n    # Check the colors of the boundary pixels found\n    boundary_color_found = None\n    for ar, ac in adjacent_boundary_pixels:\n        adj_color = grid[ar, ac]\n        \n        # Boundary pixel color must not be the target color (should be guaranteed by logic above, but check)\n        # And must not be background (also checked above)\n        if adj_color == target_color or adj_color == 0: \n             # This case indicates a logic error or unexpected input structure\n             # print(f\"Warning: Unexpected adjacent color {adj_color} found for region color {target_color}\")\n             return False \n\n        # If this is the first boundary color encountered\n        if boundary_color_found is None:\n            boundary_color_found = adj_color\n        # If a different boundary color is found -> Not enclosed by a *single* color\n        elif adj_color != boundary_color_found:\n            return False\n\n    # If we passed all checks: not escaped and exactly one boundary color found\n    return boundary_color_found is not None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding enclosed regions and setting their pixels to white (0).\n    \"\"\"\n    # Convert input list of lists to NumPy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    \n    # Create a copy to modify for the output\n    output_grid = np.copy(grid)\n    \n    # Create a mask to track pixels already processed as part of a region\n    processed_mask = np.zeros((H, W), dtype=bool) \n\n    # Iterate through each pixel in the grid\n    for r in range(H):\n        for c in range(W):\n            # Check if this pixel is non-white and hasn't been processed yet\n            if grid[r, c] != 0 and not processed_mask[r, c]:\n                target_color = grid[r, c]\n                \n                # 1. Find the entire contiguous region starting from (r, c)\n                #    This also marks all pixels in the region as processed in the mask.\n                region_pixels = find_contiguous_region(grid, r, c, processed_mask)\n\n                # If a valid region was found (find_contiguous_region handles the initial check)\n                if region_pixels: \n                    # 2. Check if this identified region is enclosed\n                    is_enclosed = check_region_enclosure(grid, region_pixels, target_color)\n\n                    # 3. If the region is enclosed, change its pixels to white (0) in the output grid\n                    if is_enclosed:\n                        for pr, pc in region_pixels:\n                            output_grid[pr, pc] = 0\n\n    # Convert the final NumPy array back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25393,
    "candidates_token_count": 1811,
    "total_token_count": 27204,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.819697,
  "retries": 1
}