
## train_1

**input:**
```
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 2 2 2 0 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 1 1 2 0 2 0 0
0 0 2 1 1 2 0 2 0 0
0 0 2 1 1 2 0 2 0 0
0 0 2 2 2 2 0 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 2 2 2 0 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 2 2 2 0 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1
```


## train_4

**input:**
```
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 0 0 2 0 2 0 0
0 0 2 0 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 2 1 2 0 0
0 0 2 0 0 2 1 2 0 0
0 0 2 0 0 2 1 2 0 0
0 0 2 0 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 0 0 0 0 2 0 0
0 0 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 2 1 1 1 1 2 0 0
0 0 2 1 1 1 1 2 0 0
0 0 2 1 1 1 1 2 0 0
0 0 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

**Perception of Task Elements:**

1.  **Input Structure:** Each input grid contains a white (0) background, a single blue (1) pixel, and a structure composed of red (2) pixels.
2.  **Output Structure:** The output grid is derived from the input. The original blue pixel is always changed to white (0). Some white pixels in the input are changed to blue (1) in the output. The red structure remains unchanged.
3.  **Key Objects:**
    *   The single blue pixel (trigger object).
    *   The red structure (boundary/shape object).
    *   White pixels (background/fillable areas).
4.  **Transformation:** The transformation involves a conditional fill operation. The location of the input blue pixel relative to the horizontal extent of the red structure determines the fill rule.
5.  **Fill Rule 1 (Blue Trigger Inside Red Span):** If the column index of the blue trigger pixel falls within the minimum and maximum column indices occupied by the red structure, the transformation identifies white regions enclosed by the red structure and the grid boundaries. The largest such enclosed region is then filled with blue. If no region is enclosed (e.g., the red structure has gaps allowing white pixels to 'escape' to the boundary), this rule might transition to Rule 2. Example train_3 demonstrates this transition where the broken 'U' has no enclosed region, leading to the bottom row fill.
6.  **Fill Rule 2 (Blue Trigger Outside Red Span / No Enclosed Region):** If the column index of the blue trigger pixel is outside the horizontal span of the red structure, OR if Rule 1 applies but finds no fully enclosed white region, the transformation fills the entire bottom row of the grid with blue.
7.  **Invariant:** The red structure's position and shape remain identical between input and output.

**YAML Fact Document:**


```yaml
task_description: Conditional fill based on a trigger pixel and a boundary structure.

elements:
  - id: background
    color: white (0)
    role: Fillable area, default state.
  - id: trigger_pixel
    color: blue (1)
    count: 1
    role: Determines the fill condition based on its horizontal position relative to the boundary structure. Disappears in the output.
  - id: boundary_structure
    color: red (2)
    role: Defines boundaries for potential fill areas and determines the horizontal span for the trigger condition. Remains unchanged.
  - id: fill_pixels
    color: blue (1)
    role: Appear in the output, replacing specific white pixels according to the transformation rule.

relationships:
  - type: relative_position
    from: trigger_pixel
    to: boundary_structure
    detail: The column index of the trigger_pixel is compared to the minimum and maximum column indices of the boundary_structure.
  - type: enclosure
    element: boundary_structure
    target: background (white pixels)
    detail: The boundary_structure, potentially along with grid edges, may enclose regions of white pixels. An enclosed region is one where white pixels cannot reach the grid boundary via adjacent (non-diagonal) white pixels without crossing the boundary_structure.
  - type: boundary
    element: grid_edges
    role: Act as implicit boundaries for enclosure.

actions:
  - name: check_trigger_position
    input: trigger_pixel, boundary_structure
    output: boolean (is trigger column within boundary horizontal span?)
  - name: find_enclosed_regions
    input: grid, boundary_structure
    output: list of enclosed white regions (sets of coordinates)
  - name: fill_region
    target: largest enclosed white region
    color: blue (1)
    condition: Trigger position is within span AND enclosed region exists.
  - name: fill_bottom_row
    target: bottom row of the grid
    color: blue (1)
    condition: Trigger position is outside span OR no enclosed region exists.
  - name: remove_trigger
    target: trigger_pixel
    action: change color to white (0)
    condition: always performed.
```


**Natural Language Program:**

1.  Identify the coordinates of the single blue pixel (the trigger) and all red pixels (the boundary structure) in the input grid.
2.  Determine the minimum and maximum column indices occupied by the red pixels to find the horizontal span of the boundary structure.
3.  Check if the column index of the blue trigger pixel falls within this horizontal span (inclusive).
4.  **Case 1: Trigger column is WITHIN the span:**
    *   Identify all regions of connected white pixels that are fully enclosed (cannot reach the grid boundary by moving horizontally or vertically through only white pixels without crossing a red pixel).
    *   If one or more enclosed white regions exist:
        *   Select the largest enclosed region (by area/number of pixels).
        *   Create the output grid by copying the input grid, changing the original blue trigger pixel to white, and changing all pixels within the selected largest enclosed region to blue.
    *   If no enclosed white regions exist:
        *   Proceed to Case 2 logic (fill bottom row).
5.  **Case 2: Trigger column is OUTSIDE the span OR (Case 1 applied but found no enclosed regions):**
    *   Create the output grid by copying the input grid, changing the original blue trigger pixel to white, and changing all pixels in the bottom row (last row) to blue.
6.  Output the modified grid.
