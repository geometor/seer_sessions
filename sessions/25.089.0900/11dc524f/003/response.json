{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a mobile red object (color 2) and a static gray target object (color 5) against an orange background (color 7).\nThe red object is moved iteratively one step at a time towards the gray object.\nThe direction of movement in each step is determined by the axis (vertical 'y' or horizontal 'x') corresponding to the largest absolute difference between the objects' bounding box centers. Vertical movement is prioritized if the absolute differences are equal.\nThe movement stops when any pixel of the red object becomes adjacent (horizontally, vertically, or diagonally) to any pixel of the gray object.\nThe shape of the red object is preserved throughout the movement. The gray object and the background remain unchanged.\n\"\"\"\n\ndef find_object_pixels(grid, color):\n    \"\"\"Finds all (row, col) coordinates of pixels with the given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    # Return as a list of tuples, which is easier to work with than two separate arrays\n    return list(zip(rows, cols))\n\ndef get_bounding_box_center(coords):\n    \"\"\"Calculates the geometric center of the bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    # Unzip the list of tuples into separate lists/tuples of rows and columns\n    rows, cols = zip(*coords)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    # Calculate center using floating point division\n    center_row = (min_row + max_row) / 2.0\n    center_col = (min_col + max_col) / 2.0\n    return center_row, center_col\n\ndef is_adjacent(coords1, coords2):\n    \"\"\"Checks if any coordinate pair from coords1 is adjacent (including diagonals) to any pair in coords2.\"\"\"\n    if not coords1 or not coords2:\n        return False\n    # Convert lists of coordinates to sets for potentially faster lookups if needed,\n    # although for small objects, iteration might be just as fast or faster.\n    # Here, nested loops are clear and sufficient for typical ARC object sizes.\n    for r1, c1 in coords1:\n        for r2, c2 in coords2:\n            # Check if the Chebyshev distance (max coordinate difference) is 1 or less.\n            # <= 1 covers the pixel itself and its 8 neighbours.\n            # Since we compare pixels from two *different* objects, distance 0 is impossible\n            # unless they overlap, and distance 1 means adjacency.\n            if max(abs(r1 - r2), abs(c1 - c2)) <= 1:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Moves the red object towards the gray object until they are adjacent.\n    \"\"\"\n    # Define colors\n    BACKGROUND_COLOR = 7\n    MOBILE_COLOR = 2 # red\n    TARGET_COLOR = 5 # gray\n\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    grid_height, grid_width = output_grid.shape\n\n    # Locate the objects\n    current_mobile_coords = find_object_pixels(output_grid, MOBILE_COLOR)\n    target_coords = find_object_pixels(output_grid, TARGET_COLOR)\n\n    # If either object is missing, return the original grid\n    if not current_mobile_coords or not target_coords:\n        return output_grid\n\n    # Set a maximum number of iterations to prevent potential infinite loops\n    max_iterations = grid_height * grid_width # A safe upper bound\n\n    for iteration in range(max_iterations):\n        # --- Check Stopping Condition ---\n        if is_adjacent(current_mobile_coords, target_coords):\n            # Objects are adjacent, movement stops, return current grid state\n            break\n\n        # --- Calculate Movement Direction ---\n        mobile_center = get_bounding_box_center(current_mobile_coords)\n        target_center = get_bounding_box_center(target_coords)\n\n        # This check should technically not be needed if objects were found initially, but good for robustness\n        if mobile_center is None or target_center is None:\n             break # Should not happen\n\n        # Calculate vector from mobile center to target center\n        delta_row = target_center[0] - mobile_center[0]\n        delta_col = target_center[1] - mobile_center[1]\n\n        # Determine step direction (dr, dc)\n        dr, dc = 0, 0\n        # Prioritize movement along the axis with the largest absolute difference\n        # If differences are equal, prioritize vertical movement (row change)\n        if abs(delta_row) >= abs(delta_col):\n            if abs(delta_row) > 1e-6: # Add tolerance for float comparison\n               dr = int(np.sign(delta_row))\n            elif abs(delta_col) > 1e-6: # If row diff is effectively zero, try col\n               dc = int(np.sign(delta_col))\n            # If both are zero (centers coincide), dr=0, dc=0 -> no move\n        else: # abs(delta_col) > abs(delta_row)\n             if abs(delta_col) > 1e-6:\n                dc = int(np.sign(delta_col))\n             elif abs(delta_row) > 1e-6: # If col diff is effectively zero, try row\n                dr = int(np.sign(delta_row))\n             # If both are zero, dr=0, dc=0 -> no move\n\n        # If no move direction is determined (e.g., centers coincide perfectly but not adjacent)\n        if dr == 0 and dc == 0:\n             # This might indicate an issue or that the objects are aligned but not touching.\n             # Since adjacency is checked first, this state implies no further valid move exists\n             # according to the center-based rule. Stop iteration.\n             break\n\n        # --- Apply Movement ---\n\n        # 1. Calculate the potential next coordinates\n        next_mobile_coords = []\n        valid_move = True\n        for r, c in current_mobile_coords:\n            nr, nc = r + dr, c + dc\n            # Check grid boundaries\n            if 0 <= nr < grid_height and 0 <= nc < grid_width:\n                # Check for overlap with the *static* target object\n                if output_grid[nr, nc] == TARGET_COLOR:\n                    # This move would cause an overlap. Since we stop at adjacency,\n                    # this state shouldn't be reached if the logic is correct.\n                    # Stop movement *before* this overlap occurs.\n                    valid_move = False\n                    # print(\"Warning: Preventing move that would overlap target.\")\n                    break # Break inner loop (coordinate calculation)\n                next_mobile_coords.append((nr, nc))\n            else:\n                # Move goes out of bounds\n                valid_move = False\n                # print(\"Warning: Preventing move out of bounds.\")\n                break # Break inner loop (coordinate calculation)\n\n        # If the move was deemed invalid (out of bounds or overlap), stop the entire process.\n        if not valid_move:\n            break # Break outer loop (iterations)\n\n        # 2. Erase the mobile object from its old position\n        for r, c in current_mobile_coords:\n            # Only erase if it wasn't part of the target (shouldn't happen, but safety)\n            if output_grid[r, c] == MOBILE_COLOR:\n                output_grid[r, c] = BACKGROUND_COLOR\n\n        # 3. Draw the mobile object at its new position\n        for nr, nc in next_mobile_coords:\n            output_grid[nr, nc] = MOBILE_COLOR\n\n        # 4. Update the coordinates for the next iteration\n        current_mobile_coords = next_mobile_coords\n\n    # Return the final state of the grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13189,
    "candidates_token_count": 1844,
    "total_token_count": 15033,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.292603,
  "retries": 1
}