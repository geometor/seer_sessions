{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct color objects in the input grid. Determines which object \nis the 'mirror' and which is the 'pattern' based on the number of contiguous \ncomponents each object has (the object with more components is the mirror). \nCalculates the vertical and horizontal reflection axes based on the min/max row/col \nof the mirror object. Creates an output grid containing the mirror object in its \noriginal position and four copies of the pattern object: the original, one reflected \nvertically, one reflected horizontally, and one reflected both vertically and horizontally, \nall relative to the mirror's axes.\n\"\"\"\n\ndef find_objects_by_color_and_components(grid, background_color=0):\n    \"\"\"\n    Finds objects by grouping pixels of the same non-background color.\n    Also counts the number of contiguous components for each color object.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a \n              color object and contains: 'color', 'coords' (set of (r, c)), \n              'count' (pixel count), 'min_r', 'max_r', 'min_c', 'max_c', \n              and 'components' (number of contiguous parts). Returns empty \n              list if no non-background pixels found.\n    \"\"\"\n    objects = {}\n    rows, cols = grid.shape\n    visited_pixels = np.zeros_like(grid, dtype=bool) # For grouping pixels by color\n    visited_components = np.zeros_like(grid, dtype=bool) # For counting components\n\n    # First pass: Group all pixels by color and find bounds\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in objects:\n                    objects[color] = {\n                        'color': color,\n                        'coords': set(),\n                        'count': 0,\n                        'min_r': r, 'max_r': r,\n                        'min_c': c, 'max_c': c,\n                        'components': 0 # Initialize component count\n                    }\n                objects[color]['coords'].add((r, c))\n                objects[color]['count'] += 1\n                objects[color]['min_r'] = min(objects[color]['min_r'], r)\n                objects[color]['max_r'] = max(objects[color]['max_r'], r)\n                objects[color]['min_c'] = min(objects[color]['min_c'], c)\n                objects[color]['max_c'] = max(objects[color]['max_c'], c)\n                visited_pixels[r,c] = True # Mark as belonging to *some* object\n\n    # Second pass: Count contiguous components for each color found\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # If it's part of a color object and not yet visited for component counting\n            if color != background_color and color in objects and not visited_components[r, c]:\n                # Start a BFS/DFS to find all connected pixels of the *same* color\n                q = deque([(r, c)])\n                visited_components[r, c] = True\n                current_component_color = color\n                \n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited_components[nr, nc] and \\\n                           grid[nr, nc] == current_component_color:\n                            visited_components[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Finished exploring a contiguous component, increment count for that color\n                objects[current_component_color]['components'] += 1\n\n    object_list = list(objects.values())\n    # Sort by color potentially, though not strictly necessary for the logic below\n    object_list.sort(key=lambda x: x['color'])\n    return object_list\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the 4-fold symmetry transformation.\n\n    Args:\n        input_grid (np.array): The input 2D numpy array.\n\n    Returns:\n        np.array: The transformed 2D numpy array.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Start with background\n\n    # Find the objects and their component counts\n    objects = find_objects_by_color_and_components(input_grid)\n\n    # Expect exactly two distinct colors/objects\n    if len(objects) != 2:\n        # If not 2 objects, return background or input? Return background for now.\n        print(f\"Warning: Expected 2 distinct color objects, found {len(objects)}. Returning background grid.\")\n        return output_grid \n\n    obj1 = objects[0]\n    obj2 = objects[1]\n\n    # Identify mirror (more components) and pattern (fewer components)\n    if obj1['components'] > obj2['components']:\n        mirror_object = obj1\n        pattern_object = obj2\n    elif obj2['components'] > obj1['components']:\n        mirror_object = obj2\n        pattern_object = obj1\n    else:\n        # Tie-breaking needed if component counts are equal.\n        # Example 3 had equal pixel counts and BB areas. Let's default \n        # to the first object found (lower color index after sort) as mirror \n        # if components are equal, although this is an assumption.\n        print(\"Warning: Equal component counts. Assuming object with lower color index is mirror.\")\n        mirror_object = obj1 # obj1 has lower color index due to sorting\n        pattern_object = obj2\n        # Alternatively, could try other tie-breakers or return error/default.\n\n    # Calculate reflection axes sums from the mirror object\n    axis_sum_V = mirror_object['min_r'] + mirror_object['max_r']\n    axis_sum_H = mirror_object['min_c'] + mirror_object['max_c']\n\n    # Place the mirror object onto the output grid\n    for r, c in mirror_object['coords']:\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = mirror_object['color']\n\n    # Place the four symmetric copies of the pattern object\n    pattern_color = pattern_object['color']\n    for r, c in pattern_object['coords']:\n        # Calculate reflected coordinates\n        r_vr = axis_sum_V - r\n        c_hr = axis_sum_H - c\n\n        # Draw original (TR quadrant relative to mirror center)\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = pattern_color\n        \n        # Draw vertically reflected (BR quadrant)\n        if 0 <= r_vr < rows and 0 <= c < cols:\n            output_grid[r_vr, c] = pattern_color\n\n        # Draw horizontally reflected (TL quadrant)\n        if 0 <= r < rows and 0 <= c_hr < cols:\n            output_grid[r, c_hr] = pattern_color\n\n        # Draw both reflected (BL quadrant)\n        if 0 <= r_vr < rows and 0 <= c_hr < cols:\n            output_grid[r_vr, c_hr] = pattern_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 33662,
    "candidates_token_count": 1824,
    "total_token_count": 35486,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 50.47784,
  "retries": 1
}