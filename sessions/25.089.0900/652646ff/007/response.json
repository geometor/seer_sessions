{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies maximal contiguous regions of pixels whose colors are not the background color and not designated noise colors (Gray=5, Orange=7, Maroon=9).\nFilters these regions, keeping only those whose minimal bounding box is exactly 6x6 pixels.\nDetermines the top-left corner (row, column) for each filtered region's bounding box.\nCollects these top-left corners. Sorts them primarily by row index, secondarily by column index.\nChecks the original input grid for the presence of any Orange (7) pixels. If found, reverses the sorted order of corners.\nFor each corner in the final ordered list:\n  1. Extracts the 6x6 pixel subgrid from the input grid starting at that corner.\n  2. Creates a cleaned version of the extracted 6x6 subgrid by replacing any pixels matching the noise colors (5, 7, 9) with the background color.\nVertically stacks the cleaned 6x6 subgrids in the final determined order to produce the output grid.\n\"\"\"\n\ndef find_maximal_objects_and_bboxes(grid, background_color, noise_colors):\n    \"\"\"\n    Finds maximal contiguous regions of non-background, non-noise colors and their bounding boxes.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n        noise_colors (set): A set of colors defined as noise.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              - 'min_row': Min row of the bounding box.\n              - 'max_row': Max row of the bounding box.\n              - 'min_col': Min col of the bounding box.\n              - 'max_col': Max col of the bounding box.\n              # - 'pixels': A set of (row, col) tuples comprising the object. (Optional)\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited pixel that is not background or noise\n            if not visited[r, c] and color != background_color and color not in noise_colors:\n                q = [(r, c)]\n                visited[r, c] = True\n                # object_pixels = set([(r, c)]) # Optional: collect pixels if needed\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Standard BFS\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n                    \n                    # Update bounding box for the current pixel\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if visited\n                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:\n                            neighbor_color = grid[nr, nc]\n                            # Add neighbor if it's part of the object (not background or noise)\n                            if neighbor_color != background_color and neighbor_color not in noise_colors:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                # object_pixels.add((nr,nc)) # Optional\n\n                # Store the bounding box of the found maximal object\n                objects.append({\n                    'min_row': min_r, 'max_row': max_r, \n                    'min_col': min_c, 'max_col': max_c,\n                    # 'pixels': object_pixels # Optional\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    # Handle empty input grid case\n    if rows == 0 or cols == 0:\n        return []\n\n    # 1. Determine the background color\n    # Use np.unique which is efficient for this\n    colors, counts = np.unique(grid, return_counts=True)\n    if len(colors) == 0: # Should not happen if rows/cols > 0, but safe check\n       return []\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Define noise colors\n    noise_colors = {5, 7, 9}\n\n    # 3. Find all maximal contiguous regions (non-background, non-noise)\n    # 4. Calculate their bounding boxes (done within the helper function)\n    all_objects = find_maximal_objects_and_bboxes(grid, background_color, noise_colors)\n    \n    # 5. Filter regions to keep only those with an exactly 6x6 bounding box\n    valid_object_corners = []\n    for obj in all_objects:\n        height = obj['max_row'] - obj['min_row'] + 1\n        width = obj['max_col'] - obj['min_col'] + 1\n        if height == 6 and width == 6:\n            # 6. Collect the top-left corner coordinates\n            valid_object_corners.append((obj['min_row'], obj['min_col']))\n\n    # Handle case where no valid 6x6 regions are found\n    if not valid_object_corners:\n        return [] \n\n    # 7. Sort unique corners (top-to-bottom, then left-to-right)\n    # Ensure uniqueness although BFS should find distinct maximal regions\n    unique_sorted_corners = sorted(list(set(valid_object_corners)), key=lambda x: (x[0], x[1]))\n\n    # 8. Check for Orange (7) pixels anywhere in the input grid\n    has_orange_signal = np.any(grid == 7)\n\n    # 9. Reverse order if Orange (7) is present\n    if has_orange_signal:\n        unique_sorted_corners.reverse()\n\n    # 10. Initialize list for cleaned 6x6 output grids\n    output_subgrids = []\n\n    # 11. Iterate through the final ordered corners\n    for r_corner, c_corner in unique_sorted_corners:\n        # 11a. Extract the 6x6 region\n        # Check if extraction is within bounds (should be guaranteed by 6x6 bbox filter if grid dims >= 6)\n        if r_corner + 6 <= rows and c_corner + 6 <= cols:\n            subgrid = grid[r_corner : r_corner + 6, c_corner : c_corner + 6].copy()\n            \n            # 11b. Clean the subgrid (replace noise with background)\n            # Create a mask for noise colors within the subgrid\n            noise_mask = np.isin(subgrid, list(noise_colors))\n            # Replace noise pixels with the background color\n            subgrid[noise_mask] = background_color\n                        \n            # 11c. Add cleaned subgrid to the list\n            output_subgrids.append(subgrid)\n        # else: # Defensive check, should not happen with current logic\n            # print(f\"Warning: Cannot extract 6x6 grid at {r_corner, c_corner} from grid of size {rows, cols}\") \n\n\n    # 12. Vertically stack the cleaned grids\n    if not output_subgrids:\n         # This case is hit if valid_object_corners was empty initially\n         return [] \n         \n    final_output_grid_np = np.vstack(output_subgrids)\n\n    # Convert final numpy array back to list of lists for ARC standard output\n    return final_output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34048,
    "candidates_token_count": 1902,
    "total_token_count": 35950,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.915106,
  "retries": 1
}