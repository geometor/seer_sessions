{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies maximal contiguous objects composed of non-background, non-noise colors \nin the input grid. Filters these objects to keep only those whose minimal bounding \nbox is exactly 6x6 pixels. The top-left corners of these bounding boxes define \nthe 6x6 regions to be extracted. These regions are ordered primarily by the row \nand secondarily by the column of their top-left corner. This order is reversed \nif any Orange (7) pixel exists anywhere in the input grid. Each selected 6x6 region \nis extracted from the input, cleaned by replacing noise pixels (Gray=5, Orange=7, \nMaroon=9) with the identified background color, and then these cleaned 6x6 grids \nare vertically stacked in the determined order to form the final output grid.\n\"\"\"\n\ndef find_objects_and_bboxes(grid, background_color, noise_colors):\n    \"\"\"\n    Finds contiguous objects of non-background, non-noise colors and their bounding boxes.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n        noise_colors (set): A set of colors defined as noise.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary contains:\n              - 'min_row': Min row of the bounding box.\n              - 'max_row': Max row of the bounding box.\n              - 'min_col': Min col of the bounding box.\n              - 'max_col': Max col of the bounding box.\n              - 'pixels': A set of (row, col) tuples comprising the object. (Optional, useful for debugging)\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited pixel that is not background or noise\n            if not visited[r, c] and color != background_color and color not in noise_colors:\n                q = [(r, c)]\n                visited[r, c] = True\n                object_pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    \n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if visited\n                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:\n                            neighbor_color = grid[nr, nc]\n                            # Add neighbor if it's part of the object (not background or noise)\n                            if neighbor_color != background_color and neighbor_color not in noise_colors:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                object_pixels.add((nr,nc))\n                \n                # Store the bounding box of the found object\n                objects.append({\n                    'min_row': min_r, 'max_row': max_r, \n                    'min_col': min_c, 'max_col': max_c,\n                    'pixels': object_pixels # Optional\n                })\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    # Handle empty input grid case\n    if rows == 0 or cols == 0:\n        return []\n\n    # 1. Identify the background color\n    colors, counts = np.unique(grid, return_counts=True)\n    if len(colors) == 0:\n       return []\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Define noise colors\n    noise_colors = {5, 7, 9}\n\n    # 3. Find all distinct contiguous objects (non-background, non-noise)\n    all_objects = find_objects_and_bboxes(grid, background_color, noise_colors)\n    \n    # 4. Filter objects to keep only those with an exactly 6x6 bounding box\n    valid_object_corners = []\n    for obj in all_objects:\n        height = obj['max_row'] - obj['min_row'] + 1\n        width = obj['max_col'] - obj['min_col'] + 1\n        if height == 6 and width == 6:\n            # 5. Collect the top-left corner coordinates\n            valid_object_corners.append((obj['min_row'], obj['min_col']))\n\n    # Handle case where no valid 6x6 objects are found\n    if not valid_object_corners:\n        return [] \n\n    # 6. Sort corners (top-to-bottom, then left-to-right)\n    # Ensure uniqueness in case multiple objects map to the same bbox (unlikely but possible)\n    unique_sorted_corners = sorted(list(set(valid_object_corners)), key=lambda x: (x[0], x[1]))\n\n    # 7. Check for Orange (7) pixels anywhere in the input grid\n    has_orange_signal = np.any(grid == 7)\n\n    # 8. Reverse order if Orange (7) is present\n    if has_orange_signal:\n        unique_sorted_corners.reverse()\n\n    # 9. Initialize list for cleaned 6x6 output grids\n    output_subgrids = []\n\n    # 10. Iterate through the final ordered corners\n    for r_corner, c_corner in unique_sorted_corners:\n        # 11a. Extract the 6x6 region\n        # Check if extraction is within bounds (should be guaranteed by object finding if grid dims >= 6)\n        if r_corner + 6 <= rows and c_corner + 6 <= cols:\n            subgrid = grid[r_corner : r_corner + 6, c_corner : c_corner + 6].copy()\n            \n            # 11b. Clean the subgrid (replace noise with background)\n            for r_sub in range(6):\n                for c_sub in range(6):\n                    if subgrid[r_sub, c_sub] in noise_colors:\n                        subgrid[r_sub, c_sub] = background_color\n                        \n            # 11c. Add cleaned subgrid to the list\n            output_subgrids.append(subgrid)\n        # else: # Should not happen based on examples and logic, but good defensive programming\n            # print(f\"Warning: Cannot extract 6x6 grid at {r_corner, c_corner} from grid of size {rows, cols}\") \n\n\n    # 12. Vertically stack the cleaned grids\n    if not output_subgrids:\n         return [] # Return empty list if no valid subgrids could be processed\n         \n    final_output_grid_np = np.vstack(output_subgrids)\n\n    # Convert final numpy array back to list of lists\n    return final_output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27720,
    "candidates_token_count": 1779,
    "total_token_count": 29499,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.934468,
  "retries": 1
}