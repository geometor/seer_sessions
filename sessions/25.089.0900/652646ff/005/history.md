
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```


**output:**
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```


## train_3

**input:**
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```


**output:**
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```


**output:**
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```

**Perception of the Task Elements**

1.  **Input/Output Structure:** The input is a larger grid, and the output is a taller, narrower grid composed of vertically stacked smaller grids.
2.  **Background Color:** Each input grid has a dominant background color (Red, Green, Yellow, Azure in the examples). This background color is preserved in the output grid's background areas.
3.  **Objects/Shapes:** Embedded within the input grid's background are distinct geometric shapes made of various colors (Yellow, Azure, Green, Blue, Red). These shapes appear to be the primary focus. Based on the output dimensions, these shapes seem to occupy a 6x6 bounding box.
4.  **Noise Pixels:** Some input grids contain scattered pixels of specific colors (Gray=5, Orange=7, Maroon=9 - although Maroon=9 isn't seen in these examples). These pixels are not part of the main shapes and do not appear in the final output grid; they seem to be noise or potentially control signals. Gray pixels appear frequently but are removed. Orange pixels appear only in `train_3`.
5.  **Transformation Goal:** The task seems to be about identifying specific shapes (those fitting a 6x6 bounding box) in the input, extracting them, cleaning them (removing noise pixels within their bounds), and arranging them vertically in the output.
6.  **Extraction:** Each relevant shape from the input corresponds to one 6x6 grid in the output. The extraction seems based on the shape's 6x6 bounding box.
7.  **Cleaning:** Any 'noise' pixels (Gray=5, Orange=7) found within the extracted 6x6 bounding box of a shape are replaced with the input grid's background color.
8.  **Ordering:** The extracted and cleaned 6x6 shapes are stacked vertically. The order appears to be determined by the top-to-bottom, then left-to-right position of the shape's bounding box in the input grid. However, in `train_3`, where Orange(7) pixels are present in the input, this order is reversed.

**YAML Facts Block**


```yaml
task_description: Extract specific 6x6 shapes from an input grid, clean them, and stack them vertically in a specific order.

elements:
  - element: grid
    role: input/output container
    properties:
      - background_color: The most frequent color in the input grid.
      - dimensions: variable (up to 30x30 for input). Output height is N * 6, width is 6, where N is the number of extracted shapes.

  - element: shape
    role: primary object of interest
    properties:
      - colors: Any color except background and noise colors (e.g., Yellow, Azure, Green, Blue, Red).
      - structure: Contiguous block of non-background, non-noise pixels.
      - size_constraint: Must have a bounding box of exactly 6x6 pixels.
      - location: Defined by its bounding box coordinates in the input grid.

  - element: noise_pixel
    role: irrelevant data or control signal
    properties:
      - colors: [Gray (5), Orange (7), Maroon (9)]
      - location: Scattered within the input grid, potentially inside shape bounding boxes.
      - significance:
          - Gray (5), Maroon (9): Ignored during shape identification, removed if within an extracted shape's box.
          - Orange (7): Presence in the input grid signals a reversal of the output stacking order. Also removed if within an extracted shape's box.

actions:
  - action: identify_background_color
    description: Find the most frequent pixel color in the input grid.
  - action: identify_shapes
    description: Find all maximal contiguous blocks of pixels that are not background or noise colors.
  - action: filter_shapes
    description: Select only those identified shapes whose bounding box dimensions are exactly 6x6.
  - action: determine_order
    description: >
      Calculate the top-left corner (min_row, min_col) for the bounding box of each filtered shape.
      Sort the shapes based on these coordinates (primary key: min_row, secondary key: min_col).
      Check if any Orange (7) pixels exist anywhere in the input grid. If yes, reverse the sorted order.
  - action: extract_and_clean
    description: >
      For each shape in the determined order:
      1. Extract the 6x6 pixel region corresponding to its bounding box from the input grid.
      2. Replace any noise pixels (Gray=5, Orange=7, Maroon=9) within this 6x6 region with the identified background color.
  - action: stack_output
    description: Vertically concatenate the cleaned 6x6 grids in the determined order to create the final output grid.

relationships:
  - relation: shape_extraction
    subject: shape
    object: output_grid
    description: Each filtered 6x6 shape from the input corresponds to a 6x6 subgrid in the output.
  - relation: noise_removal
    subject: noise_pixel
    object: shape (within its 6x6 box)
    description: Noise pixels within a shape's extracted 6x6 box are replaced by the background color.
  - relation: order_determination
    subject: shape location
    object: stacking order
    description: The relative position (top-left corner) of shapes determines their stacking order.
  - relation: order_reversal
    subject: Orange (7) pixel presence
    object: stacking order
    description: The presence of Orange (7) in the input grid reverses the default stacking order.
```


**Natural Language Program**

1.  Determine the background color by finding the most frequent color in the input grid.
2.  Identify potential "noise" colors: Gray (5), Orange (7), and Maroon (9).
3.  Find all distinct contiguous objects in the input grid composed of colors other than the background color and the noise colors.
4.  For each object found, determine its bounding box. Keep only those objects whose bounding box is exactly 6x6 pixels in size.
5.  Create a list of these valid 6x6 shapes. If no such shapes are found, the output is likely empty or unchanged (clarification needed, but examples suggest shapes are always found).
6.  Determine the initial ordering of these shapes by sorting them based on the row index of their bounding box's top edge, using the column index of the left edge as a tiebreaker (top-to-bottom, then left-to-right).
7.  Scan the entire input grid to check if any Orange (7) pixels are present.
8.  If Orange (7) pixels are present in the input grid, reverse the order of the shapes determined in step 6. Otherwise, maintain the order from step 6.
9.  Initialize an empty list to store the final 6x6 output grids.
10. Iterate through the shapes in the (potentially reversed) order:
    a.  Extract the 6x6 grid region corresponding to the shape's bounding box from the original input grid.
    b.  Create a cleaned version of this 6x6 grid: Iterate through its pixels, and if a pixel's color is one of the noise colors (5, 7, or 9), change its color to the background color identified in step 1.
    c.  Add the cleaned 6x6 grid to the list of output grids.
11. Vertically stack all the cleaned 6x6 grids in the list generated in step 10 to form the final output grid.
```python
import numpy as np
from collections import Counter

"""
Identifies specific 6x6 shapes within an input grid based on non-background, non-noise colors.
Filters these shapes to keep only those with exact 6x6 bounding boxes.
Determines the stacking order based on the top-left corner of the shapes (top-to-bottom, left-to-right), 
reversing this order if any Orange (7) pixels are present in the original input.
Extracts each selected shape's 6x6 area from the input.
Cleans the extracted 6x6 grids by replacing noise pixels (Gray=5, Orange=7, Maroon=9) with the background color.
Vertically stacks the cleaned 6x6 grids in the determined order to produce the final output grid.
"""

def find_objects(grid, background_color, noise_colors):
    """
    Finds contiguous objects of non-background, non-noise colors in the grid.

    Args:
        grid (np.array): The input grid.
        background_color (int): The background color.
        noise_colors (set): A set of colors to ignore as part of objects.

    Returns:
        list: A list of tuples, where each tuple contains:
              - min_row (int): Minimum row index of the object's bounding box.
              - max_row (int): Maximum row index of the object's bounding box.
              - min_col (int): Minimum column index of the object's bounding box.
              - max_col (int): Maximum column index of the object's bounding box.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start BFS if we find an unvisited pixel that is not background or noise
            if not visited[r, c] and color != background_color and color not in noise_colors:
                obj_coords = []
                q = [(r, c)]
                visited[r, c] = True
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.pop(0)
                    obj_coords.append((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:
                            neighbor_color = grid[nr, nc]
                            # Only add neighbors that belong to the same object type (not background or noise)
                            if neighbor_color != background_color and neighbor_color not in noise_colors:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                # Store the bounding box of the found object
                objects.append((min_r, max_r, min_c, max_c))
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid by extracting, cleaning, and stacking 6x6 shapes.

    Args:
        input_grid (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the transformed output grid.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape

    # 1. Determine the background color (most frequent color)
    colors, counts = np.unique(grid, return_counts=True)
    background_color = colors[np.argmax(counts)]

    # 2. Define noise colors
    noise_colors = {5, 7, 9}

    # 3. Find all distinct contiguous objects (non-background, non-noise)
    # 4. Filter objects to keep only those with a 6x6 bounding box
    all_objects = find_objects(grid, background_color, noise_colors)
    
    valid_shapes = []
    for min_r, max_r, min_c, max_c in all_objects:
        height = max_r - min_r + 1
        width = max_c - min_c + 1
        if height == 6 and width == 6:
            valid_shapes.append({'min_row': min_r, 'min_col': min_c})

    # 5. Handle case where no valid shapes are found
    if not valid_shapes:
        # Output should be empty or handled based on specific task rules if this occurs.
        # Based on examples, we expect shapes. Returning empty list for now.
        # A 0x6 grid might be more appropriate if numpy output is needed internally.
        return [] 

    # 6. Determine initial ordering (top-to-bottom, left-to-right)
    valid_shapes.sort(key=lambda s: (s['min_row'], s['min_col']))

    # 7. Check for Orange (7) pixels in the input grid
    has_orange = np.any(grid == 7)

    # 8. Reverse order if Orange (7) is present
    if has_orange:
        valid_shapes.reverse()

    # 9. Initialize list for cleaned 6x6 output grids
    output_grids = []

    # 10. Iterate through shapes, extract, clean, and collect
    for shape in valid_shapes:
        min_r, min_c = shape['min_row'], shape['min_col']
        
        # a. Extract the 6x6 region
        extracted_grid = grid[min_r : min_r + 6, min_c : min_c + 6].copy()
        
        # b. Clean the extracted grid (replace noise with background)
        for r in range(6):
            for c in range(6):
                if extracted_grid[r, c] in noise_colors:
                    extracted_grid[r, c] = background_color
                    
        # c. Add cleaned grid to the list
        output_grids.append(extracted_grid)

    # 11. Vertically stack the cleaned grids
    if not output_grids: # Double check after cleaning/extraction (shouldn't happen if valid_shapes wasn't empty)
         return []
    final_output_grid_np = np.vstack(output_grids)

    # Convert final numpy array back to list of lists
    return final_output_grid_np.tolist()
```
```python
import numpy as np
from collections import Counter

"""
Identify distinct, same-colored contiguous objects (non-background, non-noise) 
whose minimal bounding box fits within 6x6. Use the top-left corner of each 
such object's bounding box to define the top-left corner of a 6x6 window to 
extract from the input. Collect all unique 6x6 window definitions. Order 
them top-to-bottom, left-to-right based on their top-left corner. If the 
input grid contains any Orange (7) pixels, reverse this order. Extract each 
6x6 window, clean it by replacing noise pixels (Gray=5, Orange=7, Maroon=9) 
with the background color, and vertically stack the cleaned windows to create 
the output.
"""

def find_colored_objects(grid, background_color, noise_colors):
    """
    Finds contiguous objects of the *same* non-background, non-noise color.

    Args:
        grid (np.array): The input grid.
        background_color (int): The background color.
        noise_colors (set): A set of colors to ignore as part of objects.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains:
              - 'color': The color of the object.
              - 'pixels': A set of (row, col) tuples for pixels in the object.
              - 'bbox': A tuple (min_r, max_r, min_c, max_c) for the bounding box.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start BFS if we find an unvisited pixel that is not background or noise
            if not visited[r, c] and color != background_color and color not in noise_colors:
                obj_pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                current_color = color # Color of the object we are tracing
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.pop(0)
                    obj_pixels.add((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if visited
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:
                            neighbor_color = grid[nr, nc]
                            # Only add neighbors of the SAME color as the starting pixel
                            if neighbor_color == current_color:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                # Store the found object details
                objects.append({
                    'color': current_color,
                    'pixels': obj_pixels,
                    'bbox': (min_r, max_r, min_c, max_c)
                })
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid based on the described logic.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return []

    # 1. Identify the background color
    colors, counts = np.unique(grid, return_counts=True)
    if len(colors) == 0: # Handle empty input grid case
      return []
    background_color = colors[np.argmax(counts)]

    # 2. Define noise colors
    noise_colors = {5, 7, 9}

    # 3. Find all contiguous objects by color
    all_objects = find_colored_objects(grid, background_color, noise_colors)

    # 4. Filter objects by bounding box size (<= 6x6)
    filtered_objects = []
    for obj in all_objects:
        min_r, max_r, min_c, max_c = obj['bbox']
        height = max_r - min_r + 1
        width = max_c - min_c + 1
        if height <= 6 and width <= 6:
            filtered_objects.append(obj)

    # 5. Get unique top-left corners (min_r, min_c) from filtered objects
    unique_corners = set()
    for obj in filtered_objects:
        min_r, _, min_c, _ = obj['bbox']
        # Ensure the 6x6 window starting at this corner fits within the grid
        if min_r + 6 <= rows and min_c + 6 <= cols:
             unique_corners.add((min_r, min_c))
        #else:
            # Optional: log or handle cases where object near edge implies window out of bounds
            # Based on examples, seems objects are placed such that 6x6 fits
            # pass 

    # 6. Handle case where no valid corners are found
    if not unique_corners:
        return [] 

    # 7. Sort unique corners (row, then column)
    sorted_corners = sorted(list(unique_corners), key=lambda x: (x[0], x[1]))

    # 8. Check for Orange (7) in the original input grid
    has_orange = np.any(grid == 7)

    # 9. Reverse order if Orange (7) is present
    if has_orange:
        sorted_corners.reverse()

    # 10. Initialize list for cleaned 6x6 output grids
    output_subgrids = []

    # 11. Iterate through corners, extract, clean, and collect
    for r_corner, c_corner in sorted_corners:
        # a. Extract the 6x6 subgrid (already bounds-checked in step 5)
        subgrid = grid[r_corner : r_corner + 6, c_corner : c_corner + 6].copy()
        
        # b. Clean the subgrid (replace noise with background)
        for r_sub in range(6):
            for c_sub in range(6):
                if subgrid[r_sub, c_sub] in noise_colors:
                    subgrid[r_sub, c_sub] = background_color
                    
        # c. Add cleaned subgrid to the list
        output_subgrids.append(subgrid)

    # 12. Vertically stack the cleaned grids
    if not output_subgrids:
         return [] # Should not happen if unique_corners was not empty, but good practice
         
    final_output_grid_np = np.vstack(output_subgrids)

    # Convert final numpy array back to list of lists
    return final_output_grid_np.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Identify distinct, same-colored contiguous objects (non-background, non-noise) 
whose minimal bounding box fits within 6x6. Use the top-left corner of each 
such object's bounding box to define the top-left corner of a 6x6 window to 
extract from the input. Collect all unique 6x6 window definitions. Order 
them top-to-bottom, left-to-right based on their top-left corner. If the 
input grid contains any Orange (7) pixels, reverse this order. Extract each 
6x6 window, clean it by replacing noise pixels (Gray=5, Orange=7, Maroon=9) 
with the background color, and vertically stack the cleaned windows to create 
the output.
"""

def find_colored_objects(grid, background_color, noise_colors):
    """
    Finds contiguous objects of the *same* non-background, non-noise color.

    Args:
        grid (np.array): The input grid.
        background_color (int): The background color.
        noise_colors (set): A set of colors to ignore as part of objects.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains:
              - 'color': The color of the object.
              - 'pixels': A set of (row, col) tuples for pixels in the object.
              - 'bbox': A tuple (min_r, max_r, min_c, max_c) for the bounding box.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start BFS if we find an unvisited pixel that is not background or noise
            if not visited[r, c] and color != background_color and color not in noise_colors:
                obj_pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                current_color = color # Color of the object we are tracing
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.pop(0)
                    obj_pixels.add((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if visited
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:
                            neighbor_color = grid[nr, nc]
                            # Only add neighbors of the SAME color as the starting pixel
                            if neighbor_color == current_color:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                # Store the found object details
                objects.append({
                    'color': current_color,
                    'pixels': obj_pixels,
                    'bbox': (min_r, max_r, min_c, max_c)
                })
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid based on the described logic.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return []

    # 1. Identify the background color
    colors, counts = np.unique(grid, return_counts=True)
    if len(colors) == 0: # Handle empty input grid case
      return []
    background_color = colors[np.argmax(counts)]

    # 2. Define noise colors
    noise_colors = {5, 7, 9}

    # 3. Find all contiguous objects by color
    all_objects = find_colored_objects(grid, background_color, noise_colors)

    # 4. Filter objects by bounding box size (<= 6x6)
    filtered_objects = []
    for obj in all_objects:
        min_r, max_r, min_c, max_c = obj['bbox']
        height = max_r - min_r + 1
        width = max_c - min_c + 1
        if height <= 6 and width <= 6:
            filtered_objects.append(obj)

    # 5. Get unique top-left corners (min_r, min_c) from filtered objects
    unique_corners = set()
    for obj in filtered_objects:
        min_r, _, min_c, _ = obj['bbox']
        # Ensure the 6x6 window starting at this corner fits within the grid
        if min_r + 6 <= rows and min_c + 6 <= cols:
             unique_corners.add((min_r, min_c))
        #else:
            # Optional: log or handle cases where object near edge implies window out of bounds
            # Based on examples, seems objects are placed such that 6x6 fits
            # pass 

    # 6. Handle case where no valid corners are found
    if not unique_corners:
        return [] 

    # 7. Sort unique corners (row, then column)
    sorted_corners = sorted(list(unique_corners), key=lambda x: (x[0], x[1]))

    # 8. Check for Orange (7) in the original input grid
    has_orange = np.any(grid == 7)

    # 9. Reverse order if Orange (7) is present
    if has_orange:
        sorted_corners.reverse()

    # 10. Initialize list for cleaned 6x6 output grids
    output_subgrids = []

    # 11. Iterate through corners, extract, clean, and collect
    for r_corner, c_corner in sorted_corners:
        # a. Extract the 6x6 subgrid (already bounds-checked in step 5)
        subgrid = grid[r_corner : r_corner + 6, c_corner : c_corner + 6].copy()
        
        # b. Clean the subgrid (replace noise with background)
        for r_sub in range(6):
            for c_sub in range(6):
                if subgrid[r_sub, c_sub] in noise_colors:
                    subgrid[r_sub, c_sub] = background_color
                    
        # c. Add cleaned subgrid to the list
        output_subgrids.append(subgrid)

    # 12. Vertically stack the cleaned grids
    if not output_subgrids:
         return [] # Should not happen if unique_corners was not empty, but good practice
         
    final_output_grid_np = np.vstack(output_subgrids)

    # Convert final numpy array back to list of lists
    return final_output_grid_np.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```
Expected Output:
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```
Transformed Output:
```
4 4 2 2 2 8
2 2 4 2 8 2
2 2 2 4 2 2
2 2 2 4 2 2
2 2 4 2 8 2
4 4 2 2 2 8
8 8 2 2 2 2
2 2 8 2 3 3
2 2 2 8 2 2
2 2 3 8 2 2
2 2 8 2 2 2
8 8 2 3 2 2
4 2 2 4 2 8
2 2 2 2 4 2
2 2 2 2 4 2
4 2 2 4 2 8
2 4 4 2 2 2
2 2 2 2 2 2
4 2 8 2 2 8
2 4 2 2 2 2
2 4 2 2 2 3
4 2 8 2 2 8
2 2 2 8 8 2
2 2 2 2 2 2
8 2 2 8 2 3
2 2 2 2 8 2
2 2 2 3 8 2
8 2 2 8 2 2
2 8 8 2 3 2
2 2 2 2 2 3
8 2 3 3 2 2
2 8 2 2 3 2
3 8 2 2 2 3
8 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
3 3 2 2 2 2
2 2 3 2 2 2
2 2 2 3 2 2
2 2 2 3 2 2
2 2 3 2 2 2
3 3 2 2 2 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 2 2 2 2
2 2 2 2 2 2
4 2 2 2 2 8
4 2 2 2 3 8
2 8 2 2 8 2
2 2 8 8 2 3
2 2 2 2 2 2
2 2 2 2 2 2
8 2 2 3 2 2
8 2 2 2 3 2
2 2 2 2 3 2
3 2 2 3 2 2
2 3 3 2 2 2
2 2 2 2 2 2
3 2 2 2 2 2
2 3 2 2 2 2
2 3 2 2 2 2
3 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
3 8 2 2 2 3
8 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
2 2 2 2 2 2
2 2 2 2 2 2
4 2 2 4 2 8
2 4 4 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
4 2 8 2 2 8
2 2 2 8 8 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
8 2 2 8 2 2
2 8 8 2 3 2
2 2 2 2 2 3
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
8 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
4 4 2 2 2 8
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
8 8 2 3 2 2
2 2 2 2 3 3
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
3 2 2 3 2 2
2 3 3 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
3 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
3 3 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
2 2 2 2 2 2
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 2:
Input:
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```
Expected Output:
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```
Transformed Output:
```
4 4 3 3 3 3
3 8 4 3 3 3
8 3 3 4 3 3
1 3 3 4 8 3
3 1 4 3 8 3
4 4 1 8 3 3
4 3 8 4 3 3
3 8 3 3 4 3
8 1 3 3 4 8
4 3 1 4 3 8
3 4 4 1 8 3
3 3 8 8 3 3
8 4 3 3 3 3
3 3 4 3 3 3
3 3 4 8 3 3
1 4 3 8 3 3
4 1 8 3 3 3
8 8 3 3 3 3
4 3 8 3 3 4
4 8 1 3 3 4
1 4 3 1 4 3
3 3 4 4 1 8
3 3 3 8 8 3
1 3 3 1 3 3
8 3 3 4 3 3
1 3 3 4 8 3
3 1 4 3 8 3
4 4 1 8 3 3
3 8 8 3 3 3
3 1 3 3 3 3
8 1 3 3 4 8
4 3 1 4 3 8
3 4 4 1 8 3
3 3 8 8 3 3
3 3 1 3 3 3
1 1 3 3 3 3
1 3 3 4 8 3
3 1 4 3 8 3
4 4 1 8 3 3
3 8 8 3 3 3
3 1 3 3 3 3
1 3 3 3 3 3
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 3:
Input:
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```
Expected Output:
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```
Transformed Output:
```
8 4 4 4 4 8
8 4 4 4 4 3
4 8 4 4 3 4
4 4 8 3 4 4
4 4 4 3 4 4
4 4 4 4 3 4
2 8 4 4 4 4
4 8 4 4 4 4
4 4 8 4 4 3
4 4 4 8 3 4
4 4 4 4 3 4
4 4 4 4 4 3
8 4 4 4 4 4
4 8 4 4 4 4
4 3 3 4 4 4
3 4 4 3 4 4
4 4 4 4 3 4
4 4 4 4 3 4
8 4 4 8 4 4
4 4 4 4 8 4
4 4 4 4 3 3
8 4 4 3 4 4
4 8 3 4 4 4
4 4 3 4 4 4
2 4 4 8 4 4
4 2 8 4 4 4
4 4 8 4 4 4
4 4 4 8 4 4
4 4 4 4 8 3
4 4 4 4 4 3
8 8 4 4 4 4
4 4 8 4 4 4
4 4 4 8 4 4
4 4 4 3 3 4
4 4 3 4 4 3
8 3 4 4 4 4
2 4 4 4 4 4
8 8 4 4 4 4
4 4 8 4 4 4
4 4 4 8 4 4
4 4 4 3 3 4
4 4 3 4 4 3
2 4 4 4 4 2
2 4 4 4 4 8
4 2 4 4 8 4
4 4 2 8 4 4
4 4 4 8 4 4
4 4 4 4 8 4
2 4 4 4 4 4
4 2 4 4 4 4
4 8 8 4 4 4
8 4 4 8 4 4
4 4 4 4 8 4
4 4 4 4 3 3
2 4 4 2 4 4
4 4 4 4 2 4
4 4 4 4 8 8
2 4 4 8 4 4
4 2 8 4 4 4
4 4 8 4 4 4
2 2 4 4 4 4
4 4 2 4 4 4
4 4 4 2 4 4
4 4 4 8 8 4
4 4 8 4 4 8
2 8 4 4 4 4
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 4:
Input:
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```
Expected Output:
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```
Transformed Output:
```
4 4 8 3 3 8
8 8 4 8 8 3
8 3 8 4 8 8
8 3 8 4 8 8
8 8 4 8 8 3
4 4 8 3 3 8
4 8 8 4 8 8
2 8 3 8 4 8
8 8 3 8 4 8
4 8 8 4 8 8
8 4 4 8 3 3
8 8 8 8 8 8
4 2 8 3 8 4
4 8 8 3 8 4
8 4 8 8 4 8
8 8 4 4 8 3
8 8 8 8 8 8
8 8 8 8 8 8
2 8 3 8 4 8
8 8 3 8 4 8
4 8 8 4 8 8
8 4 4 8 3 3
8 8 8 8 8 8
8 8 8 8 8 2
3 8 4 8 8 3
3 8 4 8 8 3
8 4 8 8 3 8
4 8 3 3 8 8
8 8 8 8 8 8
8 8 8 2 8 8
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: False
Color Count Correct: False
Score: None
**General Assessment and Strategy**

The previous attempt failed significantly, producing outputs that were drastically different in size and content from the expected outputs. The core issue seems to stem from incorrectly identifying the relevant 6x6 regions to extract. The code identified too many potential starting points, likely triggering off individual pixels or small fragments rather than coherent shapes fitting within a 6x6 bounding box.

The strategy needs to be revised to more accurately identify the specific 6x6 patterns/shapes present in the input that correspond to the output subgrids. The key observation from the expected outputs is that they *are* 6x6 grids, each containing a distinct shape derived from the input. The logic should focus on finding contiguous objects in the input whose bounding box is *precisely* 6x6. These bounding boxes directly define the regions to extract, clean, and stack.

**Revised Strategy:**

1.  **Identify Background:** Determine the most frequent color in the input grid.
2.  **Identify Noise:** Define noise colors (5-Gray, 7-Orange, 9-Maroon).
3.  **Find Candidate Objects:** Locate all maximal contiguous regions (objects) composed of any color(s) *except* the background color and the noise colors. Use a method like Breadth-First Search (BFS) or Depth-First Search (DFS) starting from any non-background, non-noise pixel, ensuring visited pixels are marked to avoid redundant searches. Crucially, the search should expand to adjacent pixels regardless of their color, as long as they are not background or noise.
4.  **Filter by Bounding Box:** For each object found, calculate its minimal bounding box (min_row, max_row, min_col, max_col). Keep only those objects where `(max_row - min_row + 1) == 6` AND `(max_col - min_col + 1) == 6`.
5.  **Extract Coordinates:** Collect the top-left corner coordinates (`min_row`, `min_col`) of the bounding boxes for all filtered 6x6 objects.
6.  **Order Coordinates:** Sort these coordinates primarily by row (`min_row`) and secondarily by column (`min_col`).
7.  **Check for Reversal Signal:** Scan the *entire* original input grid for the presence of any Orange (7) pixels.
8.  **Apply Reversal:** If Orange (7) pixels were found, reverse the sorted list of coordinates.
9.  **Extract, Clean, Stack:** Iterate through the final ordered list of coordinates. For each (`r`, `c`):
    *   Extract the 6x6 subgrid from the input starting at `(r, c)`.
    *   Create a cleaned copy of this subgrid, replacing any noise pixels (5, 7, 9) within it with the background color.
    *   Append the cleaned subgrid to a list.
10. **Combine:** Vertically stack the cleaned subgrids in the list to form the final output grid.

**Metrics Gathering**


*code_execution:*
```python
import numpy as np
from collections import Counter

def analyze_example(input_data, output_data):
    input_grid = np.array(input_data)
    output_grid = np.array(output_data)
    
    # Input analysis
    i_rows, i_cols = input_grid.shape
    i_colors, i_counts = np.unique(input_grid, return_counts=True)
    i_bg_color = i_colors[np.argmax(i_counts)]
    i_non_bg_noise_pixels = np.where((input_grid != i_bg_color) & (input_grid != 5) & (input_grid != 7) & (input_grid != 9))
    i_noise_pixels = np.where((input_grid == 5) | (input_grid == 7) | (input_grid == 9))
    has_orange = np.any(input_grid == 7)

    # Output analysis
    o_rows, o_cols = output_grid.shape if output_grid.size > 0 else (0, 0)
    num_subgrids = o_rows // 6 if o_cols == 6 and o_rows > 0 else 0

    return {
        "input_dims": (i_rows, i_cols),
        "output_dims": (o_rows, o_cols),
        "input_bg_color": int(i_bg_color),
        "input_unique_colors": sorted(i_colors.tolist()),
        "input_non_bg_noise_coords": list(zip(i_non_bg_noise_pixels[0].tolist(), i_non_bg_noise_pixels[1].tolist())),
        "input_noise_coords": list(zip(i_noise_pixels[0].tolist(), i_noise_pixels[1].tolist())),
        "has_orange_signal": has_orange,
        "expected_num_subgrids": num_subgrids,
        "expected_output_width": o_cols
    }

# Example Data (as provided in the problem description)
train_1_in = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 3, 3, 2, 2, 2, 2, 2, 2], [2, 4, 2, 2, 2, 2, 4, 5, 2, 2, 2, 8, 2, 2, 3, 2, 2, 2, 2, 2], [2, 4, 2, 9, 2, 2, 4, 2, 2, 2, 3, 8, 2, 9, 2, 3, 2, 2, 2, 2], [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 2, 2, 2, 3, 2, 2, 2, 2], [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]
train_1_out = [[2, 2, 4, 4, 2, 2], [2, 4, 2, 2, 4, 2], [4, 2, 2, 2, 2, 4], [4, 2, 2, 2, 2, 4], [2, 4, 2, 2, 4, 2], [2, 2, 4, 4, 2, 2], [2, 2, 8, 8, 2, 2], [2, 8, 2, 2, 8, 2], [8, 2, 2, 2, 2, 8], [8, 2, 2, 2, 2, 8], [2, 8, 2, 2, 8, 2], [2, 2, 8, 8, 2, 2], [2, 2, 3, 3, 2, 2], [2, 3, 2, 2, 3, 2], [3, 2, 2, 2, 2, 3], [3, 2, 2, 2, 2, 3], [2, 3, 2, 2, 3, 2], [2, 2, 3, 3, 2, 2]]
train_2_in = [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [5, 3, 3, 4, 4, 3, 3, 3, 3, 3], [3, 3, 4, 3, 8, 4, 3, 3, 3, 3], [3, 4, 3, 8, 3, 3, 4, 3, 3, 3], [3, 4, 8, 1, 3, 3, 4, 8, 3, 3], [3, 1, 4, 3, 1, 4, 3, 8, 3, 3], [1, 3, 3, 4, 4, 1, 8, 3, 3, 3], [1, 3, 5, 3, 8, 8, 3, 3, 3, 3], [3, 1, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 5, 3, 3, 3]]
train_2_out = [[3, 3, 4, 4, 3, 3], [3, 4, 3, 3, 4, 3], [4, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 4], [3, 4, 3, 3, 4, 3], [3, 3, 4, 4, 3, 3], [3, 3, 8, 8, 3, 3], [3, 8, 3, 3, 8, 3], [8, 3, 3, 3, 3, 8], [8, 3, 3, 3, 3, 8], [3, 8, 3, 3, 8, 3], [3, 3, 8, 8, 3, 3], [3, 3, 1, 1, 3, 3], [3, 1, 3, 3, 1, 3], [1, 3, 3, 3, 3, 1], [1, 3, 3, 3, 3, 1], [3, 1, 3, 3, 1, 3], [3, 3, 1, 1, 3, 3]]
train_3_in = [[4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4], [2, 4, 4, 7, 4, 2, 4, 4, 4, 4, 4, 4, 4], [2, 4, 4, 4, 4, 8, 8, 4, 4, 5, 4, 4, 4], [4, 2, 4, 4, 8, 4, 4, 8, 4, 4, 4, 4, 4], [4, 4, 2, 8, 4, 4, 4, 4, 8, 4, 4, 4, 4], [4, 4, 4, 8, 4, 4, 4, 4, 3, 3, 4, 4, 4], [4, 4, 4, 4, 8, 4, 4, 3, 4, 4, 3, 4, 4], [4, 5, 4, 4, 4, 8, 3, 4, 4, 4, 4, 3, 4], [4, 4, 7, 4, 4, 4, 3, 4, 4, 5, 4, 3, 4], [4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 3, 4, 4]]
train_3_out = [[4, 4, 3, 3, 4, 4], [4, 3, 4, 4, 3, 4], [3, 4, 4, 4, 4, 3], [3, 4, 4, 4, 4, 3], [4, 3, 4, 4, 3, 4], [4, 4, 3, 3, 4, 4], [4, 4, 8, 8, 4, 4], [4, 8, 4, 4, 8, 4], [8, 4, 4, 4, 4, 8], [8, 4, 4, 4, 4, 8], [4, 8, 4, 4, 8, 4], [4, 4, 8, 8, 4, 4], [4, 4, 2, 2, 4, 4], [4, 2, 4, 4, 2, 4], [2, 4, 4, 4, 4, 2], [2, 4, 4, 4, 4, 2], [4, 2, 4, 4, 2, 4], [4, 4, 2, 2, 4, 4]]
train_4_in = [[8, 8, 8, 8, 8, 8, 8, 8, 5, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 4, 4, 8, 3, 3, 8, 8], [8, 8, 4, 8, 8, 4, 8, 8, 3, 8], [8, 4, 2, 8, 3, 8, 4, 8, 8, 3], [8, 4, 8, 8, 3, 8, 4, 8, 8, 3], [8, 8, 4, 8, 8, 4, 8, 8, 3, 8], [8, 8, 8, 4, 4, 8, 3, 3, 8, 8], [8, 5, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 2, 8, 8]]
train_4_out = [[8, 8, 4, 4, 8, 8], [8, 4, 8, 8, 4, 8], [4, 8, 8, 8, 8, 4], [4, 8, 8, 8, 8, 4], [8, 4, 8, 8, 4, 8], [8, 8, 4, 4, 8, 8], [8, 8, 3, 3, 8, 8], [8, 3, 8, 8, 3, 8], [3, 8, 8, 8, 8, 3], [3, 8, 8, 8, 8, 3], [8, 3, 8, 8, 3, 8], [8, 8, 3, 3, 8, 8]]

results = {}
results["train_1"] = analyze_example(train_1_in, train_1_out)
results["train_2"] = analyze_example(train_2_in, train_2_out)
results["train_3"] = analyze_example(train_3_in, train_3_out)
results["train_4"] = analyze_example(train_4_in, train_4_out)

import json
print(json.dumps(results, indent=2))
```

*code_execution_result:*
outcome: OUTCOME_FAILED
```
Traceback (most recent call last):
  File "<string>", line 49, in <module>
  File "__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "encoder.py", line 202, in encode
    chunks = list(chunks)
             ^^^^^^^^^^^^
  File "encoder.py", line 432, in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 406, in _iterencode_dict
    yield from chunks
  File "encoder.py", line 439, in _iterencode
    o = _default(o)
        ^^^^^^^^^^^
  File "encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type bool is not JSON serializable

```
**Revised Metrics Gathering (Correcting JSON serialization)**


*code_execution:*
```python
import numpy as np
from collections import Counter
import json

# Custom JSON encoder to handle numpy types
class NpEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        if isinstance(obj, np.floating):
            return float(obj)
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        if isinstance(obj, np.bool_):
            return bool(obj)
        return super(NpEncoder, self).default(obj)

def analyze_example(input_data, output_data):
    input_grid = np.array(input_data)
    output_grid = np.array(output_data)
    
    # Input analysis
    i_rows, i_cols = input_grid.shape
    i_colors, i_counts = np.unique(input_grid, return_counts=True)
    i_bg_color = i_colors[np.argmax(i_counts)] if i_counts.size > 0 else -1 # Handle empty grid case
    i_non_bg_noise_pixels = np.where((input_grid != i_bg_color) & (input_grid != 5) & (input_grid != 7) & (input_grid != 9))
    i_noise_pixels = np.where((input_grid == 5) | (input_grid == 7) | (input_grid == 9))
    has_orange = np.any(input_grid == 7)

    # Output analysis
    o_rows, o_cols = output_grid.shape if output_grid.size > 0 else (0, 0)
    num_subgrids = o_rows // 6 if o_cols == 6 and o_rows > 0 else 0

    return {
        "input_dims": (i_rows, i_cols),
        "output_dims": (o_rows, o_cols),
        "input_bg_color": i_bg_color,
        "input_unique_colors": sorted(i_colors.tolist()),
        "input_non_bg_noise_coords_count": len(i_non_bg_noise_pixels[0]),
        "input_noise_coords_count": len(i_noise_pixels[0]),
        "has_orange_signal": has_orange,
        "expected_num_subgrids": num_subgrids,
        "expected_output_width": o_cols
    }

# Example Data (as provided in the problem description)
train_1_in = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 3, 3, 2, 2, 2, 2, 2, 2], [2, 4, 2, 2, 2, 2, 4, 5, 2, 2, 2, 8, 2, 2, 3, 2, 2, 2, 2, 2], [2, 4, 2, 9, 2, 2, 4, 2, 2, 2, 3, 8, 2, 9, 2, 3, 2, 2, 2, 2], [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 2, 2, 2, 3, 2, 2, 2, 2], [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]
train_1_out = [[2, 2, 4, 4, 2, 2], [2, 4, 2, 2, 4, 2], [4, 2, 2, 2, 2, 4], [4, 2, 2, 2, 2, 4], [2, 4, 2, 2, 4, 2], [2, 2, 4, 4, 2, 2], [2, 2, 8, 8, 2, 2], [2, 8, 2, 2, 8, 2], [8, 2, 2, 2, 2, 8], [8, 2, 2, 2, 2, 8], [2, 8, 2, 2, 8, 2], [2, 2, 8, 8, 2, 2], [2, 2, 3, 3, 2, 2], [2, 3, 2, 2, 3, 2], [3, 2, 2, 2, 2, 3], [3, 2, 2, 2, 2, 3], [2, 3, 2, 2, 3, 2], [2, 2, 3, 3, 2, 2]]
train_2_in = [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [5, 3, 3, 4, 4, 3, 3, 3, 3, 3], [3, 3, 4, 3, 8, 4, 3, 3, 3, 3], [3, 4, 3, 8, 3, 3, 4, 3, 3, 3], [3, 4, 8, 1, 3, 3, 4, 8, 3, 3], [3, 1, 4, 3, 1, 4, 3, 8, 3, 3], [1, 3, 3, 4, 4, 1, 8, 3, 3, 3], [1, 3, 5, 3, 8, 8, 3, 3, 3, 3], [3, 1, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 5, 3, 3, 3]]
train_2_out = [[3, 3, 4, 4, 3, 3], [3, 4, 3, 3, 4, 3], [4, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 4], [3, 4, 3, 3, 4, 3], [3, 3, 4, 4, 3, 3], [3, 3, 8, 8, 3, 3], [3, 8, 3, 3, 8, 3], [8, 3, 3, 3, 3, 8], [8, 3, 3, 3, 3, 8], [3, 8, 3, 3, 8, 3], [3, 3, 8, 8, 3, 3], [3, 3, 1, 1, 3, 3], [3, 1, 3, 3, 1, 3], [1, 3, 3, 3, 3, 1], [1, 3, 3, 3, 3, 1], [3, 1, 3, 3, 1, 3], [3, 3, 1, 1, 3, 3]]
train_3_in = [[4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4], [2, 4, 4, 7, 4, 2, 4, 4, 4, 4, 4, 4, 4], [2, 4, 4, 4, 4, 8, 8, 4, 4, 5, 4, 4, 4], [4, 2, 4, 4, 8, 4, 4, 8, 4, 4, 4, 4, 4], [4, 4, 2, 8, 4, 4, 4, 4, 8, 4, 4, 4, 4], [4, 4, 4, 8, 4, 4, 4, 4, 3, 3, 4, 4, 4], [4, 4, 4, 4, 8, 4, 4, 3, 4, 4, 3, 4, 4], [4, 5, 4, 4, 4, 8, 3, 4, 4, 4, 4, 3, 4], [4, 4, 7, 4, 4, 4, 3, 4, 4, 5, 4, 3, 4], [4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 3, 4, 4]]
train_3_out = [[4, 4, 3, 3, 4, 4], [4, 3, 4, 4, 3, 4], [3, 4, 4, 4, 4, 3], [3, 4, 4, 4, 4, 3], [4, 3, 4, 4, 3, 4], [4, 4, 3, 3, 4, 4], [4, 4, 8, 8, 4, 4], [4, 8, 4, 4, 8, 4], [8, 4, 4, 4, 4, 8], [8, 4, 4, 4, 4, 8], [4, 8, 4, 4, 8, 4], [4, 4, 8, 8, 4, 4], [4, 4, 2, 2, 4, 4], [4, 2, 4, 4, 2, 4], [2, 4, 4, 4, 4, 2], [2, 4, 4, 4, 4, 2], [4, 2, 4, 4, 2, 4], [4, 4, 2, 2, 4, 4]]
train_4_in = [[8, 8, 8, 8, 8, 8, 8, 8, 5, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 4, 4, 8, 3, 3, 8, 8], [8, 8, 4, 8, 8, 4, 8, 8, 3, 8], [8, 4, 2, 8, 3, 8, 4, 8, 8, 3], [8, 4, 8, 8, 3, 8, 4, 8, 8, 3], [8, 8, 4, 8, 8, 4, 8, 8, 3, 8], [8, 8, 8, 4, 4, 8, 3, 3, 8, 8], [8, 5, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 2, 8, 8]]
train_4_out = [[8, 8, 4, 4, 8, 8], [8, 4, 8, 8, 4, 8], [4, 8, 8, 8, 8, 4], [4, 8, 8, 8, 8, 4], [8, 4, 8, 8, 4, 8], [8, 8, 4, 4, 8, 8], [8, 8, 3, 3, 8, 8], [8, 3, 8, 8, 3, 8], [3, 8, 8, 8, 8, 3], [3, 8, 8, 8, 8, 3], [8, 3, 8, 8, 3, 8], [8, 8, 3, 3, 8, 8]]

results = {}
results["train_1"] = analyze_example(train_1_in, train_1_out)
results["train_2"] = analyze_example(train_2_in, train_2_out)
results["train_3"] = analyze_example(train_3_in, train_3_out)
results["train_4"] = analyze_example(train_4_in, train_4_out)

print(json.dumps(results, indent=2, cls=NpEncoder))
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{
  "train_1": {
    "input_dims": [
      20,
      20
    ],
    "output_dims": [
      18,
      6
    ],
    "input_bg_color": 2,
    "input_unique_colors": [
      2,
      3,
      4,
      5,
      8,
      9
    ],
    "input_non_bg_noise_coords_count": 32,
    "input_noise_coords_count": 7,
    "has_orange_signal": false,
    "expected_num_subgrids": 3,
    "expected_output_width": 6
  },
  "train_2": {
    "input_dims": [
      10,
      10
    ],
    "output_dims": [
      18,
      6
    ],
    "input_bg_color": 3,
    "input_unique_colors": [
      1,
      3,
      4,
      5,
      8
    ],
    "input_non_bg_noise_coords_count": 30,
    "input_noise_coords_count": 3,
    "has_orange_signal": false,
    "expected_num_subgrids": 3,
    "expected_output_width": 6
  },
  "train_3": {
    "input_dims": [
      13,
      13
    ],
    "output_dims": [
      18,
      6
    ],
    "input_bg_color": 4,
    "input_unique_colors": [
      2,
      3,
      4,
      5,
      7,
      8
    ],
    "input_non_bg_noise_coords_count": 28,
    "input_noise_coords_count": 7,
    "has_orange_signal": true,
    "expected_num_subgrids": 3,
    "expected_output_width": 6
  },
  "train_4": {
    "input_dims": [
      10,
      10
    ],
    "output_dims": [
      12,
      6
    ],
    "input_bg_color": 8,
    "input_unique_colors": [
      2,
      3,
      4,
      5,
      8
    ],
    "input_non_bg_noise_coords_count": 24,
    "input_noise_coords_count": 2,
    "has_orange_signal": false,
    "expected_num_subgrids": 2,
    "expected_output_width": 6
  }
}

```
**YAML Facts Block**


```yaml
task_description: Extract specific 6x6 shapes from an input grid, clean noise pixels from them, and stack them vertically in an order determined by their position and the presence of an orange signal pixel.

elements:
  - element: grid
    role: input/output container
    properties:
      - background_color: The most frequent color in the input grid. (e.g., Red=2, Green=3, Yellow=4, Azure=8)
      - dimensions: Variable for input (up to 30x30). Output width is always 6. Output height is 6 * N, where N is the number of identified shapes.

  - element: target_shape_object
    role: The primary structure to identify and extract.
    properties:
      - composition: A maximal contiguous block of one or more pixels whose colors are NOT the background color and NOT noise colors. Adjacency is defined by side-sharing (not diagonal).
      - size_constraint: The minimal bounding box containing all pixels of the object MUST be exactly 6x6 pixels.
      - location: Defined by the top-left corner (min_row, min_col) of its 6x6 bounding box in the input grid.

  - element: noise_pixel
    role: Irrelevant data or control signal.
    properties:
      - colors: [Gray (5), Orange (7), Maroon (9)]
      - location: Can appear anywhere in the input grid.
      - significance:
          - Gray (5), Maroon (9): Ignored during object identification. If located within an extracted 6x6 shape region, they are replaced by the background color in the output subgrid.
          - Orange (7): Presence *anywhere* in the input grid acts as a control signal, reversing the default stacking order of the output subgrids. Also replaced by the background color if within an extracted 6x6 region.

actions:
  - action: identify_background_color
    description: Find the most frequent pixel color in the input grid.
  - action: identify_noise_colors
    description: Define the set of noise colors {5, 7, 9}.
  - action: find_potential_objects
    description: >
      Perform a search (e.g., BFS) starting from every unvisited pixel that is not background and not noise.
      Expand the search to adjacent (up, down, left, right) pixels that are also not background and not noise, marking them as visited.
      Group all pixels visited during a single search into one potential object.
  - action: filter_objects_by_bbox
    description: >
      For each potential object found:
      1. Calculate its minimal bounding box (min_row, max_row, min_col, max_col).
      2. Check if the height (max_row - min_row + 1) is exactly 6.
      3. Check if the width (max_col - min_col + 1) is exactly 6.
      4. If both conditions are true, record the top-left corner (min_row, min_col) of this bounding box.
  - action: determine_order
    description: >
      Collect all recorded top-left corners from the filtered objects.
      Sort these corners first by row index, then by column index (top-to-bottom, left-to-right).
      Scan the original input grid for any Orange (7) pixel.
      If an Orange (7) pixel is found, reverse the sorted order of corners.
  - action: extract_clean_stack
    description: >
      Initialize an empty list for output subgrids.
      For each corner (r, c) in the final determined order:
      1. Extract the 6x6 region from the input grid starting at (r, c).
      2. Create a cleaned copy of this 6x6 region: Replace every pixel with a noise color (5, 7, or 9) with the background color.
      3. Append the cleaned 6x6 subgrid to the list.
      Vertically concatenate (stack) all subgrids in the list to create the final output grid.

relationships:
  - relation: object_defines_extraction_window
    subject: target_shape_object
    object: 6x6_subgrid
    description: The exact 6x6 bounding box of a valid target shape object defines the 6x6 window to be extracted from the input.
  - relation: noise_removal
    subject: noise_pixel
    object: extracted_6x6_subgrid
    description: Noise pixels within an extracted 6x6 subgrid are replaced by the background color.
  - relation: order_determination
    subject: target_shape_object location (top-left corner)
    object: stacking_order
    description: The relative positions (row, then column) of the top-left corners of the valid 6x6 objects determine their default stacking order.
  - relation: order_reversal_signal
    subject: Orange (7) pixel presence (anywhere in input)
    object: stacking_order
    description: The presence of any Orange (7) pixel reverses the default stacking order.
```


**Natural Language Program**

1.  Identify the single background color by finding the most frequent color in the input grid.
2.  Define the set of noise colors as Gray (5), Orange (7), and Maroon (9).
3.  Find all distinct, maximal, contiguous groups of pixels (objects) in the input grid where each pixel in the group is *neither* the background color *nor* a noise color. Use 4-way adjacency (up, down, left, right) to determine contiguity.
4.  For each object found, calculate its minimal bounding box (the smallest rectangle enclosing all its pixels).
5.  Filter these objects, keeping only those whose bounding box dimensions are exactly 6 pixels high and 6 pixels wide.
6.  Create a list containing the top-left corner coordinates (row, column) of the bounding boxes for these filtered 6x6 objects.
7.  Sort this list of coordinates. The primary sort key is the row index (ascending), and the secondary sort key is the column index (ascending). This establishes the default top-to-bottom, left-to-right order.
8.  Check the *entire original input grid* to see if it contains *any* pixel with the Orange (7) color.
9.  If an Orange (7) pixel was found anywhere in the input, reverse the order of the sorted list of coordinates.
10. Initialize an empty list to hold the final 6x6 output subgrids.
11. Iterate through the list of coordinates in their final (potentially reversed) order. For each coordinate pair (R, C):
    a.  Extract the 6x6 block of pixels from the input grid starting at row R, column C.
    b.  Create a cleaned version of this 6x6 block: Iterate through its pixels. If a pixel's color is one of the noise colors (5, 7, or 9), change its color to the background color identified in step 1. Keep all other pixels as they are.
    c.  Add this cleaned 6x6 block to the list of output subgrids.
12. Vertically stack the cleaned 6x6 blocks in the order they were added to the list. This final stacked grid is the output. If no 6x6 objects were found in step 5, the output is an empty grid.
