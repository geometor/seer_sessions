{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies specific 6x6 shapes within an input grid based on non-background, non-noise colors.\nFilters these shapes to keep only those with exact 6x6 bounding boxes.\nDetermines the stacking order based on the top-left corner of the shapes (top-to-bottom, left-to-right), \nreversing this order if any Orange (7) pixels are present in the original input.\nExtracts each selected shape's 6x6 area from the input.\nCleans the extracted 6x6 grids by replacing noise pixels (Gray=5, Orange=7, Maroon=9) with the background color.\nVertically stacks the cleaned 6x6 grids in the determined order to produce the final output grid.\n\"\"\"\n\ndef find_objects(grid, background_color, noise_colors):\n    \"\"\"\n    Finds contiguous objects of non-background, non-noise colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n        noise_colors (set): A set of colors to ignore as part of objects.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              - min_row (int): Minimum row index of the object's bounding box.\n              - max_row (int): Maximum row index of the object's bounding box.\n              - min_col (int): Minimum column index of the object's bounding box.\n              - max_col (int): Maximum column index of the object's bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited pixel that is not background or noise\n            if not visited[r, c] and color != background_color and color not in noise_colors:\n                obj_coords = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:\n                            neighbor_color = grid[nr, nc]\n                            # Only add neighbors that belong to the same object type (not background or noise)\n                            if neighbor_color != background_color and neighbor_color not in noise_colors:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store the bounding box of the found object\n                objects.append((min_r, max_r, min_c, max_c))\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting, cleaning, and stacking 6x6 shapes.\n\n    Args:\n        input_grid (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Determine the background color (most frequent color)\n    colors, counts = np.unique(grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Define noise colors\n    noise_colors = {5, 7, 9}\n\n    # 3. Find all distinct contiguous objects (non-background, non-noise)\n    # 4. Filter objects to keep only those with a 6x6 bounding box\n    all_objects = find_objects(grid, background_color, noise_colors)\n    \n    valid_shapes = []\n    for min_r, max_r, min_c, max_c in all_objects:\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        if height == 6 and width == 6:\n            valid_shapes.append({'min_row': min_r, 'min_col': min_c})\n\n    # 5. Handle case where no valid shapes are found\n    if not valid_shapes:\n        # Output should be empty or handled based on specific task rules if this occurs.\n        # Based on examples, we expect shapes. Returning empty list for now.\n        # A 0x6 grid might be more appropriate if numpy output is needed internally.\n        return [] \n\n    # 6. Determine initial ordering (top-to-bottom, left-to-right)\n    valid_shapes.sort(key=lambda s: (s['min_row'], s['min_col']))\n\n    # 7. Check for Orange (7) pixels in the input grid\n    has_orange = np.any(grid == 7)\n\n    # 8. Reverse order if Orange (7) is present\n    if has_orange:\n        valid_shapes.reverse()\n\n    # 9. Initialize list for cleaned 6x6 output grids\n    output_grids = []\n\n    # 10. Iterate through shapes, extract, clean, and collect\n    for shape in valid_shapes:\n        min_r, min_c = shape['min_row'], shape['min_col']\n        \n        # a. Extract the 6x6 region\n        extracted_grid = grid[min_r : min_r + 6, min_c : min_c + 6].copy()\n        \n        # b. Clean the extracted grid (replace noise with background)\n        for r in range(6):\n            for c in range(6):\n                if extracted_grid[r, c] in noise_colors:\n                    extracted_grid[r, c] = background_color\n                    \n        # c. Add cleaned grid to the list\n        output_grids.append(extracted_grid)\n\n    # 11. Vertically stack the cleaned grids\n    if not output_grids: # Double check after cleaning/extraction (shouldn't happen if valid_shapes wasn't empty)\n         return []\n    final_output_grid_np = np.vstack(output_grids)\n\n    # Convert final numpy array back to list of lists\n    return final_output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5159,
    "candidates_token_count": 1615,
    "total_token_count": 6774,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.914336,
  "retries": 1
}