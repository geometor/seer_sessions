
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```


**output:**
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```


## train_3

**input:**
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```


**output:**
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```


**output:**
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```

**Perception of the Task Elements**

1.  **Input/Output Structure:** The input is a larger grid, and the output is a taller, narrower grid composed of vertically stacked smaller grids.
2.  **Background Color:** Each input grid has a dominant background color (Red, Green, Yellow, Azure in the examples). This background color is preserved in the output grid's background areas.
3.  **Objects/Shapes:** Embedded within the input grid's background are distinct geometric shapes made of various colors (Yellow, Azure, Green, Blue, Red). These shapes appear to be the primary focus. Based on the output dimensions, these shapes seem to occupy a 6x6 bounding box.
4.  **Noise Pixels:** Some input grids contain scattered pixels of specific colors (Gray=5, Orange=7, Maroon=9 - although Maroon=9 isn't seen in these examples). These pixels are not part of the main shapes and do not appear in the final output grid; they seem to be noise or potentially control signals. Gray pixels appear frequently but are removed. Orange pixels appear only in `train_3`.
5.  **Transformation Goal:** The task seems to be about identifying specific shapes (those fitting a 6x6 bounding box) in the input, extracting them, cleaning them (removing noise pixels within their bounds), and arranging them vertically in the output.
6.  **Extraction:** Each relevant shape from the input corresponds to one 6x6 grid in the output. The extraction seems based on the shape's 6x6 bounding box.
7.  **Cleaning:** Any 'noise' pixels (Gray=5, Orange=7) found within the extracted 6x6 bounding box of a shape are replaced with the input grid's background color.
8.  **Ordering:** The extracted and cleaned 6x6 shapes are stacked vertically. The order appears to be determined by the top-to-bottom, then left-to-right position of the shape's bounding box in the input grid. However, in `train_3`, where Orange(7) pixels are present in the input, this order is reversed.

**YAML Facts Block**


```yaml
task_description: Extract specific 6x6 shapes from an input grid, clean them, and stack them vertically in a specific order.

elements:
  - element: grid
    role: input/output container
    properties:
      - background_color: The most frequent color in the input grid.
      - dimensions: variable (up to 30x30 for input). Output height is N * 6, width is 6, where N is the number of extracted shapes.

  - element: shape
    role: primary object of interest
    properties:
      - colors: Any color except background and noise colors (e.g., Yellow, Azure, Green, Blue, Red).
      - structure: Contiguous block of non-background, non-noise pixels.
      - size_constraint: Must have a bounding box of exactly 6x6 pixels.
      - location: Defined by its bounding box coordinates in the input grid.

  - element: noise_pixel
    role: irrelevant data or control signal
    properties:
      - colors: [Gray (5), Orange (7), Maroon (9)]
      - location: Scattered within the input grid, potentially inside shape bounding boxes.
      - significance:
          - Gray (5), Maroon (9): Ignored during shape identification, removed if within an extracted shape's box.
          - Orange (7): Presence in the input grid signals a reversal of the output stacking order. Also removed if within an extracted shape's box.

actions:
  - action: identify_background_color
    description: Find the most frequent pixel color in the input grid.
  - action: identify_shapes
    description: Find all maximal contiguous blocks of pixels that are not background or noise colors.
  - action: filter_shapes
    description: Select only those identified shapes whose bounding box dimensions are exactly 6x6.
  - action: determine_order
    description: >
      Calculate the top-left corner (min_row, min_col) for the bounding box of each filtered shape.
      Sort the shapes based on these coordinates (primary key: min_row, secondary key: min_col).
      Check if any Orange (7) pixels exist anywhere in the input grid. If yes, reverse the sorted order.
  - action: extract_and_clean
    description: >
      For each shape in the determined order:
      1. Extract the 6x6 pixel region corresponding to its bounding box from the input grid.
      2. Replace any noise pixels (Gray=5, Orange=7, Maroon=9) within this 6x6 region with the identified background color.
  - action: stack_output
    description: Vertically concatenate the cleaned 6x6 grids in the determined order to create the final output grid.

relationships:
  - relation: shape_extraction
    subject: shape
    object: output_grid
    description: Each filtered 6x6 shape from the input corresponds to a 6x6 subgrid in the output.
  - relation: noise_removal
    subject: noise_pixel
    object: shape (within its 6x6 box)
    description: Noise pixels within a shape's extracted 6x6 box are replaced by the background color.
  - relation: order_determination
    subject: shape location
    object: stacking order
    description: The relative position (top-left corner) of shapes determines their stacking order.
  - relation: order_reversal
    subject: Orange (7) pixel presence
    object: stacking order
    description: The presence of Orange (7) in the input grid reverses the default stacking order.
```


**Natural Language Program**

1.  Determine the background color by finding the most frequent color in the input grid.
2.  Identify potential "noise" colors: Gray (5), Orange (7), and Maroon (9).
3.  Find all distinct contiguous objects in the input grid composed of colors other than the background color and the noise colors.
4.  For each object found, determine its bounding box. Keep only those objects whose bounding box is exactly 6x6 pixels in size.
5.  Create a list of these valid 6x6 shapes. If no such shapes are found, the output is likely empty or unchanged (clarification needed, but examples suggest shapes are always found).
6.  Determine the initial ordering of these shapes by sorting them based on the row index of their bounding box's top edge, using the column index of the left edge as a tiebreaker (top-to-bottom, then left-to-right).
7.  Scan the entire input grid to check if any Orange (7) pixels are present.
8.  If Orange (7) pixels are present in the input grid, reverse the order of the shapes determined in step 6. Otherwise, maintain the order from step 6.
9.  Initialize an empty list to store the final 6x6 output grids.
10. Iterate through the shapes in the (potentially reversed) order:
    a.  Extract the 6x6 grid region corresponding to the shape's bounding box from the original input grid.
    b.  Create a cleaned version of this 6x6 grid: Iterate through its pixels, and if a pixel's color is one of the noise colors (5, 7, or 9), change its color to the background color identified in step 1.
    c.  Add the cleaned 6x6 grid to the list of output grids.
11. Vertically stack all the cleaned 6x6 grids in the list generated in step 10 to form the final output grid.
```python
import numpy as np
from collections import Counter

"""
Identifies specific 6x6 shapes within an input grid based on non-background, non-noise colors.
Filters these shapes to keep only those with exact 6x6 bounding boxes.
Determines the stacking order based on the top-left corner of the shapes (top-to-bottom, left-to-right), 
reversing this order if any Orange (7) pixels are present in the original input.
Extracts each selected shape's 6x6 area from the input.
Cleans the extracted 6x6 grids by replacing noise pixels (Gray=5, Orange=7, Maroon=9) with the background color.
Vertically stacks the cleaned 6x6 grids in the determined order to produce the final output grid.
"""

def find_objects(grid, background_color, noise_colors):
    """
    Finds contiguous objects of non-background, non-noise colors in the grid.

    Args:
        grid (np.array): The input grid.
        background_color (int): The background color.
        noise_colors (set): A set of colors to ignore as part of objects.

    Returns:
        list: A list of tuples, where each tuple contains:
              - min_row (int): Minimum row index of the object's bounding box.
              - max_row (int): Maximum row index of the object's bounding box.
              - min_col (int): Minimum column index of the object's bounding box.
              - max_col (int): Maximum column index of the object's bounding box.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start BFS if we find an unvisited pixel that is not background or noise
            if not visited[r, c] and color != background_color and color not in noise_colors:
                obj_coords = []
                q = [(r, c)]
                visited[r, c] = True
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.pop(0)
                    obj_coords.append((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:
                            neighbor_color = grid[nr, nc]
                            # Only add neighbors that belong to the same object type (not background or noise)
                            if neighbor_color != background_color and neighbor_color not in noise_colors:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                # Store the bounding box of the found object
                objects.append((min_r, max_r, min_c, max_c))
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid by extracting, cleaning, and stacking 6x6 shapes.

    Args:
        input_grid (list): A list of lists representing the input grid.

    Returns:
        list: A list of lists representing the transformed output grid.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape

    # 1. Determine the background color (most frequent color)
    colors, counts = np.unique(grid, return_counts=True)
    background_color = colors[np.argmax(counts)]

    # 2. Define noise colors
    noise_colors = {5, 7, 9}

    # 3. Find all distinct contiguous objects (non-background, non-noise)
    # 4. Filter objects to keep only those with a 6x6 bounding box
    all_objects = find_objects(grid, background_color, noise_colors)
    
    valid_shapes = []
    for min_r, max_r, min_c, max_c in all_objects:
        height = max_r - min_r + 1
        width = max_c - min_c + 1
        if height == 6 and width == 6:
            valid_shapes.append({'min_row': min_r, 'min_col': min_c})

    # 5. Handle case where no valid shapes are found
    if not valid_shapes:
        # Output should be empty or handled based on specific task rules if this occurs.
        # Based on examples, we expect shapes. Returning empty list for now.
        # A 0x6 grid might be more appropriate if numpy output is needed internally.
        return [] 

    # 6. Determine initial ordering (top-to-bottom, left-to-right)
    valid_shapes.sort(key=lambda s: (s['min_row'], s['min_col']))

    # 7. Check for Orange (7) pixels in the input grid
    has_orange = np.any(grid == 7)

    # 8. Reverse order if Orange (7) is present
    if has_orange:
        valid_shapes.reverse()

    # 9. Initialize list for cleaned 6x6 output grids
    output_grids = []

    # 10. Iterate through shapes, extract, clean, and collect
    for shape in valid_shapes:
        min_r, min_c = shape['min_row'], shape['min_col']
        
        # a. Extract the 6x6 region
        extracted_grid = grid[min_r : min_r + 6, min_c : min_c + 6].copy()
        
        # b. Clean the extracted grid (replace noise with background)
        for r in range(6):
            for c in range(6):
                if extracted_grid[r, c] in noise_colors:
                    extracted_grid[r, c] = background_color
                    
        # c. Add cleaned grid to the list
        output_grids.append(extracted_grid)

    # 11. Vertically stack the cleaned grids
    if not output_grids: # Double check after cleaning/extraction (shouldn't happen if valid_shapes wasn't empty)
         return []
    final_output_grid_np = np.vstack(output_grids)

    # Convert final numpy array back to list of lists
    return final_output_grid_np.tolist()
```
```python
import numpy as np
from collections import Counter

"""
Identify distinct, same-colored contiguous objects (non-background, non-noise) 
whose minimal bounding box fits within 6x6. Use the top-left corner of each 
such object's bounding box to define the top-left corner of a 6x6 window to 
extract from the input. Collect all unique 6x6 window definitions. Order 
them top-to-bottom, left-to-right based on their top-left corner. If the 
input grid contains any Orange (7) pixels, reverse this order. Extract each 
6x6 window, clean it by replacing noise pixels (Gray=5, Orange=7, Maroon=9) 
with the background color, and vertically stack the cleaned windows to create 
the output.
"""

def find_colored_objects(grid, background_color, noise_colors):
    """
    Finds contiguous objects of the *same* non-background, non-noise color.

    Args:
        grid (np.array): The input grid.
        background_color (int): The background color.
        noise_colors (set): A set of colors to ignore as part of objects.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains:
              - 'color': The color of the object.
              - 'pixels': A set of (row, col) tuples for pixels in the object.
              - 'bbox': A tuple (min_r, max_r, min_c, max_c) for the bounding box.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start BFS if we find an unvisited pixel that is not background or noise
            if not visited[r, c] and color != background_color and color not in noise_colors:
                obj_pixels = set()
                q = [(r, c)]
                visited[r, c] = True
                current_color = color # Color of the object we are tracing
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.pop(0)
                    obj_pixels.add((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if visited
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]:
                            neighbor_color = grid[nr, nc]
                            # Only add neighbors of the SAME color as the starting pixel
                            if neighbor_color == current_color:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                # Store the found object details
                objects.append({
                    'color': current_color,
                    'pixels': obj_pixels,
                    'bbox': (min_r, max_r, min_c, max_c)
                })
                
    return objects

def transform(input_grid):
    """
    Transforms the input grid based on the described logic.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return []

    # 1. Identify the background color
    colors, counts = np.unique(grid, return_counts=True)
    if len(colors) == 0: # Handle empty input grid case
      return []
    background_color = colors[np.argmax(counts)]

    # 2. Define noise colors
    noise_colors = {5, 7, 9}

    # 3. Find all contiguous objects by color
    all_objects = find_colored_objects(grid, background_color, noise_colors)

    # 4. Filter objects by bounding box size (<= 6x6)
    filtered_objects = []
    for obj in all_objects:
        min_r, max_r, min_c, max_c = obj['bbox']
        height = max_r - min_r + 1
        width = max_c - min_c + 1
        if height <= 6 and width <= 6:
            filtered_objects.append(obj)

    # 5. Get unique top-left corners (min_r, min_c) from filtered objects
    unique_corners = set()
    for obj in filtered_objects:
        min_r, _, min_c, _ = obj['bbox']
        # Ensure the 6x6 window starting at this corner fits within the grid
        if min_r + 6 <= rows and min_c + 6 <= cols:
             unique_corners.add((min_r, min_c))
        #else:
            # Optional: log or handle cases where object near edge implies window out of bounds
            # Based on examples, seems objects are placed such that 6x6 fits
            # pass 

    # 6. Handle case where no valid corners are found
    if not unique_corners:
        return [] 

    # 7. Sort unique corners (row, then column)
    sorted_corners = sorted(list(unique_corners), key=lambda x: (x[0], x[1]))

    # 8. Check for Orange (7) in the original input grid
    has_orange = np.any(grid == 7)

    # 9. Reverse order if Orange (7) is present
    if has_orange:
        sorted_corners.reverse()

    # 10. Initialize list for cleaned 6x6 output grids
    output_subgrids = []

    # 11. Iterate through corners, extract, clean, and collect
    for r_corner, c_corner in sorted_corners:
        # a. Extract the 6x6 subgrid (already bounds-checked in step 5)
        subgrid = grid[r_corner : r_corner + 6, c_corner : c_corner + 6].copy()
        
        # b. Clean the subgrid (replace noise with background)
        for r_sub in range(6):
            for c_sub in range(6):
                if subgrid[r_sub, c_sub] in noise_colors:
                    subgrid[r_sub, c_sub] = background_color
                    
        # c. Add cleaned subgrid to the list
        output_subgrids.append(subgrid)

    # 12. Vertically stack the cleaned grids
    if not output_subgrids:
         return [] # Should not happen if unique_corners was not empty, but good practice
         
    final_output_grid_np = np.vstack(output_subgrids)

    # Convert final numpy array back to list of lists
    return final_output_grid_np.tolist()
```
