{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid by first selecting a specific horizontal slice and then modifying it through horizontal color expansion.\n\nThe transformation follows these steps:\n1.  **Slicing:** Assumes the input grid is composed of exactly 3 vertically stacked slices of equal height. The input grid is divided into these three slices.\n2.  **Background Identification:** Determines 'background' colors by finding the set of colors present in *all* three slices.\n3.  **Slice Selection:** Calculates the number of 'content' pixels (non-background colors) in each slice. The slice with the maximum number of content pixels is selected. Ties are broken by choosing the topmost slice (lowest index).\n4.  **Fill Color Identification:** Within the selected slice, identifies the 'fill color'. This is the background color that appears most frequently in that specific slice. If background colors are tied in frequency, the one with the lower numerical value is chosen. If no background colors are present in the selected slice (or if no background colors were identified globally), no fill color is determined.\n5.  **Horizontal Expansion:** Creates a modified version of the selected slice. For each pixel that is a 'content' color in the original selected slice, its color is expanded horizontally (left and right) into adjacent pixels, overwriting them *only if* their original color was the 'fill color'. Expansion stops at the grid boundaries or when a pixel of a different color (not the fill color) is encountered. If no fill color was determined, this step is skipped.\n6.  **Output:** The resulting modified slice is the output grid.\n\"\"\"\n\n\ndef _get_unique_colors(grid_slice: np.ndarray) -> set:\n    \"\"\"Helper function finds the set of unique non-zero colors in a numpy grid slice.\"\"\"\n    return set(np.unique(grid_slice))\n\ndef _get_fill_color(grid_slice: np.ndarray, background_colors: set) -> int | None:\n    \"\"\"\n    Identifies the most frequent background color within the slice.\n\n    Args:\n        grid_slice: The numpy array representing the selected slice.\n        background_colors: A set of colors identified as background.\n\n    Returns:\n        The integer color value of the most frequent background color in the slice,\n        or None if no background colors are present in the slice.\n    \"\"\"\n    if not background_colors:\n        return None # No background colors defined globally\n\n    # Flatten the slice and count all colors\n    colors, counts = np.unique(grid_slice, return_counts=True)\n    \n    # Filter counts to include only background colors present in this slice\n    bg_color_counts = {\n        color: count\n        for color, count in zip(colors, counts)\n        if color in background_colors\n    }\n\n    if not bg_color_counts:\n        return None # No background colors found in this specific slice\n\n    # Find the background color with the maximum count\n    # If counts are tied, max() on the dictionary items will prioritize the key (color value)\n    # after prioritizing the value (count). We want max count, then min color value for ties.\n    # A more explicit way:\n    max_count = -1\n    fill_color = None\n    # Sort by count desc, then color asc to handle ties consistently\n    sorted_bg_colors = sorted(bg_color_counts.items(), key=lambda item: (-item[1], item[0]))\n\n    if sorted_bg_colors:\n       fill_color = sorted_bg_colors[0][0]\n       return int(fill_color) # Ensure return type is standard int\n       \n    return None # Should not be reached if bg_color_counts was not empty\n\ndef _expand_horizontally(grid_slice: np.ndarray, background_colors: set, fill_color: int | None) -> np.ndarray:\n    \"\"\"\n    Performs the horizontal expansion of content colors into the fill color.\n\n    Args:\n        grid_slice: The numpy array representing the selected slice.\n        background_colors: A set of colors identified as background.\n        fill_color: The specific background color to be overwritten by expansion.\n\n    Returns:\n        A new numpy array representing the slice after horizontal expansion.\n    \"\"\"\n    # If there's no fill color, no expansion can occur\n    if fill_color is None:\n        return grid_slice.copy() # Return a copy to maintain immutability of the original slice\n\n    H, W = grid_slice.shape\n    output_slice = grid_slice.copy() # Work on a copy\n\n    for r in range(H):\n        for c in range(W):\n            original_color = grid_slice[r, c]\n\n            # Check if the current pixel is a content color\n            if original_color not in background_colors:\n                content_color = original_color\n\n                # Expand Left\n                for col in range(c - 1, -2, -1): # Go from c-1 down to -1 (boundary check)\n                    if col < 0: # Hit left boundary\n                        break\n                    # Check the color in the *original* slice to decide if we can expand *into* it\n                    if grid_slice[r, col] == fill_color:\n                        # Modify the output slice\n                        output_slice[r, col] = content_color\n                    else:\n                        # Stop expanding left if we hit a non-fill color\n                        break\n\n                # Expand Right\n                for col in range(c + 1, W + 1, 1): # Go from c+1 up to W (boundary check)\n                    if col >= W: # Hit right boundary\n                        break\n                     # Check the color in the *original* slice to decide if we can expand *into* it\n                    if grid_slice[r, col] == fill_color:\n                         # Modify the output slice\n                        output_slice[r, col] = content_color\n                    else:\n                        # Stop expanding right if we hit a non-fill color\n                        break\n                        \n    return output_slice\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the slice selection and horizontal expansion logic.\n\n    Args:\n        input_grid_list: A list of lists representing the input grid pixels.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid = np.array(input_grid_list, dtype=int)\n\n    # Handle edge case: empty input grid\n    if input_grid.size == 0:\n        return []\n\n    H_in, W_in = input_grid.shape\n\n    # --- 1. Slicing ---\n    num_slices = 3\n    if H_in == 0 or H_in % num_slices != 0:\n        # If height is 0 or not divisible by 3, the core assumption is violated.\n        # Depending on ARC rules, might return input, raise error, or return empty.\n        # Returning input unchanged seems safest if the pattern doesn't match.\n        # However, the examples strongly suggest divisibility by 3 is required.\n        # Let's raise an error for clarity during development/testing.\n        raise ValueError(f\"Input grid height {H_in} is not divisible by {num_slices} or is zero.\")\n\n    slice_height = H_in // num_slices\n\n    slices = []\n    for i in range(num_slices):\n        start_row = i * slice_height\n        end_row = start_row + slice_height\n        slices.append(input_grid[start_row:end_row, :])\n\n    # --- 2. Background Identification ---\n    if not slices: # Should not happen if H_in > 0 and divisible by 3\n         return []\n\n    common_colors = _get_unique_colors(slices[0])\n    for i in range(1, num_slices):\n        slice_colors = _get_unique_colors(slices[i])\n        common_colors.intersection_update(slice_colors)\n        if not common_colors: # Optimization\n            break\n    background_colors = common_colors\n\n    # --- 3. Slice Selection ---\n    content_pixel_counts = []\n    for i in range(num_slices):\n        current_slice = slices[i]\n        count = 0\n        # Efficiently count non-background pixels\n        mask = ~np.isin(current_slice, list(background_colors))\n        count = np.sum(mask)\n        content_pixel_counts.append(count)\n\n    # Find the index of the slice with the maximum content pixels\n    # np.argmax handles ties by returning the first occurrence (lowest index)\n    if not content_pixel_counts: # Should only happen if input was empty or H_in=0\n        best_slice_index = 0 # Default to first slice if counts are somehow empty\n    else:\n        best_slice_index = np.argmax(content_pixel_counts)\n\n    selected_slice = slices[best_slice_index]\n\n    # --- 4. Fill Color Identification ---\n    fill_color = _get_fill_color(selected_slice, background_colors)\n\n    # --- 5. Horizontal Expansion ---\n    output_grid_np = _expand_horizontally(selected_slice, background_colors, fill_color)\n\n    # --- 6. Output ---\n    # Convert the resulting numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11038,
    "candidates_token_count": 2162,
    "total_token_count": 13200,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.622303,
  "retries": 1
}