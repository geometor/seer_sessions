{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Identify Static vs. Dynamic Pixels:**\n    *   Find all contiguous objects (blocks of the same non-white color).\n    *   Determine the largest object (by pixel count). The color of this largest object is the \"static color\". All pixels of this color remain unchanged in the output.\n    *   All other non-white pixels are \"dynamic pixels\". These are removed from their original positions.\n\n2.  **Determine Actor Color and Shape Size:**\n    *   Count the frequency of each color among the dynamic pixels.\n    *   The \"actor color\" is the dynamic color with the highest frequency. If there's a tie in frequency, the color with the highest numerical index wins.\n    *   The size parameter `N` for the output shape is the count of pixels of the actor color.\n\n3.  **Construct Output Grid:**\n    *   Initialize an output grid of the same dimensions as the input, filled with white (0).\n    *   Copy the static pixels (with the static color) to the output grid at their original locations.\n    *   Based on the actor color and size `N`, draw a specific shape in a specific corner using the actor color:\n        *   **Red (2):** Bottom-Left corner, Right-angled triangle of side `N`, hypotenuse pointing Up-Right. Pixels `(r, c)` where `H-N <= r < H`, `0 <= c < N`, and `(H - 1 - r) + c < N`.\n        *   **Yellow (4):** If `N` is 2, Bottom-Right corner, 2x2 square. Pixels `(r, c)` where `H-2 <= r < H` and `W-2 <= c < W`. (Behavior for N!=2 is unspecified by examples, assumed not to occur or not to draw shape).\n        *   **Magenta (6):** Bottom-Right corner, Right-angled triangle of side `N`, hypotenuse pointing Up-Left. Pixels `(r, c)` where `H-N <= r < H`, `W-N <= c < W`, and `(H - 1 - r) + (W - 1 - c) < N`.\n        *   **Orange (7):** Top-Left corner, Right-angled triangle of side `N`, hypotenuse pointing Down-Right. Pixels `(r, c)` where `0 <= r < N`, `0 <= c < N`, and `r + c < N`.\n    *   The final output grid contains the static pixels and the newly drawn shape.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"Finds all contiguous objects of non-white colors using BFS.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Start BFS if pixel is non-white and not visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                obj_color = color\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.append((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and color match\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'color': obj_color, 'pixels': obj_pixels, 'size': len(obj_pixels)})\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies static/dynamic pixels, determines actor color and shape size,\n    and constructs the output grid with static pixels and a new shape.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    height, width = input_grid_np.shape\n    \n    # 1. Identify Static vs. Dynamic Pixels\n    objects = find_objects(input_grid_np)\n    \n    static_color = -1\n    static_pixels_coords = []\n    dynamic_pixels = [] # List of tuples (r, c, color)\n    \n    if not objects:\n        # Handle case with no non-white pixels\n        return input_grid_np.tolist() \n        \n    # Find the largest object to determine static color\n    largest_object_size = -1\n    largest_object_color = -1\n    for obj in objects:\n        if obj['size'] > largest_object_size:\n            largest_object_size = obj['size']\n            largest_object_color = obj['color']\n        # Handle tie in size - largest color index wins (though not explicitly stated for static, common ARC pattern)\n        elif obj['size'] == largest_object_size:\n             largest_object_color = max(largest_object_color, obj['color'])\n             \n    static_color = largest_object_color\n    \n    # Separate static and dynamic pixels\n    for obj in objects:\n        if obj['color'] == static_color:\n            static_pixels_coords.extend(obj['pixels'])\n        else:\n            for r, c in obj['pixels']:\n                dynamic_pixels.append((r, c, obj['color']))\n\n    # 2. Determine Actor Color and Shape Size (N)\n    actor_color = -1\n    actor_pixel_count_N = 0\n    \n    if dynamic_pixels:\n        dynamic_colors = [p[2] for p in dynamic_pixels]\n        if dynamic_colors:\n            color_counts = Counter(dynamic_colors)\n            max_count = 0\n            \n            # Find max frequency among dynamic colors\n            if color_counts:\n                 max_count = max(color_counts.values())\n\n            # Find candidate colors with max frequency\n            candidates = []\n            for color, count in color_counts.items():\n                if count == max_count:\n                    candidates.append(color)\n\n            # Tie-break using highest color index\n            if candidates:\n                actor_color = max(candidates)\n                # N is the count of the winning actor color\n                actor_pixel_count_N = color_counts[actor_color] \n\n    # 3. Construct Output Grid\n    output_grid = np.zeros_like(input_grid_np) # Initialize with white (0)\n    \n    # Place static pixels\n    for r, c in static_pixels_coords:\n        if 0 <= r < height and 0 <= c < width: # Bounds check just in case\n             output_grid[r, c] = static_color\n\n    # Draw the shape based on actor_color and N\n    N = actor_pixel_count_N\n    if actor_color != -1 and N > 0:\n        if actor_color == 2: # Red -> BL Triangle Up-Right\n            for r in range(H - N, H):\n                for c in range(N):\n                    if (H - 1 - r) + c < N:\n                         if 0 <= r < height and 0 <= c < width:\n                            output_grid[r, c] = actor_color\n                            \n        elif actor_color == 4: # Yellow -> BR 2x2 Square (only if N=2)\n            if N == 2:\n                for r in range(H - 2, H):\n                    for c in range(W - 2, W):\n                         if 0 <= r < height and 0 <= c < width:\n                             output_grid[r, c] = actor_color\n                             \n        elif actor_color == 6: # Magenta -> BR Triangle Up-Left\n            for r in range(H - N, H):\n                for c in range(W - N, W):\n                    if (H - 1 - r) + (W - 1 - c) < N:\n                         if 0 <= r < height and 0 <= c < width:\n                            output_grid[r, c] = actor_color\n                            \n        elif actor_color == 7: # Orange -> TL Triangle Down-Right\n             for r in range(N):\n                 for c in range(N):\n                     if r + c < N:\n                         if 0 <= r < height and 0 <= c < width:\n                             output_grid[r, c] = actor_color\n\n    return output_grid.tolist()\n\n# Helper variables (needed inside draw logic)\nH, W = 0, 0 # Global or passed into draw functions is better, setting inside transform\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies static/dynamic pixels, determines actor color and shape size,\n    and constructs the output grid with static pixels and a new shape.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    global H, W # Use global H, W - less ideal but works for template\n    H, W = input_grid_np.shape # Set grid dimensions H, W\n    \n    # 1. Identify Static vs. Dynamic Pixels\n    objects = find_objects(input_grid_np)\n    \n    static_color = -1\n    static_pixels_coords = []\n    dynamic_pixels = [] # List of tuples (r, c, color)\n    \n    if not objects:\n        # Handle case with no non-white pixels\n        return input_grid_np.tolist() \n        \n    # Find the largest object to determine static color\n    largest_object_size = -1\n    largest_object_color = -1\n    # Use a list to handle potential ties in size correctly before picking max color index\n    largest_objects_candidates = [] \n    for obj in objects:\n        if obj['size'] > largest_object_size:\n            largest_object_size = obj['size']\n            largest_objects_candidates = [obj['color']] # Reset candidates\n        elif obj['size'] == largest_object_size:\n            largest_objects_candidates.append(obj['color']) # Add to candidates\n             \n    if largest_objects_candidates:\n        static_color = max(largest_objects_candidates) # Pick highest color index among largest\n    else:\n         # If no objects found, maybe return original? or empty?\n         # Based on logic flow, this shouldn't happen if objects list is not empty.\n         # If objects list *was* empty, it returned earlier.\n         # Add a fallback just in case.\n         return input_grid_np.tolist()\n\n\n    # Separate static and dynamic pixels\n    for obj in objects:\n        if obj['color'] == static_color:\n            static_pixels_coords.extend(obj['pixels'])\n        else:\n            for r, c in obj['pixels']:\n                dynamic_pixels.append((r, c, obj['color']))\n\n    # 2. Determine Actor Color and Shape Size (N)\n    actor_color = -1\n    actor_pixel_count_N = 0\n    \n    if dynamic_pixels:\n        dynamic_colors = [p[2] for p in dynamic_pixels]\n        if dynamic_colors:\n            color_counts = Counter(dynamic_colors)\n            max_count = 0\n            \n            # Find max frequency among dynamic colors\n            if color_counts:\n                 max_count = max(color_counts.values())\n\n            # Find candidate colors with max frequency\n            candidates = []\n            for color, count in color_counts.items():\n                if count == max_count:\n                    candidates.append(color)\n\n            # Tie-break using highest color index\n            if candidates:\n                actor_color = max(candidates)\n                # N is the count of the winning actor color\n                actor_pixel_count_N = color_counts[actor_color] \n\n    # 3. Construct Output Grid\n    output_grid = np.zeros_like(input_grid_np) # Initialize with white (0)\n    \n    # Place static pixels\n    for r, c in static_pixels_coords:\n        # Ensure coords are within bounds - shouldn't be necessary if find_objects is correct\n        if 0 <= r < H and 0 <= c < W: \n             output_grid[r, c] = static_color\n\n    # Draw the shape based on actor_color and N\n    N = actor_pixel_count_N\n    if actor_color != -1 and N > 0:\n        # Define bounds checks to simplify drawing loops\n        def is_valid(r, c):\n            return 0 <= r < H and 0 <= c < W\n\n        if actor_color == 2: # Red -> BL Triangle Up-Right\n            for r in range(H - N, H):\n                for c in range(N):\n                    if (H - 1 - r) + c < N:\n                         if is_valid(r, c):\n                            output_grid[r, c] = actor_color\n                            \n        elif actor_color == 4: # Yellow -> BR 2x2 Square (only if N=2)\n            if N == 2:\n                for r in range(H - 2, H):\n                    for c in range(W - 2, W):\n                         if is_valid(r, c):\n                             output_grid[r, c] = actor_color\n                             \n        elif actor_color == 6: # Magenta -> BR Triangle Up-Left\n            for r in range(H - N, H):\n                for c in range(W - N, W):\n                    # Check triangle condition relative to corner (H-1, W-1)\n                    # Equivalent condition: (r - (H-N)) + (c - (W-N)) >= N-1 ? No simpler..\n                    # Use original derived condition: (H-1-r) + (W-1-c) < N\n                    if (H - 1 - r) + (W - 1 - c) < N:\n                         if is_valid(r, c):\n                            output_grid[r, c] = actor_color\n                            \n        elif actor_color == 7: # Orange -> TL Triangle Down-Right\n             for r in range(N):\n                 for c in range(N):\n                     if r + c < N:\n                         if is_valid(r, c):\n                             output_grid[r, c] = actor_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4674,
    "candidates_token_count": 3448,
    "total_token_count": 8122,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.543899,
  "retries": 1
}