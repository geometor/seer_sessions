{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Identify Static Color:** Determine the non-white color (`S`) that has the highest total pixel count in the input grid. If there's a tie in count, choose the color with the highest numerical index.\n2.  **Identify Static and Dynamic Pixels:**\n    *   All pixels in the input grid with the static color `S` are \"static pixels\".\n    *   All other non-white pixels in the input grid are \"dynamic pixels\".\n3.  **Calculate Size Parameters:**\n    *   `N_total`: Count the total number of dynamic pixels.\n    *   `N_actor`: Count the number of dynamic pixels that have the \"actor color\" (defined below).\n4.  **Determine Actor Color `A`:** Find the color that appears most frequently among the dynamic pixels. If there's a tie for the highest frequency, choose the color with the highest numerical index as the \"actor color\" `A`.\n5.  **Construct Output Grid:**\n    *   Initialize an output grid of the same dimensions (height `H`, width `W`) as the input, filled with white (0).\n    *   Copy all static pixels (color `S`) from the input grid to the output grid at their original coordinates.\n    *   Determine the shape to draw based on the actor color `A` and the relevant size parameter (`N_total` or `N_actor`):\n        *   If `A` is Yellow (4): Draw a vertical line of length `N_actor` using color `A` in the Bottom-Right corner (column `W-1`, rows `H-N_actor` to `H-1`).\n        *   If `A` is Red (2): Draw a right-angled triangle of side length `N_total` using color `A` in the Bottom-Left corner, with the hypotenuse pointing Up-Right. Pixels `(r, c)` satisfy `H - N_total <= r < H`, `0 <= c < N_total`, and `(H - 1 - r) + c < N_total`.\n        *   If `A` is Magenta (6): Draw a right-angled triangle of side length `N_actor` using color `A` in the Bottom-Right corner, with the hypotenuse pointing Up-Left. Pixels `(r, c)` satisfy `H - N_actor <= r < H`, `W - N_actor <= c < W`, and `(H - 1 - r) + (W - 1 - c) < N_actor`.\n        *   If `A` is Orange (7): Draw a right-angled triangle of side length `N_total` using color `A` in the Top-Left corner, with the hypotenuse pointing Down-Right. Pixels `(r, c)` satisfy `0 <= r < N_total`, `0 <= c < N_total`, and `r + c < N_total`.\n    *   Draw the determined shape onto the output grid. Only draw if the corresponding size parameter (`N_total` or `N_actor`) is greater than 0.\n\"\"\"\n\ndef find_pixel_coords_by_color(grid):\n    \"\"\"Creates a dictionary mapping each non-white color to a list of its pixel coordinates.\"\"\"\n    coords_map = {}\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0: # Ignore background\n                if color not in coords_map:\n                    coords_map[color] = []\n                coords_map[color].append((r, c))\n    return coords_map\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=np.int64)\n    height, width = input_grid_np.shape\n    \n    # --- Helper function for bounds checking ---\n    def is_valid(r, c):\n        return 0 <= r < height and 0 <= c < width\n\n    # --- 1. Identify Static Color ---\n    coords_map = find_pixel_coords_by_color(input_grid_np)\n    \n    static_color = -1\n    max_count = -1\n    \n    # Sort colors by index descending for tie-breaking during count comparison\n    sorted_colors = sorted(coords_map.keys(), reverse=True) \n    \n    for color in sorted_colors:\n        count = len(coords_map[color])\n        # If current count is higher, or equal with higher color index (already handled by sort)\n        if count >= max_count: \n            max_count = count\n            static_color = color\n            \n    # Handle edge case: grid is all white\n    if static_color == -1:\n        return input_grid_np.tolist()\n\n    # --- 2. Identify Static and Dynamic Pixels ---\n    static_pixels_coords = coords_map.get(static_color, [])\n    dynamic_pixels_info = [] # List of (r, c, color)\n    dynamic_colors_list = []\n    \n    for color, coords in coords_map.items():\n        if color != static_color:\n            for r, c in coords:\n                dynamic_pixels_info.append((r, c, color))\n                dynamic_colors_list.append(color)\n\n    # --- 3/4. Calculate N_total, Determine Actor Color A, Calculate N_actor ---\n    N_total = len(dynamic_pixels_info)\n    \n    actor_color = -1\n    N_actor = 0\n    \n    if dynamic_colors_list: # Proceed only if there are dynamic pixels\n        color_counts = Counter(dynamic_colors_list)\n        max_freq = 0\n        if color_counts: # Check if counter is not empty\n             max_freq = max(color_counts.values())\n        \n        candidates = []\n        for color, count in color_counts.items():\n            if count == max_freq:\n                candidates.append(color)\n        \n        if candidates:\n            actor_color = max(candidates) # Tie-break with highest index\n            N_actor = color_counts[actor_color] # Get count for the chosen actor color\n\n    # --- 5. Construct Output Grid ---\n    output_grid = np.zeros_like(input_grid_np) # Initialize with white (0)\n\n    # Place static pixels\n    for r, c in static_pixels_coords:\n        if is_valid(r, c): # Bounds check (should be redundant if coords_map is correct)\n            output_grid[r, c] = static_color\n\n    # Draw the shape based on actor_color and relevant N\n    if actor_color != -1: # Only draw if an actor color was determined\n        \n        if actor_color == 4: # Yellow -> BR Vertical Line, Length N_actor\n            if N_actor > 0:\n                for r in range(height - N_actor, height):\n                    c = width - 1\n                    if is_valid(r, c):\n                        output_grid[r, c] = actor_color\n                         \n        elif actor_color == 2: # Red -> BL Triangle Up-Right, Size N_total\n            if N_total > 0:\n                for r in range(height - N_total, height):\n                    for c in range(N_total):\n                        # Condition for triangle pixels relative to BL corner (H-1, 0)\n                        if (height - 1 - r) + c < N_total:\n                             if is_valid(r, c):\n                                output_grid[r, c] = actor_color\n                            \n        elif actor_color == 6: # Magenta -> BR Triangle Up-Left, Size N_actor\n            if N_actor > 0:\n                for r in range(height - N_actor, height):\n                    for c in range(width - N_actor, width):\n                        # Condition for triangle pixels relative to BR corner (H-1, W-1)\n                        if (height - 1 - r) + (width - 1 - c) < N_actor:\n                             if is_valid(r, c):\n                                output_grid[r, c] = actor_color\n                            \n        elif actor_color == 7: # Orange -> TL Triangle Down-Right, Size N_total\n             if N_total > 0:\n                 for r in range(N_total):\n                     for c in range(N_total):\n                         # Condition for triangle pixels relative to TL corner (0, 0)\n                         if r + c < N_total:\n                             if is_valid(r, c):\n                                 output_grid[r, c] = actor_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17439,
    "candidates_token_count": 2056,
    "total_token_count": 19495,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.559195,
  "retries": 1
}