
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 3 3 0 0 0 0 0 0 0 0 0
0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 3 0 0 0 0 0 0 0
0 0 0 3 0 0 3 0 0 0 0 0 0
0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0
0 0 0 0 0 0 0 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 3 3 8 0 0
0 0 0 0 0 0 0 0 3 0 3 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 3 0 0 0 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0 0
0 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 8 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 3 3 8 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0
0 0 8 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception**

The input grids consistently feature a white background (0) with exactly two azure pixels (8). The output grids retain these two azure pixels in their original positions. Additionally, a path composed of green pixels (3) appears in the output grid, connecting the two azure pixels. This path seems to follow the trajectory of a straight line drawn between the coordinates of the two azure pixels, selecting the grid cells that best approximate this line. The path pixels themselves do not overlap with the original azure pixels.

**Facts**


```yaml
task_description: Draw a line between two specified points on a grid.
elements:
  - element: grid
    role: background
    attributes:
      color: white (0)
  - element: pixel
    role: marker
    attributes:
      color: azure (8)
      count: 2
      location: distinct coordinates in the input grid.
  - element: pixel
    role: path
    attributes:
      color: green (3)
      location: forms a sequence of grid cells connecting the two marker pixels in the output grid.
relationships:
  - type: connection
    from: marker pixel 1
    to: marker pixel 2
    via: path pixels
    details: The path pixels trace the grid cells corresponding to a line segment drawn between the centers of the two marker pixels.
actions:
  - action: identify
    target: two azure (8) pixels
    input: input grid
  - action: draw_line
    start_point: location of the first azure pixel
    end_point: location of the second azure pixel
    color: green (3)
    output: set of coordinates for the path pixels
    constraints: The algorithm should select grid cells that best approximate the geometric line segment between the start and end points. The start and end points themselves are excluded from the path pixel set.
  - action: compose_output
    source_grid: input grid
    add: path pixels at their calculated coordinates
    result: output grid
```


**Natural Language Program**

1.  Identify the coordinates of the two azure (8) pixels in the input grid. Let these be P1 and P2.
2.  Determine the set of grid coordinates that represent the discrete path of a line drawn between P1 and P2 using a standard grid line-drawing algorithm (like Bresenham's).
3.  Create the output grid as a copy of the input grid.
4.  For each coordinate in the calculated line path (excluding the coordinates of P1 and P2 themselves), set the pixel at that coordinate in the output grid to green (3).
5.  The final output grid contains the original two azure pixels and the newly drawn green path connecting them.
```python
"""
Draw a green (3) line between the two azure (8) pixels found in the input grid. 
The line is drawn using Bresenham's line algorithm, excluding the start and end points (the azure pixels themselves). 
The output grid is a copy of the input grid with the green line pixels added.
"""

import numpy as np

def _find_pixels(grid, color):
    """Finds all coordinates of pixels with a specific color."""
    coords = np.argwhere(grid == color)
    # Convert to list of tuples (row, col)
    return [tuple(coord) for coord in coords]

def _bresenham_line(r0, c0, r1, c1):
    """
    Generate coordinates for a line between (r0, c0) and (r1, c1) using Bresenham's algorithm.
    Includes start and end points.
    """
    points = []
    dr = abs(r1 - r0)
    dc = abs(c1 - c0)
    sr = 1 if r0 < r1 else -1
    sc = 1 if c0 < c1 else -1
    err = dr - dc

    while True:
        points.append((r0, c0))
        if r0 == r1 and c0 == c1:
            break
        e2 = 2 * err
        if e2 > -dc:
            err -= dc
            r0 += sr
        if e2 < dr:
            err += dr
            c0 += sc
            
    return points

def transform(input_grid):
    """
    Identifies two azure (8) pixels in the input grid and draws a green (3) line 
    between them using Bresenham's algorithm. The start and end points are not colored green.
    
    Args:
        input_grid (np.ndarray): A 2D NumPy array representing the input grid.

    Returns:
        np.ndarray: A 2D NumPy array representing the output grid with the line drawn.
    """
    # Find the coordinates of the two azure pixels
    azure_pixels = _find_pixels(input_grid, 8)
    
    if len(azure_pixels) != 2:
        # Handle cases where there aren't exactly two azure pixels (optional, based on ARC constraints)
        # For this specific task, we assume exactly two are always present based on examples.
        # If not, we might return the input unchanged or raise an error.
        # Returning input unchanged seems safer for ARC.
        return input_grid.copy() 
        
    p1 = azure_pixels[0]
    p2 = azure_pixels[1]

    # Generate the line coordinates using Bresenham's algorithm
    line_points = _bresenham_line(p1[0], p1[1], p2[0], p2[1])

    # Initialize the output grid as a copy of the input
    output_grid = input_grid.copy()

    # Iterate through the points on the line
    for r, c in line_points:
        # Check if the current point is not one of the original azure pixels
        if (r, c) != p1 and (r, c) != p2:
            # Check grid boundaries (though Bresenham should stay within if points are)
            if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:
                 # Color the point green
                output_grid[r, c] = 3

    return output_grid
```
