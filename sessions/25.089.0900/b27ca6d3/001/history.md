
## train_1

**input:**
```
0 0 0 0 0 0 0 0 2 2 0 0 0 2 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0 2 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 2 2 3 0 3 2 3 0
2 0 0 0 0 0 0 3 3 3 3 0 3 2 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 3 3
0 0 2 0 0 0 0 0 0 0 2 0 0 2 3 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```

Okay, let's analyze the task based on the provided examples.

**Perception**

1.  **Input/Output Grids:** Both input and output grids consist primarily of white pixels (0) with some scattered red pixels (2). The output grids additionally contain green pixels (3).
2.  **Color Transformation:** The core transformation seems to involve changing some white (0) pixels to green (3) based on the positions of the red (2) pixels. The original red pixels remain unchanged in the output.
3.  **Pattern:** The green pixels in the output appear in the vicinity of *some* of the red pixels from the input. Specifically, they form a sort of "aura" or "boundary" around groups of red pixels.
4.  **Object Identification:** The red pixels can be considered as individual objects or grouped into larger objects (components) if they are connected. Connection seems to include horizontal, vertical, and diagonal adjacency.
5.  **Condition for Change:** Comparing the two examples, it appears that green pixels are only added around red components that consist of *more than one* connected red pixel. Isolated single red pixels do not cause any changes in their neighborhood.
6.  **Neighborhood Definition:** The green pixels appear in the 8 cells immediately surrounding (including diagonals) the red pixels belonging to the multi-pixel components. If a neighboring cell is already red, it remains red. If it's white, it becomes green.

**Facts**


```yaml
Transformation: Grid Color Modification

Input Grid:
  - Contains pixels of colors: white (0), red (2).

Output Grid:
  - Contains pixels of colors: white (0), red (2), green (3).
  - Red (2) pixel locations are preserved from the input.
  - Some white (0) pixels from the input are changed to green (3).

Objects:
  - Red Pixels (value 2): Primary elements driving the transformation.
  - Red Components: Groups of one or more red pixels connected horizontally, vertically, or diagonally.

Relationships:
  - Adjacency: Pixels are considered adjacent if they touch horizontally, vertically, or diagonally (8-connectivity).
  - Connectivity: Red pixels form components based on adjacency.

Actions:
  - Identify connected components of red pixels in the input grid.
  - Count the number of pixels in each red component.
  - Filter components: Select only those red components containing more than one pixel.
  - Identify Neighborhood: For each selected component, find all grid cells adjacent (8-connectivity) to any pixel within that component.
  - Conditional Coloring:
    - If an adjacent cell in the input grid is white (0), change its color to green (3) in the output grid.
    - If an adjacent cell is already red (2), it remains red (2) in the output grid.
  - Preserve Unchanged Pixels: All original red pixels and white pixels not adjacent to the selected multi-pixel red components remain unchanged in the output grid.

```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Find all red (2) pixels in the input grid.
3.  Identify all distinct connected components of red pixels, considering pixels connected if they are adjacent horizontally, vertically, or diagonally.
4.  Iterate through each identified red component.
5.  For the current red component, count the number of red pixels it contains.
6.  If the count of red pixels in the component is greater than 1:
    a.  Iterate through each red pixel belonging to this component.
    b.  For each red pixel, examine its 8 neighboring positions (horizontal, vertical, and diagonal).
    c.  For each neighboring position:
        i.  Check if the position is within the grid boundaries.
        ii. If it is within boundaries and the pixel at that position in the *input* grid is white (0), change the color of the pixel at that same position in the *output* grid to green (3).
7.  Return the modified output grid.
