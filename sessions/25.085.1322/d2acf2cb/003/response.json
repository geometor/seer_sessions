{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\nfrom collections import defaultdict\n\n\"\"\"\nTransforms pixels within specific regions of a grid based on marker pixels and content, prioritizing vertical rectangular regions over horizontal regions.\n\n1.  **Identify Regions:** Scan the input grid for yellow (4) pixels.\n2.  **Check for Vertical Rectangular Regions:** Determine if there are sets of four yellow pixels forming the corners of a rectangle: `(r1, c1)`, `(r1, c2)`, `(r2, c1)`, `(r2, c2)` with `r1 < r2` and `c1 < c2`.\n3.  **Process Vertical Regions (if found):**\n    *   If one or more Vertical Rectangular Regions exist:\n        *   For each such region defined by `(r1, c1, r2, c2)`:\n            *   Define the \"affected pixels\" as those in columns `c1` and `c2` between rows `r1` and `r2` (exclusive: `r1 < row < r2`).\n            *   Examine the colors of these affected pixels in the *input* grid.\n            *   If any affected pixel is orange (7) or azure (8), apply Transformation A: change all orange (7) to magenta (6) and all azure (8) to white (0) within this set of affected pixels in the *output* grid.\n            *   Otherwise, if any affected pixel is white (0) or magenta (6), apply Transformation B: change all white (0) to azure (8) and all magenta (6) to orange (7) within this set of affected pixels in the *output* grid.\n        *   Return the modified output grid. **Do not proceed to check for horizontal regions.**\n4.  **Process Horizontal Regions (if no vertical regions found):**\n    *   If no Vertical Rectangular Regions were found:\n        *   Iterate through each row of the grid.\n        *   If a row contains two or more yellow (4) pixels:\n            *   Find the minimum column index (`c_min`) and maximum column index (`c_max`) of the yellow pixels in that row.\n            *   Define the \"affected pixels\" as those in the current row between columns `c_min` and `c_max` (exclusive: `c_min < col < c_max`).\n            *   Examine the colors of these affected pixels in the *input* grid.\n            *   If any affected pixel is orange (7) or azure (8), apply Transformation A: change all orange (7) to magenta (6) and all azure (8) to white (0) within this set of affected pixels in the *output* grid.\n            *   Otherwise, if any affected pixel is white (0) or magenta (6), apply Transformation B: change all white (0) to azure (8) and all magenta (6) to orange (7) within this set of affected pixels in the *output* grid.\n        *   Return the modified output grid.\n\"\"\"\n\ndef apply_transformation_a(grid, region_coords):\n    \"\"\"Applies Transformation A (7->6, 8->0) to the specified coordinates.\"\"\"\n    for r, c in region_coords:\n        # Check original value before potentially overwriting if multiple regions overlap\n        # Although in this specific logic, overlap isn't expected between distinct application steps\n        # We fetch the value from the potentially modified grid state at this point\n        val = grid[r, c]\n        if val == 7:\n            grid[r, c] = 6\n        elif val == 8:\n            grid[r, c] = 0\n    return grid\n\ndef apply_transformation_b(grid, region_coords):\n    \"\"\"Applies Transformation B (0->8, 6->7) to the specified coordinates.\"\"\"\n    for r, c in region_coords:\n        # Check original value before potentially overwriting\n        val = grid[r, c]\n        if val == 0:\n            grid[r, c] = 8\n        elif val == 6:\n            grid[r, c] = 7\n    return grid\n\ndef find_vertical_rectangular_regions(input_np):\n    \"\"\"Finds all vertical rectangular regions defined by yellow markers.\"\"\"\n    rows, cols = input_np.shape\n    yellow_locations = list(zip(*np.where(input_np == 4)))\n    \n    if not yellow_locations:\n        return []\n\n    # Group yellow locations by column and row for efficient lookup\n    cols_with_yellows = defaultdict(list)\n    rows_with_yellows = defaultdict(list)\n    for r, c in yellow_locations:\n        cols_with_yellows[c].append(r)\n        rows_with_yellows[r].append(c)\n\n    for c in cols_with_yellows:\n        cols_with_yellows[c].sort()\n    for r in rows_with_yellows:\n        rows_with_yellows[r].sort()\n\n    vertical_regions = []\n    processed_rectangles = set() # To avoid duplicate processing if markers form larger structures\n\n    sorted_cols = sorted(cols_with_yellows.keys())\n\n    # Iterate through pairs of columns\n    for i in range(len(sorted_cols)):\n        for j in range(i + 1, len(sorted_cols)):\n            c1 = sorted_cols[i]\n            c2 = sorted_cols[j]\n\n            # Find common rows where both columns have yellow markers\n            common_rows = sorted(list(set(cols_with_yellows[c1]) & set(cols_with_yellows[c2])))\n\n            # Iterate through pairs of common rows to form potential rectangles\n            for k in range(len(common_rows)):\n                for l in range(k + 1, len(common_rows)):\n                    r1 = common_rows[k]\n                    r2 = common_rows[l]\n                    \n                    # Define rectangle corners\n                    rect_corners = frozenset([(r1, c1), (r1, c2), (r2, c1), (r2, c2)])\n                    \n                    # Check if this specific rectangle was already processed as part of a larger one or identical\n                    if rect_corners in processed_rectangles:\n                        continue\n\n                    # Verify all four corners are indeed yellow markers (redundant check, but safe)\n                    if input_np[r1, c1] == 4 and input_np[r1, c2] == 4 and \\\n                       input_np[r2, c1] == 4 and input_np[r2, c2] == 4:\n                        \n                        region_coords = []\n                        region_colors = []\n                        \n                        # Collect region coordinates and colors for the left column\n                        for r in range(r1 + 1, r2):\n                            region_coords.append((r, c1))\n                            region_colors.append(input_np[r, c1])\n                        # Collect region coordinates and colors for the right column\n                        for r in range(r1 + 1, r2):\n                             region_coords.append((r, c2))\n                             region_colors.append(input_np[r, c2])\n\n                        if region_coords: # Only add if the region is not empty\n                            vertical_regions.append({\n                                \"coords\": region_coords,\n                                \"colors\": region_colors\n                            })\n                            processed_rectangles.add(rect_corners) # Mark this rectangle as processed\n\n    return vertical_regions\n\ndef find_horizontal_regions(input_np):\n    \"\"\"Finds all horizontal regions defined by yellow markers.\"\"\"\n    rows, cols = input_np.shape\n    horizontal_regions = []\n\n    for r in range(rows):\n        yellow_indices = np.where(input_np[r, :] == 4)[0]\n        if len(yellow_indices) >= 2:\n            c_min = yellow_indices[0]\n            c_max = yellow_indices[-1]\n            \n            region_coords = []\n            region_colors = []\n            for c in range(c_min + 1, c_max):\n                region_coords.append((r, c))\n                region_colors.append(input_np[r, c])\n\n            if region_coords: # Only add if the region is not empty\n                 horizontal_regions.append({\n                     \"coords\": region_coords,\n                     \"colors\": region_colors\n                 })\n                 \n    return horizontal_regions\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformations based on yellow markers, prioritizing vertical rectangles.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    \n    # 1. Find and process Vertical Rectangular Regions\n    vertical_regions = find_vertical_rectangular_regions(input_np)\n    \n    if vertical_regions:\n        # If vertical regions are found, process them and return\n        for region in vertical_regions:\n            region_coords = region[\"coords\"]\n            region_colors = region[\"colors\"]\n            \n            contains_7_or_8 = any(color == 7 or color == 8 for color in region_colors)\n            contains_0_or_6 = any(color == 0 or color == 6 for color in region_colors)\n\n            if contains_7_or_8:\n                # Apply Transformation A to the output grid\n                output_grid = apply_transformation_a(output_grid, region_coords)\n            elif contains_0_or_6:\n                # Apply Transformation B to the output grid\n                output_grid = apply_transformation_b(output_grid, region_coords)\n                \n        return output_grid.tolist()\n\n    # 2. If NO vertical regions were found, find and process Horizontal Regions\n    horizontal_regions = find_horizontal_regions(input_np)\n    \n    if horizontal_regions:\n         # Process all found horizontal regions\n        for region in horizontal_regions:\n            region_coords = region[\"coords\"]\n            region_colors = region[\"colors\"]\n            \n            contains_7_or_8 = any(color == 7 or color == 8 for color in region_colors)\n            contains_0_or_6 = any(color == 0 or color == 6 for color in region_colors)\n\n            if contains_7_or_8:\n                 # Apply Transformation A to the output grid\n                output_grid = apply_transformation_a(output_grid, region_coords)\n            elif contains_0_or_6:\n                 # Apply Transformation B to the output grid\n                output_grid = apply_transformation_b(output_grid, region_coords)\n\n    # 3. Return the result (either from horizontal processing or the original if no regions found/transformed)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9130,
    "candidates_token_count": 2487,
    "total_token_count": 11617,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.872993,
  "retries": null
}