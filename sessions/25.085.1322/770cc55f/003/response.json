{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nTransformation Rule:\n1. Identify the single horizontal red line (color 2) and its row index (`red_line_row`).\n2. Identify the single color (`paired_color`) present that is neither white (0) nor red (2). Locate all pixels of this color, forming two objects: one above and one below the red line.\n3. Determine the set of column indices occupied by the object above the red line (`cols_above`).\n4. Determine the set of column indices occupied by the object below the red line (`cols_below`).\n5. Find the intersection of these two sets of column indices (`common_cols`).\n6. Determine the vertical placement of the yellow rectangle:\n    a. If `cols_above` is a proper subset of `cols_below`, place the rectangle below the red line.\n    b. Otherwise (if `cols_below` is a proper subset of `cols_above`, or if neither is a proper subset of the other), place the rectangle above the red line.\n7. Define the rectangle boundaries:\n    a. Horizontal: Spans the columns in `common_cols`.\n    b. Vertical: \n        i. If placed below: Starts at row `red_line_row + 1`, ends at the last row (`height - 1`).\n        ii. If placed above: Starts at row 0, ends at row `red_line_row - 1`.\n8. Create the output grid by copying the input grid.\n9. Fill the determined rectangle area in the output grid with yellow (color 4), but only overwrite existing white (color 0) pixels.\n\"\"\"\n\ndef find_colored_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all pixels of a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_object_columns(pixels: List[Tuple[int, int]]) -> Set[int]:\n    \"\"\"Gets the set of unique column indices from a list of pixel coordinates.\"\"\"\n    if not pixels:\n        return set()\n    return set(col for _, col in pixels)\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 1. Find the red line row\n    red_line_row = -1\n    for r in range(height):\n        # Check if any red pixel exists in the row as an indicator\n        if np.any(input_np[r, :] == 2):\n             # Verify all red pixels are ONLY on this row\n             red_rows, _ = np.where(input_np == 2)\n             if np.all(red_rows == r):\n                 red_line_row = r\n                 break\n             else:\n                 # Handle potential complex red structures if necessary,\n                 # but for now, assume the first row with red is the line if all red is on it.\n                 # If red exists on multiple rows, this logic might fail for unseen patterns.\n                 print(f\"Warning: Red pixels found on multiple rows. Using row {r} as the reference line.\")\n                 red_line_row = r\n                 break # Take the first occurrence as the line\n\n    # Check if red line indicator was found\n    if red_line_row == -1:\n        print(\"Error: Red line indicator (color 2) not found.\")\n        return input_grid # Return original if rule prerequisite is missing\n\n    # 2. Find the paired objects' color and pixels\n    paired_object_color = -1\n    all_paired_pixels = []\n    unique_colors = np.unique(input_np)\n    for color in unique_colors:\n        if color not in [0, 2]: # Exclude white and red\n            paired_object_color = color\n            all_paired_pixels = find_colored_pixels(input_np, paired_object_color)\n            break # Assume only one such color pair exists\n\n    if paired_object_color == -1:\n         print(\"Warning: Paired objects (non-white, non-red) not found.\")\n         return output_np.tolist() # Return unmodified copy if no objects to compare\n\n    # Separate pixels into above and below the red line\n    pixels_above = [p for p in all_paired_pixels if p[0] < red_line_row]\n    pixels_below = [p for p in all_paired_pixels if p[0] > red_line_row]\n\n    # 3. Get column indices for the object above\n    cols_above = get_object_columns(pixels_above)\n\n    # 4. Get column indices for the object below\n    cols_below = get_object_columns(pixels_below)\n\n    # 5. Find the intersection of column indices\n    common_cols = cols_above.intersection(cols_below)\n\n    # 6. Determine vertical placement based on subset relationship\n    place_above = True # Default placement\n    is_above_proper_subset_of_below = cols_above.issubset(cols_below) and cols_above != cols_below\n    \n    if is_above_proper_subset_of_below:\n        place_above = False # Place below only if 'above' shape fits strictly inside 'below' projection\n\n    # 7. Define the row range for the yellow rectangle\n    if place_above:\n        start_row = 0\n        end_row = red_line_row # Exclusive end (up to red_line_row - 1)\n    else: # place_below\n        start_row = red_line_row + 1\n        end_row = height # Exclusive end (up to height - 1)\n\n    # 8. & 9. Fill the yellow rectangle in the output grid (only on white pixels)\n    for r in range(start_row, end_row):\n        for c in common_cols:\n            # Ensure column index is within grid bounds (safety check)\n            if 0 <= c < width:\n                 # Only overwrite white pixels\n                 if output_np[r, c] == 0:\n                     output_np[r, c] = 4 # Yellow\n\n    # Convert the result back to a list of lists\n    output_grid = output_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8757,
    "candidates_token_count": 1526,
    "total_token_count": 10283,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.445202,
  "retries": null
}