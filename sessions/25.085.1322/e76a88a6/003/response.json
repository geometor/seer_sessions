{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a \"pattern\" object (defined by non-white, non-gray pixels) and multiple \"marker\" objects (contiguous solid rectangular blocks of gray pixels). \nIt verifies that the dimensions of the pattern's bounding box exactly match the dimensions of all marker blocks.\nIf the dimensions match, it creates the output grid by:\n1. Copying the input grid.\n2. Replacing each gray marker block area with a copy of the pattern object.\nThe original pattern remains in its position. If dimensions don't match or no pattern/markers are found, the original grid is returned.\n\"\"\"\n\ndef find_pattern_bbox_and_content(grid):\n    \"\"\"\n    Finds the bounding box, dimensions, and content of the pattern object.\n    The pattern consists of all pixels that are not white (0) or gray (5).\n    Returns (bbox, dims, content) or (None, None, None) if no pattern found.\n    bbox is (min_r, min_c, max_r, max_c).\n    dims is (height, width).\n    content is a numpy array of the pattern pixels.\n    \"\"\"\n    non_background_pixels = np.argwhere((grid != 0) & (grid != 5))\n    if non_background_pixels.size == 0:\n        return None, None, None # No pattern found\n\n    min_r = np.min(non_background_pixels[:, 0])\n    max_r = np.max(non_background_pixels[:, 0])\n    min_c = np.min(non_background_pixels[:, 1])\n    max_c = np.max(non_background_pixels[:, 1])\n\n    bbox = (min_r, min_c, max_r, max_c)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    dims = (height, width)\n    # Extract content based on bounding box\n    content = grid[min_r:max_r+1, min_c:max_c+1]\n\n    return bbox, dims, content\n\ndef find_contiguous_blocks(grid, color):\n    \"\"\"\n    Finds all contiguous, solid rectangular blocks of a specific color using BFS.\n    Returns a list of dictionaries, each containing 'bbox' (min_r, min_c, max_r, max_c)\n    and 'dims' (height, width).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    # Using a numpy array as a queue can be efficient for coordinates\n    q = np.array([], dtype=np.uint16).reshape(0,2) \n\n    for r_init in range(rows):\n        for c_init in range(cols):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r_init, c_init] == color and not visited[r_init, c_init]:\n                # Initialize queue and visited status for the new component\n                q = np.vstack([q, [r_init, c_init]])\n                visited[r_init, c_init] = True\n                component_pixels_count = 0\n                min_r_block, max_r_block = r_init, r_init\n                min_c_block, max_c_block = c_init, c_init\n\n                head = 0\n                while head < len(q):\n                    r, c = q[head]\n                    head += 1\n                    component_pixels_count += 1\n                    # Update bounding box coordinates\n                    min_r_block = min(min_r_block, r)\n                    max_r_block = max(max_r_block, r)\n                    min_c_block = min(min_c_block, c)\n                    max_c_block = max(max_c_block, c)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            # Add valid neighbor to the queue\n                            q = np.vstack([q, [nr, nc]])\n                \n                # Reset queue for the next potential component\n                q = np.array([], dtype=np.uint16).reshape(0,2) \n\n                # Calculate potential dimensions from bounding box\n                height = max_r_block - min_r_block + 1\n                width = max_c_block - min_c_block + 1\n\n                # Verify if the found component is a solid rectangle\n                is_solid_rectangle = True\n                # Check 1: Does the number of pixels found match the area of the bounding box?\n                if component_pixels_count != height * width:\n                     is_solid_rectangle = False\n                else:\n                    # Check 2: Are all pixels *within* the bounding box of the correct color?\n                    # This ensures no holes or intrusions of other colors within the bbox.\n                    block_slice = grid[min_r_block:max_r_block + 1, min_c_block:max_c_block + 1]\n                    if not np.all(block_slice == color):\n                        is_solid_rectangle = False\n\n                # If it's a solid rectangle, add its details to the list\n                if is_solid_rectangle:\n                    bbox = (min_r_block, min_c_block, max_r_block, max_c_block)\n                    dims = (height, width)\n                    blocks.append({'bbox': bbox, 'dims': dims})\n    return blocks\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Copy pattern to gray markers of the same size.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Identify the pattern object (non-white, non-gray pixels)\n    pattern_bbox, pattern_dims, pattern_content = find_pattern_bbox_and_content(input_grid_np)\n    \n    # If no pattern is found, return the original grid\n    if pattern_bbox is None:\n        return input_grid \n\n    # 2. Identify the gray marker blocks (solid gray rectangles)\n    marker_color = 5\n    markers = find_contiguous_blocks(input_grid_np, marker_color)\n\n    # If no markers are found, return the original grid\n    if not markers:\n         return input_grid \n\n    # 3. Check if pattern dimensions match all marker dimensions\n    pattern_h, pattern_w = pattern_dims\n    all_markers_match = True\n    for marker in markers:\n        marker_h, marker_w = marker['dims']\n        if pattern_h != marker_h or pattern_w != marker_w:\n            all_markers_match = False\n            break\n            \n    # If dimensions don't match, return the original grid\n    if not all_markers_match:\n        return input_grid \n\n    # 4. Initialize the output grid as a copy of the input grid\n    # This preserves the original pattern by default\n    output_grid = np.copy(input_grid_np)\n\n    # 5. Replace each marker area with the pattern content\n    for marker in markers:\n        m_min_r, m_min_c, m_max_r, m_max_c = marker['bbox']\n        # Check shape consistency before assignment (should always pass if dim check passed)\n        if output_grid[m_min_r:m_max_r+1, m_min_c:m_max_c+1].shape == pattern_content.shape:\n             output_grid[m_min_r:m_max_r+1, m_min_c:m_max_c+1] = pattern_content\n        else:\n            # This case indicates an unexpected issue, log it if necessary\n            # print(f\"Warning: Shape mismatch during copy despite dimension check. Marker shape: {(m_max_r-m_min_r+1, m_max_c-m_min_c+1)}, Pattern shape: {pattern_content.shape}\")\n            pass # Continue processing other markers\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7576,
    "candidates_token_count": 2029,
    "total_token_count": 9605,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.388955,
  "retries": null
}