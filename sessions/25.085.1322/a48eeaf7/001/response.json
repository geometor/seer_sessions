{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the largest contiguous non-background object (target) and smaller \nnon-background objects (movers). The target object remains stationary. Each mover \nobject moves towards the closest point on the target object, one step at a time \n(prioritizing diagonal moves), until it reaches a position adjacent (including \ndiagonals) to any part of the target object. The final output grid contains the \nstationary target and the movers in their final adjacent positions.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color value to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'pixels' (list of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n\n                    # Check neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n    return objects\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef get_closest_pixels(source_pixels, target_pixels):\n    \"\"\"\n    Finds the pair of pixels (one from source, one from target) with the minimum\n    Manhattan distance. If multiple pairs have the same minimum distance, it returns\n    the first pair found.\n\n    Args:\n        source_pixels (list): List of (row, col) tuples for the source object.\n        target_pixels (list): List of (row, col) tuples for the target object.\n\n    Returns:\n        tuple: A tuple containing (closest_source_pixel, closest_target_pixel, min_dist).\n               Returns (None, None, float('inf')) if either list is empty.\n    \"\"\"\n    if not source_pixels or not target_pixels:\n        return None, None, float('inf')\n\n    min_dist = float('inf')\n    closest_source = None\n    closest_target = None\n\n    for sp in source_pixels:\n        for tp in target_pixels:\n            dist = manhattan_distance(sp, tp)\n            if dist < min_dist:\n                min_dist = dist\n                closest_source = sp\n                closest_target = tp\n    \n    return closest_source, closest_target, min_dist\n\n\ndef is_adjacent(p1, target_pixels):\n    \"\"\"Checks if p1 is adjacent (including diagonals) to any pixel in target_pixels.\"\"\"\n    r1, c1 = p1\n    for r2, c2 in target_pixels:\n        if abs(r1 - r2) <= 1 and abs(c1 - c2) <= 1 and (r1, c1) != (r2, c2):\n            return True\n    return False\n\ndef move_towards(current_pos, target_pos):\n    \"\"\"Calculates the next single step position towards the target position.\"\"\"\n    r, c = current_pos\n    tr, tc = target_pos\n    \n    step_r = np.sign(tr - r)\n    step_c = np.sign(tc - c)\n    \n    next_r = r + step_r\n    next_c = c + step_c\n    \n    return (next_r, next_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the identified rules.\n    - Finds the largest object (target) and other objects (movers).\n    - Moves each mover towards the target until adjacent.\n    - Returns the grid with the target in place and movers in final positions.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # Initialize output grid with background color (white=0)\n    output_grid = np.zeros_like(input_array)\n\n    # Find all non-background objects\n    all_objects = find_objects(input_array, ignore_color=0)\n\n    if not all_objects:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # Identify the target object (largest by pixel count)\n    target_object = max(all_objects, key=lambda obj: len(obj['pixels']), default=None)\n    \n    if not target_object:\n         return output_grid.tolist() # Should not happen if all_objects is not empty, but safety check\n\n    target_pixels = target_object['pixels']\n    \n    # Place the target object in the output grid\n    for r, c in target_pixels:\n        output_grid[r, c] = target_object['color']\n\n    # Identify mover objects\n    mover_objects = [obj for obj in all_objects if obj != target_object]\n\n    # Process each mover object\n    for mover in mover_objects:\n        mover_color = mover['color']\n        # For simplicity based on examples, assume movers are single pixels. \n        # If multi-pixel movers exist, this needs adjustment. \n        # We'll use the concept of the 'closest point' on the mover to the target.\n        current_pixels = list(mover['pixels']) # Make a mutable copy\n        \n        while True:\n            # Check if *any* part of the mover is adjacent to the target\n            is_already_adjacent = False\n            for mp in current_pixels:\n                if is_adjacent(mp, target_pixels):\n                    is_already_adjacent = True\n                    break\n            if is_already_adjacent:\n                break # Mover (or part of it) has reached the target adjacency\n\n            # Find the closest point *on the mover* to *any point on the target*\n            closest_mover_pixel, closest_target_pixel, dist = get_closest_pixels(current_pixels, target_pixels)\n            \n            if closest_mover_pixel is None: # Should not happen if target exists\n                break \n\n            # Calculate the single step for the *entire object* based on the closest point\n            # This assumes rigid movement of the mover object.\n            # Find the reference point for movement (e.g., the closest_mover_pixel)\n            ref_r, ref_c = closest_mover_pixel\n            target_r, target_c = closest_target_pixel\n            \n            # Determine the step direction\n            step_r = np.sign(target_r - ref_r)\n            step_c = np.sign(target_c - ref_c)\n\n            # Calculate new positions for all pixels in the mover object\n            next_pixels = []\n            valid_move = True\n            for r, c in current_pixels:\n                nr, nc = r + step_r, c + step_c\n                # Basic boundary check - can add collision checks later if needed\n                if not (0 <= nr < rows and 0 <= nc < cols):\n                    valid_move = False\n                    break # Cannot move object if any part goes out of bounds\n                next_pixels.append((nr, nc))\n            \n            if not valid_move:\n                 # If move is invalid (e.g., out of bounds), stop moving this object.\n                 # It remains in its current position before the invalid move attempt.\n                 break\n\n            # Update current position if move was valid\n            current_pixels = next_pixels\n\n            # Safety break to prevent infinite loops in unexpected scenarios\n            if dist == 0: # Should technically be handled by adjacency check, but good fallback\n                 break\n            if step_r == 0 and step_c == 0: # No move possible towards target\n                 break\n\n\n        # Place the mover object at its final position in the output grid\n        for r, c in current_pixels:\n             # Ensure final placement is within bounds (should be guaranteed by move logic)\n             if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = mover_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3487,
    "candidates_token_count": 2138,
    "total_token_count": 5625,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.492927,
  "retries": null
}