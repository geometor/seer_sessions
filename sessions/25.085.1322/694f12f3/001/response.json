{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies solid rectangular objects of any non-background color in the input grid.\nFor each such rectangle with both width and height greater than 2, it modifies the rectangle \nin the output grid:\n1. The one-pixel-thick border of the rectangle retains its original color.\n2. The interior pixels of the rectangle are filled with a new color determined by the \n   width of the interior region (interior_width = rectangle_width - 2).\n3. If interior_width > 2, the fill color is red (2).\n4. Otherwise (if interior_width <= 2), the fill color is blue (1).\nRectangles with width or height <= 2, or objects that are not solid rectangles, remain unchanged.\nThe background (color 0) also remains unchanged.\n\"\"\"\n\ndef find_all_objects(grid):\n    \"\"\"\n    Finds all connected objects (groups of same-colored pixels)\n    that are not the background color (0).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, set_of_pixels).\n              set_of_pixels contains (row, col) tuples for the object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find an unvisited non-background pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object (color and its pixel coordinates)\n                if obj_pixels: \n                    objects.append((color, obj_pixels))\n\n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    # Find the min/max row and column indices from the pixel coordinates\n    min_row = min(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n    return (min_row, min_col, max_row, max_col)\n\ndef is_solid_rectangle(pixels, bbox):\n    \"\"\"\n    Checks if the object's pixels perfectly fill its bounding box.\n\n    Args:\n        pixels (set): A set of (row, col) tuples for the object.\n        bbox (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        bool: True if it's a solid rectangle, False otherwise.\n    \"\"\"\n    if not bbox or not pixels:\n        return False\n    min_row, min_col, max_row, max_col = bbox\n    # Calculate the expected number of pixels in a solid rectangle of this size\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n    expected_pixels = width * height\n    # Compare with the actual number of pixels in the object\n    return len(pixels) == expected_pixels\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies solid rectangles, determines interior fill color based on interior width, \n    and modifies the interior while preserving the border.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all non-background objects in the input grid\n    objects = find_all_objects(input_grid)\n\n    # Process each found object\n    for color, pixels in objects:\n        # Calculate the bounding box of the current object\n        bbox = get_bounding_box(pixels)\n        if not bbox:\n            continue\n\n        # Check if the object is a solid rectangle\n        if is_solid_rectangle(pixels, bbox):\n            min_row, min_col, max_row, max_col = bbox\n            width = max_col - min_col + 1\n            height = max_row - min_row + 1\n\n            # Check if the rectangle is large enough to have an interior\n            if width > 2 and height > 2:\n                # Calculate the width of the interior region\n                interior_width = width - 2\n                \n                # Determine the fill color based on the interior width\n                # Red (2) if interior_width > 2, Blue (1) otherwise\n                fill_color = 2 if interior_width > 2 else 1\n\n                # Iterate through the interior pixels and update the output grid\n                for r in range(min_row + 1, max_row):\n                    for c in range(min_col + 1, max_col):\n                        output_grid[r, c] = fill_color\n                # Border pixels automatically remain unchanged as we only modified the interior\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3026,
    "candidates_token_count": 1443,
    "total_token_count": 4469,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.954231,
  "retries": null
}