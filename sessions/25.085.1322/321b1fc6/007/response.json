{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Initialize an empty output grid with the same dimensions as the input grid, filled with the background color (white, 0).\n2. Identify all pixels in the input grid whose color is *not* white (0) and *not* azure (8). These are the 'source pixels'.\n3. If no source pixels are found, return the initial empty output grid.\n4. Determine the minimum bounding box that encloses *all* identified source pixels. Find the minimum row (`min_r`), minimum column (`min_c`), maximum row (`max_r`), and maximum column (`max_c`) among all source pixels.\n5. Create the 'composite template' pattern:\n    a. Create a new grid (the template) with height `max_r - min_r + 1` and width `max_c - min_c + 1`, initially filled with the background color (white, 0).\n    b. Iterate through all the original source pixels identified in step 2. For each source pixel at coordinate (`r`, `c`) with color `col`, set the pixel at `(r - min_r, c - min_c)` in the template grid to `col`.\n6. Identify all distinct connected groups of azure (8) pixels in the input grid. These are the 'markers'.\n7. If no markers are found, return the initial empty output grid.\n8. For each identified marker:\n    a. Determine the coordinate (row, column) of its top-leftmost pixel. This is the 'stamp location'.\n    b. Copy ('stamp') the 'composite template' onto the output grid, aligning the template's top-left corner with the 'stamp location'.\n    c. Pixels from the template (other than the background color 0) overwrite the corresponding pixels in the output grid. Ensure the template is clipped if it extends beyond the output grid's boundaries.\n9. Return the final modified output grid.\n\"\"\"\n\n\n# Helper function to find connected components (corrected version)\ndef find_connected_components_no_scipy(grid, target_colors=None):\n    \"\"\"\n    Finds all connected components for specified colors or all non-background colors\n    using BFS, without relying on scipy.\n\n    Args:\n        grid (np.array): The input grid.\n        target_colors (list or set, optional): A collection of integer colors\n            to find objects for. If None, finds objects for all colors except 0.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (r, c) tuples),\n              'bbox' (tuple: (min_r, min_c, max_r, max_c)), 'top_left' (r, c).\n              Returns empty list if no objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    valid_target_colors = set()\n    if target_colors is None:\n        present_colors = np.unique(grid)\n        valid_target_colors = {c for c in present_colors if c != 0}\n    else:\n        valid_target_colors = set(target_colors)\n\n    if not valid_target_colors:\n        return objects # Return empty list if no valid colors to search for\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in valid_target_colors and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                if component_pixels:\n                    objects.append({\n                        'color': color,\n                        'pixels': component_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'top_left': (min_r, min_c)\n                    })\n\n    # Sort objects only if there are objects to sort\n    if objects:\n        objects.sort(key=lambda o: (o['top_left'][0], o['top_left'][1]))\n    return objects\n\n# Helper function to stamp a pattern onto the grid (reused)\ndef stamp_pattern(output_grid, pattern, top_left_coord):\n    \"\"\"\n    Overlays the non-background pixels of the pattern onto the output grid\n    at the specified coordinate, handling clipping.\n    \"\"\"\n    r_start, c_start = top_left_coord\n    p_h, p_w = pattern.shape\n    g_h, g_w = output_grid.shape\n\n    # Calculate the intersection bounds for stamping\n    r_end = min(r_start + p_h, g_h)\n    c_end = min(c_start + p_w, g_w)\n\n    # Adjust start coordinates if they are negative (shouldn't happen often with valid markers, but defensive)\n    p_r_offset = 0\n    p_c_offset = 0\n    if r_start < 0:\n        p_r_offset = -r_start\n        r_start = 0\n    if c_start < 0:\n        p_c_offset = -c_start\n        c_start = 0\n\n    # Calculate slices for pattern and grid based on intersection and potential negative offset\n    p_r_slice = slice(p_r_offset, p_r_offset + (r_end - r_start))\n    p_c_slice = slice(p_c_offset, p_c_offset + (c_end - c_start))\n    g_r_slice = slice(r_start, r_end)\n    g_c_slice = slice(c_start, c_end)\n\n    # Ensure slices are valid (have positive range) and dimensions match before assignment\n    if g_r_slice.start < g_r_slice.stop and g_c_slice.start < g_c_slice.stop and \\\n       (p_r_slice.stop - p_r_slice.start) == (g_r_slice.stop - g_r_slice.start) and \\\n       (p_c_slice.stop - p_c_slice.start) == (g_c_slice.stop - g_c_slice.start):\n\n        # Get the relevant slice of the pattern\n        pattern_slice = pattern[p_r_slice, p_c_slice]\n        # Create a mask for non-zero (non-background) pixels in the pattern slice\n        mask = pattern_slice != 0\n\n        # Apply the pattern slice to the output grid using the mask\n        # This ensures only non-background parts of the template overwrite the output\n        output_grid[g_r_slice, g_c_slice][mask] = pattern_slice[mask]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by creating a composite template from all non-background,\n    non-marker pixels and stamping it at locations indicated by marker pixels.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Initialize output_grid\n    output_grid = np.zeros_like(input_grid_np) # Filled with background (0)\n\n    # Define marker and background colors\n    marker_color = 8\n    background_color = 0\n\n    # 2. Identify source pixels (not background, not marker)\n    source_mask = (input_grid_np != background_color) & (input_grid_np != marker_color)\n    source_rows, source_cols = np.where(source_mask)\n    source_pixels = list(zip(source_rows, source_cols))\n\n    # 3. If no source pixels, return the initial white grid\n    if not source_pixels:\n        return output_grid.tolist()\n\n    # 4. Determine the combined bounding box for source pixels\n    min_r = np.min(source_rows)\n    min_c = np.min(source_cols)\n    max_r = np.max(source_rows)\n    max_c = np.max(source_cols)\n\n    # 5. Create the 'composite template' pattern\n    template_h = max_r - min_r + 1\n    template_w = max_c - min_c + 1\n    composite_template = np.zeros((template_h, template_w), dtype=int)\n\n    # 5b. Populate the template\n    for r, c in source_pixels:\n        color = input_grid_np[r, c]\n        composite_template[r - min_r, c - min_c] = color\n\n    # 6. Find marker objects (color 8)\n    marker_objects = find_connected_components_no_scipy(input_grid_np, target_colors=[marker_color])\n\n    # 7. If no markers, return the initial white grid\n    if not marker_objects:\n        return output_grid.tolist()\n\n    # 8. Stamp the template for each marker\n    for marker in marker_objects:\n        stamp_location = marker['top_left'] # Get the top-left coordinate\n        # 8b & 8c. Stamp the template using the helper function\n        stamp_pattern(output_grid, composite_template, stamp_location)\n\n    # 9. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6683,
            "end_index": 6986,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10887,
    "candidates_token_count": 2438,
    "total_token_count": 13325,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.714998,
  "retries": null
}