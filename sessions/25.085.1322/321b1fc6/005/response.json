{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Initialize an output grid of the same dimensions as the input grid, filled entirely with the background color (white, 0).\n2. Identify all distinct connected groups of azure (8) pixels in the input grid. These are the 'markers'. If no markers are found, return the initial white output grid.\n3. Identify all distinct connected groups of pixels whose color is *not* white (0) and *not* azure (8). These are the 'source components'.\n4. If no source components are found, return the initial white output grid.\n5. Determine the single 'template pattern':\n    a. Find the source component whose top-left corner coordinate has the minimum row index.\n    b. If multiple source components share the minimum row index, select the one among them with the minimum column index. This is the 'primary source component'.\n    c. Extract the shape of this primary source component within its own bounding box (treating pixels outside the component but within the box as background/white 0). This extracted shape is the 'template pattern'.\n6. For each identified marker:\n    a. Determine the coordinate (row, column) of its top-leftmost pixel.\n    b. Copy ('stamp') the determined 'template pattern' onto the output grid, aligning the template's top-left corner with the marker's top-left coordinate.\n    c. Ensure the template pattern is clipped if it extends beyond the output grid's boundaries during stamping. Pixels from the template overwrite the corresponding pixels in the output grid.\n7. Return the final modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# Helper function to find connected components without scipy\ndef find_connected_components_no_scipy(grid, target_colors=None):\n    \"\"\"\n    Finds all connected components for specified colors or all non-background colors\n    using BFS, without relying on scipy.\n\n    Args:\n        grid (np.array): The input grid.\n        target_colors (list or set, optional): A collection of integer colors\n            to find objects for. If None, finds objects for all colors except 0.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (r, c) tuples),\n              'bbox' (tuple: (min_r, min_c, max_r, max_c)), 'top_left' (r, c).\n              Returns empty list if no objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    if target_colors is None:\n        colors_present = np.unique(grid)\n        target_colors = [c for c in colors_present if c != 0]\n    if not target_colors:\n        return objects\n\n    target_colors_set = set(target_colors) # Faster lookup\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in target_colors_set and not visited[r, c]:\n                # Start BFS for a new component\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds, color match, and visited status\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                if component_pixels:\n                    objects.append({\n                        'color': color,\n                        'pixels': component_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'top_left': (min_r, min_c)\n                    })\n\n    # Sort objects primarily by top-left row, then column for consistent ordering\n    objects.sort(key=lambda o: (o['top_left'][0], o['top_left'][1]))\n    return objects\n\n# Helper function to get the relative pattern of a component\ndef get_relative_pattern(component):\n    \"\"\"\n    Extracts the relative pattern of a component within its bounding box.\n    \"\"\"\n    color = component['color']\n    pixels = component['pixels']\n    min_r, min_c, max_r, max_c = component['bbox']\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    relative_pattern = np.zeros((height, width), dtype=int) # Use int type\n\n    for r, c in pixels:\n        relative_pattern[r - min_r, c - min_c] = color\n\n    return relative_pattern\n\n# Helper function to stamp a pattern onto the grid\ndef stamp_pattern(output_grid, pattern, top_left_coord):\n    \"\"\"\n    Overlays the pattern onto the output grid at the specified coordinate,\n    handling clipping.\n    \"\"\"\n    r_start, c_start = top_left_coord\n    p_h, p_w = pattern.shape\n    g_h, g_w = output_grid.shape\n\n    # Calculate the intersection bounds for stamping\n    r_end = min(r_start + p_h, g_h)\n    c_end = min(c_start + p_w, g_w)\n\n    # Adjust start coordinates if they are negative (shouldn't happen with valid markers, but defensive)\n    p_r_offset = 0\n    p_c_offset = 0\n    if r_start < 0:\n        p_r_offset = -r_start\n        r_start = 0\n    if c_start < 0:\n        p_c_offset = -c_start\n        c_start = 0\n        \n    # Calculate slices for pattern and grid based on intersection and potential negative offset\n    p_r_slice = slice(p_r_offset, p_r_offset + (r_end - r_start))\n    p_c_slice = slice(p_c_offset, p_c_offset + (c_end - c_start))\n    g_r_slice = slice(r_start, r_end)\n    g_c_slice = slice(c_start, c_end)\n    \n    # Ensure slices are valid (have positive range) before attempting assignment\n    # Also check if the calculated pattern slice dimensions match the grid slice dimensions\n    if g_r_slice.start < g_r_slice.stop and g_c_slice.start < g_c_slice.stop and \\\n       (p_r_slice.stop - p_r_slice.start) == (g_r_slice.stop - g_r_slice.start) and \\\n       (p_c_slice.stop - p_c_slice.start) == (g_c_slice.stop - g_c_slice.start):\n       \n        # Create a mask for non-zero pixels in the pattern slice\n        pattern_slice = pattern[p_r_slice, p_c_slice]\n        mask = pattern_slice != 0 \n        \n        # Apply the pattern slice to the output grid using the mask\n        output_grid[g_r_slice, g_c_slice][mask] = pattern_slice[mask]\n\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Initialize output_grid\n    output_grid = np.zeros_like(input_grid_np) # Filled with white (0)\n\n    # 2. Find marker objects (color 8)\n    marker_color = 8\n    marker_objects = find_connected_components_no_scipy(input_grid_np, target_colors=[marker_color])\n\n    # If no markers, return the initial white grid\n    if not marker_objects:\n        return output_grid.tolist()\n\n    # 3. Find source objects (all colors except 0 and 8)\n    all_colors = np.unique(input_grid_np)\n    source_colors = [c for c in all_colors if c != 0 and c != marker_color]\n    source_objects = find_connected_components_no_scipy(input_grid_np, target_colors=source_colors)\n\n    # 4. If no source objects, return the initial white grid\n    if not source_objects:\n        return output_grid.tolist()\n\n    # 5. Determine the template pattern\n    # Objects are already sorted by top-left row, then column by find_connected_components\n    primary_source_component = source_objects[0]\n    template = get_relative_pattern(primary_source_component)\n\n    # 6. Stamp the template for each marker\n    for marker in marker_objects:\n        marker_tl = marker['top_left']\n        stamp_pattern(output_grid, template, marker_tl)\n\n    # 7. Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5282,
    "candidates_token_count": 2299,
    "total_token_count": 7581,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.519477,
  "retries": null
}