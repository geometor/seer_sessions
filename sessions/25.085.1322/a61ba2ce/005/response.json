{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies four 3-pixel L-shaped objects in the input grid.\nExtracts the 2x2 pattern defined by each object's bounding box.\nDetermines the spatial quadrant (InTL, InTR, InBL, InBR) of each object based on its bounding box center relative to the input grid's center lines.\nChecks if the bounding box of the object in the InTL quadrant OR the object in the InTR quadrant crosses the input grid's vertical center line (crossing: min_col <= floor((W-1)/2) AND max_col >= floor((W-1)/2) + 1).\nConstructs a 4x4 output grid by placing the patterns:\n  - Pattern from InBL object goes to output BL.\n  - Pattern from InBR object goes to output BR.\n  - If the crossing condition is true, pattern from InTR goes to output TL, and pattern from InTL goes to output TR.\n  - If the crossing condition is false, pattern from InTL goes to output TL, and pattern from InTR goes to output TR.\n\"\"\"\n\ndef find_l_objects(grid):\n    \"\"\"\n    Finds all contiguous 3-pixel L-shaped objects of non-background colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an L-shaped object with keys:\n              'color': The color of the object's pixels.\n              'pixels': A list of (row, col) coordinates of the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col) of the bounding box (should be 2x2).\n              'pattern': A 2x2 numpy array of the pattern within the bbox.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                q = [(r, c)]\n                visited[r, c] = True\n                component_pixels = []\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Use BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.pop(0)\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Check if the found component is an L-shape (3 pixels and 2x2 bbox)\n                if len(component_pixels) == 3 and (max_r - min_r == 1) and (max_c - min_c == 1):\n                    bbox = (min_r, min_c, max_r, max_c)\n                    # Extract the 2x2 pattern directly using the bounding box\n                    pattern = grid[min_r:min_r+2, min_c:min_c+2].copy() # Use copy to avoid view issues\n\n                    # Should always be 2x2 for valid L, but defensive check is ok\n                    if pattern.shape != (2, 2):\n                         # This case should ideally not happen for valid L-shapes\n                         print(f\"Warning: Pattern shape incorrect {pattern.shape} for bbox {bbox}. Padding.\")\n                         padded_pattern = np.zeros((2, 2), dtype=int)\n                         rows_p, cols_p = pattern.shape\n                         padded_pattern[0:rows_p, 0:cols_p] = pattern\n                         pattern = padded_pattern\n\n                    objects.append({\n                        'color': color,\n                        'pixels': component_pixels,\n                        'bbox': bbox,\n                        'pattern': pattern # Keep as numpy array\n                    })\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying four L-shaped objects, determining\n    their spatial quadrants, checking a midline crossing condition, and assembling\n    their 2x2 patterns into a 4x4 output grid with a potential swap of the top quadrants.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify the four L-shaped objects and their patterns\n    objects = find_l_objects(input_grid_np)\n\n    # Ensure exactly four objects are found\n    if len(objects) != 4:\n        print(f\"Warning: Expected 4 L-shaped objects, but found {len(objects)}. Returning default grid.\")\n        return np.zeros((4, 4), dtype=int).tolist()\n\n    # 2. Determine the input grid center lines coordinates\n    center_row_coord = (height - 1) / 2.0\n    center_col_coord = (width - 1) / 2.0\n\n    # 3. Classify objects by input quadrant based on bounding box center\n    objects_by_quadrant = {'InTL': None, 'InTR': None, 'InBL': None, 'InBR': None}\n    quadrant_assignment_count = 0\n    for obj in objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        bbox_center_r = (min_r + max_r) / 2.0\n        bbox_center_c = (min_c + max_c) / 2.0\n\n        quadrant = \"\"\n        if bbox_center_r < center_row_coord: # Top half\n            quadrant += \"InT\"\n        else: # Bottom half (including exact center line)\n             quadrant += \"InB\"\n\n        if bbox_center_c < center_col_coord: # Left half\n            quadrant += \"L\"\n        else: # Right half (including exact center line)\n            quadrant += \"R\"\n\n        if quadrant in objects_by_quadrant and objects_by_quadrant[quadrant] is None:\n            objects_by_quadrant[quadrant] = obj\n            quadrant_assignment_count += 1\n        else:\n            # Handle error: multiple objects in one quadrant or invalid quadrant\n            print(f\"Warning: Quadrant assignment issue for object at bbox {obj['bbox']} -> quadrant {quadrant}. Existing: {objects_by_quadrant[quadrant] is not None}\")\n            return np.zeros((4, 4), dtype=int).tolist() # Return default grid on error\n\n    # Check if all quadrants were assigned exactly one object\n    if quadrant_assignment_count != 4:\n         print(f\"Warning: Not all quadrants assigned correctly. Count: {quadrant_assignment_count}. Returning default grid.\")\n         return np.zeros((4, 4), dtype=int).tolist()\n\n    # 4. Check the swap condition based on vertical midline crossing\n    vertical_center_col_idx = (width - 1) // 2\n    vertical_center_col_idx_plus_1 = vertical_center_col_idx + 1\n\n    swap_top_quadrants = False\n    obj_intl = objects_by_quadrant['InTL']\n    obj_intr = objects_by_quadrant['InTR']\n\n    # Check if InTL object's bbox crosses the vertical center line\n    bbox_intl = obj_intl['bbox']\n    if bbox_intl[1] <= vertical_center_col_idx and bbox_intl[3] >= vertical_center_col_idx_plus_1:\n        swap_top_quadrants = True\n\n    # Check if InTR object's bbox crosses the vertical center line (only need one to cross)\n    if not swap_top_quadrants:\n        bbox_intr = obj_intr['bbox']\n        if bbox_intr[1] <= vertical_center_col_idx and bbox_intr[3] >= vertical_center_col_idx_plus_1:\n            swap_top_quadrants = True\n\n    # 5. Construct the 4x4 output grid\n    output_grid = np.zeros((4, 4), dtype=int)\n\n    # Place bottom patterns (fixed relative to spatial input quadrant)\n    output_grid[2:4, 0:2] = objects_by_quadrant['InBL']['pattern']\n    output_grid[2:4, 2:4] = objects_by_quadrant['InBR']['pattern']\n\n    # Place top patterns based on swap condition\n    if swap_top_quadrants:\n        # Swap: InTR pattern goes to OutTL, InTL pattern goes to OutTR\n        output_grid[0:2, 0:2] = obj_intr['pattern']\n        output_grid[0:2, 2:4] = obj_intl['pattern']\n    else:\n        # No swap: InTL pattern goes to OutTL, InTR pattern goes to OutTR\n        output_grid[0:2, 0:2] = obj_intl['pattern']\n        output_grid[0:2, 2:4] = obj_intr['pattern']\n\n    # 6. Return as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7776,
    "candidates_token_count": 2304,
    "total_token_count": 10080,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.011393,
  "retries": null
}