{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies four distinct L-shaped objects (3 pixels) in the input grid.\nDetermines the 2x2 pattern for each object based on its bounding box.\nAssigns each object to a quadrant (Top-Left, Top-Right, Bottom-Left, Bottom-Right) based on its center of mass relative to the input grid's center.\nChecks if either of the objects assigned to the top quadrants has a bounding box that crosses the input grid's vertical center line.\nConstructs a 4x4 output grid by placing the 2x2 patterns into corresponding 2x2 sections of the output.\nIf the crossing condition is met, the patterns for the top-left and top-right quadrants are swapped in the output grid. Otherwise, they maintain their relative positions.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'color': The color of the object's pixels.\n              'pixels': A list of (row, col) coordinates of the object's pixels.\n              'bbox': A tuple (min_row, min_col, max_row, max_col) of the bounding box.\n              'center_of_mass': A tuple (avg_row, avg_col) of the object's center.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                sum_r, sum_c = 0, 0\n\n                while q:\n                    row, col = q.pop(0)\n                    pixels.append((row, col))\n                    sum_r += row\n                    sum_c += col\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                center_of_mass = (sum_r / len(pixels), sum_c / len(pixels))\n                bbox = (min_r, min_c, max_r, max_c)\n                objects.append({\n                    'color': color,\n                    'pixels': pixels,\n                    'bbox': bbox,\n                    'center_of_mass': center_of_mass\n                })\n    return objects\n\ndef get_object_pattern(grid, bbox):\n    \"\"\"\n    Extracts the 2x2 pattern of an object starting from its bounding box top-left.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        bbox (tuple): The object's bounding box (min_r, min_c, max_r, max_col).\n\n    Returns:\n        np.ndarray: A 2x2 numpy array representing the pattern.\n    \"\"\"\n    min_r, min_c, _, _ = bbox\n    height, width = grid.shape\n    pattern = np.zeros((2, 2), dtype=int) # Default background color 0\n    \n    obj_color = 0\n    # Find the object's color by checking the first non-zero pixel within the bbox area\n    # This assumes the object exists within the 2x2 area starting at bbox top-left\n    for r_offset in range(2):\n        for c_offset in range(2):\n             r, c = min_r + r_offset, min_c + c_offset\n             if 0 <= r < height and 0 <= c < width and grid[r,c] != 0:\n                 obj_color = grid[r,c]\n                 break\n        if obj_color != 0:\n            break\n            \n    # Fill the pattern grid\n    for r_offset in range(2):\n        for c_offset in range(2):\n            r, c = min_r + r_offset, min_c + c_offset\n            # Check if the coordinate is within grid bounds and belongs to the object\n            if 0 <= r < height and 0 <= c < width and grid[r, c] == obj_color:\n                 pattern[r_offset, c_offset] = grid[r, c]\n\n    return pattern\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on object identification, quadrant assignment,\n    and a potential swap condition for the top quadrants.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    height, width = input_grid_np.shape\n    center_row = height // 2\n    center_col = width // 2\n\n    # 1. Identify Objects\n    objects = find_objects(input_grid_np)\n\n    if len(objects) != 4:\n        # Handle error case or unexpected input - returning empty for now\n        return np.zeros((4, 4), dtype=int)\n\n    # 2. Characterize Objects and Assign Quadrants\n    quadrant_patterns = {}\n    quadrant_bboxes = {} # Store bboxes for swap check\n\n    for obj in objects:\n        com_r, com_c = obj['center_of_mass']\n        bbox = obj['bbox']\n        pattern = get_object_pattern(input_grid_np, bbox)\n\n        quadrant = \"\"\n        if com_r < center_row:\n            quadrant += \"T\"\n        else:\n            quadrant += \"B\"\n        if com_c < center_col:\n            quadrant += \"L\"\n        else:\n            quadrant += \"R\"\n\n        quadrant_patterns[quadrant] = pattern\n        quadrant_bboxes[quadrant] = bbox\n\n    # 3. Check Swap Condition\n    swap_top_quadrants = False\n    # Ensure TL and TR objects were found before checking their bboxes\n    if 'TL' in quadrant_bboxes and 'TR' in quadrant_bboxes:\n        tl_bbox = quadrant_bboxes['TL']\n        tr_bbox = quadrant_bboxes['TR']\n        # Check if TL bbox crosses the center column\n        if tl_bbox[1] < center_col and tl_bbox[3] >= center_col:\n            swap_top_quadrants = True\n        # Check if TR bbox crosses the center column\n        if tr_bbox[1] < center_col and tr_bbox[3] >= center_col:\n            swap_top_quadrants = True\n            \n    # Check if all quadrants are present before assembling\n    required_quadrants = {'TL', 'TR', 'BL', 'BR'}\n    if not required_quadrants.issubset(quadrant_patterns.keys()):\n         # Handle error case: not all quadrants found\n         print(f\"Warning: Missing quadrants. Found: {quadrant_patterns.keys()}\")\n         return np.zeros((4, 4), dtype=int)\n\n\n    # 4. Construct Output\n    output_grid = np.zeros((4, 4), dtype=int)\n\n    # Place bottom quadrants\n    output_grid[2:4, 0:2] = quadrant_patterns['BL']\n    output_grid[2:4, 2:4] = quadrant_patterns['BR']\n\n    # Place top quadrants based on swap condition\n    if swap_top_quadrants:\n        output_grid[0:2, 0:2] = quadrant_patterns['TR'] # Swap: TR goes to TL position\n        output_grid[0:2, 2:4] = quadrant_patterns['TL'] # Swap: TL goes to TR position\n    else:\n        output_grid[0:2, 0:2] = quadrant_patterns['TL'] # No swap: TL stays in TL\n        output_grid[0:2, 2:4] = quadrant_patterns['TR'] # No swap: TR stays in TR\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3532,
    "candidates_token_count": 2050,
    "total_token_count": 5582,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.936255,
  "retries": null
}