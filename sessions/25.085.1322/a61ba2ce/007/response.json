{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies exactly four 3-pixel L-shaped objects in the input grid.\nCalculates the bounding box (bbox) center for each object.\nDetermines the median row and median column from these four centers to establish relative quadrant boundaries.\nAssigns each object to a relative input quadrant (InTL, InTR, InBL, InBR) based on its bbox center relative to the median coordinates.\nCalculates the vertical midline indices of the input grid.\nChecks if the bbox of the object assigned to InTL OR the object assigned to InTR crosses the vertical midline. Crossing means the bbox spans columns on both sides of the midline boundary.\nConstructs a 4x4 output grid by placing the 2x2 patterns extracted from each object's bbox:\n  - Pattern from InBL object goes to output BL (bottom-left).\n  - Pattern from InBR object goes to output BR (bottom-right).\n  - If the crossing condition is True, the pattern from InTR goes to output TL (top-left), and the pattern from InTL goes to output TR (top-right).\n  - If the crossing condition is False, the pattern from InTL goes to output TL, and the pattern from InTR goes to output TR.\n\"\"\"\n\ndef find_l_objects(grid):\n    \"\"\"\n    Finds all contiguous 3-pixel L-shaped objects of non-background colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an L-shaped object with keys:\n              'color': The color of the object's pixels.\n              'pixels': A list of (row, col) coordinates of the object's pixels.\n              'bbox': A tuple (min_r, min_c, max_r, max_c) of the bounding box (should be 2x2).\n              'pattern': A 2x2 numpy array of the pattern within the bbox.\n              'bbox_center': A tuple (center_r, center_c) of the bounding box center coordinates.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                q = [(r, c)]\n                visited[r, c] = True\n                component_pixels = []\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Use BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.pop(0)\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Check if the found component is an L-shape (3 pixels and 2x2 bbox)\n                if len(component_pixels) == 3 and (max_r - min_r == 1) and (max_c - min_c == 1):\n                    bbox = (min_r, min_c, max_r, max_c)\n                    # Extract the 2x2 pattern directly using the bounding box\n                    pattern = grid[min_r:min_r+2, min_c:min_c+2].copy() # Use copy\n\n                    # Calculate bbox center\n                    center_r = (min_r + max_r) / 2.0\n                    center_c = (min_c + max_c) / 2.0\n                    bbox_center = (center_r, center_c)\n\n                    # Defensive check for pattern shape\n                    if pattern.shape == (2, 2):\n                        objects.append({\n                            'color': color,\n                            'pixels': component_pixels,\n                            'bbox': bbox,\n                            'pattern': pattern, # Keep as numpy array\n                            'bbox_center': bbox_center\n                        })\n                    # else: # Should not happen for valid L-shapes, but could log if needed\n                    #    print(f\"Warning: Pattern shape incorrect {pattern.shape} for bbox {bbox}. Skipping object.\")\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the L-shape quadrant mapping rule.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    default_output_grid = np.zeros((4, 4), dtype=int) # Grid to return on error\n\n    # 1. Identify Objects: Find exactly four L-shaped objects\n    objects = find_l_objects(input_grid_np)\n    if len(objects) != 4:\n        # print(f\"Warning: Expected 4 L-shaped objects, found {len(objects)}. Returning default grid.\")\n        return default_output_grid.tolist()\n\n    # 2. Determine Relative Center: Calculate median center coordinates\n    centers_r = [obj['bbox_center'][0] for obj in objects]\n    centers_c = [obj['bbox_center'][1] for obj in objects]\n    median_r = np.median(centers_r)\n    median_c = np.median(centers_c)\n\n    # 3. Assign Input Quadrants: Based on median coordinates\n    objects_by_quadrant = {'InTL': None, 'InTR': None, 'InBL': None, 'InBR': None}\n    quadrant_assignment_count = 0\n    assigned_quadrants_list = [] # To check for duplicates\n\n    for obj in objects:\n        center_r, center_c = obj['bbox_center']\n        quadrant = \"\"\n        if center_r < median_r: quadrant += \"InT\"\n        else: quadrant += \"InB\" # Objects exactly on median line go to Bottom/Right\n\n        if center_c < median_c: quadrant += \"L\"\n        else: quadrant += \"R\"\n\n        if quadrant in objects_by_quadrant and objects_by_quadrant[quadrant] is None:\n            objects_by_quadrant[quadrant] = obj\n            quadrant_assignment_count += 1\n            assigned_quadrants_list.append(quadrant)\n        else:\n            # This case should be less likely with median but handle defensively\n            # print(f\"Warning: Quadrant assignment issue for object at center {obj['bbox_center']} -> quadrant {quadrant}. Existing: {objects_by_quadrant.get(quadrant)}\")\n            return default_output_grid.tolist()\n\n    # Check if all quadrants were assigned exactly one object\n    if quadrant_assignment_count != 4 or len(set(assigned_quadrants_list)) != 4:\n         # print(f\"Warning: Not all quadrants assigned uniquely. Count: {quadrant_assignment_count}, Unique: {len(set(assigned_quadrants_list))}. Returning default grid.\")\n         return default_output_grid.tolist()\n\n    # 4. Check Crossing Condition: Check if InTL or InTR crosses the vertical midline\n    vertical_center_col_idx_left = (width - 1) // 2\n    vertical_center_col_idx_right = vertical_center_col_idx_left + 1\n    swap_top_quadrants = False\n\n    obj_intl = objects_by_quadrant['InTL']\n    obj_intr = objects_by_quadrant['InTR']\n\n    # Check InTL crossing\n    bbox_intl = obj_intl['bbox']\n    if bbox_intl[1] <= vertical_center_col_idx_left and bbox_intl[3] >= vertical_center_col_idx_right:\n        swap_top_quadrants = True\n\n    # Check InTR crossing (only if InTL didn't cross)\n    if not swap_top_quadrants:\n        bbox_intr = obj_intr['bbox']\n        if bbox_intr[1] <= vertical_center_col_idx_left and bbox_intr[3] >= vertical_center_col_idx_right:\n            swap_top_quadrants = True\n\n    # 5. Assemble Output Grid: Create 4x4 grid and place patterns\n    output_grid = np.zeros((4, 4), dtype=int)\n\n    # Place bottom patterns (fixed relative mapping)\n    output_grid[2:4, 0:2] = objects_by_quadrant['InBL']['pattern']\n    output_grid[2:4, 2:4] = objects_by_quadrant['InBR']['pattern']\n\n    # Place top patterns based on swap condition\n    if swap_top_quadrants:\n        # Swap: InTR pattern -> OutTL, InTL pattern -> OutTR\n        output_grid[0:2, 0:2] = obj_intr['pattern']\n        output_grid[0:2, 2:4] = obj_intl['pattern']\n    else:\n        # No swap: InTL pattern -> OutTL, InTR pattern -> OutTR\n        output_grid[0:2, 0:2] = obj_intl['pattern']\n        output_grid[0:2, 2:4] = obj_intr['pattern']\n\n    # 6. Return the assembled grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9811,
    "candidates_token_count": 2325,
    "total_token_count": 12136,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.006111,
  "retries": null
}