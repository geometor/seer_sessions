{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\n1.  Create an output grid with 3 rows and the same width as the input grid.\n2.  Copy the first row (index 0) of the input grid to the first row (index 0) of the output grid.\n3.  Copy the second row (index 1) of the input grid to the second row (index 1) of the output grid. (This assumes the input grid always has at least 2 rows).\n4.  Identify the 'background color':\n    a.  Consider all pixels from the second row (index 1) downwards in the input grid.\n    b.  Count the frequency of each color in this area.\n    c.  Find the color(s) with the maximum frequency.\n    d.  **Tie-breaking:** If there is more than one color with the maximum frequency, identify which of these tied colors are *not* present in the first row (index 0) of the input grid.\n        i.  If exactly one tied color is *not* present in the first row, that color is the 'background color'.\n        ii. If multiple tied colors are *not* present in the first row, the 'background color' is the one among them with the smallest numerical value.\n        iii. If all tied colors *are* present in the first row, the 'background color' is the one among the originally tied colors with the smallest numerical value.\n    e.  If there was only one color with the maximum frequency initially, that color is the 'background color'.\n5.  Identify the 'target color':\n    a.  Consider the first row (index 0) of the input grid.\n    b.  Count the frequency of each color in this row.\n    c.  Ignore the count for the identified 'background color'.\n    d.  Find the color(s) with the maximum frequency among the remaining colors.\n    e.  If one or more such colors exist, the 'target color' is the one with the smallest numerical value.\n    f.  If no colors remain after ignoring the 'background color', there is no 'target color'.\n6.  Construct the third row (index 2) of the output grid:\n    a.  Take a copy of the first row (index 0) of the input grid.\n    b.  If a 'target color' was identified in the previous step, replace all pixels matching the 'target color' in the copied row with magenta (color 6).\n    c.  Assign this modified (or unmodified, if no target color was found) row to the third row (index 2) of the output grid.\n\"\"\"\n\ndef find_background_color(input_grid: np.ndarray) -> int | None:\n    \"\"\"\n    Identifies the background color based on frequency in rows 1+\n    with specific tie-breaking rules involving row 0.\n    \"\"\"\n    input_height, _ = input_grid.shape\n\n    if input_height <= 1:\n        return None # Not enough rows to determine background\n\n    background_area = input_grid[1:, :].flatten()\n\n    if background_area.size == 0:\n        return None # Background area is empty\n\n    counts = Counter(background_area)\n    if not counts:\n        return None # Should not happen if size > 0, but safety check\n\n    max_freq = max(counts.values())\n    most_frequent_colors = sorted([color for color, freq in counts.items() if freq == max_freq])\n\n    if len(most_frequent_colors) == 1:\n        # Case 4e: Only one most frequent color\n        return most_frequent_colors[0]\n    else:\n        # Case 4d: Tie-breaking needed\n        row0_colors = set(input_grid[0, :])\n        \n        # Identify tied colors NOT present in row 0\n        candidates_after_exclusion = [color for color in most_frequent_colors if color not in row0_colors]\n\n        if len(candidates_after_exclusion) == 1:\n            # Case 4d.i: Exactly one tied color not in row 0\n            return candidates_after_exclusion[0]\n        elif len(candidates_after_exclusion) > 1:\n            # Case 4d.ii: Multiple tied colors not in row 0 -> pick smallest\n            return min(candidates_after_exclusion)\n        else: # len(candidates_after_exclusion) == 0\n            # Case 4d.iii: All tied colors are in row 0 -> pick smallest among original tied colors\n            return min(most_frequent_colors)\n\ndef find_target_color(input_row_0: np.ndarray, background_color: int | None) -> int | None:\n    \"\"\"\n    Identifies the target color in row 0, excluding the background color,\n    using frequency and picking the smallest value in case of a tie.\n    \"\"\"\n    if input_row_0.size == 0:\n        return None\n\n    counts_row0 = Counter(input_row_0)\n\n    # Case 5c: Ignore the background color\n    if background_color is not None and background_color in counts_row0:\n        del counts_row0[background_color]\n\n    if not counts_row0:\n        # Case 5f: No colors left after excluding background\n        return None\n\n    # Case 5d: Find max frequency among remaining\n    max_freq_row0 = max(counts_row0.values())\n    target_candidates = sorted([color for color, freq in counts_row0.items() if freq == max_freq_row0])\n\n    if not target_candidates:\n         # Should not happen if counts_row0 is not empty, but safety check\n         return None\n    \n    # Case 5e: Pick smallest numerical value if tie\n    return min(target_candidates)\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_height, input_width = input_grid.shape\n    \n    # Step 1: Initialize output_grid with 3 rows and same width\n    # Use a default color like black (0) initially\n    output_grid = np.zeros((3, input_width), dtype=int)\n\n    # Step 2: Copy row 0\n    output_grid[0, :] = input_grid[0, :]\n\n    # Step 3: Copy row 1 (assuming height >= 2 as per examples)\n    if input_height > 1:\n        output_grid[1, :] = input_grid[1, :]\n    # Else: output_grid[1, :] remains zeros, behavior for height=1 input is undefined by examples.\n\n    # Step 4: Identify background color using helper function\n    background_color = find_background_color(input_grid)\n\n    # Step 5: Identify target color using helper function\n    input_row_0 = input_grid[0, :]\n    target_color = find_target_color(input_row_0, background_color)\n\n    # Step 6: Construct row 2\n    # 6a: Take a copy of input row 0\n    output_row_2 = input_row_0.copy() \n    replacement_color = 6 # Magenta\n\n    # 6b: Replace target color if found\n    if target_color is not None:\n        output_row_2[output_row_2 == target_color] = replacement_color\n\n    # 6c: Assign to output grid\n    output_grid[2, :] = output_row_2\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7439,
    "candidates_token_count": 1752,
    "total_token_count": 9191,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.094051,
  "retries": null
}