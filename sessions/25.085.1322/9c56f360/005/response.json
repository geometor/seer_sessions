{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nProcesses each row of the input grid independently.\nFor the current row:\n    a. Create a reference copy of the original row.\n    b. Find all green pixels and calculate their target columns based on the first azure pixel to their left (target = azure_col + 1, or 0 if no azure pixel).\n    c. Identify the columns occupied by stationary green pixels (those whose target column is their original column). Store these in a set `stationary_green_columns`.\n    d. Create an empty set `occupied_moved_destinations` to track columns filled by green pixels that have successfully moved during this row's processing.\n    e. Iterate through the green pixels of the original row from right to left based on their column index `c`.\n    f. For each green pixel at original column `c` with target `target_c`:\n        i. If the pixel is stationary (`c == target_c`), do nothing.\n        ii. If the pixel wants to move (`c != target_c`):\n            1. Check for stationary conflict: If `target_c` is in `stationary_green_columns`, the pixel cannot move. Do nothing.\n            2. If no stationary conflict: Calculate the final destination `dest_c`, starting at `target_c`.\n            3. Check for dynamic conflict: While `dest_c` is in `occupied_moved_destinations`, increment `dest_c` by 1.\n            4. Check bounds and place: If `dest_c` is within the grid width:\n                A. Add `dest_c` to `occupied_moved_destinations`.\n                B. Update the output grid: Set pixel at (row, `c`) to white (0).\n                C. Update the output grid: Set pixel at (row, `dest_c`) to green (3).\n            5. If `dest_c` is out of bounds (due to dynamic conflict pushing), the pixel cannot move. Do nothing (it stays at `c`).\nReturn the final output grid.\n\"\"\"\n\ndef find_target_column(row_array, start_col):\n    \"\"\"\n    Determines the target column for a green pixel based on azure pixels to its left.\n\n    Args:\n        row_array (np.array): The 1D numpy array representing the original row.\n        start_col (int): The column index of the green pixel.\n\n    Returns:\n        int: The target column index.\n    \"\"\"\n    target_c = 0  # Default target is column 0\n    # Scan leftwards from start_col - 1 down to 0\n    for c in range(start_col - 1, -1, -1):\n        if row_array[c] == 8:  # Found an azure pixel\n            target_c = c + 1  # Target is the column immediately to its right\n            break  # Stop searching once the leftmost azure is found\n    return target_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving green pixels leftward based on azure pixel\n    positions within each row, resolving conflicts with stationary and other moved pixels.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_np)\n    height, width = output_grid.shape\n\n    # Iterate through each row independently\n    for r in range(height):\n        # Get the original state of the current row for reference\n        original_row = input_np[r, :]\n        \n        # Find column indices of all green pixels in the original row\n        green_cols_indices = np.where(original_row == 3)[0]\n        \n        # --- Pre-calculation Step ---\n        # Store targets and identify stationary green pixels\n        green_pixel_info = {} # Dict: {col: target_col}\n        stationary_green_columns = set()\n        for c in green_cols_indices:\n            target_c = find_target_column(original_row, c)\n            green_pixel_info[c] = target_c\n            if c == target_c:\n                stationary_green_columns.add(c)\n\n        # Keep track of destination columns occupied by *moved* green pixels in this row's pass\n        occupied_moved_destinations = set()\n\n        # --- Main Processing Loop (Right-to-Left) ---\n        # Process green pixels from right to left within the row based on original positions\n        for c in sorted(green_cols_indices, reverse=True):\n            \n            target_c = green_pixel_info[c]\n\n            # If the pixel is stationary, do nothing.\n            if c == target_c:\n                continue \n                \n            # --- Attempt to Move ---\n            # Check for stationary conflict: If target is a stationary green pixel's location\n            if target_c in stationary_green_columns:\n                # Cannot move, pixel stays at original position 'c'.\n                # No change needed in output_grid.\n                continue\n\n            # Calculate the final destination column, resolving dynamic collisions\n            dest_c = target_c\n            while dest_c in occupied_moved_destinations:\n                 dest_c += 1\n            \n            # Check if the final destination is within bounds\n            if dest_c < width:\n                # Mark the final destination column as occupied *by a moved pixel*\n                occupied_moved_destinations.add(dest_c)\n\n                # Update the output grid: \n                # Erase original position \n                output_grid[r, c] = 0  \n                # Place green at destination\n                output_grid[r, dest_c] = 3 \n            else:\n                 # Pixel could not find a valid spot within the grid width due to collisions.\n                 # It remains in its original position 'c'.\n                 # No change needed in output_grid.\n                 pass # Explicitly show no action needed\n\n    # Convert the final numpy array back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7753,
    "candidates_token_count": 1428,
    "total_token_count": 9181,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.591778,
  "retries": null
}