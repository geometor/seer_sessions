{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct, contiguous, non-white rectangular objects in the input grid.\nDetermine the common height (obj_h) of these objects and the maximum row index (max_obj_row) occupied by any object pixel.\nCalculate the target starting row (output_start_row) for the output assembly: base_start_row = max_obj_row - obj_h + 1. If the grid height (H_grid) is 5 or less, decrement the base_start_row by 1.\nSort the identified objects based on their leftmost column index (min_col) in ascending order.\nCreate an output grid of the same dimensions as the input, filled with the background color (white, 0).\nPlace the sorted objects horizontally adjacent to each other in the output grid, starting from column 0 and row output_start_row.\nThe color and shape of each object are preserved.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (r, c) tuples),\n              'min_row', 'max_row', 'min_col', 'max_col', 'height', 'width'.\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_row': min_r,\n                    'max_row': max_r,\n                    'min_col': min_c,\n                    'max_col': max_c,\n                    'height': max_r - min_r + 1,\n                    'width': max_c - min_c + 1\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying colored rectangular objects,\n    sorting them left-to-right, and arranging them horizontally adjacent\n    at a calculated vertical position in the output grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output_grid with the background color (white, 0)\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # Find all non-white objects\n    objects = find_objects(input_np)\n\n    # If no objects are found, return the empty grid\n    if not objects:\n        return output_grid.tolist() # Convert back to list of lists\n\n    # Assume all objects have the same height (as observed in examples)\n    # Find the common height and the overall maximum row index\n    obj_h = objects[0]['height'] # Get height from the first object\n    max_obj_row = 0\n    for obj in objects:\n        max_obj_row = max(max_obj_row, obj['max_row'])\n        # Optional: Add a check here if object heights are inconsistent\n\n    # Determine the vertical placement (output_start_row)\n    h_grid = height\n    base_start_row = max_obj_row - obj_h + 1\n    if h_grid <= 5:\n        output_start_row = base_start_row - 1\n    else:\n        output_start_row = base_start_row\n\n    # Ensure start row is not negative (edge case if objects are at the very top)\n    output_start_row = max(0, output_start_row)\n\n    # Sort objects based on their leftmost column (min_col)\n    objects.sort(key=lambda obj: obj['min_col'])\n\n    # Place sorted objects into the output grid\n    current_col = 0\n    for obj in objects:\n        obj_color = obj['color']\n        obj_width = obj['width']\n        # Iterate through the pixels of the object relative to its own bounding box\n        for r, c in obj['pixels']:\n            # Calculate relative coordinates within the object's bounding box\n            rel_r = r - obj['min_row']\n            rel_c = c - obj['min_col']\n\n            # Calculate target coordinates in the output grid\n            target_r = output_start_row + rel_r\n            target_c = current_col + rel_c\n\n            # Place the pixel if within output grid bounds\n            if 0 <= target_r < height and 0 <= target_c < width:\n                output_grid[target_r, target_c] = obj_color\n            # else: # Optional: handle cases where assembly might go out of bounds\n                # print(f\"Warning: Pixel placement out of bounds: ({target_r}, {target_c})\")\n\n\n        # Update the starting column for the next object\n        current_col += obj_width\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3226,
    "candidates_token_count": 1507,
    "total_token_count": 4733,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.554408,
  "retries": null
}