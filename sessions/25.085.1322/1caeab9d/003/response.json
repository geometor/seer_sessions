{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all distinct, contiguous, non-white objects in the input grid.\nDetermines the common height (obj_h) of these objects and the maximum row index (max_obj_row) they occupy.\nCalculates a target starting row (output_start_row) for vertical alignment: base_start_row = max_obj_row - obj_h + 1. If the grid height is 5 or less, decrement the base_start_row by 1. Ensures the start row is non-negative.\nCreates an output grid of the same dimensions, filled with the background color (white, 0).\nPlaces each identified object into the output grid, preserving its color and shape. The object's top edge is aligned with the calculated output_start_row, and its horizontal position (left edge) is preserved from its original position (min_col) in the input grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (r, c) tuples),\n              'min_row', 'max_row', 'min_col', 'max_col', 'height', 'width'.\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    background_color = 0 # Assuming white is the background\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not background and not visited yet\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the same color and hasn't been visited\n                            if not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store object information\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_row': min_r,\n                    'max_row': max_r,\n                    'min_col': min_c,\n                    'max_col': max_c,\n                    'height': max_r - min_r + 1,\n                    'width': max_c - min_c + 1\n                })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the specified rules.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output_grid with the background color (white, 0)\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 1. Identify all non-white objects\n    objects = find_objects(input_np)\n\n    # 2. If no objects found, return empty grid\n    if not objects:\n        return output_grid.tolist() # Convert back to list of lists\n\n    # 3. Determine common height (assuming all objects have same height)\n    obj_h = objects[0]['height']\n\n    # 4. Find the overall maximum row index occupied by any object pixel\n    max_obj_row = 0\n    for obj in objects:\n        max_obj_row = max(max_obj_row, obj['max_row'])\n        # Optional: Could add a check here if object heights are inconsistent, though task implies they are consistent.\n\n    # 5. Calculate the base vertical alignment row\n    base_start_row = max_obj_row - obj_h + 1\n\n    # 6. Adjust alignment row based on grid height\n    h_grid = height\n    if h_grid <= 5:\n        output_start_row = base_start_row - 1\n    else:\n        output_start_row = base_start_row\n\n    # Ensure start row is not negative\n    output_start_row = max(0, output_start_row)\n\n    # 7. Place each object into the output grid\n    for obj in objects:\n        obj_color = obj['color']\n        obj_min_row = obj['min_row'] # Original top row\n        obj_min_col = obj['min_col'] # Original left column\n\n        # Iterate through the pixels of the object\n        for r, c in obj['pixels']:\n            # Calculate relative coordinates within the object's bounding box\n            rel_r = r - obj_min_row\n            # rel_c = c - obj_min_col # Not strictly needed here but useful for understanding\n\n            # Calculate target coordinates in the output grid\n            # Target row: aligned start row + relative row within object\n            # Target column: original object left column + relative column within object\n            target_r = output_start_row + rel_r\n            # target_c = obj_min_col + rel_c\n            target_c = c # Since rel_c = c - obj_min_col, target_c = obj_min_col + (c - obj_min_col) = c\n                      # Wait, no, the target column should be based on the object's original min_col, not the absolute input col 'c'.\n                      # Let's recalculate target_c properly.\n            rel_c = c - obj_min_col\n            target_c = obj_min_col + rel_c # This ensures horizontal position is preserved relative to obj_min_col\n\n            # Place the pixel if within output grid bounds\n            if 0 <= target_r < height and 0 <= target_c < width:\n                output_grid[target_r, target_c] = obj_color\n            # else: # Optional: Handle cases where assembly might go out of bounds (if needed)\n                # print(f\"Warning: Pixel placement out of bounds: ({target_r}, {target_c})\")\n\n    # 8. Convert the result back to a list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8877,
    "candidates_token_count": 1704,
    "total_token_count": 10581,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.198915,
  "retries": null
}