{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a static 'barrier' object (color red, 2) located along one edge (left, right, or bottom).\nIdentifies all other non-background (white, 0) and non-barrier objects as 'movable objects'.\nDetermines the direction of movement based on the barrier's location: towards the barrier (left, right, or down).\nSimulates the movement of each movable object in the determined direction until it collides with the grid boundary, the barrier, or another object that has already settled in its final position.\nObjects move as a whole unit.\nThe final positions of all objects (barrier and moved objects) are placed on an initially white output grid.\nThe order of object movement simulation matters: objects closer to the barrier (along the axis of movement) are processed first to correctly handle collisions and blocking.\n\"\"\"\n\ndef find_objects(grid, colors_to_find, exclude_colors=None):\n    \"\"\"\n    Finds all contiguous objects of specified colors, excluding others.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (list or set): Colors to search for.\n        exclude_colors (list or set, optional): Colors to ignore. Defaults to None.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    if exclude_colors is None:\n        exclude_colors = set()\n    else:\n        exclude_colors = set(exclude_colors)\n        \n    colors_to_find = set(colors_to_find)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if not visited[r, c] and color in colors_to_find and color not in exclude_colors:\n                obj_coords = set()\n                obj_color = color\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                objects.append({'color': obj_color, 'coords': obj_coords})\n    return objects\n\ndef get_barrier_info(grid):\n    \"\"\"\n    Finds the red barrier object and determines movement direction.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (barrier_coords (set), move_vector (tuple (dr, dc))) or (None, None) if no barrier found.\n    \"\"\"\n    rows, cols = grid.shape\n    red_objects = find_objects(grid, [2])\n\n    if not red_objects:\n        return None, None # Should not happen based on task description\n\n    # Assuming a single contiguous barrier object as per examples\n    barrier_coords = red_objects[0]['coords']\n\n    # Check position to determine direction\n    is_left_barrier = all(c == 0 for r, c in barrier_coords)\n    is_right_barrier = all(c == cols - 1 for r, c in barrier_coords)\n    is_bottom_barrier = all(r == rows - 1 for r, c in barrier_coords)\n\n    if is_left_barrier:\n        move_vector = (0, -1) # Move left\n    elif is_right_barrier:\n        move_vector = (0, 1)  # Move right\n    elif is_bottom_barrier:\n        move_vector = (1, 0)  # Move down\n    else:\n        # Handle unexpected barrier position if necessary, though examples suggest edge alignment\n        return barrier_coords, (0, 0) # Or raise an error\n\n    return barrier_coords, move_vector\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object movement and collision logic.\n\n    Args:\n        input_grid (np.array): The input 2D numpy array.\n\n    Returns:\n        np.array: The transformed 2D numpy array.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color 0\n\n    # 1. Identify barrier and movement direction\n    barrier_coords, move_vector = get_barrier_info(input_grid)\n    if barrier_coords is None:\n        return input_grid # Or handle error - return input if no barrier\n\n    dr, dc = move_vector\n\n    # 2. Place barrier on output grid\n    for r, c in barrier_coords:\n        if 0 <= r < rows and 0 <= c < cols: # Boundary check just in case\n             output_grid[r, c] = 2\n\n    # 3. Identify movable objects\n    movable_objects = find_objects(input_grid, list(range(1, 10)), exclude_colors=[0, 2])\n\n    # 4. Sort movable objects based on movement direction for correct collision processing\n    if dc == -1: # Moving left\n        movable_objects.sort(key=lambda obj: min(c for r, c in obj['coords']))\n    elif dc == 1: # Moving right\n        movable_objects.sort(key=lambda obj: max(c for r, c in obj['coords']), reverse=True)\n    elif dr == 1: # Moving down\n        movable_objects.sort(key=lambda obj: max(r for r, c in obj['coords']), reverse=True)\n    # else: no movement if move_vector is (0,0)\n\n    # 5. Simulate movement and place objects\n    for obj in movable_objects:\n        current_coords = obj['coords']\n        color = obj['color']\n        \n        while True:\n            # Calculate potential next position\n            next_coords = set((r + dr, c + dc) for r, c in current_coords)\n            \n            # Check for collisions\n            collision = False\n            for nr, nc in next_coords:\n                # Check boundary collision\n                if not (0 <= nr < rows and 0 <= nc < cols):\n                    collision = True\n                    break\n                # Check collision with existing objects (barrier or previously moved objects)\n                if output_grid[nr, nc] != 0:\n                    collision = True\n                    break\n            \n            if collision:\n                # Cannot move further, stop simulation for this object\n                break\n            else:\n                # Move is valid, update current coordinates\n                current_coords = next_coords\n        \n        # Place the object at its final position\n        for r, c in current_coords:\n             if 0 <= r < rows and 0 <= c < cols: # Boundary check\n                output_grid[r, c] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3293,
    "candidates_token_count": 1716,
    "total_token_count": 5009,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.069393,
  "retries": null
}