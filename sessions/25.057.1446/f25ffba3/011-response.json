{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify the Red Line:** Find the rightmost vertical line of red pixels in both the input and output grids.\n2.  **Identify the Finger:** Find the \"finger\" of contiguous non-zero, non-red pixels connected to the red line in both the input and the output. The finger can extend in any of the four cardinal directions (up, down, left, or right) from the red line.\n3.  **Finger directions.** Consider all four directions from both the top and the bottom of the red line.\n4.  **Calculate Finger Translation:** Determine the row and column offset between the starting pixel (attachment to red line) of the finger in the input and output grids.  This represents how the entire finger has moved.\n5.  **Calculate Red Line Translation:** Determine the column offset between the red line in the input and output grid.\n6.  **Apply Translation:**\n    *   Move the finger in the input grid by the calculated row and column offset.\n    *   Move the red line by the calculated column offset.\n7.  **Output:** The transformed grid consists of the translated finger and red line; all other pixels are black (0).\n\"\"\"\n\nimport numpy as np\n\ndef find_vertical_line(grid, color):\n    # Find the rightmost column where all elements match color\n    for j in range(grid.shape[1] - 1, -1, -1):\n        if np.all(grid[:, j] == color):\n            return j\n    return -1\n\ndef find_fingers(grid, line_col, line_color):\n    #find all fingers connected to a vertical line\n    fingers = []\n\n    if line_col == -1:\n        return fingers # No line, so no fingers\n\n    # Find the row where the vertical line starts and ends\n    start_row = 0\n    for row in range(grid.shape[0]):\n        if grid[row, line_col] == line_color:\n            start_row = row\n            break\n\n    end_row = grid.shape[0] -1\n    for row in range(grid.shape[0] - 1, -1, -1):\n        if grid[row, line_col] == line_color:\n            end_row = row\n            break\n\n    # Check above\n    finger = []\n    for row in range(start_row - 1, -1, -1):\n        if grid[row, line_col] != 0 and grid[row, line_col] != line_color:\n            finger.append((row, line_col, grid[row, line_col]))\n        else:\n            break\n    if finger:\n        fingers.append(finger)\n\n    # Check below\n    finger = []\n    for row in range(end_row + 1, grid.shape[0]):\n        if grid[row, line_col] != 0 and grid[row, line_col] != line_color:\n            finger.append((row, line_col, grid[row, line_col]))\n        else:\n            break\n    if finger:\n        fingers.append(finger)\n\n    # Scan to the left from line end point\n    finger = []\n    for j in range(line_col - 1, -1, -1):\n        if grid[end_row, j] != 0 and grid[end_row, j] != line_color:\n            finger.append((end_row, j, grid[end_row, j]))\n        else:\n            break\n    if finger:\n        fingers.append(finger[::-1])  # Correct the reversing\n\n    # Scan to the left from line start point\n    finger = []\n    for j in range(line_col - 1, -1, -1):\n        if grid[start_row, j] != 0 and grid[start_row, j] != line_color :\n            finger.append((start_row, j, grid[start_row, j]))\n        else:\n            break\n    if finger:\n        fingers.append(finger[::-1])  # Correct the reversing\n\n    #scan to the right from the line start point\n    finger = []\n    for j in range(line_col + 1, grid.shape[1]):\n      if grid[start_row, j] != 0 and grid[start_row,j] != line_color:\n        finger.append( (start_row, j, grid[start_row,j]))\n      else:\n        break;\n    if finger:\n      fingers.append(finger)\n\n    #scan to the right from the line end point\n    finger = []\n    for j in range(line_col + 1, grid.shape[1]):\n      if grid[end_row, j] != 0 and grid[end_row,j] != line_color:\n        finger.append( (end_row, j, grid[end_row,j]))\n      else:\n        break;\n    if finger:\n      fingers.append(finger)\n\n    return fingers\n\ndef calculate_translation(input_finger, output_finger):\n    #determine row/col offset, assuming input and output are same length\n    if not input_finger or not output_finger:\n        return 0, 0\n    input_start = input_finger[0]\n    output_start = output_finger[0]\n    row_offset = output_start[0] - input_start[0]\n    col_offset = output_start[1] - input_start[1]\n    return row_offset, col_offset\n\ndef translate_finger(grid, finger, row_offset, col_offset):\n    # Move a finger by row and column offset\n    for i, j, color in finger:\n        new_row = i + row_offset\n        new_col = j + col_offset\n        if 0 <= new_row < grid.shape[0] and 0 <= new_col < grid.shape[1]:\n            grid[new_row, new_col] = color\n\ndef translate_line(grid, line_col, color, col_offset):\n  #move a vertical line by a col offset\n  if line_col == -1:\n    return\n  \n  new_col = line_col + col_offset\n  if new_col < 0 or new_col >= grid.shape[1]:\n    return;\n\n  for row in range(grid.shape[0]):\n    if grid[row, line_col] == color:\n      grid[row, new_col] = color\n\ndef transform(input_grid):\n    # 1. Identify the Red Line\n    input_red_line_col = find_vertical_line(input_grid, 2)\n\n    # 2. Identify the Fingers\n    input_fingers = find_fingers(input_grid, input_red_line_col, 2)\n    # Create a blank output grid (all black)\n    output_grid = np.zeros_like(input_grid)\n\n    #find the red line and finger in the output_grid by inverting the input\n    output_red_line_col = find_vertical_line(input_grid[::-1, ::-1], 2)\n    output_fingers = find_fingers(input_grid[::-1, ::-1], output_red_line_col, 2)\n\n    red_line_col_offset = 0\n    if input_red_line_col != -1 and output_red_line_col != -1:\n      red_line_col_offset =  (input_grid.shape[1] -1 - output_red_line_col) - input_red_line_col\n\n    # 3. & 4. Calculate Finger Translation\n    row_offset, col_offset = 0, 0\n    if input_fingers and output_fingers:\n        row_offset, col_offset = calculate_translation(input_fingers[0], output_fingers[0])\n\n    # 5. & 6. Apply Translation to finger and red line\n    if input_fingers:\n        for finger in input_fingers:\n          translate_finger(output_grid, finger, row_offset, col_offset)\n\n    translate_line(output_grid, input_red_line_col, 2, red_line_col_offset)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6656,
    "candidates_token_count": 1926,
    "total_token_count": 8582,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 16.180391,
  "response_file": "011-response.json"
}