{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nCreates a layered square grid based on the sizes of non-background objects in the input grid.\n\n1.  Identify the most frequent color in the input grid; this is the background color.\n2.  Find all contiguous groups (objects) of pixels (using 4-way adjacency) that are *not* the background color.\n3.  For each distinct non-background color found, determine the size (number of pixels) of its largest contiguous object.\n4.  Count the number of distinct non-background colors (N).\n5.  Sort these distinct colors in descending order based on their largest object size. Let the sorted colors be C1, C2, ..., CN.\n6.  Calculate the output grid dimensions as (2N - 1) x (2N - 1).\n7.  Create the output grid. Fill it concentrically, layer by layer, starting from the outside:\n    - Layer 0 (outermost border) is filled with color C1.\n    - Layer 1 (next layer inwards) is filled with color C2.\n    - ...\n    - Layer k is filled with color C(k+1).\n    - Layer N-1 (center pixel or block) is filled with color CN.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter, deque\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        dict: A dictionary mapping each non-background color to a list of its\n              objects, where each object is represented by a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects_by_color = {}\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) in visited:\n                continue\n\n            color = grid[r, c]\n            if color == background_color:\n                visited.add((r, c))\n                continue\n\n            # Start BFS for a new object\n            current_object_coords = set()\n            q = deque([(r, c)])\n            visited.add((r, c))\n            current_object_coords.add((r, c))\n\n            while q:\n                row, col = q.popleft()\n\n                # Check 4-directional neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       (nr, nc) not in visited and \\\n                       grid[nr, nc] == color:\n                        visited.add((nr, nc))\n                        current_object_coords.add((nr, nc))\n                        q.append((nr, nc))\n\n            # Store the found object\n            if color not in objects_by_color:\n                objects_by_color[color] = []\n            objects_by_color[color].append(current_object_coords)\n\n    return objects_by_color\n\ndef _get_largest_object_sizes(objects_by_color):\n    \"\"\"\n    Calculates the size of the largest object for each color.\n\n    Args:\n        objects_by_color (dict): Dictionary from _find_objects.\n\n    Returns:\n        dict: A dictionary mapping each color to the size of its largest object.\n    \"\"\"\n    largest_sizes = {}\n    for color, objects_list in objects_by_color.items():\n        if objects_list:\n            largest_sizes[color] = max(len(obj) for obj in objects_list)\n        else:\n             largest_sizes[color] = 0 # Should not happen if color is in keys\n    return largest_sizes\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the sizes of non-background objects.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # 1. Identify Background Color (most frequent)\n    colors, counts = np.unique(input_array, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find all contiguous non-background objects\n    objects_by_color = _find_objects(input_array, background_color)\n\n    # 3. Get unique non-background colors\n    non_background_colors = list(objects_by_color.keys())\n\n    # Handle edge case: No non-background objects found\n    if not non_background_colors:\n        # Returning a 1x1 grid with the background color might be a safe default,\n        # though the examples suggest this won't happen.\n        # Or perhaps return an empty grid or the original? Let's stick to 1x1.\n        return [[background_color]] # Or potentially adjust based on expected behavior\n\n    # 4. Determine the size of the largest object for each color\n    largest_sizes = _get_largest_object_sizes(objects_by_color)\n\n    # 5. Sort colors by largest object size (descending)\n    sorted_colors = sorted(non_background_colors, key=lambda c: largest_sizes[c], reverse=True)\n\n    # 6. Calculate output grid dimensions\n    N = len(sorted_colors)\n    output_dim = 2 * N - 1\n\n    # 7. Create the output grid\n    # Initialize with a dummy value like -1 or the center color CN\n    output_grid = np.full((output_dim, output_dim), -1, dtype=int)\n    center = N - 1 # Center index for both row and column\n\n    # 8. Fill the output grid layer by layer\n    for layer_index in range(N):\n        # Color for this layer (outermost is layer 0)\n        layer_color = sorted_colors[layer_index]\n        # The distance from the center for this layer's boundary\n        dist = N - 1 - layer_index\n\n        for r in range(output_dim):\n            for c in range(output_dim):\n                # Calculate Manhattan distance-like metric for square layers\n                current_dist = max(abs(r - center), abs(c - center))\n                # Fill if this pixel is exactly on the boundary of the current layer\n                if current_dist == dist:\n                    output_grid[r, c] = layer_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3673,
    "candidates_token_count": 1570,
    "total_token_count": 5243,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.006184,
  "retries": null
}