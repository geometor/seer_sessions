{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nSimulates gravity on non-white (0), non-azure (8) objects in a grid.\nObjects are defined as contiguous blocks (adjacent, not diagonal) of the same \ncolor, excluding white and azure. These mobile objects fall downwards as \nwhole units through white space (color 0). An object stops falling when any \npart of it is directly above a non-white pixel (either another mobile object, \na static azure pixel, or the grid's bottom boundary). The simulation runs \niteratively, allowing objects to fall one step at a time in each pass, until \na full pass completes with no objects moving, indicating a stable state. Azure \npixels (color 8) are static and act as obstacles/ground.\n\"\"\"\n\ndef _find_objects(grid, background_color, static_colors):\n    \"\"\"\n    Identifies all distinct mobile objects in the grid.\n\n    Args:\n        grid: The numpy array representing the grid state.\n        background_color: The integer value representing empty space.\n        static_colors: A set of integer values representing static colors.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its 'color' (int) and 'pixels' (a set of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n    # Define which colors are considered mobile\n    mobile_colors = set(range(10)) - {background_color} - static_colors\n\n    # Iterate through each cell to find starting points of new objects\n    for r in range(height):\n        for c in range(width):\n            # If the cell has a mobile color and hasn't been visited yet\n            if grid[r, c] in mobile_colors and (r, c) not in visited:\n                color = grid[r, c]\n                obj_pixels = set()\n                # Use BFS (Breadth-First Search) to find all connected pixels of the same color\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 adjacent neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check if neighbor is within bounds, has the same color, and hasn't been visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                # Add the found object to the list if it contains any pixels\n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies object-based gravity simulation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the output grid after simulation.\n    \"\"\"\n    # Convert input to NumPy array for efficient manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Create a copy to modify, representing the evolving grid state\n    output_grid = input_np.copy() \n    \n    background_color = 0\n    static_colors = {8} # Azure (8) is static\n\n    # --- Identify initial mobile objects ---\n    # These objects will be tracked and moved throughout the simulation.\n    mobile_objects = _find_objects(output_grid, background_color, static_colors)\n\n    # --- Simulation Loop ---\n    # Continue iterating until no objects move in a full pass.\n    while True:\n        moved_in_pass = False # Flag to track movement within a single pass\n        \n        # Sort objects by their lowest point (max row index) in descending order.\n        # This ensures that objects lower down are processed first in each pass.\n        mobile_objects.sort(key=lambda obj: max(r for r, c in obj['pixels']), reverse=True)\n\n        # Iterate through each mobile object and attempt to move it down\n        for i in range(len(mobile_objects)):\n            obj = mobile_objects[i]\n            \n            # --- Check if the object can move down one step ---\n            can_move = True\n            # Calculate the set of coordinates the object would occupy if moved down\n            potential_new_pixels = set((r + 1, c) for r, c in obj['pixels'])\n            \n            # Check for boundary collisions and obstacles below\n            for nr, nc in potential_new_pixels:\n                # 1. Check if any part hits the bottom boundary\n                if nr >= height:\n                    can_move = False\n                    break\n                # 2. Check if the potential new cell (nr, nc) is occupied by something static\n                #    or another object *that is not the object currently being moved*.\n                #    The `(nr, nc) not in obj['pixels']` condition is crucial. It ensures\n                #    that an object can move into a space that it currently occupies (e.g., the bottom\n                #    part moving into the space previously occupied by the top part).\n                #    We check the *current* state of output_grid, which reflects moves made\n                #    by lower objects earlier in this same pass.\n                if (nr, nc) not in obj['pixels'] and output_grid[nr, nc] != background_color:\n                    can_move = False\n                    break\n            \n            # --- If movement is possible, update the grid and object state ---\n            if can_move:\n                moved_in_pass = True # Mark that movement occurred in this pass\n                obj_color = obj['color']\n                \n                # 1. Erase the object from its old position in the output grid\n                #    It's important to copy the old pixels before updating the object's state.\n                old_pixels = obj['pixels'].copy() \n                for r, c in old_pixels:\n                    output_grid[r, c] = background_color\n                \n                # 2. Update the object's internal state (its pixel coordinates)\n                obj['pixels'] = potential_new_pixels \n\n                # 3. Draw the object in its new position in the output grid\n                for nr, nc in obj['pixels']:\n                    output_grid[nr, nc] = obj_color\n                \n                # The grid (output_grid) is now updated, reflecting this object's move.\n                # Subsequent objects checked in this pass will see this new state.\n\n        # --- Check for Simulation End ---\n        # If no object moved during this entire pass, the grid has stabilized.\n        if not moved_in_pass:\n            break # Exit the while loop\n\n    # Convert the final NumPy array back to a standard list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9769,
    "candidates_token_count": 1658,
    "total_token_count": 11427,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.612901,
  "retries": null
}