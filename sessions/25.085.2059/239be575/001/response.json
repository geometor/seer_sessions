{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify all distinct contiguous groups of red (2) pixels (Red Objects) and azure (8) pixels (Azure Objects).\nCheck if any single Azure Object is adjacent (including diagonals) to at least one pixel from *every* distinct Red Object.\nIf such an Azure Object exists, output 8. Otherwise, output 0.\nIf there are no Red Objects, output 0.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color value to find objects for.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a single object.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and (r, c) not in visited:\n                # Start BFS for a new object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (Moore neighborhood)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if it's the target color and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                obj_coords.add((nr, nc))\n                                q.append((nr, nc))\n                objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(coord, grid_shape):\n    \"\"\"\n    Gets all 8 neighboring coordinates for a given coordinate, within grid bounds.\n\n    Args:\n        coord (tuple): The (row, col) coordinate.\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        set: A set of valid neighbor (row, col) tuples.\n    \"\"\"\n    r, c = coord\n    height, width = grid_shape\n    neighbors = set()\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the adjacency rule between azure and red objects.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        int: 8 if a single azure object touches all red objects, 0 otherwise.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Find all Red Objects (color 2)\n    red_objects = find_objects(grid, 2)\n\n    # 2. Handle the case where there are no Red Objects\n    if not red_objects:\n        return 0 # Output is 0 if no red objects\n\n    # 3. Find all Azure Objects (color 8)\n    azure_objects = find_objects(grid, 8)\n\n    # Create a mapping from each red pixel coordinate to the index of the Red Object it belongs to.\n    # This helps quickly identify which red object a neighbor belongs to.\n    red_pixel_to_object_index = {}\n    for i, red_obj_coords in enumerate(red_objects):\n        for coord in red_obj_coords:\n            red_pixel_to_object_index[coord] = i\n\n    # 4. Iterate through each Azure Object\n    for azure_obj_coords in azure_objects:\n        touched_red_indices = set() # Keep track of which Red Objects this Azure Object touches\n\n        # 5. For the current Azure Object, check its adjacency to Red Objects\n        # Iterate through each pixel of the current Azure object\n        for azure_coord in azure_obj_coords:\n            # Find all neighbors of the current azure pixel\n            neighbors = get_neighbors(azure_coord, (height, width))\n            # Check if any neighbor belongs to a Red Object\n            for neighbor_coord in neighbors:\n                if neighbor_coord in red_pixel_to_object_index:\n                    # If a neighbor is red, find which Red Object it belongs to\n                    red_obj_index = red_pixel_to_object_index[neighbor_coord]\n                    # Record that this Red Object index has been touched by the current Azure Object\n                    touched_red_indices.add(red_obj_index)\n\n        # 6. Check if this Azure Object touched *all* Red Objects\n        if len(touched_red_indices) == len(red_objects):\n            # If the number of touched Red Object indices equals the total number of Red Objects,\n            # this Azure Object is our connector.\n            return 8 # Output 8\n\n    # 7. If no Azure Object touched all Red Objects after checking all of them\n    return 0 # Output 0\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2391,
    "candidates_token_count": 1310,
    "total_token_count": 3701,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.33105,
  "retries": null
}