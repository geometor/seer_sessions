{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies connected components of non-orange (7) pixels using 8-way adjacency.\nFor each component, determines its bounding box.\nIf a component's bounding box is exactly 3x3 pixels in size:\n1. Extracts the 3x3 subgrid from the input grid corresponding to this bounding box.\n2. Applies a specific pixel rearrangement within this 3x3 subgrid:\n    - Input(0,0) -> Output(2,0)\n    - Input(0,1) -> Output(1,2)\n    - Input(0,2) -> Output(0,0)\n    - Input(1,0) -> Output(0,1)\n    - Input(1,1) -> Output(1,1) (Center pixel remains)\n    - Input(1,2) -> Output(2,1)\n    - Input(2,0) -> Output(0,2)\n    - Input(2,1) -> Output(1,0)\n    - Input(2,2) -> Output(2,2)\n   (Coordinates are relative to the top-left of the 3x3 subgrid).\n3. Places the rearranged 3x3 subgrid into the output grid at the same location as the bounding box.\nPixels outside of these identified 3x3 bounding boxes remain unchanged from the input grid.\nThe output grid is initialized as a copy of the input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_non_bg_components(grid, bg_color):\n    \"\"\"\n    Finds connected components of pixels that are not the background color\n    using 8-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        bg_color (int): The background color to ignore.\n\n    Returns:\n        list[set]: A list of components, where each component is a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is non-background and not visited\n            if grid[r, c] != bg_color and (r, c) not in visited:\n                # Start BFS to find a new component\n                current_component = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_component.add((curr_r, curr_c))\n                    \n                    # Explore 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue  # Skip self\n                                \n                            nr, nc = curr_r + dr, curr_c + dc\n                            \n                            # Check grid boundaries\n                            if 0 <= nr < rows and 0 <= nc < cols:\n                                # Check if neighbor is non-background and not visited\n                                if grid[nr, nc] != bg_color and (nr, nc) not in visited:\n                                    visited.add((nr, nc))\n                                    q.append((nr, nc))\n                                    \n                if current_component: # Add component only if it's not empty\n                    components.append(current_component)\n                \n    return components\n\ndef _get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box of a component.\n\n    Args:\n        component (set): A set of (row, col) tuples representing the component.\n\n    Returns:\n        tuple: ((min_r, min_c), (max_r, max_c)) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n        \n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n    \n    return (min_r, min_c), (max_r, max_c)\n\ndef _apply_permutation(subgrid_3x3):\n    \"\"\"\n    Applies the specific pixel rearrangement to a 3x3 subgrid.\n\n    Args:\n        subgrid_3x3 (np.array): A 3x3 numpy array.\n\n    Returns:\n        np.array: The rearranged 3x3 numpy array.\n    \"\"\"\n    # Ensure the input is indeed 3x3\n    if subgrid_3x3.shape != (3, 3):\n        raise ValueError(\"Input subgrid must be 3x3\")\n\n    # Create a new 3x3 array to store the result\n    permuted_subgrid = np.zeros_like(subgrid_3x3)\n\n    # Apply the specific mapping\n    permuted_subgrid[0, 0] = subgrid_3x3[0, 2]\n    permuted_subgrid[0, 1] = subgrid_3x3[1, 0]\n    permuted_subgrid[0, 2] = subgrid_3x3[2, 0]\n    permuted_subgrid[1, 0] = subgrid_3x3[2, 1]\n    permuted_subgrid[1, 1] = subgrid_3x3[1, 1]\n    permuted_subgrid[1, 2] = subgrid_3x3[0, 1]\n    permuted_subgrid[2, 0] = subgrid_3x3[0, 0]\n    permuted_subgrid[2, 1] = subgrid_3x3[1, 2]\n    permuted_subgrid[2, 2] = subgrid_3x3[2, 2]\n    \n    return permuted_subgrid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by applying a specific permutation to 3x3 blocks\n    defined by the bounding boxes of non-orange connected components.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n    \n    # Define the background color (orange)\n    bg_color = 7\n    \n    # Find all connected components of non-background pixels\n    components = _find_non_bg_components(input_np, bg_color)\n    \n    # Process each component\n    for component in components:\n        # Calculate the bounding box of the component\n        bbox = _get_bounding_box(component)\n        if not bbox: # Should not happen if component is not empty, but check anyway\n            continue\n            \n        (min_r, min_c), (max_r, max_c) = bbox\n        \n        # Calculate the dimensions of the bounding box\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n        \n        # Check if the bounding box is exactly 3x3\n        if height == 3 and width == 3:\n            # Extract the 3x3 subgrid from the *original input* grid\n            subgrid = input_np[min_r : min_r + 3, min_c : min_c + 3]\n            \n            # Apply the permutation to the extracted subgrid\n            permuted_subgrid = _apply_permutation(subgrid)\n            \n            # Place the permuted subgrid into the *output* grid at the same location\n            output_np[min_r : min_r + 3, min_c : min_c + 3] = permuted_subgrid\n            \n    # Convert the final numpy array back to a list of lists for the required output format\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5541,
    "candidates_token_count": 1858,
    "total_token_count": 7399,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.994078,
  "retries": null
}