{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies horizontal and vertical separators (full rows/columns of yellow pixels).\nThese separators define a grid of rectangular regions.\nIterates through each region. If a region contains blue pixels (1):\n  1. Look for a 'source' color in the region directly ABOVE it (same column index, previous band index). The source color is the first pixel encountered in that region that is NOT white (0), yellow (4), or blue (1).\n  2. If no valid source color is found above (or if there is no region above), look for a source color in the region immediately to the LEFT (same band index, previous column index), using the same criteria (first non-white, non-yellow, non-blue pixel).\n  3. If a source color is found (from either above or left), replace ALL blue pixels within the original region with that source color in the output grid.\nRegions without blue pixels, separator lines, and non-blue pixels within modified regions remain unchanged.\n\"\"\"\n\ndef find_horizontal_separators(grid):\n    \"\"\"Finds indices of rows composed entirely of yellow (4).\"\"\"\n    num_rows, _ = grid.shape\n    # Check if grid has only one row, if so it cannot be a separator by itself\n    if num_rows <= 1:\n        return []\n    # Separator cannot be the very first or last row if grid height > 1\n    return [r for r in range(0, num_rows) if np.all(grid[r, :] == 4)]\n\n\ndef find_vertical_separators(grid):\n    \"\"\"Finds indices of columns composed entirely of yellow (4).\"\"\"\n    _, num_cols = grid.shape\n    # Check if grid has only one column, if so it cannot be a separator by itself\n    if num_cols <= 1:\n        return []\n    # Separator cannot be the very first or last col if grid width > 1\n    return [c for c in range(0, num_cols) if np.all(grid[:, c] == 4)]\n\ndef find_source_color_in_region(grid, row_start, row_end, col_start, col_end):\n    \"\"\"\n    Finds the first non-white (0), non-yellow (4), non-blue (1) pixel color\n    in a given region. Iterates row by row, then column by column.\n    Returns the color value or None if not found.\n    \"\"\"\n    # Ensure region bounds are valid before slicing\n    if row_start >= row_end or col_start >= col_end:\n        return None\n    \n    # Ensure bounds are within grid dimensions\n    num_rows, num_cols = grid.shape\n    row_start = max(0, row_start)\n    row_end = min(num_rows, row_end)\n    col_start = max(0, col_start)\n    col_end = min(num_cols, col_end)\n\n    # Check if adjusted bounds are still valid\n    if row_start >= row_end or col_start >= col_end:\n        return None\n        \n    region = grid[row_start:row_end, col_start:col_end]\n    \n    # Check if the slice is empty\n    if region.size == 0:\n        return None\n        \n    for r in range(region.shape[0]):\n        for c in range(region.shape[1]):\n            pixel_value = region[r, c]\n            if pixel_value not in [0, 1, 4]: # Check against white, blue, yellow\n                return pixel_value\n    return None # Indicate not found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on color replacement rules across regions\n    defined by yellow separators, using an 'Above, then Left' priority for finding\n    the non-white, non-yellow, non-blue source color.\n\n    Args:\n        input_grid (list of lists of int): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists of int: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    num_rows, num_cols = grid.shape\n\n    # 1. Identify global horizontal and vertical separators\n    h_sep_rows = find_horizontal_separators(grid)\n    v_sep_cols = find_vertical_separators(grid)\n\n    # 2. Define horizontal band boundaries (include implicit boundaries)\n    # Bands are rows *between* separators\n    band_row_boundaries = sorted(list(set([-1] + h_sep_rows + [num_rows])))\n\n    # 3. Define vertical region boundaries (include implicit boundaries)\n    # Regions are columns *between* separators\n    region_col_boundaries = sorted(list(set([-1] + v_sep_cols + [num_cols])))\n    \n    # Store region boundary info for easier lookup: regions[i][j] = (r_start, r_end, c_start, c_end)\n    regions = []\n    for i in range(len(band_row_boundaries) - 1):\n        r_start = band_row_boundaries[i] + 1\n        r_end = band_row_boundaries[i+1]\n        current_band_regions = []\n        if r_start >= r_end: # Skip empty bands between adjacent separators\n             regions.append([]) # Keep band structure consistent\n             continue\n             \n        for j in range(len(region_col_boundaries) - 1):\n            c_start = region_col_boundaries[j] + 1\n            c_end = region_col_boundaries[j+1]\n            if c_start >= c_end: # Skip empty regions between adjacent separators\n                current_band_regions.append(None) # Placeholder for empty region\n                continue\n            current_band_regions.append((r_start, r_end, c_start, c_end))\n        regions.append(current_band_regions)\n\n\n    # 4. Iterate through regions (bands first, then columns within bands)\n    for i in range(len(regions)): # band index\n        for j in range(len(regions[i])): # column index\n            \n            if regions[i][j] is None: # Skip if region was empty\n                continue\n                \n            r_start, r_end, c_start, c_end = regions[i][j]\n\n            # 5. Check if the current region contains blue\n            current_region_slice = grid[r_start:r_end, c_start:c_end]\n            if current_region_slice.size > 0 and np.any(current_region_slice == 1):\n                \n                source_color = None\n                \n                # 6a. Check Above\n                if i > 0 and j < len(regions[i-1]) and regions[i-1][j] is not None:\n                    above_r_start, above_r_end, above_c_start, above_c_end = regions[i-1][j]\n                    source_color = find_source_color_in_region(grid, above_r_start, above_r_end, above_c_start, above_c_end)\n\n                # 6b. Check Left (only if source not found above)\n                if source_color is None and j > 0 and regions[i][j-1] is not None:\n                    left_r_start, left_r_end, left_c_start, left_c_end = regions[i][j-1]\n                    source_color = find_source_color_in_region(grid, left_r_start, left_r_end, left_c_start, left_c_end)\n                    \n                # 7. Apply Transformation if source color found\n                if source_color is not None:\n                    # Iterate through the *output* grid in the current region's bounds\n                    for r in range(r_start, r_end):\n                        for c in range(c_start, c_end):\n                            if output_grid[r, c] == 1: # If the pixel is blue\n                                output_grid[r, c] = source_color # Replace with source color\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8679,
    "candidates_token_count": 1948,
    "total_token_count": 10627,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.589596,
  "retries": null
}