{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentify all distinct objects (connected groups of same non-white pixels) in the input grid.\nCalculate the size (pixel count) of each object.\nDetermine the frequency of each size.\nCount how many sizes appear only once (unique sizes).\n\nSelection Logic:\n1. If exactly one unique size exists, select the object with that unique size.\n2. If all object sizes are unique, calculate the average size of all objects and select the object whose size is numerically closest to the average.\n\nOutput:\nCrop the input grid to the minimal bounding box of the selected object.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-white color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({'color': color, 'coords': obj_coords})\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the minimal bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col)\n    \"\"\"\n    if not coords:\n        return None\n    min_row = min(r for r, c in coords)\n    min_col = min(c for r, c in coords)\n    max_row = max(r for r, c in coords)\n    max_col = max(c for r, c in coords)\n    return min_row, min_col, max_row, max_col\n\ndef crop_grid(grid, bbox):\n    \"\"\"\n    Extracts a subgrid defined by the bounding box.\n\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): (min_row, min_col, max_row, max_col)\n\n    Returns:\n        np.array: The cropped subgrid.\n    \"\"\"\n    min_row, min_col, max_row, max_col = bbox\n    return grid[min_row:max_row+1, min_col:max_col+1]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Find all objects\n    objects = find_objects(input_grid)\n    if not objects:\n        # Handle edge case: no objects found (return empty or based on convention)\n        return np.array([[]])\n\n    # 2. Calculate sizes for each object\n    for obj in objects:\n        obj['size'] = len(obj['coords'])\n\n    # 3. Analyze sizes\n    sizes = [obj['size'] for obj in objects]\n    size_counts = Counter(sizes)\n    unique_sizes = [size for size, count in size_counts.items() if count == 1]\n\n    selected_object = None\n\n    # 4. Apply selection logic\n    if len(unique_sizes) == 1:\n        # Case 1: Exactly one unique size\n        unique_size_value = unique_sizes[0]\n        for obj in objects:\n            if obj['size'] == unique_size_value:\n                selected_object = obj\n                break\n    elif len(unique_sizes) == len(objects):\n         # Case 2: All sizes are unique\n        if len(objects) == 1: # If only one object, it must be selected\n             selected_object = objects[0]\n        else:\n            average_size = sum(sizes) / len(sizes)\n            min_diff = float('inf')\n            # Find object closest to average size\n            for obj in objects:\n                diff = abs(obj['size'] - average_size)\n                if diff < min_diff:\n                    min_diff = diff\n                    selected_object = obj\n                # Simple tie-breaking: keep the first one found with min_diff\n    else:\n         # Case 3: Other scenarios (e.g., multiple non-unique sizes, no unique sizes)\n         # The provided examples don't cover this. If this occurs, the logic is undefined.\n         # Returning an empty grid or raising an error might be appropriate.\n         # For now, let's assume the examples cover all expected scenarios.\n         # If we must return something, maybe return the largest object? Or smallest?\n         # Let's stick to the defined logic for now.\n         # If no selection rule matched, selected_object remains None.\n         pass # selected_object will remain None\n\n\n    if selected_object is None:\n         # This case should ideally not happen based on the examples,\n         # but as a fallback, perhaps return an empty grid or the input?\n         # Let's return an empty 1x1 grid with background color for now.\n         print(\"Warning: No selection rule matched. Returning default.\")\n         return np.array([[0]])\n\n\n    # 5. Get bounding box of the selected object\n    bbox = get_bounding_box(selected_object['coords'])\n\n    # 6. Create output grid by cropping\n    # We need to create a new grid based on the object's pixels within its bounding box\n    min_row, min_col, max_row, max_col = bbox\n    output_height = max_row - min_row + 1\n    output_width = max_col - min_col + 1\n    output_grid = np.zeros((output_height, output_width), dtype=int) # Default to background color\n\n    for r, c in selected_object['coords']:\n        output_grid[r - min_row, c - min_col] = selected_object['color']\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2730,
    "candidates_token_count": 1606,
    "total_token_count": 4336,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.907893,
  "retries": null
}