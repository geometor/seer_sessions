{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify Red Components: Find all distinct groups of connected red pixels (color 2) in the input grid. Connectivity includes horizontal, vertical, and diagonal neighbors (8-way connectivity).\n2.  Count Components: Count the number of these distinct red groups.\n3.  Determine Output based on Count and Symmetry:\n    *   If the number of red components is greater than one, the output is a 1x1 grid containing a single blue pixel (color 1).\n    *   If the number of red components is exactly one:\n        *   Isolate the shape formed by the red pixels of this single component within its minimal bounding box.\n        *   Check if this isolated shape has horizontal reflectional symmetry (looks the same when flipped top-to-bottom).\n        *   Check if this isolated shape has vertical reflectional symmetry (looks the same when flipped left-to-right).\n        *   If the shape possesses either horizontal or vertical symmetry (or both), the output is a 1x1 grid containing a single blue pixel (color 1).\n        *   If the shape possesses neither horizontal nor vertical symmetry, the output is a 1x1 grid containing a single orange pixel (color 7).\n    *   If the number of red components is zero, the output is a 1x1 grid containing a single blue pixel (color 1). (This handles cases not present in the examples, assuming a default behavior consistent with the multi-component rule).\n4.  Produce Output: Create the 1x1 output grid with the determined color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_connected_components(grid, target_color):\n    \"\"\"\n    Finds all connected components of a specified color in a grid using 8-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color of the pixels to form components.\n\n    Returns:\n        list: A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == target_color and not visited[r, c]:\n                # Start BFS for a new component\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component.append((curr_r, curr_c))\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds, target color, and visited status\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component:\n                    components.append(component)\n    return components\n\ndef extract_component_shape(grid, component):\n    \"\"\"\n    Extracts the minimal bounding box shape of a component.\n\n    Args:\n        grid (np.array): The original input grid (needed for color).\n        component (list): A list of (row, col) tuples for the component.\n\n    Returns:\n        np.array: A minimal grid representing the component's shape.\n                  Pixels belonging to the component have their original color, others are 0.\n                  Returns an empty array if the component is empty.\n    \"\"\"\n    if not component:\n        # Return an empty array or handle as appropriate if an empty component is possible\n        return np.array([[]], dtype=int) \n\n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    \n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    shape_grid = np.zeros((height, width), dtype=int)\n    \n    target_color = grid[component[0][0], component[0][1]] # Get color from first pixel\n\n    for r, c in component:\n        # Place the target color in the relative position within the bounding box\n        shape_grid[r - min_r, c - min_c] = target_color\n        \n    return shape_grid\n\ndef check_horizontal_symmetry(shape):\n    \"\"\"Checks for horizontal reflectional symmetry (flip top-to-bottom).\"\"\"\n    if shape.size == 0: # Handle empty shape case\n        return False \n    return np.array_equal(shape, np.flipud(shape))\n\ndef check_vertical_symmetry(shape):\n    \"\"\"Checks for vertical reflectional symmetry (flip left-to-right).\"\"\"\n    if shape.size == 0: # Handle empty shape case\n        return False\n    return np.array_equal(shape, np.fliplr(shape))\n\ndef transform(input_grid):\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid, dtype=int)\n        \n    # Define colors\n    red_color = 2\n    blue_color = 1\n    orange_color = 7\n    \n    output_color = blue_color # Default output color\n\n    # 1. Find connected components of red pixels\n    components = find_connected_components(input_grid, red_color)\n\n    # 2. Count the components\n    num_components = len(components)\n\n    # 3. Determine output based on count and symmetry\n    if num_components == 1:\n        # a. Isolate the shape\n        single_component = components[0]\n        shape = extract_component_shape(input_grid, single_component)\n\n        # b. Check horizontal and vertical symmetries\n        has_hor_sym = check_horizontal_symmetry(shape)\n        has_ver_sym = check_vertical_symmetry(shape)\n\n        # c. If NEITHER symmetry exists, output orange\n        if not has_hor_sym and not has_ver_sym:\n            output_color = orange_color\n        # d. Otherwise (at least one symmetry exists), output remains blue (default)\n        # else: output_color = blue_color (already default)\n\n    # If num_components > 1 or num_components == 0, output remains blue (default)\n    # else: output_color = blue_color (already default)\n\n    # 4. Produce the 1x1 output grid\n    output_grid = np.array([[output_color]], dtype=int)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6290,
    "candidates_token_count": 1644,
    "total_token_count": 7934,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.314515,
  "retries": null
}