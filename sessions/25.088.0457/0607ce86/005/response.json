{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nIdentifies repeating block patterns in an input grid, potentially obscured by noise pixels (green=3). \nIt first identifies all connected components of non-background (white=0) pixels, including noise pixels. \nIt determines the most frequent bounding box size among these components. Then, it extracts full block \ninstances (including any noise pixels within them) from the original grid at the locations corresponding \nto the common-sized components. A \"canonical\" pattern for this block size is derived by finding the most \nfrequent non-noise, non-background color at each position across all instances. If only noise and/or \nbackground pixels are present at a position, noise becomes the canonical color if it was present, otherwise \nbackground. Finally, it constructs an output grid containing only these block instances, placed at their \noriginal locations. Within each placed block, pixels that were noise (green=3) in the input are replaced \nby the corresponding canonical pixel, but only if the canonical pixel itself is not noise (green=3). \nAll pixels outside the placed blocks are set to background (white=0).\n\"\"\"\n\ndef _find_blocks_and_derive_pattern(grid, background_color=0, noise_color=3):\n    \"\"\"\n    Finds potential pattern blocks (including noise), determines the most \n    common bounding box size, extracts full block instances of that size from \n    the original grid, and infers the canonical pattern.\n\n    Args:\n        grid (np.array): Input grid.\n        background_color (int): Color representing the background.\n        noise_color (int): Color representing noise pixels.\n\n    Returns:\n        tuple: (canonical_pattern, common_size, valid_locations, valid_instances)\n               - canonical_pattern (np.array or None): The inferred pattern.\n               - common_size (tuple or None): The (height, width) of common blocks.\n               - valid_locations (list): List of (row, col) top-left corners.\n               - valid_instances (list): List of original np.array subgrids corresponding\n                                        to valid_locations.\n               Returns (None, None, [], []) if no common blocks are found.\n    \"\"\"\n    # 1. Identify Potential Pattern Blocks: Create a mask for all non-background pixels\n    component_mask = (grid != background_color)\n    \n    # Label connected components of these potential structures\n    labeled_grid, num_labels = label(component_mask)\n    \n    # 2. Determine bounding boxes for components\n    objects_slices = find_objects(labeled_grid)\n\n    if not objects_slices: # Handle cases with no components\n        return None, None, [], []\n\n    # Calculate sizes and locations based on component bounding boxes\n    sizes = []\n    locations = [] # Store top-left corner (r_start, c_start)\n    component_indices = [] # Store index corresponding to size/location\n    \n    for i, slc in enumerate(objects_slices):\n        if slc is None: \n            continue\n        # Ensure the slices are valid tuples of slice objects\n        if not (isinstance(slc, tuple) and len(slc) == 2 and \n                isinstance(slc[0], slice) and isinstance(slc[1], slice)):\n             continue # Skip invalid slice formats\n\n        r_start, r_stop = slc[0].start, slc[0].stop\n        c_start, c_stop = slc[1].start, slc[1].stop\n        height = r_stop - r_start\n        width = c_stop - c_start\n        \n        # Store size and location if the slice is valid\n        if height > 0 and width > 0:\n            sizes.append((height, width))\n            locations.append((r_start, c_start))\n            component_indices.append(i) # Keep track of which original component this is\n\n    if not sizes:\n        return None, None, [], []\n\n    # 3. Find Dominant Block Size\n    size_counts = Counter(sizes)\n    if not size_counts:\n         return None, None, [], []\n    # Find the most common size based on components\n    # If there's a tie, Counter picks one arbitrarily, which is acceptable here.\n    most_common_size = size_counts.most_common(1)[0][0]\n    common_height, common_width = most_common_size\n\n    # 4. Extract Valid Instances from *original grid* based on common size and locations\n    valid_instances = []\n    valid_locations = []\n    grid_height, grid_width = grid.shape\n    \n    processed_locations = set() # Avoid processing overlapping components leading to same instance extraction\n\n    for i, size in enumerate(sizes):\n        if size == most_common_size:\n            r_start, c_start = locations[i]\n            \n            # Ensure the instance extraction uses the *determined common size*, not necessarily the \n            # component's exact bounding box if it was slightly off but classified as common.\n            # Also check if the block fits within the grid using the common size.\n            if r_start + common_height <= grid_height and c_start + common_width <= grid_width:\n                 # Check if this location has essentially been processed already \n                 # (e.g., if two components are within the same target block area)\n                 # We only store one instance per top-left corner of the common size block\n                 if (r_start, c_start) not in processed_locations:\n                    instance = grid[r_start : r_start + common_height, c_start : c_start + common_width]\n                    # Double check extracted shape just in case (should match common_size)\n                    if instance.shape == most_common_size:\n                        valid_instances.append(instance)\n                        valid_locations.append((r_start, c_start))\n                        processed_locations.add((r_start, c_start))\n            # else: # Optional: log if a potential block is cut off by grid edge\n                # print(f\"Component at {locations[i]} suggests block size {most_common_size}, but instance doesn't fit grid.\")\n\n\n    if not valid_instances:\n        # No instances matching the most common size could be extracted\n        return None, None, [], []\n\n    # 5. Derive Canonical Pattern\n    canonical_pattern = np.full(most_common_size, background_color, dtype=int) # Initialize with background\n    num_valid_instances = len(valid_instances)\n\n    for r in range(common_height):\n        for c in range(common_width):\n            # Collect colors at this position (r, c) from all valid instances\n            pixel_colors = [instance[r, c] for instance in valid_instances]\n            if not pixel_colors: continue \n\n            color_counts = Counter(pixel_colors)\n\n            # Separate counts for non-noise, non-background colors\n            core_color_counts = {\n                color: count for color, count in color_counts.items() \n                if color != noise_color and color != background_color\n            }\n            \n            if core_color_counts:\n                # 4.c: If non-noise, non-background colors exist, find the most frequent among them\n                most_frequent_core_color = max(core_color_counts, key=core_color_counts.get)\n                canonical_pattern[r, c] = most_frequent_core_color\n            elif noise_color in color_counts:\n                 # 4.d: If only noise and/or background are present, and noise is present, canonical is noise\n                 canonical_pattern[r, c] = noise_color\n            # 4.e: Otherwise (only background was present), it remains background (due to initialization)\n\n\n    return canonical_pattern, most_common_size, valid_locations, valid_instances\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying repeating patterns (including noise), \n    deriving a canonical form, repairing noise within pattern instances based on the\n    canonical form, and reconstructing the grid with only these repaired instances.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n    noise_color = 3\n\n    # Steps 1-5: Find components, common size, extract instances, derive canonical pattern\n    canonical_pattern, common_size, block_locations, block_instances = \\\n        _find_blocks_and_derive_pattern(input_np, background_color, noise_color)\n\n    # 5.a: Initialize output grid with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # If no consistent blocks were found, return the empty background grid\n    if canonical_pattern is None or not block_locations:\n        return output_grid.tolist()\n\n    block_height, block_width = common_size\n\n    # 5.b: Iterate through the stored valid instances and locations\n    for idx, (r_start, c_start) in enumerate(block_locations):\n        # 5.c: Process each instance\n        instance = block_instances[idx] # Get the original block instance content\n        \n        # 5.c.i: Create a temporary block to store the repaired version\n        repaired_block = np.copy(instance)\n\n        # 5.c.ii: Iterate through each pixel of the instance to apply repair logic\n        for r in range(block_height):\n            for c in range(block_width):\n                # 5.c.iii: Get original and canonical pixel values\n                original_pixel = instance[r, c]\n                canonical_pixel = canonical_pattern[r, c]\n\n                # 5.c.v: Repair Rule: Replace input pixel if it's noise AND canonical is NOT noise\n                if original_pixel == noise_color and canonical_pixel != noise_color:\n                    repaired_block[r, c] = canonical_pixel\n                # Otherwise, repaired_block[r, c] retains the value from the copied instance\n\n        # 5.c.vi: Place the (potentially) repaired block onto the output grid\n        # Ensure placement doesn't exceed output grid bounds (shouldn't happen if extraction was correct)\n        end_row = min(r_start + block_height, height)\n        end_col = min(c_start + block_width, width)\n        output_grid[r_start : end_row, c_start : end_col] = repaired_block[0:(end_row-r_start), 0:(end_col-c_start)]\n\n\n    # Step 6: Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20220,
    "candidates_token_count": 2506,
    "total_token_count": 22726,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.362448,
  "retries": null
}