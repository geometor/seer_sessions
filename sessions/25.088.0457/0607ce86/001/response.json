{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nIdentifies repeating block structures in the input grid, ignoring scattered\nnoise pixels (green=3). It determines the most common block size and infers\na 'canonical' pattern for blocks of this size by finding the most frequent\nnon-noise color at each position across all instances. It then constructs\nan output grid containing only these blocks, where any green pixels within\na block instance that deviate from the inferred canonical pattern are\nreplaced by the canonical color at that position. All other pixels (background,\nscattered noise, blocks of non-standard size) are set to background (white=0).\n\"\"\"\n\ndef _find_blocks_and_derive_pattern(grid, background_color=0, noise_color=3):\n    \"\"\"\n    Finds non-background connected components, determines the most common\n    bounding box size, extracts blocks of that size, and infers the\n    canonical pattern.\n\n    Args:\n        grid (np.array): Input grid.\n        background_color (int): Color representing the background.\n        noise_color (int): Color representing noise pixels to be potentially repaired.\n\n    Returns:\n        tuple: (canonical_pattern, common_size, valid_locations, valid_blocks)\n               - canonical_pattern (np.array or None): The inferred pattern.\n               - common_size (tuple or None): The (height, width) of common blocks.\n               - valid_locations (list): List of (row, col) top-left corners.\n               - valid_blocks (list): List of original np.array subgrids corresponding\n                                      to valid_locations.\n               Returns (None, None, [], []) if no common blocks are found.\n    \"\"\"\n    # Label connected components of non-background pixels\n    labeled_grid, num_labels = label(grid != background_color)\n    # Find the bounding box slices for each labeled component\n    objects_slices = find_objects(labeled_grid)\n\n    blocks = []\n    locations = []\n    sizes = []\n\n    if not objects_slices: # Handle empty or all-background grids\n        return None, None, [], []\n\n    # Extract blocks based on bounding boxes and record sizes/locations\n    for i, slc in enumerate(objects_slices):\n        if slc is None: # Might happen with empty labels\n             continue\n        r_start, r_stop = slc[0].start, slc[0].stop\n        c_start, c_stop = slc[1].start, slc[1].stop\n        height = r_stop - r_start\n        width = c_stop - c_start\n\n        # Extract the subgrid defined by the bounding box\n        subgrid_bbox = grid[r_start:r_stop, c_start:c_stop]\n\n        # Only store if the extracted subgrid is not empty\n        if subgrid_bbox.size > 0:\n            blocks.append(subgrid_bbox)\n            locations.append((r_start, c_start))\n            sizes.append((height, width))\n\n    if not sizes:\n        return None, None, [], []\n\n    # Find the most common block size (dimensions)\n    size_counts = Counter(sizes)\n    if not size_counts:\n         return None, None, [], []\n    most_common_size = size_counts.most_common(1)[0][0]\n    block_height, block_width = most_common_size\n\n    # Filter blocks and locations to keep only those matching the most common size\n    valid_blocks = []\n    valid_locations = []\n    for i, size in enumerate(sizes):\n        if size == most_common_size:\n            # Double check the shape of the extracted block\n            if blocks[i].shape == most_common_size:\n                 valid_blocks.append(blocks[i])\n                 valid_locations.append(locations[i])\n\n    if not valid_blocks:\n        # If no blocks match the most common size after shape check (unlikely but possible)\n        return None, None, [], []\n\n    # Infer the canonical pattern from the valid blocks\n    canonical_pattern = np.full((block_height, block_width), background_color, dtype=int)\n    num_valid_blocks = len(valid_blocks)\n\n    for r in range(block_height):\n        for c in range(block_width):\n            # Collect colors at this position (r, c) from all valid blocks\n            pixel_colors = [block[r, c] for block in valid_blocks if r < block.shape[0] and c < block.shape[1]] # Safety check\n            if not pixel_colors: continue # Should not happen with current logic\n\n            color_counts = Counter(pixel_colors)\n\n            # Separate counts for noise vs non-noise colors\n            non_noise_counts = {color: count for color, count in color_counts.items() if color != noise_color}\n\n            if non_noise_counts:\n                # If non-noise colors exist, find the most frequent among them\n                most_frequent_non_noise = max(non_noise_counts, key=non_noise_counts.get)\n                canonical_pattern[r, c] = most_frequent_non_noise\n            elif color_counts:\n                # If only noise or background colors are present, take the most frequent overall\n                most_frequent_overall = color_counts.most_common(1)[0][0]\n                canonical_pattern[r, c] = most_frequent_overall\n            # else: # If color_counts is somehow empty, it defaults to background_color\n\n    return canonical_pattern, most_common_size, valid_locations, valid_blocks\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies repeating block structures, infers a canonical pattern, repairs\n    noise pixels within blocks based on this pattern, and constructs the output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n    noise_color = 3\n\n    # Step 1: Find blocks, determine the common size, extract instances, and infer the canonical pattern\n    canonical_pattern, common_size, block_locations, original_blocks = \\\n        _find_blocks_and_derive_pattern(input_np, background_color, noise_color)\n\n    # Step 2: Initialize the output grid with the background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # Step 3: If no consistent blocks were found, return the empty background grid\n    if canonical_pattern is None or not block_locations:\n        return output_grid.tolist()\n\n    block_height, block_width = common_size\n\n    # Step 4: Iterate through each identified block instance\n    for idx, (r, c) in enumerate(block_locations):\n        input_subgrid = original_blocks[idx] # Get the original block content\n\n        # Basic sanity check (should already be filtered by the helper function)\n        if input_subgrid.shape != (block_height, block_width):\n             continue\n\n        # Create a copy of the input subgrid to modify for the output\n        repaired_subgrid = np.copy(input_subgrid)\n\n        # Step 5: Repair the subgrid based on the canonical pattern\n        for i in range(block_height):\n            for j in range(block_width):\n                input_pixel = input_subgrid[i, j]\n                canonical_pixel = canonical_pattern[i, j]\n\n                # The core repair rule:\n                # If the pixel in the input block is the noise color (3)\n                # AND it differs from the corresponding pixel in the canonical pattern,\n                # then replace it with the canonical pattern's pixel.\n                if input_pixel == noise_color and input_pixel != canonical_pixel:\n                    repaired_subgrid[i, j] = canonical_pixel\n                # Otherwise, the pixel remains as it was in the input_subgrid (already copied to repaired_subgrid)\n\n        # Step 6: Place the (potentially) repaired subgrid onto the output grid\n        # Ensure placement doesn't go out of bounds (shouldn't happen if locations are correct)\n        end_r, end_c = r + block_height, c + block_width\n        if end_r <= height and end_c <= width:\n             output_grid[r:end_r, c:end_c] = repaired_subgrid\n        # else: # Log error if placement is out of bounds\n             # print(f\"Warning: Block placement at ({r},{c}) with size {common_size} exceeds grid bounds ({height},{width})\")\n\n\n    # Step 7: Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8322,
    "candidates_token_count": 2033,
    "total_token_count": 10355,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.768824,
  "retries": null
}