{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies repeating rectangular patterns (blocks) within the input grid, which may be corrupted by noise pixels (green=3). It cleans these blocks based on a derived 'canonical' pattern and removes any elements outside these blocks.\n\n1.  **Identify Core Structures:** Find connected components of pixels that are *neither* background (white=0) *nor* noise (green=3). These represent the stable parts of the patterns.\n2.  **Determine Common Block Size:** Calculate the bounding box size for each core structure. Identify the most frequently occurring size. This is assumed to be the size of the repeating pattern block.\n3.  **Locate Pattern Instances:** Find the top-left corner coordinates of all core structures whose bounding box matches the common size.\n4.  **Extract Noisy Instances:** Using the locations from step 3 and the common block size, extract the corresponding rectangular regions from the *original input grid*. These are the potentially noisy instances of the pattern.\n5.  **Derive Canonical Pattern:** Create a template pattern of the common block size. For each position (row, col) within the block:\n    a.  Collect the colors found at that position across all extracted noisy instances.\n    b.  Count the occurrences of each color.\n    c.  Determine the canonical color for this position:\n        i.  Find the most frequent color that is *not* noise (3) and *not* background (0). If such a color exists, it becomes the canonical color.\n        ii. If only noise and/or background colors were found, the canonical color becomes noise (3) if noise was present at least once.\n        iii. Otherwise (only background was present), the canonical color is background (0).\n6.  **Reconstruct Output Grid:**\n    a.  Initialize an output grid of the same size as the input, filled with the background color (0).\n    b.  For each located pattern instance (using the locations from step 3):\n        i.  Get the corresponding noisy instance extracted in step 4.\n        ii. Create a 'repaired' block, initially a copy of the noisy instance.\n        iii. Iterate through each pixel (row, col) within this block.\n        iv. If the pixel in the noisy instance is noise (3) *and* the corresponding pixel in the canonical pattern is *not* noise (3), replace the pixel in the 'repaired' block with the canonical pixel value.\n        v.  Place this 'repaired' block onto the output grid at its original location.\n7.  Return the final output grid. Pixels outside the identified and repaired blocks remain background.\n\"\"\"\n\ndef _find_blocks_and_derive_pattern(grid, background_color=0, noise_color=3):\n    \"\"\"\n    Finds potential pattern blocks based on non-noise/non-background pixels, \n    determines the most common bounding box size, extracts full block instances \n    (including noise) of that size from the original grid, and infers the \n    canonical pattern.\n\n    Args:\n        grid (np.array): Input grid.\n        background_color (int): Color representing the background.\n        noise_color (int): Color representing noise pixels.\n\n    Returns:\n        tuple: (canonical_pattern, common_size, valid_locations, valid_instances)\n               - canonical_pattern (np.array or None): The inferred pattern.\n               - common_size (tuple or None): The (height, width) of common blocks.\n               - valid_locations (list): List of (row, col) top-left corners.\n               - valid_instances (list): List of original np.array subgrids corresponding\n                                        to valid_locations.\n               Returns (None, None, [], []) if no common blocks are found.\n    \"\"\"\n    grid_height, grid_width = grid.shape\n    \n    # 1. Identify Core Structures: Mask for non-background and non-noise pixels\n    core_mask = (grid != background_color) & (grid != noise_color)\n    \n    # Label connected components of these core structures\n    labeled_grid, num_labels = label(core_mask)\n    \n    # 2. Determine bounding boxes for core components\n    objects_slices = find_objects(labeled_grid)\n\n    if not objects_slices: # Handle cases with no core components\n        return None, None, [], []\n\n    # Calculate sizes and locations based on core component bounding boxes\n    sizes = []\n    locations = [] # Store top-left corner (r_start, c_start)\n    \n    for i, slc in enumerate(objects_slices):\n        if slc is None: \n            continue\n        # Ensure the slices are valid tuples of slice objects\n        if not (isinstance(slc, tuple) and len(slc) == 2 and \n                isinstance(slc[0], slice) and isinstance(slc[1], slice)):\n             continue # Skip invalid slice formats\n\n        r_start, r_stop = slc[0].start, slc[0].stop\n        c_start, c_stop = slc[1].start, slc[1].stop\n        height = r_stop - r_start\n        width = c_stop - c_start\n        \n        # Store size and location if the slice is valid\n        if height > 0 and width > 0:\n            sizes.append((height, width))\n            locations.append((r_start, c_start))\n\n    if not sizes:\n        return None, None, [], []\n\n    # 3. Find Dominant Block Size (based on core components)\n    size_counts = Counter(sizes)\n    if not size_counts:\n         return None, None, [], []\n    most_common_size = size_counts.most_common(1)[0][0]\n    common_height, common_width = most_common_size\n\n    # 4. Extract Valid Noisy Instances from *original grid* based on common size and locations\n    valid_instances = []\n    valid_locations = []\n    \n    processed_locations = set() # Avoid storing duplicate instances if core components overlap conceptually\n\n    for i, size in enumerate(sizes):\n        if size == most_common_size:\n            r_start, c_start = locations[i]\n            \n            # Check if the block fits within the grid using the *common size*.\n            if r_start + common_height <= grid_height and c_start + common_width <= grid_width:\n                 # Check if this location has essentially been processed already \n                 # We only store one instance per top-left corner of the common size block\n                 if (r_start, c_start) not in processed_locations:\n                    # Extract from the ORIGINAL grid to include noise\n                    instance = grid[r_start : r_start + common_height, c_start : c_start + common_width]\n                    # Double check extracted shape just in case\n                    if instance.shape == most_common_size:\n                        valid_instances.append(instance)\n                        valid_locations.append((r_start, c_start))\n                        processed_locations.add((r_start, c_start))\n\n    if not valid_instances:\n        # No instances matching the most common size could be extracted\n        return None, None, [], []\n\n    # 5. Derive Canonical Pattern\n    canonical_pattern = np.full(most_common_size, background_color, dtype=int) # Initialize with background\n    num_valid_instances = len(valid_instances)\n\n    for r in range(common_height):\n        for c in range(common_width):\n            # Collect colors at this position (r, c) from all valid instances\n            pixel_colors = [instance[r, c] for instance in valid_instances]\n            if not pixel_colors: continue \n\n            color_counts = Counter(pixel_colors)\n\n            # Separate counts for non-noise, non-background colors\n            core_color_counts = {\n                color: count for color, count in color_counts.items() \n                if color != noise_color and color != background_color\n            }\n            \n            # 5.c.i: Find most frequent non-noise, non-background color\n            if core_color_counts:\n                most_frequent_core_color = max(core_color_counts, key=core_color_counts.get)\n                canonical_pattern[r, c] = most_frequent_core_color\n            # 5.c.ii: If only noise/background, check if noise exists\n            elif noise_color in color_counts:\n                 canonical_pattern[r, c] = noise_color\n            # 5.c.iii: Otherwise, it remains background (due to initialization)\n\n\n    return canonical_pattern, most_common_size, valid_locations, valid_instances\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying repeating patterns (including noise), \n    deriving a canonical form, repairing noise within pattern instances based on the\n    canonical form, and reconstructing the grid with only these repaired instances.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n    noise_color = 3\n\n    # Steps 1-5: Find core components, common size, extract noisy instances, derive canonical pattern\n    canonical_pattern, common_size, block_locations, block_instances = \\\n        _find_blocks_and_derive_pattern(input_np, background_color, noise_color)\n\n    # 6.a: Initialize output grid with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # If no consistent blocks were found, return the empty background grid\n    if canonical_pattern is None or not block_locations:\n        return output_grid.tolist()\n\n    block_height, block_width = common_size\n\n    # 6.b: Iterate through the located instances\n    for idx, (r_start, c_start) in enumerate(block_locations):\n        # 6.b.i: Get the original noisy block instance content\n        instance = block_instances[idx] \n        \n        # 6.b.ii: Create a temporary block to store the repaired version\n        repaired_block = np.copy(instance)\n\n        # 6.b.iii: Iterate through each pixel of the instance to apply repair logic\n        for r in range(block_height):\n            for c in range(block_width):\n                # Get original and canonical pixel values\n                original_pixel = instance[r, c]\n                canonical_pixel = canonical_pattern[r, c]\n\n                # 6.b.iv: Repair Rule: Replace input pixel if it's noise AND canonical is NOT noise\n                if original_pixel == noise_color and canonical_pixel != noise_color:\n                    repaired_block[r, c] = canonical_pixel\n                # Otherwise, repaired_block[r, c] retains the value from the copied instance (which was the original noisy pixel)\n\n        # 6.b.v: Place the (potentially) repaired block onto the output grid\n        # Ensure placement doesn't exceed output grid bounds \n        end_row = min(r_start + block_height, height)\n        end_col = min(c_start + block_width, width)\n        # Ensure the slice of the repaired block matches the target area size\n        output_grid[r_start : end_row, c_start : end_col] = repaired_block[0:(end_row-r_start), 0:(end_col-c_start)]\n\n    # Step 7: Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12509,
    "candidates_token_count": 2696,
    "total_token_count": 15205,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 125.024407,
  "retries": null
}