{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nIdentifies repeating block patterns in an input grid, potentially obscured by \nnoise pixels (green=3). It first identifies \"core structures\" by looking for \nconnected components of non-background (white=0) and non-noise (green=3) pixels. \nIt determines the most frequent bounding box size among these core structures. \nThen, it extracts full block instances (including any noise pixels within them) \nfrom the original grid at the locations corresponding to the common-sized core \nstructures. A \"canonical\" pattern for this block size is derived by finding the \nmost frequent non-noise color at each position across all instances. If only noise \nis present at a position, noise becomes the canonical color. Finally, it constructs \nan output grid containing only these block instances, placed at their original \nlocations. Within each placed block, pixels that were noise (green=3) in the input \nare replaced by the corresponding canonical pixel, but only if the canonical pixel \nitself is not noise (green=3). All pixels outside the placed blocks are set to \nbackground (white=0).\n\"\"\"\n\ndef _find_blocks_and_derive_pattern(grid, background_color=0, noise_color=3):\n    \"\"\"\n    Finds core structures (non-background, non-noise), determines the most \n    common bounding box size, extracts full block instances of that size from \n    the original grid, and infers the canonical pattern.\n\n    Args:\n        grid (np.array): Input grid.\n        background_color (int): Color representing the background.\n        noise_color (int): Color representing noise pixels.\n\n    Returns:\n        tuple: (canonical_pattern, common_size, valid_locations, valid_instances)\n               - canonical_pattern (np.array or None): The inferred pattern.\n               - common_size (tuple or None): The (height, width) of common blocks.\n               - valid_locations (list): List of (row, col) top-left corners.\n               - valid_instances (list): List of original np.array subgrids corresponding\n                                        to valid_locations.\n               Returns (None, None, [], []) if no common blocks are found.\n    \"\"\"\n    # 1. Identify core structures: Create a mask for non-background and non-noise pixels\n    core_mask = (grid != background_color) & (grid != noise_color)\n    \n    # Label connected components of these core structures\n    labeled_grid, num_labels = label(core_mask)\n    \n    # 2. Determine bounding boxes for core structures\n    objects_slices = find_objects(labeled_grid)\n\n    if not objects_slices: # Handle cases with no core structures\n        return None, None, [], []\n\n    # Calculate sizes and locations based on core structure bounding boxes\n    sizes = []\n    locations = [] # Store top-left corner (r_start, c_start)\n    for i, slc in enumerate(objects_slices):\n        if slc is None: \n            continue\n        r_start, r_stop = slc[0].start, slc[0].stop\n        c_start, c_stop = slc[1].start, slc[1].stop\n        height = r_stop - r_start\n        width = c_stop - c_start\n        \n        # Store size and location if the slice is valid\n        if height > 0 and width > 0:\n            sizes.append((height, width))\n            locations.append((r_start, c_start))\n\n    if not sizes:\n        return None, None, [], []\n\n    # 3. Find common size\n    size_counts = Counter(sizes)\n    if not size_counts:\n         return None, None, [], []\n    # Find the most common size based on core structures\n    # If there's a tie, Counter picks one arbitrarily, which is acceptable here.\n    most_common_size = size_counts.most_common(1)[0][0]\n    common_height, common_width = most_common_size\n\n    # 4. Extract instances from *original grid* based on common size and locations\n    valid_instances = []\n    valid_locations = []\n    grid_height, grid_width = grid.shape\n    \n    processed_locations = set() # Avoid processing overlapping core structures leading to same instance\n\n    for i, size in enumerate(sizes):\n        if size == most_common_size:\n            r_start, c_start = locations[i]\n            \n            # Ensure the full block instance fits within the grid boundaries\n            if r_start + common_height <= grid_height and c_start + common_width <= grid_width:\n                 # Check if this location has essentially been processed already \n                 # (e.g., if two tiny core structures are within the same target block area)\n                 # We only store one instance per top-left corner of the common size block\n                 if (r_start, c_start) not in processed_locations:\n                    instance = grid[r_start : r_start + common_height, c_start : c_start + common_width]\n                    # Double check extracted shape just in case\n                    if instance.shape == most_common_size:\n                        valid_instances.append(instance)\n                        valid_locations.append((r_start, c_start))\n                        processed_locations.add((r_start, c_start))\n            # else: # Optional: log if a potential block is cut off by grid edge\n                # print(f\"Core structure at {locations[i]} suggests block size {most_common_size}, but instance doesn't fit grid.\")\n\n\n    if not valid_instances:\n        # No instances matching the most common size could be extracted\n        return None, None, [], []\n\n    # 5. Derive canonical pattern\n    canonical_pattern = np.full(most_common_size, background_color, dtype=int)\n    num_valid_instances = len(valid_instances)\n\n    for r in range(common_height):\n        for c in range(common_width):\n            # Collect colors at this position (r, c) from all valid instances\n            pixel_colors = [instance[r, c] for instance in valid_instances]\n            if not pixel_colors: continue \n\n            color_counts = Counter(pixel_colors)\n\n            # Separate counts for noise vs non-noise colors\n            non_noise_counts = {color: count for color, count in color_counts.items() if color != noise_color and color != background_color}\n            \n            if non_noise_counts:\n                # If non-noise colors (other than background) exist, find the most frequent among them\n                most_frequent_non_noise = max(non_noise_counts, key=non_noise_counts.get)\n                canonical_pattern[r, c] = most_frequent_non_noise\n            elif noise_color in color_counts:\n                 # If only noise and/or background are present, and noise is present, canonical is noise\n                 canonical_pattern[r, c] = noise_color\n            elif color_counts: \n                 # If only background is present (or Counter is empty somehow), keep background\n                 # This case implies the most frequent was background originally.\n                 canonical_pattern[r, c] = background_color # Or could take most_common overall if background needs specific handling\n\n    return canonical_pattern, most_common_size, valid_locations, valid_instances\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying repeating patterns, deriving a \n    canonical form, repairing noise within pattern instances, and reconstructing \n    the grid with only these repaired instances.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n    noise_color = 3\n\n    # Steps 1-5: Find core structures, common size, extract instances, derive canonical pattern\n    canonical_pattern, common_size, block_locations, block_instances = \\\n        _find_blocks_and_derive_pattern(input_np, background_color, noise_color)\n\n    # Initialize output grid with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # If no consistent blocks were found, return the empty background grid\n    if canonical_pattern is None or not block_locations:\n        return output_grid.tolist()\n\n    block_height, block_width = common_size\n\n    # Step 6: Generate output by placing repaired blocks\n    for idx, (r_start, c_start) in enumerate(block_locations):\n        instance = block_instances[idx] # Get the original block instance content\n        \n        # Create a temporary block to store the repaired version\n        repaired_block = np.copy(instance)\n\n        # Iterate through each pixel of the instance to apply repair logic\n        for r in range(block_height):\n            for c in range(block_width):\n                input_pixel = instance[r, c]\n                canonical_pixel = canonical_pattern[r, c]\n\n                # Repair Rule: Replace input pixel if it's noise AND canonical is NOT noise\n                if input_pixel == noise_color and canonical_pixel != noise_color:\n                    repaired_block[r, c] = canonical_pixel\n                # Otherwise, repaired_block[r, c] retains the value from the copied instance\n\n        # Place the (potentially) repaired block onto the output grid\n        output_grid[r_start : r_start + block_height, c_start : c_start + block_width] = repaired_block\n\n    # Step 7: Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17842,
    "candidates_token_count": 2254,
    "total_token_count": 20096,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.631149,
  "retries": null
}