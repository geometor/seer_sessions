{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify L-Shapes:** Scan the input grid to find all \"L-shapes\". An L-shape consists of exactly three pixels of the same non-white color (1-9) occupying three out of the four cells in any 2x2 square. Record the color and the set of three coordinate pairs for each distinct L-shape found.\n2.  **Determine Fill Color and Seed:** Examine the identified L-shapes. Find the *single* L-shape whose color is *not* azure (color 8). The color of this L-shape is the \"Fill Color\". The coordinates of the pixels forming this L-shape are the \"Seed Coordinates\". If no L-shapes are found, or if only azure L-shapes are found, or if more than one non-azure L-shape is found, return the original input grid unchanged.\n3.  **Identify Obstacles:** Find the coordinates of all non-white pixels (colors 1-9) in the original input grid. Remove the Seed Coordinates from this set. The remaining coordinates are the \"Obstacle Coordinates\".\n4.  **Generate Output Grid via Flood Fill:**\n    a.  Create a copy of the input grid. This will be the output grid.\n    b.  Initialize a queue for the flood fill algorithm and add all Seed Coordinates to it.\n    c.  Initialize a set to keep track of visited coordinates during the fill. Add all Seed Coordinates to the visited set.\n    d.  While the queue is not empty:\n        i.  Dequeue a coordinate `(r, c)`.\n        ii. If the pixel `(r, c)` in the *original input grid* was white (0), change the color of this cell in the *output grid* to the Fill Color. (Pixels that were originally non-white, including the seed pixels, are not recolored).\n        iii. Explore the 8 adjacent neighbors `(nr, nc)` of `(r, c)`.\n        iv. For each valid neighbor (within grid bounds):\n            - If the neighbor `(nr, nc)` has not been visited AND its coordinate is *not* in the Obstacle Coordinates:\n                - Add `(nr, nc)` to the visited set.\n                - Enqueue `(nr, nc)`.\n5.  Return the modified output grid.\n\"\"\"\n\n# ================= HELPER FUNCTIONS =================\n\ndef find_l_shapes(grid):\n    \"\"\"\n    Finds all distinct L-shaped objects in the grid.\n\n    An L-shape is defined as 3 pixels of the same non-white color\n    occupying 3 cells of a 2x2 square.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, frozenset_of_coordinates).\n              frozenset_of_coordinates contains (row, col) tuples for the 3 pixels\n              of the L-shape. Returns an empty list if no L-shapes are found.\n    \"\"\"\n    potential_l_shapes = []\n    rows, cols = grid.shape\n    if rows < 2 or cols < 2:\n        return [] # Cannot form 2x2 squares\n\n    added_shapes = set() # To track unique shapes (color, frozenset_coords)\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Extract the 2x2 subgrid\n            subgrid = grid[r:r+2, c:c+2]\n\n            # Count colors in the 2x2 subgrid, excluding white (0)\n            colors = defaultdict(list)\n            white_count = 0\n            for i in range(2):\n                for j in range(2):\n                    color = subgrid[i, j]\n                    coord = (r + i, c + j)\n                    if color == 0:\n                        white_count += 1\n                    else:\n                        colors[color].append(coord)\n\n            # Check for the L-shape condition: 1 white pixel and 3 pixels of the same non-white color\n            if white_count == 1:\n                for color, coords in colors.items():\n                    if len(coords) == 3:\n                        # Use frozenset for hashability needed for set operations\n                        fset_coords = frozenset(coords)\n                        shape_key = (int(color), fset_coords)\n                        # Add if truly unique\n                        if shape_key not in added_shapes:\n                            potential_l_shapes.append(shape_key)\n                            added_shapes.add(shape_key)\n                        break # Only one L-shape per 2x2 possible\n\n    return potential_l_shapes # Return list of (color, frozenset)\n\ndef get_all_non_white_coords(grid):\n    \"\"\"Finds coordinates of all non-white pixels (colors 1-9).\"\"\"\n    rows, cols = grid.shape\n    non_white = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                non_white.add((r, c))\n    return non_white\n\n# ================= MAIN TRANSFORM FUNCTION =================\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a flood fill transformation based on L-shapes.\n\n    The fill color is determined by the unique non-azure L-shape.\n    The fill starts from the non-azure L-shape pixels and spreads through\n    white space (8-way adjacency), respecting other non-white pixels as boundaries.\n    Only pixels that were originally white are recolored.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    output_grid = grid_np.copy() # Start with a copy\n\n    # 1. Find all L-shapes\n    all_l_shapes = find_l_shapes(grid_np)\n\n    # 2. Find the unique non-azure L-shape to get fill color and seeds\n    fill_color = -1\n    seed_coords_set = set()\n    non_azure_l_shape_count = 0\n    for color, coords_fset in all_l_shapes:\n        if color != 8: # Not azure\n            non_azure_l_shape_count += 1\n            fill_color = color\n            seed_coords_set = set(coords_fset) # Store coordinates of the non-azure L\n\n    # If not exactly one non-azure L-shape found, return original grid\n    if non_azure_l_shape_count != 1:\n        return input_grid\n\n    # 3. Define Obstacles (all non-white pixels except the seeds)\n    obstacle_coords = get_all_non_white_coords(grid_np)\n    if seed_coords_set: # Should always be true if non_azure_l_shape_count == 1\n        obstacle_coords = obstacle_coords - seed_coords_set # Remove seeds from obstacles\n    else:\n        # This case should not be reachable due to the count check above\n        return input_grid\n\n    # 4. Perform Flood Fill starting from seed coordinates\n    queue = deque()\n    visited = set() # Tracks cells added to queue or already processed\n\n    # Initialize queue and visited set with seed points\n    if seed_coords_set:\n        for seed in seed_coords_set:\n             if seed not in visited: # Check just in case, though set should handle uniqueness\n                 visited.add(seed)\n                 queue.append(seed)\n    # If seed_coords_set is empty (no non-azure L found), the queue remains empty,\n    # loop won't run, and original grid copy is returned (correct).\n\n    # Define 8 directions for neighbors (includes diagonals)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    while queue:\n        r, c = queue.popleft()\n\n        # Action: Color the current cell IF it was originally white (0).\n        # The non-azure L-shape's own pixels (seeds) are non-white and won't be colored.\n        if grid_np[r, c] == 0:\n             output_grid[r, c] = fill_color\n\n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            neighbor_coord = (nr, nc)\n\n            # Check bounds: Ensure neighbor is within grid limits\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor can be entered:\n                # Must not have been visited AND must not be an obstacle\n                if neighbor_coord not in visited and neighbor_coord not in obstacle_coords:\n                     # Mark as visited and add to queue for processing\n                     visited.add(neighbor_coord)\n                     queue.append(neighbor_coord)\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 36934,
    "candidates_token_count": 2153,
    "total_token_count": 39087,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 69.093482,
  "retries": null
}