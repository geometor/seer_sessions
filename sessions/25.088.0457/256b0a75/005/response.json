{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify L-Shapes:** Scan the input grid to find all \"L-shapes\". An L-shape consists of exactly three pixels of the same non-white color (1-9) occupying three out of the four cells in any 2x2 square. Record the color and the set of three coordinate pairs for each distinct L-shape found.\n2.  **Determine Fill Color:** Examine the identified L-shapes. Find the *single* L-shape whose color is *not* azure (color 8). The color of this L-shape is the \"Fill Color\". If no L-shapes are found, or if only azure L-shapes are found, return the original input grid unchanged.\n3.  **Define Fill Region:** Collect the coordinates of all pixels belonging to *any* identified L-shape (both the non-azure one and all azure ones). Calculate the minimum bounding box (minimum row, maximum row, minimum column, maximum column) that encloses all these collected L-shape coordinates. This is the \"L-shape Bounding Box\". If no L-shapes were found (and thus no coordinates), the process stops (as per step 2).\n4.  **Generate Output Grid:**\n    a.  Create a copy of the input grid. This will be the output grid.\n    b.  Iterate through every cell (row `r`, column `c`) located *within* the L-shape Bounding Box (inclusive).\n    c.  For each cell `(r, c)` inside the box, check its color in the *original input grid*.\n    d.  If the original color of cell `(r, c)` was white (0), change the color of this cell in the output grid to the determined Fill Color.\n    e.  If the original color of cell `(r, c)` was *not* white (i.e., it was 1-9, whether part of an L-shape or not), leave its color unchanged in the output grid (it retains its original color).\n    f.  All cells *outside* the L-shape Bounding Box remain unchanged from the input grid.\n5.  Return the modified output grid.\n\"\"\"\n\n# ================= HELPER FUNCTIONS =================\n\ndef find_l_shapes(grid):\n    \"\"\"\n    Finds all distinct L-shaped objects in the grid.\n\n    An L-shape is defined as 3 pixels of the same non-white color\n    occupying 3 cells of a 2x2 square.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, frozenset_of_coordinates).\n              frozenset_of_coordinates contains (row, col) tuples for the 3 pixels\n              of the L-shape. Returns an empty list if no L-shapes are found.\n              Using frozenset allows adding to a set to find unique L-shapes.\n    \"\"\"\n    potential_l_shapes = []\n    rows, cols = grid.shape\n    if rows < 2 or cols < 2:\n        return [] # Cannot form 2x2 squares\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Extract the 2x2 subgrid\n            subgrid = grid[r:r+2, c:c+2]\n\n            # Count colors in the 2x2 subgrid, excluding white (0)\n            colors = defaultdict(list)\n            white_count = 0\n            for i in range(2):\n                for j in range(2):\n                    color = subgrid[i, j]\n                    coord = (r + i, c + j)\n                    if color == 0:\n                        white_count += 1\n                    else:\n                        colors[color].append(coord)\n\n            # Check for the L-shape condition: 1 white pixel and 3 pixels of the same non-white color\n            if white_count == 1:\n                for color, coords in colors.items():\n                    if len(coords) == 3:\n                        # Use frozenset for hashability needed for set operations\n                        potential_l_shapes.append((int(color), frozenset(coords)))\n                        break # Only one L-shape per 2x2 possible\n\n    # Remove duplicate L-shapes (same color and same set of coordinates)\n    unique_l_shapes = list(set(potential_l_shapes))\n    # Convert frozenset back to set for consistency if needed later, though not strictly necessary\n    # result = [(color, set(coords)) for color, coords in unique_l_shapes]\n    return unique_l_shapes # Return with frozensets\n\ndef find_coords_bounding_box(coords_set):\n    \"\"\"\n    Finds the minimum bounding box enclosing a set of coordinates.\n\n    Args:\n        coords_set (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, max_r, min_c, max_c) defining the box,\n               or None if the set is empty. Returns ints.\n    \"\"\"\n    if not coords_set:\n        return None\n    min_r = min(r for r, c in coords_set)\n    max_r = max(r for r, c in coords_set)\n    min_c = min(c for r, c in coords_set)\n    max_c = max(c for r, c in coords_set)\n    return int(min_r), int(max_r), int(min_c), int(max_c)\n\n# ================= MAIN TRANSFORM FUNCTION =================\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the L-shape based filling transformation within the bounding box\n    defined by all L-shapes, preserving original non-white pixels.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = grid_np.copy() # Start with a copy\n\n    # 1. Identify all L-shapes\n    all_l_shapes = find_l_shapes(grid_np)\n\n    # If no L-shapes found, return original grid\n    if not all_l_shapes:\n        return input_grid\n\n    # 2. Determine Fill Color\n    fill_color = -1 # Default invalid color\n    non_azure_l_shape_found = False\n    for color, coords in all_l_shapes:\n        if color != 8: # Not azure\n            fill_color = color\n            non_azure_l_shape_found = True\n            break # Assuming only one non-azure L-shape exists\n\n    # If no non-azure L-shape was found, return original grid\n    if not non_azure_l_shape_found:\n        return input_grid\n\n    # 3. Define Fill Region (bounding box of *all* L-shape pixels)\n    all_l_shape_pixels = set().union(*(coords for _, coords in all_l_shapes))\n    l_shape_bounding_box = find_coords_bounding_box(all_l_shape_pixels)\n\n    # This check should be redundant because we know L-shapes exist if we got here\n    # but good practice to include it.\n    if l_shape_bounding_box is None:\n         return input_grid # Should not happen if all_l_shapes is not empty\n\n    min_r, max_r, min_c, max_c = l_shape_bounding_box\n\n    # 4. Generate the Output Grid\n    # Iterate through each cell within the L-shape bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check the color in the *original* input grid\n            if grid_np[r, c] == 0:\n                # If it was white, change it to the fill color in the output\n                output_grid[r, c] = fill_color\n            # Else (if original was non-white), leave it as is (already copied)\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20164,
    "candidates_token_count": 1935,
    "total_token_count": 22099,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.574155,
  "retries": null
}