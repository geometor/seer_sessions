{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all \"L-shapes\" in the input grid. An L-shape consists of exactly \n   three pixels of the same non-white color arranged to occupy three cells \n   of a 2x2 square.\n2. Categorize the L-shapes based on color: azure (8) and non-azure.\n3. Determine the fill color from the color of the non-azure L-shape(s). \n   Assume there's only one such color across all non-azure L-shapes.\n4. Collect the coordinates of all pixels belonging to *any* identified L-shape.\n5. Calculate the minimum bounding box enclosing all collected L-shape pixels.\n6. Initialize the output grid as a copy of the input grid.\n7. Iterate through each cell within the bounding box. If a cell is *not* part \n   of any originally identified L-shape, change its color to the determined \n   fill color. Otherwise, keep the original L-shape pixel color.\n8. Pixels outside the bounding box remain unchanged.\n\"\"\"\n\ndef find_l_shapes(grid):\n    \"\"\"\n    Finds all L-shaped objects in the grid.\n\n    An L-shape is defined as 3 pixels of the same non-white color\n    occupying 3 cells of a 2x2 square.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, set_of_coordinates).\n              set_of_coordinates contains (row, col) tuples for the 3 pixels\n              of the L-shape. Returns an empty list if no L-shapes are found.\n    \"\"\"\n    l_shapes = []\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Extract the 2x2 subgrid\n            subgrid = grid[r:r+2, c:c+2]\n            \n            # Count colors in the 2x2 subgrid, excluding white (0)\n            colors = defaultdict(list)\n            white_count = 0\n            for i in range(2):\n                for j in range(2):\n                    color = subgrid[i, j]\n                    coord = (r + i, c + j)\n                    if color == 0:\n                        white_count += 1\n                    else:\n                        colors[color].append(coord)\n\n            # Check for the L-shape condition: 1 white pixel and 3 pixels of the same non-white color\n            if white_count == 1:\n                for color, coords in colors.items():\n                    if len(coords) == 3:\n                        l_shapes.append((color, set(coords)))\n                        # Assuming a 2x2 can only contain one L-shape, break inner loop\n                        break \n                        \n    return l_shapes\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the L-shape based filling transformation to the input grid.\n    \n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    \n    # Convert input to numpy array for easier handling\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = grid_np.copy()\n    rows, cols = grid_np.shape\n\n    # 1. & 2. Find and categorize L-shapes\n    all_l_shapes = find_l_shapes(grid_np)\n\n    if not all_l_shapes:\n        # If no L-shapes are found, return the original grid\n        return input_grid\n\n    azure_l_shapes = []\n    non_azure_l_shapes = []\n    l_shape_pixels = set() # Collect coordinates of all pixels part of any L-shape\n\n    for color, coords in all_l_shapes:\n        if color == 8: # Azure\n            azure_l_shapes.append((color, coords))\n        else:\n            non_azure_l_shapes.append((color, coords))\n        l_shape_pixels.update(coords)\n\n    # 3. Determine fill color\n    fill_color = -1 # Default invalid color\n    if non_azure_l_shapes:\n        # Assume all non-azure L-shapes have the same color as per examples\n        fill_color = non_azure_l_shapes[0][0] \n    else:\n         # If only azure L-shapes exist, there's no non-azure color to fill with.\n         # Based on observation, this shouldn't happen, but if it did,\n         # no filling occurs, effectively returning the input.\n         # However, the bounding box is still defined by the azure shapes.\n         # Let's proceed assuming fill_color is needed, and if it's -1 later, we skip filling.\n         # OR maybe the fill color becomes white (0) or azure (8)? \n         # The examples always have a non-azure shape. Let's stick to the pattern.\n         # If only azure shapes exist, maybe no fill happens.\n         # Revisit if a test case demands different behavior.\n         # For now, if fill_color remains -1, the fill step won't execute.\n         pass # fill_color remains -1\n\n    # 4. Coordinates already collected in l_shape_pixels\n\n    # 5. Calculate bounding box\n    if not l_shape_pixels:\n       # Should not happen if all_l_shapes is not empty, but safety check\n       return input_grid\n       \n    min_r = min(r for r, c in l_shape_pixels)\n    max_r = max(r for r, c in l_shape_pixels)\n    min_c = min(c for r, c in l_shape_pixels)\n    max_c = max(c for r, c in l_shape_pixels)\n\n    # 6. Output grid initialized as a copy earlier\n\n    # 7. Iterate through bounding box and fill\n    if fill_color != -1: # Only fill if a non-azure color was found\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                # Check if the current pixel is NOT part of any L-shape\n                if (r, c) not in l_shape_pixels:\n                    output_grid[r, c] = fill_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8457,
    "candidates_token_count": 1547,
    "total_token_count": 10004,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.419458,
  "retries": null
}