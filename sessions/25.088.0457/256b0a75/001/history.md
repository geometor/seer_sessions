
## train_1

**input:**
```
0 4 0 0 0 0 0 4 0 0 0 0 6 0 0 0 0 0 0 1 0 0 5 0
0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 8 8 0 0 0 8 8 0 0 0 7 0 0 0
0 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 4
```


**output:**
```
0 4 0 0 0 0 0 4 0 0 4 1 6 1 1 1 1 0 0 1 0 0 5 0
0 0 0 0 0 0 0 0 0 0 4 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 7 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0
0 2 0 0 9 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 2
1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1
2 2 2 2 2 2 2 1 1 1 8 1 1 1 1 1 8 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 1 1 1 7 7 7 7
0 0 0 9 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 7 0 0 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 3 1 1 1 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 1 1 1 1 1 7 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 3 1 1 1 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 1 1 3 1 1 7 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 3 1 1 3 1 1 7 0 0 0 0 0 0 4
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 8 8 0 0 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0 0 0 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 0 0 0 0 8 0 0 0 9 0 0
0 0 0 0 0 0 0 0 0 7 7 0 0 8 8 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 7 6 7 7 4 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 6 7 7 4 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 6 7 7 7 7 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 7 6 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 7 7 0 0 0 0 0 0
2 2 2 7 7 7 7 7 7 8 8 8 8 8 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7 7 7 7 7 7
4 4 4 4 4 7 7 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 8 7 7 7 9 9 9
7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 7 7 7 7 7 7
0 0 0 0 0 0 0 0 0 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 7 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 1 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 1 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 1 7 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 7 7 7 7 1 7 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 1 7 0 0 0 9 0 0
0 0 0 0 0 0 0 0 0 7 7 7 7 1 7 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 7 0 5 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 9 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 8 8 0 0 0 0 8 8 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 8 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0
0 6 0 0 0 0 8 8 0 0 0 0 3 3 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 1 3 3 7 9 5 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 3 3 3 9 6 3 3 0 9 0 0 0 0 0 0 0
0 0 0 0 0 0 1 3 3 3 9 6 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 3 3 3 9 6 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 6 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 6 3 3 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 8 8 8 8 8 8 8 8 3 3 3 3 3 6 6 6 6
3 3 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
5 5 5 5 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
6 6 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
1 1 1 3 3 3 8 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3 3
6 6 3 3 3 3 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1 1
0 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 3 1 3 0 0 0 0 0 0 0 0 0
0 5 2 0 0 0 3 3 3 3 3 3 1 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 9 1 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 9 1 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 1 3 3 9 1 3 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

The core transformation involves identifying specific shapes in the input grid and using them to define a rectangular region and a fill color.

1.  **Shape Identification**: The key elements appear to be "L-shapes". These are objects composed of exactly three pixels of the same color, arranged such that they occupy three of the four cells in a 2x2 square.
2.  **Shape Roles**: There seem to be two types of L-shapes based on color: azure (color 8) and non-azure (colors 1, 7, 3 in the examples). Both types contribute to defining the area to be modified.
3.  **Bounding Box**: A rectangular area is determined by finding the minimum bounding box that encompasses *all* identified L-shapes (both azure and non-azure).
4.  **Fill Color**: The color used to fill the rectangle is determined by the color of the non-azure L-shape(s). The examples suggest there will be exactly one color for non-azure L-shapes.
5.  **Transformation**: The output grid is created by taking the input grid and modifying the region within the calculated bounding box. Pixels inside the bounding box are changed to the fill color, *unless* they were part of one of the originally identified L-shapes. Pixels belonging to the L-shapes, and all pixels outside the bounding box, retain their original colors from the input.

**Facts**


```yaml
elements:
  - type: grid
    properties:
      - background: predominantly white (0)
      - foreground: contains scattered pixels and specific objects
  - type: object
    identifier: L-shape
    properties:
      - composition: 3 pixels of the same color
      - geometry: occupies 3 cells of a 2x2 square
      - roles:
          - marker: defines a bounding box
          - color_source: determines fill color (if not azure)
      - subtypes:
          - azure_L_shape: color is azure (8)
          - non_azure_L_shape: color is not azure (8)

actions:
  - action: find_objects
    target: L-shape
    criteria: geometry and pixel count (3)
  - action: group_objects
    source: L-shapes
    criteria: color (azure vs. non-azure)
  - action: determine_fill_color
    source: non_azure_L_shape(s)
    result: single color value (color of the non-azure L-shape)
  - action: determine_bounding_box
    source: all L-shapes (azure and non-azure)
    result: rectangular region coordinates (min_row, max_row, min_col, max_col)
  - action: fill_region
    target: area within the bounding_box
    color: fill_color
    condition: only fill pixels that were NOT part of any identified L-shape in the input

relationships:
  - type: spatial
    description: The bounding box is defined by the spatial extent (min/max coordinates) of all L-shapes combined.
  - type: conditional_coloring
    description: The fill color for the bounding box is derived from the color of the non-azure L-shape(s).
  - type: preservation
    description: Pixels belonging to any L-shape are preserved; they are not overwritten by the fill color, even if inside the bounding box. Pixels outside the bounding box are also preserved.
```


**Natural Language Program**

1.  **Scan** the input grid to identify all L-shaped objects. An L-shaped object consists of exactly three pixels of the same color, arranged such that they occupy three cells within a 2x2 square. Keep track of the color and coordinates of the pixels for each L-shape found.
2.  **Categorize** the identified L-shapes based on their color: group them into azure (color 8) L-shapes and non-azure L-shapes.
3.  **Determine** the fill color: Identify the color of the non-azure L-shape(s). Assume there is exactly one such color among all non-azure L-shapes found. This color is the `fill_color`.
4.  **Collect** the coordinates of all pixels belonging to *any* identified L-shape (both azure and non-azure).
5.  **Calculate** the minimum bounding box that encloses all collected L-shape pixel coordinates. Find the minimum row (`min_r`), maximum row (`max_r`), minimum column (`min_c`), and maximum column (`max_c`).
6.  **Initialize** the output grid as a copy of the input grid.
7.  **Iterate** through each cell (`r`, `c`) within the calculated bounding box (from `min_r` to `max_r` and `min_c` to `max_c`).
8.  For each cell (`r`, `c`) inside the bounding box, check if its coordinates are present in the collection of L-shape pixel coordinates identified in step 4.
9.  If the cell (`r`, `c`) is *within* the bounding box but its coordinates are *not* in the L-shape pixel collection, **change** the color of this cell in the output grid to the `fill_color` determined in step 3.
10. **Output** the modified grid.
