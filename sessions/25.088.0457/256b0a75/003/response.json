{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify all L-shapes:** Scan the input grid for any L-shapes. An L-shape consists of exactly three pixels of the same non-white color (colors 1 through 9) that occupy three out of four cells in any 2x2 square. Record the color and the set of coordinates for each L-shape found.\n2.  **Determine the Fill Color:** Examine the identified L-shapes. Find the L-shape(s) whose color is *not* azure (color 8). The color of this non-azure L-shape is the \"Fill Color\". (Based on the examples, there appears to be only one such non-azure color present per grid). If no non-azure L-shapes are found, return the original grid.\n3.  **Collect all L-shape Pixel Coordinates:** Create a single set containing the coordinates of all pixels that are part of *any* identified L-shape (both azure and non-azure). These pixels will be preserved.\n4.  **Calculate the Global Bounding Box:** Find the minimum and maximum row and column indices occupied by *any* non-white pixel (colors 1 through 9) in the input grid. This defines the rectangular region for the filling operation. If no non-white pixels exist, return the original grid.\n5.  **Generate the Output Grid:**\n    a.  Start with a copy of the input grid.\n    b.  Iterate through every cell (row `r`, column `c`) within the Global Bounding Box (from `min_row` to `max_row`, and `min_col` to `max_col`, inclusive).\n    c.  For each cell `(r, c)`, check if its coordinates are present in the set of collected L-shape pixel coordinates.\n    d.  If the coordinates `(r, c)` are *not* in the L-shape coordinates set, change the color of this cell in the output grid to the determined Fill Color.\n    e.  If the coordinates `(r, c)` *are* in the L-shape coordinates set, leave the cell's color unchanged (it keeps its original L-shape color).\n    f.  All cells outside the Global Bounding Box remain unchanged from the input grid.\n6.  Return the modified grid.\n\"\"\"\n\ndef find_l_shapes(grid):\n    \"\"\"\n    Finds all L-shaped objects in the grid.\n\n    An L-shape is defined as 3 pixels of the same non-white color\n    occupying 3 cells of a 2x2 square.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple is (color, set_of_coordinates).\n              set_of_coordinates contains (row, col) tuples for the 3 pixels\n              of the L-shape. Returns an empty list if no L-shapes are found.\n    \"\"\"\n    l_shapes = []\n    rows, cols = grid.shape\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Extract the 2x2 subgrid\n            subgrid = grid[r:r+2, c:c+2]\n\n            # Count colors in the 2x2 subgrid, excluding white (0)\n            colors = defaultdict(list)\n            white_count = 0\n            for i in range(2):\n                for j in range(2):\n                    color = subgrid[i, j]\n                    coord = (r + i, c + j)\n                    if color == 0:\n                        white_count += 1\n                    else:\n                        colors[color].append(coord)\n\n            # Check for the L-shape condition: 1 white pixel and 3 pixels of the same non-white color\n            if white_count == 1:\n                for color, coords in colors.items():\n                    if len(coords) == 3:\n                        l_shapes.append((int(color), set(coords))) # Ensure color is python int\n                        # Assuming a 2x2 can only contain one L-shape, break inner loop\n                        break\n\n    return l_shapes\n\ndef find_non_white_bounding_box(grid):\n    \"\"\"\n    Finds the minimum bounding box enclosing all non-white pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (min_r, max_r, min_c, max_c) defining the box,\n               or None if no non-white pixels are found.\n    \"\"\"\n    non_white_coords = np.argwhere(grid != 0)\n    if non_white_coords.size == 0:\n        return None # No non-white pixels\n    min_r = int(np.min(non_white_coords[:, 0]))\n    max_r = int(np.max(non_white_coords[:, 0]))\n    min_c = int(np.min(non_white_coords[:, 1]))\n    max_c = int(np.max(non_white_coords[:, 1]))\n    return min_r, max_r, min_c, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the L-shape based filling transformation within the global bounds of non-white pixels.\n\n    Args:\n        input_grid (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = grid_np.copy() # Start with a copy\n\n    # 1. Identify all L-shapes\n    all_l_shapes = find_l_shapes(grid_np)\n\n    # If no L-shapes, the transformation might not be defined?\n    # For now, let's return the original grid if no L-shapes are found.\n    # Or maybe only proceed if a non-azure L-shape is found. Let's check that first.\n\n    # 2. Determine Fill Color and collect non-azure shapes\n    non_azure_l_shapes = []\n    fill_color = -1 # Default invalid color\n    l_shape_pixels = set() # Collect coordinates of all pixels part of *any* L-shape\n\n    for color, coords in all_l_shapes:\n        l_shape_pixels.update(coords) # Add coordinates to the master set\n        if color != 8: # Not azure\n            non_azure_l_shapes.append((color, coords))\n\n    # Determine fill color from the first non-azure L-shape found\n    if non_azure_l_shapes:\n        fill_color = non_azure_l_shapes[0][0]\n    else:\n        # No non-azure L-shape found to determine fill color.\n        # According to the rule, we should return the original grid.\n        return input_grid\n\n    # 3. L-shape pixel coordinates already collected in l_shape_pixels\n\n    # 4. Calculate the Global Bounding Box of non-white pixels\n    bounding_box = find_non_white_bounding_box(grid_np)\n\n    # If no non-white pixels exist, return the original grid\n    if bounding_box is None:\n        return input_grid\n\n    min_r, max_r, min_c, max_c = bounding_box\n\n    # 5. Generate the Output Grid by filling within the bounding box\n    # Iterate through each cell within the global bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check if the current pixel is NOT part of any L-shape\n            if (r, c) not in l_shape_pixels:\n                # If not part of an L-shape, fill it with the fill color\n                output_grid[r, c] = fill_color\n            # Else: Pixel is part of an L-shape, leave its original color (already copied)\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24357,
    "candidates_token_count": 1894,
    "total_token_count": 26251,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.582333,
  "retries": null
}