{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Create a copy of the input grid to serve as the output grid.\n2. Locate all red pixels (color 2) in the input grid, which act as markers.\n3. Keep track of coordinates already processed as part of an object to avoid redundant calculations.\n4. For each red pixel (marker) found at (marker_r, marker_c):\n    a. If this marker has already been processed, continue to the next one.\n    b. Identify the connected 'composite object' consisting of this red marker and all orthogonally connected green pixels (color 3) recursively attached to it. Use Breadth-First Search (BFS) for connectivity. Store the coordinates of all pixels in this object.\n    c. Mark all coordinates of the identified object as processed.\n    d. Determine the expansion direction (Up, Down, Left, Right) by finding the single orthogonally adjacent white pixel (color 0) next to the *marker* pixel (marker_r, marker_c) in the *input* grid. Represent this direction as a vector (dr, dc).\n    e. If a valid, unique expansion direction is found:\n        i. Iterate through each pixel (obj_r, obj_c) belonging to the composite object.\n        ii. Retrieve the original color 'C' of this pixel from the input grid (input_grid[obj_r, obj_c]).\n        iii. Initialize trace coordinates (trace_r, trace_c) starting one step from the object pixel in the expansion direction: (obj_r + dr, obj_c + dc).\n        iv. Begin a loop: While the trace coordinates (trace_r, trace_c) are within the grid boundaries AND the pixel at these coordinates in the *original input grid* (input_grid[trace_r, trace_c]) is white (0):\n            1. Set the pixel at (trace_r, trace_c) in the *output* grid to the color 'C'.\n            2. Update the trace coordinates by moving one more step in the expansion direction: (trace_r, trace_c) = (trace_r + dr, trace_c + dc).\n5. Return the modified output grid.\n\"\"\"\n\ndef find_connected_object(grid, start_r, start_c):\n    \"\"\"\n    Finds the connected object of red (2) and green (3) pixels starting from a red pixel.\n    Uses Breadth-First Search (BFS) for orthogonal connectivity.\n    Includes the starting red pixel and connected green pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    obj_coords = set([(start_r, start_c)])\n    # Only the initial pixel must be red, connected ones can be green\n    initial_pixel_color = grid[start_r, start_c]\n    if initial_pixel_color != 2: # Should always start with red based on logic, but good check\n         return set()\n\n    while q:\n        r, c = q.popleft()\n\n        # Check orthogonal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n            nr, nc = r + dr, c + dc\n            # Check bounds and if not visited\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                # Check if the neighbor is part of the object (only green connects to the initial red or other greens)\n                # The start pixel IS part of the object regardless of connection logic below\n                # Only need to check if neighbors are green (3)\n                if grid[nr, nc] == 3:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    obj_coords.add((nr, nc))\n    return obj_coords\n\ndef get_expansion_direction(grid, red_r, red_c):\n    \"\"\"\n    Determines the expansion direction based on the single adjacent white pixel (0)\n    to the specified red pixel coordinates in the *input* grid.\n    Returns the direction vector (dr, dc) or (0, 0) if no unique direction is found.\n    \"\"\"\n    rows, cols = grid.shape\n    direction_vector = (0, 0)\n    white_neighbor_count = 0\n\n    # Check orthogonal neighbors\n    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right\n        nr, nc = red_r + dr, red_c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            if grid[nr, nc] == 0: # White pixel found\n                direction_vector = (dr, dc)\n                white_neighbor_count += 1\n\n    # Expect exactly one adjacent white pixel to define the direction\n    if white_neighbor_count == 1:\n        return direction_vector\n    else:\n        # If zero or more than one white neighbor, the direction is ambiguous or undefined\n        # print(f\"Warning: Found {white_neighbor_count} white neighbors for marker at ({red_r}, {red_c}). Expected 1. No expansion.\")\n        return (0, 0)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Finds red-green objects, determines their\n    expansion direction based on the red marker's adjacent white neighbor in the input grid,\n    and expands/projects each pixel of the object into adjacent originally white space\n    along that direction in the output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np) # 1. Initialize output grid\n    rows, cols = input_grid_np.shape\n\n    # 2. Locate all red pixels (markers)\n    red_pixels = np.argwhere(input_grid_np == 2)\n\n    # 3. Keep track of pixels already part of a processed object\n    processed_coords = set()\n\n    # 4. Process each red pixel found\n    for red_r, red_c in red_pixels:\n        # 4a. Skip if already processed\n        if (red_r, red_c) in processed_coords:\n            continue\n\n        # 4b. Identify the full connected object (red marker + green body)\n        object_coords = find_connected_object(input_grid_np, red_r, red_c)\n        if not object_coords: # Should not happen if red_pixels contains valid coords\n             continue\n\n        # 4c. Mark all pixels of this object as processed\n        processed_coords.update(object_coords)\n\n        # 4d. Determine the expansion direction based on the red marker's neighbor in the INPUT grid\n        direction_vector = get_expansion_direction(input_grid_np, red_r, red_c)\n        dr, dc = direction_vector\n\n        # Only expand if a valid, unique direction was found\n        if dr != 0 or dc != 0:\n            # 4e. Expand each pixel of the object\n            for obj_r, obj_c in object_coords:\n                # 4ei. Get the original color of this part of the object\n                original_color = input_grid_np[obj_r, obj_c]\n\n                # 4eii. Initialize trace coords (start adjacent to object pixel)\n                trace_r, trace_c = obj_r + dr, obj_c + dc\n\n                # 4eiv. Expand while within bounds and hitting ORIGINAL white space (in INPUT grid)\n                while 0 <= trace_r < rows and 0 <= trace_c < cols and input_grid_np[trace_r, trace_c] == 0:\n                    # 1. Color the pixel in the OUTPUT grid\n                    output_grid[trace_r, trace_c] = original_color\n                    # 2. Move to the next pixel in the expansion direction\n                    trace_r += dr\n                    trace_c += dc\n\n    # 5. Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12938,
    "candidates_token_count": 1907,
    "total_token_count": 14845,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.211725,
  "retries": null
}