{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Locate all red pixels (color 2) in the input grid.\n3. For each red pixel found at coordinates (R, C):\n    a. Identify the connected object consisting of this red pixel and all orthogonally adjacent green pixels (color 3) recursively connected to it. Store the coordinates of all pixels belonging to this object.\n    b. Find the single orthogonally adjacent white pixel (color 0) next to the *red* pixel at (R, C). Determine the direction (Up, Down, Left, or Right) from the red pixel to this white pixel. This is the expansion direction for the entire object.\n    c. For every pixel (obj_r, obj_c) belonging to the identified connected object:\n        i. Retrieve the original color of this pixel from the input grid (it will be either red or green).\n        ii. Determine the directional step (dr, dc) corresponding to the expansion direction (e.g., Up is (-1, 0), Right is (0, 1)).\n        iii. Start tracing a path from the pixel adjacent to (obj_r, obj_c) in the expansion direction. Let the current trace coordinates be (trace_r, trace_c) = (obj_r + dr, obj_c + dc).\n        iv. While the coordinates (trace_r, trace_c) are within the grid boundaries and the pixel at (trace_r, trace_c) in the *output* grid is white (0):\n            1. Color the pixel at (trace_r, trace_c) in the output grid with the original color retrieved in step 3.c.i.\n            2. Update the trace coordinates to the next step in the expansion direction: (trace_r, trace_c) = (trace_r + dr, trace_c + dc).\n4. Return the modified output grid.\n\"\"\"\n\ndef find_connected_object(grid, start_r, start_c):\n    \"\"\"\n    Finds the connected object of red (2) and green (3) pixels starting from a red pixel.\n    Uses Breadth-First Search (BFS) for orthogonal connectivity.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    obj_coords = set([(start_r, start_c)])\n    valid_colors = {2, 3} # Red and Green\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n            nr, nc = r + dr, c + dc\n            # Check bounds and if not visited\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                # Check if the neighbor is part of the object (red or green)\n                if grid[nr, nc] in valid_colors:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    obj_coords.add((nr, nc))\n    return obj_coords\n\ndef get_expansion_direction(grid, red_r, red_c):\n    \"\"\"\n    Determines the expansion direction based on the single adjacent white pixel to the red pixel.\n    Returns the direction vector (dr, dc) or (0, 0) if no unique direction is found.\n    \"\"\"\n    rows, cols = grid.shape\n    direction_vector = (0, 0)\n    white_neighbor_count = 0\n\n    # Check orthogonal neighbors\n    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right\n        nr, nc = red_r + dr, red_c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            if grid[nr, nc] == 0: # White pixel found\n                direction_vector = (dr, dc)\n                white_neighbor_count += 1\n\n    # Expect exactly one adjacent white pixel to define the direction\n    if white_neighbor_count == 1:\n        return direction_vector\n    else:\n        # If zero or more than one white neighbor, the direction is ambiguous or undefined\n        return (0, 0)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Finds red-green objects, determines their\n    expansion direction based on the red pixel's adjacent white neighbor,\n    and expands each pixel of the object into adjacent white space along that direction.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid_np)\n    rows, cols = input_grid_np.shape\n\n    # 1. Locate all red pixels (markers)\n    red_pixels = np.argwhere(input_grid_np == 2)\n\n    # Keep track of pixels already part of a processed object\n    processed_coords = set()\n\n    # 2. Process each red pixel found\n    for red_r, red_c in red_pixels:\n        # Skip if this pixel was already part of a previously processed object\n        if (red_r, red_c) in processed_coords:\n            continue\n\n        # 3a. Identify the full connected object (red + green)\n        object_coords = find_connected_object(input_grid_np, red_r, red_c)\n        # Mark all pixels of this object as processed\n        processed_coords.update(object_coords)\n\n        # 3b. Determine the expansion direction based on the red pixel's neighbor\n        direction_vector = get_expansion_direction(input_grid_np, red_r, red_c)\n        dr, dc = direction_vector\n\n        # Only expand if a valid, unique direction was found\n        if dr != 0 or dc != 0:\n            # 3c. Expand each pixel of the object\n            for obj_r, obj_c in object_coords:\n                # 3ci. Get the original color of this part of the object\n                original_color = input_grid_np[obj_r, obj_c]\n\n                # 3ciii. Start tracing from the adjacent cell in the expansion direction\n                curr_r, curr_c = obj_r + dr, obj_c + dc\n\n                # 3civ. Expand while within bounds and hitting white space in the output grid\n                while 0 <= curr_r < rows and 0 <= curr_c < cols and output_grid[curr_r, curr_c] == 0:\n                    # 1. Color the white pixel\n                    output_grid[curr_r, curr_c] = original_color\n                    # 2. Move to the next pixel in the expansion direction\n                    curr_r += dr\n                    curr_c += dc\n\n    # 4. Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20262,
    "candidates_token_count": 1639,
    "total_token_count": 21901,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.225471,
  "retries": null
}