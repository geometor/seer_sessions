{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport heapq # For potential priority queue in distance calculation, though BFS is sufficient\n\n\"\"\"\nIdentifies seeds (single non-white pixels) and shapes (connected components > 1 pixel of the same non-white color, 4-way connected).\nFor each shape, determines the closest seed based on the shortest path distance through adjacent (8-way) white pixels.\nFor each shape and its assigned closest seed, performs a BFS starting from the seed through adjacent (8-way) white pixels.\nColors all visited white pixels from this BFS that are also adjacent (8-way) to the associated shape with the color of the seed.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-background pixels (color != 0).\n    Classifies them as shapes (size > 1, 4-way connected) or seeds (size == 1).\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        tuple: (shapes, seeds)\n            shapes: list of tuples [(coords_set, color)], where coords_set is a set of (r, c) tuples.\n            seeds: list of tuples [(coord, color)], where coord is an (r, c) tuple.\n    \"\"\"\n    H, W = grid.shape\n    visited = set()\n    shapes = []\n    seeds = []\n    \n    # 4-way neighbors for defining object connectivity\n    neighbors_4 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                component_coords.add((r, c))\n                \n                # BFS to find the connected component (4-connectivity)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    for dr, dc in neighbors_4:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < H and 0 <= nc < W and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            component_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if len(component_coords) == 1:\n                    # It's a seed if it's a single pixel\n                    seeds.append(((r, c), color))\n                else:\n                    # It's a shape if it has more than one pixel\n                    shapes.append((component_coords, color))\n                    \n    return shapes, seeds\n\ndef bfs_shortest_distance(grid, start_coord, target_coords_set):\n    \"\"\"\n    Calculates the shortest path distance from start_coord to any coord in \n    target_coords_set, moving only through adjacent (8-way) white pixels (0).\n    The distance is the number of white pixels in the path.\n\n    Args:\n        grid (np.array): The input grid.\n        start_coord (tuple): The (r, c) of the seed pixel.\n        target_coords_set (set): A set of (r, c) tuples representing the target shape.\n\n    Returns:\n        int: The shortest distance (number of white steps), or float('inf') if unreachable.\n    \"\"\"\n    H, W = grid.shape\n    neighbors_8 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Start BFS from adjacent white cells to the seed\n    queue = deque()\n    visited_white = set() # Keep track of visited white cells to avoid cycles\n\n    # Find initial white neighbors of the seed\n    start_r, start_c = start_coord\n    for dr, dc in neighbors_8:\n        nr, nc = start_r + dr, start_c + dc\n        if 0 <= nr < H and 0 <= nc < W:\n            # If neighbor is the target shape, distance is 0 white steps\n            if (nr, nc) in target_coords_set:\n                 return 0 # Directly adjacent\n            # If neighbor is white, add to queue with distance 1\n            if grid[nr, nc] == 0 and (nr, nc) not in visited_white:\n                queue.append(((nr, nc), 1)) # (coord, distance)\n                visited_white.add((nr, nc))\n\n    # Perform BFS\n    while queue:\n        (curr_r, curr_c), dist = queue.popleft()\n\n        # Check neighbors of the current white cell\n        for dr, dc in neighbors_8:\n            nr, nc = curr_r + dr, curr_c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                # If neighbor is part of the target shape, return current distance\n                if (nr, nc) in target_coords_set:\n                    return dist \n                \n                # If neighbor is white and not visited, add to queue\n                if grid[nr, nc] == 0 and (nr, nc) not in visited_white:\n                    visited_white.add((nr, nc))\n                    queue.append(((nr, nc), dist + 1))\n\n    # Target shape not reachable via white path\n    return float('inf')\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by coloring white pixels adjacent to shapes\n    based on the closest seed reachable via a white path.\n    \"\"\"\n    H, W = input_grid.shape\n    output_grid = np.copy(input_grid)\n    neighbors_8 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    # 1. Identify Objects\n    shapes, seeds = find_objects(input_grid)\n\n    if not shapes or not seeds:\n        return output_grid # No transformation possible if no shapes or no seeds\n\n    # Store shape info with indices for easy mapping\n    shape_data = [{'coords': coords, 'color': color, 'id': i} for i, (coords, color) in enumerate(shapes)]\n    seed_data = [{'coord': coord, 'color': color, 'id': i} for i, (coord, color) in enumerate(seeds)]\n\n    # 2. Determine Closest Seed for Each Shape\n    shape_to_closest_seed = {} # {shape_id: {'seed_id': id, 'distance': dist}}\n    for shape in shape_data:\n        min_dist = float('inf')\n        closest_seed_id = -1\n        \n        for seed in seed_data:\n            # Calculate distance from this seed to the current shape\n            distance = bfs_shortest_distance(input_grid, seed['coord'], shape['coords'])\n            \n            # Update closest seed if this one is closer\n            if distance < min_dist:\n                min_dist = distance\n                closest_seed_id = seed['id']\n            # Optional: Add tie-breaking logic here if needed (e.g., seed index)\n        \n        # Store the result if a reachable seed was found\n        if closest_seed_id != -1:\n            shape_to_closest_seed[shape['id']] = {'seed_id': closest_seed_id, 'distance': min_dist}\n\n    # 3. Color Adjacent White Pixels\n    pixels_to_color = {} # {(r, c): color} - Store potential colorings, handle overlaps later if needed (e.g., closest point) - current logic overwrites\n\n    for shape_id, assignment in shape_to_closest_seed.items():\n        seed_id = assignment['seed_id']\n        \n        # Get the relevant shape and seed info\n        target_shape = next(s for s in shape_data if s['id'] == shape_id)\n        assigned_seed = next(s for s in seed_data if s['id'] == seed_id)\n        \n        start_coord = assigned_seed['coord']\n        fill_color = assigned_seed['color']\n        target_shape_coords = target_shape['coords']\n\n        # Perform BFS from the assigned seed, exploring only white pixels (8-way)\n        queue = deque([start_coord])\n        # visited_bfs includes the seed and all reachable cells (white or not)\n        # to prevent cycles and redundant exploration in this specific BFS run.\n        visited_bfs = {start_coord} \n        # reachable_white_pixels stores only the white pixels found by this BFS\n        reachable_white_pixels = set() \n\n        while queue:\n            r, c = queue.popleft()\n\n            # Explore 8-way neighbors\n            for dr, dc in neighbors_8:\n                nr, nc = r + dr, c + dc\n\n                if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited_bfs:\n                    visited_bfs.add((nr, nc))\n                    # If neighbor is white, add to queue and track it\n                    if input_grid[nr, nc] == 0:\n                        reachable_white_pixels.add((nr, nc))\n                        queue.append((nr, nc))\n                    # If neighbor is colored (part of a shape or another seed),\n                    # we visit it but don't add to the white pixel set or queue\n                    # (as the path must be through white).\n        \n        # Identify which of the reachable white pixels are adjacent to the target shape\n        for wr, wc in reachable_white_pixels:\n            is_adjacent_to_target_shape = False\n            for dr, dc in neighbors_8:\n                nnr, nnc = wr + dr, wc + dc\n                # Check bounds and if neighbor is in the target shape's coordinates\n                if 0 <= nnr < H and 0 <= nnc < W and (nnr, nnc) in target_shape_coords:\n                    is_adjacent_to_target_shape = True\n                    break # Found adjacency\n            \n            if is_adjacent_to_target_shape:\n                # Store the pixel and its color. If multiple seeds claim the same pixel,\n                # the last one processed will win. A more complex rule might be needed\n                # for ties (e.g., closest seed overall). Current logic implies processing order matters.\n                 pixels_to_color[(wr, wc)] = fill_color\n                 # Instead of direct assignment, collect first:\n                 # if (wr, wc) not in pixels_to_color:\n                 #    pixels_to_color[(wr, wc)] = []\n                 # pixels_to_color[(wr, wc)].append({'seed_id': seed_id, 'color': fill_color, 'dist_from_seed': ?})\n                 # Then resolve conflicts after all BFS runs. \n                 # Let's stick to the simpler overwrite logic for now based on the NLP.\n\n    # Apply the collected color changes\n    for (r, c), color in pixels_to_color.items():\n        output_grid[r, c] = color\n        \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15194,
    "candidates_token_count": 2646,
    "total_token_count": 17840,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 130.241278,
  "retries": null
}