{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify distinct shapes (connected components > 1 pixel) and seeds (single pixels) in the input grid.\nFor each seed pixel, perform a search (like BFS) outwards through adjacent white (0) pixels.\nDetermine which shapes are reachable from the seed via this white-pixel path.\nFor each reachable shape, identify all white pixels that were visited during the search AND are adjacent (8-way) to that specific shape.\nFill these identified adjacent white pixels with the color of the seed pixel in the output grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-background pixels.\n    Classifies them as shapes (size > 1) or seeds (size == 1).\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        tuple: (shapes, seeds)\n            shapes: list of tuples [(coords_set, color)], where coords_set is a set of (r, c) tuples.\n            seeds: list of tuples [(coord, color)], where coord is an (r, c) tuple.\n    \"\"\"\n    H, W = grid.shape\n    visited = set()\n    shapes = []\n    seeds = []\n    \n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                component_coords.add((r, c))\n                \n                # BFS to find the connected component (4-connectivity for object definition)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < H and 0 <= nc < W and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            component_coords.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if len(component_coords) == 1:\n                    # It's a seed if it's a single pixel\n                    seeds.append(((r, c), color))\n                else:\n                    # It's a shape if it has more than one pixel\n                    shapes.append((component_coords, color))\n                    \n    return shapes, seeds\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on connectivity between seeds and shapes.\n\n    1. Finds all shapes and seeds.\n    2. For each seed:\n        a. Performs BFS on white pixels starting from the seed.\n        b. Identifies shapes reachable via this white path.\n        c. Identifies white pixels visited AND adjacent to reachable shapes.\n        d. Fills those white pixels with the seed's color.\n\n    Args:\n        input_grid (np.array): The input grid.\n\n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n\n    # Find shapes and seeds\n    shapes, seeds = find_objects(input_grid)\n    \n    # Create a quick lookup for all coordinates belonging to any shape\n    all_shape_coords = set()\n    for shape_coords, _ in shapes:\n        all_shape_coords.update(shape_coords)\n\n    # Define 8-way neighbors\n    neighbors_8 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    # Process each seed\n    for seed_coord, seed_color in seeds:\n        \n        # BFS starting from the seed, moving only through white pixels (0)\n        queue = deque([seed_coord])\n        # visited_bfs includes the starting seed and all visited white cells in this specific BFS\n        visited_bfs = set([seed_coord]) \n        reachable_white_pixels = set() # Store white pixels reached from this seed\n        connected_shape_indices = set() # Store indices of shapes connected via white path\n\n        while queue:\n            r, c = queue.popleft()\n\n            # Explore 8 neighbors\n            for dr, dc in neighbors_8:\n                nr, nc = r + dr, c + dc\n\n                if 0 <= nr < H and 0 <= nc < W:\n                    # Check if neighbor is already visited in this BFS\n                    if (nr, nc) not in visited_bfs:\n                        neighbor_val = input_grid[nr, nc]\n                        \n                        # If neighbor is white, add to queue and track it\n                        if neighbor_val == 0:\n                            visited_bfs.add((nr, nc))\n                            queue.append((nr, nc))\n                            reachable_white_pixels.add((nr, nc))\n                        \n                        # If neighbor is part of *any* shape, mark that shape as connected\n                        elif (nr, nc) in all_shape_coords:\n                           # We don't add the shape pixel itself to visited_bfs \n                           # or the queue, but we note the connection.\n                           # Find which shape it belongs to\n                           for i, (shape_coords, _) in enumerate(shapes):\n                               if (nr, nc) in shape_coords:\n                                   connected_shape_indices.add(i)\n                                   break # Found the shape index\n\n\n        # Now, identify the actual pixels to fill for this seed\n        pixels_to_fill_for_this_seed = set()\n        for shape_idx in connected_shape_indices:\n            current_shape_coords = shapes[shape_idx][0]\n            \n            # Check every white pixel reached by the BFS\n            for wr, wc in reachable_white_pixels:\n                # Is this white pixel adjacent to the *current* connected shape?\n                is_adjacent_to_current_shape = False\n                for dr, dc in neighbors_8:\n                    nnr, nnc = wr + dr, wc + dc\n                    # Check bounds and if neighbor is in the current shape's coordinates\n                    if 0 <= nnr < H and 0 <= nnc < W and (nnr, nnc) in current_shape_coords:\n                        is_adjacent_to_current_shape = True\n                        break # Found adjacency, no need to check other neighbors\n                \n                if is_adjacent_to_current_shape:\n                    pixels_to_fill_for_this_seed.add((wr, wc))\n\n        # Fill the identified pixels in the output grid with the seed's color\n        for fr, fc in pixels_to_fill_for_this_seed:\n            output_grid[fr, fc] = seed_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9114,
    "candidates_token_count": 1632,
    "total_token_count": 10746,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 44.338649,
  "retries": null
}