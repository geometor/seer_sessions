{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components of white pixels (color 0) using 8-way \nadjacency (including diagonals). \nRecolors each white component based on its proximity to the absolute grid \nborder (first/last row or first/last column).\n\n1. Find all connected components of white pixels (0).\n2. For each white component:\n   a. Check if *any* pixel belonging to the component is adjacent (8-way) to \n      a pixel located on the absolute border of the grid (row 0, row H-1, \n      col 0, or col W-1). Adjacency includes diagonal neighbors.\n   b. If any pixel in the component is adjacent to the border, recolor all \n      pixels in that component to red (2).\n   c. If no pixel in the component is adjacent to the border, recolor all \n      pixels in that component to green (3).\n3. Pixels that were not originally white remain unchanged.\n\"\"\"\n\ndef _is_valid(r, c, height, width):\n    \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef _is_border_pixel(r, c, height, width):\n    \"\"\"Checks if a pixel coordinate is on the absolute border.\"\"\"\n    # Note: This function assumes r, c might be out of bounds, \n    # but the way it's used ensures _is_valid is implicitly checked first,\n    # or the check is simply whether the coordinates *match* border indices.\n    # For clarity and safety if reused, explicitly add bounds check.\n    if not _is_valid(r, c, height, width):\n         return False # Cannot be a border pixel if out of bounds\n    return r == 0 or r == height - 1 or c == 0 or c == width - 1\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring connected components of white pixels.\n    Components adjacent to the border become red (2).\n    Components not adjacent to the border become green (3).\n    Other pixels remain unchanged.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output_grid as a copy of the input\n    output_array = np.copy(input_array)\n    \n    # Keep track of visited white pixels to avoid processing components multiple times\n    visited = np.zeros_like(input_array, dtype=bool)\n\n    # Define 8-directional neighbours (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1), (1, 0), (1, 1)]\n\n    # Iterate through each pixel of the grid\n    for r in range(height):\n        for c in range(width):\n            # Check if the current pixel is white (0) and hasn't been processed yet\n            if input_array[r, c] == 0 and not visited[r, c]:\n                \n                # Found the start of a new white component, perform BFS\n                component_coords = []\n                is_component_border_adjacent = False # Flag for the whole component\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark the starting pixel visited\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.append((curr_r, curr_c))\n\n                    # Check neighbours of the CURRENT component pixel for border adjacency\n                    # If we haven't already determined this component touches the border...\n                    if not is_component_border_adjacent: \n                        for dr, dc in directions:\n                            nr, nc = curr_r + dr, curr_c + dc\n                            # Check if this neighbour coordinate (nr, nc) IS a border pixel\n                            # We need _is_valid here because nr, nc could be out of bounds\n                            if _is_valid(nr, nc, height, width) and _is_border_pixel(nr, nc, height, width):\n                                is_component_border_adjacent = True\n                                # Optimization: Found one border adjacent neighbour for this component, \n                                # no need to check others for border adjacency. \n                                # We still need to continue BFS to find all component pixels.\n                                break # Break inner loop (checking neighbours for border)\n\n                    # Explore neighbours to continue BFS (find other WHITE pixels in the component)\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check if the neighbour is valid, is white, and not visited\n                        if _is_valid(nr, nc, height, width) and \\\n                           input_array[nr, nc] == 0 and \\\n                           not visited[nr, nc]:\n                            \n                            visited[nr, nc] = True # Mark neighbour as visited immediately\n                            q.append((nr, nc)) # Add neighbour to the queue\n\n                # After BFS, determine the color for the entire component\n                target_color = 2 if is_component_border_adjacent else 3\n                \n                # Apply the color to all pixels in the found component\n                for comp_r, comp_c in component_coords:\n                    output_array[comp_r, comp_c] = target_color\n            \n            # If pixel is not white or already visited, do nothing\n\n    # Convert the numpy array back to a list of lists for the expected output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11556,
    "candidates_token_count": 1305,
    "total_token_count": 12861,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 119.724669,
  "retries": null
}