{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRecolor connected components of white pixels (0) based on their adjacency to the grid's border.\n\n1. Initialize the output grid as a copy of the input grid.\n2. Create a 'visited' grid to track processed white pixels.\n3. Iterate through each pixel (r, c) of the input grid.\n4. If a pixel is white (0) and hasn't been visited:\n    a. Start a search (e.g., Breadth-First Search) to find all connected white pixels forming a component. Use 8-way adjacency (including diagonals).\n    b. Keep track of all coordinates belonging to this component.\n    c. During the search, determine if *any* pixel within the component is adjacent to the grid's absolute border (row 0, row H-1, col 0, or col W-1). Set a flag `is_border_adjacent` if this occurs.\n    d. Mark all pixels in the component as visited.\n    e. After finding the complete component:\n        i. If `is_border_adjacent` is True, change the color of all pixels in this component in the output grid to red (2).\n        ii. If `is_border_adjacent` is False, change the color of all pixels in this component in the output grid to green (3).\n5. Pixels that were not white initially remain unchanged.\n6. Return the modified output grid.\n\"\"\"\n\ndef _is_valid(r, c, height, width):\n    \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef _is_border_pixel(r, c, height, width):\n    \"\"\"Checks if a pixel coordinate is on the absolute border.\"\"\"\n    return r == 0 or r == height - 1 or c == 0 or c == width - 1\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring connected components of white pixels.\n    Components adjacent to the border become red (2).\n    Components not adjacent to the border become green (3).\n    Other pixels remain unchanged.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output_grid as a copy of the input\n    output_array = np.copy(input_array)\n    \n    # Keep track of visited white pixels to avoid processing components multiple times\n    visited = np.zeros_like(input_array, dtype=bool)\n\n    # Iterate through each pixel of the grid\n    for r in range(height):\n        for c in range(width):\n            # Check if the current pixel is white (0) and hasn't been processed yet\n            if input_array[r, c] == 0 and not visited[r, c]:\n                \n                # Found the start of a new white component, perform BFS\n                component_coords = []\n                is_component_border_adjacent = False\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.append((curr_r, curr_c))\n\n                    # Check if this specific pixel is adjacent to the border\n                    # Optimization: only need to check once per component\n                    if not is_component_border_adjacent:\n                        # Check 8 neighbours of the current pixel\n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                if dr == 0 and dc == 0:\n                                    continue\n                                nr, nc = curr_r + dr, curr_c + dc\n                                # Check if the neighbour coordinate itself is a border coordinate\n                                # We don't care about the neighbour's color, just its position\n                                if _is_border_pixel(nr, nc, height, width):\n                                    # Check if the border pixel is *actually* a border pixel,\n                                    # not just out of bounds. A simple way is to check if the current\n                                    # pixel itself is one step away from the edge.\n                                    if curr_r == 1 or curr_r == height - 2 or curr_c == 1 or curr_c == width - 2:\n                                      is_component_border_adjacent = True\n                                      # No need to check further neighbours for *this* pixel\n                                      # but continue BFS to find rest of component\n                                      # break # Incorrect place to break inner loop\n                                # No need for inner breaks, just set the flag once\n\n                    # Explore neighbours for BFS continuation\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            \n                            nr, nc = curr_r + dr, curr_c + dc\n                            \n                            # Check if the neighbour is valid, is white, and not visited\n                            if _is_valid(nr, nc, height, width) and \\\n                               input_array[nr, nc] == 0 and \\\n                               not visited[nr, nc]:\n                                \n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # After BFS, determine the color for the entire component\n                target_color = 2 if is_component_border_adjacent else 3\n                \n                # Apply the color to all pixels in the found component\n                for comp_r, comp_c in component_coords:\n                    output_array[comp_r, comp_c] = target_color\n            \n            # If pixel is not white or already visited, do nothing\n\n    # Convert the numpy array back to a list of lists for the expected output format\n    return output_array.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18285,
    "candidates_token_count": 1339,
    "total_token_count": 19624,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.643077,
  "retries": null
}