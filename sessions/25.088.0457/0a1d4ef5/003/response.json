{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all solid, monochromatic, non-white rectangles within the input grid.\nSorts these rectangles based on their top-left corner coordinates (first by row, then by column).\nExtracts the colors of the sorted rectangles.\nDetermines the dimensions (R, C) for the output grid such that R * C equals the total number of rectangles (N), \nthe absolute difference |R - C| is minimized, and R is minimized in case of ties.\nArranges the extracted colors into the R x C output grid in row-major order.\n\"\"\"\n\ndef _find_connected_component(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds a connected component of the same color starting from (start_row, start_col).\n    Uses Breadth-First Search (BFS). Handles only 4-way adjacency.\n    Returns the color, set of pixel coordinates (as tuples), and marks visited pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    target_color = grid[start_row, start_col]\n    \n    # Skip background color or already visited pixels\n    if target_color == 0 or visited[start_row, start_col]:\n        return None, None, visited\n\n    q = deque([(start_row, start_col)])\n    component_pixels = set()\n    visited[start_row, start_col] = True\n    component_pixels.add((start_row, start_col))\n\n    while q:\n        r, c = q.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not visited[nr, nc] and grid[nr, nc] == target_color:\n                visited[nr, nc] = True\n                component_pixels.add((nr, nc))\n                q.append((nr, nc))\n\n    return target_color, component_pixels, visited\n\ndef _get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_row = min(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n    return min_row, min_col, max_row, max_col\n\ndef _is_solid_rectangle(pixels, min_row, min_col, max_row, max_col):\n    \"\"\"Checks if the set of pixels forms a solid rectangle within the bounding box.\"\"\"\n    if not pixels:\n        return False\n    expected_size = (max_row - min_row + 1) * (max_col - min_col + 1)\n    actual_size = len(pixels)\n    \n    # Quick check: if the number of pixels doesn't match the bounding box area, it's not solid.\n    if expected_size != actual_size:\n        return False\n        \n    # Optional: Verify all pixels within the bounding box are present in the set. \n    # This is redundant if expected_size == actual_size and components are found correctly.\n    # for r in range(min_row, max_row + 1):\n    #     for c in range(min_col, max_col + 1):\n    #         if (r, c) not in pixels:\n    #             return False # A pixel within the bounds is missing\n\n    return True\n\ndef _find_solid_rectangles(grid):\n    \"\"\"\n    Finds all solid, monochromatic, non-background rectangles in the grid.\n    Returns a list of tuples: ((min_row, min_col), color).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = [] # Stores ((row, col), color) for sorting\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Find the connected component starting from this pixel\n                color, pixels, visited = _find_connected_component(grid, r, c, visited)\n\n                if pixels:\n                    # Calculate the bounding box\n                    min_row, min_col, max_row, max_col = _get_bounding_box(pixels)\n\n                    # Check if the component forms a solid rectangle\n                    if _is_solid_rectangle(pixels, min_row, min_col, max_row, max_col):\n                        # Store the top-left coordinate and color\n                        rectangles.append(((min_row, min_col), color))\n                        \n    return rectangles\n\ndef _get_output_dimensions(n):\n    \"\"\"\n    Calculates the optimal output grid dimensions (R, C) for N elements.\n    N = R * C\n    Minimizes |R - C|, then minimizes R among ties.\n    \"\"\"\n    if n == 0:\n        return 0, 0\n    if n == 1:\n        return 1, 1\n        \n    best_r, best_c = 1, n\n    min_diff = abs(1 - n)\n\n    # Iterate up to the square root of n to find factor pairs\n    for r in range(1, int(n**0.5) + 1):\n        if n % r == 0:\n            c = n // r\n            diff = abs(r - c)\n            \n            # Check if this pair (r, c) is better\n            if diff < min_diff:\n                min_diff = diff\n                best_r, best_c = r, c\n            elif diff == min_diff:\n                # If differences are equal, choose the one with smaller R\n                if r < best_r:\n                    best_r, best_c = r, c\n            \n            # Also consider the swapped pair (c, r) if r != c\n            if r * r != n:\n                diff_swapped = abs(c - r) # Same difference\n                # Check if this pair (c, r) is better (only if c < best_r)\n                # Since we know diff == diff_swapped == min_diff here\n                if c < best_r:\n                     best_r, best_c = c, r\n                     \n    return best_r, best_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding solid rectangles, sorting them, \n    extracting their colors, and reshaping them into an optimal grid.\n    \"\"\"\n    # Convert input to NumPy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify Rectangles: Find all solid monochromatic rectangles\n    rectangles = _find_solid_rectangles(input_np)\n\n    # 2. Sort Rectangles: Sort by top-left corner (row, then column)\n    rectangles.sort(key=lambda x: x[0]) # Sorts based on the (row, col) tuple\n\n    # 3. Extract Colors: Get the list of colors in sorted order\n    rectangle_colors = [color for pos, color in rectangles]\n    num_rectangles = len(rectangle_colors)\n\n    # 4. Calculate Output Dimensions\n    output_rows, output_cols = _get_output_dimensions(num_rectangles)\n\n    # Handle the case where no rectangles are found\n    if num_rectangles == 0:\n         # Check if dimensions are also 0, return empty list of lists\n         if output_rows == 0 and output_cols == 0:\n              # Representing an empty grid might vary; list of empty list common\n              return [[]] \n         else: # Should not happen with current _get_output_dimensions logic\n             raise ValueError(\"Calculated non-zero dimensions for zero rectangles\")\n\n    # 5. Construct Output Grid: Reshape the colors into the R x C grid\n    # Ensure colors list isn't empty before reshape if num_rectangles > 0\n    if not rectangle_colors:\n         raise ValueError(\"Found non-zero rectangle count but color list is empty\")\n         \n    output_grid_np = np.array(rectangle_colors).reshape((output_rows, output_cols))\n\n    # Convert the final NumPy array back to a standard list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18515,
    "candidates_token_count": 2013,
    "total_token_count": 20528,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.178123,
  "retries": null
}