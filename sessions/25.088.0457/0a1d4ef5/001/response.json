{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all solid, monochromatic, non-white rectangles within the input grid.\nSorts these rectangles based on their top-left corner coordinates (first by row, then by column).\nExtracts the colors of the sorted rectangles.\nDetermines the dimensions (R, C) for the output grid such that R * C equals the total number of rectangles (N), \nthe absolute difference |R - C| is minimized, and R is minimized in case of ties.\nArranges the extracted colors into the R x C output grid in row-major order.\n\"\"\"\n\ndef _find_connected_component(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds a connected component of the same color starting from (start_row, start_col).\n    Uses Breadth-First Search (BFS).\n    Returns the color, set of pixel coordinates, and marks visited pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    target_color = grid[start_row, start_col]\n    if target_color == 0:  # Ignore background\n        return None, None\n\n    q = deque([(start_row, start_col)])\n    component_pixels = set()\n    visited[start_row, start_col] = True\n    component_pixels.add((start_row, start_col))\n\n    while q:\n        r, c = q.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not visited[nr, nc] and grid[nr, nc] == target_color:\n                visited[nr, nc] = True\n                component_pixels.add((nr, nc))\n                q.append((nr, nc))\n\n    return target_color, component_pixels\n\ndef _get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_row = min(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n    return min_row, min_col, max_row, max_col\n\ndef _get_output_dimensions(n):\n    \"\"\"\n    Calculates the optimal output grid dimensions (R, C) for N elements.\n    Minimizes |R - C|, then minimizes R.\n    \"\"\"\n    if n == 0:\n        return 0, 0\n    best_r, best_c = 1, n\n    min_diff = abs(1 - n)\n\n    for r in range(1, int(n**0.5) + 1):\n        if n % r == 0:\n            c = n // r\n            diff = abs(r - c)\n            if diff < min_diff:\n                min_diff = diff\n                best_r, best_c = r, c\n            elif diff == min_diff:\n                # If differences are equal, prefer smaller number of rows (r)\n                if r < best_r:\n                    best_r, best_c = r, c\n\n    # Also check the other factor pair (c, r) if r*r != n\n    if n % best_r == 0:\n         c_check = n // best_r\n         r_check = best_r\n         if abs(c_check - r_check) < min_diff:\n              min_diff = abs(c_check - r_check)\n              best_r, best_c = r_check, c_check\n         elif abs(c_check - r_check) == min_diff:\n              if r_check < best_r:\n                  best_r, best_c = r_check, c_check\n\n         # Check the pair (n/r, r) where r is the factor\n         r_factor = int(n**0.5)\n         while r_factor > 0:\n             if n % r_factor == 0:\n                 c_factor = n // r_factor\n                 if abs(c_factor - r_factor) < min_diff:\n                     min_diff = abs(c_factor - r_factor)\n                     best_r, best_c = c_factor, r_factor # Assign c, r\n                 elif abs(c_factor - r_factor) == min_diff:\n                     if c_factor < best_r: # Prefer smaller rows (c_factor here)\n                        best_r, best_c = c_factor, r_factor\n             r_factor -=1\n\n\n    # Ensure R is always less than or equal to C if difference is the same\n    # This logic is slightly adjusted to prioritize minimizing |R-C| first,\n    # then minimizing R among those with the minimum difference.\n    factors = []\n    for r_factor in range(1, int(n**0.5) + 1):\n        if n % r_factor == 0:\n            c_factor = n // r_factor\n            factors.append(((r_factor, c_factor), abs(r_factor - c_factor)))\n            if r_factor*r_factor != n:\n                 factors.append(((c_factor, r_factor), abs(c_factor - r_factor))) # Add the swapped pair\n\n    if not factors: # Should only happen for n=1\n        return 1, 1\n\n    min_diff_final = min(diff for _, diff in factors)\n    best_pair = min(\n        (pair for pair, diff in factors if diff == min_diff_final),\n        key=lambda p: p[0] # Minimize R among pairs with min difference\n    )\n\n    return best_pair[0], best_pair[1]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Finds solid rectangles in the input, sorts them, and arranges their colors\n    into an optimally sized output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    visited = np.zeros_like(input_np, dtype=bool)\n    rectangles = [] # Store as (min_row, min_col, color)\n\n    # Iterate through each cell to find potential starting points of objects\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and input_np[r, c] != 0:\n                # Find the connected component starting from this cell\n                color, pixels = _find_connected_component(input_np, r, c, visited)\n\n                if pixels:\n                    # Calculate the bounding box of the component\n                    min_row, min_col, max_row, max_col = _get_bounding_box(pixels)\n\n                    # Check if it's a solid rectangle\n                    expected_size = (max_row - min_row + 1) * (max_col - min_col + 1)\n                    actual_size = len(pixels)\n\n                    if expected_size == actual_size:\n                        # Check if all pixels within the bounding box actually belong to the component\n                        is_solid = True\n                        # No need for this extra check if expected_size == actual_size for non-overlapping components\n                        # for check_r in range(min_row, max_row + 1):\n                        #     for check_c in range(min_col, max_col + 1):\n                        #         if (check_r, check_c) not in pixels:\n                        #             is_solid = False\n                        #             break\n                        #     if not is_solid:\n                        #         break\n\n                        # If it is a solid rectangle, add it to our list\n                        if is_solid:\n                             rectangles.append(((min_row, min_col), color)) # Store top-left and color\n\n\n    # Sort rectangles by top-left corner (row, then column)\n    rectangles.sort(key=lambda x: x[0])\n\n    # Extract colors in sorted order\n    rectangle_colors = [color for pos, color in rectangles]\n    num_rectangles = len(rectangle_colors)\n\n    # Determine output grid dimensions\n    output_rows, output_cols = _get_output_dimensions(num_rectangles)\n\n    # Create and populate the output grid\n    if num_rectangles == 0:\n        # Handle case with no rectangles found (return empty or specific format)\n        # Based on examples, if N rectangles are found, output is RxC where R*C=N.\n        # If N=0, perhaps an empty grid? Or 1x1 with 0? Let's assume empty based on task structure.\n        # The examples guarantee rectangles exist. If test case had 0, need clarification.\n        # For now, let's return a 1x1 grid with 0 if no rectangles found, although this scenario\n        # isn't covered by the provided training examples. Let's stick to the pattern:\n         if output_rows * output_cols == 0 and num_rectangles == 0:\n             return np.array([[]], dtype=int) # Or handle as error/specific case\n         elif output_rows * output_cols == 0 and num_rectangles > 0:\n             # This shouldn't happen with the current logic of get_output_dimensions\n             raise ValueError(\"Calculated 0 dimension for non-zero rectangles\")\n\n\n    output_grid = np.array(rectangle_colors).reshape((output_rows, output_cols))\n\n    return output_grid.tolist() # Convert back to list of lists as per typical ARC format\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7778,
    "candidates_token_count": 2299,
    "total_token_count": 10077,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.934645,
  "retries": null
}