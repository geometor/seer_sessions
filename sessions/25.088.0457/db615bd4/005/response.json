{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the background color, which is the most frequent color in the input grid.\n2.  Find all 'marker pixels'. These are any pixels whose color is *not* the background color.\n3.  Group the locations (row, column) of these marker pixels by their color.\n4.  Initialize the output grid as a copy of the input grid.\n5.  For each distinct marker color found in step 3:\n    a.  Get the list of locations for all markers of this color.\n    b.  Determine the bounding box (minimum row, maximum row, minimum column, maximum column) that encloses all these marker locations.\n    c.  Iterate through every cell (r, c) within this bounding box (inclusive).\n    d.  Check the color of the cell at (r, c) in the *original input grid*.\n    e.  If the original color at (r, c) was the background color, change the color of the cell at (r, c) in the *output grid* to the current marker color.\n    f.  If the original color was *not* the background color (i.e., it was another marker color or part of the initial pattern), leave the cell in the output grid unchanged (it retains its original color from the input copy).\n6.  Return the modified output grid.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Identifies the background color (most frequent).\n    Defaults to 0 if the grid is empty or has no dominant color in a specific way,\n    though ARC grids usually have a clear background.\n    \"\"\"\n    if grid.size == 0:\n        return 0 # Default for empty grid\n    flat_grid = grid.flatten()\n    color_counts = Counter(flat_grid)\n    \n    # The most common color is the background\n    # If there's a tie, Counter returns one of the most common ones.\n    # If the grid is uniform, that color is the background.\n    most_common_color = color_counts.most_common(1)\n    if not most_common_color:\n         # This case should ideally not happen for valid ARC grids\n         # If it somehow does (e.g., grid exists but Counter is empty?), default to 0.\n        return 0\n    bg_color = most_common_color[0][0]\n    \n    return bg_color\n\ndef find_marker_pixels_and_groups(grid, bg_color):\n    \"\"\"\n    Finds all pixels that are NOT the background color and groups their \n    locations by their color.\n    \"\"\"\n    marker_pixels_by_color = defaultdict(list)\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the color is NOT the background color\n            if color != bg_color:\n                marker_pixels_by_color[color].append((r, c))\n    return marker_pixels_by_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: identifies background, finds marker\n    groups (non-background pixels), calculates their bounding boxes, and fills \n    these boxes conditionally on the output grid based on whether the original\n    pixel was the background color.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    try:\n        input_array = np.array(input_grid, dtype=int)\n    except ValueError: # Handles potentially jagged lists if input isn't rectangular\n         # Or return error, depending on expected behavior for invalid input.\n         # Assuming valid rectangular grid input based on ARC spec.\n         print(\"Error: Input grid is not rectangular.\")\n         # Returning input might be safer than guessing\n         return input_grid \n\n\n    # Handle empty grid case\n    if input_array.size == 0:\n        return [] # Return empty list for empty input\n        \n    # Initialize output_grid as a copy of the input\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # 1. Identify Background color using frequency\n    bg_color = get_background_color(input_array)\n\n    # 2. Find marker pixels (non-background) and group them by color\n    marker_groups = find_marker_pixels_and_groups(input_array, bg_color)\n\n    # 3. Process each marker color group\n    for marker_color, locations in marker_groups.items():\n        if not locations: # Skip if a color somehow has no locations\n            continue\n\n        # 4a. Determine Bounding Box for the current marker group\n        rows_present = [r for r, c in locations]\n        cols_present = [c for r, c in locations]\n        # Check if rows_present or cols_present is empty before calling min/max\n        # This check is redundant given the 'if not locations:' above, but safe.\n        if not rows_present or not cols_present: \n            continue \n            \n        min_r, max_r = min(rows_present), max(rows_present)\n        min_c, max_c = min(cols_present), max(cols_present)\n\n        # 4b. Fill Bounding Box Conditionally\n        for r in range(min_r, max_r + 1):\n            # Ensure r is within grid bounds (safety check, though bounding box should be)\n            if r < 0 or r >= rows: continue \n            for c in range(min_c, max_c + 1):\n                 # Ensure c is within grid bounds (safety check)\n                if c < 0 or c >= cols: continue\n                \n                # 4c/d/e. Check ORIGINAL color and update OUTPUT if it was background\n                if input_array[r, c] == bg_color:\n                    output_array[r, c] = marker_color\n                    \n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13591,
    "candidates_token_count": 1404,
    "total_token_count": 14995,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.693798,
  "retries": null
}