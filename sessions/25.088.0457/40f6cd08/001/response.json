{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict\n\n\"\"\"\nIdentifies distinct non-background objects in the input grid.\nGroups these objects based on their primary \"frame\" color.\nFor each group, identifies one object as a \"template\" if it contains an internal pattern (colors different from the frame color).\nIdentifies other objects in the same group as \"targets\" if they consist solely of the frame color.\nCopies the internal pattern from the template object onto the corresponding internal area of each target object, respecting the target's boundaries.\nThe background color is white (0).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components of non-background colors.\n    Returns a list of objects, where each object is represented by:\n    - set of pixel coordinates {(r, c), ...}\n    - bounding box (min_r, min_c, max_r, max_c)\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                # Start BFS for a new object\n                q = deque([(r, c)])\n                visited[r, c] = True\n                pixels = set([(r, c)])\n                min_r, min_c, max_r, max_c = r, c, r, c\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            pixels.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'pixels': pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_object_properties(obj, grid):\n    \"\"\"\n    Determines the frame color and whether the object has an internal pattern.\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    pixels = obj['pixels']\n    \n    frame_colors = defaultdict(int)\n    has_internal_pattern = False\n    internal_pixels = set()\n    \n    # Check pixels on the boundary first to guess frame color\n    for r, c in pixels:\n        is_on_boundary = (r == min_r or r == max_r or c == min_c or c == max_c)\n        if is_on_boundary:\n            frame_colors[grid[r,c]] += 1\n        else:\n            internal_pixels.add((r,c))\n\n    if not frame_colors: # Handle 1x1 objects or objects where all pixels are internal? This shouldn't happen with bbox definition.\n        # If no clear boundary pixels (e.g., single pixel object), use the pixel's color.\n        if pixels:\n            r, c = next(iter(pixels))\n            frame_color = grid[r, c]\n        else:\n            return None, False, None # Should not happen\n\n    else:\n        # Assume frame color is the most common color on the boundary\n        frame_color = max(frame_colors, key=frame_colors.get)\n\n    # Check if any internal pixel has a color different from the frame color\n    pattern_details = {} # Store relative coords and colors of the pattern\n    for r, c in internal_pixels:\n        pixel_color = grid[r,c]\n        if pixel_color != frame_color:\n            has_internal_pattern = True\n            dr = r - min_r\n            dc = c - min_c\n            pattern_details[(dr, dc)] = pixel_color\n            \n    # Also check boundary pixels that don't match the frame color (might be part of pattern)\n    for r, c in pixels:\n         is_on_boundary = (r == min_r or r == max_r or c == min_c or c == max_c)\n         if is_on_boundary and grid[r,c] != frame_color:\n             has_internal_pattern = True\n             dr = r - min_r\n             dc = c - min_c\n             pattern_details[(dr, dc)] = grid[r,c]\n\n\n    is_solid = not has_internal_pattern and all(grid[r,c] == frame_color for r,c in pixels)\n            \n    return frame_color, has_internal_pattern, is_solid, pattern_details\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies template and target objects based on frame color and internal patterns,\n    then copies the pattern from the template to the targets.\n    \"\"\"\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all distinct objects\n    objects = find_objects(input_grid)\n    \n    # Group objects by potential frame color and identify templates/targets\n    grouped_objects = defaultdict(lambda: {'template': None, 'targets': [], 'pattern': None})\n    \n    for obj in objects:\n        props = get_object_properties(obj, input_grid)\n        if props:\n            frame_color, has_pattern, is_solid, pattern_details = props\n            if frame_color is not None:\n                obj_data = {'bbox': obj['bbox'], 'pixels': obj['pixels']}\n                if has_pattern:\n                    # Assume only one template per color group\n                    if grouped_objects[frame_color]['template'] is None:\n                        grouped_objects[frame_color]['template'] = obj_data\n                        grouped_objects[frame_color]['pattern'] = pattern_details\n                    else:\n                        # Handle case with multiple patterns? For now, overwrite or ignore.\n                        # Let's stick to the assumption of one template per color.\n                        pass \n                elif is_solid:\n                    grouped_objects[frame_color]['targets'].append(obj_data)\n\n    # Apply patterns from templates to targets\n    for frame_color, group in grouped_objects.items():\n        template = group['template']\n        pattern = group['pattern']\n        targets = group['targets']\n        \n        if template and pattern and targets:\n            template_min_r, template_min_c, _, _ = template['bbox']\n            \n            for target in targets:\n                target_min_r, target_min_c, target_max_r, target_max_c = target['bbox']\n                \n                # Iterate through the pattern elements\n                for (dr, dc), pattern_color in pattern.items():\n                    # Calculate absolute position in the target\n                    abs_r = target_min_r + dr\n                    abs_c = target_min_c + dc\n                    \n                    # Check if the absolute position is within the target's bounding box\n                    if target_min_r <= abs_r <= target_max_r and \\\n                       target_min_c <= abs_c <= target_max_c:\n                        # Check if the original pixel in the target was the frame color\n                        # This ensures we only overwrite the 'fill' part, not potential structure already there\n                        # or parts outside the object's original pixels.\n                        # Use the original input_grid for this check.\n                        # Also check if the target location actually belongs to the target object pixels.\n                        if (abs_r, abs_c) in target['pixels'] and input_grid[abs_r, abs_c] == frame_color:\n                             output_grid[abs_r, abs_c] = pattern_color\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12898,
    "candidates_token_count": 1947,
    "total_token_count": 14845,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.889652,
  "retries": null
}