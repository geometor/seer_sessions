{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule (Hypothesized - Requires Validation with Examples):\n\n1.  **Identify Background:** Determine the background color, typically the most frequent color or color 0, possibly confirmed by checking grid borders.\n2.  **Find Objects:** Locate all contiguous regions of non-background colors using orthogonal connectivity.\n3.  **Categorize Objects (Tentative):** If multiple objects exist, heuristically separate them. Assume the largest object is the 'main canvas'. Assume smaller objects are potential 'key' or 'reference' patterns. This distinction needs validation.\n4.  **Identify Key Pattern (Tentative):** Search within the 'key' objects for a simple, predefined pattern. A common pattern in ARC is adjacency. Look for two different non-background colors orthogonally adjacent to each other within the same key object. Record these two colors (e.g., `color1`, `color2`) and the ID of the key object containing this pattern. Use the first valid pattern found. This pattern identification needs validation.\n5.  **Identify Transformation Parameters (Tentative):**\n    *   Assume the `main canvas` object has a dominant color (`main_color`).\n    *   Based on the key pattern (`color1`, `color2`), assume one color acts as a 'marker' (`marker_color = color1`) and the other as the 'target' (`target_color = color2`). This assignment might need swapping or refinement based on examples.\n    *   Check if the `marker_color` exists anywhere within the `main canvas` object.\n6.  **Apply Transformation - Paint Rows/Columns (Tentative):**\n    *   If the `marker_color` is found within the `main canvas`:\n        *   Find all locations (r, c) of the `marker_color` within the `main canvas` object.\n        *   Collect the set of unique row indices (`marker_rows`) and column indices (`marker_cols`) from these locations.\n        *   Iterate through the output grid. For any pixel (r, c) whose original color was the `main_color`, if its row `r` is in `marker_rows` OR its column `c` is in `marker_cols`, change its color to the `target_color`. This painting logic needs validation.\n7.  **Clean Up (Tentative):** Remove the 'key' object that contained the identified pattern by replacing its pixels in the output grid with the background color. This cleanup step needs validation.\n8.  **Return:** Return the modified grid. If no key pattern or main object is found matching the criteria, return a copy of the input grid.\n\n**Note:** This program is based on hypotheses derived from previous attempts and common ARC patterns. The categorization of objects, the specific key pattern, the roles of colors from the key, the painting logic, and the cleanup step are all tentative and require validation against the specific task examples. The previous version timed out, suggesting the logic (especially around detailed marker finding and object interactions) might be overly complex or incorrect. This version simplifies some steps but retains the overall structure.\n\"\"\"\n\n# Imports\nimport numpy as np\nfrom collections import Counter, deque\n\n# Helper Functions\ndef get_background_color(grid):\n    \"\"\"Determines the background color (most frequent, often 0).\"\"\"\n    if grid.size == 0:\n        return 0\n    counts = Counter(grid.flatten())\n    # Check border pixels as a heuristic reinforcement\n    rows, cols = grid.shape\n    border_pixels = []\n    if rows > 0:\n        border_pixels.extend(grid[0, :])  # Top row\n        border_pixels.extend(grid[-1, :]) # Bottom row\n    if cols > 0:\n        border_pixels.extend(grid[:, 0])  # Left col\n        border_pixels.extend(grid[:, -1]) # Right col\n\n    if not counts:\n        return 0\n\n    most_common = counts.most_common()\n    candidate = most_common[0][0]\n\n    # If border pixels are mostly one color, prefer that as background\n    if border_pixels:\n        border_counts = Counter(border_pixels)\n        border_candidate, border_count = border_counts.most_common(1)[0]\n        # Check if this border candidate is significantly present\n        if border_count > len(border_pixels) / 2:\n             # Check if it's also the overall most common or close to it\n             if border_candidate == candidate or border_counts[border_candidate] >= counts[candidate] * 0.8:\n                  return border_candidate\n\n    # Default to most frequent if border check isn't decisive\n    # Tie-breaking: prefer lower color index if counts are equal\n    if len(most_common) > 1 and most_common[0][1] == most_common[1][1]:\n         if most_common[0][0] > most_common[1][0]:\n             return most_common[1][0]\n    return candidate\n\ndef find_objects_bfs(grid, ignore_color):\n    \"\"\"Finds connected components (objects) using BFS, ignoring a specified color.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 1\n    labeled_grid = np.zeros_like(grid, dtype=int) # Grid showing which object ID each pixel belongs to\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != ignore_color:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_colors = Counter()\n                current_object_id = object_id_counter\n\n                while q:\n                    row, col = q.popleft()\n                    pixel_color = grid[row, col]\n\n                    # Check if the pixel belongs to the object (not background)\n                    # This check prevents adding background pixels inadvertently included during BFS expansion\n                    # if a non-background pixel touches a background pixel.\n                    if grid[row, col] != ignore_color:\n                        obj_coords.append((row, col))\n                        labeled_grid[row, col] = current_object_id\n                        component_colors[pixel_color] += 1\n\n                        # Explore neighbors (orthogonal)\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] != ignore_color:\n                                # Only add valid neighbors to queue and mark visited\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    # Mark visited even if it was ignored color, to prevent reprocessing\n                    visited[r,c] = True # Mark visited after processing neighbors\n\n                if obj_coords:\n                    coords_array = np.array(obj_coords)\n                    min_r, min_c = coords_array.min(axis=0)\n                    max_r, max_c = coords_array.max(axis=0)\n                    objects.append({\n                        'id': current_object_id,\n                        'coords': coords_array,\n                        'colors': dict(component_colors),\n                        'size': len(obj_coords),\n                        'bounding_box': ((min_r, min_c), (max_r, max_c)),\n                        'dominant_color': max(component_colors, key=component_colors.get) if component_colors else -1\n                    })\n                    object_id_counter += 1\n            visited[r, c] = True # Ensure all pixels get visited\n\n    return labeled_grid, objects\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\"Gets orthogonal neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the hypothesized transformation based on finding a key pattern\n    in a small object and using it to modify a larger object.\n    \"\"\"\n    input_grid = np.array(input_grid_list)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Background\n    background_color = get_background_color(input_grid)\n\n    # 2. Find Objects\n    labeled_grid, objects = find_objects_bfs(input_grid, ignore_color=background_color)\n\n    if not objects:\n        return output_grid.tolist() # No objects to process\n\n    # 3. Categorize Objects (Tentative: Largest = Main, Others = Keys)\n    main_canvas = None\n    key_objects = []\n    if len(objects) == 1:\n        main_canvas = objects[0]\n    elif len(objects) > 1:\n        objects.sort(key=lambda x: x['size'], reverse=True)\n        main_canvas = objects[0]\n        key_objects = objects[1:]\n    else: # No objects found (shouldn't happen if not objects is checked, but defensive)\n         return output_grid.tolist()\n\n    # If no main canvas identified (e.g., only small objects), return input\n    if main_canvas is None:\n         return output_grid.tolist()\n\n    # 4. Identify Key Pattern (Tentative: Adjacency in a Key Object)\n    found_key_pattern = False\n    key_color1 = -1\n    key_color2 = -1\n    key_object_id_to_remove = -1\n    key_object_coords_to_remove = []\n\n    for key_obj in key_objects:\n        key_id = key_obj['id']\n        for r_coord, c_coord in key_obj['coords']:\n            current_pixel_color = input_grid[r_coord, c_coord]\n            # Check neighbors within the same key object\n            for nr, nc in get_neighbors(r_coord, c_coord, rows, cols):\n                if labeled_grid[nr, nc] == key_id: # Neighbor is part of the same key object\n                    neighbor_color = input_grid[nr, nc]\n                    # Found two different non-background colors adjacent\n                    if neighbor_color != current_pixel_color and neighbor_color != background_color:\n                        key_color1 = current_pixel_color\n                        key_color2 = neighbor_color\n                        key_object_id_to_remove = key_id\n                        key_object_coords_to_remove = key_obj['coords']\n                        found_key_pattern = True\n                        break # Found adjacent pair in this key object\n            if found_key_pattern: break\n        if found_key_pattern: break # Found pattern in the list of keys\n\n    # 5 & 6. Check for Marker in Main & Apply Transformation (Tentative)\n    if found_key_pattern and main_canvas:\n        marker_color = key_color1 # Hypothesis\n        target_color = key_color2 # Hypothesis\n        main_color = main_canvas['dominant_color']\n\n        # Check if marker_color exists in the main canvas\n        marker_locations_in_main = []\n        marker_present_in_main = False\n        for r_mc, c_mc in main_canvas['coords']:\n            if input_grid[r_mc, c_mc] == marker_color:\n                marker_locations_in_main.append((r_mc, c_mc))\n                marker_present_in_main = True\n                # Optimization: If we only need to know *if* it's present, can break here.\n                # break\n        \n        # If marker color is present, apply row/col painting\n        if marker_present_in_main:\n            marker_rows = set(r for r, c in marker_locations_in_main)\n            marker_cols = set(c for r, c in marker_locations_in_main)\n\n            # Apply Painting\n            for r in range(rows):\n                for c in range(cols):\n                    # Check if pixel belongs to the main canvas originally\n                    # and has the main color AND is in a marker row or column.\n                    # Using labeled_grid ensures we only paint within the main object's original area.\n                    if labeled_grid[r, c] == main_canvas['id'] and \\\n                       input_grid[r, c] == main_color and \\\n                       (r in marker_rows or c in marker_cols):\n                        # Ensure we don't overwrite the marker pixels themselves if marker == main\n                        is_marker_loc = False\n                        for mr, mc in marker_locations_in_main:\n                            if r == mr and c == mc:\n                                is_marker_loc = True\n                                break\n                        if not is_marker_loc:\n                             output_grid[r, c] = target_color\n                         # If marker pixels should *also* be painted, remove the 'if not is_marker_loc:' check\n\n            # 7. Clean Up (Tentative: Remove Key Object)\n            if key_object_id_to_remove != -1:\n                for r_k, c_k in key_object_coords_to_remove:\n                     if 0 <= r_k < rows and 0 <= c_k < cols: # Bounds check\n                          output_grid[r_k, c_k] = background_color\n\n    # Return the potentially modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6818,
    "candidates_token_count": 3194,
    "total_token_count": 10012,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.951215,
  "retries": null
}