{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom skimage.measure import label\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background color (most frequent color, often bordering the grid).\n2. Find all distinct contiguous objects that are not the background color.\n3. Differentiate objects into:\n    a. 'Main Regions': Large objects, predominantly composed of a single 'main_color'.\n    b. 'Noise Shapes': Small, potentially multi-colored objects, separate from main regions.\n4. Identify the 'marker_color': A color found both as isolated single pixels within main regions *and* as part of at least one noise shape.\n5. Identify the 'target_color': The color found orthogonally adjacent to the 'marker_color' within the noise shape.\n6. Identify the 'main_color': The dominant color of the main regions containing the isolated marker_color pixels.\n7. Find the locations (row, column) of all marker_color pixels situated within the identified main regions.\n8. Collect the unique row indices and column indices from these marker pixel locations.\n9. Create an output grid, initially a copy of the input grid.\n10. Iterate through the grid. For any pixel (r, c) where the input color is the 'main_color', if its row 'r' is in the collected marker rows OR its column 'c' is in the collected marker columns, change the color of that pixel in the output grid to the 'target_color'.\n11. Identify all pixel coordinates belonging to the noise shape(s).\n12. Replace the pixels corresponding to the noise shape(s) in the output grid with the background color.\n13. Return the modified output grid.\n\"\"\"\n\n# Helper functions\ndef find_objects(grid, ignore_color=-1):\n    \"\"\"\n    Finds connected components (objects) in the grid.\n    Optionally ignores a specific color (e.g., background).\n    Returns a labeled grid and a list of object properties.\n    \"\"\"\n    mask = grid != ignore_color if ignore_color != -1 else np.ones_like(grid, dtype=bool)\n    labeled_grid, num_labels = label(mask, connectivity=1, background=0, return_num=True) # Use connectivity=1 for orthogonal\n\n    objects = []\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        if coords.size > 0:\n            colors = grid[coords[:, 0], coords[:, 1]]\n            unique_colors, counts = np.unique(colors, return_counts=True)\n            objects.append({\n                'id': i,\n                'coords': coords,\n                'colors': dict(zip(unique_colors, counts)),\n                'size': len(coords),\n                'bounding_box': (coords.min(axis=0), coords.max(axis=0))\n            })\n    return labeled_grid, objects\n\ndef get_neighbors(grid, r, c, connectivity=1):\n    \"\"\"Gets neighbor coordinates and colors.\"\"\"\n    neighbors = []\n    rows, cols = grid.shape\n    coords = []\n    # Orthogonal neighbors (connectivity=1)\n    if r > 0: coords.append((r - 1, c))\n    if r < rows - 1: coords.append((r + 1, c))\n    if c > 0: coords.append((r, c - 1))\n    if c < cols - 1: coords.append((r, c + 1))\n    # Diagonal neighbors (connectivity=2)\n    if connectivity == 2:\n        if r > 0 and c > 0: coords.append((r - 1, c - 1))\n        if r > 0 and c < cols - 1: coords.append((r - 1, c + 1))\n        if r < rows - 1 and c > 0: coords.append((r + 1, c - 1))\n        if r < rows - 1 and c < cols - 1: coords.append((r + 1, c + 1))\n\n    for nr, nc in coords:\n        neighbors.append({'coord': (nr, nc), 'color': grid[nr, nc]})\n    return neighbors\n\ndef get_most_frequent_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle cases where the background might not be the absolute most frequent\n    # if multiple large areas exist. Check corners/borders if needed, but\n    # simple frequency often works for ARC.\n    if not counts:\n        return 0 # Default if grid is empty\n    return counts.most_common(1)[0][0]\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on marker pixels within main regions\n    and color relationships derived from separate noise shapes.\n    \"\"\"\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify background color\n    background_color = get_most_frequent_color(grid)\n\n    # 2. Find all non-background objects\n    labeled_grid, objects = find_objects(grid, ignore_color=background_color)\n\n    if not objects:\n        return output_grid # No objects to process\n\n    # 3. Differentiate Main Regions and Noise Shapes\n    # Heuristic: Main regions are significantly larger than noise shapes.\n    # We might need a more robust way, but size difference is often key in ARC.\n    sizes = [obj['size'] for obj in objects]\n    if not sizes:\n        return output_grid\n\n    # Use a threshold - e.g., objects smaller than 1/10th of the largest might be noise\n    # Or simply assume the smallest few are noise if there's a clear size gap.\n    # Let's sort by size and try to find a marker/target relationship in the smaller ones.\n    objects.sort(key=lambda x: x['size'])\n\n    potential_noise_shapes = []\n    potential_main_regions = []\n    # Simple split: smallest objects are potential noise, largest are potential main\n    # This might need adjustment based on task specifics. Assume at least one noise, one main.\n    # A better approach might involve checking color complexity too.\n    size_threshold = np.mean(sizes) # A possible heuristic\n    if len(objects) > 1:\n         for obj in objects:\n             # Noise shapes are small, main regions large. Use size comparison.\n             # Also check if object contains multiple colors, often true for noise\n             is_complex = len(obj['colors']) > 1\n             # A more robust check might be needed, maybe comparing against largest object size\n             if obj['size'] < size_threshold / 2 and is_complex : # Arbitrary threshold factor\n                 potential_noise_shapes.append(obj)\n             else:\n                 potential_main_regions.append(obj)\n    else: # Only one object found besides background\n        potential_main_regions = objects # Treat it as the main region\n\n    if not potential_main_regions: # If all objects classified as noise, maybe the threshold was wrong\n         potential_main_regions = objects # Revert\n         potential_noise_shapes = [] # Assume no noise shape if logic fails\n\n    # 4, 5, 6. Identify marker, target, and main colors\n    marker_color = -1\n    target_color = -1\n    main_color = -1\n    noise_shape_coords = []\n    marker_pixel_locations = [] # Store (r, c) tuples\n\n    # Find potential marker pixels (isolated pixels within potential main regions)\n    potential_markers = {} # {color: [(r, c), ...]}\n    for region in potential_main_regions:\n        region_coords_set = set(tuple(c) for c in region['coords'])\n        # Find the dominant color in this region\n        dominant_color_in_region = max(region['colors'], key=region['colors'].get)\n\n        for r, c in region['coords']:\n            pixel_color = grid[r, c]\n            if pixel_color != dominant_color_in_region:\n                 # Check if it's truly isolated within this region's dominant color\n                 is_isolated = True\n                 neighbor_colors = []\n                 for neighbor in get_neighbors(grid, r, c, connectivity=1):\n                     nc_r, nc_c = neighbor['coord']\n                     n_color = neighbor['color']\n                     neighbor_colors.append(n_color)\n                     # Check if neighbor is part of the *same* large region\n                     # This is tricky without re-labeling or complex checks.\n                     # Simplification: Check if neighbours are mostly the dominant color\n                 if all(nc == dominant_color_in_region or nc == pixel_color for nc in neighbor_colors) and any(nc == dominant_color_in_region for nc in neighbor_colors) :\n                      if pixel_color not in potential_markers:\n                          potential_markers[pixel_color] = []\n                      potential_markers[pixel_color].append(((r, c), dominant_color_in_region))\n\n\n    # Now check potential noise shapes for marker/target pairs\n    found_match = False\n    for noise_shape in potential_noise_shapes:\n        noise_colors = set(noise_shape['colors'].keys())\n        for pm_color, locations_and_main in potential_markers.items():\n            if pm_color in noise_colors:\n                # Found potential marker color. Look for adjacent target color in noise shape.\n                for r_noise, c_noise in noise_shape['coords']:\n                    if grid[r_noise, c_noise] == pm_color:\n                        for neighbor in get_neighbors(grid, r_noise, c_noise, connectivity=1):\n                            n_color = neighbor['color']\n                            # Ensure neighbor is part of the same noise object\n                            n_coord = neighbor['coord']\n                            is_neighbor_in_noise = False\n                            for c in noise_shape['coords']:\n                                if tuple(c) == n_coord:\n                                    is_neighbor_in_noise = True\n                                    break\n                            \n                            if is_neighbor_in_noise and n_color != pm_color and n_color != background_color:\n                                # Found potential target color adjacent to marker in noise\n                                marker_color = pm_color\n                                target_color = n_color\n                                # Assume the main color associated with the first found marker location\n                                main_color = locations_and_main[0][1]\n                                marker_pixel_locations = [loc[0] for loc in locations_and_main] # Get just the (r, c) tuples\n                                noise_shape_coords = noise_shape['coords']\n                                found_match = True\n                                break # Found target color\n                    if found_match: break\n            if found_match: break\n        if found_match: break\n\n    # If no match found via noise shape, the logic might be different or failed.\n    # Fallback or error handling could be added here. For now, proceed if found.\n    if not found_match:\n        # Maybe there's no noise shape, or the identification failed.\n        # Try a simpler rule if only markers and main regions are found?\n        # For this problem, the noise shape seems essential.\n        print(\"Warning: Could not reliably identify marker/target/main colors using noise shape.\")\n        # Attempt to guess based on most frequent non-background in main regions and isolated pixels\n        if potential_markers and potential_main_regions:\n             marker_color = list(potential_markers.keys())[0] # Guess first potential marker\n             main_color = potential_markers[marker_color][0][1] # Associated main color\n             marker_pixel_locations = [loc[0] for loc in potential_markers[marker_color]]\n             # Cannot determine target color without noise shape reliably\n             print(\"Cannot determine target color. Returning intermediate state.\")\n             # Might return output_grid without painting step or raise error\n             return output_grid # Or handle differently\n\n\n    # 7. Collect marker rows and columns\n    marker_rows = set()\n    marker_cols = set()\n    for r, c in marker_pixel_locations:\n        marker_rows.add(r)\n        marker_cols.add(c)\n\n    # 8. Apply transformation (Paint rows/columns)\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is in a marked row or column AND is the main color\n            if (r in marker_rows or c in marker_cols) and grid[r, c] == main_color:\n                output_grid[r, c] = target_color\n\n    # 9. Remove Noise Shape\n    if len(noise_shape_coords) > 0:\n        for r, c in noise_shape_coords:\n            output_grid[r, c] = background_color\n\n    # Note: The original marker pixels should remain unchanged if the painting\n    # logic correctly only targets 'main_color' pixels. Double check needed if\n    # marker_color == main_color, but examples suggest they are different.\n\n    return output_grid.tolist() # Convert back to list of lists if needed\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13716,
    "candidates_token_count": 3055,
    "total_token_count": 16771,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.414728,
  "retries": null
}