{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background color (most frequent color, often bordering the grid).\n2. Find all distinct contiguous objects (orthogonally connected) that are not the background color.\n3. Differentiate objects into:\n    a. 'Main Regions': Large objects, predominantly composed of a single 'main_color'.\n    b. 'Noise Shapes' / 'Reference Patterns': Small, potentially multi-colored objects, separate from main regions.\n4. Identify potential 'marker_pixels' within main regions: These are pixels whose color ('marker_color') differs from the main region's dominant color ('main_color') and are orthogonally surrounded only by the main_color or other identical marker_pixels within that same region.\n5. Identify the definitive 'marker_color' and 'target_color' by examining the noise shapes: Find a noise shape where a potential 'marker_color' (found in step 4) is orthogonally adjacent to another non-background color ('target_color'). Both adjacent pixels must belong to the same noise shape object.\n6. Identify the 'main_color': This is the dominant color of the main region(s) where the definitive marker_color pixels were found.\n7. Locate all confirmed 'marker_pixels' (r, c) within the main regions matching the definitive marker_color.\n8. Collect the unique row indices and column indices from these marker pixel locations.\n9. Create an output grid, initially a copy of the input grid.\n10. Apply 'painting': Iterate through the grid. For any pixel (r, c) where the input color is the 'main_color', if its row 'r' is in the collected marker rows OR its column 'c' is in the collected marker columns, change the color of that pixel in the output grid to the 'target_color'.\n11. Identify the noise shape object used as the reference in step 5.\n12. Remove the reference noise shape: Replace all pixels belonging to this noise shape in the output grid with the background color.\n13. Return the modified output grid.\n\"\"\"\n\n# Helper function to find the most frequent color\ndef get_most_frequent_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default for empty grid\n    # Consider edge cases where background isn't most frequent. A border check could be added.\n    # For now, assume most frequent is background. Often 0 in ARC.\n    # If multiple colors have max frequency, usually the one with lower value (like 0) is background.\n    most_common = counts.most_common()\n    if len(most_common) > 1 and most_common[0][1] == most_common[1][1]:\n         # Tie-breaking: prefer lower color index if counts are equal, often background.\n         if most_common[0][0] > most_common[1][0]:\n             return most_common[1][0]\n    return most_common[0][0]\n\n# Helper function to find connected components using BFS\ndef find_objects_bfs_masked(grid, ignore_color):\n    \"\"\"\n    Finds connected components (objects) using BFS, ignoring a specified color.\n    Returns a labeled grid and a list of object properties.\n    Uses orthogonal connectivity.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 1\n    labeled_grid = np.zeros_like(grid, dtype=int)\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited, non-ignored pixel\n            if not visited[r, c] and grid[r, c] != ignore_color:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_colors = Counter()\n                current_object_id = object_id_counter\n\n                while q:\n                    row, col = q.popleft()\n                    pixel_color = grid[row, col]\n\n                    # Ensure we are processing a valid pixel for the object\n                    if pixel_color != ignore_color:\n                        obj_coords.append((row, col))\n                        labeled_grid[row, col] = current_object_id\n                        component_colors[pixel_color] += 1\n\n                        # Explore neighbors (orthogonal)\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] != ignore_color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    # Mark visited even if it's the ignored color *now* to avoid reprocessing\n                    visited[row,col] = True\n\n\n                if obj_coords: # Only add if we found coordinates for this object\n                    coords_array = np.array(obj_coords)\n                    min_r, min_c = coords_array.min(axis=0)\n                    max_r, max_c = coords_array.max(axis=0)\n                    objects.append({\n                        'id': current_object_id,\n                        'coords': coords_array,\n                        'colors': dict(component_colors),\n                        'size': len(obj_coords),\n                        'bounding_box': ((min_r, min_c), (max_r, max_c)),\n                        'dominant_color': max(component_colors, key=component_colors.get) if component_colors else -1\n                    })\n                    object_id_counter += 1\n            # Mark visited even if it's ignored color and not processed as start of an object\n            visited[r,c] = True\n\n    return labeled_grid, objects\n\n# Helper function to get orthogonal neighbors\ndef get_neighbors(r, c, rows, cols):\n    \"\"\"Gets orthogonal neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on identified marker pixels within main regions\n    and color adjacency relationships found in separate reference/noise shapes.\n    Paints rows/columns in main regions corresponding to marker locations and removes\n    the reference shape.\n    \"\"\"\n    input_grid = np.array(input_grid_list)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Background Color\n    background_color = get_most_frequent_color(input_grid)\n\n    # 2. Find all non-background objects\n    labeled_grid, objects = find_objects_bfs_masked(input_grid, ignore_color=background_color)\n\n    if not objects:\n        return output_grid.tolist() # No objects to process\n\n    # 3. Categorize Objects (Main Regions vs Noise Shapes)\n    main_regions = []\n    noise_shapes = []\n    if len(objects) == 1:\n         main_regions = objects # If only one object, assume it's main\n    elif len(objects) > 1:\n        # Heuristic: largest is main, others are potential noise/reference\n        # Could be refined based on relative sizes or color complexity\n        objects.sort(key=lambda x: x['size'], reverse=True)\n        max_size = objects[0]['size']\n        main_regions.append(objects[0]) # Largest is definitely a main region\n        # Consider other large objects as main too (e.g., > max_size / 3 ?)\n        for obj in objects[1:]:\n             # Noise shapes are typically small (e.g. size < 10) and sometimes multi-colored\n             if obj['size'] < 10 or obj['size'] < max_size * 0.2: # Thresholding might need adjustment\n                 noise_shapes.append(obj)\n             else:\n                 main_regions.append(obj) # Treat other relatively large ones as main too\n    else: # No objects\n        return output_grid.tolist()\n\n\n    # 4. Find Potential Markers in Main Regions\n    potential_markers = {} # {marker_color: {'locations': [(r,c), ...], 'main_color': color, 'region_id': id}}\n    for region in main_regions:\n        main_color = region['dominant_color']\n        region_id = region['id']\n        for r_coord, c_coord in region['coords']:\n            pixel_color = input_grid[r_coord, c_coord]\n            if pixel_color != main_color:\n                is_isolated_marker = True\n                neighbor_coords = get_neighbors(r_coord, c_coord, rows, cols)\n                if len(neighbor_coords) < 4: # On edge of grid, cannot be fully surrounded\n                    is_isolated_marker = False\n                else:\n                    for nr, nc in neighbor_coords:\n                        neighbor_label = labeled_grid[nr, nc]\n                        neighbor_color = input_grid[nr, nc]\n                        # Check if neighbor is outside this object OR not the main color/marker color\n                        if neighbor_label != region_id or \\\n                           (neighbor_color != main_color and neighbor_color != pixel_color):\n                            is_isolated_marker = False\n                            break\n                if is_isolated_marker:\n                     if pixel_color not in potential_markers:\n                         potential_markers[pixel_color] = {'locations': [], 'main_color': main_color, 'region_id': region_id}\n                     # Check if marker is from the same region if multiple main regions exist\n                     # For simplicity now, assume marker color is unique or applies globally if found\n                     # If marker already exists, ensure it maps to same main color? Might be complex.\n                     # Let's just store all locations for now.\n                     potential_markers[pixel_color]['locations'].append((r_coord, c_coord))\n                     potential_markers[pixel_color]['main_color'] = main_color # Update in case dominant color differs slightly across regions with same marker\n                     # If multiple main regions contain the same marker color, this assumes the *last one processed* sets the main_color. This might need refinement.\n\n\n    # 5. Find Reference Pattern in Noise Shapes to confirm Marker/Target\n    found_reference = False\n    final_marker_color = -1\n    final_target_color = -1\n    final_main_color = -1\n    noise_object_id_to_remove = -1\n    final_marker_locations = []\n\n    for noise in noise_shapes:\n        noise_id = noise['id']\n        for r_coord, c_coord in noise['coords']:\n            current_pixel_color = input_grid[r_coord, c_coord]\n            # Check if this color is a potential marker\n            if current_pixel_color in potential_markers:\n                # Check neighbors within the same noise object\n                for nr, nc in get_neighbors(r_coord, c_coord, rows, cols):\n                    if labeled_grid[nr, nc] == noise_id: # Neighbor is part of the same noise object\n                        neighbor_color = input_grid[nr, nc]\n                        if neighbor_color != current_pixel_color and neighbor_color != background_color:\n                            # Found potential marker adjacent to a target color in noise shape\n                            final_marker_color = current_pixel_color\n                            final_target_color = neighbor_color\n                            noise_object_id_to_remove = noise_id\n                            # Get main color and locations associated with this marker\n                            final_main_color = potential_markers[final_marker_color]['main_color']\n                            final_marker_locations = potential_markers[final_marker_color]['locations']\n                            found_reference = True\n                            break # Found target for this marker\n            if found_reference: break\n        if found_reference: break # Found reference in this noise shape\n\n    # 6. Check if a valid reference was found\n    if not found_reference:\n        # Handle cases where the logic fails (e.g., no noise shape, no marker in noise, etc.)\n        # Return original grid or attempt alternative logic if specified.\n        # print(\"Warning: Could not find marker/target reference in noise shapes.\")\n        return output_grid.tolist() # Return unchanged grid if logic doesn't fit\n\n    # 7. Collect Marker Rows/Cols\n    marker_rows = set(r for r, c in final_marker_locations)\n    marker_cols = set(c for r, c in final_marker_locations)\n\n    # 8. Apply Painting Transformation\n    for r in range(rows):\n        for c in range(cols):\n            # Check if pixel is main color AND in a marker row or column\n            if input_grid[r, c] == final_main_color and (r in marker_rows or c in marker_cols):\n                 # Ensure we are not overwriting a marker pixel itself if main_color == target_color (unlikely but possible)\n                 # The check input_grid[r,c] == final_main_color should prevent this if marker_color is different\n                 is_marker_location = False\n                 for mr, mc in final_marker_locations:\n                     if r == mr and c == mc:\n                         is_marker_location = True\n                         break\n                 if not is_marker_location: # Only paint if it's the main color, not a marker pixel itself\n                    output_grid[r, c] = final_target_color\n                 # Consider if marker pixels should also be painted? Rule says paint 'main_color' pixels.\n\n    # 9. Remove Reference Noise Shape\n    coords_to_remove = []\n    for obj in noise_shapes:\n        if obj['id'] == noise_object_id_to_remove:\n            coords_to_remove = obj['coords']\n            break\n    for r, c in coords_to_remove:\n        if 0 <= r < rows and 0 <= c < cols: # Bounds check\n             output_grid[r, c] = background_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9628,
    "candidates_token_count": 3362,
    "total_token_count": 12990,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.419327,
  "retries": null
}