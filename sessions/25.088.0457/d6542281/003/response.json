{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label, find_objects as ndi_find_objects\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1. Identify the background color (most frequent color).\n2. Find all connected objects composed of non-background colors.\n3. Distinguish between:\n    a. 'Templates': Objects with more than one pixel.\n    b. 'Potential Triggers': Objects with exactly one pixel.\n4. Identify 'Actual Triggers' by filtering 'Potential Triggers': An Actual Trigger is a single-pixel object that is not adjacent (including diagonals) to any other non-background pixel.\n5. For each Actual Trigger:\n    a. Find all Templates that contain the Trigger's color.\n    b. Select the largest Template among them (by pixel count). If there's a tie, the one found first by the object detection algorithm is used (implicitly).\n    c. Determine the 'anchor point' within the selected Template: This is the top-most, then left-most pixel that has the same color as the Trigger.\n    d. Copy the selected Template onto the output grid. The Template is positioned such that its anchor point aligns perfectly with the location of the Actual Trigger pixel in the input grid.\n6. The original input grid content (including templates and triggers) is preserved in the output unless overwritten by a copied template. Copied templates can overlap.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assuming it's the background.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background for empty grid\n    # Return the most frequent color. Ties are broken arbitrarily by Counter,\n    # but in ARC backgrounds are usually dominant.\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_all_objects(grid_np, background_color):\n    \"\"\"Finds all connected components (objects) of non-background colors.\"\"\"\n    binary_grid = grid_np != background_color\n    # Use 8-connectivity (including diagonals)\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool)\n    labeled_grid, num_labels = label(binary_grid, structure=structure)\n\n    objects = []\n    object_slices = ndi_find_objects(labeled_grid) # Provides bounding boxes (slices)\n\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        pixels = []\n        colors = set()\n        pixel_coords = set()\n        min_r, max_r = rows, -1\n        min_c, max_c = cols, -1\n        \n        # Correctly handle slice indices if grid dimensions are small\n        rows, cols = grid_np.shape \n        obj_slice = object_slices[i-1]\n        min_r_slice, max_r_slice = obj_slice[0].start, obj_slice[0].stop\n        min_c_slice, max_c_slice = obj_slice[1].start, obj_slice[1].stop\n\n        # Iterate within the slice for efficiency, but use original coordinates\n        for r_rel, c_rel in np.argwhere(labeled_grid[obj_slice] == i):\n             r = min_r_slice + r_rel\n             c = min_c_slice + c_rel\n             color = grid_np[r, c]\n             pixels.append({'r': r, 'c': c, 'color': color})\n             colors.add(color)\n             pixel_coords.add((r, c))\n             min_r = min(min_r, r)\n             max_r = max(max_r, r)\n             min_c = min(min_c, c)\n             max_c = max(max_c, c)\n\n        if pixels:\n            objects.append({\n                'id': i,\n                'pixels': pixels,\n                'coords': pixel_coords, # Set of (r, c) tuples\n                'size': len(pixels),\n                'colors': colors,\n                'bbox': (min_r, min_c, max_r, max_c) # Bounding box\n            })\n\n    return objects\n\ndef is_isolated(r, c, grid_np, background_color):\n    \"\"\"Checks if a pixel at (r, c) is isolated (no non-background neighbors).\"\"\"\n    rows, cols = grid_np.shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center pixel itself\n            if dr == 0 and dc == 0:\n                continue\n            \n            nr, nc = r + dr, c + dc\n            \n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is non-background\n                if grid_np[nr, nc] != background_color:\n                    return False # Found a non-background neighbor\n                    \n    # If loop completes without finding non-background neighbors\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation: finds isolated triggers and templates,\n    and copies templates based on trigger locations and colors.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # 1. Identify the background color\n    background_color = get_background_color(input_np)\n\n    # 2. Find all distinct objects\n    all_objects = find_all_objects(input_np, background_color)\n\n    # 3. Separate objects into templates and potential triggers\n    templates = [obj for obj in all_objects if obj['size'] > 1]\n    potential_triggers = [obj for obj in all_objects if obj['size'] == 1]\n\n    # 4. Identify Actual Triggers (isolated single pixels)\n    actual_triggers = []\n    for pt in potential_triggers:\n        # Get the single pixel's info\n        pixel_info = pt['pixels'][0]\n        r, c = pixel_info['r'], pixel_info['c']\n        # Check if it's isolated\n        if is_isolated(r, c, input_np, background_color):\n            actual_triggers.append(pt) # Add the whole object info\n\n    # 5. Process each Actual Trigger\n    for trigger in actual_triggers:\n        # a. Get trigger info\n        trigger_pixel = trigger['pixels'][0] # Only one pixel in a trigger\n        trigger_color = trigger_pixel['color']\n        target_location = (trigger_pixel['r'], trigger_pixel['c'])\n\n        # b. Identify candidate templates (must contain trigger color)\n        candidate_templates = [\n            tmpl for tmpl in templates if trigger_color in tmpl['colors']\n        ]\n\n        if not candidate_templates:\n            continue # No template found for this trigger color\n\n        # c. Select the best template (largest size)\n        # Tie-breaking: implicitly picks the first one found by find_all_objects\n        best_template = max(candidate_templates, key=lambda tmpl: tmpl['size'])\n\n        # d. Find the source anchor location in the best template\n        # Anchor is the top-most, then left-most pixel of the trigger_color\n        source_anchor = None\n        min_anchor_r = rows # Initialize high\n        min_anchor_c = cols # Initialize high\n        \n        source_candidates = []\n        for p in best_template['pixels']:\n            if p['color'] == trigger_color:\n               source_candidates.append((p['r'], p['c']))\n        \n        if not source_candidates:\n             # Should not happen if candidate_templates logic is correct\n             continue\n\n        # Find top-most row among candidates\n        min_anchor_r = min(r for r, c in source_candidates)\n        # Find left-most column among the top-most candidates\n        min_anchor_c = min(c for r, c in source_candidates if r == min_anchor_r)\n        source_anchor = (min_anchor_r, min_anchor_c)\n            \n        # e. Calculate the displacement vector\n        offset_row = target_location[0] - source_anchor[0]\n        offset_col = target_location[1] - source_anchor[1]\n\n        # f. & g. Copy template pixels to output grid with offset\n        for p in best_template['pixels']:\n            p_loc = (p['r'], p['c'])\n            p_color = p['color']\n            \n            new_row = p_loc[0] + offset_row\n            new_col = p_loc[1] + offset_col\n\n            # Check if the new location is within the grid bounds before writing\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                output_np[new_row, new_col] = p_color\n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7398,
    "candidates_token_count": 2173,
    "total_token_count": 9571,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.251771,
  "retries": null
}