{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label, find_objects as ndi_find_objects\n\n\"\"\"\nTransforms the input grid by identifying single-pixel 'trigger' objects and multi-pixel 'template' objects. \nFor each trigger pixel, it finds the largest template object containing the trigger's color. \nIt then copies this template object onto the output grid, aligning the top-most, left-most pixel \nof the trigger's color within the template with the location of the trigger pixel itself. \nThe original objects and triggers remain, and copied objects can overlap.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background if grid is empty? Or raise error? Assuming 0 for now.\n    # Common case: return most common color\n    # Edge case: if multiple colors have the same max frequency, need a tie-breaker.\n    # ARC often uses black (0) or the numerically lowest color value as tie-breaker,\n    # but here the background is usually clearly dominant. Let's assume simple max frequency works.\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_all_objects(grid_np, background_color):\n    \"\"\"Finds all connected components (objects) of non-background colors.\"\"\"\n    binary_grid = grid_np != background_color\n    # Structure defines connectivity (8-connectivity including diagonals)\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool) \n    labeled_grid, num_labels = label(binary_grid, structure=structure)\n    \n    objects = []\n    # ndi_find_objects gives slices, but we need detailed pixel info\n    for i in range(1, num_labels + 1):\n        coords = np.argwhere(labeled_grid == i)\n        pixels = []\n        colors = set()\n        pixel_coords = set()\n        for r, c in coords:\n            color = grid_np[r, c]\n            pixels.append({'r': r, 'c': c, 'color': color})\n            colors.add(color)\n            pixel_coords.add((r, c))\n            \n        if pixels: # Should always be true if num_labels > 0\n            objects.append({\n                'id': i,\n                'pixels': pixels,\n                'coords': pixel_coords, # Set of (r, c) tuples for quick lookup\n                'size': len(pixels),\n                'colors': colors,\n                # Optional: add bounding box if needed later\n            })\n            \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation: finds triggers and templates,\n    and copies templates based on trigger locations and colors.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # 1. Identify the background color\n    background_color = get_background_color(input_np)\n\n    # 2. Find all distinct objects\n    all_objects = find_all_objects(input_np, background_color)\n\n    # 3. Separate objects into templates and triggers\n    templates = [obj for obj in all_objects if obj['size'] > 1]\n    triggers = [obj for obj in all_objects if obj['size'] == 1]\n\n    # 4. Process each trigger\n    for trigger in triggers:\n        # a. Get trigger info\n        trigger_pixel = trigger['pixels'][0] # Only one pixel in a trigger\n        trigger_color = trigger_pixel['color']\n        target_location = (trigger_pixel['r'], trigger_pixel['c'])\n\n        # b. Identify candidate templates\n        candidate_templates = [\n            tmpl for tmpl in templates if trigger_color in tmpl['colors']\n        ]\n\n        if not candidate_templates:\n            continue # No template found for this trigger color\n\n        # c. Select the best template (largest size)\n        # If sizes are equal, the first one found (based on object labelling order) will be picked.\n        best_template = max(candidate_templates, key=lambda tmpl: tmpl['size'])\n\n        # d. Find the source anchor location in the best template\n        source_anchor = None\n        min_r = rows # Initialize with value > max possible row\n        min_c = cols # Initialize with value > max possible col\n        \n        source_candidates = []\n        for p in best_template['pixels']:\n            if p['color'] == trigger_color:\n               source_candidates.append((p['r'], p['c']))\n        \n        if not source_candidates:\n             # This shouldn't happen if candidate_templates logic is correct, but defensively skip\n             continue\n\n        # Find top-most\n        min_r = min(r for r, c in source_candidates)\n        # Find left-most among the top-most\n        min_c = min(c for r, c in source_candidates if r == min_r)\n        source_anchor = (min_r, min_c)\n            \n        # e. Calculate the displacement vector\n        offset_row = target_location[0] - source_anchor[0]\n        offset_col = target_location[1] - source_anchor[1]\n\n        # f. & g. Copy template pixels to output grid with offset\n        for p in best_template['pixels']:\n            p_loc = (p['r'], p['c'])\n            p_color = p['color']\n            \n            new_row = p_loc[0] + offset_row\n            new_col = p_loc[1] + offset_col\n\n            # Check if the new location is within the grid bounds\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                output_np[new_row, new_col] = p_color\n\n    # Convert the final numpy array back to a list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5618,
    "candidates_token_count": 1456,
    "total_token_count": 7074,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.187884,
  "retries": null
}