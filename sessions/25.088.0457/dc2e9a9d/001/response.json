{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nThe transformation identifies connected components of green (3) pixels in the input grid. \nFor each green object, it determines if it's vertically or horizontally symmetric, or neither.\nBased on symmetry or aspect ratio, it creates a reflected version of the object:\n- If vertically symmetric: Reflect horizontally, color blue (1), place to the right.\n- If horizontally symmetric (but not vertically): Reflect vertically, color azure (8), place below.\n- If not symmetric and height > width: Reflect vertically, color azure (8), place below.\n- If not symmetric and width >= height: Reflect horizontally, color blue (1), place to the right.\nThe output grid contains the original green objects and the newly created reflected objects, potentially expanding the grid dimensions.\n\"\"\"\n\ndef is_vertically_symmetric(mask):\n    \"\"\"Checks if a 2D boolean mask is vertically symmetric.\"\"\"\n    if mask.shape[1] % 2 == 1: # Odd width\n        mid = mask.shape[1] // 2\n        left = mask[:, :mid]\n        right = mask[:, mid+1:]\n        return np.array_equal(left, np.fliplr(right))\n    else: # Even width\n        mid = mask.shape[1] // 2\n        left = mask[:, :mid]\n        right = mask[:, mid:]\n        return np.array_equal(left, np.fliplr(right))\n\ndef is_horizontally_symmetric(mask):\n    \"\"\"Checks if a 2D boolean mask is horizontally symmetric.\"\"\"\n    if mask.shape[0] % 2 == 1: # Odd height\n        mid = mask.shape[0] // 2\n        top = mask[:mid, :]\n        bottom = mask[mid+1:, :]\n        return np.array_equal(top, np.flipud(bottom))\n    else: # Even height\n        mid = mask.shape[0] // 2\n        top = mask[:mid, :]\n        bottom = mask[mid:, :]\n        return np.array_equal(top, np.flipud(bottom))\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the reflection transformation based on symmetry and aspect ratio.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = np.copy(input_grid_np)\n    \n    # Define the color of interest (green)\n    target_color = 3\n    background_color = 0\n\n    # Find connected components of the target color\n    labeled_array, num_features = label(input_grid_np == target_color)\n    \n    # Find the locations (slices) of these components\n    object_slices = find_objects(labeled_array)\n\n    # Store reflections to add later to avoid modifying grid during iteration\n    reflections_to_add = [] # List of (shape, color, r, c) tuples\n\n    max_r_needed = output_grid_np.shape[0]\n    max_c_needed = output_grid_np.shape[1]\n\n    # Iterate through each found object\n    for i in range(num_features):\n        obj_slice = object_slices[i]\n        min_r, max_r = obj_slice[0].start, obj_slice[0].stop\n        min_c, max_c = obj_slice[1].start, obj_slice[1].stop\n        \n        # Extract the object's shape within its bounding box\n        # Check only pixels matching the original object label in this slice\n        object_mask = (labeled_array[obj_slice] == (i + 1))\n        \n        h = object_mask.shape[0]\n        w = object_mask.shape[1]\n\n        # Determine symmetry\n        vert_sym = is_vertically_symmetric(object_mask)\n        horiz_sym = is_horizontally_symmetric(object_mask)\n\n        reflected_mask = None\n        new_color = 0\n        place_r, place_c = 0, 0\n\n        # Apply rules based on symmetry and aspect ratio\n        if vert_sym:\n            # Rule 1: Vertically symmetric -> Reflect horizontally, color blue, place right\n            reflected_mask = np.fliplr(object_mask)\n            new_color = 1  # blue\n            place_r = min_r\n            place_c = max_c # Place immediately to the right of the bounding box\n            \n        elif horiz_sym:\n            # Rule 2: Horizontally symmetric (and not vertically) -> Reflect vertically, color azure, place below\n            reflected_mask = np.flipud(object_mask)\n            new_color = 8  # azure\n            place_r = max_r # Place immediately below the bounding box\n            place_c = min_c\n            \n        else: # Not symmetric\n            if h > w:\n                 # Rule 3: Not symmetric, height > width -> Reflect vertically, color azure, place below\n                reflected_mask = np.flipud(object_mask)\n                new_color = 8  # azure\n                place_r = max_r\n                place_c = min_c\n            else: # width >= height\n                # Rule 4: Not symmetric, width >= height -> Reflect horizontally, color blue, place right\n                reflected_mask = np.fliplr(object_mask)\n                new_color = 1  # blue\n                place_r = min_r\n                place_c = max_c\n\n        # Store the reflection details\n        if reflected_mask is not None:\n            colored_shape = reflected_mask * new_color\n            reflections_to_add.append((colored_shape, place_r, place_c))\n            \n            # Track maximum grid size needed\n            max_r_needed = max(max_r_needed, place_r + reflected_mask.shape[0])\n            max_c_needed = max(max_c_needed, place_c + reflected_mask.shape[1])\n\n\n    # --- Grid resizing and placement phase ---\n    \n    # Resize output grid if necessary before placing reflections\n    current_h, current_w = output_grid_np.shape\n    pad_h = max(0, max_r_needed - current_h)\n    pad_w = max(0, max_c_needed - current_w)\n\n    if pad_h > 0 or pad_w > 0:\n        output_grid_np = np.pad(output_grid_np, \n                                ((0, pad_h), (0, pad_w)), \n                                mode='constant', \n                                constant_values=background_color)\n\n    # Place all reflections onto the (potentially expanded) grid\n    for shape, r, c in reflections_to_add:\n        h_shape, w_shape = shape.shape\n        # Define the target slice in the output grid\n        target_slice = output_grid_np[r : r + h_shape, c : c + w_shape]\n        # Place the shape, only overwriting where the shape is not background color (0)\n        output_grid_np[r : r + h_shape, c : c + w_shape] = np.where(shape != background_color, shape, target_slice)\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8045,
    "candidates_token_count": 1711,
    "total_token_count": 9756,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.355977,
  "retries": null
}