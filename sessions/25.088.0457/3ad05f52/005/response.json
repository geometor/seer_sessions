{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  **Initialization:** Create a copy of the input grid, which will become the output grid.\n2.  **Identify Colors:** Determine the boundary color (Azure, 8), the background color (White, 0), and the fill color (the unique color present that is neither White nor Azure).\n3.  **Identify External White Pixels:**\n    a. Perform a Breadth-First Search (BFS) starting from all White (0) pixels located on the absolute border (edges) of the grid.\n    b. Mark all reachable White (0) pixels during this BFS as 'external'. These are the white pixels connected to the outside of any Azure (8) boundaries.\n4.  **Identify Fill Seeds:** Find all pixels in the input grid that initially have the fill color.\n5.  **Perform Internal Flood Fill:**\n    a. Perform a second BFS starting from the identified 'fill seed' pixels.\n    b. During this BFS, explore adjacent pixels.\n    c. If an adjacent pixel is White (0) in the input grid, has *not* been visited by *this* fill BFS, AND was *not* marked as 'external' in step 3:\n        i. Change its color to the fill color in the output grid.\n        ii. Mark it as visited for the fill BFS.\n        iii. Add it to the fill BFS queue.\n    d. This fill process stops at Azure (8) boundaries (as they are not White 0) and at the boundary between internal and external white pixels.\n6.  **Return:** Return the modified output grid.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Fills white regions connected to 'fill_color' pixels, constrained by 'boundary_color' \n    and not connected to the grid's outer border.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # --- 1. Identify boundary, background, and fill colors ---\n    boundary_color = 8 # Azure\n    background_color = 0 # White\n    \n    unique_colors = np.unique(grid)\n    fill_color = -1\n    for color in unique_colors:\n        if color != background_color and color != boundary_color:\n            fill_color = color\n            break\n            \n    # If no specific fill color is found (only background/boundary or uniform grid), return original\n    if fill_color == -1:\n        return output_grid.tolist()\n\n    # --- 2. Identify External White Pixels ---\n    visited_external = np.zeros_like(grid, dtype=bool)\n    q_external = deque()\n\n    # Add border white pixels to the external queue\n    for r in range(rows):\n        for c in range(cols):\n            if (r == 0 or r == rows - 1 or c == 0 or c == cols - 1) and grid[r, c] == background_color:\n                if not visited_external[r, c]:\n                    visited_external[r, c] = True\n                    q_external.append((r, c))\n\n    # BFS to find all externally connected white pixels\n    while q_external:\n        r, c = q_external.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and not visited_external[nr, nc]:\n                visited_external[nr, nc] = True\n                q_external.append((nr, nc))\n\n    # --- 3. Identify Fill Seeds and Initialize Fill BFS ---\n    visited_fill = np.zeros_like(grid, dtype=bool)\n    q_fill = deque()\n\n    # Find all initial fill color pixels (\"seeds\") and add them to the fill queue\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == fill_color:\n                # Seed points are implicitly \"visited\" for the fill process\n                # but only add them to queue if not already processed (shouldn't happen here, but safe)\n                if not visited_fill[r, c]:\n                     visited_fill[r,c] = True # Mark seeds as visited for fill\n                     q_fill.append((r,c)) \n                     # Ensure seed color is in output (already is from copy)\n                     # output_grid[r, c] = fill_color \n\n    # --- 4. Perform Internal Flood Fill ---\n    while q_fill:\n        r, c = q_fill.popleft()\n\n        # Check neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is:\n                # 1. Background color (White) in the *original* grid\n                # 2. Not yet visited by *this* fill BFS\n                # 3. Not part of the 'external' white region\n                if grid[nr, nc] == background_color and \\\n                   not visited_fill[nr, nc] and \\\n                   not visited_external[nr, nc]:\n                    \n                    visited_fill[nr, nc] = True       # Mark as visited for fill\n                    output_grid[nr, nc] = fill_color  # Change color in output\n                    q_fill.append((nr, nc))           # Add to queue to explore its neighbors\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20217,
    "candidates_token_count": 1427,
    "total_token_count": 21644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.472497,
  "retries": null
}