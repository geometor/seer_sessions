{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1.  **Identify the Divider**: Locate the single, complete row or column composed entirely of azure (8) pixels. Determine its orientation (horizontal or vertical) and index (row or column number).\n2.  **Define Regions**: Based on the divider, identify the two distinct regions of the grid (e.g., Region 1: above/left, Region 2: below/right).\n3.  **Initialize Output Grid**: Create an output grid initially identical to the input grid.\n4.  **Process Each Region Independently**: Apply the following steps sequentially within each region, using the *input* grid to determine conditions and locations, and modifying the *output* grid:\n    a.  **Color Change**: Check the *input* pixels within the current region. If any yellow (4) pixels are present anywhere in this input region, change *all* corresponding yellow (4) pixels in the *output* grid for this region to green (3). Red (2) pixels from the input remain red (2) in the output (this is handled by the initial copy unless overwritten by subsequent fills).\n    b.  **Fill Towards Divider**: For each line perpendicular to the divider (i.e., each column for a horizontal divider, each row for a vertical divider) that intersects the current region:\n        i.  **Yellow Fill**: Check if the *input* grid region originally contained *any* yellow (4) pixels. If yes:\n            - Find the yellow (4) pixel in the *input* grid on the current line that is closest to the divider.\n            - If such a pixel exists, identify all the cells on this line strictly *between* that closest yellow pixel's original position and the divider.\n            - For each identified cell, if its corresponding cell in the *input* grid was white (0), change its color in the *output* grid to yellow (4).\n        ii. **Azure Fill**: Check if the *input* grid region originally contained *any* red (2) pixels. If yes:\n            - Find the red (2) pixel in the *input* grid on the current line that is closest to the divider.\n            - If such a pixel exists, identify all the cells on this line strictly *between* that closest red pixel's original position and the divider.\n            - For each identified cell, if its corresponding cell in the *input* grid was white (0), change its color in the *output* grid to azure (8). (Note: This check against the original input grid prevents azure fill from overwriting a yellow fill that targeted the same original white cell).\n5.  **Final Output**: The modified output grid after processing both regions is the result.\n\"\"\"\n\nimport numpy as np\n\ndef find_divider(grid):\n    \"\"\"\n    Finds the divider line (full row or column of azure) in the grid.\n\n    Args:\n        grid: numpy array representing the input grid.\n\n    Returns:\n        A tuple (orientation, index) where orientation is 'horizontal' or 'vertical',\n        and index is the row or column index of the divider.\n        Returns (None, None) if no divider is found.\n    \"\"\"\n    height, width = grid.shape\n\n    # Check for horizontal divider\n    for r in range(height):\n        if np.all(grid[r, :] == 8):\n            return 'horizontal', r\n\n    # Check for vertical divider\n    for c in range(width):\n        if np.all(grid[:, c] == 8):\n            return 'vertical', c\n\n    return None, None\n\ndef process_region(input_np, output_grid, orientation, divider_index, region_rows, region_cols):\n    \"\"\"\n    Processes a single region defined by row/column slices.\n    Applies color changes and filling based on input colors in the region.\n    Modifies the output_grid directly.\n\n    Args:\n        input_np: The original input numpy array.\n        output_grid: The numpy array representing the output grid (modified in-place).\n        orientation: 'horizontal' or 'vertical' orientation of the divider.\n        divider_index: Row or column index of the divider.\n        region_rows: Slice object for the rows of this region.\n        region_cols: Slice object for the columns of this region.\n    \"\"\"\n    height, width = input_np.shape\n    # Extract the view of the input grid for this region\n    region_slice_input = input_np[region_rows, region_cols]\n\n    # Check for presence of key colors in the input region\n    has_yellow_in_region = np.any(region_slice_input == 4)\n    has_red_in_region = np.any(region_slice_input == 2)\n\n    # 4a. Color Change (Yellow -> Green)\n    if has_yellow_in_region:\n        # Iterate through the defined region coordinates\n        for r in range(region_rows.start, region_rows.stop):\n             for c in range(region_cols.start, region_cols.stop):\n                 if input_np[r, c] == 4:\n                     output_grid[r, c] = 3 # Change yellow to green in output\n\n    # 4b. Fill Towards Divider\n    if orientation == 'horizontal':\n        # Iterate through each column within the region's column bounds\n        for c in range(region_cols.start, region_cols.stop):\n            # Get the slice of the *input* column within the region's row bounds\n            col_slice_input = input_np[region_rows, c]\n\n            # i. Yellow Fill (if applicable for this region)\n            if has_yellow_in_region:\n                yellow_indices_relative = np.where(col_slice_input == 4)[0]\n                if len(yellow_indices_relative) > 0:\n                    # Adjust indices to be absolute row indices in the full grid\n                    absolute_yellow_indices = yellow_indices_relative + region_rows.start\n                    \n                    # Determine the row index of the yellow pixel closest to the divider\n                    if region_rows.start < divider_index: # Region is above divider\n                        closest_yellow_row = np.max(absolute_yellow_indices)\n                        # Define the range of rows to potentially fill (exclusive of pixel, inclusive of divider edge)\n                        fill_start_row = closest_yellow_row + 1\n                        fill_end_row = divider_index # Fill up to (not including) the divider row\n                    else: # Region is below divider\n                        closest_yellow_row = np.min(absolute_yellow_indices)\n                        # Define the range of rows to potentially fill\n                        fill_start_row = divider_index + 1 # Fill starts below divider\n                        fill_end_row = closest_yellow_row # Fill up to (not including) the yellow pixel row\n                    \n                    # Fill the white cells in the output grid\n                    for fill_r in range(fill_start_row, fill_end_row):\n                        if input_np[fill_r, c] == 0: # Check original input cell\n                            output_grid[fill_r, c] = 4\n\n            # ii. Azure Fill (if applicable for this region)\n            if has_red_in_region:\n                red_indices_relative = np.where(col_slice_input == 2)[0]\n                if len(red_indices_relative) > 0:\n                    # Adjust indices to be absolute row indices\n                    absolute_red_indices = red_indices_relative + region_rows.start\n\n                    # Determine the row index of the red pixel closest to the divider\n                    if region_rows.start < divider_index: # Region is above divider\n                        closest_red_row = np.max(absolute_red_indices)\n                        fill_start_row = closest_red_row + 1\n                        fill_end_row = divider_index\n                    else: # Region is below divider\n                        closest_red_row = np.min(absolute_red_indices)\n                        fill_start_row = divider_index + 1\n                        fill_end_row = closest_red_row\n\n                    # Fill the white cells in the output grid\n                    for fill_r in range(fill_start_row, fill_end_row):\n                         if input_np[fill_r, c] == 0: # Check original input cell\n                            output_grid[fill_r, c] = 8\n\n\n    elif orientation == 'vertical':\n         # Iterate through each row within the region's row bounds\n        for r in range(region_rows.start, region_rows.stop):\n            # Get the slice of the *input* row within the region's column bounds\n            row_slice_input = input_np[r, region_cols]\n\n            # i. Yellow Fill (if applicable for this region)\n            if has_yellow_in_region:\n                yellow_indices_relative = np.where(row_slice_input == 4)[0]\n                if len(yellow_indices_relative) > 0:\n                    # Adjust indices to be absolute column indices\n                    absolute_yellow_indices = yellow_indices_relative + region_cols.start\n\n                    # Determine the column index of the yellow pixel closest to the divider\n                    if region_cols.start < divider_index: # Region is left of divider\n                        closest_yellow_col = np.max(absolute_yellow_indices)\n                        fill_start_col = closest_yellow_col + 1\n                        fill_end_col = divider_index\n                    else: # Region is right of divider\n                        closest_yellow_col = np.min(absolute_yellow_indices)\n                        fill_start_col = divider_index + 1\n                        fill_end_col = closest_yellow_col\n                        \n                    # Fill the white cells in the output grid\n                    for fill_c in range(fill_start_col, fill_end_col):\n                        if input_np[r, fill_c] == 0: # Check original input cell\n                            output_grid[r, fill_c] = 4\n\n            # ii. Azure Fill (if applicable for this region)\n            if has_red_in_region:\n                red_indices_relative = np.where(row_slice_input == 2)[0]\n                if len(red_indices_relative) > 0:\n                     # Adjust indices to be absolute column indices\n                    absolute_red_indices = red_indices_relative + region_cols.start\n\n                    # Determine the column index of the red pixel closest to the divider\n                    if region_cols.start < divider_index: # Region is left of divider\n                        closest_red_col = np.max(absolute_red_indices)\n                        fill_start_col = closest_red_col + 1\n                        fill_end_col = divider_index\n                    else: # Region is right of divider\n                        closest_red_col = np.min(absolute_red_indices)\n                        fill_start_col = divider_index + 1\n                        fill_end_col = closest_red_col\n\n                    # Fill the white cells in the output grid\n                    for fill_c in range(fill_start_col, fill_end_col):\n                        if input_np[r, fill_c] == 0: # Check original input cell\n                            output_grid[r, fill_c] = 8\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    Identifies an azure divider, splits the grid into regions,\n    and processes each region based on the presence of yellow or red pixels.\n    Yellow pixels turn green. Empty space (white) between yellow/red pixels\n    and the divider is filled with yellow/azure respectively.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 3. Initialize Output Grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # 1. Identify the divider\n    orientation, divider_index = find_divider(input_np)\n\n    # If no divider is found, return the original grid unchanged\n    # (Based on problem description, a divider should always exist)\n    if orientation is None:\n        print(\"Warning: No divider found. Returning input grid.\") # Or raise error\n        return input_grid # Return original list of lists\n\n    # 2. Define Regions and 4. Process Regions\n    if orientation == 'horizontal':\n        # Divider is a row, regions are above and below\n        d_r = divider_index\n        # Process Region 1 (Above), if it exists (divider is not the top row)\n        if d_r > 0:\n            region1_rows = slice(0, d_r)\n            region1_cols = slice(0, width)\n            process_region(input_np, output_grid, orientation, d_r, region1_rows, region1_cols)\n\n        # Process Region 2 (Below), if it exists (divider is not the bottom row)\n        if d_r < height - 1:\n            region2_rows = slice(d_r + 1, height)\n            region2_cols = slice(0, width)\n            process_region(input_np, output_grid, orientation, d_r, region2_rows, region2_cols)\n\n    elif orientation == 'vertical':\n        # Divider is a column, regions are left and right\n        d_c = divider_index\n        # Process Region 1 (Left), if it exists (divider is not the leftmost column)\n        if d_c > 0:\n            region1_rows = slice(0, height)\n            region1_cols = slice(0, d_c)\n            process_region(input_np, output_grid, orientation, d_c, region1_rows, region1_cols)\n\n        # Process Region 2 (Right), if it exists (divider is not the rightmost column)\n        if d_c < width - 1:\n            region2_rows = slice(0, height)\n            region2_cols = slice(d_c + 1, width)\n            process_region(input_np, output_grid, orientation, d_c, region2_rows, region2_cols)\n\n    # 5. Final Output: Convert the modified numpy array back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6842,
    "candidates_token_count": 3296,
    "total_token_count": 10138,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.938904,
  "retries": null
}