{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n1. Identify the Divider: Locate the single, complete row or column composed entirely of azure (8) pixels. Note its orientation (horizontal or vertical) and index (row or column number).\n2. Initialize Output: Create an output grid as an identical copy of the input grid.\n3. Define Regions: Identify the two regions of the grid separated by the divider (e.g., Region 1: above/left, Region 2: below/right).\n4. Process Each Region Independently: Apply the following steps to each region, considering only the pixels within that region in the *input* grid to determine the rules:\n    a. Color Transformation:\n        i. If the region in the *input* grid contains any yellow (4) pixels: Change all yellow (4) pixels within this region to green (3) in the *output* grid.\n        ii. Red (2) pixels from the input grid remain red (2) in the output grid (handled by the initial copy, unless overwritten by filling).\n    b. Filling Towards Divider: For each line perpendicular to the divider (i.e., each column if the divider is horizontal, each row if vertical) within the current region:\n        i. Yellow Fill: If the region in the *input* grid originally contained any yellow (4) pixels:\n            - Find the yellow (4) pixel in the *input* grid on this line that is closest to the divider.\n            - If such a pixel exists, fill all the cells in the *output* grid on this line *between* that closest yellow pixel's original position and the divider with yellow (4).\n        ii. Azure Fill: If the region in the *input* grid originally contained any red (2) pixels:\n            - Find the red (2) pixel in the *input* grid on this line that is closest to the divider.\n            - If such a pixel exists, fill all the cells in the *output* grid on this line *between* that closest red pixel's original position and the divider with azure (8). (Note: This azure fill might overwrite pixels that were initially red or became green).\n5. Return Output: The modified grid after processing both regions is the final result.\n\"\"\"\n\ndef find_divider(grid):\n    \"\"\"\n    Finds the divider line (full row or column of azure) in the grid.\n\n    Args:\n        grid: numpy array representing the input grid.\n\n    Returns:\n        A tuple (orientation, index) where orientation is 'horizontal' or 'vertical',\n        and index is the row or column index of the divider.\n        Returns (None, None) if no divider is found.\n    \"\"\"\n    height, width = grid.shape\n\n    # Check for horizontal divider\n    for r in range(height):\n        if np.all(grid[r, :] == 8):\n            return 'horizontal', r\n\n    # Check for vertical divider\n    for c in range(width):\n        if np.all(grid[:, c] == 8):\n            return 'vertical', c\n\n    return None, None\n\ndef process_region(input_np, output_grid, orientation, divider_index, region_rows, region_cols):\n    \"\"\"\n    Processes a single region defined by row/column ranges.\n    Applies color changes and filling based on input colors in the region.\n    \"\"\"\n    height, width = input_np.shape\n    region_slice_input = input_np[region_rows, region_cols]\n\n    # Check for presence of key colors in the input region\n    has_yellow_in_region = np.any(region_slice_input == 4)\n    has_red_in_region = np.any(region_slice_input == 2)\n\n    # Apply color transformation (Yellow -> Green)\n    if has_yellow_in_region:\n        # Iterate through the defined region coordinates\n        for r in range(region_rows.start, region_rows.stop):\n             for c in range(region_cols.start, region_cols.stop):\n                 if input_np[r, c] == 4:\n                     output_grid[r, c] = 3 # Change yellow to green in output\n\n    # Apply filling logic line by line\n    if orientation == 'horizontal':\n        # Iterate through each column\n        for c in range(region_cols.start, region_cols.stop):\n            col_slice_input = input_np[region_rows, c]\n            \n            # Yellow Fill (if applicable for this region)\n            if has_yellow_in_region:\n                yellow_indices = np.where(col_slice_input == 4)[0]\n                if len(yellow_indices) > 0:\n                    # Adjust indices relative to the full grid\n                    absolute_yellow_indices = yellow_indices + region_rows.start\n                    if region_rows.start < divider_index: # Region is above divider\n                        closest_yellow_row = np.max(absolute_yellow_indices)\n                        fill_start = closest_yellow_row + 1\n                        fill_end = divider_index\n                        if fill_start < fill_end:\n                            output_grid[fill_start:fill_end, c] = 4\n                    else: # Region is below divider\n                        closest_yellow_row = np.min(absolute_yellow_indices)\n                        fill_start = divider_index + 1\n                        fill_end = closest_yellow_row\n                        if fill_start < fill_end:\n                            output_grid[fill_start:fill_end, c] = 4\n\n            # Azure Fill (if applicable for this region)\n            if has_red_in_region:\n                red_indices = np.where(col_slice_input == 2)[0]\n                if len(red_indices) > 0:\n                     # Adjust indices relative to the full grid\n                    absolute_red_indices = red_indices + region_rows.start\n                    if region_rows.start < divider_index: # Region is above divider\n                        closest_red_row = np.max(absolute_red_indices)\n                        fill_start = closest_red_row + 1\n                        fill_end = divider_index\n                        if fill_start < fill_end:\n                            output_grid[fill_start:fill_end, c] = 8\n                    else: # Region is below divider\n                        closest_red_row = np.min(absolute_red_indices)\n                        fill_start = divider_index + 1\n                        fill_end = closest_red_row\n                        if fill_start < fill_end:\n                            output_grid[fill_start:fill_end, c] = 8\n\n    elif orientation == 'vertical':\n         # Iterate through each row\n        for r in range(region_rows.start, region_rows.stop):\n            row_slice_input = input_np[r, region_cols]\n\n            # Yellow Fill (if applicable for this region)\n            if has_yellow_in_region:\n                yellow_indices = np.where(row_slice_input == 4)[0]\n                if len(yellow_indices) > 0:\n                    # Adjust indices relative to the full grid\n                    absolute_yellow_indices = yellow_indices + region_cols.start\n                    if region_cols.start < divider_index: # Region is left of divider\n                        closest_yellow_col = np.max(absolute_yellow_indices)\n                        fill_start = closest_yellow_col + 1\n                        fill_end = divider_index\n                        if fill_start < fill_end:\n                            output_grid[r, fill_start:fill_end] = 4\n                    else: # Region is right of divider\n                        closest_yellow_col = np.min(absolute_yellow_indices)\n                        fill_start = divider_index + 1\n                        fill_end = closest_yellow_col\n                        if fill_start < fill_end:\n                           output_grid[r, fill_start:fill_end] = 4\n            \n            # Azure Fill (if applicable for this region)\n            if has_red_in_region:\n                red_indices = np.where(row_slice_input == 2)[0]\n                if len(red_indices) > 0:\n                    # Adjust indices relative to the full grid\n                    absolute_red_indices = red_indices + region_cols.start\n                    if region_cols.start < divider_index: # Region is left of divider\n                        closest_red_col = np.max(absolute_red_indices)\n                        fill_start = closest_red_col + 1\n                        fill_end = divider_index\n                        if fill_start < fill_end:\n                           output_grid[r, fill_start:fill_end] = 8\n                    else: # Region is right of divider\n                        closest_red_col = np.min(absolute_red_indices)\n                        fill_start = divider_index + 1\n                        fill_end = closest_red_col\n                        if fill_start < fill_end:\n                            output_grid[r, fill_start:fill_end] = 8\n\n\ndef transform(input_grid):\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # 1. Identify the divider\n    orientation, divider_index = find_divider(input_np)\n\n    # If no divider, return the copy (should not happen based on task description)\n    if orientation is None:\n        return output_grid\n\n    # 3. Define Regions and 4. Process Regions\n    if orientation == 'horizontal':\n        d_r = divider_index\n        # Define Region 1 (Above) rows and process if it exists\n        if d_r > 0:\n            region1_rows = slice(0, d_r)\n            region1_cols = slice(0, width)\n            process_region(input_np, output_grid, orientation, d_r, region1_rows, region1_cols)\n\n        # Define Region 2 (Below) rows and process if it exists\n        if d_r < height - 1:\n            region2_rows = slice(d_r + 1, height)\n            region2_cols = slice(0, width)\n            process_region(input_np, output_grid, orientation, d_r, region2_rows, region2_cols)\n\n    elif orientation == 'vertical':\n        d_c = divider_index\n        # Define Region 1 (Left) cols and process if it exists\n        if d_c > 0:\n            region1_rows = slice(0, height)\n            region1_cols = slice(0, d_c)\n            process_region(input_np, output_grid, orientation, d_c, region1_rows, region1_cols)\n\n        # Define Region 2 (Right) cols and process if it exists\n        if d_c < width - 1:\n            region2_rows = slice(0, height)\n            region2_cols = slice(d_c + 1, width)\n            process_region(input_np, output_grid, orientation, d_c, region2_rows, region2_cols)\n\n    # 5. Return the final output grid\n    return output_grid.tolist() # Convert back to list of lists if required by framework\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8199,
    "candidates_token_count": 2625,
    "total_token_count": 10824,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.045312,
  "retries": null
}