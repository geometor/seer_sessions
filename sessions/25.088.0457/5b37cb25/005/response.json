{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_inner_elements(grid):\n    \"\"\"\n    Analyzes the inner area (excluding the 1-pixel border) of the grid \n    to find the background color (most frequent) and the obstacle colors \n    (all other colors present in the inner area).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, obstacle_colors_set)\n               Returns (None, set()) if the inner area is empty, cannot be analyzed,\n               or contains no identifiable background color.\n               Obstacle set is empty if only one color is present in the inner area.\n    \"\"\"\n    h, w = grid.shape\n    # Ensure there's an inner area to analyze\n    if h <= 2 or w <= 2:\n        return None, set() \n        \n    inner_grid = grid[1:h-1, 1:w-1]\n    \n    # Check if inner grid is actually empty after slicing\n    if inner_grid.size == 0:\n        return None, set()\n\n    colors, counts = np.unique(inner_grid, return_counts=True)\n    \n    if len(colors) == 0: \n         return None, set() # Should not happen if size > 0, but safety check\n         \n    if len(colors) == 1:\n        # Only one color found, it's the background, no obstacles\n        background_color = colors[0]\n        obstacle_colors = set()\n    else:\n        # Multiple colors found, assume background is the most frequent\n        count_map = dict(zip(colors, counts))\n        # Find the color with the maximum count\n        background_color = max(count_map, key=count_map.get)\n        # Check if there are ties for the most frequent color. If so, cannot determine background.\n        max_count = count_map[background_color]\n        if sum(1 for count in count_map.values() if count == max_count) > 1:\n             # Ambiguous background color\n             return None, set() \n             \n        # Obstacles are all colors that are not the background color\n        obstacle_colors = set(c for c in colors if c != background_color)\n                 \n    return background_color, obstacle_colors\n\ndef transform(input_grid_list):\n    \"\"\"\n    Propagates colors from the four border edges inwards into an enclosed area,\n    respecting obstacle pixels.\n\n    The transformation identifies a background color (most frequent in the inner area)\n    and obstacle colors (other colors in the inner area). Colors from the middle of\n    the top, right, bottom, and left borders are propagated inwards layer by layer\n    using a simultaneous Breadth-First Search (BFS).\n\n    Propagation Rules:\n    1. Propagation starts from inner pixels adjacent to the border that match the\n       background color. These pixels are immediately colored with the corresponding\n       border color.\n    2. Propagation continues orthogonally inwards, one step per layer (BFS level).\n    3. Propagation only overwrites pixels that *originally* had the background color.\n    4. Pixels initially identified as obstacles block propagation and remain unchanged.\n    5. The 1-pixel border itself remains unchanged.\n    6. If propagation waves from different directions reach the same pixel in the\n       same BFS layer, the conflict is resolved by priority: Top > Right > Bottom > Left.\n       The highest priority wave colors the pixel.\n    7. Pixels (background or otherwise) that are not reached by any propagation wave\n       retain their original color.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = input_grid.copy()\n    h, w = input_grid.shape\n\n    # --- 1. Handle edge case: grid too small for an inner area ---\n    if h <= 2 or w <= 2:\n        return output_grid.tolist() # No inner area to propagate into\n\n    # --- 2. Identify Border Colors ---\n    # Use the middle pixel of each edge as the source color for that side.\n    c_mid = w // 2\n    r_mid = h // 2\n    top_color = input_grid[0, c_mid]\n    right_color = input_grid[r_mid, w - 1]\n    bottom_color = input_grid[h - 1, c_mid]\n    left_color = input_grid[r_mid, 0]\n    # Store border colors in the processing order for collision resolution (T, R, B, L)\n    border_colors = [top_color, right_color, bottom_color, left_color] \n\n    # --- 3. Identify Inner Background and Obstacles ---\n    background_color, obstacle_colors = find_inner_elements(input_grid)\n    \n    # If no clear background color found in the inner area, return original grid\n    if background_color is None: \n         return output_grid.tolist() \n\n    # --- 4. Initialize Propagation Structures ---\n    queues = [deque(), deque(), deque(), deque()] # T, R, B, L queues\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    # Mark border as visited (cannot be overwritten, cannot propagate from/to)\n    visited[0, :] = True\n    visited[-1, :] = True\n    visited[:, 0] = True\n    visited[:, -1] = True\n    \n    # Mark initial obstacles as visited (block propagation)\n    for r in range(1, h - 1):\n        for c in range(1, w - 1):\n            if input_grid[r, c] in obstacle_colors:\n                visited[r, c] = True\n\n    # --- 5. Seed Propagation from Inner Border Pixels ---\n    # Iterate through pixels just inside each border. If a pixel is the \n    # background color and hasn't been marked as visited (i.e., not an obstacle), \n    # color it, mark it as visited, and add to the appropriate queue.\n    # Process in T, R, B, L order for deterministic seeding at corners/edges.\n    \n    # Top seed (row 1)\n    r_seed = 1\n    for c in range(1, w - 1):\n        if not visited[r_seed, c] and input_grid[r_seed, c] == background_color:\n            output_grid[r_seed, c] = border_colors[0] # Top color\n            visited[r_seed, c] = True\n            queues[0].append((r_seed, c))\n\n    # Right seed (column w-2)\n    c_seed = w - 2\n    for r in range(1, h - 1):\n         if not visited[r, c_seed] and input_grid[r, c_seed] == background_color:\n            output_grid[r, c_seed] = border_colors[1] # Right color\n            visited[r, c_seed] = True\n            queues[1].append((r, c_seed))\n            \n    # Bottom seed (row h-2)\n    r_seed = h - 2\n    for c in range(1, w - 1):\n         if not visited[r_seed, c] and input_grid[r_seed, c] == background_color:\n            output_grid[r_seed, c] = border_colors[2] # Bottom color\n            visited[r_seed, c] = True\n            queues[2].append((r_seed, c))\n\n    # Left seed (column 1)\n    c_seed = 1\n    for r in range(1, h - 1):\n         if not visited[r, c_seed] and input_grid[r, c_seed] == background_color:\n            output_grid[r, c_seed] = border_colors[3] # Left color\n            visited[r, c_seed] = True\n            queues[3].append((r, c_seed))\n\n    # --- 6. Iterative Propagation (Simultaneous BFS Layer by Layer) ---\n    while any(q for q in queues): # Continue as long as any queue has nodes for the next layer\n        # Prepare queues for the *next* layer of propagation\n        next_queues = [deque(), deque(), deque(), deque()]\n        # Tracks pixels colored *in this specific BFS layer* to handle priority conflicts.\n        colored_this_step = np.zeros_like(input_grid, dtype=bool)\n\n        # Process queues in T, R, B, L order for priority tie-breaking\n        for i in range(4): # 0:T, 1:R, 2:B, 3:L\n            current_q = queues[i]\n            next_q = next_queues[i]\n            border_color = border_colors[i]\n\n            # Determine propagation direction based on queue index (source)\n            if i == 0: dr, dc = 1, 0   # Top propagates down\n            elif i == 1: dr, dc = 0, -1 # Right propagates left\n            elif i == 2: dr, dc = -1, 0 # Bottom propagates up\n            else: dr, dc = 0, 1        # Left propagates right\n\n            while current_q:\n                r, c = current_q.popleft()\n                nr, nc = r + dr, c + dc # Neighbor coordinates\n\n                # Check if neighbor is valid for propagation:\n                # 1. Not visited (i.e., not border, not initial obstacle, not reached in previous steps)\n                # 2. Not already colored *in this step* by a higher priority source (T>R>B>L)\n                if not visited[nr, nc] and not colored_this_step[nr, nc]:\n                    # 3. Propagation only occurs onto pixels that were *originally* the background color\n                    if input_grid[nr, nc] == background_color:\n                        output_grid[nr, nc] = border_color      # Color the neighbor\n                        visited[nr, nc] = True                  # Mark as visited globally\n                        colored_this_step[nr, nc] = True        # Mark as colored in this step\n                        next_q.append((nr, nc))                 # Add to next layer's queue\n\n        # Move to the next layer\n        queues = next_queues\n\n    # --- 7. Return the final grid ---\n    # The output_grid now contains the original border, original obstacles, \n    # original background pixels that were shielded, and the newly colored pixels.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14612,
    "candidates_token_count": 2467,
    "total_token_count": 17079,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.723718,
  "retries": null
}