{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport collections\n\n\"\"\"\nTransforms the input grid by propagating colors from the middle of each border \ninwards into a background region, respecting obstacle pixels.\n\nThe transformation logic is as follows:\n1. Identify the colors present at the midpoint of the top, right, bottom, and left borders.\n2. Analyze the inner area of the grid (excluding the 1-pixel border) to determine:\n   - The background color: The single most frequent color in the inner area. If there's a tie \n     for the most frequent color, or if the inner area is empty or uniform, the transformation\n     cannot proceed, and the original grid is returned.\n   - Obstacle colors: All other colors present in the inner area besides the background color.\n3. Perform a simultaneous Breadth-First Search (BFS) starting from all background-colored pixels \n   that are adjacent to the border.\n4. Each border source (Top, Right, Bottom, Left) attempts to expand into adjacent, \n   connected background pixels.\n5. Propagation Rules:\n   - Expansion only occurs into pixels that originally had the background color.\n   - Obstacle pixels block the expansion.\n   - The 1-pixel border remains unchanged.\n   - When expansions from different sources reach the same background pixel during the same \n     BFS layer (i.e., at the same distance from their respective borders), a conflict occurs.\n   - Conflicts are resolved based on a fixed priority: Top > Right > Bottom > Left. The \n     expansion from the higher-priority source colors the pixel.\n   - Pixels (background or obstacles) that are not reached by any expansion wave retain \n     their original color.\n\"\"\"\n\ndef find_inner_elements(grid):\n    \"\"\"\n    Analyzes the inner area (excluding the 1-pixel border) of the grid \n    to find the background color (most frequent) and the obstacle colors \n    (all other colors present in the inner area).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, obstacle_colors_set)\n               Returns (None, set()) if the inner area is empty, cannot be analyzed,\n               contains only one color (no obstacles), or contains multiple colors \n               with a tie for the most frequent (ambiguous background).\n    \"\"\"\n    h, w = grid.shape\n    # Ensure there's an inner area to analyze\n    if h <= 2 or w <= 2:\n        return None, set() \n        \n    inner_grid = grid[1:h-1, 1:w-1]\n    \n    # Check if inner grid is actually empty after slicing\n    if inner_grid.size == 0:\n        return None, set()\n\n    colors, counts = np.unique(inner_grid, return_counts=True)\n    \n    if len(colors) <= 1: \n         # Need at least one background and one obstacle color for the process\n         # Or, if only one color, it's background, but no obstacles to define regions.\n         # The problem seems to imply distinct background and obstacle regions.\n         return None, set() \n         \n    # Multiple colors found, assume background is the most frequent\n    count_map = collections.OrderedDict(sorted(zip(colors, counts), key=lambda item: item[1], reverse=True)) # Sort by count descending\n    \n    # Check for ties in the highest count\n    sorted_counts = sorted(counts, reverse=True)\n    if len(sorted_counts) > 1 and sorted_counts[0] == sorted_counts[1]:\n         # Ambiguous background color due to tie\n         return None, set() \n\n    # Background is the color with the unique highest count\n    background_color = list(count_map.keys())[0]\n                 \n    # Obstacles are all colors that are not the background color\n    obstacle_colors = set(c for c in colors if c != background_color)\n                 \n    return background_color, obstacle_colors\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the border color propagation transformation to the input grid.\n\n    Args:\n        input_grid_list (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = input_grid.copy()\n    h, w = input_grid.shape\n\n    # --- Handle edge case: grid too small for an inner area ---\n    if h <= 2 or w <= 2:\n        return output_grid.tolist() # No inner area to propagate into\n\n    # --- 1. Identify Border Colors ---\n    # Use the middle pixel of each edge as the source color for that side.\n    # Integer division // handles both even and odd dimensions correctly for midpoint.\n    c_mid = w // 2\n    r_mid = h // 2\n    # Store border colors in the processing order for collision resolution (T, R, B, L)\n    border_colors = [\n        input_grid[0, c_mid],       # 0: Top\n        input_grid[r_mid, w - 1],   # 1: Right\n        input_grid[h - 1, c_mid],   # 2: Bottom\n        input_grid[r_mid, 0]        # 3: Left\n    ]\n\n    # --- 2. Identify Inner Background and Obstacles ---\n    background_color, obstacle_colors = find_inner_elements(input_grid)\n    \n    # If no clear background color or no obstacles found, return original grid\n    if background_color is None: \n         return output_grid.tolist() \n\n    # --- 3. Initialize Propagation Structures ---\n    queues = [deque() for _ in range(4)] # T, R, B, L queues\n    # visited array also stores the source index + 1 (1=T, 2=R, 3=B, 4=L)\n    # 0 means not visited, > 0 means visited by source (value - 1)\n    visited = np.zeros(input_grid.shape, dtype=int) \n    \n    # Mark border as visited (cannot be overwritten, cannot propagate from/to)\n    # Use a value unlikely to be a source index + 1, e.g., 99\n    visited[0, :] = 99\n    visited[-1, :] = 99\n    visited[:, 0] = 99\n    visited[:, -1] = 99\n    \n    # Mark initial obstacles as visited (block propagation)\n    for r in range(1, h - 1):\n        for c in range(1, w - 1):\n            if input_grid[r, c] in obstacle_colors:\n                visited[r, c] = 99 # Mark obstacles\n\n    # --- 4. Seed Propagation ---\n    # Add initial background pixels adjacent to borders to queues and mark as visited by source.\n    # Process in T, R, B, L order for deterministic seeding at corners/edges.\n    \n    # Top seed (row 1)\n    source_index = 0 # Top\n    r_seed = 1\n    for c in range(1, w - 1):\n        if visited[r_seed, c] == 0 and input_grid[r_seed, c] == background_color:\n            visited[r_seed, c] = source_index + 1\n            queues[source_index].append((r_seed, c))\n\n    # Right seed (column w-2)\n    source_index = 1 # Right\n    c_seed = w - 2\n    for r in range(1, h - 1):\n         if visited[r, c_seed] == 0 and input_grid[r, c_seed] == background_color:\n            # Only seed if not already seeded by Top (higher priority)\n            visited[r, c_seed] = source_index + 1 \n            queues[source_index].append((r, c_seed))\n            \n    # Bottom seed (row h-2)\n    source_index = 2 # Bottom\n    r_seed = h - 2\n    for c in range(1, w - 1):\n         if visited[r_seed, c] == 0 and input_grid[r_seed, c] == background_color:\n             # Check higher priorities (T, R)\n            visited[r_seed, c] = source_index + 1\n            queues[source_index].append((r_seed, c))\n\n    # Left seed (column 1)\n    source_index = 3 # Left\n    c_seed = 1\n    for r in range(1, h - 1):\n         if visited[r, c_seed] == 0 and input_grid[r, c_seed] == background_color:\n             # Check higher priorities (T, R, B)\n            visited[r, c_seed] = source_index + 1\n            queues[source_index].append((r, c_seed))\n\n    # --- 5. Iterative Propagation (Simultaneous BFS Layer by Layer) ---\n    active_queues = True\n    while active_queues:\n        active_queues = False # Assume no propagation happens in this layer\n        coords_to_process_next = [[] for _ in range(4)] # Collect coords for next layer\n\n        # Process queues layer by layer, respecting priority T > R > B > L\n        for i in range(4): # 0:T, 1:R, 2:B, 3:L\n            q = queues[i]\n            source_color = border_colors[i]\n            \n            processed_in_this_source = len(q) > 0 # Flag if this source had nodes\n            if processed_in_this_source:\n                 active_queues = True # Mark that work was done in this layer\n\n            while q:\n                r, c = q.popleft()\n                # Color the pixel in the output grid\n                output_grid[r, c] = source_color\n\n                # Explore orthogonal neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n\n                    # Check bounds (already implicitly handles border check due to visited init)\n                    # Check if neighbor is unvisited (value 0) background pixel\n                    if visited[nr, nc] == 0 and input_grid[nr, nc] == background_color:\n                        visited[nr, nc] = i + 1 # Mark visited by this source\n                        coords_to_process_next[i].append((nr, nc)) # Add to next layer list\n\n        # Update queues for the next layer\n        for i in range(4):\n            queues[i].clear()\n            queues[i].extend(coords_to_process_next[i])\n\n    # --- 6. Return the final grid ---\n    # output_grid contains original border, obstacles, unreached background, and filled areas.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14461,
    "candidates_token_count": 2589,
    "total_token_count": 17050,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 138.040494,
  "retries": null
}