{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\ndef find_inner_colors(grid):\n    \"\"\"\n    Analyzes the inner area (excluding the 1-pixel border) of the grid \n    to find the background color (most frequent) and the obstacle color \n    (assumed to be the single other color present, if any).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, obstacle_color)\n               Returns (None, None) if the inner area is empty or cannot be analyzed.\n               Obstacle color is None if only one color is present in the inner area.\n    \"\"\"\n    h, w = grid.shape\n    # Ensure there's an inner area to analyze\n    if h <= 2 or w <= 2:\n        return None, None \n        \n    inner_grid = grid[1:h-1, 1:w-1]\n    \n    # Check if inner grid is actually empty after slicing\n    if inner_grid.size == 0:\n        return None, None\n\n    colors, counts = np.unique(inner_grid, return_counts=True)\n    \n    if len(colors) == 0: \n         return None, None # Should not happen if size > 0, but safety check\n         \n    if len(colors) == 1:\n        # Only one color found, it's the background, no obstacles\n        background_color = colors[0]\n        obstacle_color = None\n    else:\n        # Multiple colors found, assume background is the most frequent\n        count_map = dict(zip(colors, counts))\n        background_color = max(count_map, key=count_map.get)\n        # Assume the first color encountered that isn't background is the obstacle\n        obstacle_color = None\n        for color in colors:\n             if color != background_color:\n                 obstacle_color = color\n                 break # Assuming only one type of obstacle color based on examples\n                 \n    return background_color, obstacle_color\n\ndef transform(input_grid_list):\n    \"\"\"\n    Propagates colors from the four sides of a 1-pixel border inwards into an \n    enclosed area. The propagation starts from background pixels immediately \n    inside the border and moves orthogonally inwards, layer by layer (BFS). \n    \n    Propagation Rules:\n    1. Only overwrites pixels that initially had the 'background_color'.\n    2. 'background_color' is the most frequent color in the initial inner area.\n    3. 'obstacle_color' is any other color initially present in the inner area.\n    4. Pixels with the 'obstacle_color' block propagation and remain unchanged.\n    5. Pixels retain their original color if not reached by propagation (e.g., shielded \n       background pixels or original obstacle pixels).\n    6. The 1-pixel border itself remains unchanged.\n    7. If propagation waves from different directions reach the same pixel in the \n       same step (layer), the conflict is resolved by processing order: \n       Top -> Right -> Bottom -> Left. The first wave to claim the pixel colors it.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = input_grid.copy()\n    h, w = input_grid.shape\n\n    # --- 1. Handle edge case: grid too small for an inner area ---\n    if h <= 2 or w <= 2:\n        # No inner area to propagate into, return the original grid\n        return output_grid.tolist()\n\n    # --- 2. Identify Grid Elements ---\n    # Get border colors, handling potential 1xN or Nx1 grids where some sides are just corners\n    # Default to the corner color if a side doesn't exist (e.g., grid[0,1] in a Hx1 grid)\n    top_color = input_grid[0, 1] if w > 1 else input_grid[0, 0]\n    right_color = input_grid[1, w - 1] if h > 1 else input_grid[0, w-1]\n    bottom_color = input_grid[h - 1, 1] if w > 1 else input_grid[h-1, 0]\n    left_color = input_grid[1, 0] if h > 1 else input_grid[0, 0]\n    # Store border colors in the processing order for collision resolution\n    border_colors = [top_color, right_color, bottom_color, left_color] # Order: T, R, B, L\n\n    # Find background and potential obstacle color in the inner area\n    background_color, obstacle_color = find_inner_colors(input_grid)\n    \n    # If the inner area couldn't be analyzed (e.g., completely empty somehow)\n    # or if there's no background color to propagate onto, return the original.\n    if background_color is None: \n         return output_grid.tolist() \n\n    # --- 3. Setup Propagation Structures ---\n    q_top = deque()\n    q_right = deque()\n    q_bottom = deque()\n    q_left = deque()\n    # Queues store tuples: (row, column)\n    queues = [q_top, q_right, q_bottom, q_left] \n    \n    # Create a mask to track which pixels have been colored by propagation.\n    # Initialize all to True (cannot be colored).\n    colored_mask = np.ones_like(input_grid, dtype=bool) \n    # Set the inner area to False (can potentially be colored).\n    colored_mask[1:h-1, 1:w-1] = False \n\n    # --- 4. Seed Propagation from Inner Border ---\n    # Iterate through pixels just inside each border. If a pixel is the \n    # background color and hasn't been colored yet (important for corners where\n    # seeding waves might overlap), color it, mark it, and add to the queue.\n    # Process in T, R, B, L order for deterministic seeding at corners.\n    \n    # Top seed (propagate downwards)\n    r_seed_top = 1\n    for c in range(1, w - 1):\n        if input_grid[r_seed_top, c] == background_color and not colored_mask[r_seed_top, c]:\n            output_grid[r_seed_top, c] = top_color\n            colored_mask[r_seed_top, c] = True\n            q_top.append((r_seed_top, c))\n\n    # Right seed (propagate leftwards)\n    c_seed_right = w - 2\n    for r in range(1, h - 1):\n         if input_grid[r, c_seed_right] == background_color and not colored_mask[r, c_seed_right]:\n            output_grid[r, c_seed_right] = right_color\n            colored_mask[r, c_seed_right] = True\n            q_right.append((r, c_seed_right))\n            \n    # Bottom seed (propagate upwards)\n    r_seed_bottom = h - 2\n    for c in range(1, w - 1):\n         if input_grid[r_seed_bottom, c] == background_color and not colored_mask[r_seed_bottom, c]:\n            output_grid[r_seed_bottom, c] = bottom_color\n            colored_mask[r_seed_bottom, c] = True\n            q_bottom.append((r_seed_bottom, c))\n\n    # Left seed (propagate rightwards)\n    c_seed_left = 1\n    for r in range(1, h - 1):\n         if input_grid[r, c_seed_left] == background_color and not colored_mask[r, c_seed_left]:\n            output_grid[r, c_seed_left] = left_color\n            colored_mask[r, c_seed_left] = True\n            q_left.append((r, c_seed_left))\n\n    # --- 5. Iterative Propagation (Simultaneous BFS Layer by Layer) ---\n    while any(queues): # Continue as long as any queue has nodes for the next layer\n        # Prepare queues for the *next* layer of propagation\n        next_q_top = deque()\n        next_q_right = deque()\n        next_q_bottom = deque()\n        next_q_left = deque()\n        next_queues = [next_q_top, next_q_right, next_q_bottom, next_q_left]\n\n        # Process propagation for the current layer, in T, R, B, L order\n        \n        # Top queue expands downwards\n        while q_top:\n            r, c = q_top.popleft()\n            nr, nc = r + 1, c # Neighbor coordinates\n            # Check: neighbor within inner bounds? Is neighbor originally background? Not already colored?\n            if 1 <= nr < h - 1 and input_grid[nr, nc] == background_color and not colored_mask[nr, nc]:\n                output_grid[nr, nc] = top_color   # Color the neighbor\n                colored_mask[nr, nc] = True       # Mark as colored\n                next_q_top.append((nr, nc))       # Add to next layer's queue\n\n        # Right queue expands leftwards\n        while q_right:\n            r, c = q_right.popleft()\n            nr, nc = r, c - 1\n            if 1 <= nc < w - 1 and input_grid[nr, nc] == background_color and not colored_mask[nr, nc]:\n                 output_grid[nr, nc] = right_color\n                 colored_mask[nr, nc] = True\n                 next_q_right.append((nr, nc))\n\n        # Bottom queue expands upwards\n        while q_bottom:\n            r, c = q_bottom.popleft()\n            nr, nc = r - 1, c\n            if 1 <= nr < h - 1 and input_grid[nr, nc] == background_color and not colored_mask[nr, nc]:\n                 output_grid[nr, nc] = bottom_color\n                 colored_mask[nr, nc] = True\n                 next_q_bottom.append((nr, nc))\n\n        # Left queue expands rightwards\n        while q_left:\n            r, c = q_left.popleft()\n            nr, nc = r, c + 1\n            if 1 <= nc < w - 1 and input_grid[nr, nc] == background_color and not colored_mask[nr, nc]:\n                 output_grid[nr, nc] = left_color\n                 colored_mask[nr, nc] = True\n                 next_q_left.append((nr, nc))\n\n        # Move to the next layer\n        queues = next_queues\n        q_top, q_right, q_bottom, q_left = queues\n\n    # --- 6. Return the final grid ---\n    # The output_grid now contains the original border, original obstacles, \n    # original background pixels that were shielded, and the newly colored pixels.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23386,
    "candidates_token_count": 2622,
    "total_token_count": 26008,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.075463,
  "retries": null
}