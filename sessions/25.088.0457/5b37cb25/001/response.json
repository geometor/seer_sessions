{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nPropagates colors from the four sides of a 1-pixel border inwards into an enclosed area.\nThe propagation starts from the pixels immediately inside the border.\nPropagation moves one step orthogonally inwards per iteration (like a breadth-first search).\nIf a propagation wave encounters a pixel of a pre-identified 'obstacle' color, it colors that obstacle pixel but does not propagate further past it along that path.\nIf propagation waves from different borders reach the same pixel in the same step, the pixel takes the color of the wave that originated from the border corresponding to the processing order (Top, Right, Bottom, Left). In practice, the first wave to claim a pixel prevents others from claiming it.\nPixels that are not reached by any propagation wave (e.g., behind obstacles) retain their original color.\nThe border itself remains unchanged.\n\"\"\"\n\ndef find_obstacle_color(grid, border_colors):\n    \"\"\"Identifies the obstacle color within the inner area.\"\"\"\n    h, w = grid.shape\n    if h <= 2 or w <= 2: # No inner area\n        return None\n        \n    inner_grid = grid[1:h-1, 1:w-1]\n    unique_colors, counts = np.unique(inner_grid, return_counts=True)\n    \n    if len(unique_colors) == 0:\n        return None # Empty inner grid\n\n    # Exclude border colors from potential obstacle colors\n    border_colors_set = set(border_colors)\n    \n    # Find the most frequent color, assume it's background\n    # Handle cases where inner grid might be uniform (no obstacles)\n    if len(unique_colors) == 1:\n         return None # Only one color inside, no obstacles\n         \n    # Find potential background color (most frequent)\n    # Need to ignore colors that might be border colors spilling in initial state if they match background\n    possible_bg_candidates = {}\n    for color, count in zip(unique_colors, counts):\n         possible_bg_candidates[color] = count\n\n    # Remove border colors from candidates *if they exist*\n    for bc in border_colors_set:\n        if bc in possible_bg_candidates:\n             # Don't assume a border color IS the background if it's infrequent\n             # Heuristic: If a border color is the most frequent, it's likely background\n             # If not, it's unlikely background. Let's refine this.\n             pass # Keep border colors for now, let frequency decide background\n\n    if not possible_bg_candidates:\n        # This happens if the inner grid only contained border colors\n        return None \n\n    background_color = max(possible_bg_candidates, key=possible_bg_candidates.get)\n\n    # Obstacle is a color in the inner grid that is NOT the background and NOT a border color\n    obstacle_color = None\n    for color in unique_colors:\n        if color != background_color: #and color not in border_colors_set:\n             # Let's rethink: the obstacle color is defined *before* propagation.\n             # It's simply the non-background color present initially.\n             # What if multiple non-background colors exist? The examples only show one.\n             # Assume only one type of obstacle color exists besides background.\n             obstacle_color = color\n             break # Found the first non-background color, assume it's the obstacle\n\n    # Check if the found 'obstacle' color is actually one of the border colors\n    # This can happen if the example shows a border color already present inside\n    # In train_1, obstacle is 6, borders are 3, 2, 4, 8. Bg=1. OK.\n    # In train_2, obstacle is 2, borders are 1, 8, 6, 3. Bg=4. OK.\n    # If the identified non-background color IS a border color, then there are no obstacles\n    # of a distinct color.\n    if obstacle_color in border_colors_set:\n        return None # No distinct obstacle color found\n\n    return obstacle_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the border color propagation transformation.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    h, w = grid.shape\n\n    # Handle grids too small to have an inner area\n    if h <= 2 or w <= 2:\n        return output_grid.tolist()\n\n    # 1. Identify border colors (assuming 1-pixel border)\n    # Added checks for grid size > 1 in that dimension\n    top_color = grid[0, 1] if w > 1 else grid[0,0]\n    right_color = grid[1, w - 1] if h > 1 else grid[0, w-1]\n    bottom_color = grid[h - 1, 1] if w > 1 else grid[h-1, 0]\n    left_color = grid[1, 0] if h > 1 else grid[0, 0]\n    border_colors = [top_color, right_color, bottom_color, left_color] # Order matters: T, R, B, L\n\n    # 2. Identify the obstacle color\n    obstacle_color = find_obstacle_color(grid, border_colors)\n    # print(f\"Obstacle color identified as: {obstacle_color}\") # Debug\n\n    # 3. Initialize BFS structures\n    # source_grid stores the index of the border color (0=T, 1=R, 2=B, 3=L) that claimed the pixel\n    source_grid = np.full_like(grid, -1, dtype=int)\n    \n    q_top = deque()\n    q_right = deque()\n    q_bottom = deque()\n    q_left = deque()\n    queues = [q_top, q_right, q_bottom, q_left]\n\n    # 4. Initialize queues with pixels just inside each border\n    # Top border initialization\n    for c in range(1, w - 1):\n        r = 1\n        if source_grid[r, c] == -1:\n            source_grid[r, c] = 0 # 0 for Top\n            q_top.append((r, c))\n            \n    # Right border initialization\n    for r in range(1, h - 1):\n        c = w - 2\n        if source_grid[r, c] == -1:\n             source_grid[r, c] = 1 # 1 for Right\n             q_right.append((r, c))\n\n    # Bottom border initialization\n    for c in range(1, w - 1):\n        r = h - 2\n        if source_grid[r, c] == -1:\n             source_grid[r, c] = 2 # 2 for Bottom\n             q_bottom.append((r, c))\n\n    # Left border initialization\n    for r in range(1, h - 1):\n        c = 1\n        if source_grid[r, c] == -1:\n             source_grid[r, c] = 3 # 3 for Left\n             q_left.append((r, c))\n\n    # 5. Perform simultaneous BFS, layer by layer\n    while any(queues):\n        next_q_top = deque()\n        next_q_right = deque()\n        next_q_bottom = deque()\n        next_q_left = deque()\n        next_queues = [next_q_top, next_q_right, next_q_bottom, next_q_left]\n\n        # Process Top queue expansion (downwards)\n        while q_top:\n            r, c = q_top.popleft()\n            nr, nc = r + 1, c\n            # Check bounds and if already claimed\n            if 1 <= nr < h - 1 and 1 <= nc < w - 1 and source_grid[nr, nc] == -1:\n                source_grid[nr, nc] = 0 # Claimed by Top\n                # Check if the target pixel is NOT an obstacle before adding to next queue\n                if grid[nr, nc] != obstacle_color:\n                    next_q_top.append((nr, nc))\n\n        # Process Right queue expansion (leftwards)\n        while q_right:\n            r, c = q_right.popleft()\n            nr, nc = r, c - 1\n            if 1 <= nr < h - 1 and 1 <= nc < w - 1 and source_grid[nr, nc] == -1:\n                source_grid[nr, nc] = 1 # Claimed by Right\n                if grid[nr, nc] != obstacle_color:\n                     next_q_right.append((nr, nc))\n\n        # Process Bottom queue expansion (upwards)\n        while q_bottom:\n            r, c = q_bottom.popleft()\n            nr, nc = r - 1, c\n            if 1 <= nr < h - 1 and 1 <= nc < w - 1 and source_grid[nr, nc] == -1:\n                 source_grid[nr, nc] = 2 # Claimed by Bottom\n                 if grid[nr, nc] != obstacle_color:\n                     next_q_bottom.append((nr, nc))\n\n        # Process Left queue expansion (rightwards)\n        while q_left:\n            r, c = q_left.popleft()\n            nr, nc = r, c + 1\n            if 1 <= nr < h - 1 and 1 <= nc < w - 1 and source_grid[nr, nc] == -1:\n                source_grid[nr, nc] = 3 # Claimed by Left\n                if grid[nr, nc] != obstacle_color:\n                     next_q_left.append((nr, nc))\n\n        # Update queues for the next layer\n        queues = next_queues\n        q_top, q_right, q_bottom, q_left = queues\n\n    # 6. Apply the colors based on the source grid\n    for r in range(1, h - 1):\n        for c in range(1, w - 1):\n            source_index = source_grid[r, c]\n            if source_index != -1: # If the pixel was claimed\n                output_grid[r, c] = border_colors[source_index]\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10157,
    "candidates_token_count": 2428,
    "total_token_count": 12585,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 122.048262,
  "retries": null
}