{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation rule involves identifying a repeating background pattern in the input grid that is partially obscured by noise (pixels of color blue, value 1). The goal is to remove the noise and restore the underlying pattern across the entire grid.\n\n1.  **Identify Noise:** The noise color is blue (1).\n2.  **Determine Pattern Dimensions:** Find the height (H) and width (W) of the smallest repeating unit (tile) of the background pattern. This is done by analyzing the periodicity of rows and columns, ignoring the noise pixels. The smallest H > 0 is found such that for all rows r >= H, row r is consistent with row r % H (ignoring noise). Similarly, the smallest W > 0 is found such that for all columns c >= W, column c is consistent with column c % W (ignoring noise).\n3.  **Infer Base Pattern Tile:** Create an HxW tile representing the fundamental repeating unit. For each position (ph, pw) within this tile (0 <= ph < H, 0 <= pw < W):\n    a.  Gather all pixel values from the input grid at locations (r, c) where r % H == ph and c % W == pw.\n    b.  Filter out the noise color (1) from the gathered pixels.\n    c.  If only noise pixels were found for this position, the pattern color for (ph, pw) is the noise color (1).\n    d.  Otherwise, determine the most frequent color among the non-noise pixels gathered for this position. This color becomes the pattern color for (ph, pw).\n4.  **Reconstruct Output Grid:** Create an output grid of the same dimensions as the input grid. Fill each cell (r, c) of the output grid with the color from the inferred base pattern tile at position (r % H, c % W).\n\"\"\"\n\ndef find_pattern_dimensions(grid: np.ndarray, noise_color: int = 1) -> tuple[int, int]:\n    \"\"\"\n    Determines the height (H) and width (W) of the repeating pattern tile.\n\n    Args:\n        grid: The input grid as a numpy array.\n        noise_color: The integer value representing noise pixels to ignore.\n\n    Returns:\n        A tuple (H, W) representing the pattern dimensions.\n    \"\"\"\n    grid_height, grid_width = grid.shape\n    H = grid_height\n    W = grid_width\n\n    # Find smallest repeating height H\n    for h_candidate in range(1, grid_height):\n        is_periodic_height = True\n        # Check if rows repeat with period h_candidate, ignoring noise\n        for r in range(h_candidate, grid_height):\n            for c in range(grid_width):\n                val1 = grid[r, c]\n                val2 = grid[r - h_candidate, c] # Compare with row H positions above\n                # Check for mismatch only if neither is noise\n                if val1 != noise_color and val2 != noise_color and val1 != val2:\n                    is_periodic_height = False\n                    break\n            if not is_periodic_height:\n                break\n        \n        # Check consistency using modulo - rows r and r % H should match where not noise\n        is_consistent_mod = True\n        if is_periodic_height: # Optional secondary check for robustness\n             for r in range(h_candidate, grid_height):\n                 for c in range(grid_width):\n                     val1 = grid[r, c]\n                     val2 = grid[r % h_candidate, c]\n                     if val1 != noise_color and val2 != noise_color and val1 != val2:\n                        is_consistent_mod = False\n                        break\n                 if not is_consistent_mod:\n                    break\n        \n        # If both checks (or just the first one if preferred) pass, we found H\n        # Using the first check (periodicity) as primary.\n        if is_periodic_height: # and is_consistent_mod: \n            H = h_candidate\n            break\n\n    # Find smallest repeating width W\n    for w_candidate in range(1, grid_width):\n        is_periodic_width = True\n        # Check if columns repeat with period w_candidate, ignoring noise\n        for c in range(w_candidate, grid_width):\n            for r in range(grid_height):\n                val1 = grid[r, c]\n                val2 = grid[r, c - w_candidate] # Compare with column W positions left\n                # Check for mismatch only if neither is noise\n                if val1 != noise_color and val2 != noise_color and val1 != val2:\n                    is_periodic_width = False\n                    break\n            if not is_periodic_width:\n                break\n        \n        # Check consistency using modulo\n        is_consistent_mod = True\n        if is_periodic_width:\n            for c in range(w_candidate, grid_width):\n                for r in range(grid_height):\n                    val1 = grid[r, c]\n                    val2 = grid[r, c % w_candidate]\n                    if val1 != noise_color and val2 != noise_color and val1 != val2:\n                        is_consistent_mod = False\n                        break\n                if not is_consistent_mod:\n                    break\n\n        if is_periodic_width: # and is_consistent_mod:\n            W = w_candidate\n            break\n            \n    # Fallback if no period found (shouldn't happen with task structure)\n    if H == grid_height and W == grid_width:\n         print(f\"Warning: Could not determine clear periodicity. Using full grid dimensions ({grid_height}x{grid_width}).\")\n\n\n    return H, W\n\n\ndef infer_pattern_tile(grid: np.ndarray, H: int, W: int, noise_color: int = 1) -> np.ndarray:\n    \"\"\"\n    Infers the HxW base pattern tile from the noisy grid.\n\n    Args:\n        grid: The input grid as a numpy array.\n        H: The height of the pattern tile.\n        W: The width of the pattern tile.\n        noise_color: The integer value representing noise pixels.\n\n    Returns:\n        An HxW numpy array representing the base pattern tile.\n    \"\"\"\n    pattern_tile = np.zeros((H, W), dtype=int)\n    grid_height, grid_width = grid.shape\n\n    for ph in range(H):\n        for pw in range(W):\n            # Collect all pixels in the input grid corresponding to this pattern tile position\n            pixels = []\n            # Iterate through all grid cells that map to (ph, pw) in the tile structure\n            for r in range(ph, grid_height, H):\n                 for c in range(pw, grid_width, W):\n                    pixels.append(grid[r,c])\n\n            # Filter out the noise color\n            non_noise_pixels = [p for p in pixels if p != noise_color]\n\n            # Determine the pattern color for this position\n            if not non_noise_pixels:\n                # If only noise pixels were found, the pattern color is the noise color\n                pattern_tile[ph, pw] = noise_color\n            else:\n                # Otherwise, find the most frequent non-noise color\n                count = Counter(non_noise_pixels)\n                # most_common returns list of (element, count) tuples\n                most_common_color = count.most_common(1)[0][0]\n                pattern_tile[ph, pw] = most_common_color\n\n    return pattern_tile\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Restores a repeating background pattern in a grid obscured by noise (blue=1).\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the restored grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_array = np.array(input_grid, dtype=int)\n    grid_height, grid_width = input_array.shape\n    noise_color = 1 # Blue is the noise color in the examples\n\n    # Step 1: Determine the dimensions (H, W) of the repeating pattern tile\n    # We refine the dimension finding logic here. Instead of simple periodicity,\n    # let's find the smallest H, W such that the grid *mostly* conforms\n    # to grid[r,c] == grid[r % H, c % W] when not noise.\n    # Using the previously defined function, which checks periodicity.\n    H, W = find_pattern_dimensions(input_array, noise_color)\n    #print(f\"Determined Pattern Dimensions: H={H}, W={W}\") # Debug print\n\n    # Step 2: Infer the HxW base pattern tile by finding the mode color for each position\n    pattern_tile = infer_pattern_tile(input_array, H, W, noise_color)\n    #print(\"Inferred Pattern Tile:\") # Debug print\n    #print(pattern_tile) # Debug print\n\n\n    # Step 3: Create the output grid by tiling the inferred pattern\n    output_array = np.zeros_like(input_array)\n    for r in range(grid_height):\n        for c in range(grid_width):\n            # Use the modulo operator to find the corresponding position in the pattern tile\n            pattern_row = r % H\n            pattern_col = c % W\n            output_array[r, c] = pattern_tile[pattern_row, pattern_col]\n\n    # Convert the result back to a list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8899,
    "candidates_token_count": 2230,
    "total_token_count": 11129,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 48.64239,
  "retries": null
}