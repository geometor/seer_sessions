{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components in the input grid. A component consists of contiguous pixels that are not white (0), connected cardinally and diagonally. \nA component is considered \"valid\" if it contains exactly one pixel whose color is not blue (1) and not white (0). This unique non-blue, non-white pixel is the \"marker\".\nFor each valid component:\n  - Identify the marker's color.\n  - Identify all the blue (1) pixels belonging to this component.\n  - For each blue pixel in the component, determine if it is \"interior\". A blue pixel is interior if none of its cardinal neighbors (up, down, left, right) are white (0) pixels OR fall outside the grid boundary.\n  - Change the color of all interior blue pixels within the valid component to the marker's color in the output grid.\nPixels in invalid components (those with zero or more than one marker) and pixels not part of any component (white pixels) remain unchanged.\n\"\"\"\n\ndef find_marker_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component starting from (start_r, start_c) using BFS.\n    The component includes non-white (0) pixels, connected cardinally and diagonally.\n    It also identifies if the component has exactly one non-blue(1), non-white(0) marker pixel.\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): A boolean grid tracking visited pixels.\n\n    Returns:\n        tuple: (component_pixels, marker_color, is_valid)\n            component_pixels (list): List of ((r, c), color) tuples for pixels in the component.\n            marker_color (int): The color of the unique marker, or -1 if not unique/found.\n            is_valid (bool): True if the component has exactly one marker pixel.\n    \"\"\"\n    height, width = grid.shape\n    start_color = grid[start_r, start_c]\n\n    # Ignore white pixels or already visited pixels\n    if start_color == 0 or visited[start_r, start_c]:\n        return [], -1, False\n\n    component_pixels = []\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n\n    marker_color = -1\n    marker_count = 0\n    marker_coord = None # Store coord to ensure only one marker *pixel* exists\n\n    while q:\n        r, c = q.popleft()\n        current_color = grid[r, c]\n        component_pixels.append(((r, c), current_color))\n\n        # Check if this pixel is a potential marker\n        if current_color > 1: # Non-blue, non-white\n            if marker_count == 0:\n                marker_color = current_color\n                marker_count = 1\n                marker_coord = (r, c)\n            # If we find another marker pixel (different location or different color)\n            elif (r,c) != marker_coord: \n                 # Check if it's the *same* color but different location, or just different color\n                 # Either way, more than one marker pixel means invalid.\n                 marker_count = 2 # Mark as invalid (more than one marker pixel)\n\n\n        # Explore neighbors (8 directions: cardinal + diagonal)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    neighbor_color = grid[nr, nc]\n                    # Check if neighbor is part of the component (not white) and not visited\n                    if neighbor_color != 0 and not visited[nr, nc]:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n    is_valid = (marker_count == 1)\n    if not is_valid:\n        marker_color = -1 # Ensure marker_color is -1 if not valid\n\n    return component_pixels, marker_color, is_valid\n\ndef is_interior(grid, r, c):\n    \"\"\"\n    Checks if a pixel at (r, c) is 'interior'.\n    An interior pixel is not cardinally adjacent to any white (0) pixel\n    or the grid boundary.\n\n    Args:\n        grid (np.array): The input grid.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n\n    Returns:\n        bool: True if the pixel is interior, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    # Check cardinal neighbors\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n\n        # If neighbor is out of bounds OR is white (0), it's a boundary pixel.\n        if not (0 <= nr < height and 0 <= nc < width) or grid[nr, nc] == 0:\n            return False\n\n    # If no white or out-of-bounds neighbors were found\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding valid components (connected non-white pixels\n    with exactly one marker pixel), and filling the interior blue pixels of those\n    components with the marker color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    visited = np.zeros_like(input_np, dtype=bool)\n\n    # Iterate through each cell to find starting points of components\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white and hasn't been visited as part of a component yet\n            if input_np[r, c] != 0 and not visited[r, c]:\n                # Find the connected component starting from here\n                component_pixels, marker_color, is_valid = find_marker_component(input_np, r, c, visited)\n\n                # If the component is valid (exactly one marker found)\n                if is_valid:\n                    # Iterate through all pixels identified as part of this valid component\n                    for (br, bc), pixel_color in component_pixels:\n                        # We only modify blue pixels\n                        if pixel_color == 1:\n                            # Check if the blue pixel is an interior pixel\n                            if is_interior(input_np, br, bc):\n                                # Change the color of this interior blue pixel in the output grid\n                                output_np[br, bc] = marker_color\n                # No action needed for invalid components, pixels are already marked visited\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13743,
    "candidates_token_count": 1635,
    "total_token_count": 15378,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 115.407996,
  "retries": null
}