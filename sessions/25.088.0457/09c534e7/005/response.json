{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components in the input grid. A component consists of contiguous pixels that are not white (0), connected both cardinally and diagonally (8-way).\nA component is considered 'valid' if it contains exactly one 'marker' pixel. A marker pixel is any pixel whose color is not white (0) and not blue (1).\nFor each valid component:\n  - Identify the color of the unique marker pixel (the 'marker color').\n  - Identify all the blue (1) pixels belonging to this component.\n  - For each blue pixel in the component, determine if it is 'interior'. A blue pixel is defined as 'interior' if *all* of its cardinal neighbors (up, down, left, right) are also pixels belonging to the *same* connected component (i.e., they are non-white and part of the component found using 8-way connectivity).\n  - Change the color of all identified 'interior' blue pixels within the valid component to the marker color in the output grid.\nPixels belonging to invalid components (those with zero or more than one marker pixel), blue pixels in valid components that are not interior, marker pixels themselves, and the original white background pixels remain unchanged in the output grid.\n\"\"\"\n\ndef find_component_and_marker(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds a connected component (8-way) of non-white pixels starting from (start_r, start_c) using BFS.\n    Determines if the component is valid (exactly one non-blue, non-white marker pixel).\n\n    Args:\n        grid (np.array): The input grid.\n        start_r (int): Starting row index.\n        start_c (int): Starting column index.\n        visited (np.array): A boolean grid tracking visited pixels across calls.\n\n    Returns:\n        tuple: (component_coords, marker_color, is_valid)\n            component_coords (list): List of (r, c) tuples for pixels in the component.\n            marker_color (int): The color of the unique marker, or -1 if not unique/found.\n            is_valid (bool): True if the component has exactly one marker pixel.\n    \"\"\"\n    height, width = grid.shape\n    start_color = grid[start_r, start_c]\n\n    # Should not happen if called correctly, but defensive check\n    if start_color == 0 or visited[start_r, start_c]:\n        return [], -1, False\n\n    component_coords = []\n    q = deque([(start_r, start_c)])\n    visited[start_r, start_c] = True\n\n    marker_color = -1\n    marker_coord = None # Store coord of the first marker found\n    marker_count = 0    # Count distinct marker pixels found\n\n    while q:\n        r, c = q.popleft()\n        current_color = grid[r, c]\n        component_coords.append((r, c))\n\n        # Check if this pixel is a potential marker (non-white, non-blue)\n        if current_color > 1:\n            if marker_count == 0:\n                marker_color = current_color\n                marker_coord = (r, c)\n                marker_count = 1\n            # If we find another potential marker *pixel* (different location)\n            elif (r, c) != marker_coord:\n                # More than one marker pixel, regardless of color, makes it invalid\n                marker_count = 2 # Mark as invalid (more than one marker pixel)\n\n        # Explore neighbors (8 directions: cardinal + diagonal)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    neighbor_color = grid[nr, nc]\n                    # Check if neighbor is part of the component (not white) and not visited\n                    if neighbor_color != 0 and not visited[nr, nc]:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n    # Final validity check based on the number of distinct marker pixels found\n    is_valid = (marker_count == 1)\n    if not is_valid:\n        marker_color = -1 # Ensure marker_color is -1 if not valid\n\n    return component_coords, marker_color, is_valid\n\ndef is_interior(grid_shape, r, c, component_coords_set):\n    \"\"\"\n    Checks if a pixel at (r, c) is 'interior' relative to its component.\n    An interior pixel must have all its cardinal neighbors within the grid bounds\n    AND belonging to the same component (present in component_coords_set).\n\n    Args:\n        grid_shape (tuple): (height, width) of the grid.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n        component_coords_set (set): A set of (r, c) tuples belonging to the component.\n\n    Returns:\n        bool: True if the pixel is interior, False otherwise.\n    \"\"\"\n    height, width = grid_shape\n    # Check cardinal neighbors\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n\n        # Neighbor must be within bounds AND belong to the same component set\n        if not (0 <= nr < height and 0 <= nc < width and (nr, nc) in component_coords_set):\n            # If any cardinal neighbor is out of bounds or not in the component set,\n            # the pixel (r, c) is considered a boundary pixel, not interior.\n            return False\n\n    # If all cardinal neighbors passed the check (in bounds and in the component set)\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding valid components (connected non-white pixels\n    with exactly one marker pixel), and filling the interior blue pixels of those\n    components with the marker color. Interior blue pixels are those whose cardinal\n    neighbors all belong to the same component.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    visited = np.zeros_like(input_np, dtype=bool)\n\n    # Iterate through each cell to find starting points of components\n    for r in range(height):\n        for c in range(width):\n            # If pixel is non-white (part of a potential component) and hasn't been visited yet\n            if input_np[r, c] != 0 and not visited[r, c]:\n\n                # Find the connected component and check its validity\n                component_coords, marker_color, is_valid = find_component_and_marker(input_np, r, c, visited)\n\n                # If the component is valid (exactly one marker found)\n                if is_valid:\n                    # Create a set for efficient neighbor checking\n                    component_coords_set = set(component_coords)\n\n                    # Iterate through all pixels identified as part of this valid component\n                    for (br, bc) in component_coords:\n                        # We only modify blue pixels\n                        if input_np[br, bc] == 1:\n                            # Check if the blue pixel is an interior pixel based on the new definition\n                            if is_interior(input_np.shape, br, bc, component_coords_set):\n                                # Change the color of this interior blue pixel in the output grid\n                                output_np[br, bc] = marker_color\n                \n                # Pixels in invalid components are already marked visited by find_component_and_marker\n                # and require no color changes based on the rules.\n                # White pixels are skipped by the initial check.\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14179,
    "candidates_token_count": 1849,
    "total_token_count": 16028,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.275221,
  "retries": null
}