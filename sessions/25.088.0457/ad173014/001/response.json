{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify all hollow rectangular frames made of red (2) pixels in the input grid.\n2. For each red frame, identify the single non-red, non-white color present inside it (the 'pattern color') and the coordinates of all pixels forming this pattern.\n3. Order the identified frames based on their top-left corner coordinates (row first, then column).\n4. Determine the total number of frames, N.\n5. Create a mapping for pattern colors based on N:\n    - If N=3: The 1st frame's pattern area gets the 2nd frame's original pattern color. The 2nd gets the 3rd's color. The 3rd gets the 1st's color.\n    - If N=4: The 1st frame's pattern area gets the 3rd frame's original pattern color. The 2nd gets the 1st's color. The 3rd gets the 4th's color. The 4th gets the 2nd's color.\n    - Assume other values of N might have specific permutations if encountered.\n6. Construct the output grid by copying the input grid, then overwriting the pattern pixels within each frame using the new color determined by the permutation mapping.\n\"\"\"\n\ndef _find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals for connectivity)\n                    # Although frames are orthogonal, connectivity check is safer with 8\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                if component_pixels: # Should always be true here\n                     components.append({\n                         'pixels': component_pixels,\n                         'min_r': min_r,\n                         'min_c': min_c,\n                         'max_r': max_r,\n                         'max_c': max_c\n                     })\n    return components\n\ndef _find_pattern_in_container(grid, container_info):\n    \"\"\"Finds the pattern color and coordinates within a container's bounds.\"\"\"\n    min_r, min_c = container_info['min_r'], container_info['min_c']\n    max_r, max_c = container_info['max_r'], container_info['max_c']\n    \n    pattern_color = None\n    pattern_coords = []\n\n    # Scan the interior of the bounding box\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            pixel_color = grid[r, c]\n            # Pattern color is not background (0) and not frame (2)\n            if pixel_color != 0 and pixel_color != 2: \n                if pattern_color is None:\n                    pattern_color = pixel_color\n                # Assuming only one pattern color per container\n                if pixel_color == pattern_color:\n                    pattern_coords.append((r, c))\n                else:\n                    # Handle potential error: multiple non-frame/bg colors inside?\n                    # For now, stick to the first one found.\n                    pass \n                    \n    if pattern_color is not None:\n        return pattern_color, pattern_coords\n    else:\n        return None, []\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color swapping transformation based on red rectangular containers.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Find all red (2) components (potential containers)\n    red_components = _find_connected_components(input_grid, 2)\n\n    containers = []\n    # 2. For each component, find its pattern\n    for comp in red_components:\n        # Basic check: A container must have an inside area\n        if comp['max_r'] > comp['min_r'] + 1 and comp['max_c'] > comp['min_c'] + 1:\n            pattern_color, pattern_coords = _find_pattern_in_container(input_grid, comp)\n            # Only consider components that actually contain a pattern\n            if pattern_color is not None and pattern_coords:\n                 containers.append({\n                     'min_r': comp['min_r'],\n                     'min_c': comp['min_c'],\n                     'pattern_color': pattern_color,\n                     'pattern_coords': pattern_coords\n                 })\n\n    # If no valid containers with patterns found, return original grid\n    if not containers:\n        return output_grid\n\n    # 3. Order containers by top-left corner (row, then col)\n    containers.sort(key=lambda c: (c['min_r'], c['min_c']))\n\n    # 4. Determine N and the color permutation\n    N = len(containers)\n    original_colors = [c['pattern_color'] for c in containers]\n    new_colors = [0] * N # Initialize with a placeholder\n\n    if N == 3:\n        # 1 gets color of 2, 2 gets color of 3, 3 gets color of 1\n        # Indices: 0->1, 1->2, 2->0\n        new_colors[0] = original_colors[1]\n        new_colors[1] = original_colors[2]\n        new_colors[2] = original_colors[0]\n    elif N == 4:\n        # 1 gets color of 3, 2 gets color of 1, 3 gets color of 4, 4 gets color of 2\n        # Indices: 0->2, 1->0, 2->3, 3->1\n        new_colors[0] = original_colors[2]\n        new_colors[1] = original_colors[0]\n        new_colors[2] = original_colors[3]\n        new_colors[3] = original_colors[1]\n    else:\n        # If N is not 3 or 4, return the original grid as permutation is unknown\n        # Or potentially handle other cases if more examples were provided\n        # For now, just copy original colors if N is not 3 or 4\n         print(f\"Warning: Unhandled number of containers (N={N}). Returning input.\")\n         return output_grid # Or could return original_colors if no swap needed\n\n    # 5. Construct Output Grid\n    # Iterate through the *ordered* containers and apply the *new* colors\n    for i in range(N):\n        container = containers[i]\n        new_color = new_colors[i]\n        pattern_coords = container['pattern_coords']\n        \n        # Update the output grid at the pattern coordinates with the new color\n        for r, c in pattern_coords:\n             # Safety check for coordinates being within bounds (should always be)\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_grid[r, c] = new_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 7316,
            "end_index": 7651,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9412,
    "candidates_token_count": 1925,
    "total_token_count": 11337,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.682345,
  "retries": null
}