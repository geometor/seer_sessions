
## train_1

**input:**
```
1 1 0 3 3 0 2 2 0 5 5 5 0 5 5 5 0 5 5 5
1 1 0 3 3 0 2 2 0 5 0 5 0 0 5 0 0 5 0 0
0 0 0 0 0 0 0 0 0 5 5 5 0 5 5 5 0 5 5 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 3 2 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 3 1 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 1 3 2 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
1 0 1 2 0 0 0 3 0 1 0 1 2 0 0
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
2 0 0 1 0 1 0 3 0 2 0 0 1 0 1
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 3 0 0 3 0 0 3 0 0 3 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
1 0 1 2 0 0 0 3 0 1 0 1 2 0 0
1 1 1 2 2 2 3 3 3 1 1 1 2 2 2
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
2 0 0 1 0 1 0 3 0 2 0 0 1 0 1
2 2 2 1 1 1 3 3 3 2 2 2 1 1 1
```


## train_2

**input:**
```
2 2 0 4 4 0 5 5 5 5 5 0 5 5 5 5 5
2 2 0 4 4 0 5 0 0 0 0 0 5 0 0 0 5
0 0 0 0 0 0 5 0 5 5 5 0 5 0 5 5 5
0 0 0 0 0 0 5 0 0 0 0 0 5 0 5 5 0
0 0 0 0 0 0 5 5 5 5 5 0 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 2 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 2 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
4 4 4 4 4 2 2 2 2 2 4 4 4 4 4 2 2 2 2 2
4 0 0 0 4 2 0 0 0 0 4 0 0 0 4 2 0 0 0 0
4 0 4 4 4 2 0 2 2 2 4 0 4 4 4 2 0 2 2 2
4 0 4 4 0 2 0 0 0 0 4 0 4 4 0 2 0 0 0 0
4 4 4 0 0 2 2 2 2 2 4 4 4 0 0 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 2 2 2 2 2
2 0 0 0 0 2 0 0 0 0 4 0 0 0 4 2 0 0 0 0
2 0 2 2 2 2 0 2 2 2 4 0 4 4 4 2 0 2 2 2
2 0 0 0 0 2 0 0 0 0 4 0 4 4 0 2 0 0 0 0
2 2 2 2 2 2 2 2 2 2 4 4 4 0 0 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2
4 0 0 0 4 4 0 0 0 4 4 0 0 0 4 2 0 0 0 0
4 0 4 4 4 4 0 4 4 4 4 0 4 4 4 2 0 2 2 2
4 0 4 4 0 4 0 4 4 0 4 0 4 4 0 2 0 0 0 0
4 4 4 0 0 4 4 4 0 0 4 4 4 0 0 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0
2 0 2 2 2 2 0 2 2 2 2 0 2 2 2 2 0 2 2 2
2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
8 8 0 1 1 0 5 5 5 5 5 0 5 5 5 5 5
8 8 0 1 1 0 5 0 0 0 5 0 5 0 0 0 5
0 0 0 0 0 0 5 0 5 0 5 0 5 0 5 0 5
0 0 0 0 0 0 5 0 5 5 5 0 5 5 5 0 5
0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 8 1 8 1 8 1 0 0 0 0 0 0 0 0 0
0 0 1 8 1 8 1 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1
8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1
8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1
8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1
8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1
1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8 1 1 1 1 1 8 8 8 8 8
1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8 1 0 0 0 1 8 0 0 0 8
1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8 1 0 1 0 1 8 0 8 0 8
1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8 1 1 1 0 1 8 0 8 8 8
0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 1 8 0 0 0 0
```

Okay, let's break down the transformation logic for this task.

## Perception of Elements

1.  **Input Structure:** The input grid generally contains three distinct regions, typically separated by white space:
    *   **Solid Prototypes:** Small (consistently 2x2) solid squares of various colors (e.g., blue, green, red in `train_1`; red, yellow in `train_2`; azure, blue in `train_3`). These seem to define basic color units.
    *   **Hollow Prototypes:** Larger squares (3x3 in `train_1`, 5x5 in `train_2` and `train_3`) that are hollow (outer border of one color, inner area is white). The color seems less important than the *size* of these shapes.
    *   **Template Grid:** A rectangular grid composed of colors that correspond to the colors of the *solid prototypes*. This grid acts as a blueprint for the output.

2.  **Output Structure:** The output grid is a larger grid constructed by tiling blocks. The size and color of these blocks are determined by the elements found in the input grid.

3.  **Transformation:**
    *   The size (N) of the *hollow prototype* squares in the input determines the size (NxN) of the building blocks used to construct the output grid.
    *   The *solid prototype* 2x2 squares in the input define a mapping: the color (C) of a solid 2x2 square maps to a solid NxN block of that same color (C) in the output.
    *   The *template grid* dictates the arrangement of these NxN blocks in the output. Each cell in the template grid corresponds to one NxN block in the output grid. The color of the template cell specifies which color's NxN block to place.
    *   The output grid's dimensions are (Template Height * N) x (Template Width * N).

4.  **Example Walkthrough (train_1):**
    *   Hollow prototypes are 3x3 (gray). So, N=3. Output blocks will be 3x3.
    *   Solid prototypes are blue (1), green (3), red (2), all 2x2. Mappings: 1 -> solid blue 3x3, 3 -> solid green 3x3, 2 -> solid red 3x3.
    *   Template grid is 5x5, using colors 1, 2, 3.
    *   Output grid is (5*3)x(5*3) = 15x15.
    *   The top-left cell of the template is blue (1). Place a solid blue 3x3 block at (0,0) in the output.
    *   The next cell in the template's first row is red (2). Place a solid red 3x3 block at (0,3) in the output.
    *   Continue this process for all cells in the template grid.

## Facts


```yaml
task_type: pattern_tiling
input_elements:
  - element: solid_prototypes
    description: Solid 2x2 squares of a specific color. Define color mappings.
    properties:
      - color: C (variable)
      - size: 2x2
  - element: hollow_prototypes
    description: Hollow squares (border of one color, white interior). Define output block size.
    properties:
      - size: NxN (N varies per task, e.g., 3 or 5)
      - structure: hollow
  - element: template_grid
    description: A rectangular grid of colors corresponding to solid prototype colors. Defines the layout of the output.
    properties:
      - dimensions: HxW (variable)
      - cell_colors: Match colors of solid_prototypes

transformation_rules:
  - rule: determine_output_block_size
    input: hollow_prototypes
    output_property: N (size dimension)
    logic: N is the dimension of the hollow squares (e.g., if 3x3, N=3).
  - rule: define_color_mappings
    input: solid_prototypes
    output_property: color_map (map from input color C to output block)
    logic: Each solid prototype color C maps to a solid NxN block of color C, where N is determined by the hollow_prototypes.
  - rule: construct_output_grid
    inputs:
      - template_grid (H x W)
      - color_map
      - N (output block size)
    output: final_output_grid
    logic:
      1. Create an empty output grid of size (H * N) x (W * N).
      2. Iterate through template_grid at row `r`, column `c` (0 <= r < H, 0 <= c < W).
      3. Get template color K = template_grid[r][c].
      4. Get the corresponding NxN output block from color_map[K].
      5. Place this NxN block into the output grid starting at position (r * N, c * N).

output_elements:
  - element: tiled_grid
    description: The final output grid constructed by tiling NxN blocks.
    properties:
      - dimensions: (H * N) x (W * N)
      - structure: Composed of NxN blocks arranged according to the template_grid.
      - block_type: Solid NxN squares.
      - block_colors: Determined by template_grid colors and solid_prototype mappings.
```


## Natural Language Program

1.  **Analyze Input Shapes:**
    *   Identify all distinct hollow square shapes in the input grid (shapes with a non-white border and a white interior). Determine their size, N x N. Store the value of N.
    *   Identify all distinct solid 2x2 square shapes in the input grid. For each unique color `C` found in these 2x2 squares, create a mapping rule: `Input Color C` corresponds to `Output Block Type: Solid NxN of Color C`.

2.  **Locate Template Grid:**
    *   Identify the rectangular region in the input grid that serves as the template. This region consists of colors found among the solid 2x2 prototypes and is typically located in a distinct area (e.g., lower-left, middle-left). Determine its height `H` and width `W`.

3.  **Construct Output Grid:**
    *   Initialize a new grid (the output grid) with dimensions `(H * N)` rows and `(W * N)` columns, filled with the background color (white, 0).
    *   Iterate through each cell of the template grid, from row `r = 0` to `H-1` and column `c = 0` to `W-1`.
    *   For each cell `(r, c)` in the template grid, get its color `K`.
    *   Look up the mapping rule for color `K` established in Step 1. This gives you the `Solid NxN block of Color K`.
    *   Copy this `NxN` block into the output grid, positioning its top-left corner at `(r * N, c * N)`.

4.  **Finalize:** Return the fully constructed output grid.
