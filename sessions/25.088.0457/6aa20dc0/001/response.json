{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies three distinct non-background objects in the input grid. \nOne object acts as a 'key', and the other two act as 'targets'. \nThe 'key' object is identified as the one containing a color not present in either of the 'target' objects. \nThe 'fill color' is this unique color from the 'key' object.\nA bounding box is determined that minimally encloses both 'target' objects.\nThe output grid is generated by filling all background-colored pixels within this bounding box with the 'fill color'. \nThe original objects (key and targets) remain unchanged in their positions.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds connected components of non-background colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_pixels = set()\n                obj_colors = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    obj_colors.add(grid[row, col])\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != background_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels, 'colors': obj_colors})\n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, max_r, min_c, max_c\n\ndef classify_objects_and_find_fill_color(objects):\n    \"\"\"\n    Classifies objects into key and targets and determines the fill color.\n    The key object has a color not present in the other two.\n    The fill color is that unique color.\n    Assumes exactly 3 objects based on examples.\n    \"\"\"\n    if len(objects) != 3:\n        # Handle cases differently if needed, but examples show 3\n        print(f\"Warning: Expected 3 objects, found {len(objects)}\")\n        # Basic fallback or error handling could go here.\n        # For now, let's try to proceed assuming the logic might still apply or \n        # return None if it definitely won't work.\n        if len(objects) < 3: return None, None, None \n        # If more than 3, maybe try combinations? Sticking to 3 for now.\n\n    obj_colors = [o['colors'] for o in objects]\n\n    for i in range(3):\n        key_candidate_idx = i\n        target_indices = [j for j in range(3) if j != i]\n        \n        key_colors = obj_colors[key_candidate_idx]\n        target1_colors = obj_colors[target_indices[0]]\n        target2_colors = obj_colors[target_indices[1]]\n        \n        # Find colors in key_candidate not in either target\n        unique_key_colors = key_colors - target1_colors - target2_colors\n        \n        if len(unique_key_colors) == 1:\n            fill_color = list(unique_key_colors)[0]\n            key_object = objects[key_candidate_idx]\n            target1 = objects[target_indices[0]]\n            target2 = objects[target_indices[1]]\n            return key_object, target1, target2, fill_color\n            \n    # If no unique key configuration found\n    print(\"Warning: Could not uniquely identify key object based on color rule.\")\n    return None, None, None, None \n\ndef calculate_combined_bounding_box(box1, box2):\n    \"\"\"Calculates the minimal bounding box enclosing two bounding boxes.\"\"\"\n    min_r = min(box1[0], box2[0])\n    max_r = max(box1[1], box2[1])\n    min_c = min(box1[2], box2[2])\n    max_c = max(box1[3], box2[3])\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying key and target objects, determining\n    a fill color from the key, calculating the bounding box of the targets,\n    and filling the background within that box with the fill color.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    \n    # 1. Determine the background color\n    counts = Counter(input_grid.flatten())\n    background_color = counts.most_common(1)[0][0]\n    \n    # 2. Identify all distinct objects\n    objects = find_objects(input_grid, background_color)\n    \n    # Add bounding box info to each object\n    for obj in objects:\n        obj['bbox'] = get_bounding_box(obj['pixels'])\n\n    # 3. Distinguish key and target objects and determine fill color\n    key_object, target1, target2, fill_color = classify_objects_and_find_fill_color(objects)\n\n    if fill_color is None or target1 is None or target2 is None:\n         # Handle cases where classification failed - perhaps return input?\n         print(\"Error: Failed to classify objects or find fill color.\")\n         return input_grid.tolist() # Or raise an error\n\n    # 4. Calculate the combined bounding box for target objects\n    bbox1 = target1['bbox']\n    bbox2 = target2['bbox']\n    combined_bb = calculate_combined_bounding_box(bbox1, bbox2)\n    min_r, max_r, min_c, max_c = combined_bb\n\n    # 5. Create the output grid (copy of input)\n    output_grid = np.copy(input_grid)\n\n    # 6. Fill background pixels within the combined bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check if the pixel in the *original* grid is background\n            if input_grid[r, c] == background_color:\n                # Change the pixel in the *output* grid\n                output_grid[r, c] = fill_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7549,
    "candidates_token_count": 1692,
    "total_token_count": 9241,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.450196,
  "retries": null
}