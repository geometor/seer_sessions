{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms the input grid by finding specific 3x3 patterns (\"stamps\") and using them to \"paint\" adjacent areas that are either the background color or the same color as the stamp's center.\n\n1.  **Analyze Input:**\n    *   Determine the background color (C_bg) by finding the most frequent color in the input grid.\n\n2.  **Find Stamps:**\n    *   Scan the input grid for 3x3 subgrids.\n    *   A valid \"stamp\" is a 3x3 subgrid with:\n        *   A uniform border color (C_frame).\n        *   A single center pixel color (C_center).\n        *   The border color C_frame must *not* be the background color C_bg.\n    *   Store each found stamp's 3x3 grid, its center color (C_center), and its top-left position (r_stamp, c_stamp).\n\n3.  **Identify Target Pixels for Each Stamp:**\n    *   Initialize the output grid as a copy of the input grid.\n    *   Keep track of pixels that have been modified using a set `modified_pixels`.\n    *   For each identified stamp S located at (r_stamp, c_stamp) with center color C_center:\n        *   Define the 3x3 bounding box coordinates of the stamp: `stamp_coords = {(r, c) for r in range(r_stamp, r_stamp+3) for c in range(c_stamp, c_stamp+3)}`.\n        *   Find all adjacent pixel coordinates (8-connectivity, including diagonals) to any pixel within `stamp_coords`.\n        *   Filter these adjacent coordinates to find the `target_pixels` for this stamp:\n            *   A pixel (r, c) is a target if it's adjacent to the stamp AND its color in the *input* grid is either the background color (C_bg) OR the stamp's center color (C_center).\n\n4.  **Apply Stamp Pattern (Tiling):**\n    *   For each stamp S and its corresponding `target_pixels`:\n        *   Iterate through each target pixel coordinate (r, c) in `target_pixels`.\n        *   Check if (r, c) is already in the `modified_pixels` set. If yes, skip to the next target pixel (first modification wins).\n        *   Calculate the corresponding indices within the stamp's 3x3 grid using modulo arithmetic relative to the *stamp's* top-left corner:\n            *   `stamp_r_idx = (r - r_stamp) % 3`\n            *   `stamp_c_idx = (c - c_stamp) % 3`\n        *   Update the `output_grid` at position (r, c) with the color from the stamp's grid: `output_grid[r, c] = stamp_grid[stamp_r_idx, stamp_c_idx]`.\n        *   Add the coordinate (r, c) to the `modified_pixels` set.\n\n5.  **Finalize:**\n    *   Return the `output_grid`. Pixels that were not target pixels for any stamp remain unchanged from their original input color.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid or single color case\n    if not counts:\n        return 0 # Default to black/white if grid is empty\n    # If multiple colors have the same max count, the specific choice might matter,\n    # but usually, the background is overwhelmingly dominant. np.unique handles ties arbitrarily.\n    colors, freqs = np.unique(grid, return_counts=True)\n    return colors[np.argmax(freqs)]\n\ndef find_stamps(grid, background_color):\n    \"\"\"\n    Finds 3x3 stamp patterns with a uniform border color different from the background\n    and a single center color.\n    \"\"\"\n    stamps_info = []\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid[r:r+3, c:c+3]\n\n            # Check for uniform border\n            frame_color = subgrid[0, 0]\n            is_uniform_border = True\n            # Check top and bottom rows\n            if not (np.all(subgrid[0, :] == frame_color) and np.all(subgrid[2, :] == frame_color)):\n                is_uniform_border = False\n            # Check middle row sides\n            if not (subgrid[1, 0] == frame_color and subgrid[1, 2] == frame_color):\n                is_uniform_border = False\n\n            if is_uniform_border:\n                # Check if frame color is not the background color\n                if frame_color != background_color:\n                    center_color = subgrid[1, 1]\n                    stamps_info.append({\n                        'grid': subgrid.copy(),\n                        'frame_color': frame_color,\n                        'center_color': center_color,\n                        'row': r,\n                        'col': c\n                    })\n    return stamps_info\n\ndef get_adjacent_pixels(grid_shape, coords_set):\n    \"\"\"\n    Finds all unique pixels adjacent (8-connectivity) to any pixel in coords_set,\n    excluding pixels within coords_set itself.\n    \"\"\"\n    height, width = grid_shape\n    adjacent = set()\n    for r_orig, c_orig in coords_set:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r_orig + dr, c_orig + dc\n                # Check bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    neighbor_coord = (nr, nc)\n                    # Add if not part of the original set\n                    if neighbor_coord not in coords_set:\n                        adjacent.add(neighbor_coord)\n    return adjacent\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the stamp tiling transformation based on adjacency and color rules.\n    \"\"\"\n    height, width = input_grid.shape\n\n    # 1. Analyze Input: Find background color\n    background_color = find_background_color(input_grid)\n\n    # 2. Find Stamps: Identify relevant 3x3 patterns\n    stamps = find_stamps(input_grid, background_color)\n\n    # Initialize output grid and track modified pixels\n    output_grid = np.copy(input_grid)\n    modified_pixels = set()\n\n    # 3 & 4. Identify Targets & Apply Tiling for each stamp\n    for stamp in stamps:\n        stamp_grid = stamp['grid']\n        stamp_center_color = stamp['center_color']\n        r_stamp, c_stamp = stamp['row'], stamp['col']\n\n        # Define the stamp's own coordinates\n        stamp_coords = set()\n        for r_offset in range(3):\n            for c_offset in range(3):\n                 # Ensure stamp coords are within grid bounds (redundant check if find_stamps is correct)\n                 curr_r, curr_c = r_stamp + r_offset, c_stamp + c_offset\n                 if 0 <= curr_r < height and 0 <= curr_c < width:\n                    stamp_coords.add((curr_r, curr_c))\n\n\n        # Find pixels adjacent to the stamp\n        pixels_near_stamp = get_adjacent_pixels((height, width), stamp_coords)\n\n        # Filter adjacent pixels to find target pixels\n        target_pixels = set()\n        for r, c in pixels_near_stamp:\n             pixel_color = input_grid[r, c]\n             # Check color condition: pixel is background OR matches stamp center\n             if pixel_color == background_color or pixel_color == stamp_center_color:\n                 target_pixels.add((r,c))\n\n        # Apply tiling to target pixels\n        for r, c in target_pixels:\n            # Apply modification only if pixel hasn't been modified yet\n            if (r, c) not in modified_pixels:\n                # Calculate stamp indices using modulo relative to stamp's top-left\n                stamp_r_idx = (r - r_stamp) % 3\n                stamp_c_idx = (c - c_stamp) % 3\n\n                # Update the output grid\n                output_grid[r, c] = stamp_grid[stamp_r_idx, stamp_c_idx]\n                modified_pixels.add((r, c)) # Mark pixel as modified\n\n    # 5. Finalize\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11049,
    "candidates_token_count": 2040,
    "total_token_count": 13089,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.338114,
  "retries": null
}