{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms the input grid by finding specific 3x3 patterns (\"stamps\") and using them to flood-fill adjacent areas.\n\n1.  **Analyze Input:**\n    *   Determine the background color (C_bg) by finding the most frequent color in the input grid.\n\n2.  **Find Stamps:**\n    *   Scan the input grid for 3x3 subgrids.\n    *   A valid \"stamp\" is a 3x3 subgrid with:\n        *   A uniform border color (C_frame).\n        *   A single center pixel color (C_center).\n        *   The border color C_frame must *not* be the background color C_bg.\n    *   Store each found stamp's 3x3 grid, its center color (C_center), frame color (C_frame), and its top-left position (r_stamp, c_stamp).\n\n3.  **Identify Target Regions and Apply Stamp Pattern (Flood Fill & Tiling):**\n    *   Initialize the output grid as a copy of the input grid.\n    *   Keep track of pixels that have been modified globally using a set `modified_pixels`.\n    *   For each identified stamp S located at (r_stamp, c_stamp) with center color C_center and its 3x3 pattern `stamp_grid`:\n        *   Identify the coordinates occupied by the stamp itself: `stamp_coords`.\n        *   Find initial \"seed\" pixels: These are pixels directly adjacent (8-connectivity) to `stamp_coords`.\n        *   Filter seeds: Keep only seed pixels (r, c) where the color `input_grid[r, c]` is either the background color (C_bg) OR the stamp's center color (C_center).\n        *   Perform a flood fill (BFS) starting from these filtered seed pixels:\n            *   Use a queue and a `visited_fill` set (specific to this stamp's fill) to manage the search.\n            *   The fill expands to adjacent pixels (nr, nc) if:\n                *   (nr, nc) is within grid bounds.\n                *   (nr, nc) has not been visited *during this specific fill*.\n                *   The color `input_grid[nr, nc]` is either C_bg OR C_center.\n            *   Collect all pixels visited during the flood fill into a set `region_to_fill`.\n        *   Apply the stamp pattern to the `region_to_fill`:\n            *   Iterate through each pixel coordinate (r, c) in `region_to_fill`.\n            *   Check if (r, c) is already in the global `modified_pixels` set. If yes, skip (first modification wins).\n            *   Calculate the corresponding indices within the stamp's 3x3 grid using modulo arithmetic relative to the stamp's top-left corner:\n                *   `stamp_r_idx = (r - r_stamp) % 3`\n                *   `stamp_c_idx = (c - c_stamp) % 3`\n            *   Update the `output_grid` at position (r, c) with the color from the stamp's pattern: `output_grid[r, c] = stamp_grid[stamp_r_idx, stamp_c_idx]`.\n            *   Add the coordinate (r, c) to the global `modified_pixels` set.\n\n4.  **Finalize:**\n    *   Return the `output_grid`. Pixels not part of any filled region remain unchanged from their original input color.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    if not colors.size:\n        return 0 # Default for empty grid\n    return colors[np.argmax(counts)]\n\ndef find_stamps(grid, background_color):\n    \"\"\"\n    Finds 3x3 stamp patterns with a uniform border color different from the background.\n    Returns a list of dictionaries, each containing stamp info.\n    \"\"\"\n    stamps_info = []\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid[r:r+3, c:c+3]\n            frame_color = subgrid[0, 0]\n            \n            # Check if frame color is the background\n            if frame_color == background_color:\n                continue\n\n            # Check for uniform border more robustly\n            border_coords = [\n                (0, 0), (0, 1), (0, 2),\n                (1, 0),         (1, 2),\n                (2, 0), (2, 1), (2, 2)\n            ]\n            is_uniform_border = all(subgrid[br, bc] == frame_color for br, bc in border_coords)\n\n            if is_uniform_border:\n                center_color = subgrid[1, 1]\n                stamps_info.append({\n                    'grid': subgrid.copy(),\n                    'frame_color': frame_color,\n                    'center_color': center_color,\n                    'row': r,\n                    'col': c\n                })\n    return stamps_info\n\ndef flood_fill_region(grid, start_coords, fill_colors, stamp_coords):\n    \"\"\"\n    Performs a flood fill (BFS) starting from start_coords.\n    Fills regions where pixels have one of the fill_colors.\n    Does not fill pixels within the stamp_coords itself.\n    Returns the set of coordinates belonging to the filled region.\n    \"\"\"\n    height, width = grid.shape\n    q = deque(list(start_coords)) # Use list to ensure iteration order if needed, though set is fine for queue\n    visited_fill = set(start_coords)\n    region_coords = set(start_coords)\n\n    while q:\n        r, c = q.popleft()\n\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n\n                # Check bounds\n                if not (0 <= nr < height and 0 <= nc < width):\n                    continue\n                \n                neighbor_coord = (nr, nc)\n\n                # Check if already visited in this fill or part of the stamp\n                if neighbor_coord in visited_fill or neighbor_coord in stamp_coords:\n                    continue\n\n                # Check if neighbor has a valid fill color\n                if grid[nr, nc] in fill_colors:\n                    visited_fill.add(neighbor_coord)\n                    q.append(neighbor_coord)\n                    region_coords.add(neighbor_coord)\n\n    return region_coords\n\n\ndef get_adjacent_pixels(grid_shape, coords_set):\n    \"\"\"\n    Finds all unique pixels adjacent (8-connectivity) to any pixel in coords_set,\n    excluding pixels within coords_set itself. Used to find initial seeds.\n    \"\"\"\n    height, width = grid_shape\n    adjacent = set()\n    for r_orig, c_orig in coords_set:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r_orig + dr, c_orig + dc\n                # Check bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    neighbor_coord = (nr, nc)\n                    # Add if not part of the original set\n                    if neighbor_coord not in coords_set:\n                        adjacent.add(neighbor_coord)\n    return adjacent\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the stamp-based flood fill and tiling transformation.\n    \"\"\"\n    height, width = input_grid.shape\n    output_grid = np.copy(input_grid)\n    \n    # 1. Analyze Input: Find background color\n    background_color = find_background_color(input_grid)\n\n    # 2. Find Stamps\n    stamps = find_stamps(input_grid, background_color)\n\n    # 3. Identify Target Regions and Apply Stamp Pattern\n    modified_pixels = set() # Track globally modified pixels\n\n    for stamp in stamps:\n        stamp_grid = stamp['grid']\n        stamp_center_color = stamp['center_color']\n        r_stamp, c_stamp = stamp['row'], stamp['col']\n\n        # Define the stamp's own coordinates\n        stamp_coords = set()\n        for r_offset in range(3):\n            for c_offset in range(3):\n                 stamp_coords.add((r_stamp + r_offset, c_stamp + c_offset))\n\n        # Define the colors that can be filled by this stamp\n        fillable_colors = {background_color, stamp_center_color}\n\n        # Find initial seed pixels adjacent to the stamp\n        initial_adjacent = get_adjacent_pixels((height, width), stamp_coords)\n\n        # Filter seeds: must be a fillable color and not already modified\n        seed_pixels = set()\n        for r, c in initial_adjacent:\n            # Check if the pixel has a fillable color in the *original* grid\n            # And ensure it wasn't modified by a *previous* stamp's fill\n            if input_grid[r, c] in fillable_colors and (r, c) not in modified_pixels:\n                 seed_pixels.add((r, c))\n        \n        # If no valid seeds, continue to the next stamp\n        if not seed_pixels:\n            continue\n\n        # Perform flood fill starting from seed pixels\n        # The fill propagates based on original grid colors, ignoring the stamp area itself\n        region_to_fill = flood_fill_region(input_grid, seed_pixels, fillable_colors, stamp_coords)\n        \n        # Apply tiling to the identified region\n        for r, c in region_to_fill:\n            # Check if already modified by another stamp (first modification wins)\n            if (r, c) not in modified_pixels:\n                # Calculate stamp indices using modulo relative to stamp's top-left\n                stamp_r_idx = (r - r_stamp) % 3\n                stamp_c_idx = (c - c_stamp) % 3\n\n                # Update the output grid\n                output_grid[r, c] = stamp_grid[stamp_r_idx, stamp_c_idx]\n                modified_pixels.add((r, c)) # Mark pixel as globally modified\n\n    # 4. Finalize\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10954,
    "candidates_token_count": 2481,
    "total_token_count": 13435,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.057785,
  "retries": null
}