{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by finding specific 3x3 patterns and using them to tile adjacent contiguous areas.\n\n1.  **Analyze Input:** Determine the background color (C_bg) by finding the most frequent color in the input grid.\n2.  **Find Patterns:** Scan the input grid to identify all 3x3 subgrids that have a perfectly uniform border of color C_frame and a single center pixel of color C_center. Crucially, the frame color C_frame must *not* be the background color (C_bg). Store each valid pattern's 3x3 grid, its C_frame, its C_center, and its top-left location (r_pat, c_pat).\n3.  **Find Areas:** Identify all contiguous areas of single colors in the input grid using 4-connectivity. For each area, record its color (C_area), the set of pixel coordinates it occupies, its bounding box (min/max row and column), and whether its color is the background color (C_area == C_bg).\n4.  **Identify Targets & Apply Tiling:** Create a copy of the input grid to serve as the output grid. Keep track of pixels that have already been modified. Iterate through each identified pattern P. For pattern P, iterate through all identified contiguous areas A. Check if area A is adjacent (sharing an edge or corner) to the 3x3 bounding box of pattern P. If area A is adjacent, check if its color C_area meets the condition: `C_area == C_center` (matches pattern's center) OR `C_area == C_bg` (is a background area). If both adjacency and color conditions are met, use pattern P's 3x3 grid to fill the pixels belonging to area A in the output grid. The filling uses modulo arithmetic based on the area's top-left corner, ensuring the pattern tiles correctly. Only modify pixels that haven't been modified already by another pattern in this process.\n5.  **Finalize:** Return the modified output grid. Pixels not part of any target area remain unchanged from the input grid.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_patterns(grid, background_color):\n    \"\"\"\n    Finds 3x3 patterns with a uniform border color different from the background\n    and a single center color.\n    \"\"\"\n    patterns_info = []\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid[r:r+3, c:c+3]\n            \n            # Check for uniform border\n            frame_color = subgrid[0, 0]\n            is_uniform_border = True\n            for i in range(3): # Top row\n                if subgrid[0, i] != frame_color: is_uniform_border = False; break\n            if not is_uniform_border: continue\n            for i in range(3): # Bottom row\n                if subgrid[2, i] != frame_color: is_uniform_border = False; break\n            if not is_uniform_border: continue\n            # Check middle row sides (center checked separately)\n            if subgrid[1, 0] != frame_color or subgrid[1, 2] != frame_color:\n                is_uniform_border = False\n            \n            if is_uniform_border:\n                # Check if frame color is not the background color\n                if frame_color != background_color:\n                    center_color = subgrid[1, 1]\n                    patterns_info.append({\n                        'grid': subgrid.copy(),\n                        'frame_color': frame_color,\n                        'center_color': center_color,\n                        'row': r,\n                        'col': c\n                    })\n    return patterns_info\n\ndef find_contiguous_areas(grid):\n    \"\"\"\n    Finds all contiguous areas of the same color using BFS (4-connectivity).\n    Returns a list of dictionaries, each describing an area.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    areas = []\n    \n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                queue = deque([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while queue:\n                    row, col = queue.popleft()\n                    \n                    if not (0 <= row < height and 0 <= col < width) or \\\n                       visited[row, col] or \\\n                       grid[row, col] != color:\n                        continue\n                        \n                    visited[row, col] = True\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Add neighbors (4-connectivity)\n                    queue.append((row + 1, col))\n                    queue.append((row - 1, col))\n                    queue.append((row, col + 1))\n                    queue.append((row, col - 1))\n\n                if coords:\n                    areas.append({\n                        'color': color,\n                        'coords': coords,\n                        'min_row': min_r,\n                        'max_row': max_r,\n                        'min_col': min_c,\n                        'max_col': max_c\n                    })\n    return areas\n\ndef is_adjacent(pattern_info, area_info):\n    \"\"\"\n    Checks if any pixel in the area is adjacent (8-connectivity) to any \n    pixel in the pattern's 3x3 bounding box.\n    \"\"\"\n    pattern_r, pattern_c = pattern_info['row'], pattern_info['col']\n    area_coords = area_info['coords']\n\n    # Iterate through all cells within the pattern's 3x3 box\n    for r_offset in range(3):\n        for c_offset in range(3):\n            pr = pattern_r + r_offset\n            pc = pattern_c + c_offset\n            \n            # Check the 8 neighbors of this pattern cell\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue # Skip the cell itself\n                        \n                    nr, nc = pr + dr, pc + dc\n                    \n                    # If a neighbor's coordinate is in the area's set, they are adjacent\n                    if (nr, nc) in area_coords:\n                        return True\n                        \n    return False # No adjacent cell found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern tiling transformation based on adjacency and color rules.\n    \"\"\"\n    # 1. Analyze Input: Find background color\n    background_color = find_background_color(input_grid)\n    \n    # 2. Find Patterns: Identify relevant 3x3 patterns\n    patterns = find_patterns(input_grid, background_color)\n    \n    # If no relevant patterns are found, return the original grid\n    if not patterns:\n        return np.copy(input_grid)\n\n    # 3. Find Areas: Identify all contiguous areas\n    areas = find_contiguous_areas(input_grid)\n\n    # Initialize output grid and track modified pixels\n    output_grid = np.copy(input_grid)\n    modified_pixels = set()\n\n    # 4. Identify Targets & Apply Tiling\n    for pattern in patterns:\n        pattern_grid = pattern['grid']\n        pattern_center_color = pattern['center_color']\n        \n        for area in areas:\n            area_color = area['color']\n            area_coords = area['coords']\n            \n            # Check for adjacency\n            if is_adjacent(pattern, area):\n                # Check color condition: area matches pattern center OR is background\n                if area_color == pattern_center_color or area_color == background_color:\n                    # This is a target area for this pattern\n                    min_row, min_col = area['min_row'], area['min_col']\n                    \n                    # Tile the pattern onto the target area\n                    for r, c in area_coords:\n                        # Apply modification only if pixel hasn't been modified yet\n                        if (r, c) not in modified_pixels:\n                            # Calculate pattern indices using modulo relative to area's top-left\n                            pattern_r_idx = (r - min_row) % 3\n                            pattern_c_idx = (c - min_col) % 3\n                            \n                            # Update the output grid\n                            output_grid[r, c] = pattern_grid[pattern_r_idx, pattern_c_idx]\n                            modified_pixels.add((r, c)) # Mark pixel as modified\n\n    # 5. Finalize\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28472,
    "candidates_token_count": 2142,
    "total_token_count": 30614,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.226286,
  "retries": null
}