{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on identified 3x3 patterns and target areas.\n\nThe transformation involves:\n1. Identifying all distinct 3x3 patterns in the input grid. A pattern typically \n   consists of a border (frame) of one color and a central pixel of another \n   (potentially the same) color.\n2. Storing these patterns, indexed by their frame color.\n3. Identifying all contiguous areas in the input grid filled with a single color.\n4. For each contiguous area whose color matches the frame color of a stored \n   pattern:\n    a. Designate this area as a target area.\n    b. Determine the bounding box of the target area.\n    c. Fill the target area in the output grid by tiling the corresponding \n       3x3 pattern, starting from the top-left corner of the area's \n       bounding box. Only pixels belonging to the original contiguous area \n       are overwritten.\n5. Pixels not part of any modified target area retain their original color from \n   the input grid.\n\"\"\"\n\ndef find_patterns(grid):\n    \"\"\"\n    Scans the grid to find all 3x3 subgrids that represent patterns.\n    A pattern is defined by a uniform border color and a center color.\n    Returns a dictionary mapping frame_color to the 3x3 pattern grid.\n    \"\"\"\n    patterns = {}\n    height, width = grid.shape\n    for r in range(height - 2):\n        for c in range(width - 2):\n            subgrid = grid[r:r+3, c:c+3]\n            # Check if it fits the simple frame + center definition\n            # More robust check: ensure all 8 border pixels are the same.\n            frame_color = subgrid[0, 0]\n            is_pattern = True\n            # Check top/bottom row\n            for i in range(3):\n                if subgrid[0, i] != frame_color or subgrid[2, i] != frame_color:\n                    is_pattern = False\n                    break\n            if not is_pattern: continue\n            # Check middle row sides\n            if subgrid[1, 0] != frame_color or subgrid[1, 2] != frame_color:\n                is_pattern = False\n            \n            if is_pattern:\n                # Store the pattern grid, keyed by its frame color.\n                # If multiple patterns have the same frame color, the last one\n                # found in the scan will be used (consistent with examples).\n                patterns[frame_color] = subgrid.copy()\n                \n    return patterns\n\ndef find_contiguous_areas(grid):\n    \"\"\"\n    Finds all contiguous areas of the same color using BFS.\n    Ignores the most frequent color (assumed background).\n    Returns a list of dictionaries, each describing an area:\n    {'color': int, 'coords': set((r, c)), 'min_row': int, 'max_row': int, 'min_col': int, 'max_col': int}\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    areas = []\n    \n    # Determine background color (most frequent color) to ignore it\n    colors, counts = np.unique(grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                coords = set()\n                queue = deque([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while queue:\n                    row, col = queue.popleft()\n                    \n                    if not (0 <= row < height and 0 <= col < width) or \\\n                       visited[row, col] or \\\n                       grid[row, col] != color:\n                        continue\n                        \n                    visited[row, col] = True\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Add neighbors (4-connectivity)\n                    queue.append((row + 1, col))\n                    queue.append((row - 1, col))\n                    queue.append((row, col + 1))\n                    queue.append((row, col - 1))\n\n                if coords:\n                    areas.append({\n                        'color': color,\n                        'coords': coords,\n                        'min_row': min_r,\n                        'max_row': max_r,\n                        'min_col': min_c,\n                        'max_col': max_c\n                    })\n    return areas\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern tiling transformation to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all 3x3 patterns\n    patterns_by_frame_color = find_patterns(input_grid)\n    \n    # If no patterns are found, return the original grid\n    if not patterns_by_frame_color:\n        return output_grid\n\n    # 2. Find all contiguous areas of non-background colors\n    contiguous_areas = find_contiguous_areas(input_grid)\n\n    # 3. Iterate through areas and apply patterns if color matches a frame_color\n    for area in contiguous_areas:\n        area_color = area['color']\n        \n        # Check if this area's color corresponds to a pattern's frame color\n        if area_color in patterns_by_frame_color:\n            # Get the corresponding 3x3 pattern\n            pattern_grid = patterns_by_frame_color[area_color]\n            \n            # Get area details\n            area_coords = area['coords']\n            min_row, max_row = area['min_row'], area['max_row']\n            min_col, max_col = area['min_col'], area['max_col']\n\n            # 4. Tile the pattern onto the target area in the output grid\n            # Iterate through the bounding box of the area\n            for r in range(min_row, max_row + 1):\n                for c in range(min_col, max_col + 1):\n                    # Only modify pixels that were part of the original contiguous area\n                    if (r, c) in area_coords:\n                        # Calculate relative coordinates within the bounding box\n                        rel_r = r - min_row\n                        rel_c = c - min_col\n                        \n                        # Calculate corresponding indices in the 3x3 pattern grid using modulo\n                        pattern_r = rel_r % 3\n                        pattern_c = rel_c % 3\n                        \n                        # Update the output grid with the pattern pixel color\n                        output_grid[r, c] = pattern_grid[pattern_r, pattern_c]\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7310,
    "candidates_token_count": 1685,
    "total_token_count": 8995,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 112.974701,
  "retries": null
}