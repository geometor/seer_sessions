{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule: Conditional Global Color Replacement based on Color Counts and Adjacency\n\n1.  **Analyze Colors**: Examine the input grid and count the occurrences of each distinct color.\n2.  **Check Color Count**: If there are not exactly three distinct colors in the grid, return the original grid unmodified.\n3.  **Identify Key Colors**:\n    *   Find the `background_color`, which is the color that appears most frequently.\n    *   Identify the two remaining colors (non-background colors).\n    *   Compare the counts of these two remaining colors. The one with the *smaller* count is the `fill_color`. If their counts are equal, the one with the numerically *lower* color value is designated the `fill_color`.\n    *   The color that is neither the `background_color` nor the `fill_color` is the `barrier_color`.\n4.  **Check Initial Adjacency**: Determine if any pixel initially having the `fill_color` is directly adjacent (up, down, left, or right, not diagonally) to any pixel initially having the `background_color` in the input grid.\n5.  **Apply Transformation**:\n    *   **If** the grid had exactly three colors **AND** at least one `fill_color` pixel was adjacent to a `background_color` pixel in the input:\n        *   Create a new grid based on the input.\n        *   Change the color of **every** pixel that had the `background_color` in the original input grid to the `fill_color`.\n        *   Leave all pixels that were originally the `fill_color` or the `barrier_color` unchanged.\n        *   Return the modified grid.\n    *   **Else** (either not exactly three colors OR no initial adjacency between fill and background):\n        *   Return the original input grid unmodified.\n\"\"\"\n\ndef _is_adjacent(grid: np.ndarray, color1: int, color2: int) -> bool:\n    \"\"\"\n    Checks if any pixel of color1 is cardinally adjacent to a pixel of color2.\n    Optimized by only checking neighbors of color1 pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    # Find all coordinates where the grid has color1\n    color1_coords = np.argwhere(grid == color1)\n\n    # Iterate through each coordinate of color1\n    for r, c in color1_coords:\n        # Check cardinal neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor's coordinates are within the grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor pixel has color2\n                if grid[nr, nc] == color2:\n                    return True # Found an adjacent pair\n    # If no adjacent pair is found after checking all color1 pixels and their neighbors\n    return False\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a conditional global color replacement based on color frequencies and adjacency.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Analyze Input Colors: Get unique colors and their counts\n    colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(colors, counts))\n\n    # 2. Check Color Count: Must be exactly 3 colors\n    if len(colors) != 3:\n        # If not exactly 3 colors, return the original grid\n        return input_grid\n\n    # 3. Identify Key Colors\n    # Find background color (most frequent)\n    # np.argmax returns the index of the first maximum in case of ties.\n    background_color_index = np.argmax(counts)\n    background_color = colors[background_color_index]\n\n    # Identify the other two colors and their counts\n    non_background_colors = []\n    non_background_counts = []\n    for color, count in color_counts.items():\n        if color != background_color:\n            non_background_colors.append(color)\n            non_background_counts.append(count)\n\n    # Assign the two non-background colors and counts\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    count1, count2 = non_background_counts[0], non_background_counts[1]\n\n    # Determine fill and barrier colors based on counts\n    # Fill color is the one with the smaller count.\n    # Tie-breaking: If counts are equal, the numerically smaller color value is the fill color.\n    if count1 < count2:\n        fill_color = color1\n        barrier_color = color2\n    elif count2 < count1:\n        fill_color = color2\n        barrier_color = color1\n    else: # Counts are equal, use lower color value as fill color\n        fill_color = min(color1, color2)\n        barrier_color = max(color1, color2)\n\n    # 4. Check Initial Adjacency: Is fill_color adjacent to background_color?\n    # Use the helper function to check adjacency in the original grid\n    is_fill_adjacent_to_background = _is_adjacent(grid, fill_color, background_color)\n\n    # 5. Perform Transformation\n    # Check if the trigger conditions are met: exactly 3 colors AND initial adjacency exists\n    if is_fill_adjacent_to_background:\n        # If conditions met, perform global replacement\n        # Create a copy of the grid to modify\n        output_grid = grid.copy()\n        # Find all pixels that were originally the background color\n        # and change them to the fill color in the output grid.\n        output_grid[grid == background_color] = fill_color\n        # Convert the resulting NumPy array back to a list of lists\n        return output_grid.tolist()\n    else:\n        # If conditions are not met (no initial adjacency), return the original grid\n        return input_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4937,
    "candidates_token_count": 1437,
    "total_token_count": 6374,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.383291,
  "retries": null
}